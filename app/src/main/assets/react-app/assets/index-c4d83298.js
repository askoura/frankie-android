import { _ as _objectWithoutPropertiesLoose, A as getDefaultExportFromCjs, r as reactExports, ax as I18nContext, ay as getDefaults, az as _defineProperty$4, aA as _typeof$2, aB as getI18n, aC as useControlled, au as useIsFocusVisible, X as useForkRef, aD as useEnhancedEffect, aE as useEventCallback, aF as ownerDocument, m as _extends$h, w as useId, aG as setRef, q as generateUtilityClass, n as generateUtilityClasses, t as styled, W as capitalize, v as useThemeProps, j as jsxRuntimeExports, x as clsx, y as composeClasses, c as createSvgIcon, at as alpha, $ as rootShouldForwardProp, av as lighten, aw as darken, aH as slotShouldForwardProp, g as requireCreateSvgIcon, i as interopRequireDefaultExports, b as useSelector, z as commonjsGlobal, aI as reactDomExports, aJ as isGroup, aK as isQuestion, a1 as stripTags, R as React, aL as designStore, aM as changeContent, ab as PublicDraggable, aN as grey, aO as setup, aP as setupOptions, aQ as removeAnswer, aa as ConnectedDroppable, aR as default_1$p, aS as serveyRandomSetup, aT as default_1$r, aU as DesignService, aV as changeResources, aW as onDrag, aX as default_1$s, a0 as useTheme$1, aY as cloneQuestion, aZ as deleteQuestion, a_ as toggleComponentCollapse, a$ as nextId$1, b0 as addNewAnswer, b1 as deleteGroup, b2 as iconByType, b3 as collapseAllGroups, b4 as buildIndex, b5 as isEquivalent, b6 as changeAttribute, b7 as changeValidationValue, b8 as defaultSurveyTheme, b9 as _arrayLikeToArray$8, ba as _iterableToArray, bb as _unsupportedIterableToArray$8, bc as _toArray, bd as hoistStatics, be as _inherits$b, bf as _classCallCheck$b, bg as _assertThisInitialized$1, bh as _createClass$9, bi as _getPrototypeOf$1, bj as _possibleConstructorReturn$b, bk as createStore, C as CircularProgress, bl as default_1$t, al as createTheme, bm as changeRelevance, bn as removeSkipDestination, bo as editSkipDestination, bp as editSkipToEnd, bq as instructionByCode, br as updatePriorityByType, bs as updatePriority, bt as updateRandomByType, bu as updateRandom, bv as setupToggleExpand, u as useNavigate, bw as changeLang, bx as resetSetup, by as NewComponentsPanel, aj as setFetching, bz as newVersionReceived, bA as onErrorSeen, bB as GetData, an as createCache, am as defualtTheme, aq as CacheProvider, a9 as DragDropContext, ao as prefixer, ap as stylisRTLPlugin, bC as designStateReceived, bD as onError } from "./index-71e436dd.js";
import { b as ReactPlayer, C as CardMedia, P as PropTypes, D as DateTimePicker, T as TimePicker, R as RadioGroup, a as Radio, c as ThemeProvider, E as ErrorOutlineOutlined, L as Layout } from "./index-b4d19287.js";
import { w as warnOnce, q as warn$1, t as ButtonBase, v as inputClasses, x as inputBaseClasses, y as outlinedInputClasses, z as filledInputClasses, a as IconButton, P as Paper, C as ClearIcon, E as ArrowDropDownIcon, F as ButtonGroupContext, T as Typography, G as listItemTextClasses, L as ListContext, H as getListItemTextUtilityClass, i as isHostComponent, f as useTheme, J as useSlotProps, K as Grow, N as appendOwnerState, p as TextareaAutosize, B as Box, r as rtlLanguage, b as Button, u as useTranslation, D as Dialog, k as DialogActions, c as Select, d as MenuItem, j as DialogContent, _ as _slicedToArray$1, O as Popover, S as Snackbar, A as Alert } from "./common-acee48c7.js";
import { T as TextField } from "./TextField-e86274a8.js";
import { u as useDispatch } from "./useDispatch-fbef4af9.js";
import { d as default_1$q, C as Collapse, c as classNames, A as Accordion, a as AccordionSummary, b as default_1$v, e as AccordionDetails } from "./index-7c2300c0.js";
import { P as Popper, D as DatePicker, G as Grid, L as LocalizationProvider } from "./DatePicker-8e1ec2f6.js";
import { b as buildResourceUrl } from "./common-ecd0fdbe.js";
import { C as Card } from "./Card-bccd3d70.js";
import { D as DialogTitle, A as AuthService } from "./AuthService-fbd64962.js";
import { S as Switch, d as default_1$u } from "./Delete-b45d46b0.js";
import { F as FormControl, b as FormLabel } from "./InputLabel-7f86409c.js";
import { C as Checkbox } from "./Checkbox-2dc7bcca.js";
import { F as FormControlLabel } from "./FormControlLabel-4e5795b5.js";
import { d as default_1$w } from "./ArrowBack-bb00e58a.js";
import { L as LogoutOutlined } from "./LogoutOutlined-a1c750aa.js";
import "./FormGroup-4b2df1a6.js";
import "./KeyboardArrowRight-44332586.js";
import "./InputAdornment-a92d02a2.js";
function _objectWithoutProperties$2(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var voidElements = {
  "area": true,
  "base": true,
  "br": true,
  "col": true,
  "embed": true,
  "hr": true,
  "img": true,
  "input": true,
  "link": true,
  "meta": true,
  "param": true,
  "source": true,
  "track": true,
  "wbr": true
};
const e$1 = /* @__PURE__ */ getDefaultExportFromCjs(voidElements);
var t = /\s([^'"/\s><]+?)[\s/>]|([^\s=]+)=\s?(".*?"|'.*?')/g;
function n$1(n2) {
  var r2 = { type: "tag", name: "", voidElement: false, attrs: {}, children: [] }, i2 = n2.match(/<\/?([^\s]+?)[/\s>]/);
  if (i2 && (r2.name = i2[1], (e$1[i2[1]] || "/" === n2.charAt(n2.length - 2)) && (r2.voidElement = true), r2.name.startsWith("!--"))) {
    var s2 = n2.indexOf("-->");
    return { type: "comment", comment: -1 !== s2 ? n2.slice(4, s2) : "" };
  }
  for (var a2 = new RegExp(t), c2 = null; null !== (c2 = a2.exec(n2)); )
    if (c2[0].trim())
      if (c2[1]) {
        var o = c2[1].trim(), l2 = [o, ""];
        o.indexOf("=") > -1 && (l2 = o.split("=")), r2.attrs[l2[0]] = l2[1], a2.lastIndex--;
      } else
        c2[2] && (r2.attrs[c2[2]] = c2[3].trim().substring(1, c2[3].length - 1));
  return r2;
}
var r$1 = /<[a-zA-Z0-9\-\!\/](?:"[^"]*"|'[^']*'|[^'">])*>/g, i = /^\s*$/, s = /* @__PURE__ */ Object.create(null);
function a(e2, t2) {
  switch (t2.type) {
    case "text":
      return e2 + t2.content;
    case "tag":
      return e2 += "<" + t2.name + (t2.attrs ? function(e3) {
        var t3 = [];
        for (var n2 in e3)
          t3.push(n2 + '="' + e3[n2] + '"');
        return t3.length ? " " + t3.join(" ") : "";
      }(t2.attrs) : "") + (t2.voidElement ? "/>" : ">"), t2.voidElement ? e2 : e2 + t2.children.reduce(a, "") + "</" + t2.name + ">";
    case "comment":
      return e2 + "<!--" + t2.comment + "-->";
  }
}
var c$1 = { parse: function(e2, t2) {
  t2 || (t2 = {}), t2.components || (t2.components = s);
  var a2, c2 = [], o = [], l2 = -1, m2 = false;
  if (0 !== e2.indexOf("<")) {
    var u2 = e2.indexOf("<");
    c2.push({ type: "text", content: -1 === u2 ? e2 : e2.substring(0, u2) });
  }
  return e2.replace(r$1, function(r2, s2) {
    if (m2) {
      if (r2 !== "</" + a2.name + ">")
        return;
      m2 = false;
    }
    var u3, f2 = "/" !== r2.charAt(1), h2 = r2.startsWith("<!--"), p2 = s2 + r2.length, d2 = e2.charAt(p2);
    if (h2) {
      var v2 = n$1(r2);
      return l2 < 0 ? (c2.push(v2), c2) : ((u3 = o[l2]).children.push(v2), c2);
    }
    if (f2 && (l2++, "tag" === (a2 = n$1(r2)).type && t2.components[a2.name] && (a2.type = "component", m2 = true), a2.voidElement || m2 || !d2 || "<" === d2 || a2.children.push({ type: "text", content: e2.slice(p2, e2.indexOf("<", p2)) }), 0 === l2 && c2.push(a2), (u3 = o[l2 - 1]) && u3.children.push(a2), o[l2] = a2), (!f2 || a2.voidElement) && (l2 > -1 && (a2.voidElement || a2.name === r2.slice(2, -1)) && (l2--, a2 = -1 === l2 ? c2 : o[l2]), !m2 && "<" !== d2 && d2)) {
      u3 = -1 === l2 ? c2 : o[l2].children;
      var x = e2.indexOf("<", p2), g2 = e2.slice(p2, -1 === x ? void 0 : x);
      i.test(g2) && (g2 = " "), (x > -1 && l2 + u3.length >= 0 || " " !== g2) && u3.push({ type: "text", content: g2 });
    }
  }), c2;
}, stringify: function(e2) {
  return e2.reduce(function(e3, t2) {
    return e3 + a("", t2);
  }, "");
} };
var _excluded$k = ["format"], _excluded2$1 = ["children", "count", "parent", "i18nKey", "context", "tOptions", "values", "defaults", "components", "ns", "i18n", "t", "shouldUnescape"];
function ownKeys$x(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$w(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$x(Object(source), true).forEach(function(key) {
        _defineProperty$4(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$x(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function hasChildren$1(node, checkLength) {
  if (!node)
    return false;
  var base = node.props ? node.props.children : node.children;
  if (checkLength)
    return base.length > 0;
  return !!base;
}
function getChildren(node) {
  if (!node)
    return [];
  return node.props ? node.props.children : node.children;
}
function hasValidReactChildren(children) {
  if (Object.prototype.toString.call(children) !== "[object Array]")
    return false;
  return children.every(function(child) {
    return reactExports.isValidElement(child);
  });
}
function getAsArray(data) {
  return Array.isArray(data) ? data : [data];
}
function mergeProps(source, target) {
  var newTarget = _objectSpread$w({}, target);
  newTarget.props = Object.assign(source.props, target.props);
  return newTarget;
}
function nodesToString(children, i18nOptions) {
  if (!children)
    return "";
  var stringNode = "";
  var childrenArray = getAsArray(children);
  var keepArray = i18nOptions.transSupportBasicHtmlNodes && i18nOptions.transKeepBasicHtmlNodesFor ? i18nOptions.transKeepBasicHtmlNodesFor : [];
  childrenArray.forEach(function(child, childIndex) {
    if (typeof child === "string") {
      stringNode += "".concat(child);
    } else if (reactExports.isValidElement(child)) {
      var childPropsCount = Object.keys(child.props).length;
      var shouldKeepChild = keepArray.indexOf(child.type) > -1;
      var childChildren = child.props.children;
      if (!childChildren && shouldKeepChild && childPropsCount === 0) {
        stringNode += "<".concat(child.type, "/>");
      } else if (!childChildren && (!shouldKeepChild || childPropsCount !== 0)) {
        stringNode += "<".concat(childIndex, "></").concat(childIndex, ">");
      } else if (child.props.i18nIsDynamicList) {
        stringNode += "<".concat(childIndex, "></").concat(childIndex, ">");
      } else if (shouldKeepChild && childPropsCount === 1 && typeof childChildren === "string") {
        stringNode += "<".concat(child.type, ">").concat(childChildren, "</").concat(child.type, ">");
      } else {
        var content = nodesToString(childChildren, i18nOptions);
        stringNode += "<".concat(childIndex, ">").concat(content, "</").concat(childIndex, ">");
      }
    } else if (child === null) {
      warn$1("Trans: the passed in value is invalid - seems you passed in a null child.");
    } else if (_typeof$2(child) === "object") {
      var format2 = child.format, clone3 = _objectWithoutProperties$2(child, _excluded$k);
      var keys2 = Object.keys(clone3);
      if (keys2.length === 1) {
        var value = format2 ? "".concat(keys2[0], ", ").concat(format2) : keys2[0];
        stringNode += "{{".concat(value, "}}");
      } else {
        warn$1("react-i18next: the passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.", child);
      }
    } else {
      warn$1("Trans: the passed in value is invalid - seems you passed in a variable like {number} - please pass in variables for interpolation as full objects like {{number}}.", child);
    }
  });
  return stringNode;
}
function renderNodes(children, targetString, i18n, i18nOptions, combinedTOpts, shouldUnescape) {
  if (targetString === "")
    return [];
  var keepArray = i18nOptions.transKeepBasicHtmlNodesFor || [];
  var emptyChildrenButNeedsHandling = targetString && new RegExp(keepArray.join("|")).test(targetString);
  if (!children && !emptyChildrenButNeedsHandling)
    return [targetString];
  var data = {};
  function getData(childs) {
    var childrenArray = getAsArray(childs);
    childrenArray.forEach(function(child) {
      if (typeof child === "string")
        return;
      if (hasChildren$1(child))
        getData(getChildren(child));
      else if (_typeof$2(child) === "object" && !reactExports.isValidElement(child))
        Object.assign(data, child);
    });
  }
  getData(children);
  var ast = c$1.parse("<0>".concat(targetString, "</0>"));
  var opts = _objectSpread$w(_objectSpread$w({}, data), combinedTOpts);
  function renderInner(child, node, rootReactNode) {
    var childs = getChildren(child);
    var mappedChildren = mapAST(childs, node.children, rootReactNode);
    return hasValidReactChildren(childs) && mappedChildren.length === 0 ? childs : mappedChildren;
  }
  function pushTranslatedJSX(child, inner, mem, i2, isVoid) {
    if (child.dummy)
      child.children = inner;
    mem.push(reactExports.cloneElement(child, _objectSpread$w(_objectSpread$w({}, child.props), {}, {
      key: i2
    }), isVoid ? void 0 : inner));
  }
  function mapAST(reactNode, astNode, rootReactNode) {
    var reactNodes = getAsArray(reactNode);
    var astNodes = getAsArray(astNode);
    return astNodes.reduce(function(mem, node, i2) {
      var translationContent = node.children && node.children[0] && node.children[0].content && i18n.services.interpolator.interpolate(node.children[0].content, opts, i18n.language);
      if (node.type === "tag") {
        var tmp = reactNodes[parseInt(node.name, 10)];
        if (!tmp && rootReactNode.length === 1 && rootReactNode[0][node.name])
          tmp = rootReactNode[0][node.name];
        if (!tmp)
          tmp = {};
        var child = Object.keys(node.attrs).length !== 0 ? mergeProps({
          props: node.attrs
        }, tmp) : tmp;
        var isElement = reactExports.isValidElement(child);
        var isValidTranslationWithChildren = isElement && hasChildren$1(node, true) && !node.voidElement;
        var isEmptyTransWithHTML = emptyChildrenButNeedsHandling && _typeof$2(child) === "object" && child.dummy && !isElement;
        var isKnownComponent = _typeof$2(children) === "object" && children !== null && Object.hasOwnProperty.call(children, node.name);
        if (typeof child === "string") {
          var value = i18n.services.interpolator.interpolate(child, opts, i18n.language);
          mem.push(value);
        } else if (hasChildren$1(child) || isValidTranslationWithChildren) {
          var inner = renderInner(child, node, rootReactNode);
          pushTranslatedJSX(child, inner, mem, i2);
        } else if (isEmptyTransWithHTML) {
          var _inner = mapAST(reactNodes, node.children, rootReactNode);
          mem.push(reactExports.cloneElement(child, _objectSpread$w(_objectSpread$w({}, child.props), {}, {
            key: i2
          }), _inner));
        } else if (Number.isNaN(parseFloat(node.name))) {
          if (isKnownComponent) {
            var _inner2 = renderInner(child, node, rootReactNode);
            pushTranslatedJSX(child, _inner2, mem, i2, node.voidElement);
          } else if (i18nOptions.transSupportBasicHtmlNodes && keepArray.indexOf(node.name) > -1) {
            if (node.voidElement) {
              mem.push(reactExports.createElement(node.name, {
                key: "".concat(node.name, "-").concat(i2)
              }));
            } else {
              var _inner3 = mapAST(reactNodes, node.children, rootReactNode);
              mem.push(reactExports.createElement(node.name, {
                key: "".concat(node.name, "-").concat(i2)
              }, _inner3));
            }
          } else if (node.voidElement) {
            mem.push("<".concat(node.name, " />"));
          } else {
            var _inner4 = mapAST(reactNodes, node.children, rootReactNode);
            mem.push("<".concat(node.name, ">").concat(_inner4, "</").concat(node.name, ">"));
          }
        } else if (_typeof$2(child) === "object" && !isElement) {
          var content = node.children[0] ? translationContent : null;
          if (content)
            mem.push(content);
        } else if (node.children.length === 1 && translationContent) {
          mem.push(reactExports.cloneElement(child, _objectSpread$w(_objectSpread$w({}, child.props), {}, {
            key: i2
          }), translationContent));
        } else {
          mem.push(reactExports.cloneElement(child, _objectSpread$w(_objectSpread$w({}, child.props), {}, {
            key: i2
          })));
        }
      } else if (node.type === "text") {
        var wrapTextNodes = i18nOptions.transWrapTextNodes;
        var _content = shouldUnescape ? i18nOptions.unescape(i18n.services.interpolator.interpolate(node.content, opts, i18n.language)) : i18n.services.interpolator.interpolate(node.content, opts, i18n.language);
        if (wrapTextNodes) {
          mem.push(reactExports.createElement(wrapTextNodes, {
            key: "".concat(node.name, "-").concat(i2)
          }, _content));
        } else {
          mem.push(_content);
        }
      }
      return mem;
    }, []);
  }
  var result = mapAST([{
    dummy: true,
    children: children || []
  }], ast, getAsArray(children || []));
  return getChildren(result[0]);
}
function Trans(_ref) {
  var children = _ref.children, count = _ref.count, parent2 = _ref.parent, i18nKey = _ref.i18nKey, context2 = _ref.context, _ref$tOptions = _ref.tOptions, tOptions = _ref$tOptions === void 0 ? {} : _ref$tOptions, values = _ref.values, defaults2 = _ref.defaults, components = _ref.components, ns = _ref.ns, i18nFromProps = _ref.i18n, tFromProps = _ref.t, shouldUnescape = _ref.shouldUnescape, additionalProps = _objectWithoutProperties$2(_ref, _excluded2$1);
  var _ref2 = reactExports.useContext(I18nContext) || {}, i18nFromContext = _ref2.i18n, defaultNSFromContext = _ref2.defaultNS;
  var i18n = i18nFromProps || i18nFromContext || getI18n();
  if (!i18n) {
    warnOnce("You will need to pass in an i18next instance by using i18nextReactModule");
    return children;
  }
  var t2 = tFromProps || i18n.t.bind(i18n) || function(k2) {
    return k2;
  };
  if (context2)
    tOptions.context = context2;
  var reactI18nextOptions = _objectSpread$w(_objectSpread$w({}, getDefaults()), i18n.options && i18n.options.react);
  var namespaces = ns || t2.ns || defaultNSFromContext || i18n.options && i18n.options.defaultNS;
  namespaces = typeof namespaces === "string" ? [namespaces] : namespaces || ["translation"];
  var defaultValue4 = defaults2 || nodesToString(children, reactI18nextOptions) || reactI18nextOptions.transEmptyNodeValue || i18nKey;
  var hashTransKey = reactI18nextOptions.hashTransKey;
  var key = i18nKey || (hashTransKey ? hashTransKey(defaultValue4) : defaultValue4);
  var interpolationOverride = values ? tOptions.interpolation : {
    interpolation: _objectSpread$w(_objectSpread$w({}, tOptions.interpolation), {}, {
      prefix: "#$?",
      suffix: "?$#"
    })
  };
  var combinedTOpts = _objectSpread$w(_objectSpread$w(_objectSpread$w(_objectSpread$w({}, tOptions), {}, {
    count
  }, values), interpolationOverride), {}, {
    defaultValue: defaultValue4,
    ns: namespaces
  });
  var translation = key ? t2(key, combinedTOpts) : defaultValue4;
  var content = renderNodes(components || children, translation, i18n, reactI18nextOptions, combinedTOpts, shouldUnescape);
  var useAsParent = parent2 !== void 0 ? parent2 : reactI18nextOptions.defaultTransParent;
  return useAsParent ? reactExports.createElement(useAsParent, additionalProps, content) : content;
}
const usePreviousProps = (value) => {
  const ref = reactExports.useRef({});
  reactExports.useEffect(() => {
    ref.current = value;
  });
  return ref.current;
};
const usePreviousProps$1 = usePreviousProps;
const visuallyHidden = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: -1,
  overflow: "hidden",
  padding: 0,
  position: "absolute",
  whiteSpace: "nowrap",
  width: "1px"
};
const visuallyHidden$1 = visuallyHidden;
function areArraysEqual(array1, array2, itemComparer = (a2, b2) => a2 === b2) {
  return array1.length === array2.length && array1.every((value, index2) => itemComparer(value, array2[index2]));
}
const INTENTIONAL_DRAG_COUNT_THRESHOLD = 2;
function asc(a2, b2) {
  return a2 - b2;
}
function clamp(value, min2, max2) {
  if (value == null) {
    return min2;
  }
  return Math.min(Math.max(min2, value), max2);
}
function findClosest(values, currentValue) {
  var _values$reduce;
  const {
    index: closestIndex
  } = (_values$reduce = values.reduce((acc, value, index2) => {
    const distance = Math.abs(currentValue - value);
    if (acc === null || distance < acc.distance || distance === acc.distance) {
      return {
        distance,
        index: index2
      };
    }
    return acc;
  }, null)) != null ? _values$reduce : {};
  return closestIndex;
}
function trackFinger(event, touchId) {
  if (touchId.current !== void 0 && event.changedTouches) {
    const touchEvent = event;
    for (let i2 = 0; i2 < touchEvent.changedTouches.length; i2 += 1) {
      const touch = touchEvent.changedTouches[i2];
      if (touch.identifier === touchId.current) {
        return {
          x: touch.clientX,
          y: touch.clientY
        };
      }
    }
    return false;
  }
  return {
    x: event.clientX,
    y: event.clientY
  };
}
function valueToPercent(value, min2, max2) {
  return (value - min2) * 100 / (max2 - min2);
}
function percentToValue(percent, min2, max2) {
  return (max2 - min2) * percent + min2;
}
function getDecimalPrecision(num) {
  if (Math.abs(num) < 1) {
    const parts = num.toExponential().split("e-");
    const matissaDecimalPart = parts[0].split(".")[1];
    return (matissaDecimalPart ? matissaDecimalPart.length : 0) + parseInt(parts[1], 10);
  }
  const decimalPart = num.toString().split(".")[1];
  return decimalPart ? decimalPart.length : 0;
}
function roundValueToStep(value, step, min2) {
  const nearest = Math.round((value - min2) / step) * step + min2;
  return Number(nearest.toFixed(getDecimalPrecision(step)));
}
function setValueIndex({
  values,
  newValue,
  index: index2
}) {
  const output = values.slice();
  output[index2] = newValue;
  return output.sort(asc);
}
function focusThumb({
  sliderRef,
  activeIndex,
  setActive
}) {
  var _sliderRef$current, _doc$activeElement;
  const doc = ownerDocument(sliderRef.current);
  if (!((_sliderRef$current = sliderRef.current) != null && _sliderRef$current.contains(doc.activeElement)) || Number(doc == null ? void 0 : (_doc$activeElement = doc.activeElement) == null ? void 0 : _doc$activeElement.getAttribute("data-index")) !== activeIndex) {
    var _sliderRef$current2;
    (_sliderRef$current2 = sliderRef.current) == null ? void 0 : _sliderRef$current2.querySelector(`[type="range"][data-index="${activeIndex}"]`).focus();
  }
  if (setActive) {
    setActive(activeIndex);
  }
}
function areValuesEqual(newValue, oldValue) {
  if (typeof newValue === "number" && typeof oldValue === "number") {
    return newValue === oldValue;
  }
  if (typeof newValue === "object" && typeof oldValue === "object") {
    return areArraysEqual(newValue, oldValue);
  }
  return false;
}
const axisProps = {
  horizontal: {
    offset: (percent) => ({
      left: `${percent}%`
    }),
    leap: (percent) => ({
      width: `${percent}%`
    })
  },
  "horizontal-reverse": {
    offset: (percent) => ({
      right: `${percent}%`
    }),
    leap: (percent) => ({
      width: `${percent}%`
    })
  },
  vertical: {
    offset: (percent) => ({
      bottom: `${percent}%`
    }),
    leap: (percent) => ({
      height: `${percent}%`
    })
  }
};
const Identity$1 = (x) => x;
let cachedSupportsTouchActionNone;
function doesSupportTouchActionNone() {
  if (cachedSupportsTouchActionNone === void 0) {
    if (typeof CSS !== "undefined" && typeof CSS.supports === "function") {
      cachedSupportsTouchActionNone = CSS.supports("touch-action", "none");
    } else {
      cachedSupportsTouchActionNone = true;
    }
  }
  return cachedSupportsTouchActionNone;
}
function useSlider(parameters) {
  const {
    "aria-labelledby": ariaLabelledby,
    defaultValue: defaultValue4,
    disabled = false,
    disableSwap = false,
    isRtl = false,
    marks: marksProp = false,
    max: max2 = 100,
    min: min2 = 0,
    name,
    onChange,
    onChangeCommitted,
    orientation = "horizontal",
    ref,
    scale = Identity$1,
    step = 1,
    tabIndex,
    value: valueProp
  } = parameters;
  const touchId = reactExports.useRef();
  const [active3, setActive] = reactExports.useState(-1);
  const [open, setOpen] = reactExports.useState(-1);
  const [dragging, setDragging] = reactExports.useState(false);
  const moveCount = reactExports.useRef(0);
  const [valueDerived, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue4 != null ? defaultValue4 : min2,
    name: "Slider"
  });
  const handleChange = onChange && ((event, value, thumbIndex) => {
    const nativeEvent = event.nativeEvent || event;
    const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
    Object.defineProperty(clonedEvent, "target", {
      writable: true,
      value: {
        value,
        name
      }
    });
    onChange(clonedEvent, value, thumbIndex);
  });
  const range2 = Array.isArray(valueDerived);
  let values = range2 ? valueDerived.slice().sort(asc) : [valueDerived];
  values = values.map((value) => clamp(value, min2, max2));
  const marks = marksProp === true && step !== null ? [...Array(Math.floor((max2 - min2) / step) + 1)].map((_, index2) => ({
    value: min2 + step * index2
  })) : marksProp || [];
  const marksValues = marks.map((mark) => mark.value);
  const {
    isFocusVisibleRef,
    onBlur: handleBlurVisible,
    onFocus: handleFocusVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [focusedThumbIndex, setFocusedThumbIndex] = reactExports.useState(-1);
  const sliderRef = reactExports.useRef();
  const handleFocusRef = useForkRef(focusVisibleRef, sliderRef);
  const handleRef2 = useForkRef(ref, handleFocusRef);
  const createHandleHiddenInputFocus = (otherHandlers) => (event) => {
    var _otherHandlers$onFocu;
    const index2 = Number(event.currentTarget.getAttribute("data-index"));
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      setFocusedThumbIndex(index2);
    }
    setOpen(index2);
    otherHandlers == null ? void 0 : (_otherHandlers$onFocu = otherHandlers.onFocus) == null ? void 0 : _otherHandlers$onFocu.call(otherHandlers, event);
  };
  const createHandleHiddenInputBlur = (otherHandlers) => (event) => {
    var _otherHandlers$onBlur;
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setFocusedThumbIndex(-1);
    }
    setOpen(-1);
    otherHandlers == null ? void 0 : (_otherHandlers$onBlur = otherHandlers.onBlur) == null ? void 0 : _otherHandlers$onBlur.call(otherHandlers, event);
  };
  useEnhancedEffect(() => {
    if (disabled && sliderRef.current.contains(document.activeElement)) {
      var _document$activeEleme;
      (_document$activeEleme = document.activeElement) == null ? void 0 : _document$activeEleme.blur();
    }
  }, [disabled]);
  if (disabled && active3 !== -1) {
    setActive(-1);
  }
  if (disabled && focusedThumbIndex !== -1) {
    setFocusedThumbIndex(-1);
  }
  const createHandleHiddenInputChange = (otherHandlers) => (event) => {
    var _otherHandlers$onChan;
    (_otherHandlers$onChan = otherHandlers.onChange) == null ? void 0 : _otherHandlers$onChan.call(otherHandlers, event);
    const index2 = Number(event.currentTarget.getAttribute("data-index"));
    const value = values[index2];
    const marksIndex = marksValues.indexOf(value);
    let newValue = event.target.valueAsNumber;
    if (marks && step == null) {
      newValue = newValue < value ? marksValues[marksIndex - 1] : marksValues[marksIndex + 1];
    }
    newValue = clamp(newValue, min2, max2);
    if (marks && step == null) {
      const currentMarkIndex = marksValues.indexOf(values[index2]);
      newValue = newValue < values[index2] ? marksValues[currentMarkIndex - 1] : marksValues[currentMarkIndex + 1];
    }
    if (range2) {
      if (disableSwap) {
        newValue = clamp(newValue, values[index2 - 1] || -Infinity, values[index2 + 1] || Infinity);
      }
      const previousValue = newValue;
      newValue = setValueIndex({
        values,
        newValue,
        index: index2
      });
      let activeIndex = index2;
      if (!disableSwap) {
        activeIndex = newValue.indexOf(previousValue);
      }
      focusThumb({
        sliderRef,
        activeIndex
      });
    }
    setValueState(newValue);
    setFocusedThumbIndex(index2);
    if (handleChange && !areValuesEqual(newValue, valueDerived)) {
      handleChange(event, newValue, index2);
    }
    if (onChangeCommitted) {
      onChangeCommitted(event, newValue);
    }
  };
  const previousIndex = reactExports.useRef();
  let axis = orientation;
  if (isRtl && orientation === "horizontal") {
    axis += "-reverse";
  }
  const getFingerNewValue = ({
    finger,
    move = false
  }) => {
    const {
      current: slider
    } = sliderRef;
    const {
      width,
      height,
      bottom,
      left
    } = slider.getBoundingClientRect();
    let percent;
    if (axis.indexOf("vertical") === 0) {
      percent = (bottom - finger.y) / height;
    } else {
      percent = (finger.x - left) / width;
    }
    if (axis.indexOf("-reverse") !== -1) {
      percent = 1 - percent;
    }
    let newValue;
    newValue = percentToValue(percent, min2, max2);
    if (step) {
      newValue = roundValueToStep(newValue, step, min2);
    } else {
      const closestIndex = findClosest(marksValues, newValue);
      newValue = marksValues[closestIndex];
    }
    newValue = clamp(newValue, min2, max2);
    let activeIndex = 0;
    if (range2) {
      if (!move) {
        activeIndex = findClosest(values, newValue);
      } else {
        activeIndex = previousIndex.current;
      }
      if (disableSwap) {
        newValue = clamp(newValue, values[activeIndex - 1] || -Infinity, values[activeIndex + 1] || Infinity);
      }
      const previousValue = newValue;
      newValue = setValueIndex({
        values,
        newValue,
        index: activeIndex
      });
      if (!(disableSwap && move)) {
        activeIndex = newValue.indexOf(previousValue);
        previousIndex.current = activeIndex;
      }
    }
    return {
      newValue,
      activeIndex
    };
  };
  const handleTouchMove = useEventCallback((nativeEvent) => {
    const finger = trackFinger(nativeEvent, touchId);
    if (!finger) {
      return;
    }
    moveCount.current += 1;
    if (nativeEvent.type === "mousemove" && nativeEvent.buttons === 0) {
      handleTouchEnd(nativeEvent);
      return;
    }
    const {
      newValue,
      activeIndex
    } = getFingerNewValue({
      finger,
      move: true
    });
    focusThumb({
      sliderRef,
      activeIndex,
      setActive
    });
    setValueState(newValue);
    if (!dragging && moveCount.current > INTENTIONAL_DRAG_COUNT_THRESHOLD) {
      setDragging(true);
    }
    if (handleChange && !areValuesEqual(newValue, valueDerived)) {
      handleChange(nativeEvent, newValue, activeIndex);
    }
  });
  const handleTouchEnd = useEventCallback((nativeEvent) => {
    const finger = trackFinger(nativeEvent, touchId);
    setDragging(false);
    if (!finger) {
      return;
    }
    const {
      newValue
    } = getFingerNewValue({
      finger,
      move: true
    });
    setActive(-1);
    if (nativeEvent.type === "touchend") {
      setOpen(-1);
    }
    if (onChangeCommitted) {
      onChangeCommitted(nativeEvent, newValue);
    }
    touchId.current = void 0;
    stopListening();
  });
  const handleTouchStart = useEventCallback((nativeEvent) => {
    if (disabled) {
      return;
    }
    if (!doesSupportTouchActionNone()) {
      nativeEvent.preventDefault();
    }
    const touch = nativeEvent.changedTouches[0];
    if (touch != null) {
      touchId.current = touch.identifier;
    }
    const finger = trackFinger(nativeEvent, touchId);
    if (finger !== false) {
      const {
        newValue,
        activeIndex
      } = getFingerNewValue({
        finger
      });
      focusThumb({
        sliderRef,
        activeIndex,
        setActive
      });
      setValueState(newValue);
      if (handleChange && !areValuesEqual(newValue, valueDerived)) {
        handleChange(nativeEvent, newValue, activeIndex);
      }
    }
    moveCount.current = 0;
    const doc = ownerDocument(sliderRef.current);
    doc.addEventListener("touchmove", handleTouchMove);
    doc.addEventListener("touchend", handleTouchEnd);
  });
  const stopListening = reactExports.useCallback(() => {
    const doc = ownerDocument(sliderRef.current);
    doc.removeEventListener("mousemove", handleTouchMove);
    doc.removeEventListener("mouseup", handleTouchEnd);
    doc.removeEventListener("touchmove", handleTouchMove);
    doc.removeEventListener("touchend", handleTouchEnd);
  }, [handleTouchEnd, handleTouchMove]);
  reactExports.useEffect(() => {
    const {
      current: slider
    } = sliderRef;
    slider.addEventListener("touchstart", handleTouchStart, {
      passive: doesSupportTouchActionNone()
    });
    return () => {
      slider.removeEventListener("touchstart", handleTouchStart, {
        passive: doesSupportTouchActionNone()
      });
      stopListening();
    };
  }, [stopListening, handleTouchStart]);
  reactExports.useEffect(() => {
    if (disabled) {
      stopListening();
    }
  }, [disabled, stopListening]);
  const createHandleMouseDown = (otherHandlers) => (event) => {
    var _otherHandlers$onMous;
    (_otherHandlers$onMous = otherHandlers.onMouseDown) == null ? void 0 : _otherHandlers$onMous.call(otherHandlers, event);
    if (disabled) {
      return;
    }
    if (event.defaultPrevented) {
      return;
    }
    if (event.button !== 0) {
      return;
    }
    event.preventDefault();
    const finger = trackFinger(event, touchId);
    if (finger !== false) {
      const {
        newValue,
        activeIndex
      } = getFingerNewValue({
        finger
      });
      focusThumb({
        sliderRef,
        activeIndex,
        setActive
      });
      setValueState(newValue);
      if (handleChange && !areValuesEqual(newValue, valueDerived)) {
        handleChange(event, newValue, activeIndex);
      }
    }
    moveCount.current = 0;
    const doc = ownerDocument(sliderRef.current);
    doc.addEventListener("mousemove", handleTouchMove);
    doc.addEventListener("mouseup", handleTouchEnd);
  };
  const trackOffset = valueToPercent(range2 ? values[0] : min2, min2, max2);
  const trackLeap = valueToPercent(values[values.length - 1], min2, max2) - trackOffset;
  const getRootProps = (otherHandlers = {}) => {
    const ownEventHandlers = {
      onMouseDown: createHandleMouseDown(otherHandlers || {})
    };
    const mergedEventHandlers = _extends$h({}, otherHandlers, ownEventHandlers);
    return _extends$h({
      ref: handleRef2
    }, mergedEventHandlers);
  };
  const createHandleMouseOver = (otherHandlers) => (event) => {
    var _otherHandlers$onMous2;
    (_otherHandlers$onMous2 = otherHandlers.onMouseOver) == null ? void 0 : _otherHandlers$onMous2.call(otherHandlers, event);
    const index2 = Number(event.currentTarget.getAttribute("data-index"));
    setOpen(index2);
  };
  const createHandleMouseLeave = (otherHandlers) => (event) => {
    var _otherHandlers$onMous3;
    (_otherHandlers$onMous3 = otherHandlers.onMouseLeave) == null ? void 0 : _otherHandlers$onMous3.call(otherHandlers, event);
    setOpen(-1);
  };
  const getThumbProps = (otherHandlers = {}) => {
    const ownEventHandlers = {
      onMouseOver: createHandleMouseOver(otherHandlers || {}),
      onMouseLeave: createHandleMouseLeave(otherHandlers || {})
    };
    return _extends$h({}, otherHandlers, ownEventHandlers);
  };
  const getHiddenInputProps = (otherHandlers = {}) => {
    var _parameters$step;
    const ownEventHandlers = {
      onChange: createHandleHiddenInputChange(otherHandlers || {}),
      onFocus: createHandleHiddenInputFocus(otherHandlers || {}),
      onBlur: createHandleHiddenInputBlur(otherHandlers || {})
    };
    const mergedEventHandlers = _extends$h({}, otherHandlers, ownEventHandlers);
    return _extends$h({
      tabIndex,
      "aria-labelledby": ariaLabelledby,
      "aria-orientation": orientation,
      "aria-valuemax": scale(max2),
      "aria-valuemin": scale(min2),
      name,
      type: "range",
      min: parameters.min,
      max: parameters.max,
      step: (_parameters$step = parameters.step) != null ? _parameters$step : void 0,
      disabled
    }, mergedEventHandlers, {
      style: _extends$h({}, visuallyHidden$1, {
        direction: isRtl ? "rtl" : "ltr",
        // So that VoiceOver's focus indicator matches the thumb's dimensions
        width: "100%",
        height: "100%"
      })
    });
  };
  return {
    active: active3,
    axis,
    axisProps,
    dragging,
    focusedThumbIndex,
    getHiddenInputProps,
    getRootProps,
    getThumbProps,
    marks,
    open,
    range: range2,
    trackLeap,
    trackOffset,
    values
  };
}
function stripDiacritics(string) {
  return typeof string.normalize !== "undefined" ? string.normalize("NFD").replace(/[\u0300-\u036f]/g, "") : string;
}
function createFilterOptions(config2 = {}) {
  const {
    ignoreAccents = true,
    ignoreCase = true,
    limit,
    matchFrom = "any",
    stringify: stringify2,
    trim = false
  } = config2;
  return (options, {
    inputValue: inputValue2,
    getOptionLabel
  }) => {
    let input2 = trim ? inputValue2.trim() : inputValue2;
    if (ignoreCase) {
      input2 = input2.toLowerCase();
    }
    if (ignoreAccents) {
      input2 = stripDiacritics(input2);
    }
    const filteredOptions = !input2 ? options : options.filter((option) => {
      let candidate = (stringify2 || getOptionLabel)(option);
      if (ignoreCase) {
        candidate = candidate.toLowerCase();
      }
      if (ignoreAccents) {
        candidate = stripDiacritics(candidate);
      }
      return matchFrom === "start" ? candidate.indexOf(input2) === 0 : candidate.indexOf(input2) > -1;
    });
    return typeof limit === "number" ? filteredOptions.slice(0, limit) : filteredOptions;
  };
}
function findIndex(array, comp) {
  for (let i2 = 0; i2 < array.length; i2 += 1) {
    if (comp(array[i2])) {
      return i2;
    }
  }
  return -1;
}
const defaultFilterOptions$1 = createFilterOptions();
const pageSize = 5;
const defaultIsActiveElementInListbox = (listboxRef) => {
  var _listboxRef$current$p;
  return listboxRef.current !== null && ((_listboxRef$current$p = listboxRef.current.parentElement) == null ? void 0 : _listboxRef$current$p.contains(document.activeElement));
};
function useAutocomplete(props) {
  const {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    unstable_isActiveElementInListbox = defaultIsActiveElementInListbox,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    unstable_classNamePrefix = "Mui",
    autoComplete = false,
    autoHighlight = false,
    autoSelect = false,
    blurOnSelect = false,
    clearOnBlur = !props.freeSolo,
    clearOnEscape = false,
    componentName: componentName2 = "useAutocomplete",
    defaultValue: defaultValue4 = props.multiple ? [] : null,
    disableClearable = false,
    disableCloseOnSelect = false,
    disabled: disabledProp,
    disabledItemsFocusable = false,
    disableListWrap = false,
    filterOptions = defaultFilterOptions$1,
    filterSelectedOptions = false,
    freeSolo = false,
    getOptionDisabled,
    getOptionLabel: getOptionLabelProp = (option) => {
      var _option$label;
      return (_option$label = option.label) != null ? _option$label : option;
    },
    groupBy,
    handleHomeEndKeys = !props.freeSolo,
    id: idProp,
    includeInputInList = false,
    inputValue: inputValueProp,
    isOptionEqualToValue = (option, value2) => option === value2,
    multiple = false,
    onChange,
    onClose,
    onHighlightChange,
    onInputChange,
    onOpen,
    open: openProp,
    openOnFocus = false,
    options,
    readOnly = false,
    selectOnFocus = !props.freeSolo,
    value: valueProp
  } = props;
  const id = useId(idProp);
  let getOptionLabel = getOptionLabelProp;
  getOptionLabel = (option) => {
    const optionLabel = getOptionLabelProp(option);
    if (typeof optionLabel !== "string") {
      return String(optionLabel);
    }
    return optionLabel;
  };
  const ignoreFocus = reactExports.useRef(false);
  const firstFocus = reactExports.useRef(true);
  const inputRef = reactExports.useRef(null);
  const listboxRef = reactExports.useRef(null);
  const [anchorEl, setAnchorEl] = reactExports.useState(null);
  const [focusedTag, setFocusedTag] = reactExports.useState(-1);
  const defaultHighlighted = autoHighlight ? 0 : -1;
  const highlightedIndexRef = reactExports.useRef(defaultHighlighted);
  const [value, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue4,
    name: componentName2
  });
  const [inputValue2, setInputValueState] = useControlled({
    controlled: inputValueProp,
    default: "",
    name: componentName2,
    state: "inputValue"
  });
  const [focused, setFocused] = reactExports.useState(false);
  const resetInputValue = reactExports.useCallback((event, newValue) => {
    const isOptionSelected = multiple ? value.length < newValue.length : newValue !== null;
    if (!isOptionSelected && !clearOnBlur) {
      return;
    }
    let newInputValue;
    if (multiple) {
      newInputValue = "";
    } else if (newValue == null) {
      newInputValue = "";
    } else {
      const optionLabel = getOptionLabel(newValue);
      newInputValue = typeof optionLabel === "string" ? optionLabel : "";
    }
    if (inputValue2 === newInputValue) {
      return;
    }
    setInputValueState(newInputValue);
    if (onInputChange) {
      onInputChange(event, newInputValue, "reset");
    }
  }, [getOptionLabel, inputValue2, multiple, onInputChange, setInputValueState, clearOnBlur, value]);
  const [open, setOpenState] = useControlled({
    controlled: openProp,
    default: false,
    name: componentName2,
    state: "open"
  });
  const [inputPristine, setInputPristine] = reactExports.useState(true);
  const inputValueIsSelectedValue = !multiple && value != null && inputValue2 === getOptionLabel(value);
  const popupOpen = open && !readOnly;
  const filteredOptions = popupOpen ? filterOptions(
    options.filter((option) => {
      if (filterSelectedOptions && (multiple ? value : [value]).some((value2) => value2 !== null && isOptionEqualToValue(option, value2))) {
        return false;
      }
      return true;
    }),
    // we use the empty string to manipulate `filterOptions` to not filter any options
    // i.e. the filter predicate always returns true
    {
      inputValue: inputValueIsSelectedValue && inputPristine ? "" : inputValue2,
      getOptionLabel
    }
  ) : [];
  const previousProps = usePreviousProps$1({
    filteredOptions,
    value
  });
  reactExports.useEffect(() => {
    const valueChange = value !== previousProps.value;
    if (focused && !valueChange) {
      return;
    }
    if (freeSolo && !valueChange) {
      return;
    }
    resetInputValue(null, value);
  }, [value, resetInputValue, focused, previousProps.value, freeSolo]);
  const listboxAvailable = open && filteredOptions.length > 0 && !readOnly;
  const focusTag = useEventCallback((tagToFocus) => {
    if (tagToFocus === -1) {
      inputRef.current.focus();
    } else {
      anchorEl.querySelector(`[data-tag-index="${tagToFocus}"]`).focus();
    }
  });
  reactExports.useEffect(() => {
    if (multiple && focusedTag > value.length - 1) {
      setFocusedTag(-1);
      focusTag(-1);
    }
  }, [value, multiple, focusedTag, focusTag]);
  function validOptionIndex(index2, direction) {
    if (!listboxRef.current || index2 === -1) {
      return -1;
    }
    let nextFocus = index2;
    while (true) {
      if (direction === "next" && nextFocus === filteredOptions.length || direction === "previous" && nextFocus === -1) {
        return -1;
      }
      const option = listboxRef.current.querySelector(`[data-option-index="${nextFocus}"]`);
      const nextFocusDisabled = disabledItemsFocusable ? false : !option || option.disabled || option.getAttribute("aria-disabled") === "true";
      if (option && !option.hasAttribute("tabindex") || nextFocusDisabled) {
        nextFocus += direction === "next" ? 1 : -1;
      } else {
        return nextFocus;
      }
    }
  }
  const setHighlightedIndex = useEventCallback(({
    event,
    index: index2,
    reason = "auto"
  }) => {
    highlightedIndexRef.current = index2;
    if (index2 === -1) {
      inputRef.current.removeAttribute("aria-activedescendant");
    } else {
      inputRef.current.setAttribute("aria-activedescendant", `${id}-option-${index2}`);
    }
    if (onHighlightChange) {
      onHighlightChange(event, index2 === -1 ? null : filteredOptions[index2], reason);
    }
    if (!listboxRef.current) {
      return;
    }
    const prev = listboxRef.current.querySelector(`[role="option"].${unstable_classNamePrefix}-focused`);
    if (prev) {
      prev.classList.remove(`${unstable_classNamePrefix}-focused`);
      prev.classList.remove(`${unstable_classNamePrefix}-focusVisible`);
    }
    const listboxNode = listboxRef.current.parentElement.querySelector('[role="listbox"]');
    if (!listboxNode) {
      return;
    }
    if (index2 === -1) {
      listboxNode.scrollTop = 0;
      return;
    }
    const option = listboxRef.current.querySelector(`[data-option-index="${index2}"]`);
    if (!option) {
      return;
    }
    option.classList.add(`${unstable_classNamePrefix}-focused`);
    if (reason === "keyboard") {
      option.classList.add(`${unstable_classNamePrefix}-focusVisible`);
    }
    if (listboxNode.scrollHeight > listboxNode.clientHeight && reason !== "mouse") {
      const element = option;
      const scrollBottom = listboxNode.clientHeight + listboxNode.scrollTop;
      const elementBottom = element.offsetTop + element.offsetHeight;
      if (elementBottom > scrollBottom) {
        listboxNode.scrollTop = elementBottom - listboxNode.clientHeight;
      } else if (element.offsetTop - element.offsetHeight * (groupBy ? 1.3 : 0) < listboxNode.scrollTop) {
        listboxNode.scrollTop = element.offsetTop - element.offsetHeight * (groupBy ? 1.3 : 0);
      }
    }
  });
  const changeHighlightedIndex = useEventCallback(({
    event,
    diff: diff2,
    direction = "next",
    reason = "auto"
  }) => {
    if (!popupOpen) {
      return;
    }
    const getNextIndex = () => {
      const maxIndex = filteredOptions.length - 1;
      if (diff2 === "reset") {
        return defaultHighlighted;
      }
      if (diff2 === "start") {
        return 0;
      }
      if (diff2 === "end") {
        return maxIndex;
      }
      const newIndex = highlightedIndexRef.current + diff2;
      if (newIndex < 0) {
        if (newIndex === -1 && includeInputInList) {
          return -1;
        }
        if (disableListWrap && highlightedIndexRef.current !== -1 || Math.abs(diff2) > 1) {
          return 0;
        }
        return maxIndex;
      }
      if (newIndex > maxIndex) {
        if (newIndex === maxIndex + 1 && includeInputInList) {
          return -1;
        }
        if (disableListWrap || Math.abs(diff2) > 1) {
          return maxIndex;
        }
        return 0;
      }
      return newIndex;
    };
    const nextIndex = validOptionIndex(getNextIndex(), direction);
    setHighlightedIndex({
      index: nextIndex,
      reason,
      event
    });
    if (autoComplete && diff2 !== "reset") {
      if (nextIndex === -1) {
        inputRef.current.value = inputValue2;
      } else {
        const option = getOptionLabel(filteredOptions[nextIndex]);
        inputRef.current.value = option;
        const index2 = option.toLowerCase().indexOf(inputValue2.toLowerCase());
        if (index2 === 0 && inputValue2.length > 0) {
          inputRef.current.setSelectionRange(inputValue2.length, option.length);
        }
      }
    }
  });
  const checkHighlightedOptionExists = () => {
    const isSameValue = (value1, value2) => {
      const label1 = value1 ? getOptionLabel(value1) : "";
      const label2 = value2 ? getOptionLabel(value2) : "";
      return label1 === label2;
    };
    if (highlightedIndexRef.current !== -1 && previousProps.filteredOptions && previousProps.filteredOptions.length !== filteredOptions.length && (multiple ? value.length === previousProps.value.length && previousProps.value.every((val, i2) => getOptionLabel(value[i2]) === getOptionLabel(val)) : isSameValue(previousProps.value, value))) {
      const previousHighlightedOption = previousProps.filteredOptions[highlightedIndexRef.current];
      if (previousHighlightedOption) {
        const previousHighlightedOptionExists = filteredOptions.some((option) => {
          return getOptionLabel(option) === getOptionLabel(previousHighlightedOption);
        });
        if (previousHighlightedOptionExists) {
          return true;
        }
      }
    }
    return false;
  };
  const syncHighlightedIndex = reactExports.useCallback(() => {
    if (!popupOpen) {
      return;
    }
    if (checkHighlightedOptionExists()) {
      return;
    }
    const valueItem = multiple ? value[0] : value;
    if (filteredOptions.length === 0 || valueItem == null) {
      changeHighlightedIndex({
        diff: "reset"
      });
      return;
    }
    if (!listboxRef.current) {
      return;
    }
    if (valueItem != null) {
      const currentOption = filteredOptions[highlightedIndexRef.current];
      if (multiple && currentOption && findIndex(value, (val) => isOptionEqualToValue(currentOption, val)) !== -1) {
        return;
      }
      const itemIndex = findIndex(filteredOptions, (optionItem) => isOptionEqualToValue(optionItem, valueItem));
      if (itemIndex === -1) {
        changeHighlightedIndex({
          diff: "reset"
        });
      } else {
        setHighlightedIndex({
          index: itemIndex
        });
      }
      return;
    }
    if (highlightedIndexRef.current >= filteredOptions.length - 1) {
      setHighlightedIndex({
        index: filteredOptions.length - 1
      });
      return;
    }
    setHighlightedIndex({
      index: highlightedIndexRef.current
    });
  }, [
    // Only sync the highlighted index when the option switch between empty and not
    filteredOptions.length,
    // Don't sync the highlighted index with the value when multiple
    // eslint-disable-next-line react-hooks/exhaustive-deps
    multiple ? false : value,
    filterSelectedOptions,
    changeHighlightedIndex,
    setHighlightedIndex,
    popupOpen,
    inputValue2,
    multiple
  ]);
  const handleListboxRef = useEventCallback((node) => {
    setRef(listboxRef, node);
    if (!node) {
      return;
    }
    syncHighlightedIndex();
  });
  reactExports.useEffect(() => {
    syncHighlightedIndex();
  }, [syncHighlightedIndex]);
  const handleOpen = (event) => {
    if (open) {
      return;
    }
    setOpenState(true);
    setInputPristine(true);
    if (onOpen) {
      onOpen(event);
    }
  };
  const handleClose = (event, reason) => {
    if (!open) {
      return;
    }
    setOpenState(false);
    if (onClose) {
      onClose(event, reason);
    }
  };
  const handleValue = (event, newValue, reason, details) => {
    if (multiple) {
      if (value.length === newValue.length && value.every((val, i2) => val === newValue[i2])) {
        return;
      }
    } else if (value === newValue) {
      return;
    }
    if (onChange) {
      onChange(event, newValue, reason, details);
    }
    setValueState(newValue);
  };
  const isTouch = reactExports.useRef(false);
  const selectNewValue = (event, option, reasonProp = "selectOption", origin = "options") => {
    let reason = reasonProp;
    let newValue = option;
    if (multiple) {
      newValue = Array.isArray(value) ? value.slice() : [];
      const itemIndex = findIndex(newValue, (valueItem) => isOptionEqualToValue(option, valueItem));
      if (itemIndex === -1) {
        newValue.push(option);
      } else if (origin !== "freeSolo") {
        newValue.splice(itemIndex, 1);
        reason = "removeOption";
      }
    }
    resetInputValue(event, newValue);
    handleValue(event, newValue, reason, {
      option
    });
    if (!disableCloseOnSelect && (!event || !event.ctrlKey && !event.metaKey)) {
      handleClose(event, reason);
    }
    if (blurOnSelect === true || blurOnSelect === "touch" && isTouch.current || blurOnSelect === "mouse" && !isTouch.current) {
      inputRef.current.blur();
    }
  };
  function validTagIndex(index2, direction) {
    if (index2 === -1) {
      return -1;
    }
    let nextFocus = index2;
    while (true) {
      if (direction === "next" && nextFocus === value.length || direction === "previous" && nextFocus === -1) {
        return -1;
      }
      const option = anchorEl.querySelector(`[data-tag-index="${nextFocus}"]`);
      if (!option || !option.hasAttribute("tabindex") || option.disabled || option.getAttribute("aria-disabled") === "true") {
        nextFocus += direction === "next" ? 1 : -1;
      } else {
        return nextFocus;
      }
    }
  }
  const handleFocusTag = (event, direction) => {
    if (!multiple) {
      return;
    }
    if (inputValue2 === "") {
      handleClose(event, "toggleInput");
    }
    let nextTag = focusedTag;
    if (focusedTag === -1) {
      if (inputValue2 === "" && direction === "previous") {
        nextTag = value.length - 1;
      }
    } else {
      nextTag += direction === "next" ? 1 : -1;
      if (nextTag < 0) {
        nextTag = 0;
      }
      if (nextTag === value.length) {
        nextTag = -1;
      }
    }
    nextTag = validTagIndex(nextTag, direction);
    setFocusedTag(nextTag);
    focusTag(nextTag);
  };
  const handleClear = (event) => {
    ignoreFocus.current = true;
    setInputValueState("");
    if (onInputChange) {
      onInputChange(event, "", "clear");
    }
    handleValue(event, multiple ? [] : null, "clear");
  };
  const handleKeyDown = (other) => (event) => {
    if (other.onKeyDown) {
      other.onKeyDown(event);
    }
    if (event.defaultMuiPrevented) {
      return;
    }
    if (focusedTag !== -1 && ["ArrowLeft", "ArrowRight"].indexOf(event.key) === -1) {
      setFocusedTag(-1);
      focusTag(-1);
    }
    if (event.which !== 229) {
      switch (event.key) {
        case "Home":
          if (popupOpen && handleHomeEndKeys) {
            event.preventDefault();
            changeHighlightedIndex({
              diff: "start",
              direction: "next",
              reason: "keyboard",
              event
            });
          }
          break;
        case "End":
          if (popupOpen && handleHomeEndKeys) {
            event.preventDefault();
            changeHighlightedIndex({
              diff: "end",
              direction: "previous",
              reason: "keyboard",
              event
            });
          }
          break;
        case "PageUp":
          event.preventDefault();
          changeHighlightedIndex({
            diff: -pageSize,
            direction: "previous",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "PageDown":
          event.preventDefault();
          changeHighlightedIndex({
            diff: pageSize,
            direction: "next",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "ArrowDown":
          event.preventDefault();
          changeHighlightedIndex({
            diff: 1,
            direction: "next",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "ArrowUp":
          event.preventDefault();
          changeHighlightedIndex({
            diff: -1,
            direction: "previous",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "ArrowLeft":
          handleFocusTag(event, "previous");
          break;
        case "ArrowRight":
          handleFocusTag(event, "next");
          break;
        case "Enter":
          if (highlightedIndexRef.current !== -1 && popupOpen) {
            const option = filteredOptions[highlightedIndexRef.current];
            const disabled = getOptionDisabled ? getOptionDisabled(option) : false;
            event.preventDefault();
            if (disabled) {
              return;
            }
            selectNewValue(event, option, "selectOption");
            if (autoComplete) {
              inputRef.current.setSelectionRange(inputRef.current.value.length, inputRef.current.value.length);
            }
          } else if (freeSolo && inputValue2 !== "" && inputValueIsSelectedValue === false) {
            if (multiple) {
              event.preventDefault();
            }
            selectNewValue(event, inputValue2, "createOption", "freeSolo");
          }
          break;
        case "Escape":
          if (popupOpen) {
            event.preventDefault();
            event.stopPropagation();
            handleClose(event, "escape");
          } else if (clearOnEscape && (inputValue2 !== "" || multiple && value.length > 0)) {
            event.preventDefault();
            event.stopPropagation();
            handleClear(event);
          }
          break;
        case "Backspace":
          if (multiple && !readOnly && inputValue2 === "" && value.length > 0) {
            const index2 = focusedTag === -1 ? value.length - 1 : focusedTag;
            const newValue = value.slice();
            newValue.splice(index2, 1);
            handleValue(event, newValue, "removeOption", {
              option: value[index2]
            });
          }
          break;
        case "Delete":
          if (multiple && !readOnly && inputValue2 === "" && value.length > 0 && focusedTag !== -1) {
            const index2 = focusedTag;
            const newValue = value.slice();
            newValue.splice(index2, 1);
            handleValue(event, newValue, "removeOption", {
              option: value[index2]
            });
          }
          break;
      }
    }
  };
  const handleFocus3 = (event) => {
    setFocused(true);
    if (openOnFocus && !ignoreFocus.current) {
      handleOpen(event);
    }
  };
  const handleBlur = (event) => {
    if (unstable_isActiveElementInListbox(listboxRef)) {
      inputRef.current.focus();
      return;
    }
    setFocused(false);
    firstFocus.current = true;
    ignoreFocus.current = false;
    if (autoSelect && highlightedIndexRef.current !== -1 && popupOpen) {
      selectNewValue(event, filteredOptions[highlightedIndexRef.current], "blur");
    } else if (autoSelect && freeSolo && inputValue2 !== "") {
      selectNewValue(event, inputValue2, "blur", "freeSolo");
    } else if (clearOnBlur) {
      resetInputValue(event, value);
    }
    handleClose(event, "blur");
  };
  const handleInputChange = (event) => {
    const newValue = event.target.value;
    if (inputValue2 !== newValue) {
      setInputValueState(newValue);
      setInputPristine(false);
      if (onInputChange) {
        onInputChange(event, newValue, "input");
      }
    }
    if (newValue === "") {
      if (!disableClearable && !multiple) {
        handleValue(event, null, "clear");
      }
    } else {
      handleOpen(event);
    }
  };
  const handleOptionMouseMove = (event) => {
    const index2 = Number(event.currentTarget.getAttribute("data-option-index"));
    if (highlightedIndexRef.current !== index2) {
      setHighlightedIndex({
        event,
        index: index2,
        reason: "mouse"
      });
    }
  };
  const handleOptionTouchStart = (event) => {
    setHighlightedIndex({
      event,
      index: Number(event.currentTarget.getAttribute("data-option-index")),
      reason: "touch"
    });
    isTouch.current = true;
  };
  const handleOptionClick = (event) => {
    const index2 = Number(event.currentTarget.getAttribute("data-option-index"));
    selectNewValue(event, filteredOptions[index2], "selectOption");
    isTouch.current = false;
  };
  const handleTagDelete = (index2) => (event) => {
    const newValue = value.slice();
    newValue.splice(index2, 1);
    handleValue(event, newValue, "removeOption", {
      option: value[index2]
    });
  };
  const handlePopupIndicator = (event) => {
    if (open) {
      handleClose(event, "toggleInput");
    } else {
      handleOpen(event);
    }
  };
  const handleMouseDown = (event) => {
    if (event.target.getAttribute("id") !== id) {
      event.preventDefault();
    }
  };
  const handleClick = () => {
    inputRef.current.focus();
    if (selectOnFocus && firstFocus.current && inputRef.current.selectionEnd - inputRef.current.selectionStart === 0) {
      inputRef.current.select();
    }
    firstFocus.current = false;
  };
  const handleInputMouseDown = (event) => {
    if (inputValue2 === "" || !open) {
      handlePopupIndicator(event);
    }
  };
  let dirty = freeSolo && inputValue2.length > 0;
  dirty = dirty || (multiple ? value.length > 0 : value !== null);
  let groupedOptions = filteredOptions;
  if (groupBy) {
    /* @__PURE__ */ new Map();
    groupedOptions = filteredOptions.reduce((acc, option, index2) => {
      const group3 = groupBy(option);
      if (acc.length > 0 && acc[acc.length - 1].group === group3) {
        acc[acc.length - 1].options.push(option);
      } else {
        acc.push({
          key: index2,
          index: index2,
          group: group3,
          options: [option]
        });
      }
      return acc;
    }, []);
  }
  if (disabledProp && focused) {
    handleBlur();
  }
  return {
    getRootProps: (other = {}) => _extends$h({
      "aria-owns": listboxAvailable ? `${id}-listbox` : null
    }, other, {
      onKeyDown: handleKeyDown(other),
      onMouseDown: handleMouseDown,
      onClick: handleClick
    }),
    getInputLabelProps: () => ({
      id: `${id}-label`,
      htmlFor: id
    }),
    getInputProps: () => ({
      id,
      value: inputValue2,
      onBlur: handleBlur,
      onFocus: handleFocus3,
      onChange: handleInputChange,
      onMouseDown: handleInputMouseDown,
      // if open then this is handled imperatively so don't let react override
      // only have an opinion about this when closed
      "aria-activedescendant": popupOpen ? "" : null,
      "aria-autocomplete": autoComplete ? "both" : "list",
      "aria-controls": listboxAvailable ? `${id}-listbox` : void 0,
      "aria-expanded": listboxAvailable,
      // Disable browser's suggestion that might overlap with the popup.
      // Handle autocomplete but not autofill.
      autoComplete: "off",
      ref: inputRef,
      autoCapitalize: "none",
      spellCheck: "false",
      role: "combobox",
      disabled: disabledProp
    }),
    getClearProps: () => ({
      tabIndex: -1,
      onClick: handleClear
    }),
    getPopupIndicatorProps: () => ({
      tabIndex: -1,
      onClick: handlePopupIndicator
    }),
    getTagProps: ({
      index: index2
    }) => _extends$h({
      key: index2,
      "data-tag-index": index2,
      tabIndex: -1
    }, !readOnly && {
      onDelete: handleTagDelete(index2)
    }),
    getListboxProps: () => ({
      role: "listbox",
      id: `${id}-listbox`,
      "aria-labelledby": `${id}-label`,
      ref: handleListboxRef,
      onMouseDown: (event) => {
        event.preventDefault();
      }
    }),
    getOptionProps: ({
      index: index2,
      option
    }) => {
      const selected = (multiple ? value : [value]).some((value2) => value2 != null && isOptionEqualToValue(option, value2));
      const disabled = getOptionDisabled ? getOptionDisabled(option) : false;
      return {
        key: getOptionLabel(option),
        tabIndex: -1,
        role: "option",
        id: `${id}-option-${index2}`,
        onMouseMove: handleOptionMouseMove,
        onClick: handleOptionClick,
        onTouchStart: handleOptionTouchStart,
        "data-option-index": index2,
        "aria-disabled": disabled,
        "aria-selected": selected
      };
    },
    id,
    inputValue: inputValue2,
    value,
    dirty,
    expanded: popupOpen && anchorEl,
    popupOpen,
    focused: focused || focusedTag !== -1,
    anchorEl,
    setAnchorEl,
    focusedTag,
    groupedOptions
  };
}
function getListSubheaderUtilityClass(slot) {
  return generateUtilityClass("MuiListSubheader", slot);
}
generateUtilityClasses("MuiListSubheader", ["root", "colorPrimary", "colorInherit", "gutters", "inset", "sticky"]);
const _excluded$j = ["className", "color", "component", "disableGutters", "disableSticky", "inset"];
const useUtilityClasses$7 = (ownerState) => {
  const {
    classes,
    color: color2,
    disableGutters,
    inset,
    disableSticky
  } = ownerState;
  const slots = {
    root: ["root", color2 !== "default" && `color${capitalize(color2)}`, !disableGutters && "gutters", inset && "inset", !disableSticky && "sticky"]
  };
  return composeClasses(slots, getListSubheaderUtilityClass, classes);
};
const ListSubheaderRoot = styled("li", {
  name: "MuiListSubheader",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`], !ownerState.disableGutters && styles2.gutters, ownerState.inset && styles2.inset, !ownerState.disableSticky && styles2.sticky];
  }
})(({
  theme,
  ownerState
}) => _extends$h({
  boxSizing: "border-box",
  lineHeight: "48px",
  listStyle: "none",
  color: (theme.vars || theme).palette.text.secondary,
  fontFamily: theme.typography.fontFamily,
  fontWeight: theme.typography.fontWeightMedium,
  fontSize: theme.typography.pxToRem(14)
}, ownerState.color === "primary" && {
  color: (theme.vars || theme).palette.primary.main
}, ownerState.color === "inherit" && {
  color: "inherit"
}, !ownerState.disableGutters && {
  paddingLeft: 16,
  paddingRight: 16
}, ownerState.inset && {
  paddingLeft: 72
}, !ownerState.disableSticky && {
  position: "sticky",
  top: 0,
  zIndex: 1,
  backgroundColor: (theme.vars || theme).palette.background.paper
}));
const ListSubheader = /* @__PURE__ */ reactExports.forwardRef(function ListSubheader2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiListSubheader"
  });
  const {
    className,
    color: color2 = "default",
    component = "li",
    disableGutters = false,
    disableSticky = false,
    inset = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$j);
  const ownerState = _extends$h({}, props, {
    color: color2,
    component,
    disableGutters,
    disableSticky,
    inset
  });
  const classes = useUtilityClasses$7(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListSubheaderRoot, _extends$h({
    as: component,
    className: clsx(classes.root, className),
    ref,
    ownerState
  }, other));
});
ListSubheader.muiSkipListHighlight = true;
const ListSubheader$1 = ListSubheader;
const CancelIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"
}), "Cancel");
function getChipUtilityClass(slot) {
  return generateUtilityClass("MuiChip", slot);
}
const chipClasses = generateUtilityClasses("MuiChip", ["root", "sizeSmall", "sizeMedium", "colorError", "colorInfo", "colorPrimary", "colorSecondary", "colorSuccess", "colorWarning", "disabled", "clickable", "clickableColorPrimary", "clickableColorSecondary", "deletable", "deletableColorPrimary", "deletableColorSecondary", "outlined", "filled", "outlinedPrimary", "outlinedSecondary", "filledPrimary", "filledSecondary", "avatar", "avatarSmall", "avatarMedium", "avatarColorPrimary", "avatarColorSecondary", "icon", "iconSmall", "iconMedium", "iconColorPrimary", "iconColorSecondary", "label", "labelSmall", "labelMedium", "deleteIcon", "deleteIconSmall", "deleteIconMedium", "deleteIconColorPrimary", "deleteIconColorSecondary", "deleteIconOutlinedColorPrimary", "deleteIconOutlinedColorSecondary", "deleteIconFilledColorPrimary", "deleteIconFilledColorSecondary", "focusVisible"]);
const chipClasses$1 = chipClasses;
const _excluded$i = ["avatar", "className", "clickable", "color", "component", "deleteIcon", "disabled", "icon", "label", "onClick", "onDelete", "onKeyDown", "onKeyUp", "size", "variant", "tabIndex", "skipFocusWhenDisabled"];
const useUtilityClasses$6 = (ownerState) => {
  const {
    classes,
    disabled,
    size,
    color: color2,
    iconColor,
    onDelete,
    clickable: clickable2,
    variant
  } = ownerState;
  const slots = {
    root: ["root", variant, disabled && "disabled", `size${capitalize(size)}`, `color${capitalize(color2)}`, clickable2 && "clickable", clickable2 && `clickableColor${capitalize(color2)}`, onDelete && "deletable", onDelete && `deletableColor${capitalize(color2)}`, `${variant}${capitalize(color2)}`],
    label: ["label", `label${capitalize(size)}`],
    avatar: ["avatar", `avatar${capitalize(size)}`, `avatarColor${capitalize(color2)}`],
    icon: ["icon", `icon${capitalize(size)}`, `iconColor${capitalize(iconColor)}`],
    deleteIcon: ["deleteIcon", `deleteIcon${capitalize(size)}`, `deleteIconColor${capitalize(color2)}`, `deleteIcon${capitalize(variant)}Color${capitalize(color2)}`]
  };
  return composeClasses(slots, getChipUtilityClass, classes);
};
const ChipRoot = styled("div", {
  name: "MuiChip",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      color: color2,
      iconColor,
      clickable: clickable2,
      onDelete,
      size,
      variant
    } = ownerState;
    return [{
      [`& .${chipClasses$1.avatar}`]: styles2.avatar
    }, {
      [`& .${chipClasses$1.avatar}`]: styles2[`avatar${capitalize(size)}`]
    }, {
      [`& .${chipClasses$1.avatar}`]: styles2[`avatarColor${capitalize(color2)}`]
    }, {
      [`& .${chipClasses$1.icon}`]: styles2.icon
    }, {
      [`& .${chipClasses$1.icon}`]: styles2[`icon${capitalize(size)}`]
    }, {
      [`& .${chipClasses$1.icon}`]: styles2[`iconColor${capitalize(iconColor)}`]
    }, {
      [`& .${chipClasses$1.deleteIcon}`]: styles2.deleteIcon
    }, {
      [`& .${chipClasses$1.deleteIcon}`]: styles2[`deleteIcon${capitalize(size)}`]
    }, {
      [`& .${chipClasses$1.deleteIcon}`]: styles2[`deleteIconColor${capitalize(color2)}`]
    }, {
      [`& .${chipClasses$1.deleteIcon}`]: styles2[`deleteIcon${capitalize(variant)}Color${capitalize(color2)}`]
    }, styles2.root, styles2[`size${capitalize(size)}`], styles2[`color${capitalize(color2)}`], clickable2 && styles2.clickable, clickable2 && color2 !== "default" && styles2[`clickableColor${capitalize(color2)})`], onDelete && styles2.deletable, onDelete && color2 !== "default" && styles2[`deletableColor${capitalize(color2)}`], styles2[variant], styles2[`${variant}${capitalize(color2)}`]];
  }
})(({
  theme,
  ownerState
}) => {
  const textColor = theme.palette.mode === "light" ? theme.palette.grey[700] : theme.palette.grey[300];
  return _extends$h({
    maxWidth: "100%",
    fontFamily: theme.typography.fontFamily,
    fontSize: theme.typography.pxToRem(13),
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    height: 32,
    color: (theme.vars || theme).palette.text.primary,
    backgroundColor: (theme.vars || theme).palette.action.selected,
    borderRadius: 32 / 2,
    whiteSpace: "nowrap",
    transition: theme.transitions.create(["background-color", "box-shadow"]),
    // label will inherit this from root, then `clickable` class overrides this for both
    cursor: "default",
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    textDecoration: "none",
    border: 0,
    // Remove `button` border
    padding: 0,
    // Remove `button` padding
    verticalAlign: "middle",
    boxSizing: "border-box",
    [`&.${chipClasses$1.disabled}`]: {
      opacity: (theme.vars || theme).palette.action.disabledOpacity,
      pointerEvents: "none"
    },
    [`& .${chipClasses$1.avatar}`]: {
      marginLeft: 5,
      marginRight: -6,
      width: 24,
      height: 24,
      color: theme.vars ? theme.vars.palette.Chip.defaultAvatarColor : textColor,
      fontSize: theme.typography.pxToRem(12)
    },
    [`& .${chipClasses$1.avatarColorPrimary}`]: {
      color: (theme.vars || theme).palette.primary.contrastText,
      backgroundColor: (theme.vars || theme).palette.primary.dark
    },
    [`& .${chipClasses$1.avatarColorSecondary}`]: {
      color: (theme.vars || theme).palette.secondary.contrastText,
      backgroundColor: (theme.vars || theme).palette.secondary.dark
    },
    [`& .${chipClasses$1.avatarSmall}`]: {
      marginLeft: 4,
      marginRight: -4,
      width: 18,
      height: 18,
      fontSize: theme.typography.pxToRem(10)
    },
    [`& .${chipClasses$1.icon}`]: _extends$h({
      marginLeft: 5,
      marginRight: -6
    }, ownerState.size === "small" && {
      fontSize: 18,
      marginLeft: 4,
      marginRight: -4
    }, ownerState.iconColor === ownerState.color && _extends$h({
      color: theme.vars ? theme.vars.palette.Chip.defaultIconColor : textColor
    }, ownerState.color !== "default" && {
      color: "inherit"
    })),
    [`& .${chipClasses$1.deleteIcon}`]: _extends$h({
      WebkitTapHighlightColor: "transparent",
      color: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / 0.26)` : alpha(theme.palette.text.primary, 0.26),
      fontSize: 22,
      cursor: "pointer",
      margin: "0 5px 0 -6px",
      "&:hover": {
        color: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / 0.4)` : alpha(theme.palette.text.primary, 0.4)
      }
    }, ownerState.size === "small" && {
      fontSize: 16,
      marginRight: 4,
      marginLeft: -4
    }, ownerState.color !== "default" && {
      color: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].contrastTextChannel} / 0.7)` : alpha(theme.palette[ownerState.color].contrastText, 0.7),
      "&:hover, &:active": {
        color: (theme.vars || theme).palette[ownerState.color].contrastText
      }
    })
  }, ownerState.size === "small" && {
    height: 24
  }, ownerState.color !== "default" && {
    backgroundColor: (theme.vars || theme).palette[ownerState.color].main,
    color: (theme.vars || theme).palette[ownerState.color].contrastText
  }, ownerState.onDelete && {
    [`&.${chipClasses$1.focusVisible}`]: {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
    }
  }, ownerState.onDelete && ownerState.color !== "default" && {
    [`&.${chipClasses$1.focusVisible}`]: {
      backgroundColor: (theme.vars || theme).palette[ownerState.color].dark
    }
  });
}, ({
  theme,
  ownerState
}) => _extends$h({}, ownerState.clickable && {
  userSelect: "none",
  WebkitTapHighlightColor: "transparent",
  cursor: "pointer",
  "&:hover": {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity)
  },
  [`&.${chipClasses$1.focusVisible}`]: {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
  },
  "&:active": {
    boxShadow: (theme.vars || theme).shadows[1]
  }
}, ownerState.clickable && ownerState.color !== "default" && {
  [`&:hover, &.${chipClasses$1.focusVisible}`]: {
    backgroundColor: (theme.vars || theme).palette[ownerState.color].dark
  }
}), ({
  theme,
  ownerState
}) => _extends$h({}, ownerState.variant === "outlined" && {
  backgroundColor: "transparent",
  border: theme.vars ? `1px solid ${theme.vars.palette.Chip.defaultBorder}` : `1px solid ${theme.palette.mode === "light" ? theme.palette.grey[400] : theme.palette.grey[700]}`,
  [`&.${chipClasses$1.clickable}:hover`]: {
    backgroundColor: (theme.vars || theme).palette.action.hover
  },
  [`&.${chipClasses$1.focusVisible}`]: {
    backgroundColor: (theme.vars || theme).palette.action.focus
  },
  [`& .${chipClasses$1.avatar}`]: {
    marginLeft: 4
  },
  [`& .${chipClasses$1.avatarSmall}`]: {
    marginLeft: 2
  },
  [`& .${chipClasses$1.icon}`]: {
    marginLeft: 4
  },
  [`& .${chipClasses$1.iconSmall}`]: {
    marginLeft: 2
  },
  [`& .${chipClasses$1.deleteIcon}`]: {
    marginRight: 5
  },
  [`& .${chipClasses$1.deleteIconSmall}`]: {
    marginRight: 3
  }
}, ownerState.variant === "outlined" && ownerState.color !== "default" && {
  color: (theme.vars || theme).palette[ownerState.color].main,
  border: `1px solid ${theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.7)` : alpha(theme.palette[ownerState.color].main, 0.7)}`,
  [`&.${chipClasses$1.clickable}:hover`]: {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity)
  },
  [`&.${chipClasses$1.focusVisible}`]: {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette[ownerState.color].main, theme.palette.action.focusOpacity)
  },
  [`& .${chipClasses$1.deleteIcon}`]: {
    color: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.7)` : alpha(theme.palette[ownerState.color].main, 0.7),
    "&:hover, &:active": {
      color: (theme.vars || theme).palette[ownerState.color].main
    }
  }
}));
const ChipLabel = styled("span", {
  name: "MuiChip",
  slot: "Label",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      size
    } = ownerState;
    return [styles2.label, styles2[`label${capitalize(size)}`]];
  }
})(({
  ownerState
}) => _extends$h({
  overflow: "hidden",
  textOverflow: "ellipsis",
  paddingLeft: 12,
  paddingRight: 12,
  whiteSpace: "nowrap"
}, ownerState.size === "small" && {
  paddingLeft: 8,
  paddingRight: 8
}));
function isDeleteKeyboardEvent(keyboardEvent) {
  return keyboardEvent.key === "Backspace" || keyboardEvent.key === "Delete";
}
const Chip = /* @__PURE__ */ reactExports.forwardRef(function Chip2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiChip"
  });
  const {
    avatar: avatarProp,
    className,
    clickable: clickableProp,
    color: color2 = "default",
    component: ComponentProp,
    deleteIcon: deleteIconProp,
    disabled = false,
    icon: iconProp,
    label: label2,
    onClick,
    onDelete,
    onKeyDown,
    onKeyUp,
    size = "medium",
    variant = "filled",
    tabIndex,
    skipFocusWhenDisabled = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$i);
  const chipRef = reactExports.useRef(null);
  const handleRef2 = useForkRef(chipRef, ref);
  const handleDeleteIconClick = (event) => {
    event.stopPropagation();
    if (onDelete) {
      onDelete(event);
    }
  };
  const handleKeyDown = (event) => {
    if (event.currentTarget === event.target && isDeleteKeyboardEvent(event)) {
      event.preventDefault();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  };
  const handleKeyUp = (event) => {
    if (event.currentTarget === event.target) {
      if (onDelete && isDeleteKeyboardEvent(event)) {
        onDelete(event);
      } else if (event.key === "Escape" && chipRef.current) {
        chipRef.current.blur();
      }
    }
    if (onKeyUp) {
      onKeyUp(event);
    }
  };
  const clickable2 = clickableProp !== false && onClick ? true : clickableProp;
  const component = clickable2 || onDelete ? ButtonBase : ComponentProp || "div";
  const ownerState = _extends$h({}, props, {
    component,
    disabled,
    size,
    color: color2,
    iconColor: /* @__PURE__ */ reactExports.isValidElement(iconProp) ? iconProp.props.color || color2 : color2,
    onDelete: !!onDelete,
    clickable: clickable2,
    variant
  });
  const classes = useUtilityClasses$6(ownerState);
  const moreProps = component === ButtonBase ? _extends$h({
    component: ComponentProp || "div",
    focusVisibleClassName: classes.focusVisible
  }, onDelete && {
    disableRipple: true
  }) : {};
  let deleteIcon2 = null;
  if (onDelete) {
    deleteIcon2 = deleteIconProp && /* @__PURE__ */ reactExports.isValidElement(deleteIconProp) ? /* @__PURE__ */ reactExports.cloneElement(deleteIconProp, {
      className: clsx(deleteIconProp.props.className, classes.deleteIcon),
      onClick: handleDeleteIconClick
    }) : /* @__PURE__ */ jsxRuntimeExports.jsx(CancelIcon, {
      className: clsx(classes.deleteIcon),
      onClick: handleDeleteIconClick
    });
  }
  let avatar = null;
  if (avatarProp && /* @__PURE__ */ reactExports.isValidElement(avatarProp)) {
    avatar = /* @__PURE__ */ reactExports.cloneElement(avatarProp, {
      className: clsx(classes.avatar, avatarProp.props.className)
    });
  }
  let icon = null;
  if (iconProp && /* @__PURE__ */ reactExports.isValidElement(iconProp)) {
    icon = /* @__PURE__ */ reactExports.cloneElement(iconProp, {
      className: clsx(classes.icon, iconProp.props.className)
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ChipRoot, _extends$h({
    as: component,
    className: clsx(classes.root, className),
    disabled: clickable2 && disabled ? true : void 0,
    onClick,
    onKeyDown: handleKeyDown,
    onKeyUp: handleKeyUp,
    ref: handleRef2,
    tabIndex: skipFocusWhenDisabled && disabled ? -1 : tabIndex,
    ownerState
  }, moreProps, other, {
    children: [avatar || icon, /* @__PURE__ */ jsxRuntimeExports.jsx(ChipLabel, {
      className: clsx(classes.label),
      ownerState,
      children: label2
    }), deleteIcon2]
  }));
});
const Chip$1 = Chip;
function getAutocompleteUtilityClass(slot) {
  return generateUtilityClass("MuiAutocomplete", slot);
}
const autocompleteClasses = generateUtilityClasses("MuiAutocomplete", ["root", "expanded", "fullWidth", "focused", "focusVisible", "tag", "tagSizeSmall", "tagSizeMedium", "hasPopupIcon", "hasClearIcon", "inputRoot", "input", "inputFocused", "endAdornment", "clearIndicator", "popupIndicator", "popupIndicatorOpen", "popper", "popperDisablePortal", "paper", "listbox", "loading", "noOptions", "option", "groupLabel", "groupUl"]);
const autocompleteClasses$1 = autocompleteClasses;
var _ClearIcon, _ArrowDropDownIcon;
const _excluded$h = ["autoComplete", "autoHighlight", "autoSelect", "blurOnSelect", "ChipProps", "className", "clearIcon", "clearOnBlur", "clearOnEscape", "clearText", "closeText", "componentsProps", "defaultValue", "disableClearable", "disableCloseOnSelect", "disabled", "disabledItemsFocusable", "disableListWrap", "disablePortal", "filterOptions", "filterSelectedOptions", "forcePopupIcon", "freeSolo", "fullWidth", "getLimitTagsText", "getOptionDisabled", "getOptionLabel", "isOptionEqualToValue", "groupBy", "handleHomeEndKeys", "id", "includeInputInList", "inputValue", "limitTags", "ListboxComponent", "ListboxProps", "loading", "loadingText", "multiple", "noOptionsText", "onChange", "onClose", "onHighlightChange", "onInputChange", "onOpen", "open", "openOnFocus", "openText", "options", "PaperComponent", "PopperComponent", "popupIcon", "readOnly", "renderGroup", "renderInput", "renderOption", "renderTags", "selectOnFocus", "size", "slotProps", "value"];
const useUtilityClasses$5 = (ownerState) => {
  const {
    classes,
    disablePortal,
    expanded,
    focused,
    fullWidth: fullWidth2,
    hasClearIcon,
    hasPopupIcon,
    inputFocused,
    popupOpen,
    size
  } = ownerState;
  const slots = {
    root: ["root", expanded && "expanded", focused && "focused", fullWidth2 && "fullWidth", hasClearIcon && "hasClearIcon", hasPopupIcon && "hasPopupIcon"],
    inputRoot: ["inputRoot"],
    input: ["input", inputFocused && "inputFocused"],
    tag: ["tag", `tagSize${capitalize(size)}`],
    endAdornment: ["endAdornment"],
    clearIndicator: ["clearIndicator"],
    popupIndicator: ["popupIndicator", popupOpen && "popupIndicatorOpen"],
    popper: ["popper", disablePortal && "popperDisablePortal"],
    paper: ["paper"],
    listbox: ["listbox"],
    loading: ["loading"],
    noOptions: ["noOptions"],
    option: ["option"],
    groupLabel: ["groupLabel"],
    groupUl: ["groupUl"]
  };
  return composeClasses(slots, getAutocompleteUtilityClass, classes);
};
const AutocompleteRoot = styled("div", {
  name: "MuiAutocomplete",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      fullWidth: fullWidth2,
      hasClearIcon,
      hasPopupIcon,
      inputFocused,
      size
    } = ownerState;
    return [{
      [`& .${autocompleteClasses$1.tag}`]: styles2.tag
    }, {
      [`& .${autocompleteClasses$1.tag}`]: styles2[`tagSize${capitalize(size)}`]
    }, {
      [`& .${autocompleteClasses$1.inputRoot}`]: styles2.inputRoot
    }, {
      [`& .${autocompleteClasses$1.input}`]: styles2.input
    }, {
      [`& .${autocompleteClasses$1.input}`]: inputFocused && styles2.inputFocused
    }, styles2.root, fullWidth2 && styles2.fullWidth, hasPopupIcon && styles2.hasPopupIcon, hasClearIcon && styles2.hasClearIcon];
  }
})(({
  ownerState
}) => _extends$h({
  [`&.${autocompleteClasses$1.focused} .${autocompleteClasses$1.clearIndicator}`]: {
    visibility: "visible"
  },
  /* Avoid double tap issue on iOS */
  "@media (pointer: fine)": {
    [`&:hover .${autocompleteClasses$1.clearIndicator}`]: {
      visibility: "visible"
    }
  }
}, ownerState.fullWidth && {
  width: "100%"
}, {
  [`& .${autocompleteClasses$1.tag}`]: _extends$h({
    margin: 3,
    maxWidth: "calc(100% - 6px)"
  }, ownerState.size === "small" && {
    margin: 2,
    maxWidth: "calc(100% - 4px)"
  }),
  [`& .${autocompleteClasses$1.inputRoot}`]: {
    flexWrap: "wrap",
    [`.${autocompleteClasses$1.hasPopupIcon}&, .${autocompleteClasses$1.hasClearIcon}&`]: {
      paddingRight: 26 + 4
    },
    [`.${autocompleteClasses$1.hasPopupIcon}.${autocompleteClasses$1.hasClearIcon}&`]: {
      paddingRight: 52 + 4
    },
    [`& .${autocompleteClasses$1.input}`]: {
      width: 0,
      minWidth: 30
    }
  },
  [`& .${inputClasses.root}`]: {
    paddingBottom: 1,
    "& .MuiInput-input": {
      padding: "4px 4px 4px 0px"
    }
  },
  [`& .${inputClasses.root}.${inputBaseClasses.sizeSmall}`]: {
    [`& .${inputClasses.input}`]: {
      padding: "2px 4px 3px 0"
    }
  },
  [`& .${outlinedInputClasses.root}`]: {
    padding: 9,
    [`.${autocompleteClasses$1.hasPopupIcon}&, .${autocompleteClasses$1.hasClearIcon}&`]: {
      paddingRight: 26 + 4 + 9
    },
    [`.${autocompleteClasses$1.hasPopupIcon}.${autocompleteClasses$1.hasClearIcon}&`]: {
      paddingRight: 52 + 4 + 9
    },
    [`& .${autocompleteClasses$1.input}`]: {
      padding: "7.5px 4px 7.5px 5px"
    },
    [`& .${autocompleteClasses$1.endAdornment}`]: {
      right: 9
    }
  },
  [`& .${outlinedInputClasses.root}.${inputBaseClasses.sizeSmall}`]: {
    // Don't specify paddingRight, as it overrides the default value set when there is only
    // one of the popup or clear icon as the specificity is equal so the latter one wins
    paddingTop: 6,
    paddingBottom: 6,
    paddingLeft: 6,
    [`& .${autocompleteClasses$1.input}`]: {
      padding: "2.5px 4px 2.5px 8px"
    }
  },
  [`& .${filledInputClasses.root}`]: {
    paddingTop: 19,
    paddingLeft: 8,
    [`.${autocompleteClasses$1.hasPopupIcon}&, .${autocompleteClasses$1.hasClearIcon}&`]: {
      paddingRight: 26 + 4 + 9
    },
    [`.${autocompleteClasses$1.hasPopupIcon}.${autocompleteClasses$1.hasClearIcon}&`]: {
      paddingRight: 52 + 4 + 9
    },
    [`& .${filledInputClasses.input}`]: {
      padding: "7px 4px"
    },
    [`& .${autocompleteClasses$1.endAdornment}`]: {
      right: 9
    }
  },
  [`& .${filledInputClasses.root}.${inputBaseClasses.sizeSmall}`]: {
    paddingBottom: 1,
    [`& .${filledInputClasses.input}`]: {
      padding: "2.5px 4px"
    }
  },
  [`& .${inputBaseClasses.hiddenLabel}`]: {
    paddingTop: 8
  },
  [`& .${filledInputClasses.root}.${inputBaseClasses.hiddenLabel}`]: {
    paddingTop: 0,
    paddingBottom: 0,
    [`& .${autocompleteClasses$1.input}`]: {
      paddingTop: 16,
      paddingBottom: 17
    }
  },
  [`& .${filledInputClasses.root}.${inputBaseClasses.hiddenLabel}.${inputBaseClasses.sizeSmall}`]: {
    [`& .${autocompleteClasses$1.input}`]: {
      paddingTop: 8,
      paddingBottom: 9
    }
  },
  [`& .${autocompleteClasses$1.input}`]: _extends$h({
    flexGrow: 1,
    textOverflow: "ellipsis",
    opacity: 0
  }, ownerState.inputFocused && {
    opacity: 1
  })
}));
const AutocompleteEndAdornment = styled("div", {
  name: "MuiAutocomplete",
  slot: "EndAdornment",
  overridesResolver: (props, styles2) => styles2.endAdornment
})({
  // We use a position absolute to support wrapping tags.
  position: "absolute",
  right: 0,
  top: "calc(50% - 14px)"
  // Center vertically
});
const AutocompleteClearIndicator = styled(IconButton, {
  name: "MuiAutocomplete",
  slot: "ClearIndicator",
  overridesResolver: (props, styles2) => styles2.clearIndicator
})({
  marginRight: -2,
  padding: 4,
  visibility: "hidden"
});
const AutocompletePopupIndicator = styled(IconButton, {
  name: "MuiAutocomplete",
  slot: "PopupIndicator",
  overridesResolver: ({
    ownerState
  }, styles2) => _extends$h({}, styles2.popupIndicator, ownerState.popupOpen && styles2.popupIndicatorOpen)
})(({
  ownerState
}) => _extends$h({
  padding: 2,
  marginRight: -2
}, ownerState.popupOpen && {
  transform: "rotate(180deg)"
}));
const AutocompletePopper = styled(Popper, {
  name: "MuiAutocomplete",
  slot: "Popper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${autocompleteClasses$1.option}`]: styles2.option
    }, styles2.popper, ownerState.disablePortal && styles2.popperDisablePortal];
  }
})(({
  theme,
  ownerState
}) => _extends$h({
  zIndex: (theme.vars || theme).zIndex.modal
}, ownerState.disablePortal && {
  position: "absolute"
}));
const AutocompletePaper = styled(Paper, {
  name: "MuiAutocomplete",
  slot: "Paper",
  overridesResolver: (props, styles2) => styles2.paper
})(({
  theme
}) => _extends$h({}, theme.typography.body1, {
  overflow: "auto"
}));
const AutocompleteLoading = styled("div", {
  name: "MuiAutocomplete",
  slot: "Loading",
  overridesResolver: (props, styles2) => styles2.loading
})(({
  theme
}) => ({
  color: (theme.vars || theme).palette.text.secondary,
  padding: "14px 16px"
}));
const AutocompleteNoOptions = styled("div", {
  name: "MuiAutocomplete",
  slot: "NoOptions",
  overridesResolver: (props, styles2) => styles2.noOptions
})(({
  theme
}) => ({
  color: (theme.vars || theme).palette.text.secondary,
  padding: "14px 16px"
}));
const AutocompleteListbox = styled("div", {
  name: "MuiAutocomplete",
  slot: "Listbox",
  overridesResolver: (props, styles2) => styles2.listbox
})(({
  theme
}) => ({
  listStyle: "none",
  margin: 0,
  padding: "8px 0",
  maxHeight: "40vh",
  overflow: "auto",
  position: "relative",
  [`& .${autocompleteClasses$1.option}`]: {
    minHeight: 48,
    display: "flex",
    overflow: "hidden",
    justifyContent: "flex-start",
    alignItems: "center",
    cursor: "pointer",
    paddingTop: 6,
    boxSizing: "border-box",
    outline: "0",
    WebkitTapHighlightColor: "transparent",
    paddingBottom: 6,
    paddingLeft: 16,
    paddingRight: 16,
    [theme.breakpoints.up("sm")]: {
      minHeight: "auto"
    },
    [`&.${autocompleteClasses$1.focused}`]: {
      backgroundColor: (theme.vars || theme).palette.action.hover,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    },
    '&[aria-disabled="true"]': {
      opacity: (theme.vars || theme).palette.action.disabledOpacity,
      pointerEvents: "none"
    },
    [`&.${autocompleteClasses$1.focusVisible}`]: {
      backgroundColor: (theme.vars || theme).palette.action.focus
    },
    '&[aria-selected="true"]': {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
      [`&.${autocompleteClasses$1.focused}`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: (theme.vars || theme).palette.action.selected
        }
      },
      [`&.${autocompleteClasses$1.focusVisible}`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
      }
    }
  }
}));
const AutocompleteGroupLabel = styled(ListSubheader$1, {
  name: "MuiAutocomplete",
  slot: "GroupLabel",
  overridesResolver: (props, styles2) => styles2.groupLabel
})(({
  theme
}) => ({
  backgroundColor: (theme.vars || theme).palette.background.paper,
  top: -8
}));
const AutocompleteGroupUl = styled("ul", {
  name: "MuiAutocomplete",
  slot: "GroupUl",
  overridesResolver: (props, styles2) => styles2.groupUl
})({
  padding: 0,
  [`& .${autocompleteClasses$1.option}`]: {
    paddingLeft: 24
  }
});
const Autocomplete = /* @__PURE__ */ reactExports.forwardRef(function Autocomplete2(inProps, ref) {
  var _slotProps$clearIndic, _slotProps$paper, _slotProps$popper, _slotProps$popupIndic;
  const props = useThemeProps({
    props: inProps,
    name: "MuiAutocomplete"
  });
  const {
    autoComplete = false,
    autoHighlight = false,
    autoSelect = false,
    blurOnSelect = false,
    ChipProps,
    className,
    clearIcon = _ClearIcon || (_ClearIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(ClearIcon, {
      fontSize: "small"
    })),
    clearOnBlur = !props.freeSolo,
    clearOnEscape = false,
    clearText = "Clear",
    closeText = "Close",
    componentsProps = {},
    defaultValue: defaultValue4 = props.multiple ? [] : null,
    disableClearable = false,
    disableCloseOnSelect = false,
    disabled = false,
    disabledItemsFocusable = false,
    disableListWrap = false,
    disablePortal = false,
    filterSelectedOptions = false,
    forcePopupIcon = "auto",
    freeSolo = false,
    fullWidth: fullWidth2 = false,
    getLimitTagsText = (more) => `+${more}`,
    getOptionLabel = (option) => {
      var _option$label;
      return (_option$label = option.label) != null ? _option$label : option;
    },
    groupBy,
    handleHomeEndKeys = !props.freeSolo,
    includeInputInList = false,
    limitTags = -1,
    ListboxComponent = "ul",
    ListboxProps,
    loading = false,
    loadingText = "Loading…",
    multiple = false,
    noOptionsText = "No options",
    openOnFocus = false,
    openText = "Open",
    PaperComponent = Paper,
    PopperComponent = Popper,
    popupIcon = _ArrowDropDownIcon || (_ArrowDropDownIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowDropDownIcon, {})),
    readOnly = false,
    renderGroup: renderGroupProp,
    renderInput,
    renderOption: renderOptionProp,
    renderTags,
    selectOnFocus = !props.freeSolo,
    size = "medium",
    slotProps = {}
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$h);
  const {
    getRootProps,
    getInputProps,
    getInputLabelProps,
    getPopupIndicatorProps,
    getClearProps,
    getTagProps,
    getListboxProps,
    getOptionProps,
    value,
    dirty,
    expanded,
    id,
    popupOpen,
    focused,
    focusedTag,
    anchorEl,
    setAnchorEl,
    inputValue: inputValue2,
    groupedOptions
  } = useAutocomplete(_extends$h({}, props, {
    componentName: "Autocomplete"
  }));
  const hasClearIcon = !disableClearable && !disabled && dirty && !readOnly;
  const hasPopupIcon = (!freeSolo || forcePopupIcon === true) && forcePopupIcon !== false;
  const {
    onMouseDown: handleInputMouseDown
  } = getInputProps();
  const ownerState = _extends$h({}, props, {
    disablePortal,
    expanded,
    focused,
    fullWidth: fullWidth2,
    hasClearIcon,
    hasPopupIcon,
    inputFocused: focusedTag === -1,
    popupOpen,
    size
  });
  const classes = useUtilityClasses$5(ownerState);
  let startAdornment;
  if (multiple && value.length > 0) {
    const getCustomizedTagProps = (params) => _extends$h({
      className: classes.tag,
      disabled
    }, getTagProps(params));
    if (renderTags) {
      startAdornment = renderTags(value, getCustomizedTagProps, ownerState);
    } else {
      startAdornment = value.map((option, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Chip$1, _extends$h({
        label: getOptionLabel(option),
        size
      }, getCustomizedTagProps({
        index: index2
      }), ChipProps)));
    }
  }
  if (limitTags > -1 && Array.isArray(startAdornment)) {
    const more = startAdornment.length - limitTags;
    if (!focused && more > 0) {
      startAdornment = startAdornment.splice(0, limitTags);
      startAdornment.push(/* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: classes.tag,
        children: getLimitTagsText(more)
      }, startAdornment.length));
    }
  }
  const defaultRenderGroup = (params) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteGroupLabel, {
      className: classes.groupLabel,
      ownerState,
      component: "div",
      children: params.group
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteGroupUl, {
      className: classes.groupUl,
      ownerState,
      children: params.children
    })]
  }, params.key);
  const renderGroup = renderGroupProp || defaultRenderGroup;
  const defaultRenderOption = (props2, option) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", _extends$h({}, props2, {
    children: getOptionLabel(option)
  }));
  const renderOption = renderOptionProp || defaultRenderOption;
  const renderListOption = (option, index2) => {
    const optionProps = getOptionProps({
      option,
      index: index2
    });
    return renderOption(_extends$h({}, optionProps, {
      className: classes.option
    }), option, {
      selected: optionProps["aria-selected"],
      index: index2,
      inputValue: inputValue2
    });
  };
  const clearIndicatorSlotProps = (_slotProps$clearIndic = slotProps.clearIndicator) != null ? _slotProps$clearIndic : componentsProps.clearIndicator;
  const paperSlotProps = (_slotProps$paper = slotProps.paper) != null ? _slotProps$paper : componentsProps.paper;
  const popperSlotProps = (_slotProps$popper = slotProps.popper) != null ? _slotProps$popper : componentsProps.popper;
  const popupIndicatorSlotProps = (_slotProps$popupIndic = slotProps.popupIndicator) != null ? _slotProps$popupIndic : componentsProps.popupIndicator;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteRoot, _extends$h({
      ref,
      className: clsx(classes.root, className),
      ownerState
    }, getRootProps(other), {
      children: renderInput({
        id,
        disabled,
        fullWidth: true,
        size: size === "small" ? "small" : void 0,
        InputLabelProps: getInputLabelProps(),
        InputProps: _extends$h({
          ref: setAnchorEl,
          className: classes.inputRoot,
          startAdornment,
          onClick: (event) => {
            if (event.target === event.currentTarget) {
              handleInputMouseDown(event);
            }
          }
        }, (hasClearIcon || hasPopupIcon) && {
          endAdornment: /* @__PURE__ */ jsxRuntimeExports.jsxs(AutocompleteEndAdornment, {
            className: classes.endAdornment,
            ownerState,
            children: [hasClearIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteClearIndicator, _extends$h({}, getClearProps(), {
              "aria-label": clearText,
              title: clearText,
              ownerState
            }, clearIndicatorSlotProps, {
              className: clsx(classes.clearIndicator, clearIndicatorSlotProps == null ? void 0 : clearIndicatorSlotProps.className),
              children: clearIcon
            })) : null, hasPopupIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompletePopupIndicator, _extends$h({}, getPopupIndicatorProps(), {
              disabled,
              "aria-label": popupOpen ? closeText : openText,
              title: popupOpen ? closeText : openText,
              ownerState
            }, popupIndicatorSlotProps, {
              className: clsx(classes.popupIndicator, popupIndicatorSlotProps == null ? void 0 : popupIndicatorSlotProps.className),
              children: popupIcon
            })) : null]
          })
        }),
        inputProps: _extends$h({
          className: classes.input,
          disabled,
          readOnly
        }, getInputProps())
      })
    })), anchorEl ? /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompletePopper, _extends$h({
      as: PopperComponent,
      disablePortal,
      style: {
        width: anchorEl ? anchorEl.clientWidth : null
      },
      ownerState,
      role: "presentation",
      anchorEl,
      open: popupOpen
    }, popperSlotProps, {
      className: clsx(classes.popper, popperSlotProps == null ? void 0 : popperSlotProps.className),
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(AutocompletePaper, _extends$h({
        ownerState,
        as: PaperComponent
      }, paperSlotProps, {
        className: clsx(classes.paper, paperSlotProps == null ? void 0 : paperSlotProps.className),
        children: [loading && groupedOptions.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteLoading, {
          className: classes.loading,
          ownerState,
          children: loadingText
        }) : null, groupedOptions.length === 0 && !freeSolo && !loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteNoOptions, {
          className: classes.noOptions,
          ownerState,
          role: "presentation",
          onMouseDown: (event) => {
            event.preventDefault();
          },
          children: noOptionsText
        }) : null, groupedOptions.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteListbox, _extends$h({
          as: ListboxComponent,
          className: classes.listbox,
          ownerState
        }, getListboxProps(), ListboxProps, {
          children: groupedOptions.map((option, index2) => {
            if (groupBy) {
              return renderGroup({
                key: option.key,
                group: option.group,
                children: option.options.map((option2, index22) => renderListOption(option2, option.index + index22))
              });
            }
            return renderListOption(option, index2);
          })
        })) : null]
      }))
    })) : null]
  });
});
const Autocomplete$1 = Autocomplete;
function getButtonGroupUtilityClass(slot) {
  return generateUtilityClass("MuiButtonGroup", slot);
}
const buttonGroupClasses = generateUtilityClasses("MuiButtonGroup", ["root", "contained", "outlined", "text", "disableElevation", "disabled", "fullWidth", "vertical", "grouped", "groupedHorizontal", "groupedVertical", "groupedText", "groupedTextHorizontal", "groupedTextVertical", "groupedTextPrimary", "groupedTextSecondary", "groupedOutlined", "groupedOutlinedHorizontal", "groupedOutlinedVertical", "groupedOutlinedPrimary", "groupedOutlinedSecondary", "groupedContained", "groupedContainedHorizontal", "groupedContainedVertical", "groupedContainedPrimary", "groupedContainedSecondary"]);
const buttonGroupClasses$1 = buttonGroupClasses;
const _excluded$g = ["children", "className", "color", "component", "disabled", "disableElevation", "disableFocusRipple", "disableRipple", "fullWidth", "orientation", "size", "variant"];
const overridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [{
    [`& .${buttonGroupClasses$1.grouped}`]: styles2.grouped
  }, {
    [`& .${buttonGroupClasses$1.grouped}`]: styles2[`grouped${capitalize(ownerState.orientation)}`]
  }, {
    [`& .${buttonGroupClasses$1.grouped}`]: styles2[`grouped${capitalize(ownerState.variant)}`]
  }, {
    [`& .${buttonGroupClasses$1.grouped}`]: styles2[`grouped${capitalize(ownerState.variant)}${capitalize(ownerState.orientation)}`]
  }, {
    [`& .${buttonGroupClasses$1.grouped}`]: styles2[`grouped${capitalize(ownerState.variant)}${capitalize(ownerState.color)}`]
  }, styles2.root, styles2[ownerState.variant], ownerState.disableElevation === true && styles2.disableElevation, ownerState.fullWidth && styles2.fullWidth, ownerState.orientation === "vertical" && styles2.vertical];
};
const useUtilityClasses$4 = (ownerState) => {
  const {
    classes,
    color: color2,
    disabled,
    disableElevation,
    fullWidth: fullWidth2,
    orientation,
    variant
  } = ownerState;
  const slots = {
    root: ["root", variant, orientation === "vertical" && "vertical", fullWidth2 && "fullWidth", disableElevation && "disableElevation"],
    grouped: ["grouped", `grouped${capitalize(orientation)}`, `grouped${capitalize(variant)}`, `grouped${capitalize(variant)}${capitalize(orientation)}`, `grouped${capitalize(variant)}${capitalize(color2)}`, disabled && "disabled"]
  };
  return composeClasses(slots, getButtonGroupUtilityClass, classes);
};
const ButtonGroupRoot = styled("div", {
  name: "MuiButtonGroup",
  slot: "Root",
  overridesResolver
})(({
  theme,
  ownerState
}) => _extends$h({
  display: "inline-flex",
  borderRadius: (theme.vars || theme).shape.borderRadius
}, ownerState.variant === "contained" && {
  boxShadow: (theme.vars || theme).shadows[2]
}, ownerState.disableElevation && {
  boxShadow: "none"
}, ownerState.fullWidth && {
  width: "100%"
}, ownerState.orientation === "vertical" && {
  flexDirection: "column"
}, {
  [`& .${buttonGroupClasses$1.grouped}`]: _extends$h({
    minWidth: 40,
    "&:not(:first-of-type)": _extends$h({}, ownerState.orientation === "horizontal" && {
      borderTopLeftRadius: 0,
      borderBottomLeftRadius: 0
    }, ownerState.orientation === "vertical" && {
      borderTopRightRadius: 0,
      borderTopLeftRadius: 0
    }, ownerState.variant === "outlined" && ownerState.orientation === "horizontal" && {
      marginLeft: -1
    }, ownerState.variant === "outlined" && ownerState.orientation === "vertical" && {
      marginTop: -1
    }),
    "&:not(:last-of-type)": _extends$h({}, ownerState.orientation === "horizontal" && {
      borderTopRightRadius: 0,
      borderBottomRightRadius: 0
    }, ownerState.orientation === "vertical" && {
      borderBottomRightRadius: 0,
      borderBottomLeftRadius: 0
    }, ownerState.variant === "text" && ownerState.orientation === "horizontal" && {
      borderRight: theme.vars ? `1px solid rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : `1px solid ${theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)"}`
    }, ownerState.variant === "text" && ownerState.orientation === "vertical" && {
      borderBottom: theme.vars ? `1px solid rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : `1px solid ${theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)"}`
    }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
      borderColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.5)` : alpha(theme.palette[ownerState.color].main, 0.5)
    }, ownerState.variant === "outlined" && ownerState.orientation === "horizontal" && {
      borderRightColor: "transparent"
    }, ownerState.variant === "outlined" && ownerState.orientation === "vertical" && {
      borderBottomColor: "transparent"
    }, ownerState.variant === "contained" && ownerState.orientation === "horizontal" && {
      borderRight: `1px solid ${(theme.vars || theme).palette.grey[400]}`,
      [`&.${buttonGroupClasses$1.disabled}`]: {
        borderRight: `1px solid ${(theme.vars || theme).palette.action.disabled}`
      }
    }, ownerState.variant === "contained" && ownerState.orientation === "vertical" && {
      borderBottom: `1px solid ${(theme.vars || theme).palette.grey[400]}`,
      [`&.${buttonGroupClasses$1.disabled}`]: {
        borderBottom: `1px solid ${(theme.vars || theme).palette.action.disabled}`
      }
    }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
      borderColor: (theme.vars || theme).palette[ownerState.color].dark
    }, {
      "&:hover": _extends$h({}, ownerState.variant === "outlined" && ownerState.orientation === "horizontal" && {
        borderRightColor: "currentColor"
      }, ownerState.variant === "outlined" && ownerState.orientation === "vertical" && {
        borderBottomColor: "currentColor"
      })
    }),
    "&:hover": _extends$h({}, ownerState.variant === "contained" && {
      boxShadow: "none"
    })
  }, ownerState.variant === "contained" && {
    boxShadow: "none"
  })
}));
const ButtonGroup = /* @__PURE__ */ reactExports.forwardRef(function ButtonGroup2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiButtonGroup"
  });
  const {
    children,
    className,
    color: color2 = "primary",
    component = "div",
    disabled = false,
    disableElevation = false,
    disableFocusRipple = false,
    disableRipple = false,
    fullWidth: fullWidth2 = false,
    orientation = "horizontal",
    size = "medium",
    variant = "outlined"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$g);
  const ownerState = _extends$h({}, props, {
    color: color2,
    component,
    disabled,
    disableElevation,
    disableFocusRipple,
    disableRipple,
    fullWidth: fullWidth2,
    orientation,
    size,
    variant
  });
  const classes = useUtilityClasses$4(ownerState);
  const context2 = reactExports.useMemo(() => ({
    className: classes.grouped,
    color: color2,
    disabled,
    disableElevation,
    disableFocusRipple,
    disableRipple,
    fullWidth: fullWidth2,
    size,
    variant
  }), [color2, disabled, disableElevation, disableFocusRipple, disableRipple, fullWidth2, size, variant, classes.grouped]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonGroupRoot, _extends$h({
    as: component,
    role: "group",
    className: clsx(classes.root, className),
    ref,
    ownerState
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonGroupContext.Provider, {
      value: context2,
      children
    })
  }));
});
const ButtonGroup$1 = ButtonGroup;
function getDialogContentTextUtilityClass(slot) {
  return generateUtilityClass("MuiDialogContentText", slot);
}
generateUtilityClasses("MuiDialogContentText", ["root"]);
const _excluded$f = ["children", "className"];
const useUtilityClasses$3 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  const composedClasses = composeClasses(slots, getDialogContentTextUtilityClass, classes);
  return _extends$h({}, classes, composedClasses);
};
const DialogContentTextRoot = styled(Typography, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiDialogContentText",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const DialogContentText = /* @__PURE__ */ reactExports.forwardRef(function DialogContentText2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDialogContentText"
  });
  const {
    className
  } = props, ownerState = _objectWithoutPropertiesLoose(props, _excluded$f);
  const classes = useUtilityClasses$3(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentTextRoot, _extends$h({
    component: "p",
    variant: "body1",
    color: "text.secondary",
    ref,
    ownerState,
    className: clsx(classes.root, className)
  }, props, {
    classes
  }));
});
const DialogContentText$1 = DialogContentText;
const _excluded$e = ["children", "className", "disableTypography", "inset", "primary", "primaryTypographyProps", "secondary", "secondaryTypographyProps"];
const useUtilityClasses$2 = (ownerState) => {
  const {
    classes,
    inset,
    primary,
    secondary,
    dense
  } = ownerState;
  const slots = {
    root: ["root", inset && "inset", dense && "dense", primary && secondary && "multiline"],
    primary: ["primary"],
    secondary: ["secondary"]
  };
  return composeClasses(slots, getListItemTextUtilityClass, classes);
};
const ListItemTextRoot = styled("div", {
  name: "MuiListItemText",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${listItemTextClasses.primary}`]: styles2.primary
    }, {
      [`& .${listItemTextClasses.secondary}`]: styles2.secondary
    }, styles2.root, ownerState.inset && styles2.inset, ownerState.primary && ownerState.secondary && styles2.multiline, ownerState.dense && styles2.dense];
  }
})(({
  ownerState
}) => _extends$h({
  flex: "1 1 auto",
  minWidth: 0,
  marginTop: 4,
  marginBottom: 4
}, ownerState.primary && ownerState.secondary && {
  marginTop: 6,
  marginBottom: 6
}, ownerState.inset && {
  paddingLeft: 56
}));
const ListItemText = /* @__PURE__ */ reactExports.forwardRef(function ListItemText2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiListItemText"
  });
  const {
    children,
    className,
    disableTypography = false,
    inset = false,
    primary: primaryProp,
    primaryTypographyProps,
    secondary: secondaryProp,
    secondaryTypographyProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$e);
  const {
    dense
  } = reactExports.useContext(ListContext);
  let primary = primaryProp != null ? primaryProp : children;
  let secondary = secondaryProp;
  const ownerState = _extends$h({}, props, {
    disableTypography,
    inset,
    primary: !!primary,
    secondary: !!secondary,
    dense
  });
  const classes = useUtilityClasses$2(ownerState);
  if (primary != null && primary.type !== Typography && !disableTypography) {
    primary = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, _extends$h({
      variant: dense ? "body2" : "body1",
      className: classes.primary,
      component: primaryTypographyProps != null && primaryTypographyProps.variant ? void 0 : "span",
      display: "block"
    }, primaryTypographyProps, {
      children: primary
    }));
  }
  if (secondary != null && secondary.type !== Typography && !disableTypography) {
    secondary = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, _extends$h({
      variant: "body2",
      className: classes.secondary,
      color: "text.secondary",
      display: "block"
    }, secondaryTypographyProps, {
      children: secondary
    }));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItemTextRoot, _extends$h({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other, {
    children: [primary, secondary]
  }));
});
const ListItemText$1 = ListItemText;
const shouldSpreadAdditionalProps = (Slot) => {
  return !Slot || !isHostComponent(Slot);
};
const shouldSpreadAdditionalProps$1 = shouldSpreadAdditionalProps;
function getSliderUtilityClass(slot) {
  return generateUtilityClass("MuiSlider", slot);
}
const sliderClasses = generateUtilityClasses("MuiSlider", ["root", "active", "colorPrimary", "colorSecondary", "disabled", "dragging", "focusVisible", "mark", "markActive", "marked", "markLabel", "markLabelActive", "rail", "sizeSmall", "thumb", "thumbColorPrimary", "thumbColorSecondary", "track", "trackInverted", "trackFalse", "thumbSizeSmall", "valueLabel", "valueLabelOpen", "valueLabelCircle", "valueLabelLabel", "vertical"]);
const sliderClasses$1 = sliderClasses;
const useValueLabelClasses = (props) => {
  const {
    open
  } = props;
  const utilityClasses = {
    offset: clsx(open && sliderClasses$1.valueLabelOpen),
    circle: sliderClasses$1.valueLabelCircle,
    label: sliderClasses$1.valueLabelLabel
  };
  return utilityClasses;
};
function SliderValueLabel(props) {
  const {
    children,
    className,
    value
  } = props;
  const classes = useValueLabelClasses(props);
  if (!children) {
    return null;
  }
  return /* @__PURE__ */ reactExports.cloneElement(children, {
    className: clsx(children.props.className)
  }, /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [children.props.children, /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: clsx(classes.offset, className),
      "aria-hidden": true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: classes.circle,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: classes.label,
          children: value
        })
      })
    })]
  }));
}
const _excluded$d = ["aria-label", "aria-valuetext", "aria-labelledby", "component", "components", "componentsProps", "color", "classes", "className", "disableSwap", "disabled", "getAriaLabel", "getAriaValueText", "marks", "max", "min", "name", "onChange", "onChangeCommitted", "orientation", "size", "step", "scale", "slotProps", "slots", "tabIndex", "track", "value", "valueLabelDisplay", "valueLabelFormat"];
function Identity(x) {
  return x;
}
const SliderRoot = styled("span", {
  name: "MuiSlider",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`color${capitalize(ownerState.color)}`], ownerState.size !== "medium" && styles2[`size${capitalize(ownerState.size)}`], ownerState.marked && styles2.marked, ownerState.orientation === "vertical" && styles2.vertical, ownerState.track === "inverted" && styles2.trackInverted, ownerState.track === false && styles2.trackFalse];
  }
})(({
  theme,
  ownerState
}) => _extends$h({
  borderRadius: 12,
  boxSizing: "content-box",
  display: "inline-block",
  position: "relative",
  cursor: "pointer",
  touchAction: "none",
  color: (theme.vars || theme).palette[ownerState.color].main,
  WebkitTapHighlightColor: "transparent"
}, ownerState.orientation === "horizontal" && _extends$h({
  height: 4,
  width: "100%",
  padding: "13px 0",
  // The primary input mechanism of the device includes a pointing device of limited accuracy.
  "@media (pointer: coarse)": {
    // Reach 42px touch target, about ~8mm on screen.
    padding: "20px 0"
  }
}, ownerState.size === "small" && {
  height: 2
}, ownerState.marked && {
  marginBottom: 20
}), ownerState.orientation === "vertical" && _extends$h({
  height: "100%",
  width: 4,
  padding: "0 13px",
  // The primary input mechanism of the device includes a pointing device of limited accuracy.
  "@media (pointer: coarse)": {
    // Reach 42px touch target, about ~8mm on screen.
    padding: "0 20px"
  }
}, ownerState.size === "small" && {
  width: 2
}, ownerState.marked && {
  marginRight: 44
}), {
  "@media print": {
    colorAdjust: "exact"
  },
  [`&.${sliderClasses$1.disabled}`]: {
    pointerEvents: "none",
    cursor: "default",
    color: (theme.vars || theme).palette.grey[400]
  },
  [`&.${sliderClasses$1.dragging}`]: {
    [`& .${sliderClasses$1.thumb}, & .${sliderClasses$1.track}`]: {
      transition: "none"
    }
  }
}));
const SliderRail = styled("span", {
  name: "MuiSlider",
  slot: "Rail",
  overridesResolver: (props, styles2) => styles2.rail
})(({
  ownerState
}) => _extends$h({
  display: "block",
  position: "absolute",
  borderRadius: "inherit",
  backgroundColor: "currentColor",
  opacity: 0.38
}, ownerState.orientation === "horizontal" && {
  width: "100%",
  height: "inherit",
  top: "50%",
  transform: "translateY(-50%)"
}, ownerState.orientation === "vertical" && {
  height: "100%",
  width: "inherit",
  left: "50%",
  transform: "translateX(-50%)"
}, ownerState.track === "inverted" && {
  opacity: 1
}));
const SliderTrack = styled("span", {
  name: "MuiSlider",
  slot: "Track",
  overridesResolver: (props, styles2) => styles2.track
})(({
  theme,
  ownerState
}) => {
  const color2 = (
    // Same logic as the LinearProgress track color
    theme.palette.mode === "light" ? lighten(theme.palette[ownerState.color].main, 0.62) : darken(theme.palette[ownerState.color].main, 0.5)
  );
  return _extends$h({
    display: "block",
    position: "absolute",
    borderRadius: "inherit",
    border: "1px solid currentColor",
    backgroundColor: "currentColor",
    transition: theme.transitions.create(["left", "width", "bottom", "height"], {
      duration: theme.transitions.duration.shortest
    })
  }, ownerState.size === "small" && {
    border: "none"
  }, ownerState.orientation === "horizontal" && {
    height: "inherit",
    top: "50%",
    transform: "translateY(-50%)"
  }, ownerState.orientation === "vertical" && {
    width: "inherit",
    left: "50%",
    transform: "translateX(-50%)"
  }, ownerState.track === false && {
    display: "none"
  }, ownerState.track === "inverted" && {
    backgroundColor: theme.vars ? theme.vars.palette.Slider[`${ownerState.color}Track`] : color2,
    borderColor: theme.vars ? theme.vars.palette.Slider[`${ownerState.color}Track`] : color2
  });
});
const SliderThumb = styled("span", {
  name: "MuiSlider",
  slot: "Thumb",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.thumb, styles2[`thumbColor${capitalize(ownerState.color)}`], ownerState.size !== "medium" && styles2[`thumbSize${capitalize(ownerState.size)}`]];
  }
})(({
  theme,
  ownerState
}) => _extends$h({
  position: "absolute",
  width: 20,
  height: 20,
  boxSizing: "border-box",
  borderRadius: "50%",
  outline: 0,
  backgroundColor: "currentColor",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  transition: theme.transitions.create(["box-shadow", "left", "bottom"], {
    duration: theme.transitions.duration.shortest
  })
}, ownerState.size === "small" && {
  width: 12,
  height: 12
}, ownerState.orientation === "horizontal" && {
  top: "50%",
  transform: "translate(-50%, -50%)"
}, ownerState.orientation === "vertical" && {
  left: "50%",
  transform: "translate(-50%, 50%)"
}, {
  "&:before": _extends$h({
    position: "absolute",
    content: '""',
    borderRadius: "inherit",
    width: "100%",
    height: "100%",
    boxShadow: (theme.vars || theme).shadows[2]
  }, ownerState.size === "small" && {
    boxShadow: "none"
  }),
  "&::after": {
    position: "absolute",
    content: '""',
    borderRadius: "50%",
    // 42px is the hit target
    width: 42,
    height: 42,
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)"
  },
  [`&:hover, &.${sliderClasses$1.focusVisible}`]: {
    boxShadow: `0px 0px 0px 8px ${theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.16)` : alpha(theme.palette[ownerState.color].main, 0.16)}`,
    "@media (hover: none)": {
      boxShadow: "none"
    }
  },
  [`&.${sliderClasses$1.active}`]: {
    boxShadow: `0px 0px 0px 14px ${theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.16)` : alpha(theme.palette[ownerState.color].main, 0.16)}`
  },
  [`&.${sliderClasses$1.disabled}`]: {
    "&:hover": {
      boxShadow: "none"
    }
  }
}));
const StyledSliderValueLabel = styled(SliderValueLabel, {
  name: "MuiSlider",
  slot: "ValueLabel",
  overridesResolver: (props, styles2) => styles2.valueLabel
})(({
  theme,
  ownerState
}) => _extends$h({
  [`&.${sliderClasses$1.valueLabelOpen}`]: {
    transform: `${ownerState.orientation === "vertical" ? "translateY(-50%)" : "translateY(-100%)"} scale(1)`
  },
  zIndex: 1,
  whiteSpace: "nowrap"
}, theme.typography.body2, {
  fontWeight: 500,
  transition: theme.transitions.create(["transform"], {
    duration: theme.transitions.duration.shortest
  }),
  transform: `${ownerState.orientation === "vertical" ? "translateY(-50%)" : "translateY(-100%)"} scale(0)`,
  position: "absolute",
  backgroundColor: (theme.vars || theme).palette.grey[600],
  borderRadius: 2,
  color: (theme.vars || theme).palette.common.white,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  padding: "0.25rem 0.75rem"
}, ownerState.orientation === "horizontal" && {
  top: "-10px",
  transformOrigin: "bottom center",
  "&:before": {
    position: "absolute",
    content: '""',
    width: 8,
    height: 8,
    transform: "translate(-50%, 50%) rotate(45deg)",
    backgroundColor: "inherit",
    bottom: 0,
    left: "50%"
  }
}, ownerState.orientation === "vertical" && {
  right: ownerState.size === "small" ? "20px" : "30px",
  top: "50%",
  transformOrigin: "right center",
  "&:before": {
    position: "absolute",
    content: '""',
    width: 8,
    height: 8,
    transform: "translate(-50%, -50%) rotate(45deg)",
    backgroundColor: "inherit",
    right: "-20%",
    top: "50%"
  }
}, ownerState.size === "small" && {
  fontSize: theme.typography.pxToRem(12),
  padding: "0.25rem 0.5rem"
}));
const SliderMark = styled("span", {
  name: "MuiSlider",
  slot: "Mark",
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "markActive",
  overridesResolver: (props, styles2) => {
    const {
      markActive
    } = props;
    return [styles2.mark, markActive && styles2.markActive];
  }
})(({
  theme,
  ownerState,
  markActive
}) => _extends$h({
  position: "absolute",
  width: 2,
  height: 2,
  borderRadius: 1,
  backgroundColor: "currentColor"
}, ownerState.orientation === "horizontal" && {
  top: "50%",
  transform: "translate(-1px, -50%)"
}, ownerState.orientation === "vertical" && {
  left: "50%",
  transform: "translate(-50%, 1px)"
}, markActive && {
  backgroundColor: (theme.vars || theme).palette.background.paper,
  opacity: 0.8
}));
const SliderMarkLabel = styled("span", {
  name: "MuiSlider",
  slot: "MarkLabel",
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "markLabelActive",
  overridesResolver: (props, styles2) => styles2.markLabel
})(({
  theme,
  ownerState,
  markLabelActive
}) => _extends$h({}, theme.typography.body2, {
  color: (theme.vars || theme).palette.text.secondary,
  position: "absolute",
  whiteSpace: "nowrap"
}, ownerState.orientation === "horizontal" && {
  top: 30,
  transform: "translateX(-50%)",
  "@media (pointer: coarse)": {
    top: 40
  }
}, ownerState.orientation === "vertical" && {
  left: 36,
  transform: "translateY(50%)",
  "@media (pointer: coarse)": {
    left: 44
  }
}, markLabelActive && {
  color: (theme.vars || theme).palette.text.primary
}));
const useUtilityClasses$1 = (ownerState) => {
  const {
    disabled,
    dragging,
    marked,
    orientation,
    track,
    classes,
    color: color2,
    size
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", dragging && "dragging", marked && "marked", orientation === "vertical" && "vertical", track === "inverted" && "trackInverted", track === false && "trackFalse", color2 && `color${capitalize(color2)}`, size && `size${capitalize(size)}`],
    rail: ["rail"],
    track: ["track"],
    mark: ["mark"],
    markActive: ["markActive"],
    markLabel: ["markLabel"],
    markLabelActive: ["markLabelActive"],
    valueLabel: ["valueLabel"],
    thumb: ["thumb", disabled && "disabled", size && `thumbSize${capitalize(size)}`, color2 && `thumbColor${capitalize(color2)}`],
    active: ["active"],
    disabled: ["disabled"],
    focusVisible: ["focusVisible"]
  };
  return composeClasses(slots, getSliderUtilityClass, classes);
};
const Forward = ({
  children
}) => children;
const Slider$1 = /* @__PURE__ */ reactExports.forwardRef(function Slider(inputProps, ref) {
  var _ref, _slots$root, _ref2, _slots$rail, _ref3, _slots$track, _ref4, _slots$thumb, _ref5, _slots$valueLabel, _ref6, _slots$mark, _ref7, _slots$markLabel, _ref8, _slots$input, _slotProps$root, _slotProps$rail, _slotProps$track, _slotProps$thumb, _slotProps$valueLabel, _slotProps$mark, _slotProps$markLabel, _slotProps$input;
  const props = useThemeProps({
    props: inputProps,
    name: "MuiSlider"
  });
  const theme = useTheme();
  const isRtl = theme.direction === "rtl";
  const {
    "aria-label": ariaLabel,
    "aria-valuetext": ariaValuetext,
    "aria-labelledby": ariaLabelledby,
    // eslint-disable-next-line react/prop-types
    component = "span",
    components = {},
    componentsProps = {},
    color: color2 = "primary",
    classes: classesProp,
    className,
    disableSwap = false,
    disabled = false,
    getAriaLabel,
    getAriaValueText,
    marks: marksProp = false,
    max: max2 = 100,
    min: min2 = 0,
    orientation = "horizontal",
    size = "medium",
    step = 1,
    scale = Identity,
    slotProps,
    slots,
    track = "normal",
    valueLabelDisplay = "off",
    valueLabelFormat = Identity
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$d);
  const ownerState = _extends$h({}, props, {
    isRtl,
    max: max2,
    min: min2,
    classes: classesProp,
    disabled,
    disableSwap,
    orientation,
    marks: marksProp,
    color: color2,
    size,
    step,
    scale,
    track,
    valueLabelDisplay,
    valueLabelFormat
  });
  const {
    axisProps: axisProps2,
    getRootProps,
    getHiddenInputProps,
    getThumbProps,
    open,
    active: active3,
    axis,
    focusedThumbIndex,
    range: range2,
    dragging,
    marks,
    values,
    trackOffset,
    trackLeap
  } = useSlider(_extends$h({}, ownerState, {
    ref
  }));
  ownerState.marked = marks.length > 0 && marks.some((mark) => mark.label);
  ownerState.dragging = dragging;
  ownerState.focusedThumbIndex = focusedThumbIndex;
  const classes = useUtilityClasses$1(ownerState);
  const RootSlot = (_ref = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components.Root) != null ? _ref : SliderRoot;
  const RailSlot = (_ref2 = (_slots$rail = slots == null ? void 0 : slots.rail) != null ? _slots$rail : components.Rail) != null ? _ref2 : SliderRail;
  const TrackSlot = (_ref3 = (_slots$track = slots == null ? void 0 : slots.track) != null ? _slots$track : components.Track) != null ? _ref3 : SliderTrack;
  const ThumbSlot = (_ref4 = (_slots$thumb = slots == null ? void 0 : slots.thumb) != null ? _slots$thumb : components.Thumb) != null ? _ref4 : SliderThumb;
  const ValueLabelSlot = (_ref5 = (_slots$valueLabel = slots == null ? void 0 : slots.valueLabel) != null ? _slots$valueLabel : components.ValueLabel) != null ? _ref5 : StyledSliderValueLabel;
  const MarkSlot = (_ref6 = (_slots$mark = slots == null ? void 0 : slots.mark) != null ? _slots$mark : components.Mark) != null ? _ref6 : SliderMark;
  const MarkLabelSlot = (_ref7 = (_slots$markLabel = slots == null ? void 0 : slots.markLabel) != null ? _slots$markLabel : components.MarkLabel) != null ? _ref7 : SliderMarkLabel;
  const InputSlot = (_ref8 = (_slots$input = slots == null ? void 0 : slots.input) != null ? _slots$input : components.Input) != null ? _ref8 : "input";
  const rootSlotProps = (_slotProps$root = slotProps == null ? void 0 : slotProps.root) != null ? _slotProps$root : componentsProps.root;
  const railSlotProps = (_slotProps$rail = slotProps == null ? void 0 : slotProps.rail) != null ? _slotProps$rail : componentsProps.rail;
  const trackSlotProps = (_slotProps$track = slotProps == null ? void 0 : slotProps.track) != null ? _slotProps$track : componentsProps.track;
  const thumbSlotProps = (_slotProps$thumb = slotProps == null ? void 0 : slotProps.thumb) != null ? _slotProps$thumb : componentsProps.thumb;
  const valueLabelSlotProps = (_slotProps$valueLabel = slotProps == null ? void 0 : slotProps.valueLabel) != null ? _slotProps$valueLabel : componentsProps.valueLabel;
  const markSlotProps = (_slotProps$mark = slotProps == null ? void 0 : slotProps.mark) != null ? _slotProps$mark : componentsProps.mark;
  const markLabelSlotProps = (_slotProps$markLabel = slotProps == null ? void 0 : slotProps.markLabel) != null ? _slotProps$markLabel : componentsProps.markLabel;
  const inputSlotProps = (_slotProps$input = slotProps == null ? void 0 : slotProps.input) != null ? _slotProps$input : componentsProps.input;
  const rootProps = useSlotProps({
    elementType: RootSlot,
    getSlotProps: getRootProps,
    externalSlotProps: rootSlotProps,
    externalForwardedProps: other,
    additionalProps: _extends$h({}, shouldSpreadAdditionalProps$1(RootSlot) && {
      as: component
    }),
    ownerState: _extends$h({}, ownerState, rootSlotProps == null ? void 0 : rootSlotProps.ownerState),
    className: [classes.root, className]
  });
  const railProps = useSlotProps({
    elementType: RailSlot,
    externalSlotProps: railSlotProps,
    ownerState,
    className: classes.rail
  });
  const trackProps = useSlotProps({
    elementType: TrackSlot,
    externalSlotProps: trackSlotProps,
    additionalProps: {
      style: _extends$h({}, axisProps2[axis].offset(trackOffset), axisProps2[axis].leap(trackLeap))
    },
    ownerState: _extends$h({}, ownerState, trackSlotProps == null ? void 0 : trackSlotProps.ownerState),
    className: classes.track
  });
  const thumbProps = useSlotProps({
    elementType: ThumbSlot,
    getSlotProps: getThumbProps,
    externalSlotProps: thumbSlotProps,
    ownerState: _extends$h({}, ownerState, thumbSlotProps == null ? void 0 : thumbSlotProps.ownerState),
    className: classes.thumb
  });
  const valueLabelProps = useSlotProps({
    elementType: ValueLabelSlot,
    externalSlotProps: valueLabelSlotProps,
    ownerState: _extends$h({}, ownerState, valueLabelSlotProps == null ? void 0 : valueLabelSlotProps.ownerState),
    className: classes.valueLabel
  });
  const markProps = useSlotProps({
    elementType: MarkSlot,
    externalSlotProps: markSlotProps,
    ownerState,
    className: classes.mark
  });
  const markLabelProps = useSlotProps({
    elementType: MarkLabelSlot,
    externalSlotProps: markLabelSlotProps,
    ownerState,
    className: classes.markLabel
  });
  const inputSliderProps = useSlotProps({
    elementType: InputSlot,
    getSlotProps: getHiddenInputProps,
    externalSlotProps: inputSlotProps,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, _extends$h({}, rootProps, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(RailSlot, _extends$h({}, railProps)), /* @__PURE__ */ jsxRuntimeExports.jsx(TrackSlot, _extends$h({}, trackProps)), marks.filter((mark) => mark.value >= min2 && mark.value <= max2).map((mark, index2) => {
      const percent = valueToPercent(mark.value, min2, max2);
      const style = axisProps2[axis].offset(percent);
      let markActive;
      if (track === false) {
        markActive = values.indexOf(mark.value) !== -1;
      } else {
        markActive = track === "normal" && (range2 ? mark.value >= values[0] && mark.value <= values[values.length - 1] : mark.value <= values[0]) || track === "inverted" && (range2 ? mark.value <= values[0] || mark.value >= values[values.length - 1] : mark.value >= values[0]);
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(MarkSlot, _extends$h({
          "data-index": index2
        }, markProps, !isHostComponent(MarkSlot) && {
          markActive
        }, {
          style: _extends$h({}, style, markProps.style),
          className: clsx(markProps.className, markActive && classes.markActive)
        })), mark.label != null ? /* @__PURE__ */ jsxRuntimeExports.jsx(MarkLabelSlot, _extends$h({
          "aria-hidden": true,
          "data-index": index2
        }, markLabelProps, !isHostComponent(MarkLabelSlot) && {
          markLabelActive: markActive
        }, {
          style: _extends$h({}, style, markLabelProps.style),
          className: clsx(classes.markLabel, markLabelProps.className, markActive && classes.markLabelActive),
          children: mark.label
        })) : null]
      }, index2);
    }), values.map((value, index2) => {
      const percent = valueToPercent(value, min2, max2);
      const style = axisProps2[axis].offset(percent);
      const ValueLabelComponent = valueLabelDisplay === "off" ? Forward : ValueLabelSlot;
      return (
        /* TODO v6: Change component structure. It will help in avoiding the complicated React.cloneElement API added in SliderValueLabel component. Should be: Thumb -> Input, ValueLabel. Follow Joy UI's Slider structure. */
        /* @__PURE__ */ jsxRuntimeExports.jsx(ValueLabelComponent, _extends$h({}, !isHostComponent(ValueLabelComponent) && {
          valueLabelFormat,
          valueLabelDisplay,
          value: typeof valueLabelFormat === "function" ? valueLabelFormat(scale(value), index2) : valueLabelFormat,
          index: index2,
          open: open === index2 || active3 === index2 || valueLabelDisplay === "on",
          disabled
        }, valueLabelProps, {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThumbSlot, _extends$h({
            "data-index": index2
          }, thumbProps, {
            className: clsx(classes.thumb, thumbProps.className, active3 === index2 && classes.active, focusedThumbIndex === index2 && classes.focusVisible),
            style: _extends$h({}, style, {
              pointerEvents: disableSwap && active3 !== index2 ? "none" : void 0
            }, thumbProps.style),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(InputSlot, _extends$h({
              "data-index": index2,
              "aria-label": getAriaLabel ? getAriaLabel(index2) : ariaLabel,
              "aria-valuenow": scale(value),
              "aria-labelledby": ariaLabelledby,
              "aria-valuetext": getAriaValueText ? getAriaValueText(scale(value), index2) : ariaValuetext,
              value: values[index2]
            }, inputSliderProps))
          }))
        }), index2)
      );
    })]
  }));
});
const Slider$2 = Slider$1;
function getTooltipUtilityClass(slot) {
  return generateUtilityClass("MuiTooltip", slot);
}
const tooltipClasses = generateUtilityClasses("MuiTooltip", ["popper", "popperInteractive", "popperArrow", "popperClose", "tooltip", "tooltipArrow", "touch", "tooltipPlacementLeft", "tooltipPlacementRight", "tooltipPlacementTop", "tooltipPlacementBottom", "arrow"]);
const tooltipClasses$1 = tooltipClasses;
const _excluded$c = ["arrow", "children", "classes", "components", "componentsProps", "describeChild", "disableFocusListener", "disableHoverListener", "disableInteractive", "disableTouchListener", "enterDelay", "enterNextDelay", "enterTouchDelay", "followCursor", "id", "leaveDelay", "leaveTouchDelay", "onClose", "onOpen", "open", "placement", "PopperComponent", "PopperProps", "slotProps", "slots", "title", "TransitionComponent", "TransitionProps"];
function round$1(value) {
  return Math.round(value * 1e5) / 1e5;
}
const useUtilityClasses = (ownerState) => {
  const {
    classes,
    disableInteractive,
    arrow,
    touch,
    placement
  } = ownerState;
  const slots = {
    popper: ["popper", !disableInteractive && "popperInteractive", arrow && "popperArrow"],
    tooltip: ["tooltip", arrow && "tooltipArrow", touch && "touch", `tooltipPlacement${capitalize(placement.split("-")[0])}`],
    arrow: ["arrow"]
  };
  return composeClasses(slots, getTooltipUtilityClass, classes);
};
const TooltipPopper = styled(Popper, {
  name: "MuiTooltip",
  slot: "Popper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.popper, !ownerState.disableInteractive && styles2.popperInteractive, ownerState.arrow && styles2.popperArrow, !ownerState.open && styles2.popperClose];
  }
})(({
  theme,
  ownerState,
  open
}) => _extends$h({
  zIndex: (theme.vars || theme).zIndex.tooltip,
  pointerEvents: "none"
}, !ownerState.disableInteractive && {
  pointerEvents: "auto"
}, !open && {
  pointerEvents: "none"
}, ownerState.arrow && {
  [`&[data-popper-placement*="bottom"] .${tooltipClasses$1.arrow}`]: {
    top: 0,
    marginTop: "-0.71em",
    "&::before": {
      transformOrigin: "0 100%"
    }
  },
  [`&[data-popper-placement*="top"] .${tooltipClasses$1.arrow}`]: {
    bottom: 0,
    marginBottom: "-0.71em",
    "&::before": {
      transformOrigin: "100% 0"
    }
  },
  [`&[data-popper-placement*="right"] .${tooltipClasses$1.arrow}`]: _extends$h({}, !ownerState.isRtl ? {
    left: 0,
    marginLeft: "-0.71em"
  } : {
    right: 0,
    marginRight: "-0.71em"
  }, {
    height: "1em",
    width: "0.71em",
    "&::before": {
      transformOrigin: "100% 100%"
    }
  }),
  [`&[data-popper-placement*="left"] .${tooltipClasses$1.arrow}`]: _extends$h({}, !ownerState.isRtl ? {
    right: 0,
    marginRight: "-0.71em"
  } : {
    left: 0,
    marginLeft: "-0.71em"
  }, {
    height: "1em",
    width: "0.71em",
    "&::before": {
      transformOrigin: "0 0"
    }
  })
}));
const TooltipTooltip = styled("div", {
  name: "MuiTooltip",
  slot: "Tooltip",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.tooltip, ownerState.touch && styles2.touch, ownerState.arrow && styles2.tooltipArrow, styles2[`tooltipPlacement${capitalize(ownerState.placement.split("-")[0])}`]];
  }
})(({
  theme,
  ownerState
}) => _extends$h({
  backgroundColor: theme.vars ? theme.vars.palette.Tooltip.bg : alpha(theme.palette.grey[700], 0.92),
  borderRadius: (theme.vars || theme).shape.borderRadius,
  color: (theme.vars || theme).palette.common.white,
  fontFamily: theme.typography.fontFamily,
  padding: "4px 8px",
  fontSize: theme.typography.pxToRem(11),
  maxWidth: 300,
  margin: 2,
  wordWrap: "break-word",
  fontWeight: theme.typography.fontWeightMedium
}, ownerState.arrow && {
  position: "relative",
  margin: 0
}, ownerState.touch && {
  padding: "8px 16px",
  fontSize: theme.typography.pxToRem(14),
  lineHeight: `${round$1(16 / 14)}em`,
  fontWeight: theme.typography.fontWeightRegular
}, {
  [`.${tooltipClasses$1.popper}[data-popper-placement*="left"] &`]: _extends$h({
    transformOrigin: "right center"
  }, !ownerState.isRtl ? _extends$h({
    marginRight: "14px"
  }, ownerState.touch && {
    marginRight: "24px"
  }) : _extends$h({
    marginLeft: "14px"
  }, ownerState.touch && {
    marginLeft: "24px"
  })),
  [`.${tooltipClasses$1.popper}[data-popper-placement*="right"] &`]: _extends$h({
    transformOrigin: "left center"
  }, !ownerState.isRtl ? _extends$h({
    marginLeft: "14px"
  }, ownerState.touch && {
    marginLeft: "24px"
  }) : _extends$h({
    marginRight: "14px"
  }, ownerState.touch && {
    marginRight: "24px"
  })),
  [`.${tooltipClasses$1.popper}[data-popper-placement*="top"] &`]: _extends$h({
    transformOrigin: "center bottom",
    marginBottom: "14px"
  }, ownerState.touch && {
    marginBottom: "24px"
  }),
  [`.${tooltipClasses$1.popper}[data-popper-placement*="bottom"] &`]: _extends$h({
    transformOrigin: "center top",
    marginTop: "14px"
  }, ownerState.touch && {
    marginTop: "24px"
  })
}));
const TooltipArrow = styled("span", {
  name: "MuiTooltip",
  slot: "Arrow",
  overridesResolver: (props, styles2) => styles2.arrow
})(({
  theme
}) => ({
  overflow: "hidden",
  position: "absolute",
  width: "1em",
  height: "0.71em",
  boxSizing: "border-box",
  color: theme.vars ? theme.vars.palette.Tooltip.bg : alpha(theme.palette.grey[700], 0.9),
  "&::before": {
    content: '""',
    margin: "auto",
    display: "block",
    width: "100%",
    height: "100%",
    backgroundColor: "currentColor",
    transform: "rotate(45deg)"
  }
}));
let hystersisOpen = false;
let hystersisTimer = null;
let cursorPosition = {
  x: 0,
  y: 0
};
function composeEventHandler(handler, eventHandler) {
  return (event) => {
    if (eventHandler) {
      eventHandler(event);
    }
    handler(event);
  };
}
const Tooltip = /* @__PURE__ */ reactExports.forwardRef(function Tooltip2(inProps, ref) {
  var _ref, _slots$popper, _ref2, _ref3, _slots$transition, _ref4, _slots$tooltip, _ref5, _slots$arrow, _slotProps$popper, _ref6, _slotProps$popper2, _slotProps$transition, _slotProps$tooltip, _ref7, _slotProps$tooltip2, _slotProps$arrow, _ref8, _slotProps$arrow2;
  const props = useThemeProps({
    props: inProps,
    name: "MuiTooltip"
  });
  const {
    arrow = false,
    children,
    components = {},
    componentsProps = {},
    describeChild = false,
    disableFocusListener = false,
    disableHoverListener = false,
    disableInteractive: disableInteractiveProp = false,
    disableTouchListener = false,
    enterDelay = 100,
    enterNextDelay = 0,
    enterTouchDelay = 700,
    followCursor = false,
    id: idProp,
    leaveDelay = 0,
    leaveTouchDelay = 1500,
    onClose,
    onOpen,
    open: openProp,
    placement = "bottom",
    PopperComponent: PopperComponentProp,
    PopperProps = {},
    slotProps = {},
    slots = {},
    title: title2,
    TransitionComponent: TransitionComponentProp = Grow,
    TransitionProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$c);
  const theme = useTheme();
  const isRtl = theme.direction === "rtl";
  const [childNode, setChildNode] = reactExports.useState();
  const [arrowRef, setArrowRef] = reactExports.useState(null);
  const ignoreNonTouchEvents = reactExports.useRef(false);
  const disableInteractive = disableInteractiveProp || followCursor;
  const closeTimer = reactExports.useRef();
  const enterTimer = reactExports.useRef();
  const leaveTimer = reactExports.useRef();
  const touchTimer = reactExports.useRef();
  const [openState, setOpenState] = useControlled({
    controlled: openProp,
    default: false,
    name: "Tooltip",
    state: "open"
  });
  let open = openState;
  const id = useId(idProp);
  const prevUserSelect = reactExports.useRef();
  const stopTouchInteraction = reactExports.useCallback(() => {
    if (prevUserSelect.current !== void 0) {
      document.body.style.WebkitUserSelect = prevUserSelect.current;
      prevUserSelect.current = void 0;
    }
    clearTimeout(touchTimer.current);
  }, []);
  reactExports.useEffect(() => {
    return () => {
      clearTimeout(closeTimer.current);
      clearTimeout(enterTimer.current);
      clearTimeout(leaveTimer.current);
      stopTouchInteraction();
    };
  }, [stopTouchInteraction]);
  const handleOpen = (event) => {
    clearTimeout(hystersisTimer);
    hystersisOpen = true;
    setOpenState(true);
    if (onOpen && !open) {
      onOpen(event);
    }
  };
  const handleClose = useEventCallback(
    /**
     * @param {React.SyntheticEvent | Event} event
     */
    (event) => {
      clearTimeout(hystersisTimer);
      hystersisTimer = setTimeout(() => {
        hystersisOpen = false;
      }, 800 + leaveDelay);
      setOpenState(false);
      if (onClose && open) {
        onClose(event);
      }
      clearTimeout(closeTimer.current);
      closeTimer.current = setTimeout(() => {
        ignoreNonTouchEvents.current = false;
      }, theme.transitions.duration.shortest);
    }
  );
  const handleEnter = (event) => {
    if (ignoreNonTouchEvents.current && event.type !== "touchstart") {
      return;
    }
    if (childNode) {
      childNode.removeAttribute("title");
    }
    clearTimeout(enterTimer.current);
    clearTimeout(leaveTimer.current);
    if (enterDelay || hystersisOpen && enterNextDelay) {
      enterTimer.current = setTimeout(() => {
        handleOpen(event);
      }, hystersisOpen ? enterNextDelay : enterDelay);
    } else {
      handleOpen(event);
    }
  };
  const handleLeave = (event) => {
    clearTimeout(enterTimer.current);
    clearTimeout(leaveTimer.current);
    leaveTimer.current = setTimeout(() => {
      handleClose(event);
    }, leaveDelay);
  };
  const {
    isFocusVisibleRef,
    onBlur: handleBlurVisible,
    onFocus: handleFocusVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [, setChildIsFocusVisible] = reactExports.useState(false);
  const handleBlur = (event) => {
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setChildIsFocusVisible(false);
      handleLeave(event);
    }
  };
  const handleFocus3 = (event) => {
    if (!childNode) {
      setChildNode(event.currentTarget);
    }
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      setChildIsFocusVisible(true);
      handleEnter(event);
    }
  };
  const detectTouchStart = (event) => {
    ignoreNonTouchEvents.current = true;
    const childrenProps2 = children.props;
    if (childrenProps2.onTouchStart) {
      childrenProps2.onTouchStart(event);
    }
  };
  const handleMouseOver = handleEnter;
  const handleMouseLeave = handleLeave;
  const handleTouchStart = (event) => {
    detectTouchStart(event);
    clearTimeout(leaveTimer.current);
    clearTimeout(closeTimer.current);
    stopTouchInteraction();
    prevUserSelect.current = document.body.style.WebkitUserSelect;
    document.body.style.WebkitUserSelect = "none";
    touchTimer.current = setTimeout(() => {
      document.body.style.WebkitUserSelect = prevUserSelect.current;
      handleEnter(event);
    }, enterTouchDelay);
  };
  const handleTouchEnd = (event) => {
    if (children.props.onTouchEnd) {
      children.props.onTouchEnd(event);
    }
    stopTouchInteraction();
    clearTimeout(leaveTimer.current);
    leaveTimer.current = setTimeout(() => {
      handleClose(event);
    }, leaveTouchDelay);
  };
  reactExports.useEffect(() => {
    if (!open) {
      return void 0;
    }
    function handleKeyDown(nativeEvent) {
      if (nativeEvent.key === "Escape" || nativeEvent.key === "Esc") {
        handleClose(nativeEvent);
      }
    }
    document.addEventListener("keydown", handleKeyDown);
    return () => {
      document.removeEventListener("keydown", handleKeyDown);
    };
  }, [handleClose, open]);
  const handleRef2 = useForkRef(children.ref, focusVisibleRef, setChildNode, ref);
  if (!title2 && title2 !== 0) {
    open = false;
  }
  const popperRef = reactExports.useRef();
  const handleMouseMove = (event) => {
    const childrenProps2 = children.props;
    if (childrenProps2.onMouseMove) {
      childrenProps2.onMouseMove(event);
    }
    cursorPosition = {
      x: event.clientX,
      y: event.clientY
    };
    if (popperRef.current) {
      popperRef.current.update();
    }
  };
  const nameOrDescProps = {};
  const titleIsString = typeof title2 === "string";
  if (describeChild) {
    nameOrDescProps.title = !open && titleIsString && !disableHoverListener ? title2 : null;
    nameOrDescProps["aria-describedby"] = open ? id : null;
  } else {
    nameOrDescProps["aria-label"] = titleIsString ? title2 : null;
    nameOrDescProps["aria-labelledby"] = open && !titleIsString ? id : null;
  }
  const childrenProps = _extends$h({}, nameOrDescProps, other, children.props, {
    className: clsx(other.className, children.props.className),
    onTouchStart: detectTouchStart,
    ref: handleRef2
  }, followCursor ? {
    onMouseMove: handleMouseMove
  } : {});
  const interactiveWrapperListeners = {};
  if (!disableTouchListener) {
    childrenProps.onTouchStart = handleTouchStart;
    childrenProps.onTouchEnd = handleTouchEnd;
  }
  if (!disableHoverListener) {
    childrenProps.onMouseOver = composeEventHandler(handleMouseOver, childrenProps.onMouseOver);
    childrenProps.onMouseLeave = composeEventHandler(handleMouseLeave, childrenProps.onMouseLeave);
    if (!disableInteractive) {
      interactiveWrapperListeners.onMouseOver = handleMouseOver;
      interactiveWrapperListeners.onMouseLeave = handleMouseLeave;
    }
  }
  if (!disableFocusListener) {
    childrenProps.onFocus = composeEventHandler(handleFocus3, childrenProps.onFocus);
    childrenProps.onBlur = composeEventHandler(handleBlur, childrenProps.onBlur);
    if (!disableInteractive) {
      interactiveWrapperListeners.onFocus = handleFocus3;
      interactiveWrapperListeners.onBlur = handleBlur;
    }
  }
  const popperOptions = reactExports.useMemo(() => {
    var _PopperProps$popperOp;
    let tooltipModifiers = [{
      name: "arrow",
      enabled: Boolean(arrowRef),
      options: {
        element: arrowRef,
        padding: 4
      }
    }];
    if ((_PopperProps$popperOp = PopperProps.popperOptions) != null && _PopperProps$popperOp.modifiers) {
      tooltipModifiers = tooltipModifiers.concat(PopperProps.popperOptions.modifiers);
    }
    return _extends$h({}, PopperProps.popperOptions, {
      modifiers: tooltipModifiers
    });
  }, [arrowRef, PopperProps]);
  const ownerState = _extends$h({}, props, {
    isRtl,
    arrow,
    disableInteractive,
    placement,
    PopperComponentProp,
    touch: ignoreNonTouchEvents.current
  });
  const classes = useUtilityClasses(ownerState);
  const PopperComponent = (_ref = (_slots$popper = slots.popper) != null ? _slots$popper : components.Popper) != null ? _ref : TooltipPopper;
  const TransitionComponent = (_ref2 = (_ref3 = (_slots$transition = slots.transition) != null ? _slots$transition : components.Transition) != null ? _ref3 : TransitionComponentProp) != null ? _ref2 : Grow;
  const TooltipComponent = (_ref4 = (_slots$tooltip = slots.tooltip) != null ? _slots$tooltip : components.Tooltip) != null ? _ref4 : TooltipTooltip;
  const ArrowComponent = (_ref5 = (_slots$arrow = slots.arrow) != null ? _slots$arrow : components.Arrow) != null ? _ref5 : TooltipArrow;
  const popperProps = appendOwnerState(PopperComponent, _extends$h({}, PopperProps, (_slotProps$popper = slotProps.popper) != null ? _slotProps$popper : componentsProps.popper, {
    className: clsx(classes.popper, PopperProps == null ? void 0 : PopperProps.className, (_ref6 = (_slotProps$popper2 = slotProps.popper) != null ? _slotProps$popper2 : componentsProps.popper) == null ? void 0 : _ref6.className)
  }), ownerState);
  const transitionProps = appendOwnerState(TransitionComponent, _extends$h({}, TransitionProps, (_slotProps$transition = slotProps.transition) != null ? _slotProps$transition : componentsProps.transition), ownerState);
  const tooltipProps = appendOwnerState(TooltipComponent, _extends$h({}, (_slotProps$tooltip = slotProps.tooltip) != null ? _slotProps$tooltip : componentsProps.tooltip, {
    className: clsx(classes.tooltip, (_ref7 = (_slotProps$tooltip2 = slotProps.tooltip) != null ? _slotProps$tooltip2 : componentsProps.tooltip) == null ? void 0 : _ref7.className)
  }), ownerState);
  const tooltipArrowProps = appendOwnerState(ArrowComponent, _extends$h({}, (_slotProps$arrow = slotProps.arrow) != null ? _slotProps$arrow : componentsProps.arrow, {
    className: clsx(classes.arrow, (_ref8 = (_slotProps$arrow2 = slotProps.arrow) != null ? _slotProps$arrow2 : componentsProps.arrow) == null ? void 0 : _ref8.className)
  }), ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ reactExports.cloneElement(children, childrenProps), /* @__PURE__ */ jsxRuntimeExports.jsx(PopperComponent, _extends$h({
      as: PopperComponentProp != null ? PopperComponentProp : Popper,
      placement,
      anchorEl: followCursor ? {
        getBoundingClientRect: () => ({
          top: cursorPosition.y,
          left: cursorPosition.x,
          right: cursorPosition.x,
          bottom: cursorPosition.y,
          width: 0,
          height: 0
        })
      } : childNode,
      popperRef,
      open: childNode ? open : false,
      id,
      transition: true
    }, interactiveWrapperListeners, popperProps, {
      popperOptions,
      children: ({
        TransitionProps: TransitionPropsInner
      }) => /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$h({
        timeout: theme.transitions.duration.shorter
      }, TransitionPropsInner, transitionProps, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TooltipComponent, _extends$h({}, tooltipProps, {
          children: [title2, arrow ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowComponent, _extends$h({}, tooltipArrowProps, {
            ref: setArrowRef
          })) : null]
        }))
      }))
    }))]
  });
});
const Tooltip$1 = Tooltip;
const EditOutlined = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "m14.06 9.02.92.92L5.92 19H5v-.92l9.06-9.06M17.66 3c-.25 0-.51.1-.7.29l-1.83 1.83 3.75 3.75 1.83-1.83c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.2-.2-.45-.29-.71-.29zm-3.6 3.19L3 17.25V21h3.75L17.81 9.94l-3.75-3.75z"
}), "EditOutlined");
const PreviewOutlined = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm0 16H5V7h14v12zm-7-8.5c1.84 0 3.48.96 4.34 2.5-.86 1.54-2.5 2.5-4.34 2.5s-3.48-.96-4.34-2.5c.86-1.54 2.5-2.5 4.34-2.5M12 9c-2.73 0-5.06 1.66-6 4 .94 2.34 3.27 4 6 4s5.06-1.66 6-4c-.94-2.34-3.27-4-6-4zm0 5.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"
}), "PreviewOutlined");
const mainContainer = "_mainContainer_1qlrg_1";
const updateButtons = "_updateButtons_1qlrg_9";
const save = "_save_1qlrg_18";
const styles$M = {
  mainContainer,
  updateButtons,
  save
};
var ViewCompact = {};
var _interopRequireDefault$w = interopRequireDefaultExports;
Object.defineProperty(ViewCompact, "__esModule", {
  value: true
});
var default_1$o = ViewCompact.default = void 0;
var _createSvgIcon$o = _interopRequireDefault$w(requireCreateSvgIcon());
var _jsxRuntime$o = jsxRuntimeExports;
var _default$r = (0, _createSvgIcon$o.default)(/* @__PURE__ */ (0, _jsxRuntime$o.jsx)("path", {
  d: "M4 18h2.5v-2.5H4V18zm0-4.75h2.5v-2.5H4v2.5zM4 8.5h2.5V6H4v2.5zM17.5 6v2.5H20V6h-2.5zM13 8.5h2.5V6H13v2.5zm4.5 9.5H20v-2.5h-2.5V18zm0-4.75H20v-2.5h-2.5v2.5zM8.5 18H11v-2.5H8.5V18zm4.5 0h2.5v-2.5H13V18zM8.5 8.5H11V6H8.5v2.5zm4.5 4.75h2.5v-2.5H13v2.5zm-4.5 0H11v-2.5H8.5v2.5z"
}), "ViewCompact");
default_1$o = ViewCompact.default = _default$r;
const questionItem$6 = "_questionItem_wb37f_1";
const styles$L = {
  questionItem: questionItem$6
};
function TextQuestionDesign({ code }) {
  var _a, _b, _c, _d;
  const theme = useTheme();
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const lang2 = useSelector((state2) => {
    return state2.designState.langInfo.lang;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$L.questionItem, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    TextField,
    {
      disabled: true,
      variant: "standard",
      required: ((_b = (_a = state.validation) == null ? void 0 : _a.validation_required) == null ? void 0 : _b.isActive) ? true : false,
      label: state.showHint && (((_d = (_c = state.content) == null ? void 0 : _c.hint) == null ? void 0 : _d[lang2]) || ""),
      value: "",
      InputProps: {
        sx: {
          fontFamily: theme.textStyles.text.font,
          color: theme.textStyles.text.color,
          fontSize: theme.textStyles.text.size
        }
      }
    }
  ) });
}
const questionItem$5 = "_questionItem_1sx0f_1";
const styles$K = {
  questionItem: questionItem$5
};
function EmailQuestionDesign({ code }) {
  var _a, _b, _c, _d;
  const theme = useTheme();
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const lang2 = useSelector((state2) => {
    return state2.designState.langInfo.lang;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$K.questionItem, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    TextField,
    {
      disabled: true,
      variant: "standard",
      required: ((_b = (_a = state.validation) == null ? void 0 : _a.validation_required) == null ? void 0 : _b.isActive) ? true : false,
      label: state.showHint && (((_d = (_c = state.content) == null ? void 0 : _c.hint) == null ? void 0 : _d[lang2]) || ""),
      InputProps: {
        sx: {
          fontFamily: theme.textStyles.text.font,
          color: theme.textStyles.text.color,
          fontSize: theme.textStyles.text.size
        }
      },
      value: ""
    }
  ) });
}
const questionItem$4 = "_questionItem_169qj_1";
const styles$J = {
  questionItem: questionItem$4
};
function NumberQuestionDesign({ code }) {
  var _a, _b, _c, _d;
  const theme = useTheme();
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const lang2 = useSelector((state2) => {
    return state2.designState.langInfo.lang;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$J.questionItem, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    TextField,
    {
      disabled: true,
      variant: "standard",
      required: ((_b = (_a = state.validation) == null ? void 0 : _a.validation_required) == null ? void 0 : _b.isActive) ? true : false,
      label: state.showHint && (((_d = (_c = state.content) == null ? void 0 : _c.hint) == null ? void 0 : _d[lang2]) || ""),
      value: "",
      InputProps: {
        sx: {
          fontFamily: theme.textStyles.text.font,
          color: theme.textStyles.text.color,
          fontSize: theme.textStyles.text.size
        }
      }
    }
  ) });
}
const questionItem$3 = "_questionItem_13fbu_1";
const paragraph = "_paragraph_13fbu_15";
const wordCount = "_wordCount_13fbu_19";
const styles$I = {
  questionItem: questionItem$3,
  paragraph,
  wordCount
};
function ParagraphQuestionDesign({ code, t: t2 }) {
  var _a, _b, _c, _d;
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const lang2 = useSelector((state2) => {
    return state2.designState.langInfo.lang;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$I.questionItem, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextareaAutosize,
      {
        disabled: true,
        className: styles$I.paragraph,
        required: ((_b = (_a = state.validation) == null ? void 0 : _a.validation_required) == null ? void 0 : _b.isActive) ? true : false,
        placeholder: state.showHint && (((_d = (_c = state.content) == null ? void 0 : _c.hint) == null ? void 0 : _d[lang2]) || ""),
        minRows: state.minRows || 2,
        value: ""
      }
    ),
    state.showWordCount ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$I.wordCount, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("word_count", { lng: lang2, count: 0 }) }) }) : ""
  ] });
}
const textDescriptionContent = "_textDescriptionContent_meegl_1";
const groupQuestion = "_groupQuestion_meegl_7";
const titleQuestion = "_titleQuestion_meegl_19";
const questionWrapper = "_questionWrapper_meegl_28";
const inputQuestionTitle = "_inputQuestionTitle_meegl_32";
const inputQuestionDescription = "_inputQuestionDescription_meegl_38";
const moveBox$1 = "_moveBox_meegl_42";
const styles$H = {
  textDescriptionContent,
  groupQuestion,
  titleQuestion,
  questionWrapper,
  inputQuestionTitle,
  inputQuestionDescription,
  moveBox: moveBox$1
};
const fullWidth = "_fullWidth_1dvff_1";
const toolbarClass = "_toolbarClass_1dvff_6";
const noPadding = "_noPadding_1dvff_12";
const placeholder$2 = "_placeholder_1dvff_25";
const styles$G = {
  fullWidth,
  toolbarClass,
  "rdw-editor-toolbar": "_rdw-editor-toolbar_1dvff_6",
  noPadding,
  placeholder: placeholder$2
};
const ContentEditor$3 = "";
const quill_snow = "";
function listCacheClear$2() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$2;
function eq$6(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$6;
var eq$5 = eq_1;
function assocIndexOf$5(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$5(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$5;
var assocIndexOf$4 = _assocIndexOf;
var arrayProto$1 = Array.prototype;
var splice$1 = arrayProto$1.splice;
function listCacheDelete$2(key) {
  var data = this.__data__, index2 = assocIndexOf$4(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice$1.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$2;
var assocIndexOf$3 = _assocIndexOf;
function listCacheGet$2(key) {
  var data = this.__data__, index2 = assocIndexOf$3(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var _listCacheGet = listCacheGet$2;
var assocIndexOf$2 = _assocIndexOf;
function listCacheHas$2(key) {
  return assocIndexOf$2(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$2;
var assocIndexOf$1 = _assocIndexOf;
function listCacheSet$2(key, value) {
  var data = this.__data__, index2 = assocIndexOf$1(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$2;
var listCacheClear$1 = _listCacheClear, listCacheDelete$1 = _listCacheDelete, listCacheGet$1 = _listCacheGet, listCacheHas$1 = _listCacheHas, listCacheSet$1 = _listCacheSet;
function ListCache$5(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$5.prototype.clear = listCacheClear$1;
ListCache$5.prototype["delete"] = listCacheDelete$1;
ListCache$5.prototype.get = listCacheGet$1;
ListCache$5.prototype.has = listCacheHas$1;
ListCache$5.prototype.set = listCacheSet$1;
var _ListCache = ListCache$5;
var ListCache$4 = _ListCache;
function stackClear$2() {
  this.__data__ = new ListCache$4();
  this.size = 0;
}
var _stackClear = stackClear$2;
function stackDelete$2(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$2;
function stackGet$2(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$2;
function stackHas$2(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$2;
var freeGlobal$3 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$3;
var freeGlobal$2 = _freeGlobal;
var freeSelf$1 = typeof self == "object" && self && self.Object === Object && self;
var root$b = freeGlobal$2 || freeSelf$1 || Function("return this")();
var _root = root$b;
var root$a = _root;
var Symbol$9 = root$a.Symbol;
var _Symbol = Symbol$9;
var Symbol$8 = _Symbol;
var objectProto$u = Object.prototype;
var hasOwnProperty$o = objectProto$u.hasOwnProperty;
var nativeObjectToString$3 = objectProto$u.toString;
var symToStringTag$3 = Symbol$8 ? Symbol$8.toStringTag : void 0;
function getRawTag$2(value) {
  var isOwn = hasOwnProperty$o.call(value, symToStringTag$3), tag = value[symToStringTag$3];
  try {
    value[symToStringTag$3] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$3.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$3] = tag;
    } else {
      delete value[symToStringTag$3];
    }
  }
  return result;
}
var _getRawTag = getRawTag$2;
var objectProto$t = Object.prototype;
var nativeObjectToString$2 = objectProto$t.toString;
function objectToString$2(value) {
  return nativeObjectToString$2.call(value);
}
var _objectToString = objectToString$2;
var Symbol$7 = _Symbol, getRawTag$1 = _getRawTag, objectToString$1 = _objectToString;
var nullTag$1 = "[object Null]", undefinedTag$1 = "[object Undefined]";
var symToStringTag$2 = Symbol$7 ? Symbol$7.toStringTag : void 0;
function baseGetTag$8(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag$1 : nullTag$1;
  }
  return symToStringTag$2 && symToStringTag$2 in Object(value) ? getRawTag$1(value) : objectToString$1(value);
}
var _baseGetTag = baseGetTag$8;
function isObject$h(value) {
  var type2 = typeof value;
  return value != null && (type2 == "object" || type2 == "function");
}
var isObject_1 = isObject$h;
var baseGetTag$7 = _baseGetTag, isObject$g = isObject_1;
var asyncTag$1 = "[object AsyncFunction]", funcTag$4 = "[object Function]", genTag$2 = "[object GeneratorFunction]", proxyTag$1 = "[object Proxy]";
function isFunction$5(value) {
  if (!isObject$g(value)) {
    return false;
  }
  var tag = baseGetTag$7(value);
  return tag == funcTag$4 || tag == genTag$2 || tag == asyncTag$1 || tag == proxyTag$1;
}
var isFunction_1 = isFunction$5;
var root$9 = _root;
var coreJsData$3 = root$9["__core-js_shared__"];
var _coreJsData = coreJsData$3;
var coreJsData$2 = _coreJsData;
var maskSrcKey$1 = function() {
  var uid = /[^.]+$/.exec(coreJsData$2 && coreJsData$2.keys && coreJsData$2.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$2(func) {
  return !!maskSrcKey$1 && maskSrcKey$1 in func;
}
var _isMasked = isMasked$2;
var funcProto$5 = Function.prototype;
var funcToString$5 = funcProto$5.toString;
function toSource$3(func) {
  if (func != null) {
    try {
      return funcToString$5.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var _toSource = toSource$3;
var isFunction$4 = isFunction_1, isMasked$1 = _isMasked, isObject$f = isObject_1, toSource$2 = _toSource;
var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;
var funcProto$4 = Function.prototype, objectProto$s = Object.prototype;
var funcToString$4 = funcProto$4.toString;
var hasOwnProperty$n = objectProto$s.hasOwnProperty;
var reIsNative$1 = RegExp(
  "^" + funcToString$4.call(hasOwnProperty$n).replace(reRegExpChar$1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$2(value) {
  if (!isObject$f(value) || isMasked$1(value)) {
    return false;
  }
  var pattern = isFunction$4(value) ? reIsNative$1 : reIsHostCtor$1;
  return pattern.test(toSource$2(value));
}
var _baseIsNative = baseIsNative$2;
function getValue$2(object, key) {
  return object == null ? void 0 : object[key];
}
var _getValue = getValue$2;
var baseIsNative$1 = _baseIsNative, getValue$1 = _getValue;
function getNative$8(object, key) {
  var value = getValue$1(object, key);
  return baseIsNative$1(value) ? value : void 0;
}
var _getNative = getNative$8;
var getNative$7 = _getNative, root$8 = _root;
var Map$6 = getNative$7(root$8, "Map");
var _Map = Map$6;
var getNative$6 = _getNative;
var nativeCreate$6 = getNative$6(Object, "create");
var _nativeCreate = nativeCreate$6;
var nativeCreate$5 = _nativeCreate;
function hashClear$2() {
  this.__data__ = nativeCreate$5 ? nativeCreate$5(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$2;
function hashDelete$2(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$2;
var nativeCreate$4 = _nativeCreate;
var HASH_UNDEFINED$5 = "__lodash_hash_undefined__";
var objectProto$r = Object.prototype;
var hasOwnProperty$m = objectProto$r.hasOwnProperty;
function hashGet$2(key) {
  var data = this.__data__;
  if (nativeCreate$4) {
    var result = data[key];
    return result === HASH_UNDEFINED$5 ? void 0 : result;
  }
  return hasOwnProperty$m.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$2;
var nativeCreate$3 = _nativeCreate;
var objectProto$q = Object.prototype;
var hasOwnProperty$l = objectProto$q.hasOwnProperty;
function hashHas$2(key) {
  var data = this.__data__;
  return nativeCreate$3 ? data[key] !== void 0 : hasOwnProperty$l.call(data, key);
}
var _hashHas = hashHas$2;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$4 = "__lodash_hash_undefined__";
function hashSet$2(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate$2 && value === void 0 ? HASH_UNDEFINED$4 : value;
  return this;
}
var _hashSet = hashSet$2;
var hashClear$1 = _hashClear, hashDelete$1 = _hashDelete, hashGet$1 = _hashGet, hashHas$1 = _hashHas, hashSet$1 = _hashSet;
function Hash$2(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$2.prototype.clear = hashClear$1;
Hash$2.prototype["delete"] = hashDelete$1;
Hash$2.prototype.get = hashGet$1;
Hash$2.prototype.has = hashHas$1;
Hash$2.prototype.set = hashSet$1;
var _Hash = Hash$2;
var Hash$1 = _Hash, ListCache$3 = _ListCache, Map$5 = _Map;
function mapCacheClear$2() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash$1(),
    "map": new (Map$5 || ListCache$3)(),
    "string": new Hash$1()
  };
}
var _mapCacheClear = mapCacheClear$2;
function isKeyable$2(value) {
  var type2 = typeof value;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$2;
var isKeyable$1 = _isKeyable;
function getMapData$5(map2, key) {
  var data = map2.__data__;
  return isKeyable$1(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$5;
var getMapData$4 = _getMapData;
function mapCacheDelete$2(key) {
  var result = getMapData$4(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$2;
var getMapData$3 = _getMapData;
function mapCacheGet$2(key) {
  return getMapData$3(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$2;
var getMapData$2 = _getMapData;
function mapCacheHas$2(key) {
  return getMapData$2(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$2;
var getMapData$1 = _getMapData;
function mapCacheSet$2(key, value) {
  var data = getMapData$1(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$2;
var mapCacheClear$1 = _mapCacheClear, mapCacheDelete$1 = _mapCacheDelete, mapCacheGet$1 = _mapCacheGet, mapCacheHas$1 = _mapCacheHas, mapCacheSet$1 = _mapCacheSet;
function MapCache$4(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$4.prototype.clear = mapCacheClear$1;
MapCache$4.prototype["delete"] = mapCacheDelete$1;
MapCache$4.prototype.get = mapCacheGet$1;
MapCache$4.prototype.has = mapCacheHas$1;
MapCache$4.prototype.set = mapCacheSet$1;
var _MapCache = MapCache$4;
var ListCache$2 = _ListCache, Map$4 = _Map, MapCache$3 = _MapCache;
var LARGE_ARRAY_SIZE$1 = 200;
function stackSet$2(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$2) {
    var pairs = data.__data__;
    if (!Map$4 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$3(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$2;
var ListCache$1 = _ListCache, stackClear$1 = _stackClear, stackDelete$1 = _stackDelete, stackGet$1 = _stackGet, stackHas$1 = _stackHas, stackSet$1 = _stackSet;
function Stack$5(entries) {
  var data = this.__data__ = new ListCache$1(entries);
  this.size = data.size;
}
Stack$5.prototype.clear = stackClear$1;
Stack$5.prototype["delete"] = stackDelete$1;
Stack$5.prototype.get = stackGet$1;
Stack$5.prototype.has = stackHas$1;
Stack$5.prototype.set = stackSet$1;
var _Stack = Stack$5;
var HASH_UNDEFINED$3 = "__lodash_hash_undefined__";
function setCacheAdd$2(value) {
  this.__data__.set(value, HASH_UNDEFINED$3);
  return this;
}
var _setCacheAdd = setCacheAdd$2;
function setCacheHas$2(value) {
  return this.__data__.has(value);
}
var _setCacheHas = setCacheHas$2;
var MapCache$2 = _MapCache, setCacheAdd$1 = _setCacheAdd, setCacheHas$1 = _setCacheHas;
function SetCache$2(values) {
  var index2 = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache$2();
  while (++index2 < length) {
    this.add(values[index2]);
  }
}
SetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd$1;
SetCache$2.prototype.has = setCacheHas$1;
var _SetCache = SetCache$2;
function arraySome$2(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome$2;
function cacheHas$2(cache, key) {
  return cache.has(key);
}
var _cacheHas = cacheHas$2;
var SetCache$1 = _SetCache, arraySome$1 = _arraySome, cacheHas$1 = _cacheHas;
var COMPARE_PARTIAL_FLAG$b = 1, COMPARE_UNORDERED_FLAG$7 = 2;
function equalArrays$3(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$b, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$7 ? new SetCache$1() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome$1(other, function(othValue2, othIndex) {
        if (!cacheHas$1(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
var _equalArrays = equalArrays$3;
var root$7 = _root;
var Uint8Array$4 = root$7.Uint8Array;
var _Uint8Array = Uint8Array$4;
function mapToArray$2(map2) {
  var index2 = -1, result = Array(map2.size);
  map2.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
var _mapToArray = mapToArray$2;
function setToArray$2(set2) {
  var index2 = -1, result = Array(set2.size);
  set2.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var _setToArray = setToArray$2;
var Symbol$6 = _Symbol, Uint8Array$3 = _Uint8Array, eq$4 = eq_1, equalArrays$2 = _equalArrays, mapToArray$1 = _mapToArray, setToArray$1 = _setToArray;
var COMPARE_PARTIAL_FLAG$a = 1, COMPARE_UNORDERED_FLAG$6 = 2;
var boolTag$5 = "[object Boolean]", dateTag$5 = "[object Date]", errorTag$4 = "[object Error]", mapTag$8 = "[object Map]", numberTag$5 = "[object Number]", regexpTag$5 = "[object RegExp]", setTag$8 = "[object Set]", stringTag$6 = "[object String]", symbolTag$5 = "[object Symbol]";
var arrayBufferTag$5 = "[object ArrayBuffer]", dataViewTag$7 = "[object DataView]";
var symbolProto$4 = Symbol$6 ? Symbol$6.prototype : void 0, symbolValueOf$2 = symbolProto$4 ? symbolProto$4.valueOf : void 0;
function equalByTag$2(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$7:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag$5:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$3(object), new Uint8Array$3(other))) {
        return false;
      }
      return true;
    case boolTag$5:
    case dateTag$5:
    case numberTag$5:
      return eq$4(+object, +other);
    case errorTag$4:
      return object.name == other.name && object.message == other.message;
    case regexpTag$5:
    case stringTag$6:
      return object == other + "";
    case mapTag$8:
      var convert = mapToArray$1;
    case setTag$8:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$a;
      convert || (convert = setToArray$1);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$6;
      stack.set(object, other);
      var result = equalArrays$2(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag$5:
      if (symbolValueOf$2) {
        return symbolValueOf$2.call(object) == symbolValueOf$2.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag$2;
function arrayPush$4(array, values) {
  var index2 = -1, length = values.length, offset2 = array.length;
  while (++index2 < length) {
    array[offset2 + index2] = values[index2];
  }
  return array;
}
var _arrayPush = arrayPush$4;
var isArray$g = Array.isArray;
var isArray_1 = isArray$g;
var arrayPush$3 = _arrayPush, isArray$f = isArray_1;
function baseGetAllKeys$3(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$f(object) ? result : arrayPush$3(result, symbolsFunc(object));
}
var _baseGetAllKeys = baseGetAllKeys$3;
function arrayFilter$2(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$2;
function stubArray$3() {
  return [];
}
var stubArray_1 = stubArray$3;
var arrayFilter$1 = _arrayFilter, stubArray$2 = stubArray_1;
var objectProto$p = Object.prototype;
var propertyIsEnumerable$3 = objectProto$p.propertyIsEnumerable;
var nativeGetSymbols$2 = Object.getOwnPropertySymbols;
var getSymbols$5 = !nativeGetSymbols$2 ? stubArray$2 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter$1(nativeGetSymbols$2(object), function(symbol) {
    return propertyIsEnumerable$3.call(object, symbol);
  });
};
var _getSymbols = getSymbols$5;
function baseTimes$2(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var _baseTimes = baseTimes$2;
function isObjectLike$b(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$b;
var baseGetTag$6 = _baseGetTag, isObjectLike$a = isObjectLike_1;
var argsTag$6 = "[object Arguments]";
function baseIsArguments$2(value) {
  return isObjectLike$a(value) && baseGetTag$6(value) == argsTag$6;
}
var _baseIsArguments = baseIsArguments$2;
var baseIsArguments$1 = _baseIsArguments, isObjectLike$9 = isObjectLike_1;
var objectProto$o = Object.prototype;
var hasOwnProperty$k = objectProto$o.hasOwnProperty;
var propertyIsEnumerable$2 = objectProto$o.propertyIsEnumerable;
var isArguments$6 = baseIsArguments$1(function() {
  return arguments;
}()) ? baseIsArguments$1 : function(value) {
  return isObjectLike$9(value) && hasOwnProperty$k.call(value, "callee") && !propertyIsEnumerable$2.call(value, "callee");
};
var isArguments_1 = isArguments$6;
var isBuffer$6 = { exports: {} };
function stubFalse$1() {
  return false;
}
var stubFalse_1 = stubFalse$1;
isBuffer$6.exports;
(function(module2, exports2) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports2 = exports2 && !exports2.nodeType && exports2;
  var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var Buffer2 = moduleExports2 ? root2.Buffer : void 0;
  var nativeIsBuffer2 = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer2 || stubFalse2;
  module2.exports = isBuffer2;
})(isBuffer$6, isBuffer$6.exports);
var isBufferExports = isBuffer$6.exports;
var MAX_SAFE_INTEGER$3 = 9007199254740991;
var reIsUint$1 = /^(?:0|[1-9]\d*)$/;
function isIndex$5(value, length) {
  var type2 = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$3 : length;
  return !!length && (type2 == "number" || type2 != "symbol" && reIsUint$1.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex = isIndex$5;
var MAX_SAFE_INTEGER$2 = 9007199254740991;
function isLength$4(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$2;
}
var isLength_1 = isLength$4;
var baseGetTag$5 = _baseGetTag, isLength$3 = isLength_1, isObjectLike$8 = isObjectLike_1;
var argsTag$5 = "[object Arguments]", arrayTag$4 = "[object Array]", boolTag$4 = "[object Boolean]", dateTag$4 = "[object Date]", errorTag$3 = "[object Error]", funcTag$3 = "[object Function]", mapTag$7 = "[object Map]", numberTag$4 = "[object Number]", objectTag$8 = "[object Object]", regexpTag$4 = "[object RegExp]", setTag$7 = "[object Set]", stringTag$5 = "[object String]", weakMapTag$4 = "[object WeakMap]";
var arrayBufferTag$4 = "[object ArrayBuffer]", dataViewTag$6 = "[object DataView]", float32Tag$3 = "[object Float32Array]", float64Tag$3 = "[object Float64Array]", int8Tag$3 = "[object Int8Array]", int16Tag$3 = "[object Int16Array]", int32Tag$3 = "[object Int32Array]", uint8Tag$3 = "[object Uint8Array]", uint8ClampedTag$3 = "[object Uint8ClampedArray]", uint16Tag$3 = "[object Uint16Array]", uint32Tag$3 = "[object Uint32Array]";
var typedArrayTags$1 = {};
typedArrayTags$1[float32Tag$3] = typedArrayTags$1[float64Tag$3] = typedArrayTags$1[int8Tag$3] = typedArrayTags$1[int16Tag$3] = typedArrayTags$1[int32Tag$3] = typedArrayTags$1[uint8Tag$3] = typedArrayTags$1[uint8ClampedTag$3] = typedArrayTags$1[uint16Tag$3] = typedArrayTags$1[uint32Tag$3] = true;
typedArrayTags$1[argsTag$5] = typedArrayTags$1[arrayTag$4] = typedArrayTags$1[arrayBufferTag$4] = typedArrayTags$1[boolTag$4] = typedArrayTags$1[dataViewTag$6] = typedArrayTags$1[dateTag$4] = typedArrayTags$1[errorTag$3] = typedArrayTags$1[funcTag$3] = typedArrayTags$1[mapTag$7] = typedArrayTags$1[numberTag$4] = typedArrayTags$1[objectTag$8] = typedArrayTags$1[regexpTag$4] = typedArrayTags$1[setTag$7] = typedArrayTags$1[stringTag$5] = typedArrayTags$1[weakMapTag$4] = false;
function baseIsTypedArray$2(value) {
  return isObjectLike$8(value) && isLength$3(value.length) && !!typedArrayTags$1[baseGetTag$5(value)];
}
var _baseIsTypedArray = baseIsTypedArray$2;
function baseUnary$4(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$4;
var _nodeUtil = { exports: {} };
_nodeUtil.exports;
(function(module2, exports2) {
  var freeGlobal2 = _freeGlobal;
  var freeExports2 = exports2 && !exports2.nodeType && exports2;
  var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var freeProcess2 = moduleExports2 && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types2 = freeModule2 && freeModule2.require && freeModule2.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
    } catch (e2) {
    }
  }();
  module2.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var _nodeUtilExports = _nodeUtil.exports;
var baseIsTypedArray$1 = _baseIsTypedArray, baseUnary$3 = _baseUnary, nodeUtil$4 = _nodeUtilExports;
var nodeIsTypedArray$1 = nodeUtil$4 && nodeUtil$4.isTypedArray;
var isTypedArray$5 = nodeIsTypedArray$1 ? baseUnary$3(nodeIsTypedArray$1) : baseIsTypedArray$1;
var isTypedArray_1 = isTypedArray$5;
var baseTimes$1 = _baseTimes, isArguments$5 = isArguments_1, isArray$e = isArray_1, isBuffer$5 = isBufferExports, isIndex$4 = _isIndex, isTypedArray$4 = isTypedArray_1;
var objectProto$n = Object.prototype;
var hasOwnProperty$j = objectProto$n.hasOwnProperty;
function arrayLikeKeys$3(value, inherited) {
  var isArr = isArray$e(value), isArg = !isArr && isArguments$5(value), isBuff = !isArr && !isArg && isBuffer$5(value), isType = !isArr && !isArg && !isBuff && isTypedArray$4(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes$1(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$j.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex$4(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$3;
var objectProto$m = Object.prototype;
function isPrototype$4(value) {
  var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$m;
  return value === proto2;
}
var _isPrototype = isPrototype$4;
function overArg$3(func, transform2) {
  return function(arg) {
    return func(transform2(arg));
  };
}
var _overArg = overArg$3;
var overArg$2 = _overArg;
var nativeKeys$3 = overArg$2(Object.keys, Object);
var _nativeKeys = nativeKeys$3;
var isPrototype$3 = _isPrototype, nativeKeys$2 = _nativeKeys;
var objectProto$l = Object.prototype;
var hasOwnProperty$i = objectProto$l.hasOwnProperty;
function baseKeys$2(object) {
  if (!isPrototype$3(object)) {
    return nativeKeys$2(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$i.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$2;
var isFunction$3 = isFunction_1, isLength$2 = isLength_1;
function isArrayLike$7(value) {
  return value != null && isLength$2(value.length) && !isFunction$3(value);
}
var isArrayLike_1 = isArrayLike$7;
var arrayLikeKeys$2 = _arrayLikeKeys, baseKeys$1 = _baseKeys, isArrayLike$6 = isArrayLike_1;
function keys$7(object) {
  return isArrayLike$6(object) ? arrayLikeKeys$2(object) : baseKeys$1(object);
}
var keys_1 = keys$7;
const keys$8 = /* @__PURE__ */ getDefaultExportFromCjs(keys_1);
var baseGetAllKeys$2 = _baseGetAllKeys, getSymbols$4 = _getSymbols, keys$6 = keys_1;
function getAllKeys$3(object) {
  return baseGetAllKeys$2(object, keys$6, getSymbols$4);
}
var _getAllKeys = getAllKeys$3;
var getAllKeys$2 = _getAllKeys;
var COMPARE_PARTIAL_FLAG$9 = 1;
var objectProto$k = Object.prototype;
var hasOwnProperty$h = objectProto$k.hasOwnProperty;
function equalObjects$2(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$9, objProps = getAllKeys$2(object), objLength = objProps.length, othProps = getAllKeys$2(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$h.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var _equalObjects = equalObjects$2;
var getNative$5 = _getNative, root$6 = _root;
var DataView$3 = getNative$5(root$6, "DataView");
var _DataView = DataView$3;
var getNative$4 = _getNative, root$5 = _root;
var Promise$4 = getNative$4(root$5, "Promise");
var _Promise = Promise$4;
var getNative$3 = _getNative, root$4 = _root;
var Set$4 = getNative$3(root$4, "Set");
var _Set = Set$4;
var getNative$2 = _getNative, root$3 = _root;
var WeakMap$4 = getNative$2(root$3, "WeakMap");
var _WeakMap = WeakMap$4;
var DataView$2 = _DataView, Map$3 = _Map, Promise$3 = _Promise, Set$3 = _Set, WeakMap$3 = _WeakMap, baseGetTag$4 = _baseGetTag, toSource$1 = _toSource;
var mapTag$6 = "[object Map]", objectTag$7 = "[object Object]", promiseTag$1 = "[object Promise]", setTag$6 = "[object Set]", weakMapTag$3 = "[object WeakMap]";
var dataViewTag$5 = "[object DataView]";
var dataViewCtorString$1 = toSource$1(DataView$2), mapCtorString$1 = toSource$1(Map$3), promiseCtorString$1 = toSource$1(Promise$3), setCtorString$1 = toSource$1(Set$3), weakMapCtorString$1 = toSource$1(WeakMap$3);
var getTag$6 = baseGetTag$4;
if (DataView$2 && getTag$6(new DataView$2(new ArrayBuffer(1))) != dataViewTag$5 || Map$3 && getTag$6(new Map$3()) != mapTag$6 || Promise$3 && getTag$6(Promise$3.resolve()) != promiseTag$1 || Set$3 && getTag$6(new Set$3()) != setTag$6 || WeakMap$3 && getTag$6(new WeakMap$3()) != weakMapTag$3) {
  getTag$6 = function(value) {
    var result = baseGetTag$4(value), Ctor = result == objectTag$7 ? value.constructor : void 0, ctorString = Ctor ? toSource$1(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString$1:
          return dataViewTag$5;
        case mapCtorString$1:
          return mapTag$6;
        case promiseCtorString$1:
          return promiseTag$1;
        case setCtorString$1:
          return setTag$6;
        case weakMapCtorString$1:
          return weakMapTag$3;
      }
    }
    return result;
  };
}
var _getTag = getTag$6;
var Stack$4 = _Stack, equalArrays$1 = _equalArrays, equalByTag$1 = _equalByTag, equalObjects$1 = _equalObjects, getTag$5 = _getTag, isArray$d = isArray_1, isBuffer$4 = isBufferExports, isTypedArray$3 = isTypedArray_1;
var COMPARE_PARTIAL_FLAG$8 = 1;
var argsTag$4 = "[object Arguments]", arrayTag$3 = "[object Array]", objectTag$6 = "[object Object]";
var objectProto$j = Object.prototype;
var hasOwnProperty$g = objectProto$j.hasOwnProperty;
function baseIsEqualDeep$2(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$d(object), othIsArr = isArray$d(other), objTag = objIsArr ? arrayTag$3 : getTag$5(object), othTag = othIsArr ? arrayTag$3 : getTag$5(other);
  objTag = objTag == argsTag$4 ? objectTag$6 : objTag;
  othTag = othTag == argsTag$4 ? objectTag$6 : othTag;
  var objIsObj = objTag == objectTag$6, othIsObj = othTag == objectTag$6, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$4(object)) {
    if (!isBuffer$4(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$4());
    return objIsArr || isTypedArray$3(object) ? equalArrays$1(object, other, bitmask, customizer, equalFunc, stack) : equalByTag$1(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$8)) {
    var objIsWrapped = objIsObj && hasOwnProperty$g.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$g.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack$4());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack$4());
  return equalObjects$1(object, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep$2;
var baseIsEqualDeep$1 = _baseIsEqualDeep, isObjectLike$7 = isObjectLike_1;
function baseIsEqual$4(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike$7(value) && !isObjectLike$7(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep$1(value, other, bitmask, customizer, baseIsEqual$4, stack);
}
var _baseIsEqual = baseIsEqual$4;
var baseIsEqual$3 = _baseIsEqual;
function isEqual$1(value, other) {
  return baseIsEqual$3(value, other);
}
var isEqual_1$1 = isEqual$1;
var quill = { exports: {} };
/*!
 * Quill Editor v1.3.7
 * https://quilljs.com/
 * Copyright (c) 2014, Jason Chen
 * Copyright (c) 2013, salesforce.com
 */
(function(module2, exports2) {
  (function webpackUniversalModuleDefinition(root2, factory26) {
    module2.exports = factory26();
  })(typeof self !== "undefined" ? self : commonjsGlobal, function() {
    return (
      /******/
      function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          var module3 = installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {}
            /******/
          };
          modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
          module3.l = true;
          return module3.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports3, name, getter) {
          if (!__webpack_require__.o(exports3, name)) {
            Object.defineProperty(exports3, name, {
              /******/
              configurable: false,
              /******/
              enumerable: true,
              /******/
              get: getter
              /******/
            });
          }
        };
        __webpack_require__.n = function(module3) {
          var getter = module3 && module3.__esModule ? (
            /******/
            function getDefault() {
              return module3["default"];
            }
          ) : (
            /******/
            function getModuleExports() {
              return module3;
            }
          );
          __webpack_require__.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__.o = function(object, property2) {
          return Object.prototype.hasOwnProperty.call(object, property2);
        };
        __webpack_require__.p = "";
        return __webpack_require__(__webpack_require__.s = 109);
      }([
        /* 0 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          var container_1 = __webpack_require__(17);
          var format_1 = __webpack_require__(18);
          var leaf_1 = __webpack_require__(19);
          var scroll_1 = __webpack_require__(45);
          var inline_1 = __webpack_require__(46);
          var block_1 = __webpack_require__(47);
          var embed_1 = __webpack_require__(48);
          var text_1 = __webpack_require__(49);
          var attributor_1 = __webpack_require__(12);
          var class_1 = __webpack_require__(32);
          var style_1 = __webpack_require__(33);
          var store_1 = __webpack_require__(31);
          var Registry = __webpack_require__(1);
          var Parchment = {
            Scope: Registry.Scope,
            create: Registry.create,
            find: Registry.find,
            query: Registry.query,
            register: Registry.register,
            Container: container_1.default,
            Format: format_1.default,
            Leaf: leaf_1.default,
            Embed: embed_1.default,
            Scroll: scroll_1.default,
            Block: block_1.default,
            Inline: inline_1.default,
            Text: text_1.default,
            Attributor: {
              Attribute: attributor_1.default,
              Class: class_1.default,
              Style: style_1.default,
              Store: store_1.default
            }
          };
          exports3.default = Parchment;
        },
        /* 1 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var __extends2 = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p2 in b2)
                if (b2.hasOwnProperty(p2))
                  d2[p2] = b2[p2];
            };
            return function(d2, b2) {
              extendStatics(d2, b2);
              function __() {
                this.constructor = d2;
              }
              d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
            };
          }();
          Object.defineProperty(exports3, "__esModule", { value: true });
          var ParchmentError = (
            /** @class */
            function(_super) {
              __extends2(ParchmentError2, _super);
              function ParchmentError2(message) {
                var _this = this;
                message = "[Parchment] " + message;
                _this = _super.call(this, message) || this;
                _this.message = message;
                _this.name = _this.constructor.name;
                return _this;
              }
              return ParchmentError2;
            }(Error)
          );
          exports3.ParchmentError = ParchmentError;
          var attributes = {};
          var classes = {};
          var tags = {};
          var types2 = {};
          exports3.DATA_KEY = "__blot";
          var Scope;
          (function(Scope2) {
            Scope2[Scope2["TYPE"] = 3] = "TYPE";
            Scope2[Scope2["LEVEL"] = 12] = "LEVEL";
            Scope2[Scope2["ATTRIBUTE"] = 13] = "ATTRIBUTE";
            Scope2[Scope2["BLOT"] = 14] = "BLOT";
            Scope2[Scope2["INLINE"] = 7] = "INLINE";
            Scope2[Scope2["BLOCK"] = 11] = "BLOCK";
            Scope2[Scope2["BLOCK_BLOT"] = 10] = "BLOCK_BLOT";
            Scope2[Scope2["INLINE_BLOT"] = 6] = "INLINE_BLOT";
            Scope2[Scope2["BLOCK_ATTRIBUTE"] = 9] = "BLOCK_ATTRIBUTE";
            Scope2[Scope2["INLINE_ATTRIBUTE"] = 5] = "INLINE_ATTRIBUTE";
            Scope2[Scope2["ANY"] = 15] = "ANY";
          })(Scope = exports3.Scope || (exports3.Scope = {}));
          function create(input2, value) {
            var match5 = query(input2);
            if (match5 == null) {
              throw new ParchmentError("Unable to create " + input2 + " blot");
            }
            var BlotClass = match5;
            var node = (
              // @ts-ignore
              input2 instanceof Node || input2["nodeType"] === Node.TEXT_NODE ? input2 : BlotClass.create(value)
            );
            return new BlotClass(node, value);
          }
          exports3.create = create;
          function find(node, bubble2) {
            if (bubble2 === void 0) {
              bubble2 = false;
            }
            if (node == null)
              return null;
            if (node[exports3.DATA_KEY] != null)
              return node[exports3.DATA_KEY].blot;
            if (bubble2)
              return find(node.parentNode, bubble2);
            return null;
          }
          exports3.find = find;
          function query(query2, scope) {
            if (scope === void 0) {
              scope = Scope.ANY;
            }
            var match5;
            if (typeof query2 === "string") {
              match5 = types2[query2] || attributes[query2];
            } else if (query2 instanceof Text || query2["nodeType"] === Node.TEXT_NODE) {
              match5 = types2["text"];
            } else if (typeof query2 === "number") {
              if (query2 & Scope.LEVEL & Scope.BLOCK) {
                match5 = types2["block"];
              } else if (query2 & Scope.LEVEL & Scope.INLINE) {
                match5 = types2["inline"];
              }
            } else if (query2 instanceof HTMLElement) {
              var names2 = (query2.getAttribute("class") || "").split(/\s+/);
              for (var i2 in names2) {
                match5 = classes[names2[i2]];
                if (match5)
                  break;
              }
              match5 = match5 || tags[query2.tagName];
            }
            if (match5 == null)
              return null;
            if (scope & Scope.LEVEL & match5.scope && scope & Scope.TYPE & match5.scope)
              return match5;
            return null;
          }
          exports3.query = query;
          function register() {
            var Definitions = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              Definitions[_i] = arguments[_i];
            }
            if (Definitions.length > 1) {
              return Definitions.map(function(d2) {
                return register(d2);
              });
            }
            var Definition = Definitions[0];
            if (typeof Definition.blotName !== "string" && typeof Definition.attrName !== "string") {
              throw new ParchmentError("Invalid definition");
            } else if (Definition.blotName === "abstract") {
              throw new ParchmentError("Cannot register abstract class");
            }
            types2[Definition.blotName || Definition.attrName] = Definition;
            if (typeof Definition.keyName === "string") {
              attributes[Definition.keyName] = Definition;
            } else {
              if (Definition.className != null) {
                classes[Definition.className] = Definition;
              }
              if (Definition.tagName != null) {
                if (Array.isArray(Definition.tagName)) {
                  Definition.tagName = Definition.tagName.map(function(tagName) {
                    return tagName.toUpperCase();
                  });
                } else {
                  Definition.tagName = Definition.tagName.toUpperCase();
                }
                var tagNames = Array.isArray(Definition.tagName) ? Definition.tagName : [Definition.tagName];
                tagNames.forEach(function(tag) {
                  if (tags[tag] == null || Definition.className == null) {
                    tags[tag] = Definition;
                  }
                });
              }
            }
            return Definition;
          }
          exports3.register = register;
        },
        /* 2 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var diff2 = __webpack_require__(51);
          var equal = __webpack_require__(11);
          var extend3 = __webpack_require__(3);
          var op = __webpack_require__(20);
          var NULL_CHARACTER = String.fromCharCode(0);
          var Delta = function(ops) {
            if (Array.isArray(ops)) {
              this.ops = ops;
            } else if (ops != null && Array.isArray(ops.ops)) {
              this.ops = ops.ops;
            } else {
              this.ops = [];
            }
          };
          Delta.prototype.insert = function(text, attributes) {
            var newOp = {};
            if (text.length === 0)
              return this;
            newOp.insert = text;
            if (attributes != null && typeof attributes === "object" && Object.keys(attributes).length > 0) {
              newOp.attributes = attributes;
            }
            return this.push(newOp);
          };
          Delta.prototype["delete"] = function(length) {
            if (length <= 0)
              return this;
            return this.push({ "delete": length });
          };
          Delta.prototype.retain = function(length, attributes) {
            if (length <= 0)
              return this;
            var newOp = { retain: length };
            if (attributes != null && typeof attributes === "object" && Object.keys(attributes).length > 0) {
              newOp.attributes = attributes;
            }
            return this.push(newOp);
          };
          Delta.prototype.push = function(newOp) {
            var index2 = this.ops.length;
            var lastOp = this.ops[index2 - 1];
            newOp = extend3(true, {}, newOp);
            if (typeof lastOp === "object") {
              if (typeof newOp["delete"] === "number" && typeof lastOp["delete"] === "number") {
                this.ops[index2 - 1] = { "delete": lastOp["delete"] + newOp["delete"] };
                return this;
              }
              if (typeof lastOp["delete"] === "number" && newOp.insert != null) {
                index2 -= 1;
                lastOp = this.ops[index2 - 1];
                if (typeof lastOp !== "object") {
                  this.ops.unshift(newOp);
                  return this;
                }
              }
              if (equal(newOp.attributes, lastOp.attributes)) {
                if (typeof newOp.insert === "string" && typeof lastOp.insert === "string") {
                  this.ops[index2 - 1] = { insert: lastOp.insert + newOp.insert };
                  if (typeof newOp.attributes === "object")
                    this.ops[index2 - 1].attributes = newOp.attributes;
                  return this;
                } else if (typeof newOp.retain === "number" && typeof lastOp.retain === "number") {
                  this.ops[index2 - 1] = { retain: lastOp.retain + newOp.retain };
                  if (typeof newOp.attributes === "object")
                    this.ops[index2 - 1].attributes = newOp.attributes;
                  return this;
                }
              }
            }
            if (index2 === this.ops.length) {
              this.ops.push(newOp);
            } else {
              this.ops.splice(index2, 0, newOp);
            }
            return this;
          };
          Delta.prototype.chop = function() {
            var lastOp = this.ops[this.ops.length - 1];
            if (lastOp && lastOp.retain && !lastOp.attributes) {
              this.ops.pop();
            }
            return this;
          };
          Delta.prototype.filter = function(predicate) {
            return this.ops.filter(predicate);
          };
          Delta.prototype.forEach = function(predicate) {
            this.ops.forEach(predicate);
          };
          Delta.prototype.map = function(predicate) {
            return this.ops.map(predicate);
          };
          Delta.prototype.partition = function(predicate) {
            var passed = [], failed = [];
            this.forEach(function(op2) {
              var target = predicate(op2) ? passed : failed;
              target.push(op2);
            });
            return [passed, failed];
          };
          Delta.prototype.reduce = function(predicate, initial) {
            return this.ops.reduce(predicate, initial);
          };
          Delta.prototype.changeLength = function() {
            return this.reduce(function(length, elem) {
              if (elem.insert) {
                return length + op.length(elem);
              } else if (elem.delete) {
                return length - elem.delete;
              }
              return length;
            }, 0);
          };
          Delta.prototype.length = function() {
            return this.reduce(function(length, elem) {
              return length + op.length(elem);
            }, 0);
          };
          Delta.prototype.slice = function(start2, end) {
            start2 = start2 || 0;
            if (typeof end !== "number")
              end = Infinity;
            var ops = [];
            var iter = op.iterator(this.ops);
            var index2 = 0;
            while (index2 < end && iter.hasNext()) {
              var nextOp;
              if (index2 < start2) {
                nextOp = iter.next(start2 - index2);
              } else {
                nextOp = iter.next(end - index2);
                ops.push(nextOp);
              }
              index2 += op.length(nextOp);
            }
            return new Delta(ops);
          };
          Delta.prototype.compose = function(other) {
            var thisIter = op.iterator(this.ops);
            var otherIter = op.iterator(other.ops);
            var ops = [];
            var firstOther = otherIter.peek();
            if (firstOther != null && typeof firstOther.retain === "number" && firstOther.attributes == null) {
              var firstLeft = firstOther.retain;
              while (thisIter.peekType() === "insert" && thisIter.peekLength() <= firstLeft) {
                firstLeft -= thisIter.peekLength();
                ops.push(thisIter.next());
              }
              if (firstOther.retain - firstLeft > 0) {
                otherIter.next(firstOther.retain - firstLeft);
              }
            }
            var delta = new Delta(ops);
            while (thisIter.hasNext() || otherIter.hasNext()) {
              if (otherIter.peekType() === "insert") {
                delta.push(otherIter.next());
              } else if (thisIter.peekType() === "delete") {
                delta.push(thisIter.next());
              } else {
                var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
                var thisOp = thisIter.next(length);
                var otherOp = otherIter.next(length);
                if (typeof otherOp.retain === "number") {
                  var newOp = {};
                  if (typeof thisOp.retain === "number") {
                    newOp.retain = length;
                  } else {
                    newOp.insert = thisOp.insert;
                  }
                  var attributes = op.attributes.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === "number");
                  if (attributes)
                    newOp.attributes = attributes;
                  delta.push(newOp);
                  if (!otherIter.hasNext() && equal(delta.ops[delta.ops.length - 1], newOp)) {
                    var rest = new Delta(thisIter.rest());
                    return delta.concat(rest).chop();
                  }
                } else if (typeof otherOp["delete"] === "number" && typeof thisOp.retain === "number") {
                  delta.push(otherOp);
                }
              }
            }
            return delta.chop();
          };
          Delta.prototype.concat = function(other) {
            var delta = new Delta(this.ops.slice());
            if (other.ops.length > 0) {
              delta.push(other.ops[0]);
              delta.ops = delta.ops.concat(other.ops.slice(1));
            }
            return delta;
          };
          Delta.prototype.diff = function(other, index2) {
            if (this.ops === other.ops) {
              return new Delta();
            }
            var strings = [this, other].map(function(delta2) {
              return delta2.map(function(op2) {
                if (op2.insert != null) {
                  return typeof op2.insert === "string" ? op2.insert : NULL_CHARACTER;
                }
                var prep = delta2 === other ? "on" : "with";
                throw new Error("diff() called " + prep + " non-document");
              }).join("");
            });
            var delta = new Delta();
            var diffResult = diff2(strings[0], strings[1], index2);
            var thisIter = op.iterator(this.ops);
            var otherIter = op.iterator(other.ops);
            diffResult.forEach(function(component) {
              var length = component[1].length;
              while (length > 0) {
                var opLength = 0;
                switch (component[0]) {
                  case diff2.INSERT:
                    opLength = Math.min(otherIter.peekLength(), length);
                    delta.push(otherIter.next(opLength));
                    break;
                  case diff2.DELETE:
                    opLength = Math.min(length, thisIter.peekLength());
                    thisIter.next(opLength);
                    delta["delete"](opLength);
                    break;
                  case diff2.EQUAL:
                    opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
                    var thisOp = thisIter.next(opLength);
                    var otherOp = otherIter.next(opLength);
                    if (equal(thisOp.insert, otherOp.insert)) {
                      delta.retain(opLength, op.attributes.diff(thisOp.attributes, otherOp.attributes));
                    } else {
                      delta.push(otherOp)["delete"](opLength);
                    }
                    break;
                }
                length -= opLength;
              }
            });
            return delta.chop();
          };
          Delta.prototype.eachLine = function(predicate, newline) {
            newline = newline || "\n";
            var iter = op.iterator(this.ops);
            var line = new Delta();
            var i2 = 0;
            while (iter.hasNext()) {
              if (iter.peekType() !== "insert")
                return;
              var thisOp = iter.peek();
              var start2 = op.length(thisOp) - iter.peekLength();
              var index2 = typeof thisOp.insert === "string" ? thisOp.insert.indexOf(newline, start2) - start2 : -1;
              if (index2 < 0) {
                line.push(iter.next());
              } else if (index2 > 0) {
                line.push(iter.next(index2));
              } else {
                if (predicate(line, iter.next(1).attributes || {}, i2) === false) {
                  return;
                }
                i2 += 1;
                line = new Delta();
              }
            }
            if (line.length() > 0) {
              predicate(line, {}, i2);
            }
          };
          Delta.prototype.transform = function(other, priority) {
            priority = !!priority;
            if (typeof other === "number") {
              return this.transformPosition(other, priority);
            }
            var thisIter = op.iterator(this.ops);
            var otherIter = op.iterator(other.ops);
            var delta = new Delta();
            while (thisIter.hasNext() || otherIter.hasNext()) {
              if (thisIter.peekType() === "insert" && (priority || otherIter.peekType() !== "insert")) {
                delta.retain(op.length(thisIter.next()));
              } else if (otherIter.peekType() === "insert") {
                delta.push(otherIter.next());
              } else {
                var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
                var thisOp = thisIter.next(length);
                var otherOp = otherIter.next(length);
                if (thisOp["delete"]) {
                  continue;
                } else if (otherOp["delete"]) {
                  delta.push(otherOp);
                } else {
                  delta.retain(length, op.attributes.transform(thisOp.attributes, otherOp.attributes, priority));
                }
              }
            }
            return delta.chop();
          };
          Delta.prototype.transformPosition = function(index2, priority) {
            priority = !!priority;
            var thisIter = op.iterator(this.ops);
            var offset2 = 0;
            while (thisIter.hasNext() && offset2 <= index2) {
              var length = thisIter.peekLength();
              var nextType = thisIter.peekType();
              thisIter.next();
              if (nextType === "delete") {
                index2 -= Math.min(length, index2 - offset2);
                continue;
              } else if (nextType === "insert" && (offset2 < index2 || !priority)) {
                index2 += length;
              }
              offset2 += length;
            }
            return index2;
          };
          module3.exports = Delta;
        },
        /* 3 */
        /***/
        function(module3, exports3) {
          var hasOwn = Object.prototype.hasOwnProperty;
          var toStr = Object.prototype.toString;
          var defineProperty2 = Object.defineProperty;
          var gOPD = Object.getOwnPropertyDescriptor;
          var isArray2 = function isArray3(arr) {
            if (typeof Array.isArray === "function") {
              return Array.isArray(arr);
            }
            return toStr.call(arr) === "[object Array]";
          };
          var isPlainObject2 = function isPlainObject3(obj) {
            if (!obj || toStr.call(obj) !== "[object Object]") {
              return false;
            }
            var hasOwnConstructor = hasOwn.call(obj, "constructor");
            var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
            if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
              return false;
            }
            var key;
            for (key in obj) {
            }
            return typeof key === "undefined" || hasOwn.call(obj, key);
          };
          var setProperty = function setProperty2(target, options) {
            if (defineProperty2 && options.name === "__proto__") {
              defineProperty2(target, options.name, {
                enumerable: true,
                configurable: true,
                value: options.newValue,
                writable: true
              });
            } else {
              target[options.name] = options.newValue;
            }
          };
          var getProperty = function getProperty2(obj, name) {
            if (name === "__proto__") {
              if (!hasOwn.call(obj, name)) {
                return void 0;
              } else if (gOPD) {
                return gOPD(obj, name).value;
              }
            }
            return obj[name];
          };
          module3.exports = function extend3() {
            var options, name, src, copy, copyIsArray, clone3;
            var target = arguments[0];
            var i2 = 1;
            var length = arguments.length;
            var deep = false;
            if (typeof target === "boolean") {
              deep = target;
              target = arguments[1] || {};
              i2 = 2;
            }
            if (target == null || typeof target !== "object" && typeof target !== "function") {
              target = {};
            }
            for (; i2 < length; ++i2) {
              options = arguments[i2];
              if (options != null) {
                for (name in options) {
                  src = getProperty(target, name);
                  copy = getProperty(options, name);
                  if (target !== copy) {
                    if (deep && copy && (isPlainObject2(copy) || (copyIsArray = isArray2(copy)))) {
                      if (copyIsArray) {
                        copyIsArray = false;
                        clone3 = src && isArray2(src) ? src : [];
                      } else {
                        clone3 = src && isPlainObject2(src) ? src : {};
                      }
                      setProperty(target, { name, newValue: extend3(deep, clone3, copy) });
                    } else if (typeof copy !== "undefined") {
                      setProperty(target, { name, newValue: copy });
                    }
                  }
                }
              }
            }
            return target;
          };
        },
        /* 4 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.default = exports3.BlockEmbed = exports3.bubbleFormats = void 0;
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get4(object, property2, receiver) {
            if (object === null)
              object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get4(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _extend = __webpack_require__(3);
          var _extend2 = _interopRequireDefault2(_extend);
          var _quillDelta = __webpack_require__(2);
          var _quillDelta2 = _interopRequireDefault2(_quillDelta);
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _break = __webpack_require__(16);
          var _break2 = _interopRequireDefault2(_break);
          var _inline = __webpack_require__(6);
          var _inline2 = _interopRequireDefault2(_inline);
          var _text = __webpack_require__(7);
          var _text2 = _interopRequireDefault2(_text);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var NEWLINE_LENGTH = 1;
          var BlockEmbed = function(_Parchment$Embed) {
            _inherits2(BlockEmbed2, _Parchment$Embed);
            function BlockEmbed2() {
              _classCallCheck2(this, BlockEmbed2);
              return _possibleConstructorReturn2(this, (BlockEmbed2.__proto__ || Object.getPrototypeOf(BlockEmbed2)).apply(this, arguments));
            }
            _createClass2(BlockEmbed2, [{
              key: "attach",
              value: function attach() {
                _get2(BlockEmbed2.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed2.prototype), "attach", this).call(this);
                this.attributes = new _parchment2.default.Attributor.Store(this.domNode);
              }
            }, {
              key: "delta",
              value: function delta() {
                return new _quillDelta2.default().insert(this.value(), (0, _extend2.default)(this.formats(), this.attributes.values()));
              }
            }, {
              key: "format",
              value: function format2(name, value) {
                var attribute = _parchment2.default.query(name, _parchment2.default.Scope.BLOCK_ATTRIBUTE);
                if (attribute != null) {
                  this.attributes.attribute(attribute, value);
                }
              }
            }, {
              key: "formatAt",
              value: function formatAt(index2, length, name, value) {
                this.format(name, value);
              }
            }, {
              key: "insertAt",
              value: function insertAt(index2, value, def) {
                if (typeof value === "string" && value.endsWith("\n")) {
                  var block = _parchment2.default.create(Block3.blotName);
                  this.parent.insertBefore(block, index2 === 0 ? this : this.next);
                  block.insertAt(0, value.slice(0, -1));
                } else {
                  _get2(BlockEmbed2.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed2.prototype), "insertAt", this).call(this, index2, value, def);
                }
              }
            }]);
            return BlockEmbed2;
          }(_parchment2.default.Embed);
          BlockEmbed.scope = _parchment2.default.Scope.BLOCK_BLOT;
          var Block3 = function(_Parchment$Block) {
            _inherits2(Block4, _Parchment$Block);
            function Block4(domNode) {
              _classCallCheck2(this, Block4);
              var _this2 = _possibleConstructorReturn2(this, (Block4.__proto__ || Object.getPrototypeOf(Block4)).call(this, domNode));
              _this2.cache = {};
              return _this2;
            }
            _createClass2(Block4, [{
              key: "delta",
              value: function delta() {
                if (this.cache.delta == null) {
                  this.cache.delta = this.descendants(_parchment2.default.Leaf).reduce(function(delta2, leaf) {
                    if (leaf.length() === 0) {
                      return delta2;
                    } else {
                      return delta2.insert(leaf.value(), bubbleFormats(leaf));
                    }
                  }, new _quillDelta2.default()).insert("\n", bubbleFormats(this));
                }
                return this.cache.delta;
              }
            }, {
              key: "deleteAt",
              value: function deleteAt(index2, length) {
                _get2(Block4.prototype.__proto__ || Object.getPrototypeOf(Block4.prototype), "deleteAt", this).call(this, index2, length);
                this.cache = {};
              }
            }, {
              key: "formatAt",
              value: function formatAt(index2, length, name, value) {
                if (length <= 0)
                  return;
                if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {
                  if (index2 + length === this.length()) {
                    this.format(name, value);
                  }
                } else {
                  _get2(Block4.prototype.__proto__ || Object.getPrototypeOf(Block4.prototype), "formatAt", this).call(this, index2, Math.min(length, this.length() - index2 - 1), name, value);
                }
                this.cache = {};
              }
            }, {
              key: "insertAt",
              value: function insertAt(index2, value, def) {
                if (def != null)
                  return _get2(Block4.prototype.__proto__ || Object.getPrototypeOf(Block4.prototype), "insertAt", this).call(this, index2, value, def);
                if (value.length === 0)
                  return;
                var lines = value.split("\n");
                var text = lines.shift();
                if (text.length > 0) {
                  if (index2 < this.length() - 1 || this.children.tail == null) {
                    _get2(Block4.prototype.__proto__ || Object.getPrototypeOf(Block4.prototype), "insertAt", this).call(this, Math.min(index2, this.length() - 1), text);
                  } else {
                    this.children.tail.insertAt(this.children.tail.length(), text);
                  }
                  this.cache = {};
                }
                var block = this;
                lines.reduce(function(index3, line) {
                  block = block.split(index3, true);
                  block.insertAt(0, line);
                  return line.length;
                }, index2 + text.length);
              }
            }, {
              key: "insertBefore",
              value: function insertBefore(blot, ref) {
                var head = this.children.head;
                _get2(Block4.prototype.__proto__ || Object.getPrototypeOf(Block4.prototype), "insertBefore", this).call(this, blot, ref);
                if (head instanceof _break2.default) {
                  head.remove();
                }
                this.cache = {};
              }
            }, {
              key: "length",
              value: function length() {
                if (this.cache.length == null) {
                  this.cache.length = _get2(Block4.prototype.__proto__ || Object.getPrototypeOf(Block4.prototype), "length", this).call(this) + NEWLINE_LENGTH;
                }
                return this.cache.length;
              }
            }, {
              key: "moveChildren",
              value: function moveChildren2(target, ref) {
                _get2(Block4.prototype.__proto__ || Object.getPrototypeOf(Block4.prototype), "moveChildren", this).call(this, target, ref);
                this.cache = {};
              }
            }, {
              key: "optimize",
              value: function optimize(context2) {
                _get2(Block4.prototype.__proto__ || Object.getPrototypeOf(Block4.prototype), "optimize", this).call(this, context2);
                this.cache = {};
              }
            }, {
              key: "path",
              value: function path(index2) {
                return _get2(Block4.prototype.__proto__ || Object.getPrototypeOf(Block4.prototype), "path", this).call(this, index2, true);
              }
            }, {
              key: "removeChild",
              value: function removeChild(child) {
                _get2(Block4.prototype.__proto__ || Object.getPrototypeOf(Block4.prototype), "removeChild", this).call(this, child);
                this.cache = {};
              }
            }, {
              key: "split",
              value: function split(index2) {
                var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                if (force && (index2 === 0 || index2 >= this.length() - NEWLINE_LENGTH)) {
                  var clone3 = this.clone();
                  if (index2 === 0) {
                    this.parent.insertBefore(clone3, this);
                    return this;
                  } else {
                    this.parent.insertBefore(clone3, this.next);
                    return clone3;
                  }
                } else {
                  var next = _get2(Block4.prototype.__proto__ || Object.getPrototypeOf(Block4.prototype), "split", this).call(this, index2, force);
                  this.cache = {};
                  return next;
                }
              }
            }]);
            return Block4;
          }(_parchment2.default.Block);
          Block3.blotName = "block";
          Block3.tagName = "P";
          Block3.defaultChild = "break";
          Block3.allowedChildren = [_inline2.default, _parchment2.default.Embed, _text2.default];
          function bubbleFormats(blot) {
            var formats = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (blot == null)
              return formats;
            if (typeof blot.formats === "function") {
              formats = (0, _extend2.default)(formats, blot.formats());
            }
            if (blot.parent == null || blot.parent.blotName == "scroll" || blot.parent.statics.scope !== blot.statics.scope) {
              return formats;
            }
            return bubbleFormats(blot.parent, formats);
          }
          exports3.bubbleFormats = bubbleFormats;
          exports3.BlockEmbed = BlockEmbed;
          exports3.default = Block3;
        },
        /* 5 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.default = exports3.overload = exports3.expandConfig = void 0;
          var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
            return typeof obj;
          } : function(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
          var _slicedToArray2 = function() {
            function sliceIterator(arr, i2) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i2 && _arr.length === i2)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"])
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            return function(arr, i2) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i2);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          __webpack_require__(50);
          var _quillDelta = __webpack_require__(2);
          var _quillDelta2 = _interopRequireDefault2(_quillDelta);
          var _editor = __webpack_require__(14);
          var _editor2 = _interopRequireDefault2(_editor);
          var _emitter3 = __webpack_require__(8);
          var _emitter4 = _interopRequireDefault2(_emitter3);
          var _module = __webpack_require__(9);
          var _module2 = _interopRequireDefault2(_module);
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _selection = __webpack_require__(15);
          var _selection2 = _interopRequireDefault2(_selection);
          var _extend = __webpack_require__(3);
          var _extend2 = _interopRequireDefault2(_extend);
          var _logger = __webpack_require__(10);
          var _logger2 = _interopRequireDefault2(_logger);
          var _theme = __webpack_require__(34);
          var _theme2 = _interopRequireDefault2(_theme);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _defineProperty2(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var debug = (0, _logger2.default)("quill");
          var Quill2 = function() {
            _createClass2(Quill3, null, [{
              key: "debug",
              value: function debug2(limit) {
                if (limit === true) {
                  limit = "log";
                }
                _logger2.default.level(limit);
              }
            }, {
              key: "find",
              value: function find(node) {
                return node.__quill || _parchment2.default.find(node);
              }
            }, {
              key: "import",
              value: function _import(name) {
                if (this.imports[name] == null) {
                  debug.error("Cannot import " + name + ". Are you sure it was registered?");
                }
                return this.imports[name];
              }
            }, {
              key: "register",
              value: function register(path, target) {
                var _this = this;
                var overwrite = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                if (typeof path !== "string") {
                  var name = path.attrName || path.blotName;
                  if (typeof name === "string") {
                    this.register("formats/" + name, path, target);
                  } else {
                    Object.keys(path).forEach(function(key) {
                      _this.register(key, path[key], target);
                    });
                  }
                } else {
                  if (this.imports[path] != null && !overwrite) {
                    debug.warn("Overwriting " + path + " with", target);
                  }
                  this.imports[path] = target;
                  if ((path.startsWith("blots/") || path.startsWith("formats/")) && target.blotName !== "abstract") {
                    _parchment2.default.register(target);
                  } else if (path.startsWith("modules") && typeof target.register === "function") {
                    target.register();
                  }
                }
              }
            }]);
            function Quill3(container2) {
              var _this2 = this;
              var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              _classCallCheck2(this, Quill3);
              this.options = expandConfig(container2, options);
              this.container = this.options.container;
              if (this.container == null) {
                return debug.error("Invalid Quill container", container2);
              }
              if (this.options.debug) {
                Quill3.debug(this.options.debug);
              }
              var html = this.container.innerHTML.trim();
              this.container.classList.add("ql-container");
              this.container.innerHTML = "";
              this.container.__quill = this;
              this.root = this.addContainer("ql-editor");
              this.root.classList.add("ql-blank");
              this.root.setAttribute("data-gramm", false);
              this.scrollingContainer = this.options.scrollingContainer || this.root;
              this.emitter = new _emitter4.default();
              this.scroll = _parchment2.default.create(this.root, {
                emitter: this.emitter,
                whitelist: this.options.formats
              });
              this.editor = new _editor2.default(this.scroll);
              this.selection = new _selection2.default(this.scroll, this.emitter);
              this.theme = new this.options.theme(this, this.options);
              this.keyboard = this.theme.addModule("keyboard");
              this.clipboard = this.theme.addModule("clipboard");
              this.history = this.theme.addModule("history");
              this.theme.init();
              this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function(type2) {
                if (type2 === _emitter4.default.events.TEXT_CHANGE) {
                  _this2.root.classList.toggle("ql-blank", _this2.editor.isBlank());
                }
              });
              this.emitter.on(_emitter4.default.events.SCROLL_UPDATE, function(source, mutations) {
                var range2 = _this2.selection.lastRange;
                var index2 = range2 && range2.length === 0 ? range2.index : void 0;
                modify.call(_this2, function() {
                  return _this2.editor.update(null, mutations, index2);
                }, source);
              });
              var contents = this.clipboard.convert(`<div class='ql-editor' style="white-space: normal;">` + html + "<p><br></p></div>");
              this.setContents(contents);
              this.history.clear();
              if (this.options.placeholder) {
                this.root.setAttribute("data-placeholder", this.options.placeholder);
              }
              if (this.options.readOnly) {
                this.disable();
              }
            }
            _createClass2(Quill3, [{
              key: "addContainer",
              value: function addContainer(container2) {
                var refNode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                if (typeof container2 === "string") {
                  var className = container2;
                  container2 = document.createElement("div");
                  container2.classList.add(className);
                }
                this.container.insertBefore(container2, refNode);
                return container2;
              }
            }, {
              key: "blur",
              value: function blur() {
                this.selection.setRange(null);
              }
            }, {
              key: "deleteText",
              value: function deleteText(index2, length, source) {
                var _this3 = this;
                var _overload = overload(index2, length, source);
                var _overload2 = _slicedToArray2(_overload, 4);
                index2 = _overload2[0];
                length = _overload2[1];
                source = _overload2[3];
                return modify.call(this, function() {
                  return _this3.editor.deleteText(index2, length);
                }, source, index2, -1 * length);
              }
            }, {
              key: "disable",
              value: function disable() {
                this.enable(false);
              }
            }, {
              key: "enable",
              value: function enable() {
                var enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                this.scroll.enable(enabled);
                this.container.classList.toggle("ql-disabled", !enabled);
              }
            }, {
              key: "focus",
              value: function focus() {
                var scrollTop = this.scrollingContainer.scrollTop;
                this.selection.focus();
                this.scrollingContainer.scrollTop = scrollTop;
                this.scrollIntoView();
              }
            }, {
              key: "format",
              value: function format2(name, value) {
                var _this4 = this;
                var source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _emitter4.default.sources.API;
                return modify.call(this, function() {
                  var range2 = _this4.getSelection(true);
                  var change = new _quillDelta2.default();
                  if (range2 == null) {
                    return change;
                  } else if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {
                    change = _this4.editor.formatLine(range2.index, range2.length, _defineProperty2({}, name, value));
                  } else if (range2.length === 0) {
                    _this4.selection.format(name, value);
                    return change;
                  } else {
                    change = _this4.editor.formatText(range2.index, range2.length, _defineProperty2({}, name, value));
                  }
                  _this4.setSelection(range2, _emitter4.default.sources.SILENT);
                  return change;
                }, source);
              }
            }, {
              key: "formatLine",
              value: function formatLine(index2, length, name, value, source) {
                var _this5 = this;
                var formats = void 0;
                var _overload3 = overload(index2, length, name, value, source);
                var _overload4 = _slicedToArray2(_overload3, 4);
                index2 = _overload4[0];
                length = _overload4[1];
                formats = _overload4[2];
                source = _overload4[3];
                return modify.call(this, function() {
                  return _this5.editor.formatLine(index2, length, formats);
                }, source, index2, 0);
              }
            }, {
              key: "formatText",
              value: function formatText(index2, length, name, value, source) {
                var _this6 = this;
                var formats = void 0;
                var _overload5 = overload(index2, length, name, value, source);
                var _overload6 = _slicedToArray2(_overload5, 4);
                index2 = _overload6[0];
                length = _overload6[1];
                formats = _overload6[2];
                source = _overload6[3];
                return modify.call(this, function() {
                  return _this6.editor.formatText(index2, length, formats);
                }, source, index2, 0);
              }
            }, {
              key: "getBounds",
              value: function getBounds(index2) {
                var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                var bounds = void 0;
                if (typeof index2 === "number") {
                  bounds = this.selection.getBounds(index2, length);
                } else {
                  bounds = this.selection.getBounds(index2.index, index2.length);
                }
                var containerBounds = this.container.getBoundingClientRect();
                return {
                  bottom: bounds.bottom - containerBounds.top,
                  height: bounds.height,
                  left: bounds.left - containerBounds.left,
                  right: bounds.right - containerBounds.left,
                  top: bounds.top - containerBounds.top,
                  width: bounds.width
                };
              }
            }, {
              key: "getContents",
              value: function getContents() {
                var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getLength() - index2;
                var _overload7 = overload(index2, length);
                var _overload8 = _slicedToArray2(_overload7, 2);
                index2 = _overload8[0];
                length = _overload8[1];
                return this.editor.getContents(index2, length);
              }
            }, {
              key: "getFormat",
              value: function getFormat2() {
                var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getSelection(true);
                var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                if (typeof index2 === "number") {
                  return this.editor.getFormat(index2, length);
                } else {
                  return this.editor.getFormat(index2.index, index2.length);
                }
              }
            }, {
              key: "getIndex",
              value: function getIndex(blot) {
                return blot.offset(this.scroll);
              }
            }, {
              key: "getLength",
              value: function getLength() {
                return this.scroll.length();
              }
            }, {
              key: "getLeaf",
              value: function getLeaf(index2) {
                return this.scroll.leaf(index2);
              }
            }, {
              key: "getLine",
              value: function getLine(index2) {
                return this.scroll.line(index2);
              }
            }, {
              key: "getLines",
              value: function getLines() {
                var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE;
                if (typeof index2 !== "number") {
                  return this.scroll.lines(index2.index, index2.length);
                } else {
                  return this.scroll.lines(index2, length);
                }
              }
            }, {
              key: "getModule",
              value: function getModule(name) {
                return this.theme.modules[name];
              }
            }, {
              key: "getSelection",
              value: function getSelection() {
                var focus = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                if (focus)
                  this.focus();
                this.update();
                return this.selection.getRange()[0];
              }
            }, {
              key: "getText",
              value: function getText() {
                var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getLength() - index2;
                var _overload9 = overload(index2, length);
                var _overload10 = _slicedToArray2(_overload9, 2);
                index2 = _overload10[0];
                length = _overload10[1];
                return this.editor.getText(index2, length);
              }
            }, {
              key: "hasFocus",
              value: function hasFocus() {
                return this.selection.hasFocus();
              }
            }, {
              key: "insertEmbed",
              value: function insertEmbed(index2, embed, value) {
                var _this7 = this;
                var source = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Quill3.sources.API;
                return modify.call(this, function() {
                  return _this7.editor.insertEmbed(index2, embed, value);
                }, source, index2);
              }
            }, {
              key: "insertText",
              value: function insertText(index2, text, name, value, source) {
                var _this8 = this;
                var formats = void 0;
                var _overload11 = overload(index2, 0, name, value, source);
                var _overload12 = _slicedToArray2(_overload11, 4);
                index2 = _overload12[0];
                formats = _overload12[2];
                source = _overload12[3];
                return modify.call(this, function() {
                  return _this8.editor.insertText(index2, text, formats);
                }, source, index2, text.length);
              }
            }, {
              key: "isEnabled",
              value: function isEnabled2() {
                return !this.container.classList.contains("ql-disabled");
              }
            }, {
              key: "off",
              value: function off() {
                return this.emitter.off.apply(this.emitter, arguments);
              }
            }, {
              key: "on",
              value: function on() {
                return this.emitter.on.apply(this.emitter, arguments);
              }
            }, {
              key: "once",
              value: function once() {
                return this.emitter.once.apply(this.emitter, arguments);
              }
            }, {
              key: "pasteHTML",
              value: function pasteHTML(index2, html, source) {
                this.clipboard.dangerouslyPasteHTML(index2, html, source);
              }
            }, {
              key: "removeFormat",
              value: function removeFormat(index2, length, source) {
                var _this9 = this;
                var _overload13 = overload(index2, length, source);
                var _overload14 = _slicedToArray2(_overload13, 4);
                index2 = _overload14[0];
                length = _overload14[1];
                source = _overload14[3];
                return modify.call(this, function() {
                  return _this9.editor.removeFormat(index2, length);
                }, source, index2);
              }
            }, {
              key: "scrollIntoView",
              value: function scrollIntoView() {
                this.selection.scrollIntoView(this.scrollingContainer);
              }
            }, {
              key: "setContents",
              value: function setContents(delta) {
                var _this10 = this;
                var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _emitter4.default.sources.API;
                return modify.call(this, function() {
                  delta = new _quillDelta2.default(delta);
                  var length = _this10.getLength();
                  var deleted = _this10.editor.deleteText(0, length);
                  var applied = _this10.editor.applyDelta(delta);
                  var lastOp = applied.ops[applied.ops.length - 1];
                  if (lastOp != null && typeof lastOp.insert === "string" && lastOp.insert[lastOp.insert.length - 1] === "\n") {
                    _this10.editor.deleteText(_this10.getLength() - 1, 1);
                    applied.delete(1);
                  }
                  var ret = deleted.compose(applied);
                  return ret;
                }, source);
              }
            }, {
              key: "setSelection",
              value: function setSelection(index2, length, source) {
                if (index2 == null) {
                  this.selection.setRange(null, length || Quill3.sources.API);
                } else {
                  var _overload15 = overload(index2, length, source);
                  var _overload16 = _slicedToArray2(_overload15, 4);
                  index2 = _overload16[0];
                  length = _overload16[1];
                  source = _overload16[3];
                  this.selection.setRange(new _selection.Range(index2, length), source);
                  if (source !== _emitter4.default.sources.SILENT) {
                    this.selection.scrollIntoView(this.scrollingContainer);
                  }
                }
              }
            }, {
              key: "setText",
              value: function setText(text) {
                var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _emitter4.default.sources.API;
                var delta = new _quillDelta2.default().insert(text);
                return this.setContents(delta, source);
              }
            }, {
              key: "update",
              value: function update2() {
                var source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _emitter4.default.sources.USER;
                var change = this.scroll.update(source);
                this.selection.update(source);
                return change;
              }
            }, {
              key: "updateContents",
              value: function updateContents(delta) {
                var _this11 = this;
                var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _emitter4.default.sources.API;
                return modify.call(this, function() {
                  delta = new _quillDelta2.default(delta);
                  return _this11.editor.applyDelta(delta, source);
                }, source, true);
              }
            }]);
            return Quill3;
          }();
          Quill2.DEFAULTS = {
            bounds: null,
            formats: null,
            modules: {},
            placeholder: "",
            readOnly: false,
            scrollingContainer: null,
            strict: true,
            theme: "default"
          };
          Quill2.events = _emitter4.default.events;
          Quill2.sources = _emitter4.default.sources;
          Quill2.version = "1.3.7";
          Quill2.imports = {
            "delta": _quillDelta2.default,
            "parchment": _parchment2.default,
            "core/module": _module2.default,
            "core/theme": _theme2.default
          };
          function expandConfig(container2, userConfig) {
            userConfig = (0, _extend2.default)(true, {
              container: container2,
              modules: {
                clipboard: true,
                keyboard: true,
                history: true
              }
            }, userConfig);
            if (!userConfig.theme || userConfig.theme === Quill2.DEFAULTS.theme) {
              userConfig.theme = _theme2.default;
            } else {
              userConfig.theme = Quill2.import("themes/" + userConfig.theme);
              if (userConfig.theme == null) {
                throw new Error("Invalid theme " + userConfig.theme + ". Did you register it?");
              }
            }
            var themeConfig = (0, _extend2.default)(true, {}, userConfig.theme.DEFAULTS);
            [themeConfig, userConfig].forEach(function(config2) {
              config2.modules = config2.modules || {};
              Object.keys(config2.modules).forEach(function(module4) {
                if (config2.modules[module4] === true) {
                  config2.modules[module4] = {};
                }
              });
            });
            var moduleNames = Object.keys(themeConfig.modules).concat(Object.keys(userConfig.modules));
            var moduleConfig = moduleNames.reduce(function(config2, name) {
              var moduleClass = Quill2.import("modules/" + name);
              if (moduleClass == null) {
                debug.error("Cannot load " + name + " module. Are you sure you registered it?");
              } else {
                config2[name] = moduleClass.DEFAULTS || {};
              }
              return config2;
            }, {});
            if (userConfig.modules != null && userConfig.modules.toolbar && userConfig.modules.toolbar.constructor !== Object) {
              userConfig.modules.toolbar = {
                container: userConfig.modules.toolbar
              };
            }
            userConfig = (0, _extend2.default)(true, {}, Quill2.DEFAULTS, { modules: moduleConfig }, themeConfig, userConfig);
            ["bounds", "container", "scrollingContainer"].forEach(function(key) {
              if (typeof userConfig[key] === "string") {
                userConfig[key] = document.querySelector(userConfig[key]);
              }
            });
            userConfig.modules = Object.keys(userConfig.modules).reduce(function(config2, name) {
              if (userConfig.modules[name]) {
                config2[name] = userConfig.modules[name];
              }
              return config2;
            }, {});
            return userConfig;
          }
          function modify(modifier, source, index2, shift) {
            if (this.options.strict && !this.isEnabled() && source === _emitter4.default.sources.USER) {
              return new _quillDelta2.default();
            }
            var range2 = index2 == null ? null : this.getSelection();
            var oldDelta = this.editor.delta;
            var change = modifier();
            if (range2 != null) {
              if (index2 === true)
                index2 = range2.index;
              if (shift == null) {
                range2 = shiftRange(range2, change, source);
              } else if (shift !== 0) {
                range2 = shiftRange(range2, index2, shift, source);
              }
              this.setSelection(range2, _emitter4.default.sources.SILENT);
            }
            if (change.length() > 0) {
              var _emitter;
              var args = [_emitter4.default.events.TEXT_CHANGE, change, oldDelta, source];
              (_emitter = this.emitter).emit.apply(_emitter, [_emitter4.default.events.EDITOR_CHANGE].concat(args));
              if (source !== _emitter4.default.sources.SILENT) {
                var _emitter2;
                (_emitter2 = this.emitter).emit.apply(_emitter2, args);
              }
            }
            return change;
          }
          function overload(index2, length, name, value, source) {
            var formats = {};
            if (typeof index2.index === "number" && typeof index2.length === "number") {
              if (typeof length !== "number") {
                source = value, value = name, name = length, length = index2.length, index2 = index2.index;
              } else {
                length = index2.length, index2 = index2.index;
              }
            } else if (typeof length !== "number") {
              source = value, value = name, name = length, length = 0;
            }
            if ((typeof name === "undefined" ? "undefined" : _typeof2(name)) === "object") {
              formats = name;
              source = value;
            } else if (typeof name === "string") {
              if (value != null) {
                formats[name] = value;
              } else {
                source = name;
              }
            }
            source = source || _emitter4.default.sources.API;
            return [index2, length, formats, source];
          }
          function shiftRange(range2, index2, length, source) {
            if (range2 == null)
              return null;
            var start2 = void 0, end = void 0;
            if (index2 instanceof _quillDelta2.default) {
              var _map = [range2.index, range2.index + range2.length].map(function(pos) {
                return index2.transformPosition(pos, source !== _emitter4.default.sources.USER);
              });
              var _map22 = _slicedToArray2(_map, 2);
              start2 = _map22[0];
              end = _map22[1];
            } else {
              var _map32 = [range2.index, range2.index + range2.length].map(function(pos) {
                if (pos < index2 || pos === index2 && source === _emitter4.default.sources.USER)
                  return pos;
                if (length >= 0) {
                  return pos + length;
                } else {
                  return Math.max(index2, pos + length);
                }
              });
              var _map4 = _slicedToArray2(_map32, 2);
              start2 = _map4[0];
              end = _map4[1];
            }
            return new _selection.Range(start2, end - start2);
          }
          exports3.expandConfig = expandConfig;
          exports3.overload = overload;
          exports3.default = Quill2;
        },
        /* 6 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get4(object, property2, receiver) {
            if (object === null)
              object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get4(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _text = __webpack_require__(7);
          var _text2 = _interopRequireDefault2(_text);
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var Inline = function(_Parchment$Inline) {
            _inherits2(Inline2, _Parchment$Inline);
            function Inline2() {
              _classCallCheck2(this, Inline2);
              return _possibleConstructorReturn2(this, (Inline2.__proto__ || Object.getPrototypeOf(Inline2)).apply(this, arguments));
            }
            _createClass2(Inline2, [{
              key: "formatAt",
              value: function formatAt(index2, length, name, value) {
                if (Inline2.compare(this.statics.blotName, name) < 0 && _parchment2.default.query(name, _parchment2.default.Scope.BLOT)) {
                  var blot = this.isolate(index2, length);
                  if (value) {
                    blot.wrap(name, value);
                  }
                } else {
                  _get2(Inline2.prototype.__proto__ || Object.getPrototypeOf(Inline2.prototype), "formatAt", this).call(this, index2, length, name, value);
                }
              }
            }, {
              key: "optimize",
              value: function optimize(context2) {
                _get2(Inline2.prototype.__proto__ || Object.getPrototypeOf(Inline2.prototype), "optimize", this).call(this, context2);
                if (this.parent instanceof Inline2 && Inline2.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {
                  var parent2 = this.parent.isolate(this.offset(), this.length());
                  this.moveChildren(parent2);
                  parent2.wrap(this);
                }
              }
            }], [{
              key: "compare",
              value: function compare(self2, other) {
                var selfIndex = Inline2.order.indexOf(self2);
                var otherIndex = Inline2.order.indexOf(other);
                if (selfIndex >= 0 || otherIndex >= 0) {
                  return selfIndex - otherIndex;
                } else if (self2 === other) {
                  return 0;
                } else if (self2 < other) {
                  return -1;
                } else {
                  return 1;
                }
              }
            }]);
            return Inline2;
          }(_parchment2.default.Inline);
          Inline.allowedChildren = [Inline, _parchment2.default.Embed, _text2.default];
          Inline.order = [
            "cursor",
            "inline",
            // Must be lower
            "underline",
            "strike",
            "italic",
            "bold",
            "script",
            "link",
            "code"
            // Must be higher
          ];
          exports3.default = Inline;
        },
        /* 7 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var TextBlot = function(_Parchment$Text) {
            _inherits2(TextBlot2, _Parchment$Text);
            function TextBlot2() {
              _classCallCheck2(this, TextBlot2);
              return _possibleConstructorReturn2(this, (TextBlot2.__proto__ || Object.getPrototypeOf(TextBlot2)).apply(this, arguments));
            }
            return TextBlot2;
          }(_parchment2.default.Text);
          exports3.default = TextBlot;
        },
        /* 8 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get4(object, property2, receiver) {
            if (object === null)
              object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get4(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _eventemitter = __webpack_require__(54);
          var _eventemitter2 = _interopRequireDefault2(_eventemitter);
          var _logger = __webpack_require__(10);
          var _logger2 = _interopRequireDefault2(_logger);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var debug = (0, _logger2.default)("quill:events");
          var EVENTS = ["selectionchange", "mousedown", "mouseup", "click"];
          EVENTS.forEach(function(eventName) {
            document.addEventListener(eventName, function() {
              for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              [].slice.call(document.querySelectorAll(".ql-container")).forEach(function(node) {
                if (node.__quill && node.__quill.emitter) {
                  var _node$__quill$emitter;
                  (_node$__quill$emitter = node.__quill.emitter).handleDOM.apply(_node$__quill$emitter, args);
                }
              });
            });
          });
          var Emitter = function(_EventEmitter) {
            _inherits2(Emitter2, _EventEmitter);
            function Emitter2() {
              _classCallCheck2(this, Emitter2);
              var _this = _possibleConstructorReturn2(this, (Emitter2.__proto__ || Object.getPrototypeOf(Emitter2)).call(this));
              _this.listeners = {};
              _this.on("error", debug.error);
              return _this;
            }
            _createClass2(Emitter2, [{
              key: "emit",
              value: function emit() {
                debug.log.apply(debug, arguments);
                _get2(Emitter2.prototype.__proto__ || Object.getPrototypeOf(Emitter2.prototype), "emit", this).apply(this, arguments);
              }
            }, {
              key: "handleDOM",
              value: function handleDOM(event) {
                for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                (this.listeners[event.type] || []).forEach(function(_ref) {
                  var node = _ref.node, handler = _ref.handler;
                  if (event.target === node || node.contains(event.target)) {
                    handler.apply(void 0, [event].concat(args));
                  }
                });
              }
            }, {
              key: "listenDOM",
              value: function listenDOM(eventName, node, handler) {
                if (!this.listeners[eventName]) {
                  this.listeners[eventName] = [];
                }
                this.listeners[eventName].push({ node, handler });
              }
            }]);
            return Emitter2;
          }(_eventemitter2.default);
          Emitter.events = {
            EDITOR_CHANGE: "editor-change",
            SCROLL_BEFORE_UPDATE: "scroll-before-update",
            SCROLL_OPTIMIZE: "scroll-optimize",
            SCROLL_UPDATE: "scroll-update",
            SELECTION_CHANGE: "selection-change",
            TEXT_CHANGE: "text-change"
          };
          Emitter.sources = {
            API: "api",
            SILENT: "silent",
            USER: "user"
          };
          exports3.default = Emitter;
        },
        /* 9 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var Module = function Module2(quill2) {
            var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            _classCallCheck2(this, Module2);
            this.quill = quill2;
            this.options = options;
          };
          Module.DEFAULTS = {};
          exports3.default = Module;
        },
        /* 10 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var levels = ["error", "warn", "log", "info"];
          var level = "warn";
          function debug(method) {
            if (levels.indexOf(method) <= levels.indexOf(level)) {
              var _console;
              for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              (_console = console)[method].apply(_console, args);
            }
          }
          function namespace(ns) {
            return levels.reduce(function(logger2, method) {
              logger2[method] = debug.bind(console, method, ns);
              return logger2;
            }, {});
          }
          debug.level = namespace.level = function(newLevel) {
            level = newLevel;
          };
          exports3.default = namespace;
        },
        /* 11 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var pSlice = Array.prototype.slice;
          var objectKeys = __webpack_require__(52);
          var isArguments2 = __webpack_require__(53);
          var deepEqual3 = module3.exports = function(actual, expected, opts) {
            if (!opts)
              opts = {};
            if (actual === expected) {
              return true;
            } else if (actual instanceof Date && expected instanceof Date) {
              return actual.getTime() === expected.getTime();
            } else if (!actual || !expected || typeof actual != "object" && typeof expected != "object") {
              return opts.strict ? actual === expected : actual == expected;
            } else {
              return objEquiv(actual, expected, opts);
            }
          };
          function isUndefinedOrNull(value) {
            return value === null || value === void 0;
          }
          function isBuffer2(x) {
            if (!x || typeof x !== "object" || typeof x.length !== "number")
              return false;
            if (typeof x.copy !== "function" || typeof x.slice !== "function") {
              return false;
            }
            if (x.length > 0 && typeof x[0] !== "number")
              return false;
            return true;
          }
          function objEquiv(a2, b2, opts) {
            var i2, key;
            if (isUndefinedOrNull(a2) || isUndefinedOrNull(b2))
              return false;
            if (a2.prototype !== b2.prototype)
              return false;
            if (isArguments2(a2)) {
              if (!isArguments2(b2)) {
                return false;
              }
              a2 = pSlice.call(a2);
              b2 = pSlice.call(b2);
              return deepEqual3(a2, b2, opts);
            }
            if (isBuffer2(a2)) {
              if (!isBuffer2(b2)) {
                return false;
              }
              if (a2.length !== b2.length)
                return false;
              for (i2 = 0; i2 < a2.length; i2++) {
                if (a2[i2] !== b2[i2])
                  return false;
              }
              return true;
            }
            try {
              var ka = objectKeys(a2), kb = objectKeys(b2);
            } catch (e2) {
              return false;
            }
            if (ka.length != kb.length)
              return false;
            ka.sort();
            kb.sort();
            for (i2 = ka.length - 1; i2 >= 0; i2--) {
              if (ka[i2] != kb[i2])
                return false;
            }
            for (i2 = ka.length - 1; i2 >= 0; i2--) {
              key = ka[i2];
              if (!deepEqual3(a2[key], b2[key], opts))
                return false;
            }
            return typeof a2 === typeof b2;
          }
        },
        /* 12 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          var Registry = __webpack_require__(1);
          var Attributor = (
            /** @class */
            function() {
              function Attributor2(attrName, keyName, options) {
                if (options === void 0) {
                  options = {};
                }
                this.attrName = attrName;
                this.keyName = keyName;
                var attributeBit = Registry.Scope.TYPE & Registry.Scope.ATTRIBUTE;
                if (options.scope != null) {
                  this.scope = options.scope & Registry.Scope.LEVEL | attributeBit;
                } else {
                  this.scope = Registry.Scope.ATTRIBUTE;
                }
                if (options.whitelist != null)
                  this.whitelist = options.whitelist;
              }
              Attributor2.keys = function(node) {
                return [].map.call(node.attributes, function(item) {
                  return item.name;
                });
              };
              Attributor2.prototype.add = function(node, value) {
                if (!this.canAdd(node, value))
                  return false;
                node.setAttribute(this.keyName, value);
                return true;
              };
              Attributor2.prototype.canAdd = function(node, value) {
                var match5 = Registry.query(node, Registry.Scope.BLOT & (this.scope | Registry.Scope.TYPE));
                if (match5 == null)
                  return false;
                if (this.whitelist == null)
                  return true;
                if (typeof value === "string") {
                  return this.whitelist.indexOf(value.replace(/["']/g, "")) > -1;
                } else {
                  return this.whitelist.indexOf(value) > -1;
                }
              };
              Attributor2.prototype.remove = function(node) {
                node.removeAttribute(this.keyName);
              };
              Attributor2.prototype.value = function(node) {
                var value = node.getAttribute(this.keyName);
                if (this.canAdd(node, value) && value) {
                  return value;
                }
                return "";
              };
              return Attributor2;
            }()
          );
          exports3.default = Attributor;
        },
        /* 13 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.default = exports3.Code = void 0;
          var _slicedToArray2 = function() {
            function sliceIterator(arr, i2) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i2 && _arr.length === i2)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"])
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            return function(arr, i2) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i2);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get4(object, property2, receiver) {
            if (object === null)
              object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get4(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _quillDelta = __webpack_require__(2);
          var _quillDelta2 = _interopRequireDefault2(_quillDelta);
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _block = __webpack_require__(4);
          var _block2 = _interopRequireDefault2(_block);
          var _inline = __webpack_require__(6);
          var _inline2 = _interopRequireDefault2(_inline);
          var _text = __webpack_require__(7);
          var _text2 = _interopRequireDefault2(_text);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var Code = function(_Inline) {
            _inherits2(Code2, _Inline);
            function Code2() {
              _classCallCheck2(this, Code2);
              return _possibleConstructorReturn2(this, (Code2.__proto__ || Object.getPrototypeOf(Code2)).apply(this, arguments));
            }
            return Code2;
          }(_inline2.default);
          Code.blotName = "code";
          Code.tagName = "CODE";
          var CodeBlock = function(_Block) {
            _inherits2(CodeBlock2, _Block);
            function CodeBlock2() {
              _classCallCheck2(this, CodeBlock2);
              return _possibleConstructorReturn2(this, (CodeBlock2.__proto__ || Object.getPrototypeOf(CodeBlock2)).apply(this, arguments));
            }
            _createClass2(CodeBlock2, [{
              key: "delta",
              value: function delta() {
                var _this3 = this;
                var text = this.domNode.textContent;
                if (text.endsWith("\n")) {
                  text = text.slice(0, -1);
                }
                return text.split("\n").reduce(function(delta2, frag) {
                  return delta2.insert(frag).insert("\n", _this3.formats());
                }, new _quillDelta2.default());
              }
            }, {
              key: "format",
              value: function format2(name, value) {
                if (name === this.statics.blotName && value)
                  return;
                var _descendant = this.descendant(_text2.default, this.length() - 1), _descendant2 = _slicedToArray2(_descendant, 1), text = _descendant2[0];
                if (text != null) {
                  text.deleteAt(text.length() - 1, 1);
                }
                _get2(CodeBlock2.prototype.__proto__ || Object.getPrototypeOf(CodeBlock2.prototype), "format", this).call(this, name, value);
              }
            }, {
              key: "formatAt",
              value: function formatAt(index2, length, name, value) {
                if (length === 0)
                  return;
                if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK) == null || name === this.statics.blotName && value === this.statics.formats(this.domNode)) {
                  return;
                }
                var nextNewline = this.newlineIndex(index2);
                if (nextNewline < 0 || nextNewline >= index2 + length)
                  return;
                var prevNewline = this.newlineIndex(index2, true) + 1;
                var isolateLength = nextNewline - prevNewline + 1;
                var blot = this.isolate(prevNewline, isolateLength);
                var next = blot.next;
                blot.format(name, value);
                if (next instanceof CodeBlock2) {
                  next.formatAt(0, index2 - prevNewline + length - isolateLength, name, value);
                }
              }
            }, {
              key: "insertAt",
              value: function insertAt(index2, value, def) {
                if (def != null)
                  return;
                var _descendant3 = this.descendant(_text2.default, index2), _descendant4 = _slicedToArray2(_descendant3, 2), text = _descendant4[0], offset2 = _descendant4[1];
                text.insertAt(offset2, value);
              }
            }, {
              key: "length",
              value: function length() {
                var length2 = this.domNode.textContent.length;
                if (!this.domNode.textContent.endsWith("\n")) {
                  return length2 + 1;
                }
                return length2;
              }
            }, {
              key: "newlineIndex",
              value: function newlineIndex(searchIndex) {
                var reverse = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                if (!reverse) {
                  var offset2 = this.domNode.textContent.slice(searchIndex).indexOf("\n");
                  return offset2 > -1 ? searchIndex + offset2 : -1;
                } else {
                  return this.domNode.textContent.slice(0, searchIndex).lastIndexOf("\n");
                }
              }
            }, {
              key: "optimize",
              value: function optimize(context2) {
                if (!this.domNode.textContent.endsWith("\n")) {
                  this.appendChild(_parchment2.default.create("text", "\n"));
                }
                _get2(CodeBlock2.prototype.__proto__ || Object.getPrototypeOf(CodeBlock2.prototype), "optimize", this).call(this, context2);
                var next = this.next;
                if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && this.statics.formats(this.domNode) === next.statics.formats(next.domNode)) {
                  next.optimize(context2);
                  next.moveChildren(this);
                  next.remove();
                }
              }
            }, {
              key: "replace",
              value: function replace(target) {
                _get2(CodeBlock2.prototype.__proto__ || Object.getPrototypeOf(CodeBlock2.prototype), "replace", this).call(this, target);
                [].slice.call(this.domNode.querySelectorAll("*")).forEach(function(node) {
                  var blot = _parchment2.default.find(node);
                  if (blot == null) {
                    node.parentNode.removeChild(node);
                  } else if (blot instanceof _parchment2.default.Embed) {
                    blot.remove();
                  } else {
                    blot.unwrap();
                  }
                });
              }
            }], [{
              key: "create",
              value: function create(value) {
                var domNode = _get2(CodeBlock2.__proto__ || Object.getPrototypeOf(CodeBlock2), "create", this).call(this, value);
                domNode.setAttribute("spellcheck", false);
                return domNode;
              }
            }, {
              key: "formats",
              value: function formats() {
                return true;
              }
            }]);
            return CodeBlock2;
          }(_block2.default);
          CodeBlock.blotName = "code-block";
          CodeBlock.tagName = "PRE";
          CodeBlock.TAB = "  ";
          exports3.Code = Code;
          exports3.default = CodeBlock;
        },
        /* 14 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
            return typeof obj;
          } : function(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
          var _slicedToArray2 = function() {
            function sliceIterator(arr, i2) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i2 && _arr.length === i2)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"])
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            return function(arr, i2) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i2);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _quillDelta = __webpack_require__(2);
          var _quillDelta2 = _interopRequireDefault2(_quillDelta);
          var _op = __webpack_require__(20);
          var _op2 = _interopRequireDefault2(_op);
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _code = __webpack_require__(13);
          var _code2 = _interopRequireDefault2(_code);
          var _cursor = __webpack_require__(24);
          var _cursor2 = _interopRequireDefault2(_cursor);
          var _block = __webpack_require__(4);
          var _block2 = _interopRequireDefault2(_block);
          var _break = __webpack_require__(16);
          var _break2 = _interopRequireDefault2(_break);
          var _clone = __webpack_require__(21);
          var _clone2 = _interopRequireDefault2(_clone);
          var _deepEqual = __webpack_require__(11);
          var _deepEqual2 = _interopRequireDefault2(_deepEqual);
          var _extend = __webpack_require__(3);
          var _extend2 = _interopRequireDefault2(_extend);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _defineProperty2(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var ASCII = /^[ -~]*$/;
          var Editor = function() {
            function Editor2(scroll) {
              _classCallCheck2(this, Editor2);
              this.scroll = scroll;
              this.delta = this.getDelta();
            }
            _createClass2(Editor2, [{
              key: "applyDelta",
              value: function applyDelta(delta) {
                var _this = this;
                var consumeNextNewline = false;
                this.scroll.update();
                var scrollLength = this.scroll.length();
                this.scroll.batchStart();
                delta = normalizeDelta(delta);
                delta.reduce(function(index2, op) {
                  var length = op.retain || op.delete || op.insert.length || 1;
                  var attributes = op.attributes || {};
                  if (op.insert != null) {
                    if (typeof op.insert === "string") {
                      var text = op.insert;
                      if (text.endsWith("\n") && consumeNextNewline) {
                        consumeNextNewline = false;
                        text = text.slice(0, -1);
                      }
                      if (index2 >= scrollLength && !text.endsWith("\n")) {
                        consumeNextNewline = true;
                      }
                      _this.scroll.insertAt(index2, text);
                      var _scroll$line = _this.scroll.line(index2), _scroll$line2 = _slicedToArray2(_scroll$line, 2), line = _scroll$line2[0], offset2 = _scroll$line2[1];
                      var formats = (0, _extend2.default)({}, (0, _block.bubbleFormats)(line));
                      if (line instanceof _block2.default) {
                        var _line$descendant = line.descendant(_parchment2.default.Leaf, offset2), _line$descendant2 = _slicedToArray2(_line$descendant, 1), leaf = _line$descendant2[0];
                        formats = (0, _extend2.default)(formats, (0, _block.bubbleFormats)(leaf));
                      }
                      attributes = _op2.default.attributes.diff(formats, attributes) || {};
                    } else if (_typeof2(op.insert) === "object") {
                      var key = Object.keys(op.insert)[0];
                      if (key == null)
                        return index2;
                      _this.scroll.insertAt(index2, key, op.insert[key]);
                    }
                    scrollLength += length;
                  }
                  Object.keys(attributes).forEach(function(name) {
                    _this.scroll.formatAt(index2, length, name, attributes[name]);
                  });
                  return index2 + length;
                }, 0);
                delta.reduce(function(index2, op) {
                  if (typeof op.delete === "number") {
                    _this.scroll.deleteAt(index2, op.delete);
                    return index2;
                  }
                  return index2 + (op.retain || op.insert.length || 1);
                }, 0);
                this.scroll.batchEnd();
                return this.update(delta);
              }
            }, {
              key: "deleteText",
              value: function deleteText(index2, length) {
                this.scroll.deleteAt(index2, length);
                return this.update(new _quillDelta2.default().retain(index2).delete(length));
              }
            }, {
              key: "formatLine",
              value: function formatLine(index2, length) {
                var _this2 = this;
                var formats = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                this.scroll.update();
                Object.keys(formats).forEach(function(format2) {
                  if (_this2.scroll.whitelist != null && !_this2.scroll.whitelist[format2])
                    return;
                  var lines = _this2.scroll.lines(index2, Math.max(length, 1));
                  var lengthRemaining = length;
                  lines.forEach(function(line) {
                    var lineLength = line.length();
                    if (!(line instanceof _code2.default)) {
                      line.format(format2, formats[format2]);
                    } else {
                      var codeIndex = index2 - line.offset(_this2.scroll);
                      var codeLength = line.newlineIndex(codeIndex + lengthRemaining) - codeIndex + 1;
                      line.formatAt(codeIndex, codeLength, format2, formats[format2]);
                    }
                    lengthRemaining -= lineLength;
                  });
                });
                this.scroll.optimize();
                return this.update(new _quillDelta2.default().retain(index2).retain(length, (0, _clone2.default)(formats)));
              }
            }, {
              key: "formatText",
              value: function formatText(index2, length) {
                var _this3 = this;
                var formats = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                Object.keys(formats).forEach(function(format2) {
                  _this3.scroll.formatAt(index2, length, format2, formats[format2]);
                });
                return this.update(new _quillDelta2.default().retain(index2).retain(length, (0, _clone2.default)(formats)));
              }
            }, {
              key: "getContents",
              value: function getContents(index2, length) {
                return this.delta.slice(index2, index2 + length);
              }
            }, {
              key: "getDelta",
              value: function getDelta() {
                return this.scroll.lines().reduce(function(delta, line) {
                  return delta.concat(line.delta());
                }, new _quillDelta2.default());
              }
            }, {
              key: "getFormat",
              value: function getFormat2(index2) {
                var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                var lines = [], leaves = [];
                if (length === 0) {
                  this.scroll.path(index2).forEach(function(path) {
                    var _path = _slicedToArray2(path, 1), blot = _path[0];
                    if (blot instanceof _block2.default) {
                      lines.push(blot);
                    } else if (blot instanceof _parchment2.default.Leaf) {
                      leaves.push(blot);
                    }
                  });
                } else {
                  lines = this.scroll.lines(index2, length);
                  leaves = this.scroll.descendants(_parchment2.default.Leaf, index2, length);
                }
                var formatsArr = [lines, leaves].map(function(blots) {
                  if (blots.length === 0)
                    return {};
                  var formats = (0, _block.bubbleFormats)(blots.shift());
                  while (Object.keys(formats).length > 0) {
                    var blot = blots.shift();
                    if (blot == null)
                      return formats;
                    formats = combineFormats((0, _block.bubbleFormats)(blot), formats);
                  }
                  return formats;
                });
                return _extend2.default.apply(_extend2.default, formatsArr);
              }
            }, {
              key: "getText",
              value: function getText(index2, length) {
                return this.getContents(index2, length).filter(function(op) {
                  return typeof op.insert === "string";
                }).map(function(op) {
                  return op.insert;
                }).join("");
              }
            }, {
              key: "insertEmbed",
              value: function insertEmbed(index2, embed, value) {
                this.scroll.insertAt(index2, embed, value);
                return this.update(new _quillDelta2.default().retain(index2).insert(_defineProperty2({}, embed, value)));
              }
            }, {
              key: "insertText",
              value: function insertText(index2, text) {
                var _this4 = this;
                var formats = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                text = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
                this.scroll.insertAt(index2, text);
                Object.keys(formats).forEach(function(format2) {
                  _this4.scroll.formatAt(index2, text.length, format2, formats[format2]);
                });
                return this.update(new _quillDelta2.default().retain(index2).insert(text, (0, _clone2.default)(formats)));
              }
            }, {
              key: "isBlank",
              value: function isBlank() {
                if (this.scroll.children.length == 0)
                  return true;
                if (this.scroll.children.length > 1)
                  return false;
                var block = this.scroll.children.head;
                if (block.statics.blotName !== _block2.default.blotName)
                  return false;
                if (block.children.length > 1)
                  return false;
                return block.children.head instanceof _break2.default;
              }
            }, {
              key: "removeFormat",
              value: function removeFormat(index2, length) {
                var text = this.getText(index2, length);
                var _scroll$line3 = this.scroll.line(index2 + length), _scroll$line4 = _slicedToArray2(_scroll$line3, 2), line = _scroll$line4[0], offset2 = _scroll$line4[1];
                var suffixLength = 0, suffix = new _quillDelta2.default();
                if (line != null) {
                  if (!(line instanceof _code2.default)) {
                    suffixLength = line.length() - offset2;
                  } else {
                    suffixLength = line.newlineIndex(offset2) - offset2 + 1;
                  }
                  suffix = line.delta().slice(offset2, offset2 + suffixLength - 1).insert("\n");
                }
                var contents = this.getContents(index2, length + suffixLength);
                var diff2 = contents.diff(new _quillDelta2.default().insert(text).concat(suffix));
                var delta = new _quillDelta2.default().retain(index2).concat(diff2);
                return this.applyDelta(delta);
              }
            }, {
              key: "update",
              value: function update2(change) {
                var mutations = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
                var cursorIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
                var oldDelta = this.delta;
                if (mutations.length === 1 && mutations[0].type === "characterData" && mutations[0].target.data.match(ASCII) && _parchment2.default.find(mutations[0].target)) {
                  var textBlot = _parchment2.default.find(mutations[0].target);
                  var formats = (0, _block.bubbleFormats)(textBlot);
                  var index2 = textBlot.offset(this.scroll);
                  var oldValue = mutations[0].oldValue.replace(_cursor2.default.CONTENTS, "");
                  var oldText = new _quillDelta2.default().insert(oldValue);
                  var newText = new _quillDelta2.default().insert(textBlot.value());
                  var diffDelta = new _quillDelta2.default().retain(index2).concat(oldText.diff(newText, cursorIndex));
                  change = diffDelta.reduce(function(delta, op) {
                    if (op.insert) {
                      return delta.insert(op.insert, formats);
                    } else {
                      return delta.push(op);
                    }
                  }, new _quillDelta2.default());
                  this.delta = oldDelta.compose(change);
                } else {
                  this.delta = this.getDelta();
                  if (!change || !(0, _deepEqual2.default)(oldDelta.compose(change), this.delta)) {
                    change = oldDelta.diff(this.delta, cursorIndex);
                  }
                }
                return change;
              }
            }]);
            return Editor2;
          }();
          function combineFormats(formats, combined) {
            return Object.keys(combined).reduce(function(merged, name) {
              if (formats[name] == null)
                return merged;
              if (combined[name] === formats[name]) {
                merged[name] = combined[name];
              } else if (Array.isArray(combined[name])) {
                if (combined[name].indexOf(formats[name]) < 0) {
                  merged[name] = combined[name].concat([formats[name]]);
                }
              } else {
                merged[name] = [combined[name], formats[name]];
              }
              return merged;
            }, {});
          }
          function normalizeDelta(delta) {
            return delta.reduce(function(delta2, op) {
              if (op.insert === 1) {
                var attributes = (0, _clone2.default)(op.attributes);
                delete attributes["image"];
                return delta2.insert({ image: op.attributes.image }, attributes);
              }
              if (op.attributes != null && (op.attributes.list === true || op.attributes.bullet === true)) {
                op = (0, _clone2.default)(op);
                if (op.attributes.list) {
                  op.attributes.list = "ordered";
                } else {
                  op.attributes.list = "bullet";
                  delete op.attributes.bullet;
                }
              }
              if (typeof op.insert === "string") {
                var text = op.insert.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
                return delta2.insert(text, op.attributes);
              }
              return delta2.push(op);
            }, new _quillDelta2.default());
          }
          exports3.default = Editor;
        },
        /* 15 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.default = exports3.Range = void 0;
          var _slicedToArray2 = function() {
            function sliceIterator(arr, i2) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i2 && _arr.length === i2)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"])
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            return function(arr, i2) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i2);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _clone = __webpack_require__(21);
          var _clone2 = _interopRequireDefault2(_clone);
          var _deepEqual = __webpack_require__(11);
          var _deepEqual2 = _interopRequireDefault2(_deepEqual);
          var _emitter3 = __webpack_require__(8);
          var _emitter4 = _interopRequireDefault2(_emitter3);
          var _logger = __webpack_require__(10);
          var _logger2 = _interopRequireDefault2(_logger);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _toConsumableArray2(arr) {
            if (Array.isArray(arr)) {
              for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++) {
                arr2[i2] = arr[i2];
              }
              return arr2;
            } else {
              return Array.from(arr);
            }
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var debug = (0, _logger2.default)("quill:selection");
          var Range = function Range2(index2) {
            var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            _classCallCheck2(this, Range2);
            this.index = index2;
            this.length = length;
          };
          var Selection = function() {
            function Selection2(scroll, emitter) {
              var _this = this;
              _classCallCheck2(this, Selection2);
              this.emitter = emitter;
              this.scroll = scroll;
              this.composing = false;
              this.mouseDown = false;
              this.root = this.scroll.domNode;
              this.cursor = _parchment2.default.create("cursor", this);
              this.lastRange = this.savedRange = new Range(0, 0);
              this.handleComposition();
              this.handleDragging();
              this.emitter.listenDOM("selectionchange", document, function() {
                if (!_this.mouseDown) {
                  setTimeout(_this.update.bind(_this, _emitter4.default.sources.USER), 1);
                }
              });
              this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function(type2, delta) {
                if (type2 === _emitter4.default.events.TEXT_CHANGE && delta.length() > 0) {
                  _this.update(_emitter4.default.sources.SILENT);
                }
              });
              this.emitter.on(_emitter4.default.events.SCROLL_BEFORE_UPDATE, function() {
                if (!_this.hasFocus())
                  return;
                var native = _this.getNativeRange();
                if (native == null)
                  return;
                if (native.start.node === _this.cursor.textNode)
                  return;
                _this.emitter.once(_emitter4.default.events.SCROLL_UPDATE, function() {
                  try {
                    _this.setNativeRange(native.start.node, native.start.offset, native.end.node, native.end.offset);
                  } catch (ignored) {
                  }
                });
              });
              this.emitter.on(_emitter4.default.events.SCROLL_OPTIMIZE, function(mutations, context2) {
                if (context2.range) {
                  var _context$range = context2.range, startNode = _context$range.startNode, startOffset = _context$range.startOffset, endNode = _context$range.endNode, endOffset = _context$range.endOffset;
                  _this.setNativeRange(startNode, startOffset, endNode, endOffset);
                }
              });
              this.update(_emitter4.default.sources.SILENT);
            }
            _createClass2(Selection2, [{
              key: "handleComposition",
              value: function handleComposition() {
                var _this2 = this;
                this.root.addEventListener("compositionstart", function() {
                  _this2.composing = true;
                });
                this.root.addEventListener("compositionend", function() {
                  _this2.composing = false;
                  if (_this2.cursor.parent) {
                    var range2 = _this2.cursor.restore();
                    if (!range2)
                      return;
                    setTimeout(function() {
                      _this2.setNativeRange(range2.startNode, range2.startOffset, range2.endNode, range2.endOffset);
                    }, 1);
                  }
                });
              }
            }, {
              key: "handleDragging",
              value: function handleDragging() {
                var _this3 = this;
                this.emitter.listenDOM("mousedown", document.body, function() {
                  _this3.mouseDown = true;
                });
                this.emitter.listenDOM("mouseup", document.body, function() {
                  _this3.mouseDown = false;
                  _this3.update(_emitter4.default.sources.USER);
                });
              }
            }, {
              key: "focus",
              value: function focus() {
                if (this.hasFocus())
                  return;
                this.root.focus();
                this.setRange(this.savedRange);
              }
            }, {
              key: "format",
              value: function format2(_format, value) {
                if (this.scroll.whitelist != null && !this.scroll.whitelist[_format])
                  return;
                this.scroll.update();
                var nativeRange = this.getNativeRange();
                if (nativeRange == null || !nativeRange.native.collapsed || _parchment2.default.query(_format, _parchment2.default.Scope.BLOCK))
                  return;
                if (nativeRange.start.node !== this.cursor.textNode) {
                  var blot = _parchment2.default.find(nativeRange.start.node, false);
                  if (blot == null)
                    return;
                  if (blot instanceof _parchment2.default.Leaf) {
                    var after = blot.split(nativeRange.start.offset);
                    blot.parent.insertBefore(this.cursor, after);
                  } else {
                    blot.insertBefore(this.cursor, nativeRange.start.node);
                  }
                  this.cursor.attach();
                }
                this.cursor.format(_format, value);
                this.scroll.optimize();
                this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length);
                this.update();
              }
            }, {
              key: "getBounds",
              value: function getBounds(index2) {
                var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                var scrollLength = this.scroll.length();
                index2 = Math.min(index2, scrollLength - 1);
                length = Math.min(index2 + length, scrollLength - 1) - index2;
                var node = void 0, _scroll$leaf = this.scroll.leaf(index2), _scroll$leaf2 = _slicedToArray2(_scroll$leaf, 2), leaf = _scroll$leaf2[0], offset2 = _scroll$leaf2[1];
                if (leaf == null)
                  return null;
                var _leaf$position = leaf.position(offset2, true);
                var _leaf$position2 = _slicedToArray2(_leaf$position, 2);
                node = _leaf$position2[0];
                offset2 = _leaf$position2[1];
                var range2 = document.createRange();
                if (length > 0) {
                  range2.setStart(node, offset2);
                  var _scroll$leaf3 = this.scroll.leaf(index2 + length);
                  var _scroll$leaf4 = _slicedToArray2(_scroll$leaf3, 2);
                  leaf = _scroll$leaf4[0];
                  offset2 = _scroll$leaf4[1];
                  if (leaf == null)
                    return null;
                  var _leaf$position3 = leaf.position(offset2, true);
                  var _leaf$position4 = _slicedToArray2(_leaf$position3, 2);
                  node = _leaf$position4[0];
                  offset2 = _leaf$position4[1];
                  range2.setEnd(node, offset2);
                  return range2.getBoundingClientRect();
                } else {
                  var side = "left";
                  var rect = void 0;
                  if (node instanceof Text) {
                    if (offset2 < node.data.length) {
                      range2.setStart(node, offset2);
                      range2.setEnd(node, offset2 + 1);
                    } else {
                      range2.setStart(node, offset2 - 1);
                      range2.setEnd(node, offset2);
                      side = "right";
                    }
                    rect = range2.getBoundingClientRect();
                  } else {
                    rect = leaf.domNode.getBoundingClientRect();
                    if (offset2 > 0)
                      side = "right";
                  }
                  return {
                    bottom: rect.top + rect.height,
                    height: rect.height,
                    left: rect[side],
                    right: rect[side],
                    top: rect.top,
                    width: 0
                  };
                }
              }
            }, {
              key: "getNativeRange",
              value: function getNativeRange() {
                var selection = document.getSelection();
                if (selection == null || selection.rangeCount <= 0)
                  return null;
                var nativeRange = selection.getRangeAt(0);
                if (nativeRange == null)
                  return null;
                var range2 = this.normalizeNative(nativeRange);
                debug.info("getNativeRange", range2);
                return range2;
              }
            }, {
              key: "getRange",
              value: function getRange() {
                var normalized = this.getNativeRange();
                if (normalized == null)
                  return [null, null];
                var range2 = this.normalizedToRange(normalized);
                return [range2, normalized];
              }
            }, {
              key: "hasFocus",
              value: function hasFocus() {
                return document.activeElement === this.root;
              }
            }, {
              key: "normalizedToRange",
              value: function normalizedToRange(range2) {
                var _this4 = this;
                var positions = [[range2.start.node, range2.start.offset]];
                if (!range2.native.collapsed) {
                  positions.push([range2.end.node, range2.end.offset]);
                }
                var indexes = positions.map(function(position) {
                  var _position = _slicedToArray2(position, 2), node = _position[0], offset2 = _position[1];
                  var blot = _parchment2.default.find(node, true);
                  var index2 = blot.offset(_this4.scroll);
                  if (offset2 === 0) {
                    return index2;
                  } else if (blot instanceof _parchment2.default.Container) {
                    return index2 + blot.length();
                  } else {
                    return index2 + blot.index(node, offset2);
                  }
                });
                var end = Math.min(Math.max.apply(Math, _toConsumableArray2(indexes)), this.scroll.length() - 1);
                var start2 = Math.min.apply(Math, [end].concat(_toConsumableArray2(indexes)));
                return new Range(start2, end - start2);
              }
            }, {
              key: "normalizeNative",
              value: function normalizeNative(nativeRange) {
                if (!contains(this.root, nativeRange.startContainer) || !nativeRange.collapsed && !contains(this.root, nativeRange.endContainer)) {
                  return null;
                }
                var range2 = {
                  start: { node: nativeRange.startContainer, offset: nativeRange.startOffset },
                  end: { node: nativeRange.endContainer, offset: nativeRange.endOffset },
                  native: nativeRange
                };
                [range2.start, range2.end].forEach(function(position) {
                  var node = position.node, offset2 = position.offset;
                  while (!(node instanceof Text) && node.childNodes.length > 0) {
                    if (node.childNodes.length > offset2) {
                      node = node.childNodes[offset2];
                      offset2 = 0;
                    } else if (node.childNodes.length === offset2) {
                      node = node.lastChild;
                      offset2 = node instanceof Text ? node.data.length : node.childNodes.length + 1;
                    } else {
                      break;
                    }
                  }
                  position.node = node, position.offset = offset2;
                });
                return range2;
              }
            }, {
              key: "rangeToNative",
              value: function rangeToNative(range2) {
                var _this5 = this;
                var indexes = range2.collapsed ? [range2.index] : [range2.index, range2.index + range2.length];
                var args = [];
                var scrollLength = this.scroll.length();
                indexes.forEach(function(index2, i2) {
                  index2 = Math.min(scrollLength - 1, index2);
                  var node = void 0, _scroll$leaf5 = _this5.scroll.leaf(index2), _scroll$leaf6 = _slicedToArray2(_scroll$leaf5, 2), leaf = _scroll$leaf6[0], offset2 = _scroll$leaf6[1];
                  var _leaf$position5 = leaf.position(offset2, i2 !== 0);
                  var _leaf$position6 = _slicedToArray2(_leaf$position5, 2);
                  node = _leaf$position6[0];
                  offset2 = _leaf$position6[1];
                  args.push(node, offset2);
                });
                if (args.length < 2) {
                  args = args.concat(args);
                }
                return args;
              }
            }, {
              key: "scrollIntoView",
              value: function scrollIntoView(scrollingContainer) {
                var range2 = this.lastRange;
                if (range2 == null)
                  return;
                var bounds = this.getBounds(range2.index, range2.length);
                if (bounds == null)
                  return;
                var limit = this.scroll.length() - 1;
                var _scroll$line = this.scroll.line(Math.min(range2.index, limit)), _scroll$line2 = _slicedToArray2(_scroll$line, 1), first = _scroll$line2[0];
                var last2 = first;
                if (range2.length > 0) {
                  var _scroll$line3 = this.scroll.line(Math.min(range2.index + range2.length, limit));
                  var _scroll$line4 = _slicedToArray2(_scroll$line3, 1);
                  last2 = _scroll$line4[0];
                }
                if (first == null || last2 == null)
                  return;
                var scrollBounds = scrollingContainer.getBoundingClientRect();
                if (bounds.top < scrollBounds.top) {
                  scrollingContainer.scrollTop -= scrollBounds.top - bounds.top;
                } else if (bounds.bottom > scrollBounds.bottom) {
                  scrollingContainer.scrollTop += bounds.bottom - scrollBounds.bottom;
                }
              }
            }, {
              key: "setNativeRange",
              value: function setNativeRange(startNode, startOffset) {
                var endNode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : startNode;
                var endOffset = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : startOffset;
                var force = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
                debug.info("setNativeRange", startNode, startOffset, endNode, endOffset);
                if (startNode != null && (this.root.parentNode == null || startNode.parentNode == null || endNode.parentNode == null)) {
                  return;
                }
                var selection = document.getSelection();
                if (selection == null)
                  return;
                if (startNode != null) {
                  if (!this.hasFocus())
                    this.root.focus();
                  var native = (this.getNativeRange() || {}).native;
                  if (native == null || force || startNode !== native.startContainer || startOffset !== native.startOffset || endNode !== native.endContainer || endOffset !== native.endOffset) {
                    if (startNode.tagName == "BR") {
                      startOffset = [].indexOf.call(startNode.parentNode.childNodes, startNode);
                      startNode = startNode.parentNode;
                    }
                    if (endNode.tagName == "BR") {
                      endOffset = [].indexOf.call(endNode.parentNode.childNodes, endNode);
                      endNode = endNode.parentNode;
                    }
                    var range2 = document.createRange();
                    range2.setStart(startNode, startOffset);
                    range2.setEnd(endNode, endOffset);
                    selection.removeAllRanges();
                    selection.addRange(range2);
                  }
                } else {
                  selection.removeAllRanges();
                  this.root.blur();
                  document.body.focus();
                }
              }
            }, {
              key: "setRange",
              value: function setRange(range2) {
                var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                var source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _emitter4.default.sources.API;
                if (typeof force === "string") {
                  source = force;
                  force = false;
                }
                debug.info("setRange", range2);
                if (range2 != null) {
                  var args = this.rangeToNative(range2);
                  this.setNativeRange.apply(this, _toConsumableArray2(args).concat([force]));
                } else {
                  this.setNativeRange(null);
                }
                this.update(source);
              }
            }, {
              key: "update",
              value: function update2() {
                var source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _emitter4.default.sources.USER;
                var oldRange = this.lastRange;
                var _getRange = this.getRange(), _getRange2 = _slicedToArray2(_getRange, 2), lastRange = _getRange2[0], nativeRange = _getRange2[1];
                this.lastRange = lastRange;
                if (this.lastRange != null) {
                  this.savedRange = this.lastRange;
                }
                if (!(0, _deepEqual2.default)(oldRange, this.lastRange)) {
                  var _emitter;
                  if (!this.composing && nativeRange != null && nativeRange.native.collapsed && nativeRange.start.node !== this.cursor.textNode) {
                    this.cursor.restore();
                  }
                  var args = [_emitter4.default.events.SELECTION_CHANGE, (0, _clone2.default)(this.lastRange), (0, _clone2.default)(oldRange), source];
                  (_emitter = this.emitter).emit.apply(_emitter, [_emitter4.default.events.EDITOR_CHANGE].concat(args));
                  if (source !== _emitter4.default.sources.SILENT) {
                    var _emitter2;
                    (_emitter2 = this.emitter).emit.apply(_emitter2, args);
                  }
                }
              }
            }]);
            return Selection2;
          }();
          function contains(parent2, descendant) {
            try {
              descendant.parentNode;
            } catch (e2) {
              return false;
            }
            if (descendant instanceof Text) {
              descendant = descendant.parentNode;
            }
            return parent2.contains(descendant);
          }
          exports3.Range = Range;
          exports3.default = Selection;
        },
        /* 16 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get4(object, property2, receiver) {
            if (object === null)
              object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get4(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var Break = function(_Parchment$Embed) {
            _inherits2(Break2, _Parchment$Embed);
            function Break2() {
              _classCallCheck2(this, Break2);
              return _possibleConstructorReturn2(this, (Break2.__proto__ || Object.getPrototypeOf(Break2)).apply(this, arguments));
            }
            _createClass2(Break2, [{
              key: "insertInto",
              value: function insertInto(parent2, ref) {
                if (parent2.children.length === 0) {
                  _get2(Break2.prototype.__proto__ || Object.getPrototypeOf(Break2.prototype), "insertInto", this).call(this, parent2, ref);
                } else {
                  this.remove();
                }
              }
            }, {
              key: "length",
              value: function length() {
                return 0;
              }
            }, {
              key: "value",
              value: function value() {
                return "";
              }
            }], [{
              key: "value",
              value: function value() {
                return void 0;
              }
            }]);
            return Break2;
          }(_parchment2.default.Embed);
          Break.blotName = "break";
          Break.tagName = "BR";
          exports3.default = Break;
        },
        /* 17 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var __extends2 = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p2 in b2)
                if (b2.hasOwnProperty(p2))
                  d2[p2] = b2[p2];
            };
            return function(d2, b2) {
              extendStatics(d2, b2);
              function __() {
                this.constructor = d2;
              }
              d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
            };
          }();
          Object.defineProperty(exports3, "__esModule", { value: true });
          var linked_list_1 = __webpack_require__(44);
          var shadow_1 = __webpack_require__(30);
          var Registry = __webpack_require__(1);
          var ContainerBlot = (
            /** @class */
            function(_super) {
              __extends2(ContainerBlot2, _super);
              function ContainerBlot2(domNode) {
                var _this = _super.call(this, domNode) || this;
                _this.build();
                return _this;
              }
              ContainerBlot2.prototype.appendChild = function(other) {
                this.insertBefore(other);
              };
              ContainerBlot2.prototype.attach = function() {
                _super.prototype.attach.call(this);
                this.children.forEach(function(child) {
                  child.attach();
                });
              };
              ContainerBlot2.prototype.build = function() {
                var _this = this;
                this.children = new linked_list_1.default();
                [].slice.call(this.domNode.childNodes).reverse().forEach(function(node) {
                  try {
                    var child = makeBlot(node);
                    _this.insertBefore(child, _this.children.head || void 0);
                  } catch (err) {
                    if (err instanceof Registry.ParchmentError)
                      return;
                    else
                      throw err;
                  }
                });
              };
              ContainerBlot2.prototype.deleteAt = function(index2, length) {
                if (index2 === 0 && length === this.length()) {
                  return this.remove();
                }
                this.children.forEachAt(index2, length, function(child, offset2, length2) {
                  child.deleteAt(offset2, length2);
                });
              };
              ContainerBlot2.prototype.descendant = function(criteria, index2) {
                var _a = this.children.find(index2), child = _a[0], offset2 = _a[1];
                if (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) {
                  return [child, offset2];
                } else if (child instanceof ContainerBlot2) {
                  return child.descendant(criteria, offset2);
                } else {
                  return [null, -1];
                }
              };
              ContainerBlot2.prototype.descendants = function(criteria, index2, length) {
                if (index2 === void 0) {
                  index2 = 0;
                }
                if (length === void 0) {
                  length = Number.MAX_VALUE;
                }
                var descendants = [];
                var lengthLeft = length;
                this.children.forEachAt(index2, length, function(child, index3, length2) {
                  if (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) {
                    descendants.push(child);
                  }
                  if (child instanceof ContainerBlot2) {
                    descendants = descendants.concat(child.descendants(criteria, index3, lengthLeft));
                  }
                  lengthLeft -= length2;
                });
                return descendants;
              };
              ContainerBlot2.prototype.detach = function() {
                this.children.forEach(function(child) {
                  child.detach();
                });
                _super.prototype.detach.call(this);
              };
              ContainerBlot2.prototype.formatAt = function(index2, length, name, value) {
                this.children.forEachAt(index2, length, function(child, offset2, length2) {
                  child.formatAt(offset2, length2, name, value);
                });
              };
              ContainerBlot2.prototype.insertAt = function(index2, value, def) {
                var _a = this.children.find(index2), child = _a[0], offset2 = _a[1];
                if (child) {
                  child.insertAt(offset2, value, def);
                } else {
                  var blot = def == null ? Registry.create("text", value) : Registry.create(value, def);
                  this.appendChild(blot);
                }
              };
              ContainerBlot2.prototype.insertBefore = function(childBlot, refBlot) {
                if (this.statics.allowedChildren != null && !this.statics.allowedChildren.some(function(child) {
                  return childBlot instanceof child;
                })) {
                  throw new Registry.ParchmentError("Cannot insert " + childBlot.statics.blotName + " into " + this.statics.blotName);
                }
                childBlot.insertInto(this, refBlot);
              };
              ContainerBlot2.prototype.length = function() {
                return this.children.reduce(function(memo, child) {
                  return memo + child.length();
                }, 0);
              };
              ContainerBlot2.prototype.moveChildren = function(targetParent, refNode) {
                this.children.forEach(function(child) {
                  targetParent.insertBefore(child, refNode);
                });
              };
              ContainerBlot2.prototype.optimize = function(context2) {
                _super.prototype.optimize.call(this, context2);
                if (this.children.length === 0) {
                  if (this.statics.defaultChild != null) {
                    var child = Registry.create(this.statics.defaultChild);
                    this.appendChild(child);
                    child.optimize(context2);
                  } else {
                    this.remove();
                  }
                }
              };
              ContainerBlot2.prototype.path = function(index2, inclusive) {
                if (inclusive === void 0) {
                  inclusive = false;
                }
                var _a = this.children.find(index2, inclusive), child = _a[0], offset2 = _a[1];
                var position = [[this, index2]];
                if (child instanceof ContainerBlot2) {
                  return position.concat(child.path(offset2, inclusive));
                } else if (child != null) {
                  position.push([child, offset2]);
                }
                return position;
              };
              ContainerBlot2.prototype.removeChild = function(child) {
                this.children.remove(child);
              };
              ContainerBlot2.prototype.replace = function(target) {
                if (target instanceof ContainerBlot2) {
                  target.moveChildren(this);
                }
                _super.prototype.replace.call(this, target);
              };
              ContainerBlot2.prototype.split = function(index2, force) {
                if (force === void 0) {
                  force = false;
                }
                if (!force) {
                  if (index2 === 0)
                    return this;
                  if (index2 === this.length())
                    return this.next;
                }
                var after = this.clone();
                this.parent.insertBefore(after, this.next);
                this.children.forEachAt(index2, this.length(), function(child, offset2, length) {
                  child = child.split(offset2, force);
                  after.appendChild(child);
                });
                return after;
              };
              ContainerBlot2.prototype.unwrap = function() {
                this.moveChildren(this.parent, this.next);
                this.remove();
              };
              ContainerBlot2.prototype.update = function(mutations, context2) {
                var _this = this;
                var addedNodes = [];
                var removedNodes = [];
                mutations.forEach(function(mutation) {
                  if (mutation.target === _this.domNode && mutation.type === "childList") {
                    addedNodes.push.apply(addedNodes, mutation.addedNodes);
                    removedNodes.push.apply(removedNodes, mutation.removedNodes);
                  }
                });
                removedNodes.forEach(function(node) {
                  if (node.parentNode != null && // @ts-ignore
                  node.tagName !== "IFRAME" && document.body.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
                    return;
                  }
                  var blot = Registry.find(node);
                  if (blot == null)
                    return;
                  if (blot.domNode.parentNode == null || blot.domNode.parentNode === _this.domNode) {
                    blot.detach();
                  }
                });
                addedNodes.filter(function(node) {
                  return node.parentNode == _this.domNode;
                }).sort(function(a2, b2) {
                  if (a2 === b2)
                    return 0;
                  if (a2.compareDocumentPosition(b2) & Node.DOCUMENT_POSITION_FOLLOWING) {
                    return 1;
                  }
                  return -1;
                }).forEach(function(node) {
                  var refBlot = null;
                  if (node.nextSibling != null) {
                    refBlot = Registry.find(node.nextSibling);
                  }
                  var blot = makeBlot(node);
                  if (blot.next != refBlot || blot.next == null) {
                    if (blot.parent != null) {
                      blot.parent.removeChild(_this);
                    }
                    _this.insertBefore(blot, refBlot || void 0);
                  }
                });
              };
              return ContainerBlot2;
            }(shadow_1.default)
          );
          function makeBlot(node) {
            var blot = Registry.find(node);
            if (blot == null) {
              try {
                blot = Registry.create(node);
              } catch (e2) {
                blot = Registry.create(Registry.Scope.INLINE);
                [].slice.call(node.childNodes).forEach(function(child) {
                  blot.domNode.appendChild(child);
                });
                if (node.parentNode) {
                  node.parentNode.replaceChild(blot.domNode, node);
                }
                blot.attach();
              }
            }
            return blot;
          }
          exports3.default = ContainerBlot;
        },
        /* 18 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var __extends2 = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p2 in b2)
                if (b2.hasOwnProperty(p2))
                  d2[p2] = b2[p2];
            };
            return function(d2, b2) {
              extendStatics(d2, b2);
              function __() {
                this.constructor = d2;
              }
              d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
            };
          }();
          Object.defineProperty(exports3, "__esModule", { value: true });
          var attributor_1 = __webpack_require__(12);
          var store_1 = __webpack_require__(31);
          var container_1 = __webpack_require__(17);
          var Registry = __webpack_require__(1);
          var FormatBlot = (
            /** @class */
            function(_super) {
              __extends2(FormatBlot2, _super);
              function FormatBlot2(domNode) {
                var _this = _super.call(this, domNode) || this;
                _this.attributes = new store_1.default(_this.domNode);
                return _this;
              }
              FormatBlot2.formats = function(domNode) {
                if (typeof this.tagName === "string") {
                  return true;
                } else if (Array.isArray(this.tagName)) {
                  return domNode.tagName.toLowerCase();
                }
                return void 0;
              };
              FormatBlot2.prototype.format = function(name, value) {
                var format2 = Registry.query(name);
                if (format2 instanceof attributor_1.default) {
                  this.attributes.attribute(format2, value);
                } else if (value) {
                  if (format2 != null && (name !== this.statics.blotName || this.formats()[name] !== value)) {
                    this.replaceWith(name, value);
                  }
                }
              };
              FormatBlot2.prototype.formats = function() {
                var formats = this.attributes.values();
                var format2 = this.statics.formats(this.domNode);
                if (format2 != null) {
                  formats[this.statics.blotName] = format2;
                }
                return formats;
              };
              FormatBlot2.prototype.replaceWith = function(name, value) {
                var replacement = _super.prototype.replaceWith.call(this, name, value);
                this.attributes.copy(replacement);
                return replacement;
              };
              FormatBlot2.prototype.update = function(mutations, context2) {
                var _this = this;
                _super.prototype.update.call(this, mutations, context2);
                if (mutations.some(function(mutation) {
                  return mutation.target === _this.domNode && mutation.type === "attributes";
                })) {
                  this.attributes.build();
                }
              };
              FormatBlot2.prototype.wrap = function(name, value) {
                var wrapper = _super.prototype.wrap.call(this, name, value);
                if (wrapper instanceof FormatBlot2 && wrapper.statics.scope === this.statics.scope) {
                  this.attributes.move(wrapper);
                }
                return wrapper;
              };
              return FormatBlot2;
            }(container_1.default)
          );
          exports3.default = FormatBlot;
        },
        /* 19 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var __extends2 = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p2 in b2)
                if (b2.hasOwnProperty(p2))
                  d2[p2] = b2[p2];
            };
            return function(d2, b2) {
              extendStatics(d2, b2);
              function __() {
                this.constructor = d2;
              }
              d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
            };
          }();
          Object.defineProperty(exports3, "__esModule", { value: true });
          var shadow_1 = __webpack_require__(30);
          var Registry = __webpack_require__(1);
          var LeafBlot = (
            /** @class */
            function(_super) {
              __extends2(LeafBlot2, _super);
              function LeafBlot2() {
                return _super !== null && _super.apply(this, arguments) || this;
              }
              LeafBlot2.value = function(domNode) {
                return true;
              };
              LeafBlot2.prototype.index = function(node, offset2) {
                if (this.domNode === node || this.domNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
                  return Math.min(offset2, 1);
                }
                return -1;
              };
              LeafBlot2.prototype.position = function(index2, inclusive) {
                var offset2 = [].indexOf.call(this.parent.domNode.childNodes, this.domNode);
                if (index2 > 0)
                  offset2 += 1;
                return [this.parent.domNode, offset2];
              };
              LeafBlot2.prototype.value = function() {
                var _a;
                return _a = {}, _a[this.statics.blotName] = this.statics.value(this.domNode) || true, _a;
              };
              LeafBlot2.scope = Registry.Scope.INLINE_BLOT;
              return LeafBlot2;
            }(shadow_1.default)
          );
          exports3.default = LeafBlot;
        },
        /* 20 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var equal = __webpack_require__(11);
          var extend3 = __webpack_require__(3);
          var lib2 = {
            attributes: {
              compose: function(a2, b2, keepNull) {
                if (typeof a2 !== "object")
                  a2 = {};
                if (typeof b2 !== "object")
                  b2 = {};
                var attributes = extend3(true, {}, b2);
                if (!keepNull) {
                  attributes = Object.keys(attributes).reduce(function(copy, key2) {
                    if (attributes[key2] != null) {
                      copy[key2] = attributes[key2];
                    }
                    return copy;
                  }, {});
                }
                for (var key in a2) {
                  if (a2[key] !== void 0 && b2[key] === void 0) {
                    attributes[key] = a2[key];
                  }
                }
                return Object.keys(attributes).length > 0 ? attributes : void 0;
              },
              diff: function(a2, b2) {
                if (typeof a2 !== "object")
                  a2 = {};
                if (typeof b2 !== "object")
                  b2 = {};
                var attributes = Object.keys(a2).concat(Object.keys(b2)).reduce(function(attributes2, key) {
                  if (!equal(a2[key], b2[key])) {
                    attributes2[key] = b2[key] === void 0 ? null : b2[key];
                  }
                  return attributes2;
                }, {});
                return Object.keys(attributes).length > 0 ? attributes : void 0;
              },
              transform: function(a2, b2, priority) {
                if (typeof a2 !== "object")
                  return b2;
                if (typeof b2 !== "object")
                  return void 0;
                if (!priority)
                  return b2;
                var attributes = Object.keys(b2).reduce(function(attributes2, key) {
                  if (a2[key] === void 0)
                    attributes2[key] = b2[key];
                  return attributes2;
                }, {});
                return Object.keys(attributes).length > 0 ? attributes : void 0;
              }
            },
            iterator: function(ops) {
              return new Iterator(ops);
            },
            length: function(op) {
              if (typeof op["delete"] === "number") {
                return op["delete"];
              } else if (typeof op.retain === "number") {
                return op.retain;
              } else {
                return typeof op.insert === "string" ? op.insert.length : 1;
              }
            }
          };
          function Iterator(ops) {
            this.ops = ops;
            this.index = 0;
            this.offset = 0;
          }
          Iterator.prototype.hasNext = function() {
            return this.peekLength() < Infinity;
          };
          Iterator.prototype.next = function(length) {
            if (!length)
              length = Infinity;
            var nextOp = this.ops[this.index];
            if (nextOp) {
              var offset2 = this.offset;
              var opLength = lib2.length(nextOp);
              if (length >= opLength - offset2) {
                length = opLength - offset2;
                this.index += 1;
                this.offset = 0;
              } else {
                this.offset += length;
              }
              if (typeof nextOp["delete"] === "number") {
                return { "delete": length };
              } else {
                var retOp = {};
                if (nextOp.attributes) {
                  retOp.attributes = nextOp.attributes;
                }
                if (typeof nextOp.retain === "number") {
                  retOp.retain = length;
                } else if (typeof nextOp.insert === "string") {
                  retOp.insert = nextOp.insert.substr(offset2, length);
                } else {
                  retOp.insert = nextOp.insert;
                }
                return retOp;
              }
            } else {
              return { retain: Infinity };
            }
          };
          Iterator.prototype.peek = function() {
            return this.ops[this.index];
          };
          Iterator.prototype.peekLength = function() {
            if (this.ops[this.index]) {
              return lib2.length(this.ops[this.index]) - this.offset;
            } else {
              return Infinity;
            }
          };
          Iterator.prototype.peekType = function() {
            if (this.ops[this.index]) {
              if (typeof this.ops[this.index]["delete"] === "number") {
                return "delete";
              } else if (typeof this.ops[this.index].retain === "number") {
                return "retain";
              } else {
                return "insert";
              }
            }
            return "retain";
          };
          Iterator.prototype.rest = function() {
            if (!this.hasNext()) {
              return [];
            } else if (this.offset === 0) {
              return this.ops.slice(this.index);
            } else {
              var offset2 = this.offset;
              var index2 = this.index;
              var next = this.next();
              var rest = this.ops.slice(this.index);
              this.offset = offset2;
              this.index = index2;
              return [next].concat(rest);
            }
          };
          module3.exports = lib2;
        },
        /* 21 */
        /***/
        function(module3, exports3) {
          var clone3 = function() {
            function _instanceof(obj, type2) {
              return type2 != null && obj instanceof type2;
            }
            var nativeMap;
            try {
              nativeMap = Map;
            } catch (_) {
              nativeMap = function() {
              };
            }
            var nativeSet;
            try {
              nativeSet = Set;
            } catch (_) {
              nativeSet = function() {
              };
            }
            var nativePromise;
            try {
              nativePromise = Promise;
            } catch (_) {
              nativePromise = function() {
              };
            }
            function clone4(parent2, circular, depth, prototype, includeNonEnumerable) {
              if (typeof circular === "object") {
                depth = circular.depth;
                prototype = circular.prototype;
                includeNonEnumerable = circular.includeNonEnumerable;
                circular = circular.circular;
              }
              var allParents = [];
              var allChildren = [];
              var useBuffer = typeof Buffer != "undefined";
              if (typeof circular == "undefined")
                circular = true;
              if (typeof depth == "undefined")
                depth = Infinity;
              function _clone(parent3, depth2) {
                if (parent3 === null)
                  return null;
                if (depth2 === 0)
                  return parent3;
                var child;
                var proto2;
                if (typeof parent3 != "object") {
                  return parent3;
                }
                if (_instanceof(parent3, nativeMap)) {
                  child = new nativeMap();
                } else if (_instanceof(parent3, nativeSet)) {
                  child = new nativeSet();
                } else if (_instanceof(parent3, nativePromise)) {
                  child = new nativePromise(function(resolve, reject) {
                    parent3.then(function(value) {
                      resolve(_clone(value, depth2 - 1));
                    }, function(err) {
                      reject(_clone(err, depth2 - 1));
                    });
                  });
                } else if (clone4.__isArray(parent3)) {
                  child = [];
                } else if (clone4.__isRegExp(parent3)) {
                  child = new RegExp(parent3.source, __getRegExpFlags(parent3));
                  if (parent3.lastIndex)
                    child.lastIndex = parent3.lastIndex;
                } else if (clone4.__isDate(parent3)) {
                  child = new Date(parent3.getTime());
                } else if (useBuffer && Buffer.isBuffer(parent3)) {
                  if (Buffer.allocUnsafe) {
                    child = Buffer.allocUnsafe(parent3.length);
                  } else {
                    child = new Buffer(parent3.length);
                  }
                  parent3.copy(child);
                  return child;
                } else if (_instanceof(parent3, Error)) {
                  child = Object.create(parent3);
                } else {
                  if (typeof prototype == "undefined") {
                    proto2 = Object.getPrototypeOf(parent3);
                    child = Object.create(proto2);
                  } else {
                    child = Object.create(prototype);
                    proto2 = prototype;
                  }
                }
                if (circular) {
                  var index2 = allParents.indexOf(parent3);
                  if (index2 != -1) {
                    return allChildren[index2];
                  }
                  allParents.push(parent3);
                  allChildren.push(child);
                }
                if (_instanceof(parent3, nativeMap)) {
                  parent3.forEach(function(value, key) {
                    var keyChild = _clone(key, depth2 - 1);
                    var valueChild = _clone(value, depth2 - 1);
                    child.set(keyChild, valueChild);
                  });
                }
                if (_instanceof(parent3, nativeSet)) {
                  parent3.forEach(function(value) {
                    var entryChild = _clone(value, depth2 - 1);
                    child.add(entryChild);
                  });
                }
                for (var i2 in parent3) {
                  var attrs;
                  if (proto2) {
                    attrs = Object.getOwnPropertyDescriptor(proto2, i2);
                  }
                  if (attrs && attrs.set == null) {
                    continue;
                  }
                  child[i2] = _clone(parent3[i2], depth2 - 1);
                }
                if (Object.getOwnPropertySymbols) {
                  var symbols = Object.getOwnPropertySymbols(parent3);
                  for (var i2 = 0; i2 < symbols.length; i2++) {
                    var symbol = symbols[i2];
                    var descriptor = Object.getOwnPropertyDescriptor(parent3, symbol);
                    if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                      continue;
                    }
                    child[symbol] = _clone(parent3[symbol], depth2 - 1);
                    if (!descriptor.enumerable) {
                      Object.defineProperty(child, symbol, {
                        enumerable: false
                      });
                    }
                  }
                }
                if (includeNonEnumerable) {
                  var allPropertyNames = Object.getOwnPropertyNames(parent3);
                  for (var i2 = 0; i2 < allPropertyNames.length; i2++) {
                    var propertyName = allPropertyNames[i2];
                    var descriptor = Object.getOwnPropertyDescriptor(parent3, propertyName);
                    if (descriptor && descriptor.enumerable) {
                      continue;
                    }
                    child[propertyName] = _clone(parent3[propertyName], depth2 - 1);
                    Object.defineProperty(child, propertyName, {
                      enumerable: false
                    });
                  }
                }
                return child;
              }
              return _clone(parent2, depth);
            }
            clone4.clonePrototype = function clonePrototype(parent2) {
              if (parent2 === null)
                return null;
              var c2 = function() {
              };
              c2.prototype = parent2;
              return new c2();
            };
            function __objToStr(o) {
              return Object.prototype.toString.call(o);
            }
            clone4.__objToStr = __objToStr;
            function __isDate(o) {
              return typeof o === "object" && __objToStr(o) === "[object Date]";
            }
            clone4.__isDate = __isDate;
            function __isArray(o) {
              return typeof o === "object" && __objToStr(o) === "[object Array]";
            }
            clone4.__isArray = __isArray;
            function __isRegExp(o) {
              return typeof o === "object" && __objToStr(o) === "[object RegExp]";
            }
            clone4.__isRegExp = __isRegExp;
            function __getRegExpFlags(re) {
              var flags = "";
              if (re.global)
                flags += "g";
              if (re.ignoreCase)
                flags += "i";
              if (re.multiline)
                flags += "m";
              return flags;
            }
            clone4.__getRegExpFlags = __getRegExpFlags;
            return clone4;
          }();
          if (typeof module3 === "object" && module3.exports) {
            module3.exports = clone3;
          }
        },
        /* 22 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _slicedToArray2 = function() {
            function sliceIterator(arr, i2) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i2 && _arr.length === i2)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"])
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            return function(arr, i2) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i2);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get4(object, property2, receiver) {
            if (object === null)
              object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get4(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _emitter = __webpack_require__(8);
          var _emitter2 = _interopRequireDefault2(_emitter);
          var _block = __webpack_require__(4);
          var _block2 = _interopRequireDefault2(_block);
          var _break = __webpack_require__(16);
          var _break2 = _interopRequireDefault2(_break);
          var _code = __webpack_require__(13);
          var _code2 = _interopRequireDefault2(_code);
          var _container = __webpack_require__(25);
          var _container2 = _interopRequireDefault2(_container);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          function isLine(blot) {
            return blot instanceof _block2.default || blot instanceof _block.BlockEmbed;
          }
          var Scroll = function(_Parchment$Scroll) {
            _inherits2(Scroll2, _Parchment$Scroll);
            function Scroll2(domNode, config2) {
              _classCallCheck2(this, Scroll2);
              var _this = _possibleConstructorReturn2(this, (Scroll2.__proto__ || Object.getPrototypeOf(Scroll2)).call(this, domNode));
              _this.emitter = config2.emitter;
              if (Array.isArray(config2.whitelist)) {
                _this.whitelist = config2.whitelist.reduce(function(whitelist, format2) {
                  whitelist[format2] = true;
                  return whitelist;
                }, {});
              }
              _this.domNode.addEventListener("DOMNodeInserted", function() {
              });
              _this.optimize();
              _this.enable();
              return _this;
            }
            _createClass2(Scroll2, [{
              key: "batchStart",
              value: function batchStart() {
                this.batch = true;
              }
            }, {
              key: "batchEnd",
              value: function batchEnd() {
                this.batch = false;
                this.optimize();
              }
            }, {
              key: "deleteAt",
              value: function deleteAt(index2, length) {
                var _line = this.line(index2), _line2 = _slicedToArray2(_line, 2), first = _line2[0], offset2 = _line2[1];
                var _line3 = this.line(index2 + length), _line4 = _slicedToArray2(_line3, 1), last2 = _line4[0];
                _get2(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "deleteAt", this).call(this, index2, length);
                if (last2 != null && first !== last2 && offset2 > 0) {
                  if (first instanceof _block.BlockEmbed || last2 instanceof _block.BlockEmbed) {
                    this.optimize();
                    return;
                  }
                  if (first instanceof _code2.default) {
                    var newlineIndex = first.newlineIndex(first.length(), true);
                    if (newlineIndex > -1) {
                      first = first.split(newlineIndex + 1);
                      if (first === last2) {
                        this.optimize();
                        return;
                      }
                    }
                  } else if (last2 instanceof _code2.default) {
                    var _newlineIndex = last2.newlineIndex(0);
                    if (_newlineIndex > -1) {
                      last2.split(_newlineIndex + 1);
                    }
                  }
                  var ref = last2.children.head instanceof _break2.default ? null : last2.children.head;
                  first.moveChildren(last2, ref);
                  first.remove();
                }
                this.optimize();
              }
            }, {
              key: "enable",
              value: function enable() {
                var enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                this.domNode.setAttribute("contenteditable", enabled);
              }
            }, {
              key: "formatAt",
              value: function formatAt(index2, length, format2, value) {
                if (this.whitelist != null && !this.whitelist[format2])
                  return;
                _get2(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "formatAt", this).call(this, index2, length, format2, value);
                this.optimize();
              }
            }, {
              key: "insertAt",
              value: function insertAt(index2, value, def) {
                if (def != null && this.whitelist != null && !this.whitelist[value])
                  return;
                if (index2 >= this.length()) {
                  if (def == null || _parchment2.default.query(value, _parchment2.default.Scope.BLOCK) == null) {
                    var blot = _parchment2.default.create(this.statics.defaultChild);
                    this.appendChild(blot);
                    if (def == null && value.endsWith("\n")) {
                      value = value.slice(0, -1);
                    }
                    blot.insertAt(0, value, def);
                  } else {
                    var embed = _parchment2.default.create(value, def);
                    this.appendChild(embed);
                  }
                } else {
                  _get2(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "insertAt", this).call(this, index2, value, def);
                }
                this.optimize();
              }
            }, {
              key: "insertBefore",
              value: function insertBefore(blot, ref) {
                if (blot.statics.scope === _parchment2.default.Scope.INLINE_BLOT) {
                  var wrapper = _parchment2.default.create(this.statics.defaultChild);
                  wrapper.appendChild(blot);
                  blot = wrapper;
                }
                _get2(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "insertBefore", this).call(this, blot, ref);
              }
            }, {
              key: "leaf",
              value: function leaf(index2) {
                return this.path(index2).pop() || [null, -1];
              }
            }, {
              key: "line",
              value: function line(index2) {
                if (index2 === this.length()) {
                  return this.line(index2 - 1);
                }
                return this.descendant(isLine, index2);
              }
            }, {
              key: "lines",
              value: function lines() {
                var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE;
                var getLines = function getLines2(blot, index3, length2) {
                  var lines2 = [], lengthLeft = length2;
                  blot.children.forEachAt(index3, length2, function(child, index4, length3) {
                    if (isLine(child)) {
                      lines2.push(child);
                    } else if (child instanceof _parchment2.default.Container) {
                      lines2 = lines2.concat(getLines2(child, index4, lengthLeft));
                    }
                    lengthLeft -= length3;
                  });
                  return lines2;
                };
                return getLines(this, index2, length);
              }
            }, {
              key: "optimize",
              value: function optimize() {
                var mutations = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
                var context2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                if (this.batch === true)
                  return;
                _get2(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "optimize", this).call(this, mutations, context2);
                if (mutations.length > 0) {
                  this.emitter.emit(_emitter2.default.events.SCROLL_OPTIMIZE, mutations, context2);
                }
              }
            }, {
              key: "path",
              value: function path(index2) {
                return _get2(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "path", this).call(this, index2).slice(1);
              }
            }, {
              key: "update",
              value: function update2(mutations) {
                if (this.batch === true)
                  return;
                var source = _emitter2.default.sources.USER;
                if (typeof mutations === "string") {
                  source = mutations;
                }
                if (!Array.isArray(mutations)) {
                  mutations = this.observer.takeRecords();
                }
                if (mutations.length > 0) {
                  this.emitter.emit(_emitter2.default.events.SCROLL_BEFORE_UPDATE, source, mutations);
                }
                _get2(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "update", this).call(this, mutations.concat([]));
                if (mutations.length > 0) {
                  this.emitter.emit(_emitter2.default.events.SCROLL_UPDATE, source, mutations);
                }
              }
            }]);
            return Scroll2;
          }(_parchment2.default.Scroll);
          Scroll.blotName = "scroll";
          Scroll.className = "ql-editor";
          Scroll.tagName = "DIV";
          Scroll.defaultChild = "block";
          Scroll.allowedChildren = [_block2.default, _block.BlockEmbed, _container2.default];
          exports3.default = Scroll;
        },
        /* 23 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.SHORTKEY = exports3.default = void 0;
          var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
            return typeof obj;
          } : function(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
          var _slicedToArray2 = function() {
            function sliceIterator(arr, i2) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i2 && _arr.length === i2)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"])
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            return function(arr, i2) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i2);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _clone = __webpack_require__(21);
          var _clone2 = _interopRequireDefault2(_clone);
          var _deepEqual = __webpack_require__(11);
          var _deepEqual2 = _interopRequireDefault2(_deepEqual);
          var _extend = __webpack_require__(3);
          var _extend2 = _interopRequireDefault2(_extend);
          var _quillDelta = __webpack_require__(2);
          var _quillDelta2 = _interopRequireDefault2(_quillDelta);
          var _op = __webpack_require__(20);
          var _op2 = _interopRequireDefault2(_op);
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _quill = __webpack_require__(5);
          var _quill2 = _interopRequireDefault2(_quill);
          var _logger = __webpack_require__(10);
          var _logger2 = _interopRequireDefault2(_logger);
          var _module = __webpack_require__(9);
          var _module2 = _interopRequireDefault2(_module);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _defineProperty2(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var debug = (0, _logger2.default)("quill:keyboard");
          var SHORTKEY = /Mac/i.test(navigator.platform) ? "metaKey" : "ctrlKey";
          var Keyboard = function(_Module) {
            _inherits2(Keyboard2, _Module);
            _createClass2(Keyboard2, null, [{
              key: "match",
              value: function match5(evt, binding) {
                binding = normalize(binding);
                if (["altKey", "ctrlKey", "metaKey", "shiftKey"].some(function(key) {
                  return !!binding[key] !== evt[key] && binding[key] !== null;
                })) {
                  return false;
                }
                return binding.key === (evt.which || evt.keyCode);
              }
            }]);
            function Keyboard2(quill2, options) {
              _classCallCheck2(this, Keyboard2);
              var _this = _possibleConstructorReturn2(this, (Keyboard2.__proto__ || Object.getPrototypeOf(Keyboard2)).call(this, quill2, options));
              _this.bindings = {};
              Object.keys(_this.options.bindings).forEach(function(name) {
                if (name === "list autofill" && quill2.scroll.whitelist != null && !quill2.scroll.whitelist["list"]) {
                  return;
                }
                if (_this.options.bindings[name]) {
                  _this.addBinding(_this.options.bindings[name]);
                }
              });
              _this.addBinding({ key: Keyboard2.keys.ENTER, shiftKey: null }, handleEnter);
              _this.addBinding({ key: Keyboard2.keys.ENTER, metaKey: null, ctrlKey: null, altKey: null }, function() {
              });
              if (/Firefox/i.test(navigator.userAgent)) {
                _this.addBinding({ key: Keyboard2.keys.BACKSPACE }, { collapsed: true }, handleBackspace);
                _this.addBinding({ key: Keyboard2.keys.DELETE }, { collapsed: true }, handleDelete);
              } else {
                _this.addBinding({ key: Keyboard2.keys.BACKSPACE }, { collapsed: true, prefix: /^.?$/ }, handleBackspace);
                _this.addBinding({ key: Keyboard2.keys.DELETE }, { collapsed: true, suffix: /^.?$/ }, handleDelete);
              }
              _this.addBinding({ key: Keyboard2.keys.BACKSPACE }, { collapsed: false }, handleDeleteRange);
              _this.addBinding({ key: Keyboard2.keys.DELETE }, { collapsed: false }, handleDeleteRange);
              _this.addBinding({ key: Keyboard2.keys.BACKSPACE, altKey: null, ctrlKey: null, metaKey: null, shiftKey: null }, { collapsed: true, offset: 0 }, handleBackspace);
              _this.listen();
              return _this;
            }
            _createClass2(Keyboard2, [{
              key: "addBinding",
              value: function addBinding(key) {
                var context2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                var handler = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                var binding = normalize(key);
                if (binding == null || binding.key == null) {
                  return debug.warn("Attempted to add invalid keyboard binding", binding);
                }
                if (typeof context2 === "function") {
                  context2 = { handler: context2 };
                }
                if (typeof handler === "function") {
                  handler = { handler };
                }
                binding = (0, _extend2.default)(binding, context2, handler);
                this.bindings[binding.key] = this.bindings[binding.key] || [];
                this.bindings[binding.key].push(binding);
              }
            }, {
              key: "listen",
              value: function listen() {
                var _this2 = this;
                this.quill.root.addEventListener("keydown", function(evt) {
                  if (evt.defaultPrevented)
                    return;
                  var which = evt.which || evt.keyCode;
                  var bindings = (_this2.bindings[which] || []).filter(function(binding) {
                    return Keyboard2.match(evt, binding);
                  });
                  if (bindings.length === 0)
                    return;
                  var range2 = _this2.quill.getSelection();
                  if (range2 == null || !_this2.quill.hasFocus())
                    return;
                  var _quill$getLine = _this2.quill.getLine(range2.index), _quill$getLine2 = _slicedToArray2(_quill$getLine, 2), line = _quill$getLine2[0], offset2 = _quill$getLine2[1];
                  var _quill$getLeaf = _this2.quill.getLeaf(range2.index), _quill$getLeaf2 = _slicedToArray2(_quill$getLeaf, 2), leafStart = _quill$getLeaf2[0], offsetStart = _quill$getLeaf2[1];
                  var _ref = range2.length === 0 ? [leafStart, offsetStart] : _this2.quill.getLeaf(range2.index + range2.length), _ref2 = _slicedToArray2(_ref, 2), leafEnd = _ref2[0], offsetEnd = _ref2[1];
                  var prefixText = leafStart instanceof _parchment2.default.Text ? leafStart.value().slice(0, offsetStart) : "";
                  var suffixText = leafEnd instanceof _parchment2.default.Text ? leafEnd.value().slice(offsetEnd) : "";
                  var curContext = {
                    collapsed: range2.length === 0,
                    empty: range2.length === 0 && line.length() <= 1,
                    format: _this2.quill.getFormat(range2),
                    offset: offset2,
                    prefix: prefixText,
                    suffix: suffixText
                  };
                  var prevented = bindings.some(function(binding) {
                    if (binding.collapsed != null && binding.collapsed !== curContext.collapsed)
                      return false;
                    if (binding.empty != null && binding.empty !== curContext.empty)
                      return false;
                    if (binding.offset != null && binding.offset !== curContext.offset)
                      return false;
                    if (Array.isArray(binding.format)) {
                      if (binding.format.every(function(name) {
                        return curContext.format[name] == null;
                      })) {
                        return false;
                      }
                    } else if (_typeof2(binding.format) === "object") {
                      if (!Object.keys(binding.format).every(function(name) {
                        if (binding.format[name] === true)
                          return curContext.format[name] != null;
                        if (binding.format[name] === false)
                          return curContext.format[name] == null;
                        return (0, _deepEqual2.default)(binding.format[name], curContext.format[name]);
                      })) {
                        return false;
                      }
                    }
                    if (binding.prefix != null && !binding.prefix.test(curContext.prefix))
                      return false;
                    if (binding.suffix != null && !binding.suffix.test(curContext.suffix))
                      return false;
                    return binding.handler.call(_this2, range2, curContext) !== true;
                  });
                  if (prevented) {
                    evt.preventDefault();
                  }
                });
              }
            }]);
            return Keyboard2;
          }(_module2.default);
          Keyboard.keys = {
            BACKSPACE: 8,
            TAB: 9,
            ENTER: 13,
            ESCAPE: 27,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,
            DELETE: 46
          };
          Keyboard.DEFAULTS = {
            bindings: {
              "bold": makeFormatHandler("bold"),
              "italic": makeFormatHandler("italic"),
              "underline": makeFormatHandler("underline"),
              "indent": {
                // highlight tab or tab at beginning of list, indent or blockquote
                key: Keyboard.keys.TAB,
                format: ["blockquote", "indent", "list"],
                handler: function handler(range2, context2) {
                  if (context2.collapsed && context2.offset !== 0)
                    return true;
                  this.quill.format("indent", "+1", _quill2.default.sources.USER);
                }
              },
              "outdent": {
                key: Keyboard.keys.TAB,
                shiftKey: true,
                format: ["blockquote", "indent", "list"],
                // highlight tab or tab at beginning of list, indent or blockquote
                handler: function handler(range2, context2) {
                  if (context2.collapsed && context2.offset !== 0)
                    return true;
                  this.quill.format("indent", "-1", _quill2.default.sources.USER);
                }
              },
              "outdent backspace": {
                key: Keyboard.keys.BACKSPACE,
                collapsed: true,
                shiftKey: null,
                metaKey: null,
                ctrlKey: null,
                altKey: null,
                format: ["indent", "list"],
                offset: 0,
                handler: function handler(range2, context2) {
                  if (context2.format.indent != null) {
                    this.quill.format("indent", "-1", _quill2.default.sources.USER);
                  } else if (context2.format.list != null) {
                    this.quill.format("list", false, _quill2.default.sources.USER);
                  }
                }
              },
              "indent code-block": makeCodeBlockHandler(true),
              "outdent code-block": makeCodeBlockHandler(false),
              "remove tab": {
                key: Keyboard.keys.TAB,
                shiftKey: true,
                collapsed: true,
                prefix: /\t$/,
                handler: function handler(range2) {
                  this.quill.deleteText(range2.index - 1, 1, _quill2.default.sources.USER);
                }
              },
              "tab": {
                key: Keyboard.keys.TAB,
                handler: function handler(range2) {
                  this.quill.history.cutoff();
                  var delta = new _quillDelta2.default().retain(range2.index).delete(range2.length).insert("	");
                  this.quill.updateContents(delta, _quill2.default.sources.USER);
                  this.quill.history.cutoff();
                  this.quill.setSelection(range2.index + 1, _quill2.default.sources.SILENT);
                }
              },
              "list empty enter": {
                key: Keyboard.keys.ENTER,
                collapsed: true,
                format: ["list"],
                empty: true,
                handler: function handler(range2, context2) {
                  this.quill.format("list", false, _quill2.default.sources.USER);
                  if (context2.format.indent) {
                    this.quill.format("indent", false, _quill2.default.sources.USER);
                  }
                }
              },
              "checklist enter": {
                key: Keyboard.keys.ENTER,
                collapsed: true,
                format: { list: "checked" },
                handler: function handler(range2) {
                  var _quill$getLine3 = this.quill.getLine(range2.index), _quill$getLine4 = _slicedToArray2(_quill$getLine3, 2), line = _quill$getLine4[0], offset2 = _quill$getLine4[1];
                  var formats = (0, _extend2.default)({}, line.formats(), { list: "checked" });
                  var delta = new _quillDelta2.default().retain(range2.index).insert("\n", formats).retain(line.length() - offset2 - 1).retain(1, { list: "unchecked" });
                  this.quill.updateContents(delta, _quill2.default.sources.USER);
                  this.quill.setSelection(range2.index + 1, _quill2.default.sources.SILENT);
                  this.quill.scrollIntoView();
                }
              },
              "header enter": {
                key: Keyboard.keys.ENTER,
                collapsed: true,
                format: ["header"],
                suffix: /^$/,
                handler: function handler(range2, context2) {
                  var _quill$getLine5 = this.quill.getLine(range2.index), _quill$getLine6 = _slicedToArray2(_quill$getLine5, 2), line = _quill$getLine6[0], offset2 = _quill$getLine6[1];
                  var delta = new _quillDelta2.default().retain(range2.index).insert("\n", context2.format).retain(line.length() - offset2 - 1).retain(1, { header: null });
                  this.quill.updateContents(delta, _quill2.default.sources.USER);
                  this.quill.setSelection(range2.index + 1, _quill2.default.sources.SILENT);
                  this.quill.scrollIntoView();
                }
              },
              "list autofill": {
                key: " ",
                collapsed: true,
                format: { list: false },
                prefix: /^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/,
                handler: function handler(range2, context2) {
                  var length = context2.prefix.length;
                  var _quill$getLine7 = this.quill.getLine(range2.index), _quill$getLine8 = _slicedToArray2(_quill$getLine7, 2), line = _quill$getLine8[0], offset2 = _quill$getLine8[1];
                  if (offset2 > length)
                    return true;
                  var value = void 0;
                  switch (context2.prefix.trim()) {
                    case "[]":
                    case "[ ]":
                      value = "unchecked";
                      break;
                    case "[x]":
                      value = "checked";
                      break;
                    case "-":
                    case "*":
                      value = "bullet";
                      break;
                    default:
                      value = "ordered";
                  }
                  this.quill.insertText(range2.index, " ", _quill2.default.sources.USER);
                  this.quill.history.cutoff();
                  var delta = new _quillDelta2.default().retain(range2.index - offset2).delete(length + 1).retain(line.length() - 2 - offset2).retain(1, { list: value });
                  this.quill.updateContents(delta, _quill2.default.sources.USER);
                  this.quill.history.cutoff();
                  this.quill.setSelection(range2.index - length, _quill2.default.sources.SILENT);
                }
              },
              "code exit": {
                key: Keyboard.keys.ENTER,
                collapsed: true,
                format: ["code-block"],
                prefix: /\n\n$/,
                suffix: /^\s+$/,
                handler: function handler(range2) {
                  var _quill$getLine9 = this.quill.getLine(range2.index), _quill$getLine10 = _slicedToArray2(_quill$getLine9, 2), line = _quill$getLine10[0], offset2 = _quill$getLine10[1];
                  var delta = new _quillDelta2.default().retain(range2.index + line.length() - offset2 - 2).retain(1, { "code-block": null }).delete(1);
                  this.quill.updateContents(delta, _quill2.default.sources.USER);
                }
              },
              "embed left": makeEmbedArrowHandler(Keyboard.keys.LEFT, false),
              "embed left shift": makeEmbedArrowHandler(Keyboard.keys.LEFT, true),
              "embed right": makeEmbedArrowHandler(Keyboard.keys.RIGHT, false),
              "embed right shift": makeEmbedArrowHandler(Keyboard.keys.RIGHT, true)
            }
          };
          function makeEmbedArrowHandler(key, shiftKey) {
            var _ref3;
            var where = key === Keyboard.keys.LEFT ? "prefix" : "suffix";
            return _ref3 = {
              key,
              shiftKey,
              altKey: null
            }, _defineProperty2(_ref3, where, /^$/), _defineProperty2(_ref3, "handler", function handler(range2) {
              var index2 = range2.index;
              if (key === Keyboard.keys.RIGHT) {
                index2 += range2.length + 1;
              }
              var _quill$getLeaf3 = this.quill.getLeaf(index2), _quill$getLeaf4 = _slicedToArray2(_quill$getLeaf3, 1), leaf = _quill$getLeaf4[0];
              if (!(leaf instanceof _parchment2.default.Embed))
                return true;
              if (key === Keyboard.keys.LEFT) {
                if (shiftKey) {
                  this.quill.setSelection(range2.index - 1, range2.length + 1, _quill2.default.sources.USER);
                } else {
                  this.quill.setSelection(range2.index - 1, _quill2.default.sources.USER);
                }
              } else {
                if (shiftKey) {
                  this.quill.setSelection(range2.index, range2.length + 1, _quill2.default.sources.USER);
                } else {
                  this.quill.setSelection(range2.index + range2.length + 1, _quill2.default.sources.USER);
                }
              }
              return false;
            }), _ref3;
          }
          function handleBackspace(range2, context2) {
            if (range2.index === 0 || this.quill.getLength() <= 1)
              return;
            var _quill$getLine11 = this.quill.getLine(range2.index), _quill$getLine12 = _slicedToArray2(_quill$getLine11, 1), line = _quill$getLine12[0];
            var formats = {};
            if (context2.offset === 0) {
              var _quill$getLine13 = this.quill.getLine(range2.index - 1), _quill$getLine14 = _slicedToArray2(_quill$getLine13, 1), prev = _quill$getLine14[0];
              if (prev != null && prev.length() > 1) {
                var curFormats = line.formats();
                var prevFormats = this.quill.getFormat(range2.index - 1, 1);
                formats = _op2.default.attributes.diff(curFormats, prevFormats) || {};
              }
            }
            var length = /[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(context2.prefix) ? 2 : 1;
            this.quill.deleteText(range2.index - length, length, _quill2.default.sources.USER);
            if (Object.keys(formats).length > 0) {
              this.quill.formatLine(range2.index - length, length, formats, _quill2.default.sources.USER);
            }
            this.quill.focus();
          }
          function handleDelete(range2, context2) {
            var length = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(context2.suffix) ? 2 : 1;
            if (range2.index >= this.quill.getLength() - length)
              return;
            var formats = {}, nextLength = 0;
            var _quill$getLine15 = this.quill.getLine(range2.index), _quill$getLine16 = _slicedToArray2(_quill$getLine15, 1), line = _quill$getLine16[0];
            if (context2.offset >= line.length() - 1) {
              var _quill$getLine17 = this.quill.getLine(range2.index + 1), _quill$getLine18 = _slicedToArray2(_quill$getLine17, 1), next = _quill$getLine18[0];
              if (next) {
                var curFormats = line.formats();
                var nextFormats = this.quill.getFormat(range2.index, 1);
                formats = _op2.default.attributes.diff(curFormats, nextFormats) || {};
                nextLength = next.length();
              }
            }
            this.quill.deleteText(range2.index, length, _quill2.default.sources.USER);
            if (Object.keys(formats).length > 0) {
              this.quill.formatLine(range2.index + nextLength - 1, length, formats, _quill2.default.sources.USER);
            }
          }
          function handleDeleteRange(range2) {
            var lines = this.quill.getLines(range2);
            var formats = {};
            if (lines.length > 1) {
              var firstFormats = lines[0].formats();
              var lastFormats = lines[lines.length - 1].formats();
              formats = _op2.default.attributes.diff(lastFormats, firstFormats) || {};
            }
            this.quill.deleteText(range2, _quill2.default.sources.USER);
            if (Object.keys(formats).length > 0) {
              this.quill.formatLine(range2.index, 1, formats, _quill2.default.sources.USER);
            }
            this.quill.setSelection(range2.index, _quill2.default.sources.SILENT);
            this.quill.focus();
          }
          function handleEnter(range2, context2) {
            var _this3 = this;
            if (range2.length > 0) {
              this.quill.scroll.deleteAt(range2.index, range2.length);
            }
            var lineFormats = Object.keys(context2.format).reduce(function(lineFormats2, format2) {
              if (_parchment2.default.query(format2, _parchment2.default.Scope.BLOCK) && !Array.isArray(context2.format[format2])) {
                lineFormats2[format2] = context2.format[format2];
              }
              return lineFormats2;
            }, {});
            this.quill.insertText(range2.index, "\n", lineFormats, _quill2.default.sources.USER);
            this.quill.setSelection(range2.index + 1, _quill2.default.sources.SILENT);
            this.quill.focus();
            Object.keys(context2.format).forEach(function(name) {
              if (lineFormats[name] != null)
                return;
              if (Array.isArray(context2.format[name]))
                return;
              if (name === "link")
                return;
              _this3.quill.format(name, context2.format[name], _quill2.default.sources.USER);
            });
          }
          function makeCodeBlockHandler(indent) {
            return {
              key: Keyboard.keys.TAB,
              shiftKey: !indent,
              format: { "code-block": true },
              handler: function handler(range2) {
                var CodeBlock = _parchment2.default.query("code-block");
                var index2 = range2.index, length = range2.length;
                var _quill$scroll$descend = this.quill.scroll.descendant(CodeBlock, index2), _quill$scroll$descend2 = _slicedToArray2(_quill$scroll$descend, 2), block = _quill$scroll$descend2[0], offset2 = _quill$scroll$descend2[1];
                if (block == null)
                  return;
                var scrollIndex = this.quill.getIndex(block);
                var start2 = block.newlineIndex(offset2, true) + 1;
                var end = block.newlineIndex(scrollIndex + offset2 + length);
                var lines = block.domNode.textContent.slice(start2, end).split("\n");
                offset2 = 0;
                lines.forEach(function(line, i2) {
                  if (indent) {
                    block.insertAt(start2 + offset2, CodeBlock.TAB);
                    offset2 += CodeBlock.TAB.length;
                    if (i2 === 0) {
                      index2 += CodeBlock.TAB.length;
                    } else {
                      length += CodeBlock.TAB.length;
                    }
                  } else if (line.startsWith(CodeBlock.TAB)) {
                    block.deleteAt(start2 + offset2, CodeBlock.TAB.length);
                    offset2 -= CodeBlock.TAB.length;
                    if (i2 === 0) {
                      index2 -= CodeBlock.TAB.length;
                    } else {
                      length -= CodeBlock.TAB.length;
                    }
                  }
                  offset2 += line.length + 1;
                });
                this.quill.update(_quill2.default.sources.USER);
                this.quill.setSelection(index2, length, _quill2.default.sources.SILENT);
              }
            };
          }
          function makeFormatHandler(format2) {
            return {
              key: format2[0].toUpperCase(),
              shortKey: true,
              handler: function handler(range2, context2) {
                this.quill.format(format2, !context2.format[format2], _quill2.default.sources.USER);
              }
            };
          }
          function normalize(binding) {
            if (typeof binding === "string" || typeof binding === "number") {
              return normalize({ key: binding });
            }
            if ((typeof binding === "undefined" ? "undefined" : _typeof2(binding)) === "object") {
              binding = (0, _clone2.default)(binding, false);
            }
            if (typeof binding.key === "string") {
              if (Keyboard.keys[binding.key.toUpperCase()] != null) {
                binding.key = Keyboard.keys[binding.key.toUpperCase()];
              } else if (binding.key.length === 1) {
                binding.key = binding.key.toUpperCase().charCodeAt(0);
              } else {
                return null;
              }
            }
            if (binding.shortKey) {
              binding[SHORTKEY] = binding.shortKey;
              delete binding.shortKey;
            }
            return binding;
          }
          exports3.default = Keyboard;
          exports3.SHORTKEY = SHORTKEY;
        },
        /* 24 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _slicedToArray2 = function() {
            function sliceIterator(arr, i2) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i2 && _arr.length === i2)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"])
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            return function(arr, i2) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i2);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();
          var _get2 = function get4(object, property2, receiver) {
            if (object === null)
              object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get4(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _text = __webpack_require__(7);
          var _text2 = _interopRequireDefault2(_text);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var Cursor = function(_Parchment$Embed) {
            _inherits2(Cursor2, _Parchment$Embed);
            _createClass2(Cursor2, null, [{
              key: "value",
              value: function value() {
                return void 0;
              }
            }]);
            function Cursor2(domNode, selection) {
              _classCallCheck2(this, Cursor2);
              var _this = _possibleConstructorReturn2(this, (Cursor2.__proto__ || Object.getPrototypeOf(Cursor2)).call(this, domNode));
              _this.selection = selection;
              _this.textNode = document.createTextNode(Cursor2.CONTENTS);
              _this.domNode.appendChild(_this.textNode);
              _this._length = 0;
              return _this;
            }
            _createClass2(Cursor2, [{
              key: "detach",
              value: function detach() {
                if (this.parent != null)
                  this.parent.removeChild(this);
              }
            }, {
              key: "format",
              value: function format2(name, value) {
                if (this._length !== 0) {
                  return _get2(Cursor2.prototype.__proto__ || Object.getPrototypeOf(Cursor2.prototype), "format", this).call(this, name, value);
                }
                var target = this, index2 = 0;
                while (target != null && target.statics.scope !== _parchment2.default.Scope.BLOCK_BLOT) {
                  index2 += target.offset(target.parent);
                  target = target.parent;
                }
                if (target != null) {
                  this._length = Cursor2.CONTENTS.length;
                  target.optimize();
                  target.formatAt(index2, Cursor2.CONTENTS.length, name, value);
                  this._length = 0;
                }
              }
            }, {
              key: "index",
              value: function index2(node, offset2) {
                if (node === this.textNode)
                  return 0;
                return _get2(Cursor2.prototype.__proto__ || Object.getPrototypeOf(Cursor2.prototype), "index", this).call(this, node, offset2);
              }
            }, {
              key: "length",
              value: function length() {
                return this._length;
              }
            }, {
              key: "position",
              value: function position() {
                return [this.textNode, this.textNode.data.length];
              }
            }, {
              key: "remove",
              value: function remove() {
                _get2(Cursor2.prototype.__proto__ || Object.getPrototypeOf(Cursor2.prototype), "remove", this).call(this);
                this.parent = null;
              }
            }, {
              key: "restore",
              value: function restore() {
                if (this.selection.composing || this.parent == null)
                  return;
                var textNode = this.textNode;
                var range2 = this.selection.getNativeRange();
                var restoreText = void 0, start2 = void 0, end = void 0;
                if (range2 != null && range2.start.node === textNode && range2.end.node === textNode) {
                  var _ref = [textNode, range2.start.offset, range2.end.offset];
                  restoreText = _ref[0];
                  start2 = _ref[1];
                  end = _ref[2];
                }
                while (this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode) {
                  this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);
                }
                if (this.textNode.data !== Cursor2.CONTENTS) {
                  var text = this.textNode.data.split(Cursor2.CONTENTS).join("");
                  if (this.next instanceof _text2.default) {
                    restoreText = this.next.domNode;
                    this.next.insertAt(0, text);
                    this.textNode.data = Cursor2.CONTENTS;
                  } else {
                    this.textNode.data = text;
                    this.parent.insertBefore(_parchment2.default.create(this.textNode), this);
                    this.textNode = document.createTextNode(Cursor2.CONTENTS);
                    this.domNode.appendChild(this.textNode);
                  }
                }
                this.remove();
                if (start2 != null) {
                  var _map = [start2, end].map(function(offset2) {
                    return Math.max(0, Math.min(restoreText.data.length, offset2 - 1));
                  });
                  var _map22 = _slicedToArray2(_map, 2);
                  start2 = _map22[0];
                  end = _map22[1];
                  return {
                    startNode: restoreText,
                    startOffset: start2,
                    endNode: restoreText,
                    endOffset: end
                  };
                }
              }
            }, {
              key: "update",
              value: function update2(mutations, context2) {
                var _this2 = this;
                if (mutations.some(function(mutation) {
                  return mutation.type === "characterData" && mutation.target === _this2.textNode;
                })) {
                  var range2 = this.restore();
                  if (range2)
                    context2.range = range2;
                }
              }
            }, {
              key: "value",
              value: function value() {
                return "";
              }
            }]);
            return Cursor2;
          }(_parchment2.default.Embed);
          Cursor.blotName = "cursor";
          Cursor.className = "ql-cursor";
          Cursor.tagName = "span";
          Cursor.CONTENTS = "\uFEFF";
          exports3.default = Cursor;
        },
        /* 25 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _block = __webpack_require__(4);
          var _block2 = _interopRequireDefault2(_block);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var Container = function(_Parchment$Container) {
            _inherits2(Container2, _Parchment$Container);
            function Container2() {
              _classCallCheck2(this, Container2);
              return _possibleConstructorReturn2(this, (Container2.__proto__ || Object.getPrototypeOf(Container2)).apply(this, arguments));
            }
            return Container2;
          }(_parchment2.default.Container);
          Container.allowedChildren = [_block2.default, _block.BlockEmbed, Container];
          exports3.default = Container;
        },
        /* 26 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.ColorStyle = exports3.ColorClass = exports3.ColorAttributor = void 0;
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get4(object, property2, receiver) {
            if (object === null)
              object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get4(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var ColorAttributor = function(_Parchment$Attributor) {
            _inherits2(ColorAttributor2, _Parchment$Attributor);
            function ColorAttributor2() {
              _classCallCheck2(this, ColorAttributor2);
              return _possibleConstructorReturn2(this, (ColorAttributor2.__proto__ || Object.getPrototypeOf(ColorAttributor2)).apply(this, arguments));
            }
            _createClass2(ColorAttributor2, [{
              key: "value",
              value: function value(domNode) {
                var value2 = _get2(ColorAttributor2.prototype.__proto__ || Object.getPrototypeOf(ColorAttributor2.prototype), "value", this).call(this, domNode);
                if (!value2.startsWith("rgb("))
                  return value2;
                value2 = value2.replace(/^[^\d]+/, "").replace(/[^\d]+$/, "");
                return "#" + value2.split(",").map(function(component) {
                  return ("00" + parseInt(component).toString(16)).slice(-2);
                }).join("");
              }
            }]);
            return ColorAttributor2;
          }(_parchment2.default.Attributor.Style);
          var ColorClass = new _parchment2.default.Attributor.Class("color", "ql-color", {
            scope: _parchment2.default.Scope.INLINE
          });
          var ColorStyle = new ColorAttributor("color", "color", {
            scope: _parchment2.default.Scope.INLINE
          });
          exports3.ColorAttributor = ColorAttributor;
          exports3.ColorClass = ColorClass;
          exports3.ColorStyle = ColorStyle;
        },
        /* 27 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.sanitize = exports3.default = void 0;
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get4(object, property2, receiver) {
            if (object === null)
              object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get4(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _inline = __webpack_require__(6);
          var _inline2 = _interopRequireDefault2(_inline);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var Link = function(_Inline) {
            _inherits2(Link2, _Inline);
            function Link2() {
              _classCallCheck2(this, Link2);
              return _possibleConstructorReturn2(this, (Link2.__proto__ || Object.getPrototypeOf(Link2)).apply(this, arguments));
            }
            _createClass2(Link2, [{
              key: "format",
              value: function format2(name, value) {
                if (name !== this.statics.blotName || !value)
                  return _get2(Link2.prototype.__proto__ || Object.getPrototypeOf(Link2.prototype), "format", this).call(this, name, value);
                value = this.constructor.sanitize(value);
                this.domNode.setAttribute("href", value);
              }
            }], [{
              key: "create",
              value: function create(value) {
                var node = _get2(Link2.__proto__ || Object.getPrototypeOf(Link2), "create", this).call(this, value);
                value = this.sanitize(value);
                node.setAttribute("href", value);
                node.setAttribute("rel", "noopener noreferrer");
                node.setAttribute("target", "_blank");
                return node;
              }
            }, {
              key: "formats",
              value: function formats(domNode) {
                return domNode.getAttribute("href");
              }
            }, {
              key: "sanitize",
              value: function sanitize(url) {
                return _sanitize(url, this.PROTOCOL_WHITELIST) ? url : this.SANITIZED_URL;
              }
            }]);
            return Link2;
          }(_inline2.default);
          Link.blotName = "link";
          Link.tagName = "A";
          Link.SANITIZED_URL = "about:blank";
          Link.PROTOCOL_WHITELIST = ["http", "https", "mailto", "tel"];
          function _sanitize(url, protocols) {
            var anchor = document.createElement("a");
            anchor.href = url;
            var protocol = anchor.href.slice(0, anchor.href.indexOf(":"));
            return protocols.indexOf(protocol) > -1;
          }
          exports3.default = Link;
          exports3.sanitize = _sanitize;
        },
        /* 28 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
            return typeof obj;
          } : function(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _keyboard = __webpack_require__(23);
          var _keyboard2 = _interopRequireDefault2(_keyboard);
          var _dropdown = __webpack_require__(107);
          var _dropdown2 = _interopRequireDefault2(_dropdown);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var optionsCounter = 0;
          function toggleAriaAttribute(element, attribute) {
            element.setAttribute(attribute, !(element.getAttribute(attribute) === "true"));
          }
          var Picker = function() {
            function Picker2(select) {
              var _this = this;
              _classCallCheck2(this, Picker2);
              this.select = select;
              this.container = document.createElement("span");
              this.buildPicker();
              this.select.style.display = "none";
              this.select.parentNode.insertBefore(this.container, this.select);
              this.label.addEventListener("mousedown", function() {
                _this.togglePicker();
              });
              this.label.addEventListener("keydown", function(event) {
                switch (event.keyCode) {
                  case _keyboard2.default.keys.ENTER:
                    _this.togglePicker();
                    break;
                  case _keyboard2.default.keys.ESCAPE:
                    _this.escape();
                    event.preventDefault();
                    break;
                }
              });
              this.select.addEventListener("change", this.update.bind(this));
            }
            _createClass2(Picker2, [{
              key: "togglePicker",
              value: function togglePicker() {
                this.container.classList.toggle("ql-expanded");
                toggleAriaAttribute(this.label, "aria-expanded");
                toggleAriaAttribute(this.options, "aria-hidden");
              }
            }, {
              key: "buildItem",
              value: function buildItem(option) {
                var _this2 = this;
                var item = document.createElement("span");
                item.tabIndex = "0";
                item.setAttribute("role", "button");
                item.classList.add("ql-picker-item");
                if (option.hasAttribute("value")) {
                  item.setAttribute("data-value", option.getAttribute("value"));
                }
                if (option.textContent) {
                  item.setAttribute("data-label", option.textContent);
                }
                item.addEventListener("click", function() {
                  _this2.selectItem(item, true);
                });
                item.addEventListener("keydown", function(event) {
                  switch (event.keyCode) {
                    case _keyboard2.default.keys.ENTER:
                      _this2.selectItem(item, true);
                      event.preventDefault();
                      break;
                    case _keyboard2.default.keys.ESCAPE:
                      _this2.escape();
                      event.preventDefault();
                      break;
                  }
                });
                return item;
              }
            }, {
              key: "buildLabel",
              value: function buildLabel() {
                var label2 = document.createElement("span");
                label2.classList.add("ql-picker-label");
                label2.innerHTML = _dropdown2.default;
                label2.tabIndex = "0";
                label2.setAttribute("role", "button");
                label2.setAttribute("aria-expanded", "false");
                this.container.appendChild(label2);
                return label2;
              }
            }, {
              key: "buildOptions",
              value: function buildOptions3() {
                var _this3 = this;
                var options = document.createElement("span");
                options.classList.add("ql-picker-options");
                options.setAttribute("aria-hidden", "true");
                options.tabIndex = "-1";
                options.id = "ql-picker-options-" + optionsCounter;
                optionsCounter += 1;
                this.label.setAttribute("aria-controls", options.id);
                this.options = options;
                [].slice.call(this.select.options).forEach(function(option) {
                  var item = _this3.buildItem(option);
                  options.appendChild(item);
                  if (option.selected === true) {
                    _this3.selectItem(item);
                  }
                });
                this.container.appendChild(options);
              }
            }, {
              key: "buildPicker",
              value: function buildPicker() {
                var _this4 = this;
                [].slice.call(this.select.attributes).forEach(function(item) {
                  _this4.container.setAttribute(item.name, item.value);
                });
                this.container.classList.add("ql-picker");
                this.label = this.buildLabel();
                this.buildOptions();
              }
            }, {
              key: "escape",
              value: function escape() {
                var _this5 = this;
                this.close();
                setTimeout(function() {
                  return _this5.label.focus();
                }, 1);
              }
            }, {
              key: "close",
              value: function close2() {
                this.container.classList.remove("ql-expanded");
                this.label.setAttribute("aria-expanded", "false");
                this.options.setAttribute("aria-hidden", "true");
              }
            }, {
              key: "selectItem",
              value: function selectItem(item) {
                var trigger = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                var selected = this.container.querySelector(".ql-selected");
                if (item === selected)
                  return;
                if (selected != null) {
                  selected.classList.remove("ql-selected");
                }
                if (item == null)
                  return;
                item.classList.add("ql-selected");
                this.select.selectedIndex = [].indexOf.call(item.parentNode.children, item);
                if (item.hasAttribute("data-value")) {
                  this.label.setAttribute("data-value", item.getAttribute("data-value"));
                } else {
                  this.label.removeAttribute("data-value");
                }
                if (item.hasAttribute("data-label")) {
                  this.label.setAttribute("data-label", item.getAttribute("data-label"));
                } else {
                  this.label.removeAttribute("data-label");
                }
                if (trigger) {
                  if (typeof Event === "function") {
                    this.select.dispatchEvent(new Event("change"));
                  } else if ((typeof Event === "undefined" ? "undefined" : _typeof2(Event)) === "object") {
                    var event = document.createEvent("Event");
                    event.initEvent("change", true, true);
                    this.select.dispatchEvent(event);
                  }
                  this.close();
                }
              }
            }, {
              key: "update",
              value: function update2() {
                var option = void 0;
                if (this.select.selectedIndex > -1) {
                  var item = this.container.querySelector(".ql-picker-options").children[this.select.selectedIndex];
                  option = this.select.options[this.select.selectedIndex];
                  this.selectItem(item);
                } else {
                  this.selectItem(null);
                }
                var isActive = option != null && option !== this.select.querySelector("option[selected]");
                this.label.classList.toggle("ql-active", isActive);
              }
            }]);
            return Picker2;
          }();
          exports3.default = Picker;
        },
        /* 29 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _quill = __webpack_require__(5);
          var _quill2 = _interopRequireDefault2(_quill);
          var _block = __webpack_require__(4);
          var _block2 = _interopRequireDefault2(_block);
          var _break = __webpack_require__(16);
          var _break2 = _interopRequireDefault2(_break);
          var _container = __webpack_require__(25);
          var _container2 = _interopRequireDefault2(_container);
          var _cursor = __webpack_require__(24);
          var _cursor2 = _interopRequireDefault2(_cursor);
          var _embed = __webpack_require__(35);
          var _embed2 = _interopRequireDefault2(_embed);
          var _inline = __webpack_require__(6);
          var _inline2 = _interopRequireDefault2(_inline);
          var _scroll = __webpack_require__(22);
          var _scroll2 = _interopRequireDefault2(_scroll);
          var _text = __webpack_require__(7);
          var _text2 = _interopRequireDefault2(_text);
          var _clipboard = __webpack_require__(55);
          var _clipboard2 = _interopRequireDefault2(_clipboard);
          var _history = __webpack_require__(42);
          var _history2 = _interopRequireDefault2(_history);
          var _keyboard = __webpack_require__(23);
          var _keyboard2 = _interopRequireDefault2(_keyboard);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          _quill2.default.register({
            "blots/block": _block2.default,
            "blots/block/embed": _block.BlockEmbed,
            "blots/break": _break2.default,
            "blots/container": _container2.default,
            "blots/cursor": _cursor2.default,
            "blots/embed": _embed2.default,
            "blots/inline": _inline2.default,
            "blots/scroll": _scroll2.default,
            "blots/text": _text2.default,
            "modules/clipboard": _clipboard2.default,
            "modules/history": _history2.default,
            "modules/keyboard": _keyboard2.default
          });
          _parchment2.default.register(_block2.default, _break2.default, _cursor2.default, _inline2.default, _scroll2.default, _text2.default);
          exports3.default = _quill2.default;
        },
        /* 30 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          var Registry = __webpack_require__(1);
          var ShadowBlot = (
            /** @class */
            function() {
              function ShadowBlot2(domNode) {
                this.domNode = domNode;
                this.domNode[Registry.DATA_KEY] = { blot: this };
              }
              Object.defineProperty(ShadowBlot2.prototype, "statics", {
                // Hack for accessing inherited static methods
                get: function() {
                  return this.constructor;
                },
                enumerable: true,
                configurable: true
              });
              ShadowBlot2.create = function(value) {
                if (this.tagName == null) {
                  throw new Registry.ParchmentError("Blot definition missing tagName");
                }
                var node;
                if (Array.isArray(this.tagName)) {
                  if (typeof value === "string") {
                    value = value.toUpperCase();
                    if (parseInt(value).toString() === value) {
                      value = parseInt(value);
                    }
                  }
                  if (typeof value === "number") {
                    node = document.createElement(this.tagName[value - 1]);
                  } else if (this.tagName.indexOf(value) > -1) {
                    node = document.createElement(value);
                  } else {
                    node = document.createElement(this.tagName[0]);
                  }
                } else {
                  node = document.createElement(this.tagName);
                }
                if (this.className) {
                  node.classList.add(this.className);
                }
                return node;
              };
              ShadowBlot2.prototype.attach = function() {
                if (this.parent != null) {
                  this.scroll = this.parent.scroll;
                }
              };
              ShadowBlot2.prototype.clone = function() {
                var domNode = this.domNode.cloneNode(false);
                return Registry.create(domNode);
              };
              ShadowBlot2.prototype.detach = function() {
                if (this.parent != null)
                  this.parent.removeChild(this);
                delete this.domNode[Registry.DATA_KEY];
              };
              ShadowBlot2.prototype.deleteAt = function(index2, length) {
                var blot = this.isolate(index2, length);
                blot.remove();
              };
              ShadowBlot2.prototype.formatAt = function(index2, length, name, value) {
                var blot = this.isolate(index2, length);
                if (Registry.query(name, Registry.Scope.BLOT) != null && value) {
                  blot.wrap(name, value);
                } else if (Registry.query(name, Registry.Scope.ATTRIBUTE) != null) {
                  var parent2 = Registry.create(this.statics.scope);
                  blot.wrap(parent2);
                  parent2.format(name, value);
                }
              };
              ShadowBlot2.prototype.insertAt = function(index2, value, def) {
                var blot = def == null ? Registry.create("text", value) : Registry.create(value, def);
                var ref = this.split(index2);
                this.parent.insertBefore(blot, ref);
              };
              ShadowBlot2.prototype.insertInto = function(parentBlot, refBlot) {
                if (refBlot === void 0) {
                  refBlot = null;
                }
                if (this.parent != null) {
                  this.parent.children.remove(this);
                }
                var refDomNode = null;
                parentBlot.children.insertBefore(this, refBlot);
                if (refBlot != null) {
                  refDomNode = refBlot.domNode;
                }
                if (this.domNode.parentNode != parentBlot.domNode || this.domNode.nextSibling != refDomNode) {
                  parentBlot.domNode.insertBefore(this.domNode, refDomNode);
                }
                this.parent = parentBlot;
                this.attach();
              };
              ShadowBlot2.prototype.isolate = function(index2, length) {
                var target = this.split(index2);
                target.split(length);
                return target;
              };
              ShadowBlot2.prototype.length = function() {
                return 1;
              };
              ShadowBlot2.prototype.offset = function(root2) {
                if (root2 === void 0) {
                  root2 = this.parent;
                }
                if (this.parent == null || this == root2)
                  return 0;
                return this.parent.children.offset(this) + this.parent.offset(root2);
              };
              ShadowBlot2.prototype.optimize = function(context2) {
                if (this.domNode[Registry.DATA_KEY] != null) {
                  delete this.domNode[Registry.DATA_KEY].mutations;
                }
              };
              ShadowBlot2.prototype.remove = function() {
                if (this.domNode.parentNode != null) {
                  this.domNode.parentNode.removeChild(this.domNode);
                }
                this.detach();
              };
              ShadowBlot2.prototype.replace = function(target) {
                if (target.parent == null)
                  return;
                target.parent.insertBefore(this, target.next);
                target.remove();
              };
              ShadowBlot2.prototype.replaceWith = function(name, value) {
                var replacement = typeof name === "string" ? Registry.create(name, value) : name;
                replacement.replace(this);
                return replacement;
              };
              ShadowBlot2.prototype.split = function(index2, force) {
                return index2 === 0 ? this : this.next;
              };
              ShadowBlot2.prototype.update = function(mutations, context2) {
              };
              ShadowBlot2.prototype.wrap = function(name, value) {
                var wrapper = typeof name === "string" ? Registry.create(name, value) : name;
                if (this.parent != null) {
                  this.parent.insertBefore(wrapper, this.next);
                }
                wrapper.appendChild(this);
                return wrapper;
              };
              ShadowBlot2.blotName = "abstract";
              return ShadowBlot2;
            }()
          );
          exports3.default = ShadowBlot;
        },
        /* 31 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          var attributor_1 = __webpack_require__(12);
          var class_1 = __webpack_require__(32);
          var style_1 = __webpack_require__(33);
          var Registry = __webpack_require__(1);
          var AttributorStore = (
            /** @class */
            function() {
              function AttributorStore2(domNode) {
                this.attributes = {};
                this.domNode = domNode;
                this.build();
              }
              AttributorStore2.prototype.attribute = function(attribute, value) {
                if (value) {
                  if (attribute.add(this.domNode, value)) {
                    if (attribute.value(this.domNode) != null) {
                      this.attributes[attribute.attrName] = attribute;
                    } else {
                      delete this.attributes[attribute.attrName];
                    }
                  }
                } else {
                  attribute.remove(this.domNode);
                  delete this.attributes[attribute.attrName];
                }
              };
              AttributorStore2.prototype.build = function() {
                var _this = this;
                this.attributes = {};
                var attributes = attributor_1.default.keys(this.domNode);
                var classes = class_1.default.keys(this.domNode);
                var styles2 = style_1.default.keys(this.domNode);
                attributes.concat(classes).concat(styles2).forEach(function(name) {
                  var attr = Registry.query(name, Registry.Scope.ATTRIBUTE);
                  if (attr instanceof attributor_1.default) {
                    _this.attributes[attr.attrName] = attr;
                  }
                });
              };
              AttributorStore2.prototype.copy = function(target) {
                var _this = this;
                Object.keys(this.attributes).forEach(function(key) {
                  var value = _this.attributes[key].value(_this.domNode);
                  target.format(key, value);
                });
              };
              AttributorStore2.prototype.move = function(target) {
                var _this = this;
                this.copy(target);
                Object.keys(this.attributes).forEach(function(key) {
                  _this.attributes[key].remove(_this.domNode);
                });
                this.attributes = {};
              };
              AttributorStore2.prototype.values = function() {
                var _this = this;
                return Object.keys(this.attributes).reduce(function(attributes, name) {
                  attributes[name] = _this.attributes[name].value(_this.domNode);
                  return attributes;
                }, {});
              };
              return AttributorStore2;
            }()
          );
          exports3.default = AttributorStore;
        },
        /* 32 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var __extends2 = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p2 in b2)
                if (b2.hasOwnProperty(p2))
                  d2[p2] = b2[p2];
            };
            return function(d2, b2) {
              extendStatics(d2, b2);
              function __() {
                this.constructor = d2;
              }
              d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
            };
          }();
          Object.defineProperty(exports3, "__esModule", { value: true });
          var attributor_1 = __webpack_require__(12);
          function match5(node, prefix) {
            var className = node.getAttribute("class") || "";
            return className.split(/\s+/).filter(function(name) {
              return name.indexOf(prefix + "-") === 0;
            });
          }
          var ClassAttributor = (
            /** @class */
            function(_super) {
              __extends2(ClassAttributor2, _super);
              function ClassAttributor2() {
                return _super !== null && _super.apply(this, arguments) || this;
              }
              ClassAttributor2.keys = function(node) {
                return (node.getAttribute("class") || "").split(/\s+/).map(function(name) {
                  return name.split("-").slice(0, -1).join("-");
                });
              };
              ClassAttributor2.prototype.add = function(node, value) {
                if (!this.canAdd(node, value))
                  return false;
                this.remove(node);
                node.classList.add(this.keyName + "-" + value);
                return true;
              };
              ClassAttributor2.prototype.remove = function(node) {
                var matches = match5(node, this.keyName);
                matches.forEach(function(name) {
                  node.classList.remove(name);
                });
                if (node.classList.length === 0) {
                  node.removeAttribute("class");
                }
              };
              ClassAttributor2.prototype.value = function(node) {
                var result = match5(node, this.keyName)[0] || "";
                var value = result.slice(this.keyName.length + 1);
                return this.canAdd(node, value) ? value : "";
              };
              return ClassAttributor2;
            }(attributor_1.default)
          );
          exports3.default = ClassAttributor;
        },
        /* 33 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var __extends2 = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p2 in b2)
                if (b2.hasOwnProperty(p2))
                  d2[p2] = b2[p2];
            };
            return function(d2, b2) {
              extendStatics(d2, b2);
              function __() {
                this.constructor = d2;
              }
              d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
            };
          }();
          Object.defineProperty(exports3, "__esModule", { value: true });
          var attributor_1 = __webpack_require__(12);
          function camelize(name) {
            var parts = name.split("-");
            var rest = parts.slice(1).map(function(part) {
              return part[0].toUpperCase() + part.slice(1);
            }).join("");
            return parts[0] + rest;
          }
          var StyleAttributor = (
            /** @class */
            function(_super) {
              __extends2(StyleAttributor2, _super);
              function StyleAttributor2() {
                return _super !== null && _super.apply(this, arguments) || this;
              }
              StyleAttributor2.keys = function(node) {
                return (node.getAttribute("style") || "").split(";").map(function(value) {
                  var arr = value.split(":");
                  return arr[0].trim();
                });
              };
              StyleAttributor2.prototype.add = function(node, value) {
                if (!this.canAdd(node, value))
                  return false;
                node.style[camelize(this.keyName)] = value;
                return true;
              };
              StyleAttributor2.prototype.remove = function(node) {
                node.style[camelize(this.keyName)] = "";
                if (!node.getAttribute("style")) {
                  node.removeAttribute("style");
                }
              };
              StyleAttributor2.prototype.value = function(node) {
                var value = node.style[camelize(this.keyName)];
                return this.canAdd(node, value) ? value : "";
              };
              return StyleAttributor2;
            }(attributor_1.default)
          );
          exports3.default = StyleAttributor;
        },
        /* 34 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var Theme = function() {
            function Theme2(quill2, options) {
              _classCallCheck2(this, Theme2);
              this.quill = quill2;
              this.options = options;
              this.modules = {};
            }
            _createClass2(Theme2, [{
              key: "init",
              value: function init() {
                var _this = this;
                Object.keys(this.options.modules).forEach(function(name) {
                  if (_this.modules[name] == null) {
                    _this.addModule(name);
                  }
                });
              }
            }, {
              key: "addModule",
              value: function addModule(name) {
                var moduleClass = this.quill.constructor.import("modules/" + name);
                this.modules[name] = new moduleClass(this.quill, this.options.modules[name] || {});
                return this.modules[name];
              }
            }]);
            return Theme2;
          }();
          Theme.DEFAULTS = {
            modules: {}
          };
          Theme.themes = {
            "default": Theme
          };
          exports3.default = Theme;
        },
        /* 35 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get4(object, property2, receiver) {
            if (object === null)
              object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get4(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _text = __webpack_require__(7);
          var _text2 = _interopRequireDefault2(_text);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var GUARD_TEXT = "\uFEFF";
          var Embed2 = function(_Parchment$Embed) {
            _inherits2(Embed3, _Parchment$Embed);
            function Embed3(node) {
              _classCallCheck2(this, Embed3);
              var _this = _possibleConstructorReturn2(this, (Embed3.__proto__ || Object.getPrototypeOf(Embed3)).call(this, node));
              _this.contentNode = document.createElement("span");
              _this.contentNode.setAttribute("contenteditable", false);
              [].slice.call(_this.domNode.childNodes).forEach(function(childNode) {
                _this.contentNode.appendChild(childNode);
              });
              _this.leftGuard = document.createTextNode(GUARD_TEXT);
              _this.rightGuard = document.createTextNode(GUARD_TEXT);
              _this.domNode.appendChild(_this.leftGuard);
              _this.domNode.appendChild(_this.contentNode);
              _this.domNode.appendChild(_this.rightGuard);
              return _this;
            }
            _createClass2(Embed3, [{
              key: "index",
              value: function index2(node, offset2) {
                if (node === this.leftGuard)
                  return 0;
                if (node === this.rightGuard)
                  return 1;
                return _get2(Embed3.prototype.__proto__ || Object.getPrototypeOf(Embed3.prototype), "index", this).call(this, node, offset2);
              }
            }, {
              key: "restore",
              value: function restore(node) {
                var range2 = void 0, textNode = void 0;
                var text = node.data.split(GUARD_TEXT).join("");
                if (node === this.leftGuard) {
                  if (this.prev instanceof _text2.default) {
                    var prevLength = this.prev.length();
                    this.prev.insertAt(prevLength, text);
                    range2 = {
                      startNode: this.prev.domNode,
                      startOffset: prevLength + text.length
                    };
                  } else {
                    textNode = document.createTextNode(text);
                    this.parent.insertBefore(_parchment2.default.create(textNode), this);
                    range2 = {
                      startNode: textNode,
                      startOffset: text.length
                    };
                  }
                } else if (node === this.rightGuard) {
                  if (this.next instanceof _text2.default) {
                    this.next.insertAt(0, text);
                    range2 = {
                      startNode: this.next.domNode,
                      startOffset: text.length
                    };
                  } else {
                    textNode = document.createTextNode(text);
                    this.parent.insertBefore(_parchment2.default.create(textNode), this.next);
                    range2 = {
                      startNode: textNode,
                      startOffset: text.length
                    };
                  }
                }
                node.data = GUARD_TEXT;
                return range2;
              }
            }, {
              key: "update",
              value: function update2(mutations, context2) {
                var _this2 = this;
                mutations.forEach(function(mutation) {
                  if (mutation.type === "characterData" && (mutation.target === _this2.leftGuard || mutation.target === _this2.rightGuard)) {
                    var range2 = _this2.restore(mutation.target);
                    if (range2)
                      context2.range = range2;
                  }
                });
              }
            }]);
            return Embed3;
          }(_parchment2.default.Embed);
          exports3.default = Embed2;
        },
        /* 36 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.AlignStyle = exports3.AlignClass = exports3.AlignAttribute = void 0;
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var config2 = {
            scope: _parchment2.default.Scope.BLOCK,
            whitelist: ["right", "center", "justify"]
          };
          var AlignAttribute = new _parchment2.default.Attributor.Attribute("align", "align", config2);
          var AlignClass = new _parchment2.default.Attributor.Class("align", "ql-align", config2);
          var AlignStyle = new _parchment2.default.Attributor.Style("align", "text-align", config2);
          exports3.AlignAttribute = AlignAttribute;
          exports3.AlignClass = AlignClass;
          exports3.AlignStyle = AlignStyle;
        },
        /* 37 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.BackgroundStyle = exports3.BackgroundClass = void 0;
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _color = __webpack_require__(26);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var BackgroundClass = new _parchment2.default.Attributor.Class("background", "ql-bg", {
            scope: _parchment2.default.Scope.INLINE
          });
          var BackgroundStyle = new _color.ColorAttributor("background", "background-color", {
            scope: _parchment2.default.Scope.INLINE
          });
          exports3.BackgroundClass = BackgroundClass;
          exports3.BackgroundStyle = BackgroundStyle;
        },
        /* 38 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.DirectionStyle = exports3.DirectionClass = exports3.DirectionAttribute = void 0;
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var config2 = {
            scope: _parchment2.default.Scope.BLOCK,
            whitelist: ["rtl"]
          };
          var DirectionAttribute = new _parchment2.default.Attributor.Attribute("direction", "dir", config2);
          var DirectionClass = new _parchment2.default.Attributor.Class("direction", "ql-direction", config2);
          var DirectionStyle = new _parchment2.default.Attributor.Style("direction", "direction", config2);
          exports3.DirectionAttribute = DirectionAttribute;
          exports3.DirectionClass = DirectionClass;
          exports3.DirectionStyle = DirectionStyle;
        },
        /* 39 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.FontClass = exports3.FontStyle = void 0;
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get4(object, property2, receiver) {
            if (object === null)
              object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get4(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var config2 = {
            scope: _parchment2.default.Scope.INLINE,
            whitelist: ["serif", "monospace"]
          };
          var FontClass = new _parchment2.default.Attributor.Class("font", "ql-font", config2);
          var FontStyleAttributor = function(_Parchment$Attributor) {
            _inherits2(FontStyleAttributor2, _Parchment$Attributor);
            function FontStyleAttributor2() {
              _classCallCheck2(this, FontStyleAttributor2);
              return _possibleConstructorReturn2(this, (FontStyleAttributor2.__proto__ || Object.getPrototypeOf(FontStyleAttributor2)).apply(this, arguments));
            }
            _createClass2(FontStyleAttributor2, [{
              key: "value",
              value: function value(node) {
                return _get2(FontStyleAttributor2.prototype.__proto__ || Object.getPrototypeOf(FontStyleAttributor2.prototype), "value", this).call(this, node).replace(/["']/g, "");
              }
            }]);
            return FontStyleAttributor2;
          }(_parchment2.default.Attributor.Style);
          var FontStyle = new FontStyleAttributor("font", "font-family", config2);
          exports3.FontStyle = FontStyle;
          exports3.FontClass = FontClass;
        },
        /* 40 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.SizeStyle = exports3.SizeClass = void 0;
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var SizeClass = new _parchment2.default.Attributor.Class("size", "ql-size", {
            scope: _parchment2.default.Scope.INLINE,
            whitelist: ["small", "large", "huge"]
          });
          var SizeStyle = new _parchment2.default.Attributor.Style("size", "font-size", {
            scope: _parchment2.default.Scope.INLINE,
            whitelist: ["10px", "18px", "32px"]
          });
          exports3.SizeClass = SizeClass;
          exports3.SizeStyle = SizeStyle;
        },
        /* 41 */
        /***/
        function(module3, exports3, __webpack_require__) {
          module3.exports = {
            "align": {
              "": __webpack_require__(76),
              "center": __webpack_require__(77),
              "right": __webpack_require__(78),
              "justify": __webpack_require__(79)
            },
            "background": __webpack_require__(80),
            "blockquote": __webpack_require__(81),
            "bold": __webpack_require__(82),
            "clean": __webpack_require__(83),
            "code": __webpack_require__(58),
            "code-block": __webpack_require__(58),
            "color": __webpack_require__(84),
            "direction": {
              "": __webpack_require__(85),
              "rtl": __webpack_require__(86)
            },
            "float": {
              "center": __webpack_require__(87),
              "full": __webpack_require__(88),
              "left": __webpack_require__(89),
              "right": __webpack_require__(90)
            },
            "formula": __webpack_require__(91),
            "header": {
              "1": __webpack_require__(92),
              "2": __webpack_require__(93)
            },
            "italic": __webpack_require__(94),
            "image": __webpack_require__(95),
            "indent": {
              "+1": __webpack_require__(96),
              "-1": __webpack_require__(97)
            },
            "link": __webpack_require__(98),
            "list": {
              "ordered": __webpack_require__(99),
              "bullet": __webpack_require__(100),
              "check": __webpack_require__(101)
            },
            "script": {
              "sub": __webpack_require__(102),
              "super": __webpack_require__(103)
            },
            "strike": __webpack_require__(104),
            "underline": __webpack_require__(105),
            "video": __webpack_require__(106)
          };
        },
        /* 42 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.getLastChangeIndex = exports3.default = void 0;
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _quill = __webpack_require__(5);
          var _quill2 = _interopRequireDefault2(_quill);
          var _module = __webpack_require__(9);
          var _module2 = _interopRequireDefault2(_module);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var History = function(_Module) {
            _inherits2(History2, _Module);
            function History2(quill2, options) {
              _classCallCheck2(this, History2);
              var _this = _possibleConstructorReturn2(this, (History2.__proto__ || Object.getPrototypeOf(History2)).call(this, quill2, options));
              _this.lastRecorded = 0;
              _this.ignoreChange = false;
              _this.clear();
              _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function(eventName, delta, oldDelta, source) {
                if (eventName !== _quill2.default.events.TEXT_CHANGE || _this.ignoreChange)
                  return;
                if (!_this.options.userOnly || source === _quill2.default.sources.USER) {
                  _this.record(delta, oldDelta);
                } else {
                  _this.transform(delta);
                }
              });
              _this.quill.keyboard.addBinding({ key: "Z", shortKey: true }, _this.undo.bind(_this));
              _this.quill.keyboard.addBinding({ key: "Z", shortKey: true, shiftKey: true }, _this.redo.bind(_this));
              if (/Win/i.test(navigator.platform)) {
                _this.quill.keyboard.addBinding({ key: "Y", shortKey: true }, _this.redo.bind(_this));
              }
              return _this;
            }
            _createClass2(History2, [{
              key: "change",
              value: function change(source, dest) {
                if (this.stack[source].length === 0)
                  return;
                var delta = this.stack[source].pop();
                this.stack[dest].push(delta);
                this.lastRecorded = 0;
                this.ignoreChange = true;
                this.quill.updateContents(delta[source], _quill2.default.sources.USER);
                this.ignoreChange = false;
                var index2 = getLastChangeIndex(delta[source]);
                this.quill.setSelection(index2);
              }
            }, {
              key: "clear",
              value: function clear() {
                this.stack = { undo: [], redo: [] };
              }
            }, {
              key: "cutoff",
              value: function cutoff() {
                this.lastRecorded = 0;
              }
            }, {
              key: "record",
              value: function record(changeDelta, oldDelta) {
                if (changeDelta.ops.length === 0)
                  return;
                this.stack.redo = [];
                var undoDelta = this.quill.getContents().diff(oldDelta);
                var timestamp = Date.now();
                if (this.lastRecorded + this.options.delay > timestamp && this.stack.undo.length > 0) {
                  var delta = this.stack.undo.pop();
                  undoDelta = undoDelta.compose(delta.undo);
                  changeDelta = delta.redo.compose(changeDelta);
                } else {
                  this.lastRecorded = timestamp;
                }
                this.stack.undo.push({
                  redo: changeDelta,
                  undo: undoDelta
                });
                if (this.stack.undo.length > this.options.maxStack) {
                  this.stack.undo.shift();
                }
              }
            }, {
              key: "redo",
              value: function redo() {
                this.change("redo", "undo");
              }
            }, {
              key: "transform",
              value: function transform2(delta) {
                this.stack.undo.forEach(function(change) {
                  change.undo = delta.transform(change.undo, true);
                  change.redo = delta.transform(change.redo, true);
                });
                this.stack.redo.forEach(function(change) {
                  change.undo = delta.transform(change.undo, true);
                  change.redo = delta.transform(change.redo, true);
                });
              }
            }, {
              key: "undo",
              value: function undo() {
                this.change("undo", "redo");
              }
            }]);
            return History2;
          }(_module2.default);
          History.DEFAULTS = {
            delay: 1e3,
            maxStack: 100,
            userOnly: false
          };
          function endsWithNewlineChange(delta) {
            var lastOp = delta.ops[delta.ops.length - 1];
            if (lastOp == null)
              return false;
            if (lastOp.insert != null) {
              return typeof lastOp.insert === "string" && lastOp.insert.endsWith("\n");
            }
            if (lastOp.attributes != null) {
              return Object.keys(lastOp.attributes).some(function(attr) {
                return _parchment2.default.query(attr, _parchment2.default.Scope.BLOCK) != null;
              });
            }
            return false;
          }
          function getLastChangeIndex(delta) {
            var deleteLength = delta.reduce(function(length, op) {
              length += op.delete || 0;
              return length;
            }, 0);
            var changeIndex = delta.length() - deleteLength;
            if (endsWithNewlineChange(delta)) {
              changeIndex -= 1;
            }
            return changeIndex;
          }
          exports3.default = History;
          exports3.getLastChangeIndex = getLastChangeIndex;
        },
        /* 43 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.default = exports3.BaseTooltip = void 0;
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get4(object, property2, receiver) {
            if (object === null)
              object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get4(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _extend = __webpack_require__(3);
          var _extend2 = _interopRequireDefault2(_extend);
          var _quillDelta = __webpack_require__(2);
          var _quillDelta2 = _interopRequireDefault2(_quillDelta);
          var _emitter = __webpack_require__(8);
          var _emitter2 = _interopRequireDefault2(_emitter);
          var _keyboard = __webpack_require__(23);
          var _keyboard2 = _interopRequireDefault2(_keyboard);
          var _theme = __webpack_require__(34);
          var _theme2 = _interopRequireDefault2(_theme);
          var _colorPicker = __webpack_require__(59);
          var _colorPicker2 = _interopRequireDefault2(_colorPicker);
          var _iconPicker = __webpack_require__(60);
          var _iconPicker2 = _interopRequireDefault2(_iconPicker);
          var _picker = __webpack_require__(28);
          var _picker2 = _interopRequireDefault2(_picker);
          var _tooltip = __webpack_require__(61);
          var _tooltip2 = _interopRequireDefault2(_tooltip);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var ALIGNS = [false, "center", "right", "justify"];
          var COLORS = ["#000000", "#e60000", "#ff9900", "#ffff00", "#008a00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466"];
          var FONTS = [false, "serif", "monospace"];
          var HEADERS = ["1", "2", "3", false];
          var SIZES = ["small", false, "large", "huge"];
          var BaseTheme = function(_Theme) {
            _inherits2(BaseTheme2, _Theme);
            function BaseTheme2(quill2, options) {
              _classCallCheck2(this, BaseTheme2);
              var _this = _possibleConstructorReturn2(this, (BaseTheme2.__proto__ || Object.getPrototypeOf(BaseTheme2)).call(this, quill2, options));
              var listener = function listener2(e2) {
                if (!document.body.contains(quill2.root)) {
                  return document.body.removeEventListener("click", listener2);
                }
                if (_this.tooltip != null && !_this.tooltip.root.contains(e2.target) && document.activeElement !== _this.tooltip.textbox && !_this.quill.hasFocus()) {
                  _this.tooltip.hide();
                }
                if (_this.pickers != null) {
                  _this.pickers.forEach(function(picker) {
                    if (!picker.container.contains(e2.target)) {
                      picker.close();
                    }
                  });
                }
              };
              quill2.emitter.listenDOM("click", document.body, listener);
              return _this;
            }
            _createClass2(BaseTheme2, [{
              key: "addModule",
              value: function addModule(name) {
                var module4 = _get2(BaseTheme2.prototype.__proto__ || Object.getPrototypeOf(BaseTheme2.prototype), "addModule", this).call(this, name);
                if (name === "toolbar") {
                  this.extendToolbar(module4);
                }
                return module4;
              }
            }, {
              key: "buildButtons",
              value: function buildButtons(buttons, icons) {
                buttons.forEach(function(button) {
                  var className = button.getAttribute("class") || "";
                  className.split(/\s+/).forEach(function(name) {
                    if (!name.startsWith("ql-"))
                      return;
                    name = name.slice("ql-".length);
                    if (icons[name] == null)
                      return;
                    if (name === "direction") {
                      button.innerHTML = icons[name][""] + icons[name]["rtl"];
                    } else if (typeof icons[name] === "string") {
                      button.innerHTML = icons[name];
                    } else {
                      var value = button.value || "";
                      if (value != null && icons[name][value]) {
                        button.innerHTML = icons[name][value];
                      }
                    }
                  });
                });
              }
            }, {
              key: "buildPickers",
              value: function buildPickers(selects, icons) {
                var _this2 = this;
                this.pickers = selects.map(function(select) {
                  if (select.classList.contains("ql-align")) {
                    if (select.querySelector("option") == null) {
                      fillSelect(select, ALIGNS);
                    }
                    return new _iconPicker2.default(select, icons.align);
                  } else if (select.classList.contains("ql-background") || select.classList.contains("ql-color")) {
                    var format2 = select.classList.contains("ql-background") ? "background" : "color";
                    if (select.querySelector("option") == null) {
                      fillSelect(select, COLORS, format2 === "background" ? "#ffffff" : "#000000");
                    }
                    return new _colorPicker2.default(select, icons[format2]);
                  } else {
                    if (select.querySelector("option") == null) {
                      if (select.classList.contains("ql-font")) {
                        fillSelect(select, FONTS);
                      } else if (select.classList.contains("ql-header")) {
                        fillSelect(select, HEADERS);
                      } else if (select.classList.contains("ql-size")) {
                        fillSelect(select, SIZES);
                      }
                    }
                    return new _picker2.default(select);
                  }
                });
                var update2 = function update3() {
                  _this2.pickers.forEach(function(picker) {
                    picker.update();
                  });
                };
                this.quill.on(_emitter2.default.events.EDITOR_CHANGE, update2);
              }
            }]);
            return BaseTheme2;
          }(_theme2.default);
          BaseTheme.DEFAULTS = (0, _extend2.default)(true, {}, _theme2.default.DEFAULTS, {
            modules: {
              toolbar: {
                handlers: {
                  formula: function formula() {
                    this.quill.theme.tooltip.edit("formula");
                  },
                  image: function image() {
                    var _this3 = this;
                    var fileInput = this.container.querySelector("input.ql-image[type=file]");
                    if (fileInput == null) {
                      fileInput = document.createElement("input");
                      fileInput.setAttribute("type", "file");
                      fileInput.setAttribute("accept", "image/png, image/gif, image/jpeg, image/bmp, image/x-icon");
                      fileInput.classList.add("ql-image");
                      fileInput.addEventListener("change", function() {
                        if (fileInput.files != null && fileInput.files[0] != null) {
                          var reader = new FileReader();
                          reader.onload = function(e2) {
                            var range2 = _this3.quill.getSelection(true);
                            _this3.quill.updateContents(new _quillDelta2.default().retain(range2.index).delete(range2.length).insert({ image: e2.target.result }), _emitter2.default.sources.USER);
                            _this3.quill.setSelection(range2.index + 1, _emitter2.default.sources.SILENT);
                            fileInput.value = "";
                          };
                          reader.readAsDataURL(fileInput.files[0]);
                        }
                      });
                      this.container.appendChild(fileInput);
                    }
                    fileInput.click();
                  },
                  video: function video() {
                    this.quill.theme.tooltip.edit("video");
                  }
                }
              }
            }
          });
          var BaseTooltip = function(_Tooltip) {
            _inherits2(BaseTooltip2, _Tooltip);
            function BaseTooltip2(quill2, boundsContainer) {
              _classCallCheck2(this, BaseTooltip2);
              var _this4 = _possibleConstructorReturn2(this, (BaseTooltip2.__proto__ || Object.getPrototypeOf(BaseTooltip2)).call(this, quill2, boundsContainer));
              _this4.textbox = _this4.root.querySelector('input[type="text"]');
              _this4.listen();
              return _this4;
            }
            _createClass2(BaseTooltip2, [{
              key: "listen",
              value: function listen() {
                var _this5 = this;
                this.textbox.addEventListener("keydown", function(event) {
                  if (_keyboard2.default.match(event, "enter")) {
                    _this5.save();
                    event.preventDefault();
                  } else if (_keyboard2.default.match(event, "escape")) {
                    _this5.cancel();
                    event.preventDefault();
                  }
                });
              }
            }, {
              key: "cancel",
              value: function cancel() {
                this.hide();
              }
            }, {
              key: "edit",
              value: function edit() {
                var mode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "link";
                var preview = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                this.root.classList.remove("ql-hidden");
                this.root.classList.add("ql-editing");
                if (preview != null) {
                  this.textbox.value = preview;
                } else if (mode !== this.root.getAttribute("data-mode")) {
                  this.textbox.value = "";
                }
                this.position(this.quill.getBounds(this.quill.selection.savedRange));
                this.textbox.select();
                this.textbox.setAttribute("placeholder", this.textbox.getAttribute("data-" + mode) || "");
                this.root.setAttribute("data-mode", mode);
              }
            }, {
              key: "restoreFocus",
              value: function restoreFocus() {
                var scrollTop = this.quill.scrollingContainer.scrollTop;
                this.quill.focus();
                this.quill.scrollingContainer.scrollTop = scrollTop;
              }
            }, {
              key: "save",
              value: function save2() {
                var value = this.textbox.value;
                switch (this.root.getAttribute("data-mode")) {
                  case "link": {
                    var scrollTop = this.quill.root.scrollTop;
                    if (this.linkRange) {
                      this.quill.formatText(this.linkRange, "link", value, _emitter2.default.sources.USER);
                      delete this.linkRange;
                    } else {
                      this.restoreFocus();
                      this.quill.format("link", value, _emitter2.default.sources.USER);
                    }
                    this.quill.root.scrollTop = scrollTop;
                    break;
                  }
                  case "video": {
                    value = extractVideoUrl(value);
                  }
                  case "formula": {
                    if (!value)
                      break;
                    var range2 = this.quill.getSelection(true);
                    if (range2 != null) {
                      var index2 = range2.index + range2.length;
                      this.quill.insertEmbed(index2, this.root.getAttribute("data-mode"), value, _emitter2.default.sources.USER);
                      if (this.root.getAttribute("data-mode") === "formula") {
                        this.quill.insertText(index2 + 1, " ", _emitter2.default.sources.USER);
                      }
                      this.quill.setSelection(index2 + 2, _emitter2.default.sources.USER);
                    }
                    break;
                  }
                }
                this.textbox.value = "";
                this.hide();
              }
            }]);
            return BaseTooltip2;
          }(_tooltip2.default);
          function extractVideoUrl(url) {
            var match5 = url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/) || url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);
            if (match5) {
              return (match5[1] || "https") + "://www.youtube.com/embed/" + match5[2] + "?showinfo=0";
            }
            if (match5 = url.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/)) {
              return (match5[1] || "https") + "://player.vimeo.com/video/" + match5[2] + "/";
            }
            return url;
          }
          function fillSelect(select, values) {
            var defaultValue4 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            values.forEach(function(value) {
              var option = document.createElement("option");
              if (value === defaultValue4) {
                option.setAttribute("selected", "selected");
              } else {
                option.setAttribute("value", value);
              }
              select.appendChild(option);
            });
          }
          exports3.BaseTooltip = BaseTooltip;
          exports3.default = BaseTheme;
        },
        /* 44 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          var LinkedList = (
            /** @class */
            function() {
              function LinkedList2() {
                this.head = this.tail = null;
                this.length = 0;
              }
              LinkedList2.prototype.append = function() {
                var nodes = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  nodes[_i] = arguments[_i];
                }
                this.insertBefore(nodes[0], null);
                if (nodes.length > 1) {
                  this.append.apply(this, nodes.slice(1));
                }
              };
              LinkedList2.prototype.contains = function(node) {
                var cur, next = this.iterator();
                while (cur = next()) {
                  if (cur === node)
                    return true;
                }
                return false;
              };
              LinkedList2.prototype.insertBefore = function(node, refNode) {
                if (!node)
                  return;
                node.next = refNode;
                if (refNode != null) {
                  node.prev = refNode.prev;
                  if (refNode.prev != null) {
                    refNode.prev.next = node;
                  }
                  refNode.prev = node;
                  if (refNode === this.head) {
                    this.head = node;
                  }
                } else if (this.tail != null) {
                  this.tail.next = node;
                  node.prev = this.tail;
                  this.tail = node;
                } else {
                  node.prev = null;
                  this.head = this.tail = node;
                }
                this.length += 1;
              };
              LinkedList2.prototype.offset = function(target) {
                var index2 = 0, cur = this.head;
                while (cur != null) {
                  if (cur === target)
                    return index2;
                  index2 += cur.length();
                  cur = cur.next;
                }
                return -1;
              };
              LinkedList2.prototype.remove = function(node) {
                if (!this.contains(node))
                  return;
                if (node.prev != null)
                  node.prev.next = node.next;
                if (node.next != null)
                  node.next.prev = node.prev;
                if (node === this.head)
                  this.head = node.next;
                if (node === this.tail)
                  this.tail = node.prev;
                this.length -= 1;
              };
              LinkedList2.prototype.iterator = function(curNode) {
                if (curNode === void 0) {
                  curNode = this.head;
                }
                return function() {
                  var ret = curNode;
                  if (curNode != null)
                    curNode = curNode.next;
                  return ret;
                };
              };
              LinkedList2.prototype.find = function(index2, inclusive) {
                if (inclusive === void 0) {
                  inclusive = false;
                }
                var cur, next = this.iterator();
                while (cur = next()) {
                  var length = cur.length();
                  if (index2 < length || inclusive && index2 === length && (cur.next == null || cur.next.length() !== 0)) {
                    return [cur, index2];
                  }
                  index2 -= length;
                }
                return [null, 0];
              };
              LinkedList2.prototype.forEach = function(callback) {
                var cur, next = this.iterator();
                while (cur = next()) {
                  callback(cur);
                }
              };
              LinkedList2.prototype.forEachAt = function(index2, length, callback) {
                if (length <= 0)
                  return;
                var _a = this.find(index2), startNode = _a[0], offset2 = _a[1];
                var cur, curIndex = index2 - offset2, next = this.iterator(startNode);
                while ((cur = next()) && curIndex < index2 + length) {
                  var curLength = cur.length();
                  if (index2 > curIndex) {
                    callback(cur, index2 - curIndex, Math.min(length, curIndex + curLength - index2));
                  } else {
                    callback(cur, 0, Math.min(curLength, index2 + length - curIndex));
                  }
                  curIndex += curLength;
                }
              };
              LinkedList2.prototype.map = function(callback) {
                return this.reduce(function(memo, cur) {
                  memo.push(callback(cur));
                  return memo;
                }, []);
              };
              LinkedList2.prototype.reduce = function(callback, memo) {
                var cur, next = this.iterator();
                while (cur = next()) {
                  memo = callback(memo, cur);
                }
                return memo;
              };
              return LinkedList2;
            }()
          );
          exports3.default = LinkedList;
        },
        /* 45 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var __extends2 = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p2 in b2)
                if (b2.hasOwnProperty(p2))
                  d2[p2] = b2[p2];
            };
            return function(d2, b2) {
              extendStatics(d2, b2);
              function __() {
                this.constructor = d2;
              }
              d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
            };
          }();
          Object.defineProperty(exports3, "__esModule", { value: true });
          var container_1 = __webpack_require__(17);
          var Registry = __webpack_require__(1);
          var OBSERVER_CONFIG = {
            attributes: true,
            characterData: true,
            characterDataOldValue: true,
            childList: true,
            subtree: true
          };
          var MAX_OPTIMIZE_ITERATIONS = 100;
          var ScrollBlot = (
            /** @class */
            function(_super) {
              __extends2(ScrollBlot2, _super);
              function ScrollBlot2(node) {
                var _this = _super.call(this, node) || this;
                _this.scroll = _this;
                _this.observer = new MutationObserver(function(mutations) {
                  _this.update(mutations);
                });
                _this.observer.observe(_this.domNode, OBSERVER_CONFIG);
                _this.attach();
                return _this;
              }
              ScrollBlot2.prototype.detach = function() {
                _super.prototype.detach.call(this);
                this.observer.disconnect();
              };
              ScrollBlot2.prototype.deleteAt = function(index2, length) {
                this.update();
                if (index2 === 0 && length === this.length()) {
                  this.children.forEach(function(child) {
                    child.remove();
                  });
                } else {
                  _super.prototype.deleteAt.call(this, index2, length);
                }
              };
              ScrollBlot2.prototype.formatAt = function(index2, length, name, value) {
                this.update();
                _super.prototype.formatAt.call(this, index2, length, name, value);
              };
              ScrollBlot2.prototype.insertAt = function(index2, value, def) {
                this.update();
                _super.prototype.insertAt.call(this, index2, value, def);
              };
              ScrollBlot2.prototype.optimize = function(mutations, context2) {
                var _this = this;
                if (mutations === void 0) {
                  mutations = [];
                }
                if (context2 === void 0) {
                  context2 = {};
                }
                _super.prototype.optimize.call(this, context2);
                var records = [].slice.call(this.observer.takeRecords());
                while (records.length > 0)
                  mutations.push(records.pop());
                var mark = function(blot, markParent) {
                  if (markParent === void 0) {
                    markParent = true;
                  }
                  if (blot == null || blot === _this)
                    return;
                  if (blot.domNode.parentNode == null)
                    return;
                  if (blot.domNode[Registry.DATA_KEY].mutations == null) {
                    blot.domNode[Registry.DATA_KEY].mutations = [];
                  }
                  if (markParent)
                    mark(blot.parent);
                };
                var optimize = function(blot) {
                  if (
                    // @ts-ignore
                    blot.domNode[Registry.DATA_KEY] == null || // @ts-ignore
                    blot.domNode[Registry.DATA_KEY].mutations == null
                  ) {
                    return;
                  }
                  if (blot instanceof container_1.default) {
                    blot.children.forEach(optimize);
                  }
                  blot.optimize(context2);
                };
                var remaining = mutations;
                for (var i2 = 0; remaining.length > 0; i2 += 1) {
                  if (i2 >= MAX_OPTIMIZE_ITERATIONS) {
                    throw new Error("[Parchment] Maximum optimize iterations reached");
                  }
                  remaining.forEach(function(mutation) {
                    var blot = Registry.find(mutation.target, true);
                    if (blot == null)
                      return;
                    if (blot.domNode === mutation.target) {
                      if (mutation.type === "childList") {
                        mark(Registry.find(mutation.previousSibling, false));
                        [].forEach.call(mutation.addedNodes, function(node) {
                          var child = Registry.find(node, false);
                          mark(child, false);
                          if (child instanceof container_1.default) {
                            child.children.forEach(function(grandChild) {
                              mark(grandChild, false);
                            });
                          }
                        });
                      } else if (mutation.type === "attributes") {
                        mark(blot.prev);
                      }
                    }
                    mark(blot);
                  });
                  this.children.forEach(optimize);
                  remaining = [].slice.call(this.observer.takeRecords());
                  records = remaining.slice();
                  while (records.length > 0)
                    mutations.push(records.pop());
                }
              };
              ScrollBlot2.prototype.update = function(mutations, context2) {
                var _this = this;
                if (context2 === void 0) {
                  context2 = {};
                }
                mutations = mutations || this.observer.takeRecords();
                mutations.map(function(mutation) {
                  var blot = Registry.find(mutation.target, true);
                  if (blot == null)
                    return null;
                  if (blot.domNode[Registry.DATA_KEY].mutations == null) {
                    blot.domNode[Registry.DATA_KEY].mutations = [mutation];
                    return blot;
                  } else {
                    blot.domNode[Registry.DATA_KEY].mutations.push(mutation);
                    return null;
                  }
                }).forEach(function(blot) {
                  if (blot == null || blot === _this || //@ts-ignore
                  blot.domNode[Registry.DATA_KEY] == null)
                    return;
                  blot.update(blot.domNode[Registry.DATA_KEY].mutations || [], context2);
                });
                if (this.domNode[Registry.DATA_KEY].mutations != null) {
                  _super.prototype.update.call(this, this.domNode[Registry.DATA_KEY].mutations, context2);
                }
                this.optimize(mutations, context2);
              };
              ScrollBlot2.blotName = "scroll";
              ScrollBlot2.defaultChild = "block";
              ScrollBlot2.scope = Registry.Scope.BLOCK_BLOT;
              ScrollBlot2.tagName = "DIV";
              return ScrollBlot2;
            }(container_1.default)
          );
          exports3.default = ScrollBlot;
        },
        /* 46 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var __extends2 = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p2 in b2)
                if (b2.hasOwnProperty(p2))
                  d2[p2] = b2[p2];
            };
            return function(d2, b2) {
              extendStatics(d2, b2);
              function __() {
                this.constructor = d2;
              }
              d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
            };
          }();
          Object.defineProperty(exports3, "__esModule", { value: true });
          var format_1 = __webpack_require__(18);
          var Registry = __webpack_require__(1);
          function isEqual2(obj1, obj2) {
            if (Object.keys(obj1).length !== Object.keys(obj2).length)
              return false;
            for (var prop in obj1) {
              if (obj1[prop] !== obj2[prop])
                return false;
            }
            return true;
          }
          var InlineBlot = (
            /** @class */
            function(_super) {
              __extends2(InlineBlot2, _super);
              function InlineBlot2() {
                return _super !== null && _super.apply(this, arguments) || this;
              }
              InlineBlot2.formats = function(domNode) {
                if (domNode.tagName === InlineBlot2.tagName)
                  return void 0;
                return _super.formats.call(this, domNode);
              };
              InlineBlot2.prototype.format = function(name, value) {
                var _this = this;
                if (name === this.statics.blotName && !value) {
                  this.children.forEach(function(child) {
                    if (!(child instanceof format_1.default)) {
                      child = child.wrap(InlineBlot2.blotName, true);
                    }
                    _this.attributes.copy(child);
                  });
                  this.unwrap();
                } else {
                  _super.prototype.format.call(this, name, value);
                }
              };
              InlineBlot2.prototype.formatAt = function(index2, length, name, value) {
                if (this.formats()[name] != null || Registry.query(name, Registry.Scope.ATTRIBUTE)) {
                  var blot = this.isolate(index2, length);
                  blot.format(name, value);
                } else {
                  _super.prototype.formatAt.call(this, index2, length, name, value);
                }
              };
              InlineBlot2.prototype.optimize = function(context2) {
                _super.prototype.optimize.call(this, context2);
                var formats = this.formats();
                if (Object.keys(formats).length === 0) {
                  return this.unwrap();
                }
                var next = this.next;
                if (next instanceof InlineBlot2 && next.prev === this && isEqual2(formats, next.formats())) {
                  next.moveChildren(this);
                  next.remove();
                }
              };
              InlineBlot2.blotName = "inline";
              InlineBlot2.scope = Registry.Scope.INLINE_BLOT;
              InlineBlot2.tagName = "SPAN";
              return InlineBlot2;
            }(format_1.default)
          );
          exports3.default = InlineBlot;
        },
        /* 47 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var __extends2 = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p2 in b2)
                if (b2.hasOwnProperty(p2))
                  d2[p2] = b2[p2];
            };
            return function(d2, b2) {
              extendStatics(d2, b2);
              function __() {
                this.constructor = d2;
              }
              d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
            };
          }();
          Object.defineProperty(exports3, "__esModule", { value: true });
          var format_1 = __webpack_require__(18);
          var Registry = __webpack_require__(1);
          var BlockBlot = (
            /** @class */
            function(_super) {
              __extends2(BlockBlot2, _super);
              function BlockBlot2() {
                return _super !== null && _super.apply(this, arguments) || this;
              }
              BlockBlot2.formats = function(domNode) {
                var tagName = Registry.query(BlockBlot2.blotName).tagName;
                if (domNode.tagName === tagName)
                  return void 0;
                return _super.formats.call(this, domNode);
              };
              BlockBlot2.prototype.format = function(name, value) {
                if (Registry.query(name, Registry.Scope.BLOCK) == null) {
                  return;
                } else if (name === this.statics.blotName && !value) {
                  this.replaceWith(BlockBlot2.blotName);
                } else {
                  _super.prototype.format.call(this, name, value);
                }
              };
              BlockBlot2.prototype.formatAt = function(index2, length, name, value) {
                if (Registry.query(name, Registry.Scope.BLOCK) != null) {
                  this.format(name, value);
                } else {
                  _super.prototype.formatAt.call(this, index2, length, name, value);
                }
              };
              BlockBlot2.prototype.insertAt = function(index2, value, def) {
                if (def == null || Registry.query(value, Registry.Scope.INLINE) != null) {
                  _super.prototype.insertAt.call(this, index2, value, def);
                } else {
                  var after = this.split(index2);
                  var blot = Registry.create(value, def);
                  after.parent.insertBefore(blot, after);
                }
              };
              BlockBlot2.prototype.update = function(mutations, context2) {
                if (navigator.userAgent.match(/Trident/)) {
                  this.build();
                } else {
                  _super.prototype.update.call(this, mutations, context2);
                }
              };
              BlockBlot2.blotName = "block";
              BlockBlot2.scope = Registry.Scope.BLOCK_BLOT;
              BlockBlot2.tagName = "P";
              return BlockBlot2;
            }(format_1.default)
          );
          exports3.default = BlockBlot;
        },
        /* 48 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var __extends2 = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p2 in b2)
                if (b2.hasOwnProperty(p2))
                  d2[p2] = b2[p2];
            };
            return function(d2, b2) {
              extendStatics(d2, b2);
              function __() {
                this.constructor = d2;
              }
              d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
            };
          }();
          Object.defineProperty(exports3, "__esModule", { value: true });
          var leaf_1 = __webpack_require__(19);
          var EmbedBlot = (
            /** @class */
            function(_super) {
              __extends2(EmbedBlot2, _super);
              function EmbedBlot2() {
                return _super !== null && _super.apply(this, arguments) || this;
              }
              EmbedBlot2.formats = function(domNode) {
                return void 0;
              };
              EmbedBlot2.prototype.format = function(name, value) {
                _super.prototype.formatAt.call(this, 0, this.length(), name, value);
              };
              EmbedBlot2.prototype.formatAt = function(index2, length, name, value) {
                if (index2 === 0 && length === this.length()) {
                  this.format(name, value);
                } else {
                  _super.prototype.formatAt.call(this, index2, length, name, value);
                }
              };
              EmbedBlot2.prototype.formats = function() {
                return this.statics.formats(this.domNode);
              };
              return EmbedBlot2;
            }(leaf_1.default)
          );
          exports3.default = EmbedBlot;
        },
        /* 49 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var __extends2 = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p2 in b2)
                if (b2.hasOwnProperty(p2))
                  d2[p2] = b2[p2];
            };
            return function(d2, b2) {
              extendStatics(d2, b2);
              function __() {
                this.constructor = d2;
              }
              d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
            };
          }();
          Object.defineProperty(exports3, "__esModule", { value: true });
          var leaf_1 = __webpack_require__(19);
          var Registry = __webpack_require__(1);
          var TextBlot = (
            /** @class */
            function(_super) {
              __extends2(TextBlot2, _super);
              function TextBlot2(node) {
                var _this = _super.call(this, node) || this;
                _this.text = _this.statics.value(_this.domNode);
                return _this;
              }
              TextBlot2.create = function(value) {
                return document.createTextNode(value);
              };
              TextBlot2.value = function(domNode) {
                var text = domNode.data;
                if (text["normalize"])
                  text = text["normalize"]();
                return text;
              };
              TextBlot2.prototype.deleteAt = function(index2, length) {
                this.domNode.data = this.text = this.text.slice(0, index2) + this.text.slice(index2 + length);
              };
              TextBlot2.prototype.index = function(node, offset2) {
                if (this.domNode === node) {
                  return offset2;
                }
                return -1;
              };
              TextBlot2.prototype.insertAt = function(index2, value, def) {
                if (def == null) {
                  this.text = this.text.slice(0, index2) + value + this.text.slice(index2);
                  this.domNode.data = this.text;
                } else {
                  _super.prototype.insertAt.call(this, index2, value, def);
                }
              };
              TextBlot2.prototype.length = function() {
                return this.text.length;
              };
              TextBlot2.prototype.optimize = function(context2) {
                _super.prototype.optimize.call(this, context2);
                this.text = this.statics.value(this.domNode);
                if (this.text.length === 0) {
                  this.remove();
                } else if (this.next instanceof TextBlot2 && this.next.prev === this) {
                  this.insertAt(this.length(), this.next.value());
                  this.next.remove();
                }
              };
              TextBlot2.prototype.position = function(index2, inclusive) {
                return [this.domNode, index2];
              };
              TextBlot2.prototype.split = function(index2, force) {
                if (force === void 0) {
                  force = false;
                }
                if (!force) {
                  if (index2 === 0)
                    return this;
                  if (index2 === this.length())
                    return this.next;
                }
                var after = Registry.create(this.domNode.splitText(index2));
                this.parent.insertBefore(after, this.next);
                this.text = this.statics.value(this.domNode);
                return after;
              };
              TextBlot2.prototype.update = function(mutations, context2) {
                var _this = this;
                if (mutations.some(function(mutation) {
                  return mutation.type === "characterData" && mutation.target === _this.domNode;
                })) {
                  this.text = this.statics.value(this.domNode);
                }
              };
              TextBlot2.prototype.value = function() {
                return this.text;
              };
              TextBlot2.blotName = "text";
              TextBlot2.scope = Registry.Scope.INLINE_BLOT;
              return TextBlot2;
            }(leaf_1.default)
          );
          exports3.default = TextBlot;
        },
        /* 50 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var elem = document.createElement("div");
          elem.classList.toggle("test-class", false);
          if (elem.classList.contains("test-class")) {
            var _toggle = DOMTokenList.prototype.toggle;
            DOMTokenList.prototype.toggle = function(token2, force) {
              if (arguments.length > 1 && !this.contains(token2) === !force) {
                return force;
              } else {
                return _toggle.call(this, token2);
              }
            };
          }
          if (!String.prototype.startsWith) {
            String.prototype.startsWith = function(searchString, position) {
              position = position || 0;
              return this.substr(position, searchString.length) === searchString;
            };
          }
          if (!String.prototype.endsWith) {
            String.prototype.endsWith = function(searchString, position) {
              var subjectString = this.toString();
              if (typeof position !== "number" || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
                position = subjectString.length;
              }
              position -= searchString.length;
              var lastIndex = subjectString.indexOf(searchString, position);
              return lastIndex !== -1 && lastIndex === position;
            };
          }
          if (!Array.prototype.find) {
            Object.defineProperty(Array.prototype, "find", {
              value: function value(predicate) {
                if (this === null) {
                  throw new TypeError("Array.prototype.find called on null or undefined");
                }
                if (typeof predicate !== "function") {
                  throw new TypeError("predicate must be a function");
                }
                var list2 = Object(this);
                var length = list2.length >>> 0;
                var thisArg = arguments[1];
                var value2;
                for (var i2 = 0; i2 < length; i2++) {
                  value2 = list2[i2];
                  if (predicate.call(thisArg, value2, i2, list2)) {
                    return value2;
                  }
                }
                return void 0;
              }
            });
          }
          document.addEventListener("DOMContentLoaded", function() {
            document.execCommand("enableObjectResizing", false, false);
            document.execCommand("autoUrlDetect", false, false);
          });
        },
        /* 51 */
        /***/
        function(module3, exports3) {
          var DIFF_DELETE = -1;
          var DIFF_INSERT = 1;
          var DIFF_EQUAL = 0;
          function diff_main(text1, text2, cursor_pos) {
            if (text1 == text2) {
              if (text1) {
                return [[DIFF_EQUAL, text1]];
              }
              return [];
            }
            if (cursor_pos < 0 || text1.length < cursor_pos) {
              cursor_pos = null;
            }
            var commonlength = diff_commonPrefix(text1, text2);
            var commonprefix = text1.substring(0, commonlength);
            text1 = text1.substring(commonlength);
            text2 = text2.substring(commonlength);
            commonlength = diff_commonSuffix(text1, text2);
            var commonsuffix = text1.substring(text1.length - commonlength);
            text1 = text1.substring(0, text1.length - commonlength);
            text2 = text2.substring(0, text2.length - commonlength);
            var diffs = diff_compute_(text1, text2);
            if (commonprefix) {
              diffs.unshift([DIFF_EQUAL, commonprefix]);
            }
            if (commonsuffix) {
              diffs.push([DIFF_EQUAL, commonsuffix]);
            }
            diff_cleanupMerge(diffs);
            if (cursor_pos != null) {
              diffs = fix_cursor(diffs, cursor_pos);
            }
            diffs = fix_emoji(diffs);
            return diffs;
          }
          function diff_compute_(text1, text2) {
            var diffs;
            if (!text1) {
              return [[DIFF_INSERT, text2]];
            }
            if (!text2) {
              return [[DIFF_DELETE, text1]];
            }
            var longtext = text1.length > text2.length ? text1 : text2;
            var shorttext = text1.length > text2.length ? text2 : text1;
            var i2 = longtext.indexOf(shorttext);
            if (i2 != -1) {
              diffs = [
                [DIFF_INSERT, longtext.substring(0, i2)],
                [DIFF_EQUAL, shorttext],
                [DIFF_INSERT, longtext.substring(i2 + shorttext.length)]
              ];
              if (text1.length > text2.length) {
                diffs[0][0] = diffs[2][0] = DIFF_DELETE;
              }
              return diffs;
            }
            if (shorttext.length == 1) {
              return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
            }
            var hm = diff_halfMatch_(text1, text2);
            if (hm) {
              var text1_a = hm[0];
              var text1_b = hm[1];
              var text2_a = hm[2];
              var text2_b = hm[3];
              var mid_common = hm[4];
              var diffs_a = diff_main(text1_a, text2_a);
              var diffs_b = diff_main(text1_b, text2_b);
              return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
            }
            return diff_bisect_(text1, text2);
          }
          function diff_bisect_(text1, text2) {
            var text1_length = text1.length;
            var text2_length = text2.length;
            var max_d = Math.ceil((text1_length + text2_length) / 2);
            var v_offset = max_d;
            var v_length = 2 * max_d;
            var v1 = new Array(v_length);
            var v2 = new Array(v_length);
            for (var x = 0; x < v_length; x++) {
              v1[x] = -1;
              v2[x] = -1;
            }
            v1[v_offset + 1] = 0;
            v2[v_offset + 1] = 0;
            var delta = text1_length - text2_length;
            var front = delta % 2 != 0;
            var k1start = 0;
            var k1end = 0;
            var k2start = 0;
            var k2end = 0;
            for (var d2 = 0; d2 < max_d; d2++) {
              for (var k1 = -d2 + k1start; k1 <= d2 - k1end; k1 += 2) {
                var k1_offset = v_offset + k1;
                var x1;
                if (k1 == -d2 || k1 != d2 && v1[k1_offset - 1] < v1[k1_offset + 1]) {
                  x1 = v1[k1_offset + 1];
                } else {
                  x1 = v1[k1_offset - 1] + 1;
                }
                var y1 = x1 - k1;
                while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)) {
                  x1++;
                  y1++;
                }
                v1[k1_offset] = x1;
                if (x1 > text1_length) {
                  k1end += 2;
                } else if (y1 > text2_length) {
                  k1start += 2;
                } else if (front) {
                  var k2_offset = v_offset + delta - k1;
                  if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
                    var x2 = text1_length - v2[k2_offset];
                    if (x1 >= x2) {
                      return diff_bisectSplit_(text1, text2, x1, y1);
                    }
                  }
                }
              }
              for (var k2 = -d2 + k2start; k2 <= d2 - k2end; k2 += 2) {
                var k2_offset = v_offset + k2;
                var x2;
                if (k2 == -d2 || k2 != d2 && v2[k2_offset - 1] < v2[k2_offset + 1]) {
                  x2 = v2[k2_offset + 1];
                } else {
                  x2 = v2[k2_offset - 1] + 1;
                }
                var y2 = x2 - k2;
                while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) == text2.charAt(text2_length - y2 - 1)) {
                  x2++;
                  y2++;
                }
                v2[k2_offset] = x2;
                if (x2 > text1_length) {
                  k2end += 2;
                } else if (y2 > text2_length) {
                  k2start += 2;
                } else if (!front) {
                  var k1_offset = v_offset + delta - k2;
                  if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
                    var x1 = v1[k1_offset];
                    var y1 = v_offset + x1 - k1_offset;
                    x2 = text1_length - x2;
                    if (x1 >= x2) {
                      return diff_bisectSplit_(text1, text2, x1, y1);
                    }
                  }
                }
              }
            }
            return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
          }
          function diff_bisectSplit_(text1, text2, x, y2) {
            var text1a = text1.substring(0, x);
            var text2a = text2.substring(0, y2);
            var text1b = text1.substring(x);
            var text2b = text2.substring(y2);
            var diffs = diff_main(text1a, text2a);
            var diffsb = diff_main(text1b, text2b);
            return diffs.concat(diffsb);
          }
          function diff_commonPrefix(text1, text2) {
            if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
              return 0;
            }
            var pointermin = 0;
            var pointermax = Math.min(text1.length, text2.length);
            var pointermid = pointermax;
            var pointerstart = 0;
            while (pointermin < pointermid) {
              if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
                pointermin = pointermid;
                pointerstart = pointermin;
              } else {
                pointermax = pointermid;
              }
              pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
            }
            return pointermid;
          }
          function diff_commonSuffix(text1, text2) {
            if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
              return 0;
            }
            var pointermin = 0;
            var pointermax = Math.min(text1.length, text2.length);
            var pointermid = pointermax;
            var pointerend = 0;
            while (pointermin < pointermid) {
              if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
                pointermin = pointermid;
                pointerend = pointermin;
              } else {
                pointermax = pointermid;
              }
              pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
            }
            return pointermid;
          }
          function diff_halfMatch_(text1, text2) {
            var longtext = text1.length > text2.length ? text1 : text2;
            var shorttext = text1.length > text2.length ? text2 : text1;
            if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
              return null;
            }
            function diff_halfMatchI_(longtext2, shorttext2, i2) {
              var seed = longtext2.substring(i2, i2 + Math.floor(longtext2.length / 4));
              var j = -1;
              var best_common = "";
              var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
              while ((j = shorttext2.indexOf(seed, j + 1)) != -1) {
                var prefixLength = diff_commonPrefix(
                  longtext2.substring(i2),
                  shorttext2.substring(j)
                );
                var suffixLength = diff_commonSuffix(
                  longtext2.substring(0, i2),
                  shorttext2.substring(0, j)
                );
                if (best_common.length < suffixLength + prefixLength) {
                  best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
                  best_longtext_a = longtext2.substring(0, i2 - suffixLength);
                  best_longtext_b = longtext2.substring(i2 + prefixLength);
                  best_shorttext_a = shorttext2.substring(0, j - suffixLength);
                  best_shorttext_b = shorttext2.substring(j + prefixLength);
                }
              }
              if (best_common.length * 2 >= longtext2.length) {
                return [
                  best_longtext_a,
                  best_longtext_b,
                  best_shorttext_a,
                  best_shorttext_b,
                  best_common
                ];
              } else {
                return null;
              }
            }
            var hm1 = diff_halfMatchI_(
              longtext,
              shorttext,
              Math.ceil(longtext.length / 4)
            );
            var hm2 = diff_halfMatchI_(
              longtext,
              shorttext,
              Math.ceil(longtext.length / 2)
            );
            var hm;
            if (!hm1 && !hm2) {
              return null;
            } else if (!hm2) {
              hm = hm1;
            } else if (!hm1) {
              hm = hm2;
            } else {
              hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
            }
            var text1_a, text1_b, text2_a, text2_b;
            if (text1.length > text2.length) {
              text1_a = hm[0];
              text1_b = hm[1];
              text2_a = hm[2];
              text2_b = hm[3];
            } else {
              text2_a = hm[0];
              text2_b = hm[1];
              text1_a = hm[2];
              text1_b = hm[3];
            }
            var mid_common = hm[4];
            return [text1_a, text1_b, text2_a, text2_b, mid_common];
          }
          function diff_cleanupMerge(diffs) {
            diffs.push([DIFF_EQUAL, ""]);
            var pointer = 0;
            var count_delete = 0;
            var count_insert = 0;
            var text_delete = "";
            var text_insert = "";
            var commonlength;
            while (pointer < diffs.length) {
              switch (diffs[pointer][0]) {
                case DIFF_INSERT:
                  count_insert++;
                  text_insert += diffs[pointer][1];
                  pointer++;
                  break;
                case DIFF_DELETE:
                  count_delete++;
                  text_delete += diffs[pointer][1];
                  pointer++;
                  break;
                case DIFF_EQUAL:
                  if (count_delete + count_insert > 1) {
                    if (count_delete !== 0 && count_insert !== 0) {
                      commonlength = diff_commonPrefix(text_insert, text_delete);
                      if (commonlength !== 0) {
                        if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {
                          diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
                        } else {
                          diffs.splice(0, 0, [
                            DIFF_EQUAL,
                            text_insert.substring(0, commonlength)
                          ]);
                          pointer++;
                        }
                        text_insert = text_insert.substring(commonlength);
                        text_delete = text_delete.substring(commonlength);
                      }
                      commonlength = diff_commonSuffix(text_insert, text_delete);
                      if (commonlength !== 0) {
                        diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                        text_insert = text_insert.substring(0, text_insert.length - commonlength);
                        text_delete = text_delete.substring(0, text_delete.length - commonlength);
                      }
                    }
                    if (count_delete === 0) {
                      diffs.splice(
                        pointer - count_insert,
                        count_delete + count_insert,
                        [DIFF_INSERT, text_insert]
                      );
                    } else if (count_insert === 0) {
                      diffs.splice(
                        pointer - count_delete,
                        count_delete + count_insert,
                        [DIFF_DELETE, text_delete]
                      );
                    } else {
                      diffs.splice(
                        pointer - count_delete - count_insert,
                        count_delete + count_insert,
                        [DIFF_DELETE, text_delete],
                        [DIFF_INSERT, text_insert]
                      );
                    }
                    pointer = pointer - count_delete - count_insert + (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
                  } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
                    diffs[pointer - 1][1] += diffs[pointer][1];
                    diffs.splice(pointer, 1);
                  } else {
                    pointer++;
                  }
                  count_insert = 0;
                  count_delete = 0;
                  text_delete = "";
                  text_insert = "";
                  break;
              }
            }
            if (diffs[diffs.length - 1][1] === "") {
              diffs.pop();
            }
            var changes = false;
            pointer = 1;
            while (pointer < diffs.length - 1) {
              if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
                if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
                  diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
                  diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
                  diffs.splice(pointer - 1, 1);
                  changes = true;
                } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
                  diffs[pointer - 1][1] += diffs[pointer + 1][1];
                  diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
                  diffs.splice(pointer + 1, 1);
                  changes = true;
                }
              }
              pointer++;
            }
            if (changes) {
              diff_cleanupMerge(diffs);
            }
          }
          var diff2 = diff_main;
          diff2.INSERT = DIFF_INSERT;
          diff2.DELETE = DIFF_DELETE;
          diff2.EQUAL = DIFF_EQUAL;
          module3.exports = diff2;
          function cursor_normalize_diff(diffs, cursor_pos) {
            if (cursor_pos === 0) {
              return [DIFF_EQUAL, diffs];
            }
            for (var current_pos = 0, i2 = 0; i2 < diffs.length; i2++) {
              var d2 = diffs[i2];
              if (d2[0] === DIFF_DELETE || d2[0] === DIFF_EQUAL) {
                var next_pos = current_pos + d2[1].length;
                if (cursor_pos === next_pos) {
                  return [i2 + 1, diffs];
                } else if (cursor_pos < next_pos) {
                  diffs = diffs.slice();
                  var split_pos = cursor_pos - current_pos;
                  var d_left = [d2[0], d2[1].slice(0, split_pos)];
                  var d_right = [d2[0], d2[1].slice(split_pos)];
                  diffs.splice(i2, 1, d_left, d_right);
                  return [i2 + 1, diffs];
                } else {
                  current_pos = next_pos;
                }
              }
            }
            throw new Error("cursor_pos is out of bounds!");
          }
          function fix_cursor(diffs, cursor_pos) {
            var norm = cursor_normalize_diff(diffs, cursor_pos);
            var ndiffs = norm[1];
            var cursor_pointer = norm[0];
            var d2 = ndiffs[cursor_pointer];
            var d_next = ndiffs[cursor_pointer + 1];
            if (d2 == null) {
              return diffs;
            } else if (d2[0] !== DIFF_EQUAL) {
              return diffs;
            } else {
              if (d_next != null && d2[1] + d_next[1] === d_next[1] + d2[1]) {
                ndiffs.splice(cursor_pointer, 2, d_next, d2);
                return merge_tuples(ndiffs, cursor_pointer, 2);
              } else if (d_next != null && d_next[1].indexOf(d2[1]) === 0) {
                ndiffs.splice(cursor_pointer, 2, [d_next[0], d2[1]], [0, d2[1]]);
                var suffix = d_next[1].slice(d2[1].length);
                if (suffix.length > 0) {
                  ndiffs.splice(cursor_pointer + 2, 0, [d_next[0], suffix]);
                }
                return merge_tuples(ndiffs, cursor_pointer, 3);
              } else {
                return diffs;
              }
            }
          }
          function fix_emoji(diffs) {
            var compact = false;
            var starts_with_pair_end = function(str) {
              return str.charCodeAt(0) >= 56320 && str.charCodeAt(0) <= 57343;
            };
            var ends_with_pair_start = function(str) {
              return str.charCodeAt(str.length - 1) >= 55296 && str.charCodeAt(str.length - 1) <= 56319;
            };
            for (var i2 = 2; i2 < diffs.length; i2 += 1) {
              if (diffs[i2 - 2][0] === DIFF_EQUAL && ends_with_pair_start(diffs[i2 - 2][1]) && diffs[i2 - 1][0] === DIFF_DELETE && starts_with_pair_end(diffs[i2 - 1][1]) && diffs[i2][0] === DIFF_INSERT && starts_with_pair_end(diffs[i2][1])) {
                compact = true;
                diffs[i2 - 1][1] = diffs[i2 - 2][1].slice(-1) + diffs[i2 - 1][1];
                diffs[i2][1] = diffs[i2 - 2][1].slice(-1) + diffs[i2][1];
                diffs[i2 - 2][1] = diffs[i2 - 2][1].slice(0, -1);
              }
            }
            if (!compact) {
              return diffs;
            }
            var fixed_diffs = [];
            for (var i2 = 0; i2 < diffs.length; i2 += 1) {
              if (diffs[i2][1].length > 0) {
                fixed_diffs.push(diffs[i2]);
              }
            }
            return fixed_diffs;
          }
          function merge_tuples(diffs, start2, length) {
            for (var i2 = start2 + length - 1; i2 >= 0 && i2 >= start2 - 1; i2--) {
              if (i2 + 1 < diffs.length) {
                var left_d = diffs[i2];
                var right_d = diffs[i2 + 1];
                if (left_d[0] === right_d[1]) {
                  diffs.splice(i2, 2, [left_d[0], left_d[1] + right_d[1]]);
                }
              }
            }
            return diffs;
          }
        },
        /* 52 */
        /***/
        function(module3, exports3) {
          exports3 = module3.exports = typeof Object.keys === "function" ? Object.keys : shim;
          exports3.shim = shim;
          function shim(obj) {
            var keys2 = [];
            for (var key in obj)
              keys2.push(key);
            return keys2;
          }
        },
        /* 53 */
        /***/
        function(module3, exports3) {
          var supportsArgumentsClass = function() {
            return Object.prototype.toString.call(arguments);
          }() == "[object Arguments]";
          exports3 = module3.exports = supportsArgumentsClass ? supported : unsupported;
          exports3.supported = supported;
          function supported(object) {
            return Object.prototype.toString.call(object) == "[object Arguments]";
          }
          exports3.unsupported = unsupported;
          function unsupported(object) {
            return object && typeof object == "object" && typeof object.length == "number" && Object.prototype.hasOwnProperty.call(object, "callee") && !Object.prototype.propertyIsEnumerable.call(object, "callee") || false;
          }
        },
        /* 54 */
        /***/
        function(module3, exports3) {
          var has = Object.prototype.hasOwnProperty, prefix = "~";
          function Events() {
          }
          if (Object.create) {
            Events.prototype = /* @__PURE__ */ Object.create(null);
            if (!new Events().__proto__)
              prefix = false;
          }
          function EE(fn, context2, once) {
            this.fn = fn;
            this.context = context2;
            this.once = once || false;
          }
          function EventEmitter() {
            this._events = new Events();
            this._eventsCount = 0;
          }
          EventEmitter.prototype.eventNames = function eventNames() {
            var names2 = [], events, name;
            if (this._eventsCount === 0)
              return names2;
            for (name in events = this._events) {
              if (has.call(events, name))
                names2.push(prefix ? name.slice(1) : name);
            }
            if (Object.getOwnPropertySymbols) {
              return names2.concat(Object.getOwnPropertySymbols(events));
            }
            return names2;
          };
          EventEmitter.prototype.listeners = function listeners(event, exists) {
            var evt = prefix ? prefix + event : event, available = this._events[evt];
            if (exists)
              return !!available;
            if (!available)
              return [];
            if (available.fn)
              return [available.fn];
            for (var i2 = 0, l2 = available.length, ee = new Array(l2); i2 < l2; i2++) {
              ee[i2] = available[i2].fn;
            }
            return ee;
          };
          EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
            var evt = prefix ? prefix + event : event;
            if (!this._events[evt])
              return false;
            var listeners = this._events[evt], len = arguments.length, args, i2;
            if (listeners.fn) {
              if (listeners.once)
                this.removeListener(event, listeners.fn, void 0, true);
              switch (len) {
                case 1:
                  return listeners.fn.call(listeners.context), true;
                case 2:
                  return listeners.fn.call(listeners.context, a1), true;
                case 3:
                  return listeners.fn.call(listeners.context, a1, a2), true;
                case 4:
                  return listeners.fn.call(listeners.context, a1, a2, a3), true;
                case 5:
                  return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
                case 6:
                  return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
              }
              for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
                args[i2 - 1] = arguments[i2];
              }
              listeners.fn.apply(listeners.context, args);
            } else {
              var length = listeners.length, j;
              for (i2 = 0; i2 < length; i2++) {
                if (listeners[i2].once)
                  this.removeListener(event, listeners[i2].fn, void 0, true);
                switch (len) {
                  case 1:
                    listeners[i2].fn.call(listeners[i2].context);
                    break;
                  case 2:
                    listeners[i2].fn.call(listeners[i2].context, a1);
                    break;
                  case 3:
                    listeners[i2].fn.call(listeners[i2].context, a1, a2);
                    break;
                  case 4:
                    listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
                    break;
                  default:
                    if (!args)
                      for (j = 1, args = new Array(len - 1); j < len; j++) {
                        args[j - 1] = arguments[j];
                      }
                    listeners[i2].fn.apply(listeners[i2].context, args);
                }
              }
            }
            return true;
          };
          EventEmitter.prototype.on = function on(event, fn, context2) {
            var listener = new EE(fn, context2 || this), evt = prefix ? prefix + event : event;
            if (!this._events[evt])
              this._events[evt] = listener, this._eventsCount++;
            else if (!this._events[evt].fn)
              this._events[evt].push(listener);
            else
              this._events[evt] = [this._events[evt], listener];
            return this;
          };
          EventEmitter.prototype.once = function once(event, fn, context2) {
            var listener = new EE(fn, context2 || this, true), evt = prefix ? prefix + event : event;
            if (!this._events[evt])
              this._events[evt] = listener, this._eventsCount++;
            else if (!this._events[evt].fn)
              this._events[evt].push(listener);
            else
              this._events[evt] = [this._events[evt], listener];
            return this;
          };
          EventEmitter.prototype.removeListener = function removeListener(event, fn, context2, once) {
            var evt = prefix ? prefix + event : event;
            if (!this._events[evt])
              return this;
            if (!fn) {
              if (--this._eventsCount === 0)
                this._events = new Events();
              else
                delete this._events[evt];
              return this;
            }
            var listeners = this._events[evt];
            if (listeners.fn) {
              if (listeners.fn === fn && (!once || listeners.once) && (!context2 || listeners.context === context2)) {
                if (--this._eventsCount === 0)
                  this._events = new Events();
                else
                  delete this._events[evt];
              }
            } else {
              for (var i2 = 0, events = [], length = listeners.length; i2 < length; i2++) {
                if (listeners[i2].fn !== fn || once && !listeners[i2].once || context2 && listeners[i2].context !== context2) {
                  events.push(listeners[i2]);
                }
              }
              if (events.length)
                this._events[evt] = events.length === 1 ? events[0] : events;
              else if (--this._eventsCount === 0)
                this._events = new Events();
              else
                delete this._events[evt];
            }
            return this;
          };
          EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
            var evt;
            if (event) {
              evt = prefix ? prefix + event : event;
              if (this._events[evt]) {
                if (--this._eventsCount === 0)
                  this._events = new Events();
                else
                  delete this._events[evt];
              }
            } else {
              this._events = new Events();
              this._eventsCount = 0;
            }
            return this;
          };
          EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
          EventEmitter.prototype.addListener = EventEmitter.prototype.on;
          EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
            return this;
          };
          EventEmitter.prefixed = prefix;
          EventEmitter.EventEmitter = EventEmitter;
          if ("undefined" !== typeof module3) {
            module3.exports = EventEmitter;
          }
        },
        /* 55 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.matchText = exports3.matchSpacing = exports3.matchNewline = exports3.matchBlot = exports3.matchAttributor = exports3.default = void 0;
          var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
            return typeof obj;
          } : function(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
          var _slicedToArray2 = function() {
            function sliceIterator(arr, i2) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i2 && _arr.length === i2)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"])
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            return function(arr, i2) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i2);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _extend2 = __webpack_require__(3);
          var _extend3 = _interopRequireDefault2(_extend2);
          var _quillDelta = __webpack_require__(2);
          var _quillDelta2 = _interopRequireDefault2(_quillDelta);
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _quill = __webpack_require__(5);
          var _quill2 = _interopRequireDefault2(_quill);
          var _logger = __webpack_require__(10);
          var _logger2 = _interopRequireDefault2(_logger);
          var _module = __webpack_require__(9);
          var _module2 = _interopRequireDefault2(_module);
          var _align = __webpack_require__(36);
          var _background = __webpack_require__(37);
          var _code = __webpack_require__(13);
          var _code2 = _interopRequireDefault2(_code);
          var _color = __webpack_require__(26);
          var _direction = __webpack_require__(38);
          var _font = __webpack_require__(39);
          var _size = __webpack_require__(40);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _defineProperty2(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var debug = (0, _logger2.default)("quill:clipboard");
          var DOM_KEY = "__ql-matcher";
          var CLIPBOARD_CONFIG = [[Node.TEXT_NODE, matchText], [Node.TEXT_NODE, matchNewline], ["br", matchBreak], [Node.ELEMENT_NODE, matchNewline], [Node.ELEMENT_NODE, matchBlot], [Node.ELEMENT_NODE, matchSpacing], [Node.ELEMENT_NODE, matchAttributor], [Node.ELEMENT_NODE, matchStyles], ["li", matchIndent], ["b", matchAlias.bind(matchAlias, "bold")], ["i", matchAlias.bind(matchAlias, "italic")], ["style", matchIgnore]];
          var ATTRIBUTE_ATTRIBUTORS = [_align.AlignAttribute, _direction.DirectionAttribute].reduce(function(memo, attr) {
            memo[attr.keyName] = attr;
            return memo;
          }, {});
          var STYLE_ATTRIBUTORS = [_align.AlignStyle, _background.BackgroundStyle, _color.ColorStyle, _direction.DirectionStyle, _font.FontStyle, _size.SizeStyle].reduce(function(memo, attr) {
            memo[attr.keyName] = attr;
            return memo;
          }, {});
          var Clipboard = function(_Module) {
            _inherits2(Clipboard2, _Module);
            function Clipboard2(quill2, options) {
              _classCallCheck2(this, Clipboard2);
              var _this = _possibleConstructorReturn2(this, (Clipboard2.__proto__ || Object.getPrototypeOf(Clipboard2)).call(this, quill2, options));
              _this.quill.root.addEventListener("paste", _this.onPaste.bind(_this));
              _this.container = _this.quill.addContainer("ql-clipboard");
              _this.container.setAttribute("contenteditable", true);
              _this.container.setAttribute("tabindex", -1);
              _this.matchers = [];
              CLIPBOARD_CONFIG.concat(_this.options.matchers).forEach(function(_ref) {
                var _ref2 = _slicedToArray2(_ref, 2), selector = _ref2[0], matcher = _ref2[1];
                if (!options.matchVisual && matcher === matchSpacing)
                  return;
                _this.addMatcher(selector, matcher);
              });
              return _this;
            }
            _createClass2(Clipboard2, [{
              key: "addMatcher",
              value: function addMatcher(selector, matcher) {
                this.matchers.push([selector, matcher]);
              }
            }, {
              key: "convert",
              value: function convert(html) {
                if (typeof html === "string") {
                  this.container.innerHTML = html.replace(/\>\r?\n +\</g, "><");
                  return this.convert();
                }
                var formats = this.quill.getFormat(this.quill.selection.savedRange.index);
                if (formats[_code2.default.blotName]) {
                  var text = this.container.innerText;
                  this.container.innerHTML = "";
                  return new _quillDelta2.default().insert(text, _defineProperty2({}, _code2.default.blotName, formats[_code2.default.blotName]));
                }
                var _prepareMatching = this.prepareMatching(), _prepareMatching2 = _slicedToArray2(_prepareMatching, 2), elementMatchers = _prepareMatching2[0], textMatchers = _prepareMatching2[1];
                var delta = traverse(this.container, elementMatchers, textMatchers);
                if (deltaEndsWith(delta, "\n") && delta.ops[delta.ops.length - 1].attributes == null) {
                  delta = delta.compose(new _quillDelta2.default().retain(delta.length() - 1).delete(1));
                }
                debug.log("convert", this.container.innerHTML, delta);
                this.container.innerHTML = "";
                return delta;
              }
            }, {
              key: "dangerouslyPasteHTML",
              value: function dangerouslyPasteHTML(index2, html) {
                var source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _quill2.default.sources.API;
                if (typeof index2 === "string") {
                  this.quill.setContents(this.convert(index2), html);
                  this.quill.setSelection(0, _quill2.default.sources.SILENT);
                } else {
                  var paste = this.convert(html);
                  this.quill.updateContents(new _quillDelta2.default().retain(index2).concat(paste), source);
                  this.quill.setSelection(index2 + paste.length(), _quill2.default.sources.SILENT);
                }
              }
            }, {
              key: "onPaste",
              value: function onPaste(e2) {
                var _this2 = this;
                if (e2.defaultPrevented || !this.quill.isEnabled())
                  return;
                var range2 = this.quill.getSelection();
                var delta = new _quillDelta2.default().retain(range2.index);
                var scrollTop = this.quill.scrollingContainer.scrollTop;
                this.container.focus();
                this.quill.selection.update(_quill2.default.sources.SILENT);
                setTimeout(function() {
                  delta = delta.concat(_this2.convert()).delete(range2.length);
                  _this2.quill.updateContents(delta, _quill2.default.sources.USER);
                  _this2.quill.setSelection(delta.length() - range2.length, _quill2.default.sources.SILENT);
                  _this2.quill.scrollingContainer.scrollTop = scrollTop;
                  _this2.quill.focus();
                }, 1);
              }
            }, {
              key: "prepareMatching",
              value: function prepareMatching() {
                var _this3 = this;
                var elementMatchers = [], textMatchers = [];
                this.matchers.forEach(function(pair) {
                  var _pair = _slicedToArray2(pair, 2), selector = _pair[0], matcher = _pair[1];
                  switch (selector) {
                    case Node.TEXT_NODE:
                      textMatchers.push(matcher);
                      break;
                    case Node.ELEMENT_NODE:
                      elementMatchers.push(matcher);
                      break;
                    default:
                      [].forEach.call(_this3.container.querySelectorAll(selector), function(node) {
                        node[DOM_KEY] = node[DOM_KEY] || [];
                        node[DOM_KEY].push(matcher);
                      });
                      break;
                  }
                });
                return [elementMatchers, textMatchers];
              }
            }]);
            return Clipboard2;
          }(_module2.default);
          Clipboard.DEFAULTS = {
            matchers: [],
            matchVisual: true
          };
          function applyFormat(delta, format2, value) {
            if ((typeof format2 === "undefined" ? "undefined" : _typeof2(format2)) === "object") {
              return Object.keys(format2).reduce(function(delta2, key) {
                return applyFormat(delta2, key, format2[key]);
              }, delta);
            } else {
              return delta.reduce(function(delta2, op) {
                if (op.attributes && op.attributes[format2]) {
                  return delta2.push(op);
                } else {
                  return delta2.insert(op.insert, (0, _extend3.default)({}, _defineProperty2({}, format2, value), op.attributes));
                }
              }, new _quillDelta2.default());
            }
          }
          function computeStyle(node) {
            if (node.nodeType !== Node.ELEMENT_NODE)
              return {};
            var DOM_KEY2 = "__ql-computed-style";
            return node[DOM_KEY2] || (node[DOM_KEY2] = window.getComputedStyle(node));
          }
          function deltaEndsWith(delta, text) {
            var endText = "";
            for (var i2 = delta.ops.length - 1; i2 >= 0 && endText.length < text.length; --i2) {
              var op = delta.ops[i2];
              if (typeof op.insert !== "string")
                break;
              endText = op.insert + endText;
            }
            return endText.slice(-1 * text.length) === text;
          }
          function isLine(node) {
            if (node.childNodes.length === 0)
              return false;
            var style = computeStyle(node);
            return ["block", "list-item"].indexOf(style.display) > -1;
          }
          function traverse(node, elementMatchers, textMatchers) {
            if (node.nodeType === node.TEXT_NODE) {
              return textMatchers.reduce(function(delta, matcher) {
                return matcher(node, delta);
              }, new _quillDelta2.default());
            } else if (node.nodeType === node.ELEMENT_NODE) {
              return [].reduce.call(node.childNodes || [], function(delta, childNode) {
                var childrenDelta = traverse(childNode, elementMatchers, textMatchers);
                if (childNode.nodeType === node.ELEMENT_NODE) {
                  childrenDelta = elementMatchers.reduce(function(childrenDelta2, matcher) {
                    return matcher(childNode, childrenDelta2);
                  }, childrenDelta);
                  childrenDelta = (childNode[DOM_KEY] || []).reduce(function(childrenDelta2, matcher) {
                    return matcher(childNode, childrenDelta2);
                  }, childrenDelta);
                }
                return delta.concat(childrenDelta);
              }, new _quillDelta2.default());
            } else {
              return new _quillDelta2.default();
            }
          }
          function matchAlias(format2, node, delta) {
            return applyFormat(delta, format2, true);
          }
          function matchAttributor(node, delta) {
            var attributes = _parchment2.default.Attributor.Attribute.keys(node);
            var classes = _parchment2.default.Attributor.Class.keys(node);
            var styles2 = _parchment2.default.Attributor.Style.keys(node);
            var formats = {};
            attributes.concat(classes).concat(styles2).forEach(function(name) {
              var attr = _parchment2.default.query(name, _parchment2.default.Scope.ATTRIBUTE);
              if (attr != null) {
                formats[attr.attrName] = attr.value(node);
                if (formats[attr.attrName])
                  return;
              }
              attr = ATTRIBUTE_ATTRIBUTORS[name];
              if (attr != null && (attr.attrName === name || attr.keyName === name)) {
                formats[attr.attrName] = attr.value(node) || void 0;
              }
              attr = STYLE_ATTRIBUTORS[name];
              if (attr != null && (attr.attrName === name || attr.keyName === name)) {
                attr = STYLE_ATTRIBUTORS[name];
                formats[attr.attrName] = attr.value(node) || void 0;
              }
            });
            if (Object.keys(formats).length > 0) {
              delta = applyFormat(delta, formats);
            }
            return delta;
          }
          function matchBlot(node, delta) {
            var match5 = _parchment2.default.query(node);
            if (match5 == null)
              return delta;
            if (match5.prototype instanceof _parchment2.default.Embed) {
              var embed = {};
              var value = match5.value(node);
              if (value != null) {
                embed[match5.blotName] = value;
                delta = new _quillDelta2.default().insert(embed, match5.formats(node));
              }
            } else if (typeof match5.formats === "function") {
              delta = applyFormat(delta, match5.blotName, match5.formats(node));
            }
            return delta;
          }
          function matchBreak(node, delta) {
            if (!deltaEndsWith(delta, "\n")) {
              delta.insert("\n");
            }
            return delta;
          }
          function matchIgnore() {
            return new _quillDelta2.default();
          }
          function matchIndent(node, delta) {
            var match5 = _parchment2.default.query(node);
            if (match5 == null || match5.blotName !== "list-item" || !deltaEndsWith(delta, "\n")) {
              return delta;
            }
            var indent = -1, parent2 = node.parentNode;
            while (!parent2.classList.contains("ql-clipboard")) {
              if ((_parchment2.default.query(parent2) || {}).blotName === "list") {
                indent += 1;
              }
              parent2 = parent2.parentNode;
            }
            if (indent <= 0)
              return delta;
            return delta.compose(new _quillDelta2.default().retain(delta.length() - 1).retain(1, { indent }));
          }
          function matchNewline(node, delta) {
            if (!deltaEndsWith(delta, "\n")) {
              if (isLine(node) || delta.length() > 0 && node.nextSibling && isLine(node.nextSibling)) {
                delta.insert("\n");
              }
            }
            return delta;
          }
          function matchSpacing(node, delta) {
            if (isLine(node) && node.nextElementSibling != null && !deltaEndsWith(delta, "\n\n")) {
              var nodeHeight = node.offsetHeight + parseFloat(computeStyle(node).marginTop) + parseFloat(computeStyle(node).marginBottom);
              if (node.nextElementSibling.offsetTop > node.offsetTop + nodeHeight * 1.5) {
                delta.insert("\n");
              }
            }
            return delta;
          }
          function matchStyles(node, delta) {
            var formats = {};
            var style = node.style || {};
            if (style.fontStyle && computeStyle(node).fontStyle === "italic") {
              formats.italic = true;
            }
            if (style.fontWeight && (computeStyle(node).fontWeight.startsWith("bold") || parseInt(computeStyle(node).fontWeight) >= 700)) {
              formats.bold = true;
            }
            if (Object.keys(formats).length > 0) {
              delta = applyFormat(delta, formats);
            }
            if (parseFloat(style.textIndent || 0) > 0) {
              delta = new _quillDelta2.default().insert("	").concat(delta);
            }
            return delta;
          }
          function matchText(node, delta) {
            var text = node.data;
            if (node.parentNode.tagName === "O:P") {
              return delta.insert(text.trim());
            }
            if (text.trim().length === 0 && node.parentNode.classList.contains("ql-clipboard")) {
              return delta;
            }
            if (!computeStyle(node.parentNode).whiteSpace.startsWith("pre")) {
              var replacer = function replacer2(collapse, match5) {
                match5 = match5.replace(/[^\u00a0]/g, "");
                return match5.length < 1 && collapse ? " " : match5;
              };
              text = text.replace(/\r\n/g, " ").replace(/\n/g, " ");
              text = text.replace(/\s\s+/g, replacer.bind(replacer, true));
              if (node.previousSibling == null && isLine(node.parentNode) || node.previousSibling != null && isLine(node.previousSibling)) {
                text = text.replace(/^\s+/, replacer.bind(replacer, false));
              }
              if (node.nextSibling == null && isLine(node.parentNode) || node.nextSibling != null && isLine(node.nextSibling)) {
                text = text.replace(/\s+$/, replacer.bind(replacer, false));
              }
            }
            return delta.insert(text);
          }
          exports3.default = Clipboard;
          exports3.matchAttributor = matchAttributor;
          exports3.matchBlot = matchBlot;
          exports3.matchNewline = matchNewline;
          exports3.matchSpacing = matchSpacing;
          exports3.matchText = matchText;
        },
        /* 56 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get4(object, property2, receiver) {
            if (object === null)
              object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get4(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _inline = __webpack_require__(6);
          var _inline2 = _interopRequireDefault2(_inline);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var Bold = function(_Inline) {
            _inherits2(Bold2, _Inline);
            function Bold2() {
              _classCallCheck2(this, Bold2);
              return _possibleConstructorReturn2(this, (Bold2.__proto__ || Object.getPrototypeOf(Bold2)).apply(this, arguments));
            }
            _createClass2(Bold2, [{
              key: "optimize",
              value: function optimize(context2) {
                _get2(Bold2.prototype.__proto__ || Object.getPrototypeOf(Bold2.prototype), "optimize", this).call(this, context2);
                if (this.domNode.tagName !== this.statics.tagName[0]) {
                  this.replaceWith(this.statics.blotName);
                }
              }
            }], [{
              key: "create",
              value: function create() {
                return _get2(Bold2.__proto__ || Object.getPrototypeOf(Bold2), "create", this).call(this);
              }
            }, {
              key: "formats",
              value: function formats() {
                return true;
              }
            }]);
            return Bold2;
          }(_inline2.default);
          Bold.blotName = "bold";
          Bold.tagName = ["STRONG", "B"];
          exports3.default = Bold;
        },
        /* 57 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.addControls = exports3.default = void 0;
          var _slicedToArray2 = function() {
            function sliceIterator(arr, i2) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i2 && _arr.length === i2)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"])
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            return function(arr, i2) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i2);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _quillDelta = __webpack_require__(2);
          var _quillDelta2 = _interopRequireDefault2(_quillDelta);
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _quill = __webpack_require__(5);
          var _quill2 = _interopRequireDefault2(_quill);
          var _logger = __webpack_require__(10);
          var _logger2 = _interopRequireDefault2(_logger);
          var _module = __webpack_require__(9);
          var _module2 = _interopRequireDefault2(_module);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _defineProperty2(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var debug = (0, _logger2.default)("quill:toolbar");
          var Toolbar = function(_Module) {
            _inherits2(Toolbar2, _Module);
            function Toolbar2(quill2, options) {
              _classCallCheck2(this, Toolbar2);
              var _this = _possibleConstructorReturn2(this, (Toolbar2.__proto__ || Object.getPrototypeOf(Toolbar2)).call(this, quill2, options));
              if (Array.isArray(_this.options.container)) {
                var container2 = document.createElement("div");
                addControls(container2, _this.options.container);
                quill2.container.parentNode.insertBefore(container2, quill2.container);
                _this.container = container2;
              } else if (typeof _this.options.container === "string") {
                _this.container = document.querySelector(_this.options.container);
              } else {
                _this.container = _this.options.container;
              }
              if (!(_this.container instanceof HTMLElement)) {
                var _ret;
                return _ret = debug.error("Container required for toolbar", _this.options), _possibleConstructorReturn2(_this, _ret);
              }
              _this.container.classList.add("ql-toolbar");
              _this.controls = [];
              _this.handlers = {};
              Object.keys(_this.options.handlers).forEach(function(format2) {
                _this.addHandler(format2, _this.options.handlers[format2]);
              });
              [].forEach.call(_this.container.querySelectorAll("button, select"), function(input2) {
                _this.attach(input2);
              });
              _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function(type2, range2) {
                if (type2 === _quill2.default.events.SELECTION_CHANGE) {
                  _this.update(range2);
                }
              });
              _this.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function() {
                var _this$quill$selection = _this.quill.selection.getRange(), _this$quill$selection2 = _slicedToArray2(_this$quill$selection, 1), range2 = _this$quill$selection2[0];
                _this.update(range2);
              });
              return _this;
            }
            _createClass2(Toolbar2, [{
              key: "addHandler",
              value: function addHandler(format2, handler) {
                this.handlers[format2] = handler;
              }
            }, {
              key: "attach",
              value: function attach(input2) {
                var _this2 = this;
                var format2 = [].find.call(input2.classList, function(className) {
                  return className.indexOf("ql-") === 0;
                });
                if (!format2)
                  return;
                format2 = format2.slice("ql-".length);
                if (input2.tagName === "BUTTON") {
                  input2.setAttribute("type", "button");
                }
                if (this.handlers[format2] == null) {
                  if (this.quill.scroll.whitelist != null && this.quill.scroll.whitelist[format2] == null) {
                    debug.warn("ignoring attaching to disabled format", format2, input2);
                    return;
                  }
                  if (_parchment2.default.query(format2) == null) {
                    debug.warn("ignoring attaching to nonexistent format", format2, input2);
                    return;
                  }
                }
                var eventName = input2.tagName === "SELECT" ? "change" : "click";
                input2.addEventListener(eventName, function(e2) {
                  var value = void 0;
                  if (input2.tagName === "SELECT") {
                    if (input2.selectedIndex < 0)
                      return;
                    var selected = input2.options[input2.selectedIndex];
                    if (selected.hasAttribute("selected")) {
                      value = false;
                    } else {
                      value = selected.value || false;
                    }
                  } else {
                    if (input2.classList.contains("ql-active")) {
                      value = false;
                    } else {
                      value = input2.value || !input2.hasAttribute("value");
                    }
                    e2.preventDefault();
                  }
                  _this2.quill.focus();
                  var _quill$selection$getR = _this2.quill.selection.getRange(), _quill$selection$getR2 = _slicedToArray2(_quill$selection$getR, 1), range2 = _quill$selection$getR2[0];
                  if (_this2.handlers[format2] != null) {
                    _this2.handlers[format2].call(_this2, value);
                  } else if (_parchment2.default.query(format2).prototype instanceof _parchment2.default.Embed) {
                    value = prompt("Enter " + format2);
                    if (!value)
                      return;
                    _this2.quill.updateContents(new _quillDelta2.default().retain(range2.index).delete(range2.length).insert(_defineProperty2({}, format2, value)), _quill2.default.sources.USER);
                  } else {
                    _this2.quill.format(format2, value, _quill2.default.sources.USER);
                  }
                  _this2.update(range2);
                });
                this.controls.push([format2, input2]);
              }
            }, {
              key: "update",
              value: function update2(range2) {
                var formats = range2 == null ? {} : this.quill.getFormat(range2);
                this.controls.forEach(function(pair) {
                  var _pair = _slicedToArray2(pair, 2), format2 = _pair[0], input2 = _pair[1];
                  if (input2.tagName === "SELECT") {
                    var option = void 0;
                    if (range2 == null) {
                      option = null;
                    } else if (formats[format2] == null) {
                      option = input2.querySelector("option[selected]");
                    } else if (!Array.isArray(formats[format2])) {
                      var value = formats[format2];
                      if (typeof value === "string") {
                        value = value.replace(/\"/g, '\\"');
                      }
                      option = input2.querySelector('option[value="' + value + '"]');
                    }
                    if (option == null) {
                      input2.value = "";
                      input2.selectedIndex = -1;
                    } else {
                      option.selected = true;
                    }
                  } else {
                    if (range2 == null) {
                      input2.classList.remove("ql-active");
                    } else if (input2.hasAttribute("value")) {
                      var isActive = formats[format2] === input2.getAttribute("value") || formats[format2] != null && formats[format2].toString() === input2.getAttribute("value") || formats[format2] == null && !input2.getAttribute("value");
                      input2.classList.toggle("ql-active", isActive);
                    } else {
                      input2.classList.toggle("ql-active", formats[format2] != null);
                    }
                  }
                });
              }
            }]);
            return Toolbar2;
          }(_module2.default);
          Toolbar.DEFAULTS = {};
          function addButton(container2, format2, value) {
            var input2 = document.createElement("button");
            input2.setAttribute("type", "button");
            input2.classList.add("ql-" + format2);
            if (value != null) {
              input2.value = value;
            }
            container2.appendChild(input2);
          }
          function addControls(container2, groups) {
            if (!Array.isArray(groups[0])) {
              groups = [groups];
            }
            groups.forEach(function(controls) {
              var group3 = document.createElement("span");
              group3.classList.add("ql-formats");
              controls.forEach(function(control) {
                if (typeof control === "string") {
                  addButton(group3, control);
                } else {
                  var format2 = Object.keys(control)[0];
                  var value = control[format2];
                  if (Array.isArray(value)) {
                    addSelect(group3, format2, value);
                  } else {
                    addButton(group3, format2, value);
                  }
                }
              });
              container2.appendChild(group3);
            });
          }
          function addSelect(container2, format2, values) {
            var input2 = document.createElement("select");
            input2.classList.add("ql-" + format2);
            values.forEach(function(value) {
              var option = document.createElement("option");
              if (value !== false) {
                option.setAttribute("value", value);
              } else {
                option.setAttribute("selected", "selected");
              }
              input2.appendChild(option);
            });
            container2.appendChild(input2);
          }
          Toolbar.DEFAULTS = {
            container: null,
            handlers: {
              clean: function clean() {
                var _this3 = this;
                var range2 = this.quill.getSelection();
                if (range2 == null)
                  return;
                if (range2.length == 0) {
                  var formats = this.quill.getFormat();
                  Object.keys(formats).forEach(function(name) {
                    if (_parchment2.default.query(name, _parchment2.default.Scope.INLINE) != null) {
                      _this3.quill.format(name, false);
                    }
                  });
                } else {
                  this.quill.removeFormat(range2, _quill2.default.sources.USER);
                }
              },
              direction: function direction(value) {
                var align = this.quill.getFormat()["align"];
                if (value === "rtl" && align == null) {
                  this.quill.format("align", "right", _quill2.default.sources.USER);
                } else if (!value && align === "right") {
                  this.quill.format("align", false, _quill2.default.sources.USER);
                }
                this.quill.format("direction", value, _quill2.default.sources.USER);
              },
              indent: function indent(value) {
                var range2 = this.quill.getSelection();
                var formats = this.quill.getFormat(range2);
                var indent2 = parseInt(formats.indent || 0);
                if (value === "+1" || value === "-1") {
                  var modifier = value === "+1" ? 1 : -1;
                  if (formats.direction === "rtl")
                    modifier *= -1;
                  this.quill.format("indent", indent2 + modifier, _quill2.default.sources.USER);
                }
              },
              link: function link(value) {
                if (value === true) {
                  value = prompt("Enter link URL:");
                }
                this.quill.format("link", value, _quill2.default.sources.USER);
              },
              list: function list2(value) {
                var range2 = this.quill.getSelection();
                var formats = this.quill.getFormat(range2);
                if (value === "check") {
                  if (formats["list"] === "checked" || formats["list"] === "unchecked") {
                    this.quill.format("list", false, _quill2.default.sources.USER);
                  } else {
                    this.quill.format("list", "unchecked", _quill2.default.sources.USER);
                  }
                } else {
                  this.quill.format("list", value, _quill2.default.sources.USER);
                }
              }
            }
          };
          exports3.default = Toolbar;
          exports3.addControls = addControls;
        },
        /* 58 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <polyline class="ql-even ql-stroke" points="5 7 3 9 5 11"></polyline> <polyline class="ql-even ql-stroke" points="13 7 15 9 13 11"></polyline> <line class=ql-stroke x1=10 x2=8 y1=5 y2=13></line> </svg>';
        },
        /* 59 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get4(object, property2, receiver) {
            if (object === null)
              object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get4(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _picker = __webpack_require__(28);
          var _picker2 = _interopRequireDefault2(_picker);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var ColorPicker2 = function(_Picker) {
            _inherits2(ColorPicker3, _Picker);
            function ColorPicker3(select, label2) {
              _classCallCheck2(this, ColorPicker3);
              var _this = _possibleConstructorReturn2(this, (ColorPicker3.__proto__ || Object.getPrototypeOf(ColorPicker3)).call(this, select));
              _this.label.innerHTML = label2;
              _this.container.classList.add("ql-color-picker");
              [].slice.call(_this.container.querySelectorAll(".ql-picker-item"), 0, 7).forEach(function(item) {
                item.classList.add("ql-primary");
              });
              return _this;
            }
            _createClass2(ColorPicker3, [{
              key: "buildItem",
              value: function buildItem(option) {
                var item = _get2(ColorPicker3.prototype.__proto__ || Object.getPrototypeOf(ColorPicker3.prototype), "buildItem", this).call(this, option);
                item.style.backgroundColor = option.getAttribute("value") || "";
                return item;
              }
            }, {
              key: "selectItem",
              value: function selectItem(item, trigger) {
                _get2(ColorPicker3.prototype.__proto__ || Object.getPrototypeOf(ColorPicker3.prototype), "selectItem", this).call(this, item, trigger);
                var colorLabel = this.label.querySelector(".ql-color-label");
                var value = item ? item.getAttribute("data-value") || "" : "";
                if (colorLabel) {
                  if (colorLabel.tagName === "line") {
                    colorLabel.style.stroke = value;
                  } else {
                    colorLabel.style.fill = value;
                  }
                }
              }
            }]);
            return ColorPicker3;
          }(_picker2.default);
          exports3.default = ColorPicker2;
        },
        /* 60 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get4(object, property2, receiver) {
            if (object === null)
              object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get4(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _picker = __webpack_require__(28);
          var _picker2 = _interopRequireDefault2(_picker);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var IconPicker = function(_Picker) {
            _inherits2(IconPicker2, _Picker);
            function IconPicker2(select, icons) {
              _classCallCheck2(this, IconPicker2);
              var _this = _possibleConstructorReturn2(this, (IconPicker2.__proto__ || Object.getPrototypeOf(IconPicker2)).call(this, select));
              _this.container.classList.add("ql-icon-picker");
              [].forEach.call(_this.container.querySelectorAll(".ql-picker-item"), function(item) {
                item.innerHTML = icons[item.getAttribute("data-value") || ""];
              });
              _this.defaultItem = _this.container.querySelector(".ql-selected");
              _this.selectItem(_this.defaultItem);
              return _this;
            }
            _createClass2(IconPicker2, [{
              key: "selectItem",
              value: function selectItem(item, trigger) {
                _get2(IconPicker2.prototype.__proto__ || Object.getPrototypeOf(IconPicker2.prototype), "selectItem", this).call(this, item, trigger);
                item = item || this.defaultItem;
                this.label.innerHTML = item.innerHTML;
              }
            }]);
            return IconPicker2;
          }(_picker2.default);
          exports3.default = IconPicker;
        },
        /* 61 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var Tooltip3 = function() {
            function Tooltip4(quill2, boundsContainer) {
              var _this = this;
              _classCallCheck2(this, Tooltip4);
              this.quill = quill2;
              this.boundsContainer = boundsContainer || document.body;
              this.root = quill2.addContainer("ql-tooltip");
              this.root.innerHTML = this.constructor.TEMPLATE;
              if (this.quill.root === this.quill.scrollingContainer) {
                this.quill.root.addEventListener("scroll", function() {
                  _this.root.style.marginTop = -1 * _this.quill.root.scrollTop + "px";
                });
              }
              this.hide();
            }
            _createClass2(Tooltip4, [{
              key: "hide",
              value: function hide() {
                this.root.classList.add("ql-hidden");
              }
            }, {
              key: "position",
              value: function position(reference) {
                var left = reference.left + reference.width / 2 - this.root.offsetWidth / 2;
                var top = reference.bottom + this.quill.root.scrollTop;
                this.root.style.left = left + "px";
                this.root.style.top = top + "px";
                this.root.classList.remove("ql-flip");
                var containerBounds = this.boundsContainer.getBoundingClientRect();
                var rootBounds = this.root.getBoundingClientRect();
                var shift = 0;
                if (rootBounds.right > containerBounds.right) {
                  shift = containerBounds.right - rootBounds.right;
                  this.root.style.left = left + shift + "px";
                }
                if (rootBounds.left < containerBounds.left) {
                  shift = containerBounds.left - rootBounds.left;
                  this.root.style.left = left + shift + "px";
                }
                if (rootBounds.bottom > containerBounds.bottom) {
                  var height = rootBounds.bottom - rootBounds.top;
                  var verticalShift = reference.bottom - reference.top + height;
                  this.root.style.top = top - verticalShift + "px";
                  this.root.classList.add("ql-flip");
                }
                return shift;
              }
            }, {
              key: "show",
              value: function show() {
                this.root.classList.remove("ql-editing");
                this.root.classList.remove("ql-hidden");
              }
            }]);
            return Tooltip4;
          }();
          exports3.default = Tooltip3;
        },
        /* 62 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _slicedToArray2 = function() {
            function sliceIterator(arr, i2) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i2 && _arr.length === i2)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"])
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            return function(arr, i2) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i2);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();
          var _get2 = function get4(object, property2, receiver) {
            if (object === null)
              object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get4(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _extend = __webpack_require__(3);
          var _extend2 = _interopRequireDefault2(_extend);
          var _emitter = __webpack_require__(8);
          var _emitter2 = _interopRequireDefault2(_emitter);
          var _base = __webpack_require__(43);
          var _base2 = _interopRequireDefault2(_base);
          var _link = __webpack_require__(27);
          var _link2 = _interopRequireDefault2(_link);
          var _selection = __webpack_require__(15);
          var _icons = __webpack_require__(41);
          var _icons2 = _interopRequireDefault2(_icons);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var TOOLBAR_CONFIG = [[{ header: ["1", "2", "3", false] }], ["bold", "italic", "underline", "link"], [{ list: "ordered" }, { list: "bullet" }], ["clean"]];
          var SnowTheme = function(_BaseTheme) {
            _inherits2(SnowTheme2, _BaseTheme);
            function SnowTheme2(quill2, options) {
              _classCallCheck2(this, SnowTheme2);
              if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
                options.modules.toolbar.container = TOOLBAR_CONFIG;
              }
              var _this = _possibleConstructorReturn2(this, (SnowTheme2.__proto__ || Object.getPrototypeOf(SnowTheme2)).call(this, quill2, options));
              _this.quill.container.classList.add("ql-snow");
              return _this;
            }
            _createClass2(SnowTheme2, [{
              key: "extendToolbar",
              value: function extendToolbar(toolbar) {
                toolbar.container.classList.add("ql-snow");
                this.buildButtons([].slice.call(toolbar.container.querySelectorAll("button")), _icons2.default);
                this.buildPickers([].slice.call(toolbar.container.querySelectorAll("select")), _icons2.default);
                this.tooltip = new SnowTooltip(this.quill, this.options.bounds);
                if (toolbar.container.querySelector(".ql-link")) {
                  this.quill.keyboard.addBinding({ key: "K", shortKey: true }, function(range2, context2) {
                    toolbar.handlers["link"].call(toolbar, !context2.format.link);
                  });
                }
              }
            }]);
            return SnowTheme2;
          }(_base2.default);
          SnowTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {
            modules: {
              toolbar: {
                handlers: {
                  link: function link(value) {
                    if (value) {
                      var range2 = this.quill.getSelection();
                      if (range2 == null || range2.length == 0)
                        return;
                      var preview = this.quill.getText(range2);
                      if (/^\S+@\S+\.\S+$/.test(preview) && preview.indexOf("mailto:") !== 0) {
                        preview = "mailto:" + preview;
                      }
                      var tooltip = this.quill.theme.tooltip;
                      tooltip.edit("link", preview);
                    } else {
                      this.quill.format("link", false);
                    }
                  }
                }
              }
            }
          });
          var SnowTooltip = function(_BaseTooltip) {
            _inherits2(SnowTooltip2, _BaseTooltip);
            function SnowTooltip2(quill2, bounds) {
              _classCallCheck2(this, SnowTooltip2);
              var _this2 = _possibleConstructorReturn2(this, (SnowTooltip2.__proto__ || Object.getPrototypeOf(SnowTooltip2)).call(this, quill2, bounds));
              _this2.preview = _this2.root.querySelector("a.ql-preview");
              return _this2;
            }
            _createClass2(SnowTooltip2, [{
              key: "listen",
              value: function listen() {
                var _this3 = this;
                _get2(SnowTooltip2.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip2.prototype), "listen", this).call(this);
                this.root.querySelector("a.ql-action").addEventListener("click", function(event) {
                  if (_this3.root.classList.contains("ql-editing")) {
                    _this3.save();
                  } else {
                    _this3.edit("link", _this3.preview.textContent);
                  }
                  event.preventDefault();
                });
                this.root.querySelector("a.ql-remove").addEventListener("click", function(event) {
                  if (_this3.linkRange != null) {
                    var range2 = _this3.linkRange;
                    _this3.restoreFocus();
                    _this3.quill.formatText(range2, "link", false, _emitter2.default.sources.USER);
                    delete _this3.linkRange;
                  }
                  event.preventDefault();
                  _this3.hide();
                });
                this.quill.on(_emitter2.default.events.SELECTION_CHANGE, function(range2, oldRange, source) {
                  if (range2 == null)
                    return;
                  if (range2.length === 0 && source === _emitter2.default.sources.USER) {
                    var _quill$scroll$descend = _this3.quill.scroll.descendant(_link2.default, range2.index), _quill$scroll$descend2 = _slicedToArray2(_quill$scroll$descend, 2), link = _quill$scroll$descend2[0], offset2 = _quill$scroll$descend2[1];
                    if (link != null) {
                      _this3.linkRange = new _selection.Range(range2.index - offset2, link.length());
                      var preview = _link2.default.formats(link.domNode);
                      _this3.preview.textContent = preview;
                      _this3.preview.setAttribute("href", preview);
                      _this3.show();
                      _this3.position(_this3.quill.getBounds(_this3.linkRange));
                      return;
                    }
                  } else {
                    delete _this3.linkRange;
                  }
                  _this3.hide();
                });
              }
            }, {
              key: "show",
              value: function show() {
                _get2(SnowTooltip2.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip2.prototype), "show", this).call(this);
                this.root.removeAttribute("data-mode");
              }
            }]);
            return SnowTooltip2;
          }(_base.BaseTooltip);
          SnowTooltip.TEMPLATE = ['<a class="ql-preview" rel="noopener noreferrer" target="_blank" href="about:blank"></a>', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-action"></a>', '<a class="ql-remove"></a>'].join("");
          exports3.default = SnowTheme;
        },
        /* 63 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _core = __webpack_require__(29);
          var _core2 = _interopRequireDefault2(_core);
          var _align = __webpack_require__(36);
          var _direction = __webpack_require__(38);
          var _indent = __webpack_require__(64);
          var _blockquote = __webpack_require__(65);
          var _blockquote2 = _interopRequireDefault2(_blockquote);
          var _header = __webpack_require__(66);
          var _header2 = _interopRequireDefault2(_header);
          var _list = __webpack_require__(67);
          var _list2 = _interopRequireDefault2(_list);
          var _background = __webpack_require__(37);
          var _color = __webpack_require__(26);
          var _font = __webpack_require__(39);
          var _size = __webpack_require__(40);
          var _bold = __webpack_require__(56);
          var _bold2 = _interopRequireDefault2(_bold);
          var _italic = __webpack_require__(68);
          var _italic2 = _interopRequireDefault2(_italic);
          var _link = __webpack_require__(27);
          var _link2 = _interopRequireDefault2(_link);
          var _script = __webpack_require__(69);
          var _script2 = _interopRequireDefault2(_script);
          var _strike = __webpack_require__(70);
          var _strike2 = _interopRequireDefault2(_strike);
          var _underline = __webpack_require__(71);
          var _underline2 = _interopRequireDefault2(_underline);
          var _image = __webpack_require__(72);
          var _image2 = _interopRequireDefault2(_image);
          var _video = __webpack_require__(73);
          var _video2 = _interopRequireDefault2(_video);
          var _code = __webpack_require__(13);
          var _code2 = _interopRequireDefault2(_code);
          var _formula = __webpack_require__(74);
          var _formula2 = _interopRequireDefault2(_formula);
          var _syntax = __webpack_require__(75);
          var _syntax2 = _interopRequireDefault2(_syntax);
          var _toolbar = __webpack_require__(57);
          var _toolbar2 = _interopRequireDefault2(_toolbar);
          var _icons = __webpack_require__(41);
          var _icons2 = _interopRequireDefault2(_icons);
          var _picker = __webpack_require__(28);
          var _picker2 = _interopRequireDefault2(_picker);
          var _colorPicker = __webpack_require__(59);
          var _colorPicker2 = _interopRequireDefault2(_colorPicker);
          var _iconPicker = __webpack_require__(60);
          var _iconPicker2 = _interopRequireDefault2(_iconPicker);
          var _tooltip = __webpack_require__(61);
          var _tooltip2 = _interopRequireDefault2(_tooltip);
          var _bubble = __webpack_require__(108);
          var _bubble2 = _interopRequireDefault2(_bubble);
          var _snow = __webpack_require__(62);
          var _snow2 = _interopRequireDefault2(_snow);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          _core2.default.register({
            "attributors/attribute/direction": _direction.DirectionAttribute,
            "attributors/class/align": _align.AlignClass,
            "attributors/class/background": _background.BackgroundClass,
            "attributors/class/color": _color.ColorClass,
            "attributors/class/direction": _direction.DirectionClass,
            "attributors/class/font": _font.FontClass,
            "attributors/class/size": _size.SizeClass,
            "attributors/style/align": _align.AlignStyle,
            "attributors/style/background": _background.BackgroundStyle,
            "attributors/style/color": _color.ColorStyle,
            "attributors/style/direction": _direction.DirectionStyle,
            "attributors/style/font": _font.FontStyle,
            "attributors/style/size": _size.SizeStyle
          }, true);
          _core2.default.register({
            "formats/align": _align.AlignClass,
            "formats/direction": _direction.DirectionClass,
            "formats/indent": _indent.IndentClass,
            "formats/background": _background.BackgroundStyle,
            "formats/color": _color.ColorStyle,
            "formats/font": _font.FontClass,
            "formats/size": _size.SizeClass,
            "formats/blockquote": _blockquote2.default,
            "formats/code-block": _code2.default,
            "formats/header": _header2.default,
            "formats/list": _list2.default,
            "formats/bold": _bold2.default,
            "formats/code": _code.Code,
            "formats/italic": _italic2.default,
            "formats/link": _link2.default,
            "formats/script": _script2.default,
            "formats/strike": _strike2.default,
            "formats/underline": _underline2.default,
            "formats/image": _image2.default,
            "formats/video": _video2.default,
            "formats/list/item": _list.ListItem,
            "modules/formula": _formula2.default,
            "modules/syntax": _syntax2.default,
            "modules/toolbar": _toolbar2.default,
            "themes/bubble": _bubble2.default,
            "themes/snow": _snow2.default,
            "ui/icons": _icons2.default,
            "ui/picker": _picker2.default,
            "ui/icon-picker": _iconPicker2.default,
            "ui/color-picker": _colorPicker2.default,
            "ui/tooltip": _tooltip2.default
          }, true);
          exports3.default = _core2.default;
        },
        /* 64 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.IndentClass = void 0;
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get4(object, property2, receiver) {
            if (object === null)
              object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get4(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var IdentAttributor = function(_Parchment$Attributor) {
            _inherits2(IdentAttributor2, _Parchment$Attributor);
            function IdentAttributor2() {
              _classCallCheck2(this, IdentAttributor2);
              return _possibleConstructorReturn2(this, (IdentAttributor2.__proto__ || Object.getPrototypeOf(IdentAttributor2)).apply(this, arguments));
            }
            _createClass2(IdentAttributor2, [{
              key: "add",
              value: function add2(node, value) {
                if (value === "+1" || value === "-1") {
                  var indent = this.value(node) || 0;
                  value = value === "+1" ? indent + 1 : indent - 1;
                }
                if (value === 0) {
                  this.remove(node);
                  return true;
                } else {
                  return _get2(IdentAttributor2.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor2.prototype), "add", this).call(this, node, value);
                }
              }
            }, {
              key: "canAdd",
              value: function canAdd(node, value) {
                return _get2(IdentAttributor2.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor2.prototype), "canAdd", this).call(this, node, value) || _get2(IdentAttributor2.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor2.prototype), "canAdd", this).call(this, node, parseInt(value));
              }
            }, {
              key: "value",
              value: function value(node) {
                return parseInt(_get2(IdentAttributor2.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor2.prototype), "value", this).call(this, node)) || void 0;
              }
            }]);
            return IdentAttributor2;
          }(_parchment2.default.Attributor.Class);
          var IndentClass = new IdentAttributor("indent", "ql-indent", {
            scope: _parchment2.default.Scope.BLOCK,
            whitelist: [1, 2, 3, 4, 5, 6, 7, 8]
          });
          exports3.IndentClass = IndentClass;
        },
        /* 65 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _block = __webpack_require__(4);
          var _block2 = _interopRequireDefault2(_block);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var Blockquote = function(_Block) {
            _inherits2(Blockquote2, _Block);
            function Blockquote2() {
              _classCallCheck2(this, Blockquote2);
              return _possibleConstructorReturn2(this, (Blockquote2.__proto__ || Object.getPrototypeOf(Blockquote2)).apply(this, arguments));
            }
            return Blockquote2;
          }(_block2.default);
          Blockquote.blotName = "blockquote";
          Blockquote.tagName = "blockquote";
          exports3.default = Blockquote;
        },
        /* 66 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _block = __webpack_require__(4);
          var _block2 = _interopRequireDefault2(_block);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var Header = function(_Block) {
            _inherits2(Header2, _Block);
            function Header2() {
              _classCallCheck2(this, Header2);
              return _possibleConstructorReturn2(this, (Header2.__proto__ || Object.getPrototypeOf(Header2)).apply(this, arguments));
            }
            _createClass2(Header2, null, [{
              key: "formats",
              value: function formats(domNode) {
                return this.tagName.indexOf(domNode.tagName) + 1;
              }
            }]);
            return Header2;
          }(_block2.default);
          Header.blotName = "header";
          Header.tagName = ["H1", "H2", "H3", "H4", "H5", "H6"];
          exports3.default = Header;
        },
        /* 67 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.default = exports3.ListItem = void 0;
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get4(object, property2, receiver) {
            if (object === null)
              object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get4(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _block = __webpack_require__(4);
          var _block2 = _interopRequireDefault2(_block);
          var _container = __webpack_require__(25);
          var _container2 = _interopRequireDefault2(_container);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _defineProperty2(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var ListItem = function(_Block) {
            _inherits2(ListItem2, _Block);
            function ListItem2() {
              _classCallCheck2(this, ListItem2);
              return _possibleConstructorReturn2(this, (ListItem2.__proto__ || Object.getPrototypeOf(ListItem2)).apply(this, arguments));
            }
            _createClass2(ListItem2, [{
              key: "format",
              value: function format2(name, value) {
                if (name === List.blotName && !value) {
                  this.replaceWith(_parchment2.default.create(this.statics.scope));
                } else {
                  _get2(ListItem2.prototype.__proto__ || Object.getPrototypeOf(ListItem2.prototype), "format", this).call(this, name, value);
                }
              }
            }, {
              key: "remove",
              value: function remove() {
                if (this.prev == null && this.next == null) {
                  this.parent.remove();
                } else {
                  _get2(ListItem2.prototype.__proto__ || Object.getPrototypeOf(ListItem2.prototype), "remove", this).call(this);
                }
              }
            }, {
              key: "replaceWith",
              value: function replaceWith(name, value) {
                this.parent.isolate(this.offset(this.parent), this.length());
                if (name === this.parent.statics.blotName) {
                  this.parent.replaceWith(name, value);
                  return this;
                } else {
                  this.parent.unwrap();
                  return _get2(ListItem2.prototype.__proto__ || Object.getPrototypeOf(ListItem2.prototype), "replaceWith", this).call(this, name, value);
                }
              }
            }], [{
              key: "formats",
              value: function formats(domNode) {
                return domNode.tagName === this.tagName ? void 0 : _get2(ListItem2.__proto__ || Object.getPrototypeOf(ListItem2), "formats", this).call(this, domNode);
              }
            }]);
            return ListItem2;
          }(_block2.default);
          ListItem.blotName = "list-item";
          ListItem.tagName = "LI";
          var List = function(_Container) {
            _inherits2(List2, _Container);
            _createClass2(List2, null, [{
              key: "create",
              value: function create(value) {
                var tagName = value === "ordered" ? "OL" : "UL";
                var node = _get2(List2.__proto__ || Object.getPrototypeOf(List2), "create", this).call(this, tagName);
                if (value === "checked" || value === "unchecked") {
                  node.setAttribute("data-checked", value === "checked");
                }
                return node;
              }
            }, {
              key: "formats",
              value: function formats(domNode) {
                if (domNode.tagName === "OL")
                  return "ordered";
                if (domNode.tagName === "UL") {
                  if (domNode.hasAttribute("data-checked")) {
                    return domNode.getAttribute("data-checked") === "true" ? "checked" : "unchecked";
                  } else {
                    return "bullet";
                  }
                }
                return void 0;
              }
            }]);
            function List2(domNode) {
              _classCallCheck2(this, List2);
              var _this2 = _possibleConstructorReturn2(this, (List2.__proto__ || Object.getPrototypeOf(List2)).call(this, domNode));
              var listEventHandler = function listEventHandler2(e2) {
                if (e2.target.parentNode !== domNode)
                  return;
                var format2 = _this2.statics.formats(domNode);
                var blot = _parchment2.default.find(e2.target);
                if (format2 === "checked") {
                  blot.format("list", "unchecked");
                } else if (format2 === "unchecked") {
                  blot.format("list", "checked");
                }
              };
              domNode.addEventListener("touchstart", listEventHandler);
              domNode.addEventListener("mousedown", listEventHandler);
              return _this2;
            }
            _createClass2(List2, [{
              key: "format",
              value: function format2(name, value) {
                if (this.children.length > 0) {
                  this.children.tail.format(name, value);
                }
              }
            }, {
              key: "formats",
              value: function formats() {
                return _defineProperty2({}, this.statics.blotName, this.statics.formats(this.domNode));
              }
            }, {
              key: "insertBefore",
              value: function insertBefore(blot, ref) {
                if (blot instanceof ListItem) {
                  _get2(List2.prototype.__proto__ || Object.getPrototypeOf(List2.prototype), "insertBefore", this).call(this, blot, ref);
                } else {
                  var index2 = ref == null ? this.length() : ref.offset(this);
                  var after = this.split(index2);
                  after.parent.insertBefore(blot, after);
                }
              }
            }, {
              key: "optimize",
              value: function optimize(context2) {
                _get2(List2.prototype.__proto__ || Object.getPrototypeOf(List2.prototype), "optimize", this).call(this, context2);
                var next = this.next;
                if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && next.domNode.tagName === this.domNode.tagName && next.domNode.getAttribute("data-checked") === this.domNode.getAttribute("data-checked")) {
                  next.moveChildren(this);
                  next.remove();
                }
              }
            }, {
              key: "replace",
              value: function replace(target) {
                if (target.statics.blotName !== this.statics.blotName) {
                  var item = _parchment2.default.create(this.statics.defaultChild);
                  target.moveChildren(item);
                  this.appendChild(item);
                }
                _get2(List2.prototype.__proto__ || Object.getPrototypeOf(List2.prototype), "replace", this).call(this, target);
              }
            }]);
            return List2;
          }(_container2.default);
          List.blotName = "list";
          List.scope = _parchment2.default.Scope.BLOCK_BLOT;
          List.tagName = ["OL", "UL"];
          List.defaultChild = "list-item";
          List.allowedChildren = [ListItem];
          exports3.ListItem = ListItem;
          exports3.default = List;
        },
        /* 68 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _bold = __webpack_require__(56);
          var _bold2 = _interopRequireDefault2(_bold);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var Italic = function(_Bold) {
            _inherits2(Italic2, _Bold);
            function Italic2() {
              _classCallCheck2(this, Italic2);
              return _possibleConstructorReturn2(this, (Italic2.__proto__ || Object.getPrototypeOf(Italic2)).apply(this, arguments));
            }
            return Italic2;
          }(_bold2.default);
          Italic.blotName = "italic";
          Italic.tagName = ["EM", "I"];
          exports3.default = Italic;
        },
        /* 69 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get4(object, property2, receiver) {
            if (object === null)
              object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get4(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _inline = __webpack_require__(6);
          var _inline2 = _interopRequireDefault2(_inline);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var Script = function(_Inline) {
            _inherits2(Script2, _Inline);
            function Script2() {
              _classCallCheck2(this, Script2);
              return _possibleConstructorReturn2(this, (Script2.__proto__ || Object.getPrototypeOf(Script2)).apply(this, arguments));
            }
            _createClass2(Script2, null, [{
              key: "create",
              value: function create(value) {
                if (value === "super") {
                  return document.createElement("sup");
                } else if (value === "sub") {
                  return document.createElement("sub");
                } else {
                  return _get2(Script2.__proto__ || Object.getPrototypeOf(Script2), "create", this).call(this, value);
                }
              }
            }, {
              key: "formats",
              value: function formats(domNode) {
                if (domNode.tagName === "SUB")
                  return "sub";
                if (domNode.tagName === "SUP")
                  return "super";
                return void 0;
              }
            }]);
            return Script2;
          }(_inline2.default);
          Script.blotName = "script";
          Script.tagName = ["SUB", "SUP"];
          exports3.default = Script;
        },
        /* 70 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _inline = __webpack_require__(6);
          var _inline2 = _interopRequireDefault2(_inline);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var Strike = function(_Inline) {
            _inherits2(Strike2, _Inline);
            function Strike2() {
              _classCallCheck2(this, Strike2);
              return _possibleConstructorReturn2(this, (Strike2.__proto__ || Object.getPrototypeOf(Strike2)).apply(this, arguments));
            }
            return Strike2;
          }(_inline2.default);
          Strike.blotName = "strike";
          Strike.tagName = "S";
          exports3.default = Strike;
        },
        /* 71 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _inline = __webpack_require__(6);
          var _inline2 = _interopRequireDefault2(_inline);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var Underline = function(_Inline) {
            _inherits2(Underline2, _Inline);
            function Underline2() {
              _classCallCheck2(this, Underline2);
              return _possibleConstructorReturn2(this, (Underline2.__proto__ || Object.getPrototypeOf(Underline2)).apply(this, arguments));
            }
            return Underline2;
          }(_inline2.default);
          Underline.blotName = "underline";
          Underline.tagName = "U";
          exports3.default = Underline;
        },
        /* 72 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get4(object, property2, receiver) {
            if (object === null)
              object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get4(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _link = __webpack_require__(27);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var ATTRIBUTES = ["alt", "height", "width"];
          var Image2 = function(_Parchment$Embed) {
            _inherits2(Image3, _Parchment$Embed);
            function Image3() {
              _classCallCheck2(this, Image3);
              return _possibleConstructorReturn2(this, (Image3.__proto__ || Object.getPrototypeOf(Image3)).apply(this, arguments));
            }
            _createClass2(Image3, [{
              key: "format",
              value: function format2(name, value) {
                if (ATTRIBUTES.indexOf(name) > -1) {
                  if (value) {
                    this.domNode.setAttribute(name, value);
                  } else {
                    this.domNode.removeAttribute(name);
                  }
                } else {
                  _get2(Image3.prototype.__proto__ || Object.getPrototypeOf(Image3.prototype), "format", this).call(this, name, value);
                }
              }
            }], [{
              key: "create",
              value: function create(value) {
                var node = _get2(Image3.__proto__ || Object.getPrototypeOf(Image3), "create", this).call(this, value);
                if (typeof value === "string") {
                  node.setAttribute("src", this.sanitize(value));
                }
                return node;
              }
            }, {
              key: "formats",
              value: function formats(domNode) {
                return ATTRIBUTES.reduce(function(formats2, attribute) {
                  if (domNode.hasAttribute(attribute)) {
                    formats2[attribute] = domNode.getAttribute(attribute);
                  }
                  return formats2;
                }, {});
              }
            }, {
              key: "match",
              value: function match5(url) {
                return /\.(jpe?g|gif|png)$/.test(url) || /^data:image\/.+;base64/.test(url);
              }
            }, {
              key: "sanitize",
              value: function sanitize(url) {
                return (0, _link.sanitize)(url, ["http", "https", "data"]) ? url : "//:0";
              }
            }, {
              key: "value",
              value: function value(domNode) {
                return domNode.getAttribute("src");
              }
            }]);
            return Image3;
          }(_parchment2.default.Embed);
          Image2.blotName = "image";
          Image2.tagName = "IMG";
          exports3.default = Image2;
        },
        /* 73 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get4(object, property2, receiver) {
            if (object === null)
              object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get4(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _block = __webpack_require__(4);
          var _link = __webpack_require__(27);
          var _link2 = _interopRequireDefault2(_link);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var ATTRIBUTES = ["height", "width"];
          var Video = function(_BlockEmbed) {
            _inherits2(Video2, _BlockEmbed);
            function Video2() {
              _classCallCheck2(this, Video2);
              return _possibleConstructorReturn2(this, (Video2.__proto__ || Object.getPrototypeOf(Video2)).apply(this, arguments));
            }
            _createClass2(Video2, [{
              key: "format",
              value: function format2(name, value) {
                if (ATTRIBUTES.indexOf(name) > -1) {
                  if (value) {
                    this.domNode.setAttribute(name, value);
                  } else {
                    this.domNode.removeAttribute(name);
                  }
                } else {
                  _get2(Video2.prototype.__proto__ || Object.getPrototypeOf(Video2.prototype), "format", this).call(this, name, value);
                }
              }
            }], [{
              key: "create",
              value: function create(value) {
                var node = _get2(Video2.__proto__ || Object.getPrototypeOf(Video2), "create", this).call(this, value);
                node.setAttribute("frameborder", "0");
                node.setAttribute("allowfullscreen", true);
                node.setAttribute("src", this.sanitize(value));
                return node;
              }
            }, {
              key: "formats",
              value: function formats(domNode) {
                return ATTRIBUTES.reduce(function(formats2, attribute) {
                  if (domNode.hasAttribute(attribute)) {
                    formats2[attribute] = domNode.getAttribute(attribute);
                  }
                  return formats2;
                }, {});
              }
            }, {
              key: "sanitize",
              value: function sanitize(url) {
                return _link2.default.sanitize(url);
              }
            }, {
              key: "value",
              value: function value(domNode) {
                return domNode.getAttribute("src");
              }
            }]);
            return Video2;
          }(_block.BlockEmbed);
          Video.blotName = "video";
          Video.className = "ql-video";
          Video.tagName = "IFRAME";
          exports3.default = Video;
        },
        /* 74 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.default = exports3.FormulaBlot = void 0;
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get4(object, property2, receiver) {
            if (object === null)
              object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get4(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _embed = __webpack_require__(35);
          var _embed2 = _interopRequireDefault2(_embed);
          var _quill = __webpack_require__(5);
          var _quill2 = _interopRequireDefault2(_quill);
          var _module = __webpack_require__(9);
          var _module2 = _interopRequireDefault2(_module);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var FormulaBlot = function(_Embed) {
            _inherits2(FormulaBlot2, _Embed);
            function FormulaBlot2() {
              _classCallCheck2(this, FormulaBlot2);
              return _possibleConstructorReturn2(this, (FormulaBlot2.__proto__ || Object.getPrototypeOf(FormulaBlot2)).apply(this, arguments));
            }
            _createClass2(FormulaBlot2, null, [{
              key: "create",
              value: function create(value) {
                var node = _get2(FormulaBlot2.__proto__ || Object.getPrototypeOf(FormulaBlot2), "create", this).call(this, value);
                if (typeof value === "string") {
                  window.katex.render(value, node, {
                    throwOnError: false,
                    errorColor: "#f00"
                  });
                  node.setAttribute("data-value", value);
                }
                return node;
              }
            }, {
              key: "value",
              value: function value(domNode) {
                return domNode.getAttribute("data-value");
              }
            }]);
            return FormulaBlot2;
          }(_embed2.default);
          FormulaBlot.blotName = "formula";
          FormulaBlot.className = "ql-formula";
          FormulaBlot.tagName = "SPAN";
          var Formula = function(_Module) {
            _inherits2(Formula2, _Module);
            _createClass2(Formula2, null, [{
              key: "register",
              value: function register() {
                _quill2.default.register(FormulaBlot, true);
              }
            }]);
            function Formula2() {
              _classCallCheck2(this, Formula2);
              var _this2 = _possibleConstructorReturn2(this, (Formula2.__proto__ || Object.getPrototypeOf(Formula2)).call(this));
              if (window.katex == null) {
                throw new Error("Formula module requires KaTeX.");
              }
              return _this2;
            }
            return Formula2;
          }(_module2.default);
          exports3.FormulaBlot = FormulaBlot;
          exports3.default = Formula;
        },
        /* 75 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.default = exports3.CodeToken = exports3.CodeBlock = void 0;
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get2 = function get4(object, property2, receiver) {
            if (object === null)
              object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get4(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _parchment = __webpack_require__(0);
          var _parchment2 = _interopRequireDefault2(_parchment);
          var _quill = __webpack_require__(5);
          var _quill2 = _interopRequireDefault2(_quill);
          var _module = __webpack_require__(9);
          var _module2 = _interopRequireDefault2(_module);
          var _code = __webpack_require__(13);
          var _code2 = _interopRequireDefault2(_code);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var SyntaxCodeBlock = function(_CodeBlock) {
            _inherits2(SyntaxCodeBlock2, _CodeBlock);
            function SyntaxCodeBlock2() {
              _classCallCheck2(this, SyntaxCodeBlock2);
              return _possibleConstructorReturn2(this, (SyntaxCodeBlock2.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock2)).apply(this, arguments));
            }
            _createClass2(SyntaxCodeBlock2, [{
              key: "replaceWith",
              value: function replaceWith(block) {
                this.domNode.textContent = this.domNode.textContent;
                this.attach();
                _get2(SyntaxCodeBlock2.prototype.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock2.prototype), "replaceWith", this).call(this, block);
              }
            }, {
              key: "highlight",
              value: function highlight(_highlight) {
                var text = this.domNode.textContent;
                if (this.cachedText !== text) {
                  if (text.trim().length > 0 || this.cachedText == null) {
                    this.domNode.innerHTML = _highlight(text);
                    this.domNode.normalize();
                    this.attach();
                  }
                  this.cachedText = text;
                }
              }
            }]);
            return SyntaxCodeBlock2;
          }(_code2.default);
          SyntaxCodeBlock.className = "ql-syntax";
          var CodeToken = new _parchment2.default.Attributor.Class("token", "hljs", {
            scope: _parchment2.default.Scope.INLINE
          });
          var Syntax = function(_Module) {
            _inherits2(Syntax2, _Module);
            _createClass2(Syntax2, null, [{
              key: "register",
              value: function register() {
                _quill2.default.register(CodeToken, true);
                _quill2.default.register(SyntaxCodeBlock, true);
              }
            }]);
            function Syntax2(quill2, options) {
              _classCallCheck2(this, Syntax2);
              var _this2 = _possibleConstructorReturn2(this, (Syntax2.__proto__ || Object.getPrototypeOf(Syntax2)).call(this, quill2, options));
              if (typeof _this2.options.highlight !== "function") {
                throw new Error("Syntax module requires highlight.js. Please include the library on the page before Quill.");
              }
              var timer = null;
              _this2.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function() {
                clearTimeout(timer);
                timer = setTimeout(function() {
                  _this2.highlight();
                  timer = null;
                }, _this2.options.interval);
              });
              _this2.highlight();
              return _this2;
            }
            _createClass2(Syntax2, [{
              key: "highlight",
              value: function highlight() {
                var _this3 = this;
                if (this.quill.selection.composing)
                  return;
                this.quill.update(_quill2.default.sources.USER);
                var range2 = this.quill.getSelection();
                this.quill.scroll.descendants(SyntaxCodeBlock).forEach(function(code) {
                  code.highlight(_this3.options.highlight);
                });
                this.quill.update(_quill2.default.sources.SILENT);
                if (range2 != null) {
                  this.quill.setSelection(range2, _quill2.default.sources.SILENT);
                }
              }
            }]);
            return Syntax2;
          }(_module2.default);
          Syntax.DEFAULTS = {
            highlight: function() {
              if (window.hljs == null)
                return null;
              return function(text) {
                var result = window.hljs.highlightAuto(text);
                return result.value;
              };
            }(),
            interval: 1e3
          };
          exports3.CodeBlock = SyntaxCodeBlock;
          exports3.CodeToken = CodeToken;
          exports3.default = Syntax;
        },
        /* 76 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=13 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=9 y1=4 y2=4></line> </svg>';
        },
        /* 77 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=14 x2=4 y1=14 y2=14></line> <line class=ql-stroke x1=12 x2=6 y1=4 y2=4></line> </svg>';
        },
        /* 78 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=5 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=9 y1=4 y2=4></line> </svg>';
        },
        /* 79 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=3 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=3 y1=4 y2=4></line> </svg>';
        },
        /* 80 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <g class="ql-fill ql-color-label"> <polygon points="6 6.868 6 6 5 6 5 7 5.942 7 6 6.868"></polygon> <rect height=1 width=1 x=4 y=4></rect> <polygon points="6.817 5 6 5 6 6 6.38 6 6.817 5"></polygon> <rect height=1 width=1 x=2 y=6></rect> <rect height=1 width=1 x=3 y=5></rect> <rect height=1 width=1 x=4 y=7></rect> <polygon points="4 11.439 4 11 3 11 3 12 3.755 12 4 11.439"></polygon> <rect height=1 width=1 x=2 y=12></rect> <rect height=1 width=1 x=2 y=9></rect> <rect height=1 width=1 x=2 y=15></rect> <polygon points="4.63 10 4 10 4 11 4.192 11 4.63 10"></polygon> <rect height=1 width=1 x=3 y=8></rect> <path d=M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z></path> <path d=M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z></path> <path d=M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z></path> <rect height=1 width=1 x=12 y=2></rect> <rect height=1 width=1 x=11 y=3></rect> <path d=M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z></path> <rect height=1 width=1 x=2 y=3></rect> <rect height=1 width=1 x=6 y=2></rect> <rect height=1 width=1 x=3 y=2></rect> <rect height=1 width=1 x=5 y=3></rect> <rect height=1 width=1 x=9 y=2></rect> <rect height=1 width=1 x=15 y=14></rect> <polygon points="13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174"></polygon> <rect height=1 width=1 x=13 y=7></rect> <rect height=1 width=1 x=15 y=5></rect> <rect height=1 width=1 x=14 y=6></rect> <rect height=1 width=1 x=15 y=8></rect> <rect height=1 width=1 x=14 y=9></rect> <path d=M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z></path> <rect height=1 width=1 x=14 y=3></rect> <polygon points="12 6.868 12 6 11.62 6 12 6.868"></polygon> <rect height=1 width=1 x=15 y=2></rect> <rect height=1 width=1 x=12 y=5></rect> <rect height=1 width=1 x=13 y=4></rect> <polygon points="12.933 9 13 9 13 8 12.495 8 12.933 9"></polygon> <rect height=1 width=1 x=9 y=14></rect> <rect height=1 width=1 x=8 y=15></rect> <path d=M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z></path> <rect height=1 width=1 x=5 y=15></rect> <path d=M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z></path> <rect height=1 width=1 x=11 y=15></rect> <path d=M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z></path> <rect height=1 width=1 x=14 y=15></rect> <rect height=1 width=1 x=15 y=11></rect> </g> <polyline class=ql-stroke points="5.5 13 9 5 12.5 13"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=11 y2=11></line> </svg>';
        },
        /* 81 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <rect class="ql-fill ql-stroke" height=3 width=3 x=4 y=5></rect> <rect class="ql-fill ql-stroke" height=3 width=3 x=11 y=5></rect> <path class="ql-even ql-fill ql-stroke" d=M7,8c0,4.031-3,5-3,5></path> <path class="ql-even ql-fill ql-stroke" d=M14,8c0,4.031-3,5-3,5></path> </svg>';
        },
        /* 82 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <path class=ql-stroke d=M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z></path> <path class=ql-stroke d=M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z></path> </svg>';
        },
        /* 83 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg class="" viewbox="0 0 18 18"> <line class=ql-stroke x1=5 x2=13 y1=3 y2=3></line> <line class=ql-stroke x1=6 x2=9.35 y1=12 y2=3></line> <line class=ql-stroke x1=11 x2=15 y1=11 y2=15></line> <line class=ql-stroke x1=15 x2=11 y1=11 y2=15></line> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=7 x=2 y=14></rect> </svg>';
        },
        /* 84 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <line class="ql-color-label ql-stroke ql-transparent" x1=3 x2=15 y1=15 y2=15></line> <polyline class=ql-stroke points="5.5 11 9 3 12.5 11"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=9 y2=9></line> </svg>';
        },
        /* 85 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <polygon class="ql-stroke ql-fill" points="3 11 5 9 3 7 3 11"></polygon> <line class="ql-stroke ql-fill" x1=15 x2=11 y1=4 y2=4></line> <path class=ql-fill d=M11,3a3,3,0,0,0,0,6h1V3H11Z></path> <rect class=ql-fill height=11 width=1 x=11 y=4></rect> <rect class=ql-fill height=11 width=1 x=13 y=4></rect> </svg>';
        },
        /* 86 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <polygon class="ql-stroke ql-fill" points="15 12 13 10 15 8 15 12"></polygon> <line class="ql-stroke ql-fill" x1=9 x2=5 y1=4 y2=4></line> <path class=ql-fill d=M5,3A3,3,0,0,0,5,9H6V3H5Z></path> <rect class=ql-fill height=11 width=1 x=5 y=4></rect> <rect class=ql-fill height=11 width=1 x=7 y=4></rect> </svg>';
        },
        /* 87 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M14,16H4a1,1,0,0,1,0-2H14A1,1,0,0,1,14,16Z /> <path class=ql-fill d=M14,4H4A1,1,0,0,1,4,2H14A1,1,0,0,1,14,4Z /> <rect class=ql-fill x=3 y=6 width=12 height=6 rx=1 ry=1 /> </svg>';
        },
        /* 88 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M13,16H5a1,1,0,0,1,0-2h8A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H5A1,1,0,0,1,5,2h8A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=2 y=6 width=14 height=6 rx=1 ry=1 /> </svg>';
        },
        /* 89 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15,8H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,8Z /> <path class=ql-fill d=M15,12H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,12Z /> <path class=ql-fill d=M15,16H5a1,1,0,0,1,0-2H15A1,1,0,0,1,15,16Z /> <path class=ql-fill d=M15,4H5A1,1,0,0,1,5,2H15A1,1,0,0,1,15,4Z /> <rect class=ql-fill x=2 y=6 width=8 height=6 rx=1 ry=1 /> </svg>';
        },
        /* 90 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M5,8H3A1,1,0,0,1,3,6H5A1,1,0,0,1,5,8Z /> <path class=ql-fill d=M5,12H3a1,1,0,0,1,0-2H5A1,1,0,0,1,5,12Z /> <path class=ql-fill d=M13,16H3a1,1,0,0,1,0-2H13A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H3A1,1,0,0,1,3,2H13A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=8 y=6 width=8 height=6 rx=1 ry=1 transform="translate(24 18) rotate(-180)"/> </svg>';
        },
        /* 91 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z></path> <rect class=ql-fill height=1.6 rx=0.8 ry=0.8 width=5 x=5.15 y=6.2></rect> <path class=ql-fill d=M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z></path> </svg>';
        },
        /* 92 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewBox="0 0 18 18"> <path class=ql-fill d=M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z /> </svg>';
        },
        /* 93 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewBox="0 0 18 18"> <path class=ql-fill d=M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z /> </svg>';
        },
        /* 94 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=13 y1=4 y2=4></line> <line class=ql-stroke x1=5 x2=11 y1=14 y2=14></line> <line class=ql-stroke x1=8 x2=10 y1=14 y2=4></line> </svg>';
        },
        /* 95 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <rect class=ql-stroke height=10 width=12 x=3 y=4></rect> <circle class=ql-fill cx=6 cy=7 r=1></circle> <polyline class="ql-even ql-fill" points="5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12"></polyline> </svg>';
        },
        /* 96 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class="ql-fill ql-stroke" points="3 7 3 11 5 9 3 7"></polyline> </svg>';
        },
        /* 97 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points="5 7 5 11 3 9 5 7"></polyline> </svg>';
        },
        /* 98 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=11 y1=7 y2=11></line> <path class="ql-even ql-stroke" d=M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z></path> <path class="ql-even ql-stroke" d=M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z></path> </svg>';
        },
        /* 99 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=7 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=7 x2=15 y1=14 y2=14></line> <line class="ql-stroke ql-thin" x1=2.5 x2=4.5 y1=5.5 y2=5.5></line> <path class=ql-fill d=M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z></path> <path class="ql-stroke ql-thin" d=M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156></path> <path class="ql-stroke ql-thin" d=M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109></path> </svg>';
        },
        /* 100 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=6 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=6 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=6 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=3 y1=4 y2=4></line> <line class=ql-stroke x1=3 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=3 y1=14 y2=14></line> </svg>';
        },
        /* 101 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg class="" viewbox="0 0 18 18"> <line class=ql-stroke x1=9 x2=15 y1=4 y2=4></line> <polyline class=ql-stroke points="3 4 4 5 6 3"></polyline> <line class=ql-stroke x1=9 x2=15 y1=14 y2=14></line> <polyline class=ql-stroke points="3 14 4 15 6 13"></polyline> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points="3 9 4 10 6 8"></polyline> </svg>';
        },
        /* 102 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z /> <path class=ql-fill d=M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z /> </svg>';
        },
        /* 103 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z /> <path class=ql-fill d=M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z /> </svg>';
        },
        /* 104 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <line class="ql-stroke ql-thin" x1=15.5 x2=2.5 y1=8.5 y2=9.5></line> <path class=ql-fill d=M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z></path> <path class=ql-fill d=M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z></path> </svg>';
        },
        /* 105 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <path class=ql-stroke d=M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3></path> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=12 x=3 y=15></rect> </svg>';
        },
        /* 106 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <rect class=ql-stroke height=12 width=12 x=3 y=3></rect> <rect class=ql-fill height=12 width=1 x=5 y=3></rect> <rect class=ql-fill height=12 width=1 x=12 y=3></rect> <rect class=ql-fill height=2 width=8 x=5 y=8></rect> <rect class=ql-fill height=1 width=3 x=3 y=5></rect> <rect class=ql-fill height=1 width=3 x=3 y=7></rect> <rect class=ql-fill height=1 width=3 x=3 y=10></rect> <rect class=ql-fill height=1 width=3 x=3 y=12></rect> <rect class=ql-fill height=1 width=3 x=12 y=5></rect> <rect class=ql-fill height=1 width=3 x=12 y=7></rect> <rect class=ql-fill height=1 width=3 x=12 y=10></rect> <rect class=ql-fill height=1 width=3 x=12 y=12></rect> </svg>';
        },
        /* 107 */
        /***/
        function(module3, exports3) {
          module3.exports = '<svg viewbox="0 0 18 18"> <polygon class=ql-stroke points="7 11 9 13 11 11 7 11"></polygon> <polygon class=ql-stroke points="7 7 9 5 11 7 7 7"></polygon> </svg>';
        },
        /* 108 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.default = exports3.BubbleTooltip = void 0;
          var _get2 = function get4(object, property2, receiver) {
            if (object === null)
              object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property2);
            if (desc === void 0) {
              var parent2 = Object.getPrototypeOf(object);
              if (parent2 === null) {
                return void 0;
              } else {
                return get4(parent2, property2, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === void 0) {
                return void 0;
              }
              return getter.call(receiver);
            }
          };
          var _createClass2 = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _extend = __webpack_require__(3);
          var _extend2 = _interopRequireDefault2(_extend);
          var _emitter = __webpack_require__(8);
          var _emitter2 = _interopRequireDefault2(_emitter);
          var _base = __webpack_require__(43);
          var _base2 = _interopRequireDefault2(_base);
          var _selection = __webpack_require__(15);
          var _icons = __webpack_require__(41);
          var _icons2 = _interopRequireDefault2(_icons);
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (!self2) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var TOOLBAR_CONFIG = [["bold", "italic", "link"], [{ header: 1 }, { header: 2 }, "blockquote"]];
          var BubbleTheme = function(_BaseTheme) {
            _inherits2(BubbleTheme2, _BaseTheme);
            function BubbleTheme2(quill2, options) {
              _classCallCheck2(this, BubbleTheme2);
              if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
                options.modules.toolbar.container = TOOLBAR_CONFIG;
              }
              var _this = _possibleConstructorReturn2(this, (BubbleTheme2.__proto__ || Object.getPrototypeOf(BubbleTheme2)).call(this, quill2, options));
              _this.quill.container.classList.add("ql-bubble");
              return _this;
            }
            _createClass2(BubbleTheme2, [{
              key: "extendToolbar",
              value: function extendToolbar(toolbar) {
                this.tooltip = new BubbleTooltip(this.quill, this.options.bounds);
                this.tooltip.root.appendChild(toolbar.container);
                this.buildButtons([].slice.call(toolbar.container.querySelectorAll("button")), _icons2.default);
                this.buildPickers([].slice.call(toolbar.container.querySelectorAll("select")), _icons2.default);
              }
            }]);
            return BubbleTheme2;
          }(_base2.default);
          BubbleTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {
            modules: {
              toolbar: {
                handlers: {
                  link: function link(value) {
                    if (!value) {
                      this.quill.format("link", false);
                    } else {
                      this.quill.theme.tooltip.edit();
                    }
                  }
                }
              }
            }
          });
          var BubbleTooltip = function(_BaseTooltip) {
            _inherits2(BubbleTooltip2, _BaseTooltip);
            function BubbleTooltip2(quill2, bounds) {
              _classCallCheck2(this, BubbleTooltip2);
              var _this2 = _possibleConstructorReturn2(this, (BubbleTooltip2.__proto__ || Object.getPrototypeOf(BubbleTooltip2)).call(this, quill2, bounds));
              _this2.quill.on(_emitter2.default.events.EDITOR_CHANGE, function(type2, range2, oldRange, source) {
                if (type2 !== _emitter2.default.events.SELECTION_CHANGE)
                  return;
                if (range2 != null && range2.length > 0 && source === _emitter2.default.sources.USER) {
                  _this2.show();
                  _this2.root.style.left = "0px";
                  _this2.root.style.width = "";
                  _this2.root.style.width = _this2.root.offsetWidth + "px";
                  var lines = _this2.quill.getLines(range2.index, range2.length);
                  if (lines.length === 1) {
                    _this2.position(_this2.quill.getBounds(range2));
                  } else {
                    var lastLine = lines[lines.length - 1];
                    var index2 = _this2.quill.getIndex(lastLine);
                    var length = Math.min(lastLine.length() - 1, range2.index + range2.length - index2);
                    var _bounds = _this2.quill.getBounds(new _selection.Range(index2, length));
                    _this2.position(_bounds);
                  }
                } else if (document.activeElement !== _this2.textbox && _this2.quill.hasFocus()) {
                  _this2.hide();
                }
              });
              return _this2;
            }
            _createClass2(BubbleTooltip2, [{
              key: "listen",
              value: function listen() {
                var _this3 = this;
                _get2(BubbleTooltip2.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip2.prototype), "listen", this).call(this);
                this.root.querySelector(".ql-close").addEventListener("click", function() {
                  _this3.root.classList.remove("ql-editing");
                });
                this.quill.on(_emitter2.default.events.SCROLL_OPTIMIZE, function() {
                  setTimeout(function() {
                    if (_this3.root.classList.contains("ql-hidden"))
                      return;
                    var range2 = _this3.quill.getSelection();
                    if (range2 != null) {
                      _this3.position(_this3.quill.getBounds(range2));
                    }
                  }, 1);
                });
              }
            }, {
              key: "cancel",
              value: function cancel() {
                this.show();
              }
            }, {
              key: "position",
              value: function position(reference) {
                var shift = _get2(BubbleTooltip2.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip2.prototype), "position", this).call(this, reference);
                var arrow = this.root.querySelector(".ql-tooltip-arrow");
                arrow.style.marginLeft = "";
                if (shift === 0)
                  return shift;
                arrow.style.marginLeft = -1 * shift - arrow.offsetWidth / 2 + "px";
              }
            }]);
            return BubbleTooltip2;
          }(_base.BaseTooltip);
          BubbleTooltip.TEMPLATE = ['<span class="ql-tooltip-arrow"></span>', '<div class="ql-tooltip-editor">', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-close"></a>', "</div>"].join("");
          exports3.BubbleTooltip = BubbleTooltip;
          exports3.default = BubbleTheme;
        },
        /* 109 */
        /***/
        function(module3, exports3, __webpack_require__) {
          module3.exports = __webpack_require__(63);
        }
        /******/
      ])["default"]
    );
  });
})(quill);
var quillExports = quill.exports;
const Quill = /* @__PURE__ */ getDefaultExportFromCjs(quillExports);
var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (b3.hasOwnProperty(p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign$1 = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$1 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
var __spreadArrays = commonjsGlobal && commonjsGlobal.__spreadArrays || function() {
  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
    s2 += arguments[i2].length;
  for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
    for (var a2 = arguments[i2], j = 0, jl = a2.length; j < jl; j++, k2++)
      r2[k2] = a2[j];
  return r2;
};
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
var react_1 = __importDefault(reactExports);
var react_dom_1 = __importDefault(reactDomExports);
var isEqual_1 = __importDefault(isEqual_1$1);
var quill_1 = __importDefault(quillExports);
var ReactQuill = (
  /** @class */
  function(_super) {
    __extends(ReactQuill2, _super);
    function ReactQuill2(props) {
      var _this = _super.call(this, props) || this;
      _this.dirtyProps = [
        "modules",
        "formats",
        "bounds",
        "theme",
        "children"
      ];
      _this.cleanProps = [
        "id",
        "className",
        "style",
        "placeholder",
        "tabIndex",
        "onChange",
        "onChangeSelection",
        "onFocus",
        "onBlur",
        "onKeyPress",
        "onKeyDown",
        "onKeyUp"
      ];
      _this.state = {
        generation: 0
      };
      _this.selection = null;
      _this.onEditorChange = function(eventName, rangeOrDelta, oldRangeOrDelta, source) {
        var _a, _b, _c, _d;
        if (eventName === "text-change") {
          (_b = (_a = _this).onEditorChangeText) === null || _b === void 0 ? void 0 : _b.call(_a, _this.editor.root.innerHTML, rangeOrDelta, source, _this.unprivilegedEditor);
        } else if (eventName === "selection-change") {
          (_d = (_c = _this).onEditorChangeSelection) === null || _d === void 0 ? void 0 : _d.call(_c, rangeOrDelta, source, _this.unprivilegedEditor);
        }
      };
      var value = _this.isControlled() ? props.value : props.defaultValue;
      _this.value = value !== null && value !== void 0 ? value : "";
      return _this;
    }
    ReactQuill2.prototype.validateProps = function(props) {
      var _a;
      if (react_1.default.Children.count(props.children) > 1)
        throw new Error("The Quill editing area can only be composed of a single React element.");
      if (react_1.default.Children.count(props.children)) {
        var child = react_1.default.Children.only(props.children);
        if (((_a = child) === null || _a === void 0 ? void 0 : _a.type) === "textarea")
          throw new Error("Quill does not support editing on a <textarea>. Use a <div> instead.");
      }
      if (this.lastDeltaChangeSet && props.value === this.lastDeltaChangeSet)
        throw new Error("You are passing the `delta` object from the `onChange` event back as `value`. You most probably want `editor.getContents()` instead. See: https://github.com/zenoamaro/react-quill#using-deltas");
    };
    ReactQuill2.prototype.shouldComponentUpdate = function(nextProps, nextState) {
      var _this = this;
      var _a;
      this.validateProps(nextProps);
      if (!this.editor || this.state.generation !== nextState.generation) {
        return true;
      }
      if ("value" in nextProps) {
        var prevContents = this.getEditorContents();
        var nextContents = (_a = nextProps.value, _a !== null && _a !== void 0 ? _a : "");
        if (!this.isEqualValue(nextContents, prevContents)) {
          this.setEditorContents(this.editor, nextContents);
        }
      }
      if (nextProps.readOnly !== this.props.readOnly) {
        this.setEditorReadOnly(this.editor, nextProps.readOnly);
      }
      return __spreadArrays(this.cleanProps, this.dirtyProps).some(function(prop) {
        return !isEqual_1.default(nextProps[prop], _this.props[prop]);
      });
    };
    ReactQuill2.prototype.shouldComponentRegenerate = function(nextProps) {
      var _this = this;
      return this.dirtyProps.some(function(prop) {
        return !isEqual_1.default(nextProps[prop], _this.props[prop]);
      });
    };
    ReactQuill2.prototype.componentDidMount = function() {
      this.instantiateEditor();
      this.setEditorContents(this.editor, this.getEditorContents());
    };
    ReactQuill2.prototype.componentWillUnmount = function() {
      this.destroyEditor();
    };
    ReactQuill2.prototype.componentDidUpdate = function(prevProps, prevState) {
      var _this = this;
      if (this.editor && this.shouldComponentRegenerate(prevProps)) {
        var delta = this.editor.getContents();
        var selection = this.editor.getSelection();
        this.regenerationSnapshot = { delta, selection };
        this.setState({ generation: this.state.generation + 1 });
        this.destroyEditor();
      }
      if (this.state.generation !== prevState.generation) {
        var _a = this.regenerationSnapshot, delta = _a.delta, selection_1 = _a.selection;
        delete this.regenerationSnapshot;
        this.instantiateEditor();
        var editor_1 = this.editor;
        editor_1.setContents(delta);
        postpone(function() {
          return _this.setEditorSelection(editor_1, selection_1);
        });
      }
    };
    ReactQuill2.prototype.instantiateEditor = function() {
      if (this.editor) {
        this.hookEditor(this.editor);
      } else {
        this.editor = this.createEditor(this.getEditingArea(), this.getEditorConfig());
      }
    };
    ReactQuill2.prototype.destroyEditor = function() {
      if (!this.editor)
        return;
      this.unhookEditor(this.editor);
    };
    ReactQuill2.prototype.isControlled = function() {
      return "value" in this.props;
    };
    ReactQuill2.prototype.getEditorConfig = function() {
      return {
        bounds: this.props.bounds,
        formats: this.props.formats,
        modules: this.props.modules,
        placeholder: this.props.placeholder,
        readOnly: this.props.readOnly,
        scrollingContainer: this.props.scrollingContainer,
        tabIndex: this.props.tabIndex,
        theme: this.props.theme
      };
    };
    ReactQuill2.prototype.getEditor = function() {
      if (!this.editor)
        throw new Error("Accessing non-instantiated editor");
      return this.editor;
    };
    ReactQuill2.prototype.createEditor = function(element, config2) {
      var editor = new quill_1.default(element, config2);
      if (config2.tabIndex != null) {
        this.setEditorTabIndex(editor, config2.tabIndex);
      }
      this.hookEditor(editor);
      return editor;
    };
    ReactQuill2.prototype.hookEditor = function(editor) {
      this.unprivilegedEditor = this.makeUnprivilegedEditor(editor);
      editor.on("editor-change", this.onEditorChange);
    };
    ReactQuill2.prototype.unhookEditor = function(editor) {
      editor.off("editor-change", this.onEditorChange);
    };
    ReactQuill2.prototype.getEditorContents = function() {
      return this.value;
    };
    ReactQuill2.prototype.getEditorSelection = function() {
      return this.selection;
    };
    ReactQuill2.prototype.isDelta = function(value) {
      return value && value.ops;
    };
    ReactQuill2.prototype.isEqualValue = function(value, nextValue) {
      if (this.isDelta(value) && this.isDelta(nextValue)) {
        return isEqual_1.default(value.ops, nextValue.ops);
      } else {
        return isEqual_1.default(value, nextValue);
      }
    };
    ReactQuill2.prototype.setEditorContents = function(editor, value) {
      var _this = this;
      this.value = value;
      var sel = this.getEditorSelection();
      if (typeof value === "string") {
        editor.setContents(editor.clipboard.convert(value));
      } else {
        editor.setContents(value);
      }
      postpone(function() {
        return _this.setEditorSelection(editor, sel);
      });
    };
    ReactQuill2.prototype.setEditorSelection = function(editor, range2) {
      this.selection = range2;
      if (range2) {
        var length_1 = editor.getLength();
        range2.index = Math.max(0, Math.min(range2.index, length_1 - 1));
        range2.length = Math.max(0, Math.min(range2.length, length_1 - 1 - range2.index));
        editor.setSelection(range2);
      }
    };
    ReactQuill2.prototype.setEditorTabIndex = function(editor, tabIndex) {
      var _a, _b;
      if ((_b = (_a = editor) === null || _a === void 0 ? void 0 : _a.scroll) === null || _b === void 0 ? void 0 : _b.domNode) {
        editor.scroll.domNode.tabIndex = tabIndex;
      }
    };
    ReactQuill2.prototype.setEditorReadOnly = function(editor, value) {
      if (value) {
        editor.disable();
      } else {
        editor.enable();
      }
    };
    ReactQuill2.prototype.makeUnprivilegedEditor = function(editor) {
      var e2 = editor;
      return {
        getHTML: function() {
          return e2.root.innerHTML;
        },
        getLength: e2.getLength.bind(e2),
        getText: e2.getText.bind(e2),
        getContents: e2.getContents.bind(e2),
        getSelection: e2.getSelection.bind(e2),
        getBounds: e2.getBounds.bind(e2)
      };
    };
    ReactQuill2.prototype.getEditingArea = function() {
      if (!this.editingArea) {
        throw new Error("Instantiating on missing editing area");
      }
      var element = react_dom_1.default.findDOMNode(this.editingArea);
      if (!element) {
        throw new Error("Cannot find element for editing area");
      }
      if (element.nodeType === 3) {
        throw new Error("Editing area cannot be a text node");
      }
      return element;
    };
    ReactQuill2.prototype.renderEditingArea = function() {
      var _this = this;
      var _a = this.props, children = _a.children, preserveWhitespace = _a.preserveWhitespace;
      var generation = this.state.generation;
      var properties = {
        key: generation,
        ref: function(instance) {
          _this.editingArea = instance;
        }
      };
      if (react_1.default.Children.count(children)) {
        return react_1.default.cloneElement(react_1.default.Children.only(children), properties);
      }
      return preserveWhitespace ? react_1.default.createElement("pre", __assign$1({}, properties)) : react_1.default.createElement("div", __assign$1({}, properties));
    };
    ReactQuill2.prototype.render = function() {
      var _a;
      return react_1.default.createElement("div", { id: this.props.id, style: this.props.style, key: this.state.generation, className: "quill " + (_a = this.props.className, _a !== null && _a !== void 0 ? _a : ""), onKeyPress: this.props.onKeyPress, onKeyDown: this.props.onKeyDown, onKeyUp: this.props.onKeyUp }, this.renderEditingArea());
    };
    ReactQuill2.prototype.onEditorChangeText = function(value, delta, source, editor) {
      var _a, _b;
      if (!this.editor)
        return;
      var nextContents = this.isDelta(this.value) ? editor.getContents() : editor.getHTML();
      if (nextContents !== this.getEditorContents()) {
        this.lastDeltaChangeSet = delta;
        this.value = nextContents;
        (_b = (_a = this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, value, delta, source, editor);
      }
    };
    ReactQuill2.prototype.onEditorChangeSelection = function(nextSelection, source, editor) {
      var _a, _b, _c, _d, _e, _f;
      if (!this.editor)
        return;
      var currentSelection = this.getEditorSelection();
      var hasGainedFocus = !currentSelection && nextSelection;
      var hasLostFocus = currentSelection && !nextSelection;
      if (isEqual_1.default(nextSelection, currentSelection))
        return;
      this.selection = nextSelection;
      (_b = (_a = this.props).onChangeSelection) === null || _b === void 0 ? void 0 : _b.call(_a, nextSelection, source, editor);
      if (hasGainedFocus) {
        (_d = (_c = this.props).onFocus) === null || _d === void 0 ? void 0 : _d.call(_c, nextSelection, source, editor);
      } else if (hasLostFocus) {
        (_f = (_e = this.props).onBlur) === null || _f === void 0 ? void 0 : _f.call(_e, currentSelection, source, editor);
      }
    };
    ReactQuill2.prototype.focus = function() {
      if (!this.editor)
        return;
      this.editor.focus();
    };
    ReactQuill2.prototype.blur = function() {
      if (!this.editor)
        return;
      this.selection = null;
      this.editor.blur();
    };
    ReactQuill2.displayName = "React Quill";
    ReactQuill2.Quill = quill_1.default;
    ReactQuill2.defaultProps = {
      theme: "snow",
      modules: {},
      readOnly: false
    };
    return ReactQuill2;
  }(react_1.default.Component)
);
function postpone(fn) {
  Promise.resolve().then(fn);
}
var lib$1 = ReactQuill;
const ReactQuill$1 = /* @__PURE__ */ getDefaultExportFromCjs(lib$1);
function _classCallCheck$a(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$8(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _defineProperty$3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends$g() {
  _extends$g = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$g.apply(this, arguments);
}
function _inherits$a(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf(o, p2);
}
function _isNativeReflectConstruct$s() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn$a(self2, call2) {
  if (call2 && (typeof call2 === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _createSuper$s(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$s();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$a(this, result);
  };
}
function _superPropBase$1(object, property2) {
  while (!Object.prototype.hasOwnProperty.call(object, property2)) {
    object = _getPrototypeOf(object);
    if (object === null)
      break;
  }
  return object;
}
function _get$1() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get$1 = Reflect.get;
  } else {
    _get$1 = function _get2(target, property2, receiver) {
      var base = _superPropBase$1(target, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get$1.apply(this, arguments);
}
function _unsupportedIterableToArray$7(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$7(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$7(o, minLen);
}
function _arrayLikeToArray$7(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
function _createForOfIteratorHelper$6(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$7(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i2 = 0;
      var F2 = function() {
      };
      return {
        s: F2,
        n: function() {
          if (i2 >= o.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o[i2++]
          };
        },
        e: function(e2) {
          throw e2;
        },
        f: F2
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function() {
      it = it.call(o);
    },
    n: function() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function(e2) {
      didErr = true;
      err = e2;
    },
    f: function() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    }
  };
}
var Keys = {
  TAB: 9,
  ENTER: 13,
  ESCAPE: 27,
  UP: 38,
  DOWN: 40
};
function attachDataValues(element, data, dataAttributes) {
  var mention = element;
  Object.keys(data).forEach(function(key) {
    if (dataAttributes.indexOf(key) > -1) {
      mention.dataset[key] = data[key];
    } else {
      delete mention.dataset[key];
    }
  });
  return mention;
}
function getMentionCharIndex(text, mentionDenotationChars) {
  return mentionDenotationChars.reduce(function(prev, mentionChar) {
    var mentionCharIndex = text.lastIndexOf(mentionChar);
    if (mentionCharIndex > prev.mentionCharIndex) {
      return {
        mentionChar,
        mentionCharIndex
      };
    }
    return {
      mentionChar: prev.mentionChar,
      mentionCharIndex: prev.mentionCharIndex
    };
  }, {
    mentionChar: null,
    mentionCharIndex: -1
  });
}
function hasValidChars(text, allowedChars) {
  return allowedChars.test(text);
}
function hasValidMentionCharIndex(mentionCharIndex, text, isolateChar) {
  if (mentionCharIndex > -1) {
    if (isolateChar && !(mentionCharIndex === 0 || !!text[mentionCharIndex - 1].match(/\s/g))) {
      return false;
    }
    return true;
  }
  return false;
}
var Embed = Quill["import"]("blots/embed");
var MentionBlot = /* @__PURE__ */ function(_Embed) {
  _inherits$a(MentionBlot2, _Embed);
  var _super = _createSuper$s(MentionBlot2);
  function MentionBlot2(scroll, node) {
    var _this;
    _classCallCheck$a(this, MentionBlot2);
    _this = _super.call(this, scroll, node);
    _defineProperty$3(_assertThisInitialized(_this), "hoverHandler", void 0);
    _defineProperty$3(_assertThisInitialized(_this), "hoverHandler", void 0);
    _this.clickHandler = null;
    _this.hoverHandler = null;
    _this.mounted = false;
    return _this;
  }
  _createClass$8(MentionBlot2, [{
    key: "attach",
    value: function attach() {
      _get$1(_getPrototypeOf(MentionBlot2.prototype), "attach", this).call(this);
      if (!this.mounted) {
        this.mounted = true;
        this.clickHandler = this.getClickHandler();
        this.hoverHandler = this.getHoverHandler();
        this.domNode.addEventListener("click", this.clickHandler, false);
        this.domNode.addEventListener("mouseenter", this.hoverHandler, false);
      }
    }
  }, {
    key: "detach",
    value: function detach() {
      _get$1(_getPrototypeOf(MentionBlot2.prototype), "detach", this).call(this);
      this.mounted = false;
      if (this.clickHandler) {
        this.domNode.removeEventListener("click", this.clickHandler);
        this.clickHandler = null;
      }
    }
  }, {
    key: "getClickHandler",
    value: function getClickHandler() {
      var _this2 = this;
      return function(e2) {
        var event = _this2.buildEvent("mention-clicked", e2);
        window.dispatchEvent(event);
        e2.preventDefault();
      };
    }
  }, {
    key: "getHoverHandler",
    value: function getHoverHandler() {
      var _this3 = this;
      return function(e2) {
        var event = _this3.buildEvent("mention-hovered", e2);
        window.dispatchEvent(event);
        e2.preventDefault();
      };
    }
  }, {
    key: "buildEvent",
    value: function buildEvent(name, e2) {
      var event = new Event(name, {
        bubbles: true,
        cancelable: true
      });
      event.value = _extends$g({}, this.domNode.dataset);
      event.event = e2;
      return event;
    }
  }], [{
    key: "create",
    value: function create(data) {
      var node = _get$1(_getPrototypeOf(MentionBlot2), "create", this).call(this);
      var denotationChar = document.createElement("span");
      denotationChar.className = "ql-mention-denotation-char";
      denotationChar.innerHTML = data.denotationChar;
      node.appendChild(denotationChar);
      node.innerHTML += data.value;
      return MentionBlot2.setDataValues(node, data);
    }
  }, {
    key: "setDataValues",
    value: function setDataValues(element, data) {
      var domNode = element;
      Object.keys(data).forEach(function(key) {
        domNode.dataset[key] = data[key];
      });
      return domNode;
    }
  }, {
    key: "value",
    value: function value(domNode) {
      return domNode.dataset;
    }
  }]);
  return MentionBlot2;
}(Embed);
MentionBlot.blotName = "mention";
MentionBlot.tagName = "span";
MentionBlot.className = "mention";
Quill.register(MentionBlot);
var Mention = /* @__PURE__ */ function() {
  function Mention2(quill2, options) {
    var _this = this;
    _classCallCheck$a(this, Mention2);
    this.isOpen = false;
    this.itemIndex = 0;
    this.mentionCharPos = null;
    this.cursorPos = null;
    this.values = [];
    this.suspendMouseEnter = false;
    this.existingSourceExecutionToken = null;
    this.quill = quill2;
    this.options = {
      source: null,
      renderItem: function renderItem(item) {
        return "".concat(item.value);
      },
      renderLoading: function renderLoading() {
        return null;
      },
      onSelect: function onSelect(item, insertItem) {
        insertItem(item);
      },
      mentionDenotationChars: ["@"],
      showDenotationChar: true,
      allowedChars: /^[a-zA-Z0-9_]*$/,
      minChars: 0,
      maxChars: 31,
      offsetTop: 2,
      offsetLeft: 0,
      isolateCharacter: false,
      fixMentionsToQuill: false,
      positioningStrategy: "normal",
      defaultMenuOrientation: "bottom",
      blotName: "mention",
      dataAttributes: ["id", "value", "denotationChar", "link", "target", "disabled"],
      linkTarget: "_blank",
      onOpen: function onOpen() {
        return true;
      },
      onBeforeClose: function onBeforeClose() {
        return true;
      },
      onClose: function onClose() {
        return true;
      },
      // Style options
      listItemClass: "ql-mention-list-item",
      mentionContainerClass: "ql-mention-list-container",
      mentionListClass: "ql-mention-list",
      spaceAfterInsert: true,
      selectKeys: [Keys.ENTER]
    };
    _extends$g(this.options, options, {
      dataAttributes: Array.isArray(options.dataAttributes) ? this.options.dataAttributes.concat(options.dataAttributes) : this.options.dataAttributes
    });
    this.mentionContainer = document.createElement("div");
    this.mentionContainer.className = this.options.mentionContainerClass ? this.options.mentionContainerClass : "";
    this.mentionContainer.style.cssText = "display: none; position: absolute;";
    this.mentionContainer.onmousemove = this.onContainerMouseMove.bind(this);
    if (this.options.fixMentionsToQuill) {
      this.mentionContainer.style.width = "auto";
    }
    this.mentionList = document.createElement("ul");
    this.mentionList.id = "quill-mention-list";
    quill2.root.setAttribute("aria-owns", "quill-mention-list");
    this.mentionList.className = this.options.mentionListClass ? this.options.mentionListClass : "";
    this.mentionContainer.appendChild(this.mentionList);
    quill2.on("text-change", this.onTextChange.bind(this));
    quill2.on("selection-change", this.onSelectionChange.bind(this));
    quill2.container.addEventListener("paste", function() {
      setTimeout(function() {
        var range2 = quill2.getSelection();
        _this.onSelectionChange(range2);
      });
    });
    quill2.keyboard.addBinding({
      key: Keys.TAB
    }, this.selectHandler.bind(this));
    quill2.keyboard.bindings[Keys.TAB].unshift(quill2.keyboard.bindings[Keys.TAB].pop());
    var _iterator = _createForOfIteratorHelper$6(this.options.selectKeys), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var selectKey = _step.value;
        quill2.keyboard.addBinding({
          key: selectKey
        }, this.selectHandler.bind(this));
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    quill2.keyboard.bindings[Keys.ENTER].unshift(quill2.keyboard.bindings[Keys.ENTER].pop());
    quill2.keyboard.addBinding({
      key: Keys.ESCAPE
    }, this.escapeHandler.bind(this));
    quill2.keyboard.addBinding({
      key: Keys.UP
    }, this.upHandler.bind(this));
    quill2.keyboard.addBinding({
      key: Keys.DOWN
    }, this.downHandler.bind(this));
  }
  _createClass$8(Mention2, [{
    key: "selectHandler",
    value: function selectHandler() {
      if (this.isOpen && !this.existingSourceExecutionToken) {
        this.selectItem();
        return false;
      }
      return true;
    }
  }, {
    key: "escapeHandler",
    value: function escapeHandler() {
      if (this.isOpen) {
        if (this.existingSourceExecutionToken) {
          this.existingSourceExecutionToken.abandoned = true;
        }
        this.hideMentionList();
        return false;
      }
      return true;
    }
  }, {
    key: "upHandler",
    value: function upHandler() {
      if (this.isOpen && !this.existingSourceExecutionToken) {
        this.prevItem();
        return false;
      }
      return true;
    }
  }, {
    key: "downHandler",
    value: function downHandler() {
      if (this.isOpen && !this.existingSourceExecutionToken) {
        this.nextItem();
        return false;
      }
      return true;
    }
  }, {
    key: "showMentionList",
    value: function showMentionList() {
      if (this.options.positioningStrategy === "fixed") {
        document.body.appendChild(this.mentionContainer);
      } else {
        this.quill.container.appendChild(this.mentionContainer);
      }
      this.mentionContainer.style.visibility = "hidden";
      this.mentionContainer.style.display = "";
      this.mentionContainer.scrollTop = 0;
      this.setMentionContainerPosition();
      this.setIsOpen(true);
    }
  }, {
    key: "hideMentionList",
    value: function hideMentionList() {
      this.options.onBeforeClose();
      this.mentionContainer.style.display = "none";
      this.mentionContainer.remove();
      this.setIsOpen(false);
      this.quill.root.removeAttribute("aria-activedescendant");
    }
  }, {
    key: "highlightItem",
    value: function highlightItem() {
      var scrollItemInView = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      for (var i2 = 0; i2 < this.mentionList.childNodes.length; i2 += 1) {
        this.mentionList.childNodes[i2].classList.remove("selected");
      }
      if (this.itemIndex === -1 || this.mentionList.childNodes[this.itemIndex].dataset.disabled === "true") {
        return;
      }
      this.mentionList.childNodes[this.itemIndex].classList.add("selected");
      this.quill.root.setAttribute("aria-activedescendant", this.mentionList.childNodes[this.itemIndex].id);
      if (scrollItemInView) {
        var itemHeight = this.mentionList.childNodes[this.itemIndex].offsetHeight;
        var itemPos = this.mentionList.childNodes[this.itemIndex].offsetTop;
        var containerTop = this.mentionContainer.scrollTop;
        var containerBottom = containerTop + this.mentionContainer.offsetHeight;
        if (itemPos < containerTop) {
          this.mentionContainer.scrollTop = itemPos;
        } else if (itemPos > containerBottom - itemHeight) {
          this.mentionContainer.scrollTop += itemPos - containerBottom + itemHeight;
        }
      }
    }
  }, {
    key: "getItemData",
    value: function getItemData() {
      var link = this.mentionList.childNodes[this.itemIndex].dataset.link;
      var hasLinkValue = typeof link !== "undefined";
      var itemTarget = this.mentionList.childNodes[this.itemIndex].dataset.target;
      if (hasLinkValue) {
        this.mentionList.childNodes[this.itemIndex].dataset.value = '<a href="'.concat(link, '" target=').concat(itemTarget || this.options.linkTarget, ">").concat(this.mentionList.childNodes[this.itemIndex].dataset.value);
      }
      return this.mentionList.childNodes[this.itemIndex].dataset;
    }
  }, {
    key: "onContainerMouseMove",
    value: function onContainerMouseMove() {
      this.suspendMouseEnter = false;
    }
  }, {
    key: "selectItem",
    value: function selectItem() {
      var _this2 = this;
      if (this.itemIndex === -1) {
        return;
      }
      var data = this.getItemData();
      if (data.disabled) {
        return;
      }
      this.options.onSelect(data, function(asyncData) {
        _this2.insertItem(asyncData);
      });
      this.hideMentionList();
    }
  }, {
    key: "insertItem",
    value: function insertItem(data, programmaticInsert) {
      var render3 = data;
      if (render3 === null) {
        return;
      }
      if (!this.options.showDenotationChar) {
        render3.denotationChar = "";
      }
      var insertAtPos;
      if (!programmaticInsert) {
        insertAtPos = this.mentionCharPos;
        this.quill.deleteText(this.mentionCharPos, this.cursorPos - this.mentionCharPos, Quill.sources.USER);
      } else {
        insertAtPos = this.cursorPos;
      }
      this.quill.insertEmbed(insertAtPos, this.options.blotName, render3, Quill.sources.USER);
      if (this.options.spaceAfterInsert) {
        this.quill.insertText(insertAtPos + 1, " ", Quill.sources.USER);
        this.quill.setSelection(insertAtPos + 2, Quill.sources.USER);
      } else {
        this.quill.setSelection(insertAtPos + 1, Quill.sources.USER);
      }
      this.hideMentionList();
    }
  }, {
    key: "onItemMouseEnter",
    value: function onItemMouseEnter(e2) {
      if (this.suspendMouseEnter) {
        return;
      }
      var index2 = Number(e2.target.dataset.index);
      if (!Number.isNaN(index2) && index2 !== this.itemIndex) {
        this.itemIndex = index2;
        this.highlightItem(false);
      }
    }
  }, {
    key: "onDisabledItemMouseEnter",
    value: function onDisabledItemMouseEnter(e2) {
      if (this.suspendMouseEnter) {
        return;
      }
      this.itemIndex = -1;
      this.highlightItem(false);
    }
  }, {
    key: "onItemClick",
    value: function onItemClick(e2) {
      if (e2.button !== 0) {
        return;
      }
      e2.preventDefault();
      e2.stopImmediatePropagation();
      this.itemIndex = e2.currentTarget.dataset.index;
      this.highlightItem();
      this.selectItem();
    }
  }, {
    key: "onItemMouseDown",
    value: function onItemMouseDown(e2) {
      e2.preventDefault();
      e2.stopImmediatePropagation();
    }
  }, {
    key: "renderLoading",
    value: function renderLoading() {
      var renderedLoading = this.options.renderLoading();
      if (!renderedLoading) {
        return;
      }
      if (this.mentionContainer.getElementsByClassName("ql-mention-loading").length > 0) {
        this.showMentionList();
        return;
      }
      this.mentionList.innerHTML = "";
      var loadingDiv = document.createElement("div");
      loadingDiv.className = "ql-mention-loading";
      loadingDiv.innerHTML = this.options.renderLoading();
      this.mentionContainer.append(loadingDiv);
      this.showMentionList();
    }
  }, {
    key: "removeLoading",
    value: function removeLoading() {
      var loadingDiv = this.mentionContainer.getElementsByClassName("ql-mention-loading");
      if (loadingDiv.length > 0) {
        loadingDiv[0].remove();
      }
    }
  }, {
    key: "renderList",
    value: function renderList(mentionChar, data, searchTerm) {
      if (data && data.length > 0) {
        this.removeLoading();
        this.values = data;
        this.mentionList.innerHTML = "";
        var initialSelection = -1;
        for (var i2 = 0; i2 < data.length; i2 += 1) {
          var li = document.createElement("li");
          li.id = "quill-mention-item-" + i2;
          li.className = this.options.listItemClass ? this.options.listItemClass : "";
          if (data[i2].disabled) {
            li.className += " disabled";
            li.setAttribute("aria-hidden", "true");
          } else if (initialSelection === -1) {
            initialSelection = i2;
          }
          li.dataset.index = i2;
          li.innerHTML = this.options.renderItem(data[i2], searchTerm);
          if (!data[i2].disabled) {
            li.onmouseenter = this.onItemMouseEnter.bind(this);
            li.onmouseup = this.onItemClick.bind(this);
            li.onmousedown = this.onItemMouseDown.bind(this);
          } else {
            li.onmouseenter = this.onDisabledItemMouseEnter.bind(this);
          }
          li.dataset.denotationChar = mentionChar;
          this.mentionList.appendChild(attachDataValues(li, data[i2], this.options.dataAttributes));
        }
        this.itemIndex = initialSelection;
        this.highlightItem();
        this.showMentionList();
      } else {
        this.hideMentionList();
      }
    }
  }, {
    key: "nextItem",
    value: function nextItem() {
      var increment = 0;
      var newIndex;
      do {
        increment++;
        newIndex = (this.itemIndex + increment) % this.values.length;
        var disabled = this.mentionList.childNodes[newIndex].dataset.disabled === "true";
        if (increment === this.values.length + 1) {
          newIndex = -1;
          break;
        }
      } while (disabled);
      this.itemIndex = newIndex;
      this.suspendMouseEnter = true;
      this.highlightItem();
    }
  }, {
    key: "prevItem",
    value: function prevItem() {
      var decrement = 0;
      var newIndex;
      do {
        decrement++;
        newIndex = (this.itemIndex + this.values.length - decrement) % this.values.length;
        var disabled = this.mentionList.childNodes[newIndex].dataset.disabled === "true";
        if (decrement === this.values.length + 1) {
          newIndex = -1;
          break;
        }
      } while (disabled);
      this.itemIndex = newIndex;
      this.suspendMouseEnter = true;
      this.highlightItem();
    }
  }, {
    key: "containerBottomIsNotVisible",
    value: function containerBottomIsNotVisible(topPos, containerPos) {
      var mentionContainerBottom = topPos + this.mentionContainer.offsetHeight + containerPos.top;
      return mentionContainerBottom > window.pageYOffset + window.innerHeight;
    }
  }, {
    key: "containerRightIsNotVisible",
    value: function containerRightIsNotVisible(leftPos, containerPos) {
      if (this.options.fixMentionsToQuill) {
        return false;
      }
      var rightPos = leftPos + this.mentionContainer.offsetWidth + containerPos.left;
      var browserWidth = window.pageXOffset + document.documentElement.clientWidth;
      return rightPos > browserWidth;
    }
  }, {
    key: "setIsOpen",
    value: function setIsOpen(isOpen) {
      if (this.isOpen !== isOpen) {
        if (isOpen) {
          this.options.onOpen();
        } else {
          this.options.onClose();
        }
        this.isOpen = isOpen;
      }
    }
  }, {
    key: "setMentionContainerPosition",
    value: function setMentionContainerPosition() {
      if (this.options.positioningStrategy === "fixed") {
        this.setMentionContainerPosition_Fixed();
      } else {
        this.setMentionContainerPosition_Normal();
      }
    }
  }, {
    key: "setMentionContainerPosition_Normal",
    value: function setMentionContainerPosition_Normal() {
      var _this3 = this;
      var containerPos = this.quill.container.getBoundingClientRect();
      var mentionCharPos = this.quill.getBounds(this.mentionCharPos);
      var containerHeight = this.mentionContainer.offsetHeight;
      var topPos = this.options.offsetTop;
      var leftPos = this.options.offsetLeft;
      if (this.options.fixMentionsToQuill) {
        var rightPos = 0;
        this.mentionContainer.style.right = "".concat(rightPos, "px");
      } else {
        leftPos += mentionCharPos.left;
      }
      if (this.containerRightIsNotVisible(leftPos, containerPos)) {
        var containerWidth = this.mentionContainer.offsetWidth + this.options.offsetLeft;
        var quillWidth = containerPos.width;
        leftPos = quillWidth - containerWidth;
      }
      if (this.options.defaultMenuOrientation === "top") {
        if (this.options.fixMentionsToQuill) {
          topPos = -1 * (containerHeight + this.options.offsetTop);
        } else {
          topPos = mentionCharPos.top - (containerHeight + this.options.offsetTop);
        }
        if (topPos + containerPos.top <= 0) {
          var overMentionCharPos = this.options.offsetTop;
          if (this.options.fixMentionsToQuill) {
            overMentionCharPos += containerPos.height;
          } else {
            overMentionCharPos += mentionCharPos.bottom;
          }
          topPos = overMentionCharPos;
        }
      } else {
        if (this.options.fixMentionsToQuill) {
          topPos += containerPos.height;
        } else {
          topPos += mentionCharPos.bottom;
        }
        if (this.containerBottomIsNotVisible(topPos, containerPos)) {
          var _overMentionCharPos = this.options.offsetTop * -1;
          if (!this.options.fixMentionsToQuill) {
            _overMentionCharPos += mentionCharPos.top;
          }
          topPos = _overMentionCharPos - containerHeight;
        }
      }
      if (topPos >= 0) {
        this.options.mentionContainerClass.split(" ").forEach(function(className) {
          _this3.mentionContainer.classList.add("".concat(className, "-bottom"));
          _this3.mentionContainer.classList.remove("".concat(className, "-top"));
        });
      } else {
        this.options.mentionContainerClass.split(" ").forEach(function(className) {
          _this3.mentionContainer.classList.add("".concat(className, "-top"));
          _this3.mentionContainer.classList.remove("".concat(className, "-bottom"));
        });
      }
      this.mentionContainer.style.top = "".concat(topPos, "px");
      this.mentionContainer.style.left = "".concat(leftPos, "px");
      this.mentionContainer.style.visibility = "visible";
    }
  }, {
    key: "setMentionContainerPosition_Fixed",
    value: function setMentionContainerPosition_Fixed() {
      var _this4 = this;
      this.mentionContainer.style.position = "fixed";
      this.mentionContainer.style.height = null;
      var containerPos = this.quill.container.getBoundingClientRect();
      var mentionCharPos = this.quill.getBounds(this.mentionCharPos);
      var mentionCharPosAbsolute = {
        left: containerPos.left + mentionCharPos.left,
        top: containerPos.top + mentionCharPos.top,
        width: 0,
        height: mentionCharPos.height
      };
      var relativeToPos = this.options.fixMentionsToQuill ? containerPos : mentionCharPosAbsolute;
      var topPos = this.options.offsetTop;
      var leftPos = this.options.offsetLeft;
      if (this.options.fixMentionsToQuill) {
        var rightPos = relativeToPos.right;
        this.mentionContainer.style.right = "".concat(rightPos, "px");
      } else {
        leftPos += relativeToPos.left;
        if (leftPos + this.mentionContainer.offsetWidth > document.documentElement.clientWidth) {
          leftPos -= leftPos + this.mentionContainer.offsetWidth - document.documentElement.clientWidth;
        }
      }
      var availableSpaceTop = relativeToPos.top;
      var availableSpaceBottom = document.documentElement.clientHeight - (relativeToPos.top + relativeToPos.height);
      var fitsBottom = this.mentionContainer.offsetHeight <= availableSpaceBottom;
      var fitsTop = this.mentionContainer.offsetHeight <= availableSpaceTop;
      var placement;
      if (this.options.defaultMenuOrientation === "top" && fitsTop) {
        placement = "top";
      } else if (this.options.defaultMenuOrientation === "bottom" && fitsBottom) {
        placement = "bottom";
      } else {
        placement = availableSpaceBottom > availableSpaceTop ? "bottom" : "top";
      }
      if (placement === "bottom") {
        topPos = relativeToPos.top + relativeToPos.height;
        if (!fitsBottom) {
          this.mentionContainer.style.height = availableSpaceBottom - 3 + "px";
        }
        this.options.mentionContainerClass.split(" ").forEach(function(className) {
          _this4.mentionContainer.classList.add("".concat(className, "-bottom"));
          _this4.mentionContainer.classList.remove("".concat(className, "-top"));
        });
      } else {
        topPos = relativeToPos.top - this.mentionContainer.offsetHeight;
        if (!fitsTop) {
          this.mentionContainer.style.height = availableSpaceTop - 3 + "px";
          topPos = 3;
        }
        this.options.mentionContainerClass.split(" ").forEach(function(className) {
          _this4.mentionContainer.classList.add("".concat(className, "-top"));
          _this4.mentionContainer.classList.remove("".concat(className, "-bottom"));
        });
      }
      this.mentionContainer.style.top = "".concat(topPos, "px");
      this.mentionContainer.style.left = "".concat(leftPos, "px");
      this.mentionContainer.style.visibility = "visible";
    }
  }, {
    key: "getTextBeforeCursor",
    value: function getTextBeforeCursor() {
      var startPos = Math.max(0, this.cursorPos - this.options.maxChars);
      var textBeforeCursorPos = this.quill.getText(startPos, this.cursorPos - startPos);
      return textBeforeCursorPos;
    }
  }, {
    key: "onSomethingChange",
    value: function onSomethingChange() {
      var _this5 = this;
      var range2 = this.quill.getSelection();
      if (range2 == null)
        return;
      this.cursorPos = range2.index;
      var textBeforeCursor = this.getTextBeforeCursor();
      var _getMentionCharIndex = getMentionCharIndex(textBeforeCursor, this.options.mentionDenotationChars), mentionChar = _getMentionCharIndex.mentionChar, mentionCharIndex = _getMentionCharIndex.mentionCharIndex;
      if (hasValidMentionCharIndex(mentionCharIndex, textBeforeCursor, this.options.isolateCharacter)) {
        var mentionCharPos = this.cursorPos - (textBeforeCursor.length - mentionCharIndex);
        this.mentionCharPos = mentionCharPos;
        var textAfter = textBeforeCursor.substring(mentionCharIndex + mentionChar.length);
        if (textAfter.length >= this.options.minChars && hasValidChars(textAfter, this.getAllowedCharsRegex(mentionChar))) {
          if (this.existingSourceExecutionToken) {
            this.existingSourceExecutionToken.abandoned = true;
          }
          this.renderLoading();
          var sourceRequestToken = {
            abandoned: false
          };
          this.existingSourceExecutionToken = sourceRequestToken;
          this.options.source(textAfter, function(data, searchTerm) {
            if (sourceRequestToken.abandoned) {
              return;
            }
            _this5.existingSourceExecutionToken = null;
            _this5.renderList(mentionChar, data, searchTerm);
          }, mentionChar);
        } else {
          if (this.existingSourceExecutionToken) {
            this.existingSourceExecutionToken.abandoned = true;
          }
          this.hideMentionList();
        }
      } else {
        if (this.existingSourceExecutionToken) {
          this.existingSourceExecutionToken.abandoned = true;
        }
        this.hideMentionList();
      }
    }
  }, {
    key: "getAllowedCharsRegex",
    value: function getAllowedCharsRegex(denotationChar) {
      if (this.options.allowedChars instanceof RegExp) {
        return this.options.allowedChars;
      } else {
        return this.options.allowedChars(denotationChar);
      }
    }
  }, {
    key: "onTextChange",
    value: function onTextChange(delta, oldDelta, source) {
      if (source === "user") {
        this.onSomethingChange();
      }
    }
  }, {
    key: "onSelectionChange",
    value: function onSelectionChange(range2) {
      if (range2 && range2.length === 0) {
        this.onSomethingChange();
      } else {
        this.hideMentionList();
      }
    }
  }, {
    key: "openMenu",
    value: function openMenu(denotationChar) {
      var selection = this.quill.getSelection(true);
      this.quill.insertText(selection.index, denotationChar);
      this.quill.blur();
      this.quill.focus();
    }
  }]);
  return Mention2;
}();
Quill.register("modules/mention", Mention);
const quill_mention = "";
const accessibleDependencies = (componentIndices, code) => {
  let dependencies = [];
  if (!componentIndices) {
    return dependencies;
  }
  let componentIndex = componentIndices.find(
    (element) => element.code === code
  );
  if (!componentIndex) {
    return dependencies;
  }
  if (componentIndex.parent) {
    let componentParents = parents$1(componentIndices, componentIndex);
    componentParents.forEach((element) => {
      dependencies = dependencies.concat(
        accessibleSiblings$1(componentIndices, element)
      );
    });
  }
  if (isGroup(componentIndex.code) || isQuestion(componentIndex.code)) {
    dependencies = dependencies.concat(
      accessibleSiblings$1(componentIndices, componentIndex)
    );
  }
  return dependencies;
};
const parents$1 = (componentIndices, componentIndex) => {
  let result = [];
  let parent2 = componentIndices.find(
    (element) => element.code === componentIndex.parent
  );
  if (parent2 && parent2.parent) {
    result.push(parent2);
    result = result.concat(parents$1(componentIndices, parent2));
  }
  return result;
};
const accessibleSiblings$1 = (componentIndices, componentIndex) => {
  let result = [];
  if (!isGroup(componentIndex.code) && !isQuestion(componentIndex.code)) {
    return result;
  }
  let accessibleSiblings2 = componentIndices.filter((elem) => {
    return elem.parent === componentIndex.parent && elem.maxIndex < componentIndex.minIndex && (!componentIndex.prioritisedSiblings || componentIndex.prioritisedSiblings.indexOf(elem.code) === -1);
  });
  accessibleSiblings2.forEach((sibling) => {
    result = result.concat(sibling.code);
    result = result.concat(childrenDependencies$1(componentIndices, sibling));
  });
  return result;
};
const childrenDependencies$1 = (componentIndices, componentIndex) => {
  let result = [];
  if (!isGroup(componentIndex.code)) {
    return result;
  }
  if (componentIndex.children) {
    componentIndex.children.forEach((childCode) => {
      let child = componentIndices.find(
        (element) => element.code === childCode
      );
      result = result.concat(child.code);
      result = result.concat(childrenDependencies$1(componentIndices, child));
    });
  }
  return result;
};
const buildReferences = (componentIndices, code, state, mainLang) => {
  let dependencies = accessibleDependencies(componentIndices, code);
  let returnResult = [];
  dependencies.forEach((el) => {
    if (isQuestion(el)) {
      const reference = buildReference(el, state[el], state, mainLang);
      if (reference.length) {
        returnResult = returnResult.concat(reference);
      }
    }
  });
  return returnResult;
};
const buildReference = (code, component, state, mainLang) => {
  var _a, _b;
  const label2 = code + ". " + stripTags((_b = (_a = component.content) == null ? void 0 : _a.label) == null ? void 0 : _b[mainLang]);
  let instruction = "";
  let type2 = component.type;
  switch (component.type) {
    case "scq_array":
      return component.children.filter((el) => el.type == "row").map((element) => {
        var _a2, _b2;
        return {
          value: label2 + " - " + code + ". " + stripTags(
            (_b2 = (_a2 = state[element.qualifiedCode].content) == null ? void 0 : _a2.label) == null ? void 0 : _b2[mainLang]
          ),
          id: code + element.code,
          type: "SCQ Array Row",
          instruction: code + element.code + ".masked_value"
        };
      });
    case "text":
      type2 = "Short Text";
      instruction = `${code}.value`;
      break;
    case "nps":
      type2 = "NPS";
      instruction = `${code}.value`;
      break;
    case "email":
      type2 = "Email";
      instruction = `${code}.value`;
      break;
    case "paragraph":
      instruction = `${code}.value`;
      type2 = "Long Text";
      break;
    case "number":
      type2 = "Number";
      instruction = `${code}.value`;
      break;
    case "date":
      type2 = "Date";
      instruction = `${code}.masked_value`;
      break;
    case "time":
      type2 = "time";
      instruction = `${code}.masked_value`;
      break;
    case "date_time":
      type2 = "Date Time";
      instruction = `${code}.masked_value`;
      break;
    case "scq":
      type2 = "SCQ";
      instruction = `${code}.masked_value`;
      break;
    case "image_scq":
      type2 = "Image SCQ";
      instruction = `${code}.masked_value`;
      break;
    case "mcq":
      type2 = "MCQ";
      instruction = `${code}.masked_value`;
      break;
    case "image_mcq":
      type2 = "Image MCQ";
      instruction = `${code}.masked_value`;
      break;
    default:
      return [];
  }
  return [{ id: code, instruction, value: label2, type: type2 }];
};
lib$1.Quill.register("modules/mentions", Mention);
function DraftEditor({ value, onBlurListener, extended, isRtl, lang: lang2, code }) {
  console.log("DraftEditor for: " + code);
  const oneLine = (value2, oneLine2) => {
    return !oneLine2 ? value2 : "<p>" + value2.replace(/<br>/gi, "").replace(/<p>/gi, "").replace(/<\/p>/, "") + "</p>";
  };
  const editor = React.createRef();
  const [state, setState] = reactExports.useState(oneLine(value, !extended));
  const [lastFocus, setLastFocus] = reactExports.useState(0);
  async function references(searchTerm) {
    const designState = designStore.getState().designState;
    const values = buildReferences(
      designState.componentIndex,
      code,
      designState,
      designState.langInfo.mainLang
    );
    if (searchTerm.length === 0) {
      return values;
    } else {
      const matches = [];
      for (var i2 = 0; i2 < values.length; i2++) {
        if (values[i2].value.toLowerCase().indexOf(searchTerm.toLowerCase()) >= 0) {
          matches.push(values[i2]);
        }
      }
      return matches;
    }
  }
  reactExports.useEffect(() => {
    const quill2 = editor.current.getEditor();
    quill2.setSelection(quill2.getLength(), 0);
  }, [editor.current]);
  const modules = reactExports.useMemo(() => {
    return {
      mention: {
        dataAttributes: ["instruction", "type"],
        isolateCharacter: true,
        allowedChars: /[^\p{L}\p{N}]*$/,
        mentionDenotationChars: ["@"],
        showDenotationChar: false,
        onSelect: function(item, insertItem) {
          insertItem({ ...item, value: `{{${item.id}:${item.type}}}` });
        },
        source: async function(searchTerm, renderList) {
          const values = await references(searchTerm);
          renderList(values);
        }
      },
      toolbar: {
        container: extended ? [
          ["bold", "italic", "underline", "strike", "link"],
          [
            { list: "ordered" },
            { list: "bullet" },
            { indent: "-1" },
            { indent: "+1" }
          ],
          [{ color: [] }, { background: [] }],
          ["clean"]
        ] : [
          ["bold", "italic", "underline", "strike", "link"],
          [{ color: [] }, { background: [] }],
          ["clean"]
        ]
      }
    };
  }, []);
  const formats = [
    "bold",
    "italic",
    "underline",
    "strike",
    "direction",
    "list",
    "bullet",
    "indent",
    "color",
    "background",
    "mention",
    "link"
  ];
  let timeoutID = null;
  const onFocus = () => {
    setLastFocus(Date.now());
    timeoutID && clearTimeout(timeoutID);
  };
  const onBlur = () => {
    if (Date.now() - lastFocus > 100) {
      timeoutID = setTimeout(() => {
        onBlurListener(state, lang2);
      }, 100);
    }
  };
  const onChange = (value2) => {
    onFocus();
    setState(oneLine(value2, !extended));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onFocus, onBlur, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ReactQuill$1,
    {
      className: isRtl ? "rtl" : "ltr",
      theme: "snow",
      ref: editor,
      modules,
      formats,
      value: state,
      onChange
    }
  ) });
}
const DraftEditor$1 = React.memo(DraftEditor);
function ContentEditor$1({ placeholder: placeholder2, extended, contentKey, code, onActive }) {
  console.log("ContentEditor for : " + code);
  const dispatch = useDispatch();
  const content = useSelector((state) => {
    var _a;
    return (_a = state.designState[code].content) == null ? void 0 : _a[contentKey];
  });
  const langInfo = useSelector((state) => {
    return state.designState.langInfo;
  });
  const lang2 = langInfo.lang;
  const mainLang = langInfo.mainLang;
  const onMainLang = langInfo.mainLang == langInfo.lang;
  const value = (content == null ? void 0 : content[lang2]) || "";
  const finalPlaceholder = onMainLang ? placeholder2 : (content == null ? void 0 : content[mainLang]) || placeholder2;
  const [isActive, setActive] = reactExports.useState(false);
  const OnEditorBlurred = (text, editorLang) => {
    setActive(false);
    if (lang2 != editorLang) {
      return;
    } else if (text != value) {
      dispatch(changeContent({ code, key: contentKey, lang: lang2, value: text }));
    }
  };
  const onContainerClicked = (event) => {
    event.preventDefault();
    setActive(true);
    onActive();
  };
  const isRtl = rtlLanguage.includes(lang2);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      className: styles$G.fullWidth,
      onClick: (e2) => {
        onContainerClicked(e2);
      },
      children: isActive ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        DraftEditor$1,
        {
          lang: lang2,
          isRtl,
          code,
          extended,
          onBlurListener: OnEditorBlurred,
          value
        }
      ) : /[^<br><p><\/p>\s]/gm.test(value) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: `${isRtl ? "rtl" : "ltr"} ql-editor ${styles$G.noPadding}`,
          dangerouslySetInnerHTML: { __html: value }
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: `${isRtl ? "rtl" : "ltr"} ql-editor ${styles$G.placeholder}`,
          dangerouslySetInnerHTML: { __html: finalPlaceholder }
        }
      )
    }
  );
}
const ContentEditor$2 = React.memo(ContentEditor$1);
const questionItem$2 = "_questionItem_1sx0f_1";
const styles$F = {
  questionItem: questionItem$2
};
function FileUploadQuestionDesign({ code }) {
  var _a, _b;
  const theme = useTheme();
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const lang2 = useSelector((state2) => {
    return state2.designState.langInfo.lang;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$F.questionItem, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    TextField,
    {
      variant: "standard",
      required: ((_b = (_a = state.validation) == null ? void 0 : _a.validation_required) == null ? void 0 : _b.isActive) ? true : false,
      label: state.showHint && state.content.hint ? state.content.hint[lang2] : "",
      InputProps: {
        sx: {
          fontFamily: theme.textStyles.text.font,
          color: theme.textStyles.text.color,
          fontSize: theme.textStyles.text.size
        }
      },
      value: "",
      type: "file",
      disabled: true
    }
  ) });
}
const questionItem$1 = "_questionItem_1sx0f_1";
const styles$E = {
  questionItem: questionItem$1
};
function DateTimeQuestionDesign({ code }) {
  var _a, _b;
  const theme = useTheme();
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const lang2 = useSelector((state2) => {
    return state2.designState.langInfo.lang;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$E.questionItem, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    TextField,
    {
      disabled: true,
      variant: "standard",
      required: ((_b = (_a = state.validation) == null ? void 0 : _a.validation_required) == null ? void 0 : _b.isActive) ? true : false,
      label: state.showHint && state.content.hint ? state.content.hint[lang2] : "",
      value: "",
      InputProps: {
        sx: {
          fontFamily: theme.textStyles.text,
          color: theme.textStyles.text.color,
          fontSize: theme.textStyles.text.size
        }
      },
      placeholder: state.dateFormat
    }
  ) });
}
const questionItem = "_questionItem_wb37f_1";
const styles$D = {
  questionItem
};
function TimeQuestionDesign({ code }) {
  var _a, _b;
  const theme = useTheme();
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const lang2 = useSelector((state2) => {
    return state2.designState.langInfo.lang;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$D.questionItem, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    TextField,
    {
      disabled: true,
      variant: "standard",
      required: ((_b = (_a = state.validation) == null ? void 0 : _a.validation_required) == null ? void 0 : _b.isActive) ? true : false,
      label: state.showHint && state.content.hint ? state.content.hint[lang2] : "",
      value: "",
      type: "time",
      InputProps: {
        sx: {
          fontFamily: theme.textStyles.text.font,
          color: theme.textStyles.text.color,
          fontSize: theme.textStyles.text.size
        }
      }
    }
  ) });
}
const answerAdd$1 = "_answerAdd_1mqlf_1";
const answerIcon$2 = "_answerIcon_1mqlf_7";
const styles$C = {
  answerAdd: answerAdd$1,
  answerIcon: answerIcon$2
};
var RadioButtonUnchecked = {};
var _interopRequireDefault$v = interopRequireDefaultExports;
Object.defineProperty(RadioButtonUnchecked, "__esModule", {
  value: true
});
var default_1$n = RadioButtonUnchecked.default = void 0;
var _createSvgIcon$n = _interopRequireDefault$v(requireCreateSvgIcon());
var _jsxRuntime$n = jsxRuntimeExports;
var _default$q = (0, _createSvgIcon$n.default)(/* @__PURE__ */ (0, _jsxRuntime$n.jsx)("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
}), "RadioButtonUnchecked");
default_1$n = RadioButtonUnchecked.default = _default$q;
var CheckBoxOutlineBlank = {};
var _interopRequireDefault$u = interopRequireDefaultExports;
Object.defineProperty(CheckBoxOutlineBlank, "__esModule", {
  value: true
});
var default_1$m = CheckBoxOutlineBlank.default = void 0;
var _createSvgIcon$m = _interopRequireDefault$u(requireCreateSvgIcon());
var _jsxRuntime$m = jsxRuntimeExports;
var _default$p = (0, _createSvgIcon$m.default)(/* @__PURE__ */ (0, _jsxRuntime$m.jsx)("path", {
  d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
}), "CheckBoxOutlineBlank");
default_1$m = CheckBoxOutlineBlank.default = _default$p;
const answerItem = "_answerItem_1h53l_1";
const answerIcon$1 = "_answerIcon_1h53l_8";
const answerIconOther = "_answerIconOther_1h53l_16";
const answerNumberOrder$1 = "_answerNumberOrder_1h53l_25";
const answerControl = "_answerControl_1h53l_30";
const answerControlRtl = "_answerControlRtl_1h53l_35";
const answerControlOther = "_answerControlOther_1h53l_40";
const answerControlOtherRtl = "_answerControlOtherRtl_1h53l_45";
const answerOtherControl = "_answerOtherControl_1h53l_50";
const styles$B = {
  answerItem,
  answerIcon: answerIcon$1,
  answerIconOther,
  answerNumberOrder: answerNumberOrder$1,
  answerControl,
  answerControlRtl,
  answerControlOther,
  answerControlOtherRtl,
  answerOtherControl
};
var DragIndicator = {};
var _interopRequireDefault$t = interopRequireDefaultExports;
Object.defineProperty(DragIndicator, "__esModule", {
  value: true
});
var default_1$l = DragIndicator.default = void 0;
var _createSvgIcon$l = _interopRequireDefault$t(requireCreateSvgIcon());
var _jsxRuntime$l = jsxRuntimeExports;
var _default$o = (0, _createSvgIcon$l.default)(/* @__PURE__ */ (0, _jsxRuntime$l.jsx)("path", {
  d: "M11 18c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zm-2-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
}), "DragIndicator");
default_1$l = DragIndicator.default = _default$o;
var Close = {};
var _interopRequireDefault$s = interopRequireDefaultExports;
Object.defineProperty(Close, "__esModule", {
  value: true
});
var default_1$k = Close.default = void 0;
var _createSvgIcon$k = _interopRequireDefault$s(requireCreateSvgIcon());
var _jsxRuntime$k = jsxRuntimeExports;
var _default$n = (0, _createSvgIcon$k.default)(/* @__PURE__ */ (0, _jsxRuntime$k.jsx)("path", {
  d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Close");
default_1$k = Close.default = _default$n;
var Build = {};
var _interopRequireDefault$r = interopRequireDefaultExports;
Object.defineProperty(Build, "__esModule", {
  value: true
});
var default_1$j = Build.default = void 0;
var _createSvgIcon$j = _interopRequireDefault$r(requireCreateSvgIcon());
var _jsxRuntime$j = jsxRuntimeExports;
var _default$m = (0, _createSvgIcon$j.default)(/* @__PURE__ */ (0, _jsxRuntime$j.jsx)("path", {
  d: "m22.7 19-9.1-9.1c.9-2.3.4-5-1.5-6.9-2-2-5-2.4-7.4-1.3L9 6 6 9 1.6 4.7C.4 7.1.9 10.1 2.9 12.1c1.9 1.9 4.6 2.4 6.9 1.5l9.1 9.1c.4.4 1 .4 1.4 0l2.3-2.3c.5-.4.5-1.1.1-1.4z"
}), "Build");
default_1$j = Build.default = _default$m;
function ChoiceQuestionItem(props) {
  const dispatch = useDispatch();
  const theme = useTheme();
  const langInfo = useSelector((state) => {
    return state.designState.langInfo;
  });
  const answer = useSelector((state) => {
    return state.designState[props.qualifiedCode];
  });
  const onMainLang = langInfo.lang === langInfo.mainLang;
  const lang2 = langInfo.lang;
  const isRtl = rtlLanguage.includes(lang2);
  const isInSetup = useSelector((state) => {
    var _a;
    return answer.type === "other" && ((_a = state.designState.setup) == null ? void 0 : _a.code) == props.qualifiedCode + "Atext";
  });
  const content = useSelector((state) => {
    var _a, _b;
    return (_b = (_a = state.designState[props.qualifiedCode].content) == null ? void 0 : _a["label"]) == null ? void 0 : _b[lang2];
  });
  const mainContent = useSelector((state) => {
    var _a, _b;
    return (_b = (_a = state.designState[props.qualifiedCode].content) == null ? void 0 : _a["label"]) == null ? void 0 : _b[langInfo.mainLang];
  });
  const renderIconByType = (type2) => {
    switch (type2) {
      case "radio":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          default_1$n,
          {
            className: styles$B.answerIcon,
            sx: { fontSize: 18, color: grey[600] }
          }
        );
      case "checkbox":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          default_1$m,
          {
            className: styles$B.answerIcon,
            sx: { fontSize: 18, color: grey[600] }
          }
        );
      case "numberOrder":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: styles$B.answerNumberOrder,
            style: {
              fontFamily: theme.textStyles.text.font,
              color: theme.textStyles.text.color,
              fontSize: 18
            },
            children: props.code
          }
        );
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PublicDraggable, { draggableId: props.qualifiedCode, index: props.index, children: (provided) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: { backgroundColor: isInSetup ? "beige" : "inherit" },
      ref: provided.innerRef,
      ...provided.draggableProps,
      ...provided.dragHandleProps,
      className: styles$B.answerItem,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          default_1$l,
          {
            className: styles$B.answerIcon,
            sx: { fontSize: 18, color: grey[600] }
          }
        ),
        renderIconByType(props.type),
        props.label ? /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: props.label }) : "",
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            variant: "standard",
            className: answer.type === "other" && isRtl ? styles$B.answerControlOtherRtl : answer.type === "other" ? styles$B.answerControlOther : isRtl ? styles$B.answerControlRtl : styles$B.answerControl,
            value: content || "",
            onChange: (e2) => dispatch(
              changeContent({
                code: props.qualifiedCode,
                key: "label",
                lang: lang2,
                value: e2.target.value
              })
            ),
            placeholder: onMainLang ? "Option" : mainContent || "Option",
            InputProps: {
              sx: {
                fontFamily: theme.textStyles.text.font,
                color: theme.textStyles.text.color,
                fontSize: theme.textStyles.text.size
              }
            }
          }
        ),
        answer.type === "other" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          default_1$j,
          {
            sx: { fontSize: 18, color: grey[600] },
            className: styles$B.answerIconOther,
            onClick: () => {
              dispatch(
                setup({
                  code: props.qualifiedCode + "Atext",
                  rules: setupOptions("other_text")
                })
              );
            }
          },
          "setup"
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          default_1$k,
          {
            sx: { fontSize: 18, color: grey[600] },
            className: styles$B.answerIcon,
            onClick: (e2) => dispatch(removeAnswer(props.qualifiedCode))
          },
          "close"
        )
      ]
    }
  ) });
}
function ChoiceQuestion(props) {
  const theme = useTheme();
  const t2 = props.t;
  const children = useSelector((state) => {
    return state.designState[props.code].children;
  });
  const questionType = useSelector((state) => {
    return state.designState[props.code].type;
  });
  const isOther = (questionType == "mcq" || questionType == "scq") && (!children || !children.some((el) => el.code === "Aother"));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$C.questionItem, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ConnectedDroppable,
      {
        droppableId: `option-${props.code}`,
        type: `option-${props.code}`,
        children: (provided) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: provided.innerRef, ...provided.droppableProps, children: [
          children && children.length > 0 && children.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            ChoiceQuestionItem,
            {
              code: item.code,
              label: item.code,
              qualifiedCode: item.qualifiedCode,
              index: index2,
              type: props.type
            },
            item.code
          )),
          provided.placeholder
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$C.answerAdd, children: [
      props.type === "checkbox" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        default_1$m,
        {
          style: { fontSize: 18, color: grey[600] },
          className: styles$C.answerIcon
        }
      ) : props.type === "radio" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        default_1$n,
        {
          style: { fontSize: 18, color: grey[600] },
          className: styles$C.answerIcon
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        default_1$p,
        {
          style: { fontSize: 18, color: grey[600] },
          className: styles$C.answerIcon
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          size: "small",
          style: {
            fontFamily: theme.textStyles.text.font,
            fontSize: theme.textStyles.text.size
          },
          onClick: () => props.addNewAnswer(props.code, questionType),
          children: t2("add_option")
        }
      ),
      isOther && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("or") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            style: {
              fontFamily: theme.textStyles.text.font,
              fontSize: theme.textStyles.text.size
            },
            size: "small",
            className: styles$C.answerIcon,
            onClick: () => props.addNewAnswer(props.code, questionType, "other"),
            children: t2("add_other")
          }
        )
      ] })
    ] })
  ] });
}
const scqList = "_scqList_13vte_1";
const scqItem = "_scqItem_13vte_6";
const answerAdd = "_answerAdd_13vte_15";
const answerIcon = "_answerIcon_13vte_20";
const answerNumberOrder = "_answerNumberOrder_13vte_24";
const styles$A = {
  scqList,
  scqItem,
  answerAdd,
  answerIcon,
  answerNumberOrder
};
function SCQArray(props) {
  const theme = useTheme();
  const t2 = props.t;
  const rows = useSelector((state) => {
    var _a;
    return ((_a = state.designState[props.code].children) == null ? void 0 : _a.filter(
      (el) => el.type == "row"
    )) || [];
  });
  const columns = useSelector((state) => {
    var _a;
    return ((_a = state.designState[props.code].children) == null ? void 0 : _a.filter(
      (el) => el.type == "column"
    )) || [];
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$A.scqList, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectedDroppable, { droppableId: `row-${props.code}`, type: `row-${props.code}`, children: (provided) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        ref: provided.innerRef,
        ...provided.droppableProps,
        className: styles$A.scqItem,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { children: "Rows" }),
          rows && rows.map((item, index2) => {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              ChoiceQuestionItem,
              {
                code: item.code,
                index: index2,
                qualifiedCode: item.qualifiedCode,
                type: "numberOrder"
              },
              item.code
            );
          }),
          provided.placeholder,
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$A.answerAdd, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              sx: {
                fontFamily: theme.textStyles.text.font,
                fontSize: theme.textStyles.text.size
              },
              onClick: (e2) => props.addNewAnswer(props.code, props.type, "row"),
              children: t2("add_row")
            }
          ) })
        ]
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectedDroppable, { droppableId: `col-${props.code}`, type: `col-${props.code}`, children: (provided) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        ref: provided.innerRef,
        ...provided.droppableProps,
        className: styles$A.scqItem,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { children: "Columns" }),
          columns && columns.map((item, index2) => {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              ChoiceQuestionItem,
              {
                code: item.code,
                index: index2,
                qualifiedCode: item.qualifiedCode,
                type: "radio"
              },
              item.code
            );
          }),
          provided.placeholder,
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$A.answerAdd, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              sx: {
                fontFamily: theme.textStyles.text.font,
                fontSize: theme.textStyles.text.size
              },
              size: "small",
              onClick: (e2) => props.addNewAnswer(props.code, props.type, "column"),
              children: t2("add_column")
            }
          ) })
        ]
      }
    ) })
  ] });
}
const errorDisplay$3 = "_errorDisplay_1joy4_1";
const clickable = "_clickable_1joy4_10";
const styles$z = {
  errorDisplay: errorDisplay$3,
  clickable
};
var ErrorOutline = {};
var _interopRequireDefault$q = interopRequireDefaultExports;
Object.defineProperty(ErrorOutline, "__esModule", {
  value: true
});
var default_1$i = ErrorOutline.default = void 0;
var _createSvgIcon$i = _interopRequireDefault$q(requireCreateSvgIcon());
var _jsxRuntime$i = jsxRuntimeExports;
var _default$l = (0, _createSvgIcon$i.default)(/* @__PURE__ */ (0, _jsxRuntime$i.jsx)("path", {
  d: "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
}), "ErrorOutline");
default_1$i = ErrorOutline.default = _default$l;
function ErrorDisplay(props) {
  var _a;
  const { t: t2 } = useTranslation("design");
  const dispatch = useDispatch();
  const state = useSelector((state2) => {
    return state2.designState[props.code];
  });
  const errors = state.errors;
  const designErrors = state.designErrors;
  const instructions = (_a = state.instructionList) == null ? void 0 : _a.filter(
    (instructions2) => instructions2.errors
  );
  const hasErrors = (errors == null ? void 0 : errors.length) > 0 || (designErrors == null ? void 0 : designErrors.length) > 0 || (instructions == null ? void 0 : instructions.length) > 0;
  const type2 = useSelector((state2) => {
    var _a2;
    return props.code == "Survey" ? "" : isGroup(props.code) ? ((_a2 = state2.designState[props.code].groupType) == null ? void 0 : _a2.toLowerCase()) || "group" : state2.designState[props.code].type;
  });
  const onErrClick = (instruction) => {
    if (instruction.code === "conditional_relevance") {
      dispatch(
        setup({
          code: props.code,
          rules: setupOptions(type2),
          highlighted: "relevance",
          expanded: ["relevance"]
        })
      );
    } else if (instruction.code === "random_group" || instruction.code === "priority_groups") {
      if (props.code == "Survey") {
        dispatch(setup({ ...serveyRandomSetup, highlighted: "random" }));
      } else {
        dispatch(
          setup({
            code: props.code,
            rules: setupOptions(type2),
            highlighted: "random",
            expanded: ["random"]
          })
        );
      }
    } else if (instruction.code.startsWith("skip_to")) {
      dispatch(
        setup({
          code: props.code,
          rules: setupOptions(type2),
          highlighted: "skip_logic",
          expanded: ["skip_logic"]
        })
      );
    }
    return "";
  };
  const isClickable = (instruction) => {
    return instruction.code === "conditional_relevance" || instruction.code === "random_group" || instruction.code === "priority_groups" || instruction.code.startsWith("skip_to");
  };
  return hasErrors ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: styles$z.errorDisplay, children: [
    errors && errors.map((el) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$k, { style: { verticalAlign: "middle" } }),
        mapComponentError(props.code, el, t2)
      ] }, el);
    }),
    designErrors && designErrors.map((el) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$k, { style: { verticalAlign: "middle" } }),
        el.message
      ] }, el.code);
    }),
    instructions && instructions.map((el) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: isClickable(el) ? styles$z.clickable : "",
          onClick: () => onErrClick(el),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$i, { style: { verticalAlign: "middle" } }),
            mapInstructionError(el, t2)
          ]
        },
        el.code
      );
    })
  ] }) : "";
}
const mapComponentError = (code, error2, t2) => {
  if (error2 === "EMPTY_PARENT") {
    return t2("err_empty_parent", {
      component_name: componentName(code, t2),
      child_name: componentChildName(code, t2)
    });
  } else if (error2 === "DUPLICATE_CODE") {
    return t2("err_duplicate_code"), { component_name: componentName(code, t2) };
  } else if (error2 === "NO_END_GROUP") {
    return t2("err_no_end_group");
  } else if (error2 === "MISPLACED_END_GROUP") {
    return t2("err_misplaced_end_group");
  } else if (error2 === "MISPLACED_WELCOME_GROUP") {
    return t2("err_misplaced_welcome_group");
  }
  return "";
};
const mapInstructionError = (instruction, t2) => {
  if (instruction.code === "value" && instruction.errors[0].name == "InvalidInstructionInEndGroup") {
    return t2("err_value_in_end_group");
  } else if (instruction.code === "conditional_relevance") {
    return t2("err_relevance");
  } else if (instruction.code === "random_group") {
    return t2("err_random");
  } else if (instruction.code === "priority_groups") {
    return t2("err_priority");
  } else if (instruction.code.startsWith("reference")) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Trans,
      {
        t: t2,
        values: {
          codes: instruction.errors.map((error2) => error2.dependency.componentCode).join(", "),
          lang: instruction.lang
        },
        i18nKey: "err_reference"
      }
    );
  } else if (instruction.code.startsWith("skip_to")) {
    return t2("err_skip");
  }
  return "";
};
const componentName = (code, t2) => {
  if (code == "Survey") {
    return t2("survey");
  } else if (isQuestion(code)) {
    return t2("question");
  } else if (isGroup(code)) {
    return t2("group");
  }
  return t2("option");
};
const componentChildName = (code, t2) => {
  if (isGroup(code)) {
    return t2("question");
  } else if (code == "Survey") {
    return t2("group");
  }
  return t2("option");
};
const ErrorDisplay$1 = reactExports.memo(ErrorDisplay);
const actionControl = "_actionControl_1xa5v_1";
const statusIcon = "_statusIcon_1xa5v_8";
const questionContainer = "_questionContainer_1xa5v_12";
const actionIcon = "_actionIcon_1xa5v_16";
const settingIcon$2 = "_settingIcon_1xa5v_17";
const deleteIcon = "_deleteIcon_1xa5v_25";
const styles$y = {
  actionControl,
  statusIcon,
  questionContainer,
  actionIcon,
  settingIcon: settingIcon$2,
  deleteIcon
};
var DeleteOutline = {};
var _interopRequireDefault$p = interopRequireDefaultExports;
Object.defineProperty(DeleteOutline, "__esModule", {
  value: true
});
var default_1$h = DeleteOutline.default = void 0;
var _createSvgIcon$h = _interopRequireDefault$p(requireCreateSvgIcon());
var _jsxRuntime$h = jsxRuntimeExports;
var _default$k = (0, _createSvgIcon$h.default)(/* @__PURE__ */ (0, _jsxRuntime$h.jsx)("path", {
  d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM8 9h8v10H8V9zm7.5-5-1-1h-5l-1 1H5v2h14V4z"
}), "DeleteOutline");
default_1$h = DeleteOutline.default = _default$k;
var UnfoldLess = {};
var _interopRequireDefault$o = interopRequireDefaultExports;
Object.defineProperty(UnfoldLess, "__esModule", {
  value: true
});
var default_1$g = UnfoldLess.default = void 0;
var _createSvgIcon$g = _interopRequireDefault$o(requireCreateSvgIcon());
var _jsxRuntime$g = jsxRuntimeExports;
var _default$j = (0, _createSvgIcon$g.default)(/* @__PURE__ */ (0, _jsxRuntime$g.jsx)("path", {
  d: "M7.41 18.59 8.83 20 12 16.83 15.17 20l1.41-1.41L12 14l-4.59 4.59zm9.18-13.18L15.17 4 12 7.17 8.83 4 7.41 5.41 12 10l4.59-4.59z"
}), "UnfoldLess");
default_1$g = UnfoldLess.default = _default$j;
var UnfoldMore = {};
var _interopRequireDefault$n = interopRequireDefaultExports;
Object.defineProperty(UnfoldMore, "__esModule", {
  value: true
});
var default_1$f = UnfoldMore.default = void 0;
var _createSvgIcon$f = _interopRequireDefault$n(requireCreateSvgIcon());
var _jsxRuntime$f = jsxRuntimeExports;
var _default$i = (0, _createSvgIcon$f.default)(/* @__PURE__ */ (0, _jsxRuntime$f.jsx)("path", {
  d: "M12 5.83 15.17 9l1.41-1.41L12 3 7.41 7.59 8.83 9 12 5.83zm0 12.34L8.83 15l-1.41 1.41L12 21l4.59-4.59L15.17 15 12 18.17z"
}), "UnfoldMore");
default_1$f = UnfoldMore.default = _default$i;
var Visibility = {};
var _interopRequireDefault$m = interopRequireDefaultExports;
Object.defineProperty(Visibility, "__esModule", {
  value: true
});
var default_1$e = Visibility.default = void 0;
var _createSvgIcon$e = _interopRequireDefault$m(requireCreateSvgIcon());
var _jsxRuntime$e = jsxRuntimeExports;
var _default$h = (0, _createSvgIcon$e.default)(/* @__PURE__ */ (0, _jsxRuntime$e.jsx)("path", {
  d: "M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"
}), "Visibility");
default_1$e = Visibility.default = _default$h;
var Verified = {};
var _interopRequireDefault$l = interopRequireDefaultExports;
Object.defineProperty(Verified, "__esModule", {
  value: true
});
var default_1$d = Verified.default = void 0;
var _createSvgIcon$d = _interopRequireDefault$l(requireCreateSvgIcon());
var _jsxRuntime$d = jsxRuntimeExports;
var _default$g = (0, _createSvgIcon$d.default)(/* @__PURE__ */ (0, _jsxRuntime$d.jsx)("path", {
  d: "m23 12-2.44-2.79.34-3.69-3.61-.82-1.89-3.2L12 2.96 8.6 1.5 6.71 4.69 3.1 5.5l.34 3.7L1 12l2.44 2.79-.34 3.7 3.61.82L8.6 22.5l3.4-1.47 3.4 1.46 1.89-3.19 3.61-.82-.34-3.69L23 12zm-12.91 4.72-3.8-3.81 1.48-1.48 2.32 2.33 5.85-5.87 1.48 1.48-7.33 7.35z"
}), "Verified");
default_1$d = Verified.default = _default$g;
var Shuffle = {};
var _interopRequireDefault$k = interopRequireDefaultExports;
Object.defineProperty(Shuffle, "__esModule", {
  value: true
});
var default_1$c = Shuffle.default = void 0;
var _createSvgIcon$c = _interopRequireDefault$k(requireCreateSvgIcon());
var _jsxRuntime$c = jsxRuntimeExports;
var _default$f = (0, _createSvgIcon$c.default)(/* @__PURE__ */ (0, _jsxRuntime$c.jsx)("path", {
  d: "M10.59 9.17 5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z"
}), "Shuffle");
default_1$c = Shuffle.default = _default$f;
var LowPriority = {};
var _interopRequireDefault$j = interopRequireDefaultExports;
Object.defineProperty(LowPriority, "__esModule", {
  value: true
});
var default_1$b = LowPriority.default = void 0;
var _createSvgIcon$b = _interopRequireDefault$j(requireCreateSvgIcon());
var _jsxRuntime$b = jsxRuntimeExports;
var _default$e = (0, _createSvgIcon$b.default)(/* @__PURE__ */ (0, _jsxRuntime$b.jsx)("path", {
  d: "M14 5h8v2h-8zm0 5.5h8v2h-8zm0 5.5h8v2h-8zM2 11.5C2 15.08 4.92 18 8.5 18H9v2l3-3-3-3v2h-.5C6.02 16 4 13.98 4 11.5S6.02 7 8.5 7H12V5H8.5C4.92 5 2 7.92 2 11.5z"
}), "LowPriority");
default_1$b = LowPriority.default = _default$e;
var MoveDown = {};
var _interopRequireDefault$i = interopRequireDefaultExports;
Object.defineProperty(MoveDown, "__esModule", {
  value: true
});
var default_1$a = MoveDown.default = void 0;
var _createSvgIcon$a = _interopRequireDefault$i(requireCreateSvgIcon());
var _jsxRuntime$a = jsxRuntimeExports;
var _default$d = (0, _createSvgIcon$a.default)(/* @__PURE__ */ (0, _jsxRuntime$a.jsx)("path", {
  d: "M3 11c0 2.45 1.76 4.47 4.08 4.91l-1.49-1.49L7 13l4 4.01L7 21l-1.41-1.41 1.58-1.58v-.06C3.7 17.54 1 14.58 1 11c0-3.87 3.13-7 7-7h3v2H8c-2.76 0-5 2.24-5 5zm19 0V4h-9v7h9zm-2-2h-5V6h5v3zm-7 4h9v7h-9z"
}), "MoveDown");
default_1$a = MoveDown.default = _default$d;
function ActionToolbar({
  code,
  isGroup: isGroup2,
  parentCode,
  collapsed,
  toggleCollapse,
  disableDelete,
  onDelete,
  onClone,
  t: t2
}) {
  const dispatch = useDispatch();
  const type2 = useSelector((state) => {
    var _a;
    return isGroup2 ? ((_a = state.designState[code].groupType) == null ? void 0 : _a.toLowerCase()) || "group" : state.designState[code].type;
  });
  const hasRelevance = useSelector((state) => {
    var _a, _b;
    let instruction = (_b = (_a = state.designState[code]) == null ? void 0 : _a.instructionList) == null ? void 0 : _b.find(
      (el) => el.code == "conditional_relevance"
    );
    return typeof instruction !== "undefined" && !instruction.errors;
  });
  const hasValidation = useSelector((state) => {
    var _a, _b, _c;
    return !isGroup2 && ((_c = (_b = (_a = state.designState[code]) == null ? void 0 : _a.instructionList) == null ? void 0 : _b.filter(
      (el) => el.code.startsWith("validation_") && !el.errors
    )) == null ? void 0 : _c.length) > 0;
  });
  const setSetup = () => {
    dispatch(setup({ code, rules: setupOptions(type2) }));
  };
  const expandRelevance = () => {
    dispatch(
      setup({
        code,
        rules: setupOptions(type2),
        highlighted: "relevance",
        expanded: ["relevance"]
      })
    );
  };
  const expandValidation = () => {
    dispatch(
      setup({
        code,
        rules: setupOptions(type2),
        highlighted: "validation",
        expanded: ["validation"]
      })
    );
  };
  const expandSkipLogic = () => {
    dispatch(
      setup({
        code,
        rules: setupOptions(type2),
        highlighted: "skip_logic",
        expanded: ["skip_logic"]
      })
    );
  };
  const expandParentRandom = () => {
    if (isGroup2) {
      dispatch(setup({ ...serveyRandomSetup, highlighted: "random" }));
    } else {
      dispatch(
        setup({
          code: parentCode,
          rules: setupOptions("group"),
          highlighted: "random",
          expanded: ["random"]
        })
      );
    }
  };
  const hasSkip = useSelector((state) => {
    var _a, _b, _c;
    let skipInstructions = (_b = (_a = state.designState[code]) == null ? void 0 : _a.instructionList) == null ? void 0 : _b.filter(
      (el) => el.code.startsWith("skip_to")
    );
    return ((_c = skipInstructions == null ? void 0 : skipInstructions.filter((el) => !el.errors)) == null ? void 0 : _c.length) >= 1;
  });
  const isRandomized = useSelector((state) => {
    var _a;
    let indexObj = (_a = state.designState.componentIndex) == null ? void 0 : _a.find(
      (el) => el.code == code
    );
    return indexObj && indexObj.minIndex != indexObj.maxIndex;
  });
  const isPrioritised = useSelector((state) => {
    var _a, _b;
    let indexObj = (_a = state.designState.componentIndex) == null ? void 0 : _a.find(
      (el) => el.code == code
    );
    return ((_b = indexObj == null ? void 0 : indexObj.prioritisedSiblings) == null ? void 0 : _b.length) > 0;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$y.actionControl, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: toggleCollapse, children: collapsed ? /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$f, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$g, {}) }),
    hasRelevance && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$1, { title: "Has show/Hide Condition", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      IconButton,
      {
        className: styles$y.statusIcon,
        onClick: () => expandRelevance(),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$e, {})
      }
    ) }),
    hasValidation && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$1, { title: "Has Validation", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      IconButton,
      {
        className: styles$y.statusIcon,
        onClick: () => expandValidation(),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$d, {})
      }
    ) }),
    isRandomized && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$1, { title: "Is part of a valid Random Group (within parent)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      IconButton,
      {
        className: styles$y.statusIcon,
        onClick: () => expandParentRandom(),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$c, {})
      }
    ) }),
    isPrioritised && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$1, { title: "Is part of a valid Priority Group (within parent)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      IconButton,
      {
        className: styles$y.statusIcon,
        onClick: () => expandParentRandom(),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$b, {})
      }
    ) }),
    hasSkip && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip$1, { title: "Has active Skip Logic", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      IconButton,
      {
        className: styles$y.statusIcon,
        onClick: () => expandSkipLogic(),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$a, {})
      }
    ) }),
    type2 != "welcome" && type2 != "end" && /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: () => setSetup(), children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$j, { className: styles$y.settingIcon }) }),
    !isGroup2 && /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: () => onClone(), children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$q, { className: styles$y.actionIcon }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IconButton,
      {
        onClick: () => {
          if (window.confirm(t2("are_you_sure"))) {
            onDelete();
          }
        },
        disabled: disableDelete,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$h, { className: styles$y.deleteIcon })
      }
    )
  ] }) });
}
const addAnswerIcon$1 = "_addAnswerIcon_1fnbz_1";
const addAnswerButton$1 = "_addAnswerButton_1fnbz_5";
const styles$x = {
  addAnswerIcon: addAnswerIcon$1,
  addAnswerButton: addAnswerButton$1
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
function __values(o) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o[s2], i2 = 0;
  if (m2)
    return m2.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i2 >= o.length)
          o = void 0;
        return { value: o && o[i2++], done: !o };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i2 = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error2) {
    e2 = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
    ar = ar.concat(__read(arguments[i2]));
  return ar;
}
function getDragPosition(index2, grid, dx, dy, center) {
  var _a = __read(getPositionForIndex(index2, grid).xy, 2), left = _a[0], top = _a[1];
  return {
    xy: [
      left + dx + (center ? grid.columnWidth / 2 : 0),
      top + dy + (center ? grid.rowHeight / 2 : 0)
    ]
  };
}
function getPositionForIndex(i2, _a, traverseIndex) {
  var boxesPerRow = _a.boxesPerRow, rowHeight = _a.rowHeight, columnWidth = _a.columnWidth;
  var index2 = typeof traverseIndex == "number" ? i2 >= traverseIndex ? i2 + 1 : i2 : i2;
  var x = index2 % boxesPerRow * columnWidth;
  var y2 = Math.floor(index2 / boxesPerRow) * rowHeight;
  return {
    xy: [x, y2]
  };
}
function getIndexFromCoordinates(x, y2, _a, count) {
  var rowHeight = _a.rowHeight, boxesPerRow = _a.boxesPerRow, columnWidth = _a.columnWidth;
  var index2 = Math.floor(y2 / rowHeight) * boxesPerRow + Math.floor(x / columnWidth);
  return index2 >= count ? count : index2;
}
function getTargetIndex(startIndex, grid, count, dx, dy) {
  var _a = __read(getDragPosition(startIndex, grid, dx, dy, true).xy, 2), cx = _a[0], cy = _a[1];
  return getIndexFromCoordinates(cx, cy, grid, count);
}
var noop = function() {
  throw new Error("Make sure that you have wrapped your drop zones with GridContext");
};
var GridContext = reactExports.createContext({
  register: noop,
  remove: noop,
  getActiveDropId: noop,
  startTraverse: noop,
  measureAll: noop,
  traverse: null,
  endTraverse: noop,
  onChange: noop
});
function GridContextProvider(_a) {
  var children = _a.children, onChange = _a.onChange;
  var _b = __read(reactExports.useState(null), 2), traverse = _b[0], setTraverse = _b[1];
  var dropRefs = reactExports.useRef(/* @__PURE__ */ new Map());
  function register(id, options) {
    dropRefs.current.set(id, options);
  }
  function remove(id) {
    dropRefs.current.delete(id);
  }
  function getFixedPosition(sourceId, rx, ry) {
    var item = dropRefs.current.get(sourceId);
    if (!item) {
      return {
        x: rx,
        y: ry
      };
    }
    var left = item.left, top = item.top;
    return {
      x: left + rx,
      y: top + ry
    };
  }
  function getRelativePosition(targetId, fx, fy) {
    var _a2 = dropRefs.current.get(targetId), left = _a2.left, top = _a2.top;
    return {
      x: fx - left,
      y: fy - top
    };
  }
  function diffDropzones(sourceId, targetId) {
    var sBounds = dropRefs.current.get(sourceId);
    var tBounds = dropRefs.current.get(targetId);
    return {
      x: tBounds.left - sBounds.left,
      y: tBounds.top - sBounds.top
    };
  }
  function getActiveDropId(sourceId, x, y2) {
    var e_1, _a2;
    var _b2 = getFixedPosition(sourceId, x, y2), fx = _b2.x, fy = _b2.y;
    try {
      for (var _c = __values(dropRefs.current.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {
        var _e = __read(_d.value, 2), key = _e[0], bounds = _e[1];
        if (!bounds.disableDrop && fx > bounds.left && fx < bounds.right && fy > bounds.top && fy < bounds.bottom) {
          return key;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_d && !_d.done && (_a2 = _c.return))
          _a2.call(_c);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return null;
  }
  function startTraverse(sourceId, targetId, x, y2, sourceIndex) {
    var _a2 = getFixedPosition(sourceId, x, y2), fx = _a2.x, fy = _a2.y;
    var _b2 = getRelativePosition(targetId, fx, fy), rx = _b2.x, ry = _b2.y;
    var _c = dropRefs.current.get(targetId), targetGrid = _c.grid, count = _c.count;
    var targetIndex = getIndexFromCoordinates(rx + targetGrid.columnWidth / 2, ry + targetGrid.rowHeight / 2, targetGrid, count);
    var _d = __read(getPositionForIndex(targetIndex, targetGrid).xy, 2), px = _d[0], py = _d[1];
    var _e = diffDropzones(sourceId, targetId), dx = _e.x, dy = _e.y;
    if (!traverse || !(traverse && traverse.targetIndex !== targetIndex && traverse.targetId !== targetId)) {
      setTraverse({
        rx: px + dx,
        ry: py + dy,
        tx: rx,
        ty: ry,
        sourceId,
        targetId,
        sourceIndex,
        targetIndex
      });
    }
  }
  function endTraverse() {
    setTraverse(null);
  }
  function onSwitch(sourceId, sourceIndex, targetIndex, targetId) {
    setTraverse(__assign({}, traverse, { execute: true }));
    onChange(sourceId, sourceIndex, targetIndex, targetId);
  }
  function measureAll() {
    dropRefs.current.forEach(function(ref) {
      ref.remeasure();
    });
  }
  return reactExports.createElement(GridContext.Provider, { value: {
    register,
    remove,
    getActiveDropId,
    startTraverse,
    traverse,
    measureAll,
    endTraverse,
    onChange: onSwitch
  } }, children);
}
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key) {
    var result = -1;
    arr.some(function(entry, index2) {
      if (entry[0] === key) {
        result = index2;
        return true;
      }
      return false;
    });
    return result;
  }
  return (
    /** @class */
    function() {
      function class_1() {
        this.__entries__ = [];
      }
      Object.defineProperty(class_1.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: true,
        configurable: true
      });
      class_1.prototype.get = function(key) {
        var index2 = getIndex(this.__entries__, key);
        var entry = this.__entries__[index2];
        return entry && entry[1];
      };
      class_1.prototype.set = function(key, value) {
        var index2 = getIndex(this.__entries__, key);
        if (~index2) {
          this.__entries__[index2][1] = value;
        } else {
          this.__entries__.push([key, value]);
        }
      };
      class_1.prototype.delete = function(key) {
        var entries = this.__entries__;
        var index2 = getIndex(entries, key);
        if (~index2) {
          entries.splice(index2, 1);
        }
      };
      class_1.prototype.has = function(key) {
        return !!~getIndex(this.__entries__, key);
      };
      class_1.prototype.clear = function() {
        this.__entries__.splice(0);
      };
      class_1.prototype.forEach = function(callback, ctx) {
        if (ctx === void 0) {
          ctx = null;
        }
        for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
          var entry = _a[_i];
          callback.call(ctx, entry[1], entry[0]);
        }
      };
      return class_1;
    }()
  );
}();
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
function throttle$1(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1$1(resolvePending);
  }
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = (
  /** @class */
  function() {
    function ResizeObserverController2() {
      this.connected_ = false;
      this.mutationEventsAdded_ = false;
      this.mutationsObserver_ = null;
      this.observers_ = [];
      this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
      this.refresh = throttle$1(this.refresh.bind(this), REFRESH_DELAY);
    }
    ResizeObserverController2.prototype.addObserver = function(observer) {
      if (!~this.observers_.indexOf(observer)) {
        this.observers_.push(observer);
      }
      if (!this.connected_) {
        this.connect_();
      }
    };
    ResizeObserverController2.prototype.removeObserver = function(observer) {
      var observers2 = this.observers_;
      var index2 = observers2.indexOf(observer);
      if (~index2) {
        observers2.splice(index2, 1);
      }
      if (!observers2.length && this.connected_) {
        this.disconnect_();
      }
    };
    ResizeObserverController2.prototype.refresh = function() {
      var changesDetected = this.updateObservers_();
      if (changesDetected) {
        this.refresh();
      }
    };
    ResizeObserverController2.prototype.updateObservers_ = function() {
      var activeObservers = this.observers_.filter(function(observer) {
        return observer.gatherActive(), observer.hasActive();
      });
      activeObservers.forEach(function(observer) {
        return observer.broadcastActive();
      });
      return activeObservers.length > 0;
    };
    ResizeObserverController2.prototype.connect_ = function() {
      if (!isBrowser || this.connected_) {
        return;
      }
      document.addEventListener("transitionend", this.onTransitionEnd_);
      window.addEventListener("resize", this.refresh);
      if (mutationObserverSupported) {
        this.mutationsObserver_ = new MutationObserver(this.refresh);
        this.mutationsObserver_.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      } else {
        document.addEventListener("DOMSubtreeModified", this.refresh);
        this.mutationEventsAdded_ = true;
      }
      this.connected_ = true;
    };
    ResizeObserverController2.prototype.disconnect_ = function() {
      if (!isBrowser || !this.connected_) {
        return;
      }
      document.removeEventListener("transitionend", this.onTransitionEnd_);
      window.removeEventListener("resize", this.refresh);
      if (this.mutationsObserver_) {
        this.mutationsObserver_.disconnect();
      }
      if (this.mutationEventsAdded_) {
        document.removeEventListener("DOMSubtreeModified", this.refresh);
      }
      this.mutationsObserver_ = null;
      this.mutationEventsAdded_ = false;
      this.connected_ = false;
    };
    ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
      var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
      var isReflowProperty = transitionKeys.some(function(key) {
        return !!~propertyName.indexOf(key);
      });
      if (isReflowProperty) {
        this.refresh();
      }
    };
    ResizeObserverController2.getInstance = function() {
      if (!this.instance_) {
        this.instance_ = new ResizeObserverController2();
      }
      return this.instance_;
    };
    ResizeObserverController2.instance_ = null;
    return ResizeObserverController2;
  }()
);
var defineConfigurable = function(target, props) {
  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
    var key = _a[_i];
    Object.defineProperty(target, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
};
var getWindowOf = function(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || global$1;
};
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value) {
  return parseFloat(value) || 0;
}
function getBordersSize(styles2) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size, position) {
    var value = styles2["border-" + position + "-width"];
    return size + toFloat(value);
  }, 0);
}
function getPaddings(styles2) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles2["padding-" + position];
    paddings[position] = toFloat(value);
  }
  return paddings;
}
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles2 = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles2);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles2.width), height = toFloat(styles2.height);
  if (styles2.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles2, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles2, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  return function(target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
  };
}();
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
function createReadOnlyRect(_a) {
  var x = _a.x, y2 = _a.y, width = _a.width, height = _a.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x,
    y: y2,
    width,
    height,
    top: y2,
    right: x + width,
    bottom: height + y2,
    left: x
  });
  return rect;
}
function createRectInit(x, y2, width, height) {
  return { x, y: y2, width, height };
}
var ResizeObservation = (
  /** @class */
  function() {
    function ResizeObservation2(target) {
      this.broadcastWidth = 0;
      this.broadcastHeight = 0;
      this.contentRect_ = createRectInit(0, 0, 0, 0);
      this.target = target;
    }
    ResizeObservation2.prototype.isActive = function() {
      var rect = getContentRect(this.target);
      this.contentRect_ = rect;
      return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
    };
    ResizeObservation2.prototype.broadcastRect = function() {
      var rect = this.contentRect_;
      this.broadcastWidth = rect.width;
      this.broadcastHeight = rect.height;
      return rect;
    };
    return ResizeObservation2;
  }()
);
var ResizeObserverEntry = (
  /** @class */
  function() {
    function ResizeObserverEntry2(target, rectInit) {
      var contentRect = createReadOnlyRect(rectInit);
      defineConfigurable(this, { target, contentRect });
    }
    return ResizeObserverEntry2;
  }()
);
var ResizeObserverSPI = (
  /** @class */
  function() {
    function ResizeObserverSPI2(callback, controller, callbackCtx) {
      this.activeObservations_ = [];
      this.observations_ = new MapShim();
      if (typeof callback !== "function") {
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      }
      this.callback_ = callback;
      this.controller_ = controller;
      this.callbackCtx_ = callbackCtx;
    }
    ResizeObserverSPI2.prototype.observe = function(target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (observations.has(target)) {
        return;
      }
      observations.set(target, new ResizeObservation(target));
      this.controller_.addObserver(this);
      this.controller_.refresh();
    };
    ResizeObserverSPI2.prototype.unobserve = function(target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (!observations.has(target)) {
        return;
      }
      observations.delete(target);
      if (!observations.size) {
        this.controller_.removeObserver(this);
      }
    };
    ResizeObserverSPI2.prototype.disconnect = function() {
      this.clearActive();
      this.observations_.clear();
      this.controller_.removeObserver(this);
    };
    ResizeObserverSPI2.prototype.gatherActive = function() {
      var _this = this;
      this.clearActive();
      this.observations_.forEach(function(observation) {
        if (observation.isActive()) {
          _this.activeObservations_.push(observation);
        }
      });
    };
    ResizeObserverSPI2.prototype.broadcastActive = function() {
      if (!this.hasActive()) {
        return;
      }
      var ctx = this.callbackCtx_;
      var entries = this.activeObservations_.map(function(observation) {
        return new ResizeObserverEntry(observation.target, observation.broadcastRect());
      });
      this.callback_.call(ctx, entries, ctx);
      this.clearActive();
    };
    ResizeObserverSPI2.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    };
    ResizeObserverSPI2.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI2;
  }()
);
var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
var ResizeObserver = (
  /** @class */
  function() {
    function ResizeObserver2(callback) {
      if (!(this instanceof ResizeObserver2)) {
        throw new TypeError("Cannot call a class as a function.");
      }
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      var controller = ResizeObserverController.getInstance();
      var observer = new ResizeObserverSPI(callback, controller, this);
      observers.set(this, observer);
    }
    return ResizeObserver2;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method) {
  ResizeObserver.prototype[method] = function() {
    var _a;
    return (_a = observers.get(this))[method].apply(_a, arguments);
  };
});
var index = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver;
}();
function useMeasure(ref) {
  var _a = __read(reactExports.useState({
    left: 0,
    top: 0,
    width: 0,
    height: 0,
    right: 0,
    bottom: 0
  }), 2), bounds = _a[0], setBounds = _a[1];
  var _b = __read(reactExports.useState(function() {
    return new index(function(_a2) {
      var _b2 = __read(_a2, 1), entry = _b2[0];
      setBounds(entry.target.getBoundingClientRect());
    });
  }), 1), observer = _b[0];
  reactExports.useLayoutEffect(function() {
    if (ref.current) {
      observer.observe(ref.current);
    }
    return function() {
      return observer.disconnect();
    };
  }, [ref, observer]);
  function remeasure() {
    setBounds(ref.current.getBoundingClientRect());
  }
  return { bounds, remeasure };
}
function swap(array, moveIndex, toIndex) {
  var item = array[moveIndex];
  var length = array.length;
  var diff2 = moveIndex - toIndex;
  if (diff2 > 0) {
    return __spread(array.slice(0, toIndex), [
      item
    ], array.slice(toIndex, moveIndex), array.slice(moveIndex + 1, length));
  } else if (diff2 < 0) {
    var targetIndex = toIndex + 1;
    return __spread(array.slice(0, moveIndex), array.slice(moveIndex + 1, targetIndex), [
      item
    ], array.slice(targetIndex, length));
  }
  return array;
}
var GridItemContext = reactExports.createContext(null);
function GridDropZone(_a) {
  var id = _a.id, boxesPerRow = _a.boxesPerRow, children = _a.children, style = _a.style, _b = _a.disableDrag, disableDrag = _b === void 0 ? false : _b, _c = _a.disableDrop, disableDrop = _c === void 0 ? false : _c, rowHeight = _a.rowHeight, other = __rest(_a, ["id", "boxesPerRow", "children", "style", "disableDrag", "disableDrop", "rowHeight"]);
  var _d = reactExports.useContext(GridContext), traverse = _d.traverse, startTraverse = _d.startTraverse, endTraverse = _d.endTraverse, register = _d.register, measureAll = _d.measureAll, onChange = _d.onChange, remove = _d.remove, getActiveDropId = _d.getActiveDropId;
  var ref = reactExports.useRef(null);
  var _e = useMeasure(ref), bounds = _e.bounds, remeasure = _e.remeasure;
  var _f = __read(reactExports.useState(null), 2), draggingIndex = _f[0], setDraggingIndex = _f[1];
  var _g = __read(reactExports.useState(null), 2), placeholder2 = _g[0], setPlaceholder = _g[1];
  var traverseIndex = traverse && !traverse.execute && traverse.targetId === id ? traverse.targetIndex : null;
  var grid = {
    columnWidth: bounds.width / boxesPerRow,
    boxesPerRow,
    rowHeight
  };
  var childCount = reactExports.Children.count(children);
  reactExports.useEffect(function() {
    register(id, {
      top: bounds.top,
      bottom: bounds.bottom,
      left: bounds.left,
      right: bounds.right,
      width: bounds.width,
      height: bounds.height,
      count: childCount,
      grid,
      disableDrop,
      remeasure
    });
  }, [childCount, disableDrop, bounds, id, grid]);
  reactExports.useEffect(function() {
    return function() {
      return remove(id);
    };
  }, [id]);
  var itemsIndexes = reactExports.Children.map(children, function(_, i2) {
    return i2;
  });
  return reactExports.createElement("div", __assign({ ref, style: __assign({ position: "relative" }, style) }, other), grid.columnWidth === 0 ? null : reactExports.Children.map(children, function(child, i2) {
    var isTraverseTarget = traverse && traverse.targetId === id && traverse.targetIndex === i2;
    var order = placeholder2 ? swap(itemsIndexes, placeholder2.startIndex, placeholder2.targetIndex) : itemsIndexes;
    var pos = getPositionForIndex(order.indexOf(i2), grid, traverseIndex);
    function onMove(state, x, y2) {
      if (!ref.current)
        return;
      if (draggingIndex !== i2) {
        setDraggingIndex(i2);
      }
      var targetDropId = getActiveDropId(id, x + grid.columnWidth / 2, y2 + grid.rowHeight / 2);
      if (targetDropId && targetDropId !== id) {
        startTraverse(id, targetDropId, x, y2, i2);
      } else {
        endTraverse();
      }
      var targetIndex = targetDropId !== id ? childCount : getTargetIndex(i2, grid, childCount, state.delta[0], state.delta[1]);
      if (targetIndex !== i2) {
        if (placeholder2 && placeholder2.targetIndex !== targetIndex || !placeholder2) {
          setPlaceholder({
            targetIndex,
            startIndex: i2
          });
        }
      } else if (placeholder2) {
        setPlaceholder(null);
      }
    }
    function onEnd(state, x, y2) {
      var targetDropId = getActiveDropId(id, x + grid.columnWidth / 2, y2 + grid.rowHeight / 2);
      var targetIndex = targetDropId !== id ? childCount : getTargetIndex(i2, grid, childCount, state.delta[0], state.delta[1]);
      if (traverse) {
        onChange(traverse.sourceId, traverse.sourceIndex, traverse.targetIndex, traverse.targetId);
      } else {
        onChange(id, i2, targetIndex);
      }
      setPlaceholder(null);
      setDraggingIndex(null);
    }
    function onStart() {
      measureAll();
    }
    return reactExports.createElement(GridItemContext.Provider, { value: {
      top: pos.xy[1],
      disableDrag,
      endTraverse,
      mountWithTraverseTarget: isTraverseTarget ? [traverse.tx, traverse.ty] : void 0,
      left: pos.xy[0],
      i: i2,
      onMove,
      onEnd,
      onStart,
      grid,
      dragging: i2 === draggingIndex
    } }, child);
  }));
}
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
var isEnabled = false;
var MOUSE_MOVE_THRESHOLD = 1e3;
var lastTouchTimestamp = 0;
function enableMouse() {
  if (isEnabled || Date.now() - lastTouchTimestamp < MOUSE_MOVE_THRESHOLD) {
    return;
  }
  isEnabled = true;
}
function disableMouse() {
  lastTouchTimestamp = Date.now();
  if (isEnabled) {
    isEnabled = false;
  }
}
if (canUseDOM) {
  document.addEventListener("touchstart", disableMouse, true);
  document.addEventListener("touchmove", disableMouse, true);
  document.addEventListener("mousemove", enableMouse, true);
}
function isMouseEnabled() {
  return isEnabled;
}
var initialState = {
  time: Date.now(),
  xy: [0, 0],
  delta: [0, 0],
  initial: [0, 0],
  previous: [0, 0],
  direction: [0, 0],
  initialDirection: [0, 0],
  local: [0, 0],
  lastLocal: [0, 0],
  velocity: 0,
  distance: 0
};
var defaultConfig = {
  enableMouse: true
};
var grantedTouch = null;
function useGestureResponder(options, config2) {
  if (options === void 0) {
    options = {};
  }
  if (config2 === void 0) {
    config2 = {};
  }
  var state = reactExports.useRef(initialState);
  var _a = __assign({}, defaultConfig, config2), uid = _a.uid, enableMouse2 = _a.enableMouse;
  var id = reactExports.useRef(uid || Math.random());
  var pressed = reactExports.useRef(false);
  var callbackRefs = reactExports.useRef(options);
  reactExports.useEffect(function() {
    callbackRefs.current = options;
  }, [options]);
  function claimTouch(e2) {
    if (grantedTouch && grantedTouch.onTerminationRequest(e2)) {
      grantedTouch.onTerminate(e2);
      grantedTouch = null;
    }
    attemptGrant(e2);
  }
  function attemptGrant(e2) {
    if (grantedTouch) {
      return;
    }
    grantedTouch = {
      id: id.current,
      onTerminate,
      onTerminationRequest
    };
    onGrant(e2);
  }
  function bindGlobalMouseEvents() {
    window.addEventListener("mousemove", handleMoveMouse, false);
    window.addEventListener("mousemove", handleMoveMouseCapture, true);
    window.addEventListener("mouseup", handleEndMouse);
  }
  function unbindGlobalMouseEvents() {
    window.removeEventListener("mousemove", handleMoveMouse, false);
    window.removeEventListener("mousemove", handleMoveMouseCapture, true);
    window.removeEventListener("mouseup", handleEndMouse);
  }
  function handleStartCapture(e2) {
    updateStartState(e2);
    pressed.current = true;
    var granted = onStartShouldSetCapture(e2);
    if (granted) {
      attemptGrant(e2);
    }
  }
  function handleStart(e2) {
    updateStartState(e2);
    pressed.current = true;
    bindGlobalMouseEvents();
    var granted = onStartShouldSet(e2);
    if (granted) {
      attemptGrant(e2);
    }
  }
  function isGrantedTouch() {
    return grantedTouch && grantedTouch.id === id.current;
  }
  function handleEnd(e2) {
    pressed.current = false;
    unbindGlobalMouseEvents();
    if (!isGrantedTouch()) {
      return;
    }
    grantedTouch = null;
    onRelease(e2);
  }
  function handleMoveCapture(e2) {
    updateMoveState(e2);
    if (isGrantedTouch()) {
      return;
    }
    if (onMoveShouldSetCapture(e2)) {
      claimTouch(e2);
    }
  }
  function handleMove(e2) {
    if (isGrantedTouch()) {
      onMove(e2);
      return;
    }
    if (onMoveShouldSet(e2)) {
      claimTouch(e2);
    }
  }
  function onStartShouldSet(e2) {
    return callbackRefs.current.onStartShouldSet ? callbackRefs.current.onStartShouldSet(state.current, e2) : false;
  }
  function onStartShouldSetCapture(e2) {
    return callbackRefs.current.onStartShouldSetCapture ? callbackRefs.current.onStartShouldSetCapture(state.current, e2) : false;
  }
  function onMoveShouldSet(e2) {
    return callbackRefs.current.onMoveShouldSet ? callbackRefs.current.onMoveShouldSet(state.current, e2) : false;
  }
  function onMoveShouldSetCapture(e2) {
    return callbackRefs.current.onMoveShouldSetCapture ? callbackRefs.current.onMoveShouldSetCapture(state.current, e2) : false;
  }
  function onGrant(e2) {
    if (callbackRefs.current.onGrant) {
      callbackRefs.current.onGrant(state.current, e2);
    }
  }
  function updateStartState(e2) {
    var _a2 = e2.touches && e2.touches[0] ? e2.touches[0] : e2, pageX = _a2.pageX, pageY = _a2.pageY;
    var s2 = state.current;
    state.current = __assign({}, initialState, { lastLocal: s2.lastLocal || initialState.lastLocal, xy: [pageX, pageY], initial: [pageX, pageY], previous: [pageX, pageY], time: Date.now() });
  }
  function updateMoveState(e2) {
    var _a2 = e2.touches && e2.touches[0] ? e2.touches[0] : e2, pageX = _a2.pageX, pageY = _a2.pageY;
    var s2 = state.current;
    var time = Date.now();
    var x_dist = pageX - s2.xy[0];
    var y_dist = pageY - s2.xy[1];
    var delta_x = pageX - s2.initial[0];
    var delta_y = pageY - s2.initial[1];
    var distance = Math.sqrt(delta_x * delta_x + delta_y * delta_y);
    var len = Math.sqrt(x_dist * x_dist + y_dist * y_dist);
    var scaler = 1 / (len || 1);
    var velocity = len / (time - s2.time);
    var initialDirection = s2.initialDirection[0] !== 0 || s2.initialDirection[1] !== 0 ? s2.initialDirection : [delta_x * scaler, delta_y * scaler];
    state.current = __assign({}, state.current, { time, xy: [pageX, pageY], initialDirection, delta: [delta_x, delta_y], local: [
      s2.lastLocal[0] + pageX - s2.initial[0],
      s2.lastLocal[1] + pageY - s2.initial[1]
    ], velocity: time - s2.time === 0 ? s2.velocity : velocity, distance, direction: [x_dist * scaler, y_dist * scaler], previous: s2.xy });
  }
  function onMove(e2) {
    if (pressed.current && callbackRefs.current.onMove) {
      callbackRefs.current.onMove(state.current, e2);
    }
  }
  function onRelease(e2) {
    var s2 = state.current;
    state.current = __assign({}, state.current, { lastLocal: s2.local });
    if (callbackRefs.current.onRelease) {
      callbackRefs.current.onRelease(state.current, e2);
    }
    grantedTouch = null;
  }
  function onTerminationRequest(e2) {
    return callbackRefs.current.onTerminationRequest ? callbackRefs.current.onTerminationRequest(state.current, e2) : true;
  }
  function onTerminate(e2) {
    var s2 = state.current;
    state.current = __assign({}, state.current, { lastLocal: s2.local });
    if (callbackRefs.current.onTerminate) {
      callbackRefs.current.onTerminate(state.current, e2);
    }
  }
  function handleMoveMouse(e2) {
    if (isMouseEnabled()) {
      handleMove(e2);
    }
  }
  function handleMoveMouseCapture(e2) {
    if (isMouseEnabled()) {
      handleMoveCapture(e2);
    }
  }
  function handleEndMouse(e2) {
    if (isMouseEnabled()) {
      handleEnd(e2);
    }
  }
  reactExports.useEffect(function() {
    return unbindGlobalMouseEvents;
  }, []);
  function terminateCurrentResponder() {
    if (grantedTouch) {
      grantedTouch.onTerminate();
      grantedTouch = null;
    }
  }
  function getCurrentResponder() {
    return grantedTouch;
  }
  var touchEvents = {
    onTouchStart: handleStart,
    onTouchEnd: handleEnd,
    onTouchMove: handleMove,
    onTouchStartCapture: handleStartCapture,
    onTouchMoveCapture: handleMoveCapture
  };
  var mouseEvents = enableMouse2 ? {
    onMouseDown: function(e2) {
      if (isMouseEnabled()) {
        handleStart(e2);
      }
    },
    onMouseDownCapture: function(e2) {
      if (isMouseEnabled()) {
        handleStartCapture(e2);
      }
    }
  } : {};
  return {
    bind: __assign({}, touchEvents, mouseEvents),
    terminateCurrentResponder,
    getCurrentResponder
  };
}
let applyAnimatedValues;
let createStringInterpolator;
let now$5 = () => Date.now();
let colorNames = {};
let defaultElement;
let manualFrameloop;
let createAnimatedStyle;
let createAnimatedTransform;
let createAnimatedInterpolation;
let createAnimatedRef = (node) => node.current;
let requestAnimationFrame$1 = typeof window !== "undefined" ? window.requestAnimationFrame : () => {
};
let cancelAnimationFrame = typeof window !== "undefined" ? window.cancelAnimationFrame : () => {
};
const assign = (globals) => {
  var _Object$assign = Object.assign({
    colorNames,
    defaultElement,
    applyAnimatedValues,
    createStringInterpolator,
    createAnimatedInterpolation,
    createAnimatedTransform,
    createAnimatedStyle,
    createAnimatedRef,
    requestAnimationFrame: requestAnimationFrame$1,
    cancelAnimationFrame,
    manualFrameloop
  }, globals);
  colorNames = _Object$assign.colorNames;
  defaultElement = _Object$assign.defaultElement;
  applyAnimatedValues = _Object$assign.applyAnimatedValues;
  createStringInterpolator = _Object$assign.createStringInterpolator;
  createAnimatedInterpolation = _Object$assign.createAnimatedInterpolation;
  createAnimatedTransform = _Object$assign.createAnimatedTransform;
  createAnimatedStyle = _Object$assign.createAnimatedStyle;
  createAnimatedRef = _Object$assign.createAnimatedRef;
  requestAnimationFrame$1 = _Object$assign.requestAnimationFrame;
  cancelAnimationFrame = _Object$assign.cancelAnimationFrame;
  manualFrameloop = _Object$assign.manualFrameloop;
  return _Object$assign;
};
class Animated {
  constructor() {
    this.payload = void 0;
    this.children = [];
  }
  getAnimatedValue() {
    return this.getValue();
  }
  getPayload() {
    return this.payload || this;
  }
  attach() {
  }
  detach() {
  }
  getChildren() {
    return this.children;
  }
  addChild(child) {
    if (this.children.length === 0)
      this.attach();
    this.children.push(child);
  }
  removeChild(child) {
    const index2 = this.children.indexOf(child);
    this.children.splice(index2, 1);
    if (this.children.length === 0)
      this.detach();
  }
}
class AnimatedArray extends Animated {
  constructor() {
    super(...arguments);
    this.payload = void 0;
  }
  attach() {
    this.payload.forEach((p2) => p2 instanceof Animated && p2.addChild(this));
  }
  detach() {
    this.payload.forEach((p2) => p2 instanceof Animated && p2.removeChild(this));
  }
}
class AnimatedObject extends Animated {
  constructor(payload) {
    super();
    this.payload = payload;
  }
  getValue(animated) {
    if (animated === void 0) {
      animated = false;
    }
    const payload = {};
    for (const key in this.payload) {
      const value = this.payload[key];
      if (animated && !(value instanceof Animated))
        continue;
      payload[key] = value instanceof Animated ? value[animated ? "getAnimatedValue" : "getValue"]() : value;
    }
    return payload;
  }
  getAnimatedValue() {
    return this.getValue(true);
  }
  attach() {
    Object.values(this.payload).forEach((s2) => s2 instanceof Animated && s2.addChild(this));
  }
  detach() {
    Object.values(this.payload).forEach((s2) => s2 instanceof Animated && s2.removeChild(this));
  }
}
class AnimatedStyle extends AnimatedObject {
  constructor(style) {
    if (style === void 0) {
      style = {};
    }
    super(style.transform && createAnimatedTransform ? _extends$h({}, style, {
      transform: createAnimatedTransform(style.transform)
    }) : style);
  }
}
const is$1 = {
  arr: Array.isArray,
  obj: (a2) => Object.prototype.toString.call(a2) === "[object Object]",
  fun: (a2) => typeof a2 === "function",
  str: (a2) => typeof a2 === "string",
  num: (a2) => typeof a2 === "number",
  und: (a2) => a2 === void 0,
  boo: (a2) => typeof a2 === "boolean"
};
function useForceUpdate() {
  const _useState = reactExports.useState(false), f2 = _useState[1];
  const forceUpdate = reactExports.useCallback(() => f2((v2) => !v2), []);
  return forceUpdate;
}
function withDefault(value, defaultValue4) {
  return value == null ? defaultValue4 : value;
}
function toArray$1(a2) {
  return is$1.und(a2) ? [] : Array.isArray(a2) ? a2 : [a2];
}
function callProp(obj) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return is$1.fun(obj) ? obj(...args) : obj;
}
function getForwardProps(props) {
  props.to;
  props.from;
  props.config;
  props.onStart;
  props.onRest;
  props.onFrame;
  props.children;
  props.cancel;
  props.reset;
  props.reverse;
  props.force;
  props.immediate;
  props.delay;
  props.attach;
  props.destroyed;
  props.interpolateTo;
  props.ref;
  props.lazy;
  const forward = _objectWithoutPropertiesLoose(props, ["to", "from", "config", "onStart", "onRest", "onFrame", "children", "cancel", "reset", "reverse", "force", "immediate", "delay", "attach", "destroyed", "interpolateTo", "ref", "lazy"]);
  return forward;
}
function interpolateTo(props) {
  const forward = getForwardProps(props);
  props = Object.entries(props).reduce((props2, _ref) => {
    let key = _ref[0], value = _ref[1];
    return key in forward || (props2[key] = value), props2;
  }, {});
  return _extends$h({
    to: forward
  }, props);
}
function handleRef(ref, forward) {
  if (forward) {
    if (is$1.fun(forward))
      forward(ref);
    else if (is$1.obj(forward)) {
      forward.current = ref;
    }
  }
  return ref;
}
function usePrev(value) {
  const prevRef = reactExports.useRef(void 0);
  const prev = prevRef.current;
  prevRef.current = value;
  return prev;
}
function fillArray(length, mapIndex) {
  const arr = [];
  for (let i2 = 0; i2 < length; i2++)
    arr.push(mapIndex(i2));
  return arr;
}
function freeze(obj) {
  if (typeof process !== "undefined" && false) {
    return Object.freeze(obj);
  }
  return obj;
}
class AnimatedValueArray extends AnimatedArray {
  constructor(values) {
    super();
    this.payload = values;
  }
  getValue() {
    return this.payload.map((v2) => v2.getValue());
  }
  setValue(value, flush) {
    if (flush === void 0) {
      flush = true;
    }
    if (is$1.arr(value)) {
      if (value.length === this.payload.length) {
        value.forEach((v2, i2) => this.payload[i2].setValue(v2, flush));
      }
    } else {
      this.payload.forEach((p2) => p2.setValue(value, flush));
    }
  }
  interpolate() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return createAnimatedInterpolation(this, ...args);
  }
}
const createInterpolator = (range2, output, extrapolate) => {
  if (is$1.fun(range2)) {
    return range2;
  }
  if (is$1.arr(range2)) {
    return createInterpolator({
      range: range2,
      output,
      extrapolate
    });
  }
  if (is$1.str(range2.output[0])) {
    return createStringInterpolator(range2);
  }
  const config2 = range2;
  const outputRange = config2.output;
  const inputRange = config2.range || [0, 1];
  const extrapolateLeft = config2.extrapolateLeft || config2.extrapolate || "extend";
  const extrapolateRight = config2.extrapolateRight || config2.extrapolate || "extend";
  const easing = config2.easing || ((t2) => t2);
  return (input2) => {
    const range3 = findRange(input2, inputRange);
    return interpolate(input2, inputRange[range3], inputRange[range3 + 1], outputRange[range3], outputRange[range3 + 1], easing, extrapolateLeft, extrapolateRight, config2.map);
  };
};
function interpolate(input2, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map2) {
  let result = map2 ? map2(input2) : input2;
  if (result < inputMin) {
    if (extrapolateLeft === "identity")
      return result;
    else if (extrapolateLeft === "clamp")
      result = inputMin;
  }
  if (result > inputMax) {
    if (extrapolateRight === "identity")
      return result;
    else if (extrapolateRight === "clamp")
      result = inputMax;
  }
  if (outputMin === outputMax)
    return outputMin;
  if (inputMin === inputMax)
    return input2 <= inputMin ? outputMin : outputMax;
  if (inputMin === -Infinity)
    result = -result;
  else if (inputMax === Infinity)
    result = result - inputMin;
  else
    result = (result - inputMin) / (inputMax - inputMin);
  result = easing(result);
  if (outputMin === -Infinity)
    result = -result;
  else if (outputMax === Infinity)
    result = result + outputMin;
  else
    result = result * (outputMax - outputMin) + outputMin;
  return result;
}
function findRange(input2, inputRange) {
  for (var i2 = 1; i2 < inputRange.length - 1; ++i2)
    if (inputRange[i2] >= input2)
      break;
  return i2 - 1;
}
class AnimatedInterpolation extends AnimatedArray {
  constructor(parents2, args) {
    super();
    this.calc = void 0;
    this.calc = createInterpolator(...args);
    this.payload = Array.isArray(parents2) ? parents2 : parents2 instanceof AnimatedValueArray ? parents2.getPayload() : [parents2];
  }
  getValue() {
    const args = this.payload.map((value) => value.getValue());
    return this.calc(...args);
  }
  interpolate() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return createAnimatedInterpolation(this, ...args);
  }
}
let active$2 = false;
const controllers = /* @__PURE__ */ new Set();
const update = () => {
  if (!active$2)
    return false;
  let time = now$5();
  for (let controller of controllers) {
    let isActive = false;
    let updateCount = 0;
    for (let configIdx = 0; configIdx < controller.configs.length; configIdx++) {
      let config2 = controller.configs[configIdx];
      let endOfAnimation, lastTime;
      for (let valIdx = 0; valIdx < config2.animatedValues.length; valIdx++) {
        let animated = config2.animatedValues[valIdx];
        if (animated.done)
          continue;
        updateCount++;
        let to2 = config2.toValues[valIdx];
        let isAnimated = to2 instanceof Animated;
        if (isAnimated)
          to2 = to2.getValue();
        if (config2.immediate) {
          animated.setValue(to2);
          animated.done = true;
          continue;
        }
        let from2 = config2.fromValues[valIdx];
        if (typeof from2 === "string" || typeof to2 === "string") {
          animated.setValue(to2);
          animated.done = true;
          continue;
        }
        let position = animated.lastPosition;
        let velocity = Array.isArray(config2.initialVelocity) ? config2.initialVelocity[valIdx] : config2.initialVelocity;
        if (config2.duration !== void 0) {
          position = from2 + config2.easing((time - animated.startTime) / config2.duration) * (to2 - from2);
          endOfAnimation = time >= animated.startTime + config2.duration;
        } else if (config2.decay) {
          const decay = config2.decay === true ? 0.998 : config2.decay;
          position = from2 + velocity / (1 - decay) * (1 - Math.exp(-(1 - decay) * (time - animated.startTime)));
          endOfAnimation = Math.abs(animated.lastPosition - position) < 0.1;
          if (endOfAnimation)
            to2 = position;
        } else {
          lastTime = animated.lastTime !== void 0 ? animated.lastTime : time;
          velocity = animated.lastVelocity !== void 0 ? animated.lastVelocity : config2.initialVelocity;
          if (time > lastTime + 64)
            lastTime = time;
          let numSteps = Math.floor(time - lastTime);
          for (let i2 = 0; i2 < numSteps; ++i2) {
            let force = -config2.tension * (position - to2);
            let damping = -config2.friction * velocity;
            let acceleration = (force + damping) / config2.mass;
            velocity = velocity + acceleration * 1 / 1e3;
            position = position + velocity * 1 / 1e3;
          }
          let isOvershooting = config2.clamp && config2.tension !== 0 ? from2 < to2 ? position > to2 : position < to2 : false;
          let isVelocity = Math.abs(velocity) <= config2.precision;
          let isDisplacement = config2.tension !== 0 ? Math.abs(to2 - position) <= config2.precision : true;
          endOfAnimation = isOvershooting || isVelocity && isDisplacement;
          animated.lastVelocity = velocity;
          animated.lastTime = time;
        }
        if (isAnimated && !config2.toValues[valIdx].done) {
          endOfAnimation = false;
        }
        if (endOfAnimation) {
          if (animated.value !== to2)
            position = to2;
          animated.done = true;
        } else {
          isActive = true;
        }
        animated.setValue(position);
        animated.lastPosition = position;
      }
      if (controller.props.onFrame) {
        controller.values[config2.key] = config2.animated.getValue();
      }
    }
    controller.onFrame(isActive, updateCount);
  }
  if (controllers.size) {
    if (manualFrameloop)
      manualFrameloop();
    else
      requestAnimationFrame$1(update);
  } else {
    active$2 = false;
  }
  return active$2;
};
const start = (controller) => {
  controllers.add(controller);
  if (!active$2) {
    active$2 = true;
    if (manualFrameloop)
      manualFrameloop();
    else
      requestAnimationFrame$1(update);
  }
};
const stop = (controller) => {
  controllers.delete(controller);
};
function addAnimatedStyles(node, styles2) {
  if ("update" in node) {
    styles2.add(node);
  } else {
    node.getChildren().forEach((child) => addAnimatedStyles(child, styles2));
  }
}
class AnimatedValue extends Animated {
  constructor(_value) {
    var _this;
    super();
    _this = this;
    this.animatedStyles = /* @__PURE__ */ new Set();
    this.value = void 0;
    this.startPosition = void 0;
    this.lastPosition = void 0;
    this.lastVelocity = void 0;
    this.startTime = void 0;
    this.lastTime = void 0;
    this.done = false;
    this.setValue = function(value, flush) {
      if (flush === void 0) {
        flush = true;
      }
      _this.value = value;
      if (flush)
        _this.flush();
    };
    this.value = _value;
    if (is$1.num(_value)) {
      this.startPosition = _value;
      this.lastPosition = _value;
    }
  }
  getValue() {
    return this.value;
  }
  interpolate() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return createAnimatedInterpolation(this, ...args);
  }
  reset(isActive) {
    if (is$1.num(this.value)) {
      this.startPosition = this.value;
      this.lastPosition = this.value;
      this.lastVelocity = isActive ? this.lastVelocity : void 0;
      this.lastTime = isActive ? this.lastTime : void 0;
      this.startTime = now$5();
    }
    this.done = false;
    this.animatedStyles.clear();
  }
  clearStyles() {
    this.animatedStyles.clear();
  }
  flush() {
    if (this.animatedStyles.size === 0) {
      addAnimatedStyles(this, this.animatedStyles);
    }
    this.animatedStyles.forEach((animatedStyle) => animatedStyle.update());
  }
}
const linear = (t2) => t2;
const emptyObj = Object.freeze({});
let nextId = 1;
class Controller {
  constructor(props) {
    this.id = nextId++;
    this.idle = true;
    this.runCount = 0;
    this.destroyed = false;
    this.props = {};
    this.queue = [];
    this.timestamps = {};
    this.values = {};
    this.merged = {};
    this.animated = {};
    this.animations = {};
    this.configs = [];
    this.onEndQueue = [];
    this.cancelledAt = 0;
    if (props)
      this.update(props).start();
  }
  /**
   * Push props into the update queue. The props are used after `start` is
   * called and any delay is over. The props are intelligently diffed to ensure
   * that later calls to this method properly override any delayed props.
   * The `propsArg` argument is always copied before mutations are made.
   */
  update(propsArg) {
    if (!propsArg || this.destroyed)
      return this;
    const props = interpolateTo(propsArg);
    this._ensureAnimated(props.from, true);
    this._ensureAnimated(props.to);
    props.timestamp = now$5();
    if (is$1.fun(props.delay) && is$1.obj(props.to)) {
      const from2 = props.from || emptyObj;
      for (const key in props.to) {
        this.queue.push(_extends$h({}, props, {
          to: {
            [key]: props.to[key]
          },
          from: key in from2 ? {
            [key]: from2[key]
          } : void 0,
          delay: Math.max(0, Math.round(props.delay(key)))
        }));
      }
    } else {
      props.delay = is$1.num(props.delay) ? Math.max(0, Math.round(props.delay)) : 0;
      if (!props.to)
        props.to = void 0;
      if (!props.from)
        props.from = void 0;
      this.queue.push(props);
    }
    return this;
  }
  /**
   * Flush the update queue.
   * If the queue is empty, try starting the frameloop.
   */
  start(onEnd) {
    if (this.queue.length)
      this._flush(onEnd);
    else
      this._start(onEnd);
    return this;
  }
  /** Stop one animation or all animations */
  stop() {
    for (var _len = arguments.length, keys2 = new Array(_len), _key = 0; _key < _len; _key++) {
      keys2[_key] = arguments[_key];
    }
    let finished = false;
    if (is$1.boo(keys2[0])) {
      var _keys = keys2;
      finished = _keys[0];
      keys2 = _keys.slice(1);
    }
    if (keys2.length) {
      for (const key of keys2) {
        const index2 = this.configs.findIndex((config2) => key === config2.key);
        this._stopAnimation(key);
        this.configs[index2] = this.animations[key];
      }
    } else if (this.runCount) {
      this.cancelledAt = now$5();
      this.configs.forEach((config2) => this._stopAnimation(config2.key));
      this.configs = Object.values(this.animations);
      this._stop(finished);
    }
    return this;
  }
  /** Revert the controller to its initial state */
  reset() {
    this.stop();
    this.destroyed = false;
    this.props = {};
    this.queue = [];
    this.timestamps = {};
    this.values = {};
    this.merged = {};
    this.animated = {};
    this.animations = {};
    this.configs = [];
    return this;
  }
  /** Prevent all current and future animation */
  destroy() {
    if (!this.destroyed) {
      this.stop();
      this.destroyed = true;
    }
  }
  /** @internal Called by the frameloop */
  onFrame(isActive, updateCount) {
    if (updateCount) {
      const onFrame = this.props.onFrame;
      if (onFrame)
        onFrame(_extends$h({}, this.values));
    }
    if (!isActive)
      this._stop(true);
  }
  /**
   * Set a prop for the next animations where the prop is undefined. The given
   * value is overridden by the next update where the prop is defined.
   *
   * Ongoing animations are not changed.
   */
  setProp(key, value) {
    this.props[key] = value;
    this.timestamps[key] = now$5();
    return this;
  }
  // Create an Animated node if none exists.
  _ensureAnimated(values, shouldUpdate) {
    if (shouldUpdate === void 0) {
      shouldUpdate = false;
    }
    if (!is$1.obj(values))
      return;
    for (const key in values) {
      const value = values[key];
      let animated = this.animated[key];
      if (animated && shouldUpdate && this.animations[key].isNew) {
        if (animated.setValue) {
          animated.setValue(value);
        } else {
          animated = null;
        }
      }
      if (!animated) {
        animated = createAnimated(value);
        if (animated) {
          if (this.animated[key]) {
            moveChildren(this.animated[key], animated);
          }
          this.animated[key] = animated;
          this._stopAnimation(key, true);
        } else {
          console.warn("Given value not animatable:", value);
        }
      }
    }
  }
  // Listen for all animations to end.
  _onEnd(onEnd) {
    if (this.runCount)
      this.onEndQueue.push(onEnd);
    else
      onEnd(true);
  }
  // Add this controller to the frameloop.
  _start(onEnd) {
    if (onEnd)
      this._onEnd(onEnd);
    if (this.idle && this.runCount) {
      this.idle = false;
      start(this);
    }
  }
  // Remove this controller from the frameloop, and notify any listeners.
  _stop(finished) {
    this.idle = true;
    stop(this);
    const onEndQueue = this.onEndQueue;
    if (onEndQueue.length) {
      this.onEndQueue = [];
      onEndQueue.forEach((onEnd) => onEnd(finished));
    }
  }
  // Execute the current queue of prop updates.
  _flush(onEnd) {
    const queue = this.queue.reduce(reduceDelays, []);
    this.queue.length = 0;
    let runsLeft = Object.keys(queue).length;
    this.runCount += runsLeft;
    const onRunEnd = (finished) => {
      this.runCount--;
      if (--runsLeft)
        return;
      if (onEnd)
        onEnd(finished);
      if (!this.runCount && finished) {
        const onRest = this.props.onRest;
        if (onRest)
          onRest(this.merged);
      }
    };
    queue.forEach((props, delay) => {
      if (delay) {
        setTimeout(() => {
          if (props.timestamp < this.cancelledAt)
            return;
          this._run(props, onRunEnd);
        }, delay);
      } else {
        this._run(props, onRunEnd);
      }
    });
  }
  // Update the props and animations
  _run(props, onEnd) {
    if (is$1.arr(props.to) || is$1.fun(props.to)) {
      this._runAsync(props, onEnd);
    } else if (this._diff(props)) {
      this._animate(props)._start(onEnd);
    } else {
      this._onEnd(onEnd);
    }
  }
  // Start an async chain or an async script.
  _runAsync(_ref, onEnd) {
    let to2 = _ref.to, props = _objectWithoutPropertiesLoose(_ref, ["to"]);
    if (this._diff(props)) {
      this._animate(props);
    }
    if (props.cancel === true) {
      this.props.asyncTo = void 0;
      return onEnd(false);
    }
    const timestamp = props.timestamp;
    if (!this._diff({
      asyncTo: to2,
      timestamp
    })) {
      return onEnd(false);
    }
    const isCancelled = () => (
      // Cancelling methods touch the `cancelledAt` property
      timestamp < this.cancelledAt || // Async scripts are also cancelled when a new chain/script begins
      is$1.fun(to2) && to2 !== this.props.asyncTo
    );
    let last2;
    const next = (props2) => {
      if (isCancelled())
        throw this;
      return (last2 = new Promise((done) => {
        this.update(props2).start(done);
      })).then(() => {
        if (isCancelled())
          throw this;
      });
    };
    let queue = Promise.resolve();
    if (is$1.arr(to2)) {
      to2.forEach((props2) => queue = queue.then(() => next(props2)));
    } else if (is$1.fun(to2)) {
      queue = queue.then(() => to2(next, this.stop.bind(this)).then(() => last2));
    }
    queue.catch((err) => err !== this && console.error(err)).then(() => onEnd(!isCancelled()));
  }
  // Merge every fresh prop. Returns true if one or more props changed.
  // These props are ignored: (delay, config, immediate, reverse)
  _diff(_ref2) {
    let timestamp = _ref2.timestamp;
    _ref2.delay;
    _ref2.config;
    _ref2.immediate;
    let reverse = _ref2.reverse, props = _objectWithoutPropertiesLoose(_ref2, ["timestamp", "delay", "config", "immediate", "reverse"]);
    let changed = false;
    const diffTimestamp = (keyPath) => {
      const previous = this.timestamps[keyPath];
      if (is$1.und(previous) || timestamp >= previous) {
        this.timestamps[keyPath] = timestamp;
        return true;
      }
      return false;
    };
    const diffProp = (keys2, value, parent2) => {
      if (is$1.und(value))
        return;
      const lastKey = keys2[keys2.length - 1];
      if (is$1.obj(value)) {
        if (!is$1.obj(parent2[lastKey]))
          parent2[lastKey] = {};
        for (const key in value) {
          diffProp(keys2.concat(key), value[key], parent2[lastKey]);
        }
      } else if (diffTimestamp(keys2.join("."))) {
        const oldValue = parent2[lastKey];
        if (!isEqual(value, oldValue)) {
          changed = true;
          parent2[lastKey] = value;
        }
      }
    };
    if (reverse) {
      const to2 = props.to;
      props.to = props.from;
      props.from = is$1.obj(to2) ? to2 : void 0;
    }
    for (const key in props) {
      diffProp([key], props[key], this.props);
    }
    if ("reset" in props)
      this.props.reset = false;
    if ("cancel" in props)
      this.props.cancel = void 0;
    return changed;
  }
  // Return true if the given prop was changed by this update
  _isModified(props, prop) {
    return this.timestamps[prop] === props.timestamp;
  }
  // Update the animation configs. The given props override any default props.
  _animate(props) {
    const _this$props = this.props, _this$props$from = _this$props.from, from2 = _this$props$from === void 0 ? emptyObj : _this$props$from, _this$props$to = _this$props.to, to2 = _this$props$to === void 0 ? emptyObj : _this$props$to, attach = _this$props.attach, onStart = _this$props.onStart;
    let isPrevented = (_) => false;
    if (props.cancel && this._isModified(props, "cancel")) {
      if (props.cancel === true) {
        this.stop();
        this.cancelledAt = props.timestamp;
        return this;
      }
      const keys2 = toArray$1(props.cancel);
      if (is$1.arr(keys2) && keys2.length) {
        isPrevented = (key) => keys2.indexOf(key) >= 0;
        this.stop(...keys2);
      }
    }
    this.merged = freeze(_extends$h({}, from2, to2));
    let changed = false;
    const started = [];
    const target = attach && attach(this);
    for (const key in this.merged) {
      if (isPrevented(key))
        continue;
      const state = this.animations[key];
      if (!state) {
        console.warn(`Failed to animate key: "${key}"
Did you forget to define "from.${key}" for an async animation?`);
        continue;
      }
      let animated = state.animated, animatedValues = state.animatedValues;
      const value = this.merged[key];
      const goalValue = computeGoalValue(value);
      const currValue = animated.getValue();
      if (!props.reset && isEqual(goalValue, currValue)) {
        if (!state.idle) {
          changed = true;
          this._stopAnimation(key);
        }
        continue;
      }
      if (props.reset || !isEqual(goalValue, state.isNew ? currValue : state.goalValue)) {
        let _ref3 = is$1.und(props.immediate) ? this.props : props, immediate = _ref3.immediate;
        immediate = !!callProp(immediate, key);
        const isActive = animatedValues.some((v2) => !v2.done);
        const fromValue = !is$1.und(from2[key]) ? computeGoalValue(from2[key]) : goalValue;
        const isInterpolated = isAnimatableString(value);
        if (isInterpolated) {
          const output = [props.reset ? fromValue : animated.getValue(), goalValue];
          let input2 = animatedValues[0];
          if (input2) {
            input2.setValue(0, false);
            input2.reset(isActive);
          } else {
            input2 = new AnimatedValue(0);
          }
          try {
            const prev = animated;
            animated = input2.interpolate({
              output
            });
            moveChildren(prev, animated);
          } catch (err) {
            console.warn('Failed to interpolate string from "%s" to "%s"', output[0], output[1]);
            console.error(err);
            continue;
          }
          if (immediate) {
            input2.setValue(1, false);
          }
        } else {
          if (is$1.arr(value)) {
            if (animated instanceof AnimatedValueArray) {
              if (props.reset)
                animated.setValue(fromValue, false);
              animatedValues.forEach((v2) => v2.reset(isActive));
            } else {
              const prev = animated;
              animated = createAnimated(fromValue);
              moveChildren(prev, animated);
            }
          } else {
            if (animated instanceof AnimatedValue) {
              if (props.reset)
                animated.setValue(fromValue, false);
              animated.reset(isActive);
            } else {
              const prev = animated;
              animated = new AnimatedValue(fromValue);
              moveChildren(prev, animated);
            }
          }
          if (immediate) {
            animated.setValue(goalValue, false);
          }
        }
        const config2 = callProp(props.config, key) || callProp(this.props.config, key) || emptyObj;
        if (!immediate) {
          started.push(key);
        }
        changed = true;
        animatedValues = toArray$1(animated.getPayload());
        this.animations[key] = {
          key,
          idle: false,
          goalValue,
          toValues: toArray$1(target instanceof Controller ? target.animations[key].animated.getPayload() : isInterpolated && 1 || goalValue),
          fromValues: animatedValues.map((v2) => v2.getValue()),
          animated,
          animatedValues,
          immediate,
          duration: config2.duration,
          easing: withDefault(config2.easing, linear),
          decay: config2.decay,
          mass: withDefault(config2.mass, 1),
          tension: withDefault(config2.tension, 170),
          friction: withDefault(config2.friction, 26),
          initialVelocity: withDefault(config2.velocity, 0),
          clamp: withDefault(config2.clamp, false),
          precision: withDefault(config2.precision, 5e-3),
          config: config2
        };
      }
    }
    if (changed) {
      if (onStart && started.length) {
        started.forEach((key) => onStart(this.animations[key]));
      }
      const keys2 = Object.keys(this.animations);
      this.configs.length = keys2.length;
      keys2.forEach((key, i2) => {
        const config2 = this.animations[key];
        this.configs[i2] = config2;
        this.values[key] = config2.animated.getValue();
        this.animated[key] = config2.animated;
      });
    }
    return this;
  }
  /**
   * Stop an animation by its key.
   *
   * This mutates the `timestamps.to[key]`, `props.to[key]`, and `animations[key]` properties.
   * Notably, it does *not* mutate the `configs[key]` or `animated[key]` properties.
   */
  _stopAnimation(key, isNew) {
    const animated = this.animated[key];
    if (!animated) {
      return console.warn(`Cannot stop an animation for a key that isn't animated: "${key}"`);
    }
    this.timestamps["to." + key] = now$5();
    const state = this.animations[key] || emptyObj;
    if (state.idle && animated === state.animated)
      return;
    if (is$1.und(isNew)) {
      isNew = !!state.isNew;
    }
    const animatedValues = toArray$1(animated.getPayload());
    animatedValues.forEach((v2) => v2.done = true);
    const goalValue = animated.getValue();
    if (this.props.to) {
      this.props.to[key] = goalValue;
    }
    this.animations[key] = {
      key,
      idle: true,
      isNew,
      goalValue,
      animated,
      animatedValues
    };
  }
}
function createAnimated(value) {
  return is$1.arr(value) ? new AnimatedValueArray(value.map((value2) => {
    const animated = createAnimated(value2);
    const payload = animated.getPayload();
    return animated instanceof AnimatedInterpolation ? payload[0] : payload;
  })) : isAnimatableString(value) ? (
    // Convert "red" into "rgba(255, 0, 0, 1)" etc
    new AnimatedValue(0).interpolate({
      output: [value, value]
    })
  ) : (
    // The `AnimatedValue` class supports any type, but only numbers are
    // interpolated by the frameloop.
    new AnimatedValue(value)
  );
}
function moveChildren(prev, next) {
  const children = prev.getChildren().slice();
  children.forEach((child) => {
    prev.removeChild(child);
    next.addChild(child);
    const payload = child.getPayload();
    if (is$1.arr(payload)) {
      const i2 = payload.indexOf(prev);
      if (i2 >= 0) {
        const copy = [...payload];
        copy[i2] = next;
        child["payload"] = copy;
      }
    } else if (is$1.obj(payload)) {
      const entry = Object.entries(payload).find((entry2) => entry2[1] === prev);
      if (entry) {
        child["payload"] = _extends$h({}, payload, {
          [entry[0]]: next
        });
      }
    }
  });
}
function reduceDelays(merged, props) {
  const prev = merged[props.delay];
  if (prev) {
    props.to = merge$5(prev.to, props.to);
    props.from = merge$5(prev.from, props.from);
    Object.assign(prev, props);
  } else {
    merged[props.delay] = props;
  }
  return merged;
}
function merge$5(dest, src) {
  return is$1.obj(dest) && is$1.obj(src) ? _extends$h({}, dest, src) : src || dest;
}
function isAnimatableString(value) {
  if (!is$1.str(value))
    return false;
  return value.startsWith("#") || /\d/.test(value) || !!colorNames[value];
}
function computeGoalValue(value) {
  return is$1.arr(value) ? value.map(computeGoalValue) : isAnimatableString(value) ? createStringInterpolator({
    range: [0, 1],
    output: [value, value]
  })(1) : value;
}
function isEqual(a2, b2) {
  if (is$1.arr(a2)) {
    if (!is$1.arr(b2) || a2.length !== b2.length)
      return false;
    for (let i2 = 0; i2 < a2.length; i2++) {
      if (a2[i2] !== b2[i2])
        return false;
    }
    return true;
  }
  return a2 === b2;
}
const useSprings = (length, propsArg, deps) => {
  const hasNewSprings = length !== usePrev(length);
  const isFn = is$1.fun(propsArg);
  const state = reactExports.useRef({
    springs: [],
    ref: null
  }).current;
  const props = isFn ? [] : propsArg;
  const springs = reactExports.useMemo(() => fillArray(length, (i2) => {
    const s2 = new Controller();
    const p2 = props[i2] || (props[i2] = callProp(propsArg, i2, s2));
    return s2.update(p2);
  }), [length]);
  const _useMemo = reactExports.useMemo(() => ({
    /** Apply any pending updates */
    start: () => Promise.all(state.springs.map((s2) => new Promise((done) => s2.start(done)))),
    /** Update the spring controllers */
    update: (props2) => {
      const isFn2 = is$1.fun(props2);
      const isArr = is$1.arr(props2);
      state.springs.forEach((spring, i2) => {
        spring.update(isFn2 ? callProp(props2, i2, spring) : isArr ? props2[i2] : props2);
        if (!state.ref)
          spring.start();
      });
    },
    /** Stop one key or all keys from animating */
    stop: function stop3() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return state.springs.forEach((s2) => s2.stop(...args));
    }
  }), []), start2 = _useMemo.start, update2 = _useMemo.update, stop2 = _useMemo.stop;
  const ref = props[0] ? props[0].ref : isFn ? state.ref : null;
  reactExports.useImperativeHandle(ref, () => ({
    start: start2,
    stop: stop2,
    get controllers() {
      return state.springs;
    }
  }));
  reactExports.useEffect(() => {
    if (!isFn || hasNewSprings) {
      props.forEach((p2, i2) => {
        springs[i2].setProp("config", p2.config);
        springs[i2].setProp("immediate", p2.immediate);
      });
    }
    if (hasNewSprings) {
      state.springs.forEach((s2) => s2.destroy());
      state.springs = springs;
      state.ref = ref;
      if (!ref) {
        springs.forEach((s2) => s2.start());
      }
    } else if (!isFn) {
      update2(props);
    }
  }, deps);
  reactExports.useEffect(() => {
    return () => state.springs.forEach((s2) => s2.destroy());
  }, []);
  const values = springs.map((s2) => _extends$h({}, s2.animated));
  return isFn ? [values, update2, stop2] : values;
};
const useSpring = (props, deps) => {
  const isFn = is$1.fun(props);
  const _useSprings = useSprings(1, isFn ? props : [props], deps), result = _useSprings[0], set2 = _useSprings[1], stop2 = _useSprings[2];
  return isFn ? [result[0], set2, stop2] : result;
};
assign({
  createAnimatedStyle: (style) => new AnimatedStyle(style),
  createAnimatedInterpolation: function createAnimatedInterpolation$$1(parents2) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return new AnimatedInterpolation(parents2, args);
  }
});
class AnimatedProps extends AnimatedObject {
  constructor(props, callback) {
    super(props.style && createAnimatedStyle ? _extends$h({}, props, {
      style: createAnimatedStyle(props.style)
    }) : props);
    this.update = void 0;
    this.update = callback;
    this.attach();
  }
}
const createAnimatedComponent = (Component) => {
  const AnimatedComponent = reactExports.forwardRef((props, _ref) => {
    const forceUpdate = useForceUpdate();
    const mounted = reactExports.useRef(true);
    const propsAnimated = reactExports.useRef(null);
    const node = reactExports.useRef(null);
    const attachProps = reactExports.useCallback((props2) => {
      const oldPropsAnimated = propsAnimated.current;
      const callback = () => {
        if (node.current) {
          const didUpdate = applyAnimatedValues(node.current, propsAnimated.current.getAnimatedValue());
          if (didUpdate === false)
            forceUpdate();
        }
      };
      propsAnimated.current = new AnimatedProps(props2, callback);
      oldPropsAnimated && oldPropsAnimated.detach();
    }, []);
    reactExports.useEffect(() => () => {
      mounted.current = false;
      propsAnimated.current && propsAnimated.current.detach();
    }, []);
    reactExports.useImperativeHandle(_ref, () => createAnimatedRef(node, mounted, forceUpdate));
    attachProps(props);
    const _getValue2 = propsAnimated.current.getValue();
    _getValue2.scrollTop;
    _getValue2.scrollLeft;
    const animatedProps = _objectWithoutPropertiesLoose(_getValue2, ["scrollTop", "scrollLeft"]);
    return React.createElement(Component, _extends$h({}, animatedProps, {
      ref: (childRef) => node.current = handleRef(childRef, _ref)
    }));
  });
  return AnimatedComponent;
};
function withExtend(animated, options) {
  if (options === void 0) {
    options = {};
  }
  const self2 = animated;
  self2.extend = function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    args.forEach((arg) => extend3(arg));
    return self2;
  };
  return self2;
  function extend3(arg, overrideKey) {
    if (is$1.arr(arg)) {
      return arg.forEach((arg2) => extend3(arg2));
    }
    if (is$1.obj(arg)) {
      for (const key2 in arg)
        extend3(arg[key2], key2);
      return;
    }
    let key = is$1.str(overrideKey) ? overrideKey : is$1.str(arg) ? arg : arg && is$1.str(arg.displayName) ? arg.displayName : is$1.fun(arg) ? arg.name : "";
    if (options.lowercase) {
      key = key[0].toLowerCase() + key.slice(1);
    }
    self2[key] = animated(arg);
  }
}
const elements = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
const animated$1 = withExtend(createAnimatedComponent).extend(elements);
animated$1.extend;
let isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
const prefixKey = (prefix, key) => prefix + key.charAt(0).toUpperCase() + key.substring(1);
const prefixes = ["Webkit", "Ms", "Moz", "O"];
isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
  prefixes.forEach((prefix) => acc[prefixKey(prefix, prop)] = acc[prop]);
  return acc;
}, isUnitlessNumber);
function dangerousStyleValue(name, value, isCustomProperty) {
  if (value == null || typeof value === "boolean" || value === "")
    return "";
  if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))
    return value + "px";
  return ("" + value).trim();
}
const attributeCache = {};
function applyAnimatedValues$1(instance, props) {
  if (!instance.nodeType || !instance.setAttribute) {
    return false;
  }
  const _ref = props, style = _ref.style, children = _ref.children, scrollTop = _ref.scrollTop, scrollLeft = _ref.scrollLeft, attributes = _objectWithoutPropertiesLoose(_ref, ["style", "children", "scrollTop", "scrollLeft"]);
  if (scrollTop !== void 0)
    instance.scrollTop = scrollTop;
  if (scrollLeft !== void 0)
    instance.scrollLeft = scrollLeft;
  if (children !== void 0)
    instance.textContent = children;
  for (let styleName in style) {
    if (!style.hasOwnProperty(styleName))
      continue;
    var isCustomProperty = styleName.indexOf("--") === 0;
    var styleValue = dangerousStyleValue(styleName, style[styleName], isCustomProperty);
    if (styleName === "float")
      styleName = "cssFloat";
    if (isCustomProperty)
      instance.style.setProperty(styleName, styleValue);
    else
      instance.style[styleName] = styleValue;
  }
  const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
  for (let name in attributes) {
    const attributeName = isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(/([A-Z])/g, (n2) => "-" + n2.toLowerCase()));
    instance.setAttribute(attributeName, attributes[name]);
  }
}
const NUMBER = "[-+]?\\d*\\.?\\d+";
const PERCENTAGE = NUMBER + "%";
function call() {
  for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
    parts[_key] = arguments[_key];
  }
  return "\\(\\s*(" + parts.join(")\\s*,\\s*(") + ")\\s*\\)";
}
const rgb = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER));
const rgba = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER));
const hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE));
const hsla = new RegExp("hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));
const hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
const hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
const hex6 = /^#([0-9a-fA-F]{6})$/;
const hex8 = /^#([0-9a-fA-F]{8})$/;
const colors = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
};
function normalizeColor(color2) {
  let match5;
  if (typeof color2 === "number") {
    return color2 >>> 0 === color2 && color2 >= 0 && color2 <= 4294967295 ? color2 : null;
  }
  if (match5 = hex6.exec(color2))
    return parseInt(match5[1] + "ff", 16) >>> 0;
  if (colors.hasOwnProperty(color2))
    return colors[color2];
  if (match5 = rgb.exec(color2)) {
    return (parse255(match5[1]) << 24 | // r
    parse255(match5[2]) << 16 | // g
    parse255(match5[3]) << 8 | // b
    255) >>> // a
    0;
  }
  if (match5 = rgba.exec(color2)) {
    return (parse255(match5[1]) << 24 | // r
    parse255(match5[2]) << 16 | // g
    parse255(match5[3]) << 8 | // b
    parse1(match5[4])) >>> // a
    0;
  }
  if (match5 = hex3.exec(color2)) {
    return parseInt(
      match5[1] + match5[1] + // r
      match5[2] + match5[2] + // g
      match5[3] + match5[3] + // b
      "ff",
      // a
      16
    ) >>> 0;
  }
  if (match5 = hex8.exec(color2))
    return parseInt(match5[1], 16) >>> 0;
  if (match5 = hex4.exec(color2)) {
    return parseInt(
      match5[1] + match5[1] + // r
      match5[2] + match5[2] + // g
      match5[3] + match5[3] + // b
      match5[4] + match5[4],
      // a
      16
    ) >>> 0;
  }
  if (match5 = hsl.exec(color2)) {
    return (hslToRgb$1(
      parse360(match5[1]),
      // h
      parsePercentage(match5[2]),
      // s
      parsePercentage(match5[3])
      // l
    ) | 255) >>> // a
    0;
  }
  if (match5 = hsla.exec(color2)) {
    return (hslToRgb$1(
      parse360(match5[1]),
      // h
      parsePercentage(match5[2]),
      // s
      parsePercentage(match5[3])
      // l
    ) | parse1(match5[4])) >>> // a
    0;
  }
  return null;
}
function hue2rgb(p2, q2, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p2 + (q2 - p2) * 6 * t2;
  if (t2 < 1 / 2)
    return q2;
  if (t2 < 2 / 3)
    return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
  return p2;
}
function hslToRgb$1(h2, s2, l2) {
  const q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
  const p2 = 2 * l2 - q2;
  const r2 = hue2rgb(p2, q2, h2 + 1 / 3);
  const g2 = hue2rgb(p2, q2, h2);
  const b2 = hue2rgb(p2, q2, h2 - 1 / 3);
  return Math.round(r2 * 255) << 24 | Math.round(g2 * 255) << 16 | Math.round(b2 * 255) << 8;
}
function parse255(str) {
  const int = parseInt(str, 10);
  if (int < 0)
    return 0;
  if (int > 255)
    return 255;
  return int;
}
function parse360(str) {
  const int = parseFloat(str);
  return (int % 360 + 360) % 360 / 360;
}
function parse1(str) {
  const num = parseFloat(str);
  if (num < 0)
    return 0;
  if (num > 1)
    return 255;
  return Math.round(num * 255);
}
function parsePercentage(str) {
  const int = parseFloat(str);
  if (int < 0)
    return 0;
  if (int > 100)
    return 1;
  return int / 100;
}
function colorToRgba(input2) {
  let int32Color = normalizeColor(input2);
  if (int32Color === null)
    return input2;
  int32Color = int32Color || 0;
  let r2 = (int32Color & 4278190080) >>> 24;
  let g2 = (int32Color & 16711680) >>> 16;
  let b2 = (int32Color & 65280) >>> 8;
  let a2 = (int32Color & 255) / 255;
  return `rgba(${r2}, ${g2}, ${b2}, ${a2})`;
}
const stringShapeRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
const colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
const colorNamesRegex = new RegExp(`(${Object.keys(colors).join("|")})`, "g");
const createStringInterpolator$1 = (config2) => {
  const outputRange = config2.output.map((rangeValue) => rangeValue.replace(colorRegex, colorToRgba)).map((rangeValue) => rangeValue.replace(colorNamesRegex, colorToRgba));
  const outputRanges = outputRange[0].match(stringShapeRegex).map(() => []);
  outputRange.forEach((value) => {
    value.match(stringShapeRegex).forEach((number, i2) => outputRanges[i2].push(+number));
  });
  const interpolations = outputRange[0].match(stringShapeRegex).map((_value, i2) => createInterpolator(_extends$h({}, config2, {
    output: outputRanges[i2]
  })));
  return (input2) => {
    let i2 = 0;
    return outputRange[0].replace(stringShapeRegex, () => interpolations[i2++](input2)).replace(/rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi, (_, p1, p2, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`);
  };
};
assign({
  defaultElement: "div",
  colorNames: colors,
  applyAnimatedValues: applyAnimatedValues$1,
  createStringInterpolator: createStringInterpolator$1
});
function GridItem(_a) {
  var children = _a.children, style = _a.style, className = _a.className, other = __rest(_a, ["children", "style", "className"]);
  var context2 = reactExports.useContext(GridItemContext);
  if (!context2) {
    throw Error("Unable to find GridItem context. Please ensure that GridItem is used as a child of GridDropZone");
  }
  var top = context2.top, disableDrag = context2.disableDrag, endTraverse = context2.endTraverse, onStart = context2.onStart, mountWithTraverseTarget = context2.mountWithTraverseTarget, left = context2.left, i2 = context2.i, onMove = context2.onMove, onEnd = context2.onEnd, grid = context2.grid, isDragging = context2.dragging;
  var columnWidth = grid.columnWidth, rowHeight = grid.rowHeight;
  var dragging = reactExports.useRef(false);
  var startCoords = reactExports.useRef([left, top]);
  var _b = __read(useSpring(function() {
    if (mountWithTraverseTarget) {
      var mountXY = mountWithTraverseTarget;
      endTraverse();
      return {
        xy: mountXY,
        immediate: true,
        zIndex: "1",
        scale: 1.1,
        opacity: 0.8
      };
    }
    return {
      xy: [left, top],
      immediate: true,
      zIndex: "0",
      scale: 1,
      opacity: 1
    };
  }), 2), styles2 = _b[0], set2 = _b[1];
  function handleMove(state, e2) {
    var x = startCoords.current[0] + state.delta[0];
    var y2 = startCoords.current[1] + state.delta[1];
    set2({
      xy: [x, y2],
      zIndex: "1",
      immediate: true,
      opacity: 0.8,
      scale: 1.1
    });
    onMove(state, x, y2);
  }
  function handleEnd(state) {
    var x = startCoords.current[0] + state.delta[0];
    var y2 = startCoords.current[1] + state.delta[1];
    dragging.current = false;
    onEnd(state, x, y2);
  }
  var bind = useGestureResponder({
    onMoveShouldSet: function(state) {
      if (disableDrag) {
        return false;
      }
      onStart();
      startCoords.current = [left, top];
      dragging.current = true;
      return true;
    },
    onMove: handleMove,
    onTerminationRequest: function() {
      if (dragging.current) {
        return false;
      }
      return true;
    },
    onTerminate: handleEnd,
    onRelease: handleEnd
  }, {
    enableMouse: true
  }).bind;
  reactExports.useEffect(function() {
    if (!dragging.current) {
      set2({
        xy: [left, top],
        zIndex: "0",
        opacity: 1,
        scale: 1,
        immediate: false
      });
    }
  }, [dragging.current, left, top]);
  var props = __assign({ className: "GridItem" + (isDragging ? " dragging" : "") + (!!disableDrag ? " disabled" : "") + className ? " " + className : "" }, bind, { style: __assign({ cursor: !!disableDrag ? "grab" : void 0, zIndex: styles2.zIndex, position: "absolute", width: columnWidth + "px", opacity: styles2.opacity, height: rowHeight + "px", boxSizing: "border-box", transform: createAnimatedInterpolation([styles2.xy, styles2.scale], function(xy, s2) {
    return "translate3d(" + xy[0] + "px, " + xy[1] + "px, 0) scale(" + s2 + ")";
  }) }, style) }, other);
  return typeof children === "function" ? children(animated$1.div, props, {
    dragging: isDragging,
    disabled: !!disableDrag,
    i: i2,
    grid
  }) : reactExports.createElement(animated$1.div, __assign({}, props), children);
}
const imageIconButton = "_imageIconButton_12ufg_1";
const imageContainer$1 = "_imageContainer_12ufg_9";
const addAnswerIcon = "_addAnswerIcon_12ufg_15";
const addAnswerButton = "_addAnswerButton_12ufg_19";
const styles$w = {
  imageIconButton,
  imageContainer: imageContainer$1,
  addAnswerIcon,
  addAnswerButton
};
var Add = {};
var _interopRequireDefault$h = interopRequireDefaultExports;
Object.defineProperty(Add, "__esModule", {
  value: true
});
var default_1$9 = Add.default = void 0;
var _createSvgIcon$9 = _interopRequireDefault$h(requireCreateSvgIcon());
var _jsxRuntime$9 = jsxRuntimeExports;
var _default$c = (0, _createSvgIcon$9.default)(/* @__PURE__ */ (0, _jsxRuntime$9.jsx)("path", {
  d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"
}), "Add");
default_1$9 = Add.default = _default$c;
function ImageChoiceQuestionItem({
  qualifiedCode,
  imageHeight,
  hideText,
  spacing,
  type: type2,
  addAnswer
}) {
  var _a;
  const dispatch = useDispatch();
  const theme = useTheme();
  const langInfo = useSelector((state) => {
    return state.designState.langInfo;
  });
  const answer = useSelector((state) => {
    return type2 == "add" ? void 0 : state.designState[qualifiedCode];
  });
  const onMainLang = langInfo.lang === langInfo.mainLang;
  const lang2 = langInfo.lang;
  const content = useSelector((state) => {
    var _a2, _b;
    return type2 == "add" ? void 0 : (_b = (_a2 = state.designState[qualifiedCode].content) == null ? void 0 : _a2["label"]) == null ? void 0 : _b[lang2];
  });
  const mainContent = useSelector((state) => {
    var _a2, _b;
    return type2 == "add" ? void 0 : (_b = (_a2 = state.designState[qualifiedCode].content) == null ? void 0 : _a2["label"]) == null ? void 0 : _b[langInfo.mainLang];
  });
  const onDelete = () => {
    if (window.confirm(`Are you sure?`)) {
      dispatch(removeAnswer(qualifiedCode));
    }
  };
  const backgroundImage = ((_a = answer == null ? void 0 : answer.resources) == null ? void 0 : _a.image) ? `url('${buildResourceUrl(answer.resources.image)}')` : "0";
  function handleImageChange(e2) {
    e2.preventDefault();
    let file = e2.target.files[0];
    DesignService.uploadResource(file).then((response) => {
      dispatch(
        changeResources({
          code: qualifiedCode,
          key: "image",
          value: file.name
        })
      );
    }).catch((err) => {
      console.error(err);
    });
  }
  return type2 == "add" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    GridItem,
    {
      style: {
        padding: spacing + "px"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Card,
        {
          className: styles$w.addAnswerButton,
          style: {
            backgroundColor: theme.palette.background.default,
            height: imageHeight + "px",
            width: "100%"
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconButton,
            {
              className: styles$w.addAnswerIcon,
              onClick: () => {
                addAnswer();
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$9, {})
            }
          )
        }
      )
    },
    "add"
  ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
    GridItem,
    {
      style: {
        padding: spacing + "px"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Card,
          {
            className: styles$w.imageContainer,
            style: {
              backgroundImage,
              backgroundColor: theme.palette.background.default,
              height: imageHeight + "px"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton,
                {
                  className: styles$w.imageIconButton,
                  onClick: () => {
                    onDelete();
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$h, {})
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(IconButton, { component: "label", className: styles$w.imageIconButton, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    hidden: true,
                    id: qualifiedCode,
                    accept: "image/*",
                    multiple: true,
                    type: "file",
                    onChange: handleImageChange
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$r, {})
              ] })
            ]
          }
        ),
        !hideText && /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            variant: "standard",
            value: content || "",
            onChange: (e2) => dispatch(
              changeContent({
                code: qualifiedCode,
                key: "label",
                lang: lang2,
                value: e2.target.value
              })
            ),
            placeholder: onMainLang ? "Option" : mainContent || "Option",
            InputProps: {
              sx: {
                fontFamily: theme.textStyles.text.font,
                color: theme.textStyles.text.color,
                fontSize: theme.textStyles.text.size
              }
            }
          }
        )
      ]
    },
    qualifiedCode
  );
}
function ImageChoiceQuestion(props) {
  const containerRef = reactExports.useRef(null);
  const dispatch = useDispatch();
  const [width, setWidth] = reactExports.useState(800);
  const children = useSelector((state) => {
    return state.designState[props.code].children || [];
  });
  const questionType = useSelector((state) => {
    return state.designState[props.code].type;
  });
  const childrenWithAdd = [...children, { type: "add", code: "add" }];
  const columnNumber = useSelector((state) => {
    return state.designState[props.code].columns || 2;
  });
  const hideText = useSelector((state) => {
    return state.designState[props.code].hideText || false;
  });
  const spacing = useSelector((state) => {
    return state.designState[props.code].spacing || 8;
  });
  const imageAspectRatio = useSelector((state) => {
    return state.designState[props.code].imageAspectRatio || 1;
  });
  const textHeight = hideText ? 0 : 80;
  const imageHeight = (width - columnNumber * spacing * 2) / columnNumber / imageAspectRatio;
  const totalHeight = Math.ceil(((children ? children.length : 0) + 1) / columnNumber) * (imageHeight + textHeight + columnNumber * spacing);
  const onChange = (sourceId, sourceIndex, targetIndex, targetId) => {
    if (sourceIndex < childrenWithAdd.length - 1 && targetIndex < childrenWithAdd.length - 1) {
      const payload = {
        type: "reorder_answers",
        id: children[sourceIndex].qualifiedCode,
        fromIndex: sourceIndex,
        toIndex: targetIndex
      };
      dispatch(onDrag(payload));
    }
  };
  reactExports.useEffect(() => {
    var _a;
    setWidth((_a = containerRef == null ? void 0 : containerRef.current) == null ? void 0 : _a.offsetWidth);
  }, [containerRef]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref: containerRef,
      className: styles$x.questionItem,
      style: {
        direction: "ltr"
      },
      children: imageHeight && /* @__PURE__ */ jsxRuntimeExports.jsx(GridContextProvider, { onChange, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        GridDropZone,
        {
          id: "items-" + props.code,
          boxesPerRow: columnNumber,
          rowHeight: imageHeight + textHeight + spacing,
          style: { height: totalHeight + "px" },
          children: childrenWithAdd.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            ImageChoiceQuestionItem,
            {
              spacing,
              addAnswer: () => props.addNewAnswer(props.code, questionType),
              type: item.type,
              imageHeight,
              hideText,
              qualifiedCode: item.qualifiedCode
            },
            item.code
          ))
        }
      ) })
    }
  );
}
const placeholder$1 = "_placeholder_4iqf5_1";
const buttonContainer$1 = "_buttonContainer_4iqf5_9";
const styles$v = {
  placeholder: placeholder$1,
  buttonContainer: buttonContainer$1
};
function VideoDisplayDesign({ code }) {
  var _a;
  useTheme();
  const dispatch = useDispatch();
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const handleVideoUpload = (e2) => {
    e2.preventDefault();
    let file = e2.target.files[0];
    DesignService.uploadResource(file).then((response) => {
      dispatch(changeResources({ code, key: "videoUrl", value: file.name }));
    }).catch((err) => {
      console.error(err);
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    ((_a = state.resources) == null ? void 0 : _a.videoUrl) && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          position: "relative",
          marginTop: "16px",
          // 16:9 aspect ratio
          paddingTop: state.audio_only ? "10%" : "56%"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          ReactPlayer,
          {
            url: buildResourceUrl(state.resources.videoUrl),
            loop: state.loop || false,
            light: true,
            controls: true,
            config: {
              forceAudio: state.audio_only || false
            },
            style: {
              backgroundColor: "black",
              position: "absolute",
              top: "0",
              left: "0"
            },
            volume: 1,
            width: "100%",
            height: "100%"
          }
        )
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$v.buttonContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Button,
      {
        component: "label",
        variant: "outlined",
        startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$s, {}),
        children: [
          state.video ? "Replace Video" : "Upload Video",
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              hidden: true,
              id: code,
              accept: "video/*",
              multiple: true,
              type: "file",
              onChange: handleVideoUpload
            }
          )
        ]
      }
    ) })
  ] });
}
const signatureCanvas = "_signatureCanvas_1uxb1_1";
const styles$u = {
  signatureCanvas
};
function SignatureDesign() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      className: styles$u.signatureCanvas,
      sx: { backgroundColor: "background.default" },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: "/signature.png",
          style: {
            backgroundColor: "rgba(255,255,255,255)",
            width: "80%",
            maxWidth: "500px",
            height: "200px"
          }
        }
      )
    }
  );
}
const placeholder = "_placeholder_xjf3c_1";
const buttonContainer = "_buttonContainer_xjf3c_9";
const imageContainer = "_imageContainer_xjf3c_14";
const styles$t = {
  placeholder,
  buttonContainer,
  imageContainer
};
function ImageDisplayDesign({ code }) {
  var _a;
  const dispatch = useDispatch();
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const handleUpload = (e2) => {
    e2.preventDefault();
    let file = e2.target.files[0];
    DesignService.uploadResource(file).then((response) => {
      dispatch(changeResources({ code, key: "imageUrl", value: file.name }));
    }).catch((err) => {
      console.error(err);
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    ((_a = state.resources) == null ? void 0 : _a.imageUrl) && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        style: {
          width: "100%"
        },
        src: buildResourceUrl(state.resources.imageUrl)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$t.buttonContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { component: "label", variant: "outlined", startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$r, {}), children: [
      state.video ? "Replace Image" : "Upload Image",
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          hidden: true,
          id: code,
          accept: "image/*",
          type: "file",
          onChange: handleUpload
        }
      )
    ] }) })
  ] });
}
const choicesContainer = "_choicesContainer_k0bnu_1";
const choice = "_choice_k0bnu_1";
const choiceLabels = "_choiceLabels_k0bnu_19";
const styles$s = {
  choicesContainer,
  choice,
  choiceLabels
};
function NPSDesign({ code }) {
  var _a, _b, _c, _d;
  useTheme();
  let columns = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const lang2 = useSelector((state2) => {
    return state2.designState.langInfo.lang;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: styles$s.choiceLabels, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: (_b = (_a = state.content) == null ? void 0 : _a.lower_bound_hint) == null ? void 0 : _b[lang2] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: (_d = (_c = state.content) == null ? void 0 : _c.higher_bound_hint) == null ? void 0 : _d[lang2] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: styles$s.choicesContainer, children: columns.map((option) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: styles$s.choice, children: option }, option);
    }) })
  ] });
}
const container$2 = "_container_cyg3h_1";
const styles$r = {
  container: container$2
};
function PhotoCaptureDesign({ code }) {
  var _a, _b;
  useTheme$1();
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const lang2 = useSelector((state2) => {
    return state2.designState.langInfo.lang;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: styles$r.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        src: "/camera.png",
        style: {
          maxHeight: "200px"
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    state.showHint && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: ((_b = (_a = state.content) == null ? void 0 : _a.hint) == null ? void 0 : _b[lang2]) || "" })
  ] });
}
const container$1 = "_container_cyg3h_1";
const styles$q = {
  container: container$1
};
function VideoCaptureDesign({ code }) {
  var _a, _b;
  useTheme$1();
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const lang2 = useSelector((state2) => {
    return state2.designState.langInfo.lang;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: styles$q.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        src: "/video.png",
        style: {
          maxHeight: "200px"
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    state.showHint && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: ((_b = (_a = state.content) == null ? void 0 : _a.hint) == null ? void 0 : _b[lang2]) || "" })
  ] });
}
const container = "_container_cyg3h_1";
const styles$p = {
  container
};
function BarcodeDesign({ code }) {
  var _a, _b;
  useTheme$1();
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const lang2 = useSelector((state2) => {
    return state2.designState.langInfo.lang;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: styles$p.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        src: "/barcode.png",
        style: {
          maxHeight: "200px"
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    state.showHint && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: ((_b = (_a = state.content) == null ? void 0 : _a.hint) == null ? void 0 : _b[lang2]) || "" })
  ] });
}
function QuestionDesign({ code, type: type2, parentCode, dragHandleProps, t: t2 }) {
  console.log(code);
  const dispatch = useDispatch();
  const theme = useTheme();
  const isInSetup = useSelector((state) => {
    var _a;
    return ((_a = state.designState.setup) == null ? void 0 : _a.code) == code;
  });
  const children = useSelector((state) => {
    return state.designState[code].children;
  });
  const collapsed = useSelector((state) => {
    return state.designState[code].collapsed;
  });
  const toggleCollapse = () => {
    dispatch(toggleComponentCollapse(code));
  };
  const showQuestion = () => {
    switch (type2) {
      case "video_display":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(VideoDisplayDesign, { code }, code);
      case "image_display":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(ImageDisplayDesign, { code }, code);
      case "signature":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(SignatureDesign, {});
      case "photo_capture":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(PhotoCaptureDesign, { code });
      case "video_capture":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(VideoCaptureDesign, { code });
      case "date_time":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(DateTimeQuestionDesign, { code }, code);
      case "date":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(DateTimeQuestionDesign, { code }, code);
      case "time":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(TimeQuestionDesign, { code }, code);
      case "scq":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          ChoiceQuestion,
          {
            t: t2,
            addNewAnswer: addAnswer,
            code,
            type: "radio"
          },
          code
        );
      case "image_mcq":
      case "image_scq":
      case "image_ranking":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          ImageChoiceQuestion,
          {
            t: t2,
            addNewAnswer: addAnswer,
            code
          },
          code
        );
      case "scq_array":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(SCQArray, { addNewAnswer: addAnswer, code, t: t2 }, code);
      case "file_upload":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(FileUploadQuestionDesign, { code }, code);
      case "mcq":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          ChoiceQuestion,
          {
            addNewAnswer: addAnswer,
            code,
            t: t2,
            type: "checkbox"
          },
          code
        );
      case "ranking":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          ChoiceQuestion,
          {
            addNewAnswer: addAnswer,
            code,
            t: t2,
            type: "ranking"
          },
          code
        );
      case "nps":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(NPSDesign, { code }, code);
      case "number":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(NumberQuestionDesign, { code }, code);
      case "text":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(TextQuestionDesign, { code }, code);
      case "paragraph":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(ParagraphQuestionDesign, { t: t2, code }, code);
      case "barcode":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(BarcodeDesign, { t: t2, code }, code);
      case "email":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(EmailQuestionDesign, { code }, code);
      default:
        return "";
    }
  };
  const addAnswer = (questionCode, questionType, type22) => {
    const answers = children || [];
    let nextAnswerIndex = 1;
    let code2 = "";
    let qualifiedCode = "";
    let label2 = "";
    const valueInstruction = {
      code: "value",
      isActive: false,
      returnType: {
        name: questionType == "ranking" || questionType == "nps" || questionType == "image_ranking" ? "Int" : "Boolean"
      },
      text: ""
    };
    switch (type22) {
      case "column":
        nextAnswerIndex = nextId$1(answers.filter((el) => el.type === "column"));
        label2 = "Col" + nextAnswerIndex;
        code2 = "Ac" + nextAnswerIndex;
        qualifiedCode = questionCode + code2;
        dispatch(
          addNewAnswer({ label: label2, answer: { code: code2, qualifiedCode, type: type22 } })
        );
        break;
      case "row":
        nextAnswerIndex = nextId$1(answers.filter((el) => el.type === "row"));
        code2 = "A" + nextAnswerIndex;
        label2 = "Row" + nextAnswerIndex;
        qualifiedCode = questionCode + code2;
        dispatch(
          addNewAnswer({
            label: label2,
            instructionList: [valueInstruction],
            answer: { code: code2, qualifiedCode, type: type22 }
          })
        );
        break;
      case "other":
        code2 = "Aother";
        label2 = "Other";
        qualifiedCode = questionCode + code2;
        const instructionListForText = [
          {
            code: "value",
            isActive: false,
            returnType: {
              name: "String"
            },
            text: ""
          },
          {
            code: "conditional_relevance",
            isActive: true,
            returnType: {
              name: "Boolean"
            },
            text: questionType === "scq" ? `${questionCode}.value === 'Aother'` : `${questionCode}Aother.value === true`
          }
        ];
        dispatch(
          addNewAnswer({
            label: label2,
            answer: { code: code2, qualifiedCode, type: type22 },
            instructionList: questionType == "mcq" ? [valueInstruction] : []
          })
        );
        dispatch(
          addNewAnswer({
            instructionList: instructionListForText,
            answer: {
              code: "Atext",
              qualifiedCode: qualifiedCode + "Atext",
              type: "other_text"
            }
          })
        );
        break;
      default:
        nextAnswerIndex = nextId$1(answers);
        code2 = "A" + nextAnswerIndex;
        label2 = "Option" + nextAnswerIndex;
        qualifiedCode = questionCode + code2;
        dispatch(
          addNewAnswer({
            label: label2,
            answer: { code: code2, qualifiedCode },
            instructionList: questionType == "mcq" || questionType == "image_mcq" || questionType == "ranking" || questionType == "image_ranking" ? [valueInstruction] : []
          })
        );
        break;
    }
  };
  const setSetup = React.useCallback(() => {
    dispatch(setup({ code, rules: setupOptions(type2) }));
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: {
        backgroundColor: isInSetup ? "beige" : "background.paper",
        borderColor: "grey.500"
      },
      className: `${styles$H.groupQuestion}`,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$H.questionWrapper, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$H.moveBox, ...dragHandleProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$o, {}) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ActionToolbar,
              {
                t: t2,
                isGroup: false,
                code,
                parentCode,
                toggleCollapse,
                collapsed,
                onClone: () => dispatch(cloneQuestion(code)),
                onDelete: () => dispatch(deleteQuestion(code)),
                disableDelete: false
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: styles$H.titleQuestion,
              style: {
                fontFamily: theme.textStyles.question.font,
                color: theme.textStyles.question.color,
                fontSize: theme.textStyles.question.size
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                ContentEditor$2,
                {
                  code,
                  extended: false,
                  onActive: setSetup,
                  placeholder: "Title",
                  contentKey: "label"
                }
              )
            }
          ),
          !collapsed && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: styles$H.textDescriptionContent, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            ContentEditor$2,
            {
              code,
              onActive: setSetup,
              extended: true,
              placeholder: "Description",
              contentKey: "description"
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Collapse, { in: collapsed !== true, timeout: "auto", unmountOnExit: true, children: showQuestion() }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorDisplay$1, { code })
      ]
    }
  );
}
const QuestionDesign$1 = React.memo(QuestionDesign);
const textHeader = "_textHeader_iiwtl_1";
const textDescription = "_textDescription_iiwtl_6";
const titleRow = "_titleRow_iiwtl_12";
const groupCard = "_groupCard_iiwtl_23";
const groupEmptyHint$1 = "_groupEmptyHint_iiwtl_33";
const type = "_type_iiwtl_43";
const questionsOuterContainer = "_questionsOuterContainer_iiwtl_50";
const questionsInnerContainer = "_questionsInnerContainer_iiwtl_54";
const groupDesignError = "_groupDesignError_iiwtl_59";
const groupHeader = "_groupHeader_iiwtl_64";
const inputGroupTitle = "_inputGroupTitle_iiwtl_70";
const inputGroupDescription = "_inputGroupDescription_iiwtl_75";
const moveBox = "_moveBox_iiwtl_80";
const styles$o = {
  textHeader,
  textDescription,
  titleRow,
  groupCard,
  groupEmptyHint: groupEmptyHint$1,
  type,
  questionsOuterContainer,
  questionsInnerContainer,
  groupDesignError,
  groupHeader,
  inputGroupTitle,
  inputGroupDescription,
  moveBox
};
function GroupDesign(props) {
  console.log(props.code);
  const dispatch = useDispatch();
  const [open, setOpen] = React.useState(false);
  const collapsed = useSelector((state) => {
    return state.designState[props.code].collapsed;
  });
  const isInSetup = useSelector((state) => {
    var _a;
    return ((_a = state.designState.setup) == null ? void 0 : _a.code) == props.code;
  });
  const children = useSelector((state) => {
    return state.designState[props.code].children;
  });
  const toggleCollapse = () => {
    dispatch(toggleComponentCollapse(props.code));
  };
  const setSetup = React.useCallback(() => {
    dispatch(setup({ code: props.code, rules: setupOptions("group") }));
  });
  const theme = useTheme();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      PublicDraggable,
      {
        isDragDisabled: props.isDragDisabled,
        draggableId: props.code,
        index: props.dragIndex,
        children: (provided) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: provided.innerRef, ...provided.draggableProps, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            className: styles$o.groupCard,
            sx: {
              borderColor: "grey.500",
              boxShadow: 1,
              backgroundColor: isInSetup ? "beige" : "background.paper"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Box,
                {
                  sx: { backgroundColor: "primary.main", height: "8px" },
                  className: styles$o.groupHeader
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  ...provided.dragHandleProps,
                  className: styles$o.moveBox,
                  onMouseDown: (event) => {
                    if (props.isDragDisabled) {
                      event.preventDefault();
                      setOpen(true);
                    }
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$o, {})
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                ActionToolbar,
                {
                  code: props.code,
                  t: props.t,
                  isGroup: true,
                  toggleCollapse,
                  collapsed,
                  onDelete: () => dispatch(deleteGroup(props.code)),
                  disableDelete: children && children.length > 0
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$o.titleRow, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: styles$o.textHeader,
                    style: {
                      fontFamily: theme.textStyles.group.font,
                      color: theme.textStyles.group.color,
                      fontSize: theme.textStyles.group.size
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      ContentEditor$2,
                      {
                        code: props.code,
                        extended: false,
                        onActive: setSetup,
                        contentKey: "label",
                        placeholder: "Title"
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: styles$o.textDescription, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ContentEditor$2,
                  {
                    code: props.code,
                    extended: true,
                    onActive: setSetup,
                    contentKey: "description",
                    placeholder: "Description"
                  }
                ) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorDisplay$1, { type: "group", code: props.code })
            ]
          }
        ) })
      },
      props.code
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Collapse,
      {
        className: styles$o.questionsOuterContainer,
        in: collapsed !== true,
        sx: { backgroundColor: isInSetup ? "beige" : "background.paper" },
        timeout: "auto",
        unmountOnExit: true,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectedDroppable, { droppableId: props.code, type: "questions", children: (provided) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            ref: provided.innerRef,
            ...provided.droppableProps,
            className: styles$o.questionsInnerContainer,
            sx: { backgroundColor: "background.default" },
            children: [
              children == null ? void 0 : children.map((quest, index2) => {
                return /* @__PURE__ */ jsxRuntimeExports.jsx(
                  PublicDraggable,
                  {
                    parentIndex: props.dragIndex,
                    draggableId: quest.code,
                    index: props.dragIndex + index2 + 1,
                    children: (provided2, snapshot) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "div",
                      {
                        ref: provided2.innerRef,
                        snapshot,
                        ...provided2.draggableProps,
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$o.type, children: [
                            iconByType(quest.type, "small"),
                            " ",
                            props.t("component_" + quest.type + "_title")
                          ] }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            QuestionDesign$1,
                            {
                              t: props.t,
                              dragHandleProps: provided2.dragHandleProps,
                              parentCode: props.code,
                              index: index2,
                              type: quest.type,
                              code: quest.code
                            },
                            quest.code
                          )
                        ]
                      }
                    )
                  },
                  quest.code
                );
              }),
              !children && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$o.groupEmptyHint, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: props.t("empty_group_hint") }) }),
              provided.placeholder
            ]
          }
        ) })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Dialog,
      {
        open,
        onClose: () => setOpen(false),
        "aria-labelledby": "alert-dialog-title-collapse-all",
        "aria-describedby": "alert-dialog-description",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { id: "alert-dialog-title-collapse-all", children: "All Groups Must be collapsed first before you can drag them... Collapse All?" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogActions, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => setOpen(false), children: "Cancel" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                onClick: () => {
                  dispatch(collapseAllGroups());
                  setOpen(false);
                },
                children: "Collapse"
              }
            )
          ] })
        ]
      }
    )
  ] });
}
const GroupDesign$1 = React.memo(GroupDesign);
const surveyGroups = "_surveyGroups_10g3b_1";
const groupEmptyHint = "_groupEmptyHint_10g3b_8";
const footer = "_footer_10g3b_18";
const contentPanel = "_contentPanel_10g3b_22";
const headerImage = "_headerImage_10g3b_30";
const styles$n = {
  surveyGroups,
  groupEmptyHint,
  footer,
  contentPanel,
  headerImage
};
function ContentPanel(props) {
  var _a;
  const theme = useTheme();
  let isDragDisabled = false;
  const codeIndex = useSelector((state) => {
    return buildIndex(state.designState, props.groups);
  }, isEquivalent);
  const collapseInfo = useSelector((state) => {
    var _a2;
    const info = {};
    (_a2 = props.groups) == null ? void 0 : _a2.forEach((element) => {
      info[element.code] = state.designState[element.code].collapsed;
    });
    return info;
  }, isEquivalent);
  (_a = props.groups) == null ? void 0 : _a.forEach((group3) => {
    if (group3 && !collapseInfo[group3.code]) {
      isDragDisabled = true;
    }
  });
  const groupsEmpty = !props.groups;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: styles$n.contentPanel,
      style: {
        fontFamily: theme.textStyles.text.font,
        color: theme.textStyles.text.color,
        fontSize: theme.textStyles.text.size
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorDisplay$1, { code: "Survey" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectedDroppable, { droppableId: "content-panel", type: "groups", children: (provided) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            ref: provided.innerRef,
            ...provided.droppableProps,
            children: [
              props.headerImage && /* @__PURE__ */ jsxRuntimeExports.jsx(
                CardMedia,
                {
                  className: styles$n.cardImage,
                  component: "img",
                  image: buildResourceUrl(props.headerImage),
                  height: "140"
                }
              ),
              props.groups && props.groups.map((group3) => {
                const groupDesign = /* @__PURE__ */ jsxRuntimeExports.jsx(
                  GroupDesign$1,
                  {
                    className: styles$n.surveyGroups,
                    t: props.t,
                    code: group3.code,
                    dragIndex: codeIndex.indexOf(group3.code),
                    isDragDisabled
                  },
                  group3.code
                );
                return groupDesign;
              }),
              groupsEmpty && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$n.groupEmptyHint, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: props.t("empty_survey_hint") }) }),
              provided.placeholder,
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$n.footer })
            ]
          }
        ) })
      ]
    }
  );
}
const onDragEnd = (result, onDragListener) => {
  if (!result.destination) {
    return;
  } else if (result.type == "questions" && isGroup(result.source.droppableId) && isGroup(result.destination.droppableId)) {
    const payload = {
      type: "reorder_questions",
      source: result.source.droppableId,
      destination: result.destination.droppableId,
      id: result.draggableId,
      fromIndex: result.source.index,
      toIndex: result.destination.index
    };
    onDragListener(payload);
    return;
  } else if (result.type == "questions" && result.source.droppableId == "new-questions" && isGroup(result.destination.droppableId)) {
    const payload = {
      type: "new_question",
      questionType: result.draggableId,
      destination: result.destination.droppableId,
      toIndex: result.destination.index
    };
    onDragListener(payload);
    return;
  } else if (result.type == "groups" && isGroup(result.draggableId)) {
    const payload = {
      type: "reorder_groups",
      id: result.draggableId,
      fromIndex: result.source.index,
      toIndex: result.destination.index
    };
    onDragListener(payload);
    return;
  } else if (result.type == "groups" && result.source.droppableId == "new-groups") {
    const payload = {
      type: "new_group",
      groupType: result.draggableId,
      toIndex: result.destination.index
    };
    onDragListener(payload);
    return;
  } else if (result.type.startsWith("option")) {
    const payload = {
      type: "reorder_answers",
      id: result.draggableId,
      fromIndex: result.source.index,
      toIndex: result.destination.index
    };
    onDragListener(payload);
    return;
  } else if (result.type.startsWith("row") || result.type.startsWith("col")) {
    const payload = {
      type: "reorder_answers_by_type",
      id: result.draggableId,
      fromIndex: result.source.index,
      toIndex: result.destination.index
    };
    onDragListener(payload);
    return;
  }
};
var Palette = {};
var _interopRequireDefault$g = interopRequireDefaultExports;
Object.defineProperty(Palette, "__esModule", {
  value: true
});
var default_1$8 = Palette.default = void 0;
var _createSvgIcon$8 = _interopRequireDefault$g(requireCreateSvgIcon());
var _jsxRuntime$8 = jsxRuntimeExports;
var _default$b = (0, _createSvgIcon$8.default)(/* @__PURE__ */ (0, _jsxRuntime$8.jsx)("path", {
  d: "M12 2C6.49 2 2 6.49 2 12s4.49 10 10 10c1.38 0 2.5-1.12 2.5-2.5 0-.61-.23-1.2-.64-1.67-.08-.1-.13-.21-.13-.33 0-.28.22-.5.5-.5H16c3.31 0 6-2.69 6-6 0-4.96-4.49-9-10-9zm5.5 11c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm-3-4c-.83 0-1.5-.67-1.5-1.5S13.67 6 14.5 6s1.5.67 1.5 1.5S15.33 9 14.5 9zM5 11.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5S7.33 13 6.5 13 5 12.33 5 11.5zm6-4c0 .83-.67 1.5-1.5 1.5S8 8.33 8 7.5 8.67 6 9.5 6s1.5.67 1.5 1.5z"
}), "Palette");
default_1$8 = Palette.default = _default$b;
const leftContent = "_leftContent_1b40q_1";
const leftPanelGroupItem = "_leftPanelGroupItem_1b40q_9";
const close = "_close_1b40q_13";
const styles$m = {
  leftContent,
  leftPanelGroupItem,
  close
};
function FieldSize({
  label: label2,
  rule: rule3,
  defaultValue: defaultValue4,
  code,
  lowerBound,
  upperBound
}) {
  const dispatch = useDispatch();
  const value = useSelector((state) => {
    return state.designState[code][rule3] || defaultValue4;
  });
  const onValueChange = (event) => {
    dispatch(
      changeAttribute({
        code,
        key: rule3,
        value: Math.max(lowerBound, Math.min(upperBound, event.target.value))
      })
    );
  };
  const isError = value < lowerBound || value > upperBound;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { children: [
      label2,
      ":"
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextField,
      {
        label: label2,
        error: isError,
        variant: "outlined",
        type: "number",
        size: "small",
        style: { maxWidth: "200px" },
        value,
        onChange: (event) => onValueChange(event)
      }
    )
  ] });
}
const showHint = "_showHint_9iocv_1";
const inputValue$1 = "_inputValue_9iocv_9";
const styles$l = {
  showHint,
  inputValue: inputValue$1
};
function ShowHint({ code, t: t2 }) {
  const dispatch = useDispatch();
  const showHint2 = useSelector((state) => {
    return state.designState[code].showHint || false;
  });
  const setCheckedHint = (value) => {
    dispatch(changeAttribute({ code, key: "showHint", value }));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$l.showHint, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: t2("show_question_hint") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Switch,
        {
          checked: showHint2,
          onChange: (event) => setCheckedHint(event.target.checked)
        }
      )
    ] }),
    showHint2 && /* @__PURE__ */ jsxRuntimeExports.jsx(ContentEditor, { code, objectName: "hint" })
  ] });
}
function ContentEditor({ code, objectName, title: title2 }) {
  const dispatch = useDispatch();
  const setContentValue = (lang2, value) => {
    dispatch(changeContent({ code, key: objectName, lang: lang2, value }));
  };
  const languagesList = useSelector((state) => {
    return state.designState.langInfo.languagesList;
  });
  const hintObj = useSelector((state) => {
    var _a;
    return (_a = state.designState[code].content) == null ? void 0 : _a[objectName];
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    title2 && /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: title2 }),
    languagesList.map((lang2) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$l.inputValue, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextField,
        {
          label: lang2.langName,
          variant: "standard",
          type: "text",
          value: (hintObj == null ? void 0 : hintObj[lang2.code]) || "",
          onChange: (event) => setContentValue(lang2.code, event.target.value)
        }
      ) }, lang2.code);
    })
  ] });
}
const boxContainer$1 = "_boxContainer_182us_1";
const mt10$1 = "_mt10_182us_10";
const uppercase$1 = "_uppercase_182us_14";
const title$5 = "_title_182us_18";
const styles$k = {
  boxContainer: boxContainer$1,
  mt10: mt10$1,
  uppercase: uppercase$1,
  title: title$5
};
const boxContainer = "_boxContainer_1vhs4_1";
const mt10 = "_mt10_1vhs4_9";
const uppercase = "_uppercase_1vhs4_13";
const title$4 = "_title_1vhs4_18";
const titleContent = "_titleContent_1vhs4_28";
const standardError = "_standardError_1vhs4_33";
const errorWrapper = "_errorWrapper_1vhs4_44";
const errorLabelWrapper = "_errorLabelWrapper_1vhs4_48";
const errorItem = "_errorItem_1vhs4_52";
const errorItemContainer = "_errorItemContainer_1vhs4_58";
const styles$j = {
  boxContainer,
  mt10,
  uppercase,
  title: title$4,
  titleContent,
  standardError,
  errorWrapper,
  errorLabelWrapper,
  errorItem,
  errorItemContainer
};
function ValidationSetupMessage({ validationRule, code, rule: rule3, t: t2 }) {
  const dispatch = useDispatch();
  const isCustomErrorActive = validationRule.isCustomErrorActive || false;
  const languagesList = useSelector((state) => {
    return state.designState.langInfo.languagesList;
  });
  let content = validationRule.content || {};
  const checkedCustomError = (checked) => {
    dispatch(
      changeValidationValue({
        code,
        rule: rule3,
        key: "isCustomErrorActive",
        value: checked
      })
    );
  };
  const onContentUpdate = (key, value) => {
    const newContent = { ...content, [key]: value };
    dispatch(
      changeValidationValue({
        code,
        rule: rule3,
        key: "content",
        value: newContent
      })
    );
  };
  const label2 = { inputProps: { "aria-label": "Switch validation" } };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: t2("standard_error") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$j.errorWrapper, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$j.errorLabelWrapper, children: languagesList.map((l2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `${styles$j.errorItem} ${styles$j.uppercase}`,
          children: [
            l2.code,
            ":"
          ]
        },
        l2.code
      )) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: languagesList.map((l2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$j.errorItem, children: t2(rule3, { ns: "run", lng: l2.code, ...validationRule }) }, l2.code)) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$j.title, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: styles$j.mt10, children: t2("custom_error") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Switch,
        {
          ...label2,
          checked: isCustomErrorActive,
          onChange: (event) => checkedCustomError(event.target.checked)
        }
      )
    ] }),
    isCustomErrorActive ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$j.errorWrapper, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$j.errorLabelWrapper, children: languagesList.map((l2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `${styles$j.errorItem} ${styles$j.uppercase}`,
          children: [
            l2.code,
            ":"
          ]
        },
        l2.code
      )) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$j.errorItemContainer, children: languagesList.map((l2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$j.errorItem, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextField,
        {
          size: "small",
          variant: "standard",
          value: content[l2.code] || "",
          onChange: (event) => onContentUpdate(l2.code, event.target.value)
        }
      ) }, l2.code)) })
    ] }) : ""
  ] });
}
const valueValidationItems = "_valueValidationItems_1hupk_1";
const valueValidationItemsContainer = "_valueValidationItemsContainer_1hupk_6";
const error = "_error_1hupk_11";
const styles$i = {
  valueValidationItems,
  valueValidationItemsContainer,
  error
};
function ValidationSetupValue({ code, validation, rule: rule3, t: t2 }) {
  const bounds = useSelector((state) => {
    var _a, _b, _c;
    switch (rule3) {
      case "validation_min_char_length":
        return [1, Number.MAX_VALUE];
      case "validation_max_char_length":
        return [1, Number.MAX_VALUE];
      case "validation_max_word_count":
        return [1, Number.MAX_VALUE];
      case "validation_min_word_count":
        return [1, Number.MAX_VALUE];
      case "validation_min_ranking_count":
      case "validation_min_option_count":
        return [1, ((_a = state.designState[code].children) == null ? void 0 : _a.length) || 0];
      case "validation_max_ranking_count":
      case "validation_max_option_count":
        return [1, ((_b = state.designState[code].children) == null ? void 0 : _b.length) || 0];
      case "validation_ranking_count":
      case "validation_option_count":
        return [1, ((_c = state.designState[code].children) == null ? void 0 : _c.length) || 0];
      default:
        return void 0;
    }
  });
  const dispatch = useDispatch();
  const onChange = (key, value) => {
    dispatch(changeValidationValue({ rule: rule3, code, key, value }));
  };
  const onValuesUpdate = (key, value) => {
    onChange(
      key,
      typeof bounds === "undefined" ? value : Math.max(bounds[0], Math.min(bounds[1], value))
    );
  };
  let keys2 = validationAttributes(validation);
  const hasSubtitle = rule3 != "validation_required" && rule3 != "validation_pattern_email";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$i.valueValidationItemsContainer, children: [
    keys2 && hasSubtitle && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: t2(rule3 + "_subtitle") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$i.valueValidationItems, children: keys2.map((i2) => {
      const isInError = typeof bounds !== "undefined" && (validation[i2] < bounds[0] || validation[i2] > bounds[1]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextField,
        {
          error: isInError,
          value: validation[i2],
          variant: "outlined",
          size: "small",
          type: typeof validation[i2] === "number" ? "number" : "text",
          onChange: (event) => onValuesUpdate(
            i2,
            typeof validation[i2] === "number" ? parseInt(event.target.value) : event.target.value
          ),
          style: { maxWidth: "150px", marginLeft: "8px" }
        },
        i2
      );
    }) })
  ] });
}
const validationAttributes = (validation) => {
  return Object.keys(validation).filter(
    (el) => !["content", "isActive", "isCustomErrorActive", "bounds"].includes(el)
  );
};
function ValidationSetupItem({ rule: rule3, t: t2, code }) {
  console.log("ValidationSetupItem: " + code);
  const dispatch = useDispatch();
  const validationRule = useSelector((state) => {
    var _a, _b;
    return (_b = (_a = state.designState[code]) == null ? void 0 : _a.validation) == null ? void 0 : _b[rule3];
  });
  const label2 = { inputProps: { "aria-label": "Switch validation" } };
  const isActive = (validationRule == null ? void 0 : validationRule.isActive) || false;
  const checkedValidationItem = (checked) => {
    dispatch(
      changeValidationValue({
        code,
        rule: rule3,
        key: "isActive",
        value: checked
      })
    );
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$k.title, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: t2(rule3 + "_title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Switch,
        {
          ...label2,
          checked: isActive,
          onChange: (event) => checkedValidationItem(event.target.checked)
        }
      )
    ] }),
    isActive && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: styles$k.boxContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ValidationSetupValue,
        {
          code,
          validation: validationRule,
          rule: rule3,
          t: t2
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ValidationSetupMessage,
        {
          code,
          validationRule,
          rule: rule3,
          t: t2
        }
      )
    ] })
  ] });
}
const ValidationSetupItem$1 = React.memo(ValidationSetupItem);
const toggleValue = "_toggleValue_1d9zg_1";
const inputValue = "_inputValue_1d9zg_8";
const styles$h = {
  toggleValue,
  inputValue
};
function ToggleValue({ label: label2, code, rule: rule3 }) {
  const dispatch = useDispatch();
  const value = useSelector((state) => {
    return state.designState[code][rule3] || false;
  });
  const onChange = (value2) => {
    dispatch(changeAttribute({ code, key: rule3, value: value2 }));
  };
  const swithLabel = { inputProps: { "aria-label": "Switch demo" } };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$h.toggleValue, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: label2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Switch,
      {
        ...swithLabel,
        checked: value,
        onChange: (event) => {
          onChange(event.target.checked);
        }
      }
    )
  ] });
}
const selectValue$1 = "_selectValue_9m4tq_1";
const styles$g = {
  selectValue: selectValue$1
};
function SelectValue({ label: label2, rule: rule3, defaultValue: defaultValue4, code, values, labels }) {
  const dispatch = useDispatch();
  const value = useSelector((state) => {
    return state.designState[code][rule3] || defaultValue4;
  });
  const onChange = (value2) => {
    dispatch(changeAttribute({ code, key: rule3, value: value2 }));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$g.selectDate, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: label2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { variant: "standard", fullWidth: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Select,
      {
        id: "select-value",
        value,
        label: "Select Value",
        onChange: (e2) => {
          onChange(e2.target.value);
        },
        children: values.map((element, index2) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: element, children: labels ? labels[index2] : element }, element);
        })
      }
    ) })
  ] });
}
const selectDate = "_selectDate_1qp3e_1";
const selectDateField = "_selectDateField_1qp3e_8";
const styles$f = {
  selectDate,
  selectDateField
};
function SelectDate({ label: label2, rule: rule3, code }) {
  const dispatch = useDispatch();
  const value = useSelector((state) => {
    return state.designState[code][rule3] || "";
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$f.selectDate, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: label2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextField,
      {
        className: styles$f.selectDateField,
        variant: "standard",
        value,
        type: "date",
        onChange: (event) => {
          dispatch(
            changeAttribute({ code, key: rule3, value: event.target.value })
          );
        }
      }
    )
  ] });
}
const theming = "_theming_5qk2m_1";
const styles$e = {
  theming
};
const color = "_color_1xjz4_1";
const swatch = "_swatch_1xjz4_6";
const popover = "_popover_1xjz4_13";
const cover = "_cover_1xjz4_17";
const styles$d = {
  color,
  swatch,
  popover,
  cover
};
var lib = {};
var flattenNames$1 = {};
var baseGetTag$3 = _baseGetTag, isArray$c = isArray_1, isObjectLike$6 = isObjectLike_1;
var stringTag$4 = "[object String]";
function isString$1(value) {
  return typeof value == "string" || !isArray$c(value) && isObjectLike$6(value) && baseGetTag$3(value) == stringTag$4;
}
var isString_1 = isString$1;
function createBaseFor$2(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var _createBaseFor = createBaseFor$2;
var createBaseFor$1 = _createBaseFor;
var baseFor$4 = createBaseFor$1();
var _baseFor = baseFor$4;
var baseFor$3 = _baseFor, keys$5 = keys_1;
function baseForOwn$4(object, iteratee) {
  return object && baseFor$3(object, iteratee, keys$5);
}
var _baseForOwn = baseForOwn$4;
function identity$5(value) {
  return value;
}
var identity_1 = identity$5;
var identity$4 = identity_1;
function castFunction$2(value) {
  return typeof value == "function" ? value : identity$4;
}
var _castFunction = castFunction$2;
var baseForOwn$3 = _baseForOwn, castFunction$1 = _castFunction;
function forOwn(object, iteratee) {
  return object && baseForOwn$3(object, castFunction$1(iteratee));
}
var forOwn_1 = forOwn;
var overArg$1 = _overArg;
var getPrototype$5 = overArg$1(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$5;
var baseGetTag$2 = _baseGetTag, getPrototype$4 = _getPrototype, isObjectLike$5 = isObjectLike_1;
var objectTag$5 = "[object Object]";
var funcProto$3 = Function.prototype, objectProto$i = Object.prototype;
var funcToString$3 = funcProto$3.toString;
var hasOwnProperty$f = objectProto$i.hasOwnProperty;
var objectCtorString$1 = funcToString$3.call(Object);
function isPlainObject$3(value) {
  if (!isObjectLike$5(value) || baseGetTag$2(value) != objectTag$5) {
    return false;
  }
  var proto2 = getPrototype$4(value);
  if (proto2 === null) {
    return true;
  }
  var Ctor = hasOwnProperty$f.call(proto2, "constructor") && proto2.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString$3.call(Ctor) == objectCtorString$1;
}
var isPlainObject_1 = isPlainObject$3;
function arrayMap$5(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var _arrayMap = arrayMap$5;
var Stack$3 = _Stack, baseIsEqual$2 = _baseIsEqual;
var COMPARE_PARTIAL_FLAG$7 = 1, COMPARE_UNORDERED_FLAG$5 = 2;
function baseIsMatch$2(object, source, matchData, customizer) {
  var index2 = matchData.length, length = index2, noCustomizer = !customizer;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index2--) {
    var data = matchData[index2];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index2 < length) {
    data = matchData[index2];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack$3();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual$2(srcValue, objValue, COMPARE_PARTIAL_FLAG$7 | COMPARE_UNORDERED_FLAG$5, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var _baseIsMatch = baseIsMatch$2;
var isObject$e = isObject_1;
function isStrictComparable$3(value) {
  return value === value && !isObject$e(value);
}
var _isStrictComparable = isStrictComparable$3;
var isStrictComparable$2 = _isStrictComparable, keys$4 = keys_1;
function getMatchData$2(object) {
  var result = keys$4(object), length = result.length;
  while (length--) {
    var key = result[length], value = object[key];
    result[length] = [key, value, isStrictComparable$2(value)];
  }
  return result;
}
var _getMatchData = getMatchData$2;
function matchesStrictComparable$3(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var _matchesStrictComparable = matchesStrictComparable$3;
var baseIsMatch$1 = _baseIsMatch, getMatchData$1 = _getMatchData, matchesStrictComparable$2 = _matchesStrictComparable;
function baseMatches$2(source) {
  var matchData = getMatchData$1(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable$2(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch$1(object, source, matchData);
  };
}
var _baseMatches = baseMatches$2;
var baseGetTag$1 = _baseGetTag, isObjectLike$4 = isObjectLike_1;
var symbolTag$4 = "[object Symbol]";
function isSymbol$5(value) {
  return typeof value == "symbol" || isObjectLike$4(value) && baseGetTag$1(value) == symbolTag$4;
}
var isSymbol_1 = isSymbol$5;
var isArray$b = isArray_1, isSymbol$4 = isSymbol_1;
var reIsDeepProp$1 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp$1 = /^\w*$/;
function isKey$4(value, object) {
  if (isArray$b(value)) {
    return false;
  }
  var type2 = typeof value;
  if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol$4(value)) {
    return true;
  }
  return reIsPlainProp$1.test(value) || !reIsDeepProp$1.test(value) || object != null && value in Object(object);
}
var _isKey = isKey$4;
var MapCache$1 = _MapCache;
var FUNC_ERROR_TEXT$4 = "Expected a function";
function memoize$2(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$4);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$2.Cache || MapCache$1)();
  return memoized;
}
memoize$2.Cache = MapCache$1;
var memoize_1 = memoize$2;
var memoize$1 = memoize_1;
var MAX_MEMOIZE_SIZE$1 = 500;
function memoizeCapped$2(func) {
  var result = memoize$1(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE$1) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$2;
var memoizeCapped$1 = _memoizeCapped;
var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar$1 = /\\(\\)?/g;
var stringToPath$3 = memoizeCapped$1(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName$1, function(match5, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar$1, "$1") : number || match5);
  });
  return result;
});
var _stringToPath = stringToPath$3;
var Symbol$5 = _Symbol, arrayMap$4 = _arrayMap, isArray$a = isArray_1, isSymbol$3 = isSymbol_1;
var INFINITY$4 = 1 / 0;
var symbolProto$3 = Symbol$5 ? Symbol$5.prototype : void 0, symbolToString$1 = symbolProto$3 ? symbolProto$3.toString : void 0;
function baseToString$3(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$a(value)) {
    return arrayMap$4(value, baseToString$3) + "";
  }
  if (isSymbol$3(value)) {
    return symbolToString$1 ? symbolToString$1.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$4 ? "-0" : result;
}
var _baseToString = baseToString$3;
var baseToString$2 = _baseToString;
function toString$4(value) {
  return value == null ? "" : baseToString$2(value);
}
var toString_1 = toString$4;
var isArray$9 = isArray_1, isKey$3 = _isKey, stringToPath$2 = _stringToPath, toString$3 = toString_1;
function castPath$7(value, object) {
  if (isArray$9(value)) {
    return value;
  }
  return isKey$3(value, object) ? [value] : stringToPath$2(toString$3(value));
}
var _castPath = castPath$7;
var isSymbol$2 = isSymbol_1;
var INFINITY$3 = 1 / 0;
function toKey$7(value) {
  if (typeof value == "string" || isSymbol$2(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$3 ? "-0" : result;
}
var _toKey = toKey$7;
var castPath$6 = _castPath, toKey$6 = _toKey;
function baseGet$5(object, path) {
  path = castPath$6(path, object);
  var index2 = 0, length = path.length;
  while (object != null && index2 < length) {
    object = object[toKey$6(path[index2++])];
  }
  return index2 && index2 == length ? object : void 0;
}
var _baseGet = baseGet$5;
var baseGet$4 = _baseGet;
function get$6(object, path, defaultValue4) {
  var result = object == null ? void 0 : baseGet$4(object, path);
  return result === void 0 ? defaultValue4 : result;
}
var get_1 = get$6;
function baseHasIn$2(object, key) {
  return object != null && key in Object(object);
}
var _baseHasIn = baseHasIn$2;
var castPath$5 = _castPath, isArguments$4 = isArguments_1, isArray$8 = isArray_1, isIndex$3 = _isIndex, isLength$1 = isLength_1, toKey$5 = _toKey;
function hasPath$2(object, path, hasFunc) {
  path = castPath$5(path, object);
  var index2 = -1, length = path.length, result = false;
  while (++index2 < length) {
    var key = toKey$5(path[index2]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index2 != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength$1(length) && isIndex$3(key, length) && (isArray$8(object) || isArguments$4(object));
}
var _hasPath = hasPath$2;
var baseHasIn$1 = _baseHasIn, hasPath$1 = _hasPath;
function hasIn$3(object, path) {
  return object != null && hasPath$1(object, path, baseHasIn$1);
}
var hasIn_1 = hasIn$3;
var baseIsEqual$1 = _baseIsEqual, get$5 = get_1, hasIn$2 = hasIn_1, isKey$2 = _isKey, isStrictComparable$1 = _isStrictComparable, matchesStrictComparable$1 = _matchesStrictComparable, toKey$4 = _toKey;
var COMPARE_PARTIAL_FLAG$6 = 1, COMPARE_UNORDERED_FLAG$4 = 2;
function baseMatchesProperty$2(path, srcValue) {
  if (isKey$2(path) && isStrictComparable$1(srcValue)) {
    return matchesStrictComparable$1(toKey$4(path), srcValue);
  }
  return function(object) {
    var objValue = get$5(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn$2(object, path) : baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG$6 | COMPARE_UNORDERED_FLAG$4);
  };
}
var _baseMatchesProperty = baseMatchesProperty$2;
function baseProperty$2(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var _baseProperty = baseProperty$2;
var baseGet$3 = _baseGet;
function basePropertyDeep$2(path) {
  return function(object) {
    return baseGet$3(object, path);
  };
}
var _basePropertyDeep = basePropertyDeep$2;
var baseProperty$1 = _baseProperty, basePropertyDeep$1 = _basePropertyDeep, isKey$1 = _isKey, toKey$3 = _toKey;
function property$2(path) {
  return isKey$1(path) ? baseProperty$1(toKey$3(path)) : basePropertyDeep$1(path);
}
var property_1 = property$2;
var baseMatches$1 = _baseMatches, baseMatchesProperty$1 = _baseMatchesProperty, identity$3 = identity_1, isArray$7 = isArray_1, property$1 = property_1;
function baseIteratee$4(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity$3;
  }
  if (typeof value == "object") {
    return isArray$7(value) ? baseMatchesProperty$1(value[0], value[1]) : baseMatches$1(value);
  }
  return property$1(value);
}
var _baseIteratee = baseIteratee$4;
var isArrayLike$5 = isArrayLike_1;
function createBaseEach$2(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike$5(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var _createBaseEach = createBaseEach$2;
var baseForOwn$2 = _baseForOwn, createBaseEach$1 = _createBaseEach;
var baseEach$3 = createBaseEach$1(baseForOwn$2);
var _baseEach = baseEach$3;
var baseEach$2 = _baseEach, isArrayLike$4 = isArrayLike_1;
function baseMap$2(collection, iteratee) {
  var index2 = -1, result = isArrayLike$4(collection) ? Array(collection.length) : [];
  baseEach$2(collection, function(value, key, collection2) {
    result[++index2] = iteratee(value, key, collection2);
  });
  return result;
}
var _baseMap = baseMap$2;
var arrayMap$3 = _arrayMap, baseIteratee$3 = _baseIteratee, baseMap$1 = _baseMap, isArray$6 = isArray_1;
function map$2(collection, iteratee) {
  var func = isArray$6(collection) ? arrayMap$3 : baseMap$1;
  return func(collection, baseIteratee$3(iteratee));
}
var map_1 = map$2;
Object.defineProperty(flattenNames$1, "__esModule", {
  value: true
});
flattenNames$1.flattenNames = void 0;
var _isString2 = isString_1;
var _isString3 = _interopRequireDefault$f(_isString2);
var _forOwn2$2 = forOwn_1;
var _forOwn3$2 = _interopRequireDefault$f(_forOwn2$2);
var _isPlainObject2 = isPlainObject_1;
var _isPlainObject3 = _interopRequireDefault$f(_isPlainObject2);
var _map2 = map_1;
var _map3 = _interopRequireDefault$f(_map2);
function _interopRequireDefault$f(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var flattenNames = flattenNames$1.flattenNames = function flattenNames2() {
  var things = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var names2 = [];
  (0, _map3.default)(things, function(thing) {
    if (Array.isArray(thing)) {
      flattenNames2(thing).map(function(name) {
        return names2.push(name);
      });
    } else if ((0, _isPlainObject3.default)(thing)) {
      (0, _forOwn3$2.default)(thing, function(value, key) {
        value === true && names2.push(key);
        names2.push(key + "-" + value);
      });
    } else if ((0, _isString3.default)(thing)) {
      names2.push(thing);
    }
  });
  return names2;
};
flattenNames$1.default = flattenNames;
var mergeClasses$1 = {};
function arrayEach$2(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (iteratee(array[index2], index2, array) === false) {
      break;
    }
  }
  return array;
}
var _arrayEach = arrayEach$2;
var getNative$1 = _getNative;
var defineProperty$4 = function() {
  try {
    var func = getNative$1(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
var _defineProperty$2 = defineProperty$4;
var defineProperty$3 = _defineProperty$2;
function baseAssignValue$5(object, key, value) {
  if (key == "__proto__" && defineProperty$3) {
    defineProperty$3(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var _baseAssignValue = baseAssignValue$5;
var baseAssignValue$4 = _baseAssignValue, eq$3 = eq_1;
var objectProto$h = Object.prototype;
var hasOwnProperty$e = objectProto$h.hasOwnProperty;
function assignValue$4(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$e.call(object, key) && eq$3(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue$4(object, key, value);
  }
}
var _assignValue = assignValue$4;
var assignValue$3 = _assignValue, baseAssignValue$3 = _baseAssignValue;
function copyObject$7(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue$3(object, key, newValue);
    } else {
      assignValue$3(object, key, newValue);
    }
  }
  return object;
}
var _copyObject = copyObject$7;
var copyObject$6 = _copyObject, keys$3 = keys_1;
function baseAssign$1(object, source) {
  return object && copyObject$6(source, keys$3(source), object);
}
var _baseAssign = baseAssign$1;
function nativeKeysIn$2(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn$2;
var isObject$d = isObject_1, isPrototype$2 = _isPrototype, nativeKeysIn$1 = _nativeKeysIn;
var objectProto$g = Object.prototype;
var hasOwnProperty$d = objectProto$g.hasOwnProperty;
function baseKeysIn$2(object) {
  if (!isObject$d(object)) {
    return nativeKeysIn$1(object);
  }
  var isProto = isPrototype$2(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$d.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn$2;
var arrayLikeKeys$1 = _arrayLikeKeys, baseKeysIn$1 = _baseKeysIn, isArrayLike$3 = isArrayLike_1;
function keysIn$6(object) {
  return isArrayLike$3(object) ? arrayLikeKeys$1(object, true) : baseKeysIn$1(object);
}
var keysIn_1 = keysIn$6;
var copyObject$5 = _copyObject, keysIn$5 = keysIn_1;
function baseAssignIn$1(object, source) {
  return object && copyObject$5(source, keysIn$5(source), object);
}
var _baseAssignIn = baseAssignIn$1;
var _cloneBuffer = { exports: {} };
_cloneBuffer.exports;
(function(module2, exports2) {
  var root2 = _root;
  var freeExports2 = exports2 && !exports2.nodeType && exports2;
  var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var Buffer2 = moduleExports2 ? root2.Buffer : void 0, allocUnsafe2 = Buffer2 ? Buffer2.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe2 ? allocUnsafe2(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  module2.exports = cloneBuffer2;
})(_cloneBuffer, _cloneBuffer.exports);
var _cloneBufferExports = _cloneBuffer.exports;
function copyArray$3(source, array) {
  var index2 = -1, length = source.length;
  array || (array = Array(length));
  while (++index2 < length) {
    array[index2] = source[index2];
  }
  return array;
}
var _copyArray = copyArray$3;
var copyObject$4 = _copyObject, getSymbols$3 = _getSymbols;
function copySymbols$1(source, object) {
  return copyObject$4(source, getSymbols$3(source), object);
}
var _copySymbols = copySymbols$1;
var arrayPush$2 = _arrayPush, getPrototype$3 = _getPrototype, getSymbols$2 = _getSymbols, stubArray$1 = stubArray_1;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbolsIn$2 = !nativeGetSymbols$1 ? stubArray$1 : function(object) {
  var result = [];
  while (object) {
    arrayPush$2(result, getSymbols$2(object));
    object = getPrototype$3(object);
  }
  return result;
};
var _getSymbolsIn = getSymbolsIn$2;
var copyObject$3 = _copyObject, getSymbolsIn$1 = _getSymbolsIn;
function copySymbolsIn$1(source, object) {
  return copyObject$3(source, getSymbolsIn$1(source), object);
}
var _copySymbolsIn = copySymbolsIn$1;
var baseGetAllKeys$1 = _baseGetAllKeys, getSymbolsIn = _getSymbolsIn, keysIn$4 = keysIn_1;
function getAllKeysIn$3(object) {
  return baseGetAllKeys$1(object, keysIn$4, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$3;
var objectProto$f = Object.prototype;
var hasOwnProperty$c = objectProto$f.hasOwnProperty;
function initCloneArray$1(array) {
  var length = array.length, result = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty$c.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var _initCloneArray = initCloneArray$1;
var Uint8Array$2 = _Uint8Array;
function cloneArrayBuffer$4(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
  return result;
}
var _cloneArrayBuffer = cloneArrayBuffer$4;
var cloneArrayBuffer$3 = _cloneArrayBuffer;
function cloneDataView$1(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$3(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView = cloneDataView$1;
var reFlags = /\w*$/;
function cloneRegExp$1(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var _cloneRegExp = cloneRegExp$1;
var Symbol$4 = _Symbol;
var symbolProto$2 = Symbol$4 ? Symbol$4.prototype : void 0, symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;
function cloneSymbol$1(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}
var _cloneSymbol = cloneSymbol$1;
var cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneTypedArray$3(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$2(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$3;
var cloneArrayBuffer$1 = _cloneArrayBuffer, cloneDataView = _cloneDataView, cloneRegExp = _cloneRegExp, cloneSymbol = _cloneSymbol, cloneTypedArray$2 = _cloneTypedArray;
var boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", symbolTag$3 = "[object Symbol]";
var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
function initCloneByTag$1(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$3:
      return cloneArrayBuffer$1(object);
    case boolTag$3:
    case dateTag$3:
      return new Ctor(+object);
    case dataViewTag$4:
      return cloneDataView(object, isDeep);
    case float32Tag$2:
    case float64Tag$2:
    case int8Tag$2:
    case int16Tag$2:
    case int32Tag$2:
    case uint8Tag$2:
    case uint8ClampedTag$2:
    case uint16Tag$2:
    case uint32Tag$2:
      return cloneTypedArray$2(object, isDeep);
    case mapTag$5:
      return new Ctor();
    case numberTag$3:
    case stringTag$3:
      return new Ctor(object);
    case regexpTag$3:
      return cloneRegExp(object);
    case setTag$5:
      return new Ctor();
    case symbolTag$3:
      return cloneSymbol(object);
  }
}
var _initCloneByTag = initCloneByTag$1;
var isObject$c = isObject_1;
var objectCreate$1 = Object.create;
var baseCreate$3 = function() {
  function object() {
  }
  return function(proto2) {
    if (!isObject$c(proto2)) {
      return {};
    }
    if (objectCreate$1) {
      return objectCreate$1(proto2);
    }
    object.prototype = proto2;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var _baseCreate = baseCreate$3;
var baseCreate$2 = _baseCreate, getPrototype$2 = _getPrototype, isPrototype$1 = _isPrototype;
function initCloneObject$3(object) {
  return typeof object.constructor == "function" && !isPrototype$1(object) ? baseCreate$2(getPrototype$2(object)) : {};
}
var _initCloneObject = initCloneObject$3;
var getTag$4 = _getTag, isObjectLike$3 = isObjectLike_1;
var mapTag$4 = "[object Map]";
function baseIsMap$1(value) {
  return isObjectLike$3(value) && getTag$4(value) == mapTag$4;
}
var _baseIsMap = baseIsMap$1;
var baseIsMap = _baseIsMap, baseUnary$2 = _baseUnary, nodeUtil$3 = _nodeUtilExports;
var nodeIsMap = nodeUtil$3 && nodeUtil$3.isMap;
var isMap$1 = nodeIsMap ? baseUnary$2(nodeIsMap) : baseIsMap;
var isMap_1 = isMap$1;
var getTag$3 = _getTag, isObjectLike$2 = isObjectLike_1;
var setTag$4 = "[object Set]";
function baseIsSet$1(value) {
  return isObjectLike$2(value) && getTag$3(value) == setTag$4;
}
var _baseIsSet = baseIsSet$1;
var baseIsSet = _baseIsSet, baseUnary$1 = _baseUnary, nodeUtil$2 = _nodeUtilExports;
var nodeIsSet = nodeUtil$2 && nodeUtil$2.isSet;
var isSet$1 = nodeIsSet ? baseUnary$1(nodeIsSet) : baseIsSet;
var isSet_1 = isSet$1;
var Stack$2 = _Stack, arrayEach$1 = _arrayEach, assignValue$2 = _assignValue, baseAssign = _baseAssign, baseAssignIn = _baseAssignIn, cloneBuffer$2 = _cloneBufferExports, copyArray$2 = _copyArray, copySymbols = _copySymbols, copySymbolsIn = _copySymbolsIn, getAllKeys$1 = _getAllKeys, getAllKeysIn$2 = _getAllKeysIn, getTag$2 = _getTag, initCloneArray = _initCloneArray, initCloneByTag = _initCloneByTag, initCloneObject$2 = _initCloneObject, isArray$5 = isArray_1, isBuffer$3 = isBufferExports, isMap = isMap_1, isObject$b = isObject_1, isSet = isSet_1, keys$2 = keys_1, keysIn$3 = keysIn_1;
var CLONE_DEEP_FLAG$2 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$2 = 4;
var argsTag$3 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$2 = "[object Error]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag$3] = cloneableTags[arrayTag$2] = cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$3] = cloneableTags[boolTag$2] = cloneableTags[dateTag$2] = cloneableTags[float32Tag$1] = cloneableTags[float64Tag$1] = cloneableTags[int8Tag$1] = cloneableTags[int16Tag$1] = cloneableTags[int32Tag$1] = cloneableTags[mapTag$3] = cloneableTags[numberTag$2] = cloneableTags[objectTag$4] = cloneableTags[regexpTag$2] = cloneableTags[setTag$3] = cloneableTags[stringTag$2] = cloneableTags[symbolTag$2] = cloneableTags[uint8Tag$1] = cloneableTags[uint8ClampedTag$1] = cloneableTags[uint16Tag$1] = cloneableTags[uint32Tag$1] = true;
cloneableTags[errorTag$2] = cloneableTags[funcTag$2] = cloneableTags[weakMapTag$2] = false;
function baseClone$2(value, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$2, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$b(value)) {
    return value;
  }
  var isArr = isArray$5(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray$2(value, result);
    }
  } else {
    var tag = getTag$2(value), isFunc = tag == funcTag$2 || tag == genTag$1;
    if (isBuffer$3(value)) {
      return cloneBuffer$2(value, isDeep);
    }
    if (tag == objectTag$4 || tag == argsTag$3 || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject$2(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack$2());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone$2(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone$2(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn$2 : getAllKeys$1 : isFlat ? keysIn$3 : keys$2;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach$1(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue$2(result, key2, baseClone$2(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var _baseClone = baseClone$2;
var baseClone$1 = _baseClone;
var CLONE_DEEP_FLAG$1 = 1, CLONE_SYMBOLS_FLAG$1 = 4;
function cloneDeep(value) {
  return baseClone$1(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
}
var cloneDeep_1 = cloneDeep;
Object.defineProperty(mergeClasses$1, "__esModule", {
  value: true
});
mergeClasses$1.mergeClasses = void 0;
var _forOwn2$1 = forOwn_1;
var _forOwn3$1 = _interopRequireDefault$e(_forOwn2$1);
var _cloneDeep2 = cloneDeep_1;
var _cloneDeep3 = _interopRequireDefault$e(_cloneDeep2);
var _extends$f = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
function _interopRequireDefault$e(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var mergeClasses = mergeClasses$1.mergeClasses = function mergeClasses2(classes) {
  var activeNames = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var styles2 = classes.default && (0, _cloneDeep3.default)(classes.default) || {};
  activeNames.map(function(name) {
    var toMerge = classes[name];
    if (toMerge) {
      (0, _forOwn3$1.default)(toMerge, function(value, key) {
        if (!styles2[key]) {
          styles2[key] = {};
        }
        styles2[key] = _extends$f({}, styles2[key], toMerge[key]);
      });
    }
    return name;
  });
  return styles2;
};
mergeClasses$1.default = mergeClasses;
var autoprefix$1 = {};
Object.defineProperty(autoprefix$1, "__esModule", {
  value: true
});
autoprefix$1.autoprefix = void 0;
var _forOwn2 = forOwn_1;
var _forOwn3 = _interopRequireDefault$d(_forOwn2);
var _extends$e = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
function _interopRequireDefault$d(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var transforms = {
  borderRadius: function borderRadius(value) {
    return {
      msBorderRadius: value,
      MozBorderRadius: value,
      OBorderRadius: value,
      WebkitBorderRadius: value,
      borderRadius: value
    };
  },
  boxShadow: function boxShadow(value) {
    return {
      msBoxShadow: value,
      MozBoxShadow: value,
      OBoxShadow: value,
      WebkitBoxShadow: value,
      boxShadow: value
    };
  },
  userSelect: function userSelect(value) {
    return {
      WebkitTouchCallout: value,
      KhtmlUserSelect: value,
      MozUserSelect: value,
      msUserSelect: value,
      WebkitUserSelect: value,
      userSelect: value
    };
  },
  flex: function flex(value) {
    return {
      WebkitBoxFlex: value,
      MozBoxFlex: value,
      WebkitFlex: value,
      msFlex: value,
      flex: value
    };
  },
  flexBasis: function flexBasis(value) {
    return {
      WebkitFlexBasis: value,
      flexBasis: value
    };
  },
  justifyContent: function justifyContent(value) {
    return {
      WebkitJustifyContent: value,
      justifyContent: value
    };
  },
  transition: function transition(value) {
    return {
      msTransition: value,
      MozTransition: value,
      OTransition: value,
      WebkitTransition: value,
      transition: value
    };
  },
  transform: function transform(value) {
    return {
      msTransform: value,
      MozTransform: value,
      OTransform: value,
      WebkitTransform: value,
      transform: value
    };
  },
  absolute: function absolute(value) {
    var direction = value && value.split(" ");
    return {
      position: "absolute",
      top: direction && direction[0],
      right: direction && direction[1],
      bottom: direction && direction[2],
      left: direction && direction[3]
    };
  },
  extend: function extend(name, otherElementStyles) {
    var otherStyle = otherElementStyles[name];
    if (otherStyle) {
      return otherStyle;
    }
    return {
      "extend": name
    };
  }
};
var autoprefix = autoprefix$1.autoprefix = function autoprefix2(elements2) {
  var prefixed = {};
  (0, _forOwn3.default)(elements2, function(styles2, element) {
    var expanded = {};
    (0, _forOwn3.default)(styles2, function(value, key) {
      var transform2 = transforms[key];
      if (transform2) {
        expanded = _extends$e({}, expanded, transform2(value));
      } else {
        expanded[key] = value;
      }
    });
    prefixed[element] = expanded;
  });
  return prefixed;
};
autoprefix$1.default = autoprefix;
var hover$1 = {};
Object.defineProperty(hover$1, "__esModule", {
  value: true
});
hover$1.hover = void 0;
var _extends$d = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _react$3 = reactExports;
var _react2$3 = _interopRequireDefault$c(_react$3);
function _interopRequireDefault$c(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _classCallCheck$9(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$9(self2, call2) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
}
function _inherits$9(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var hover = hover$1.hover = function hover2(Component) {
  var Span = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
  return function(_React$Component) {
    _inherits$9(Hover, _React$Component);
    function Hover() {
      var _ref;
      var _temp, _this, _ret;
      _classCallCheck$9(this, Hover);
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _ret = (_temp = (_this = _possibleConstructorReturn$9(this, (_ref = Hover.__proto__ || Object.getPrototypeOf(Hover)).call.apply(_ref, [this].concat(args))), _this), _this.state = { hover: false }, _this.handleMouseOver = function() {
        return _this.setState({ hover: true });
      }, _this.handleMouseOut = function() {
        return _this.setState({ hover: false });
      }, _this.render = function() {
        return _react2$3.default.createElement(
          Span,
          { onMouseOver: _this.handleMouseOver, onMouseOut: _this.handleMouseOut },
          _react2$3.default.createElement(Component, _extends$d({}, _this.props, _this.state))
        );
      }, _temp), _possibleConstructorReturn$9(_this, _ret);
    }
    return Hover;
  }(_react2$3.default.Component);
};
hover$1.default = hover;
var active$1 = {};
Object.defineProperty(active$1, "__esModule", {
  value: true
});
active$1.active = void 0;
var _extends$c = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _react$2 = reactExports;
var _react2$2 = _interopRequireDefault$b(_react$2);
function _interopRequireDefault$b(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _classCallCheck$8(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$8(self2, call2) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
}
function _inherits$8(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var active = active$1.active = function active2(Component) {
  var Span = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
  return function(_React$Component) {
    _inherits$8(Active, _React$Component);
    function Active() {
      var _ref;
      var _temp, _this, _ret;
      _classCallCheck$8(this, Active);
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _ret = (_temp = (_this = _possibleConstructorReturn$8(this, (_ref = Active.__proto__ || Object.getPrototypeOf(Active)).call.apply(_ref, [this].concat(args))), _this), _this.state = { active: false }, _this.handleMouseDown = function() {
        return _this.setState({ active: true });
      }, _this.handleMouseUp = function() {
        return _this.setState({ active: false });
      }, _this.render = function() {
        return _react2$2.default.createElement(
          Span,
          { onMouseDown: _this.handleMouseDown, onMouseUp: _this.handleMouseUp },
          _react2$2.default.createElement(Component, _extends$c({}, _this.props, _this.state))
        );
      }, _temp), _possibleConstructorReturn$8(_this, _ret);
    }
    return Active;
  }(_react2$2.default.Component);
};
active$1.default = active;
var loop = {};
Object.defineProperty(loop, "__esModule", {
  value: true
});
var loopable = function loopable2(i2, length) {
  var props = {};
  var setProp = function setProp2(name) {
    var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    props[name] = value;
  };
  i2 === 0 && setProp("first-child");
  i2 === length - 1 && setProp("last-child");
  (i2 === 0 || i2 % 2 === 0) && setProp("even");
  Math.abs(i2 % 2) === 1 && setProp("odd");
  setProp("nth-child", i2);
  return props;
};
loop.default = loopable;
Object.defineProperty(lib, "__esModule", {
  value: true
});
lib.ReactCSS = lib.loop = lib.handleActive = handleHover = lib.handleHover = lib.hover = void 0;
var _flattenNames = flattenNames$1;
var _flattenNames2 = _interopRequireDefault$a(_flattenNames);
var _mergeClasses = mergeClasses$1;
var _mergeClasses2 = _interopRequireDefault$a(_mergeClasses);
var _autoprefix = autoprefix$1;
var _autoprefix2 = _interopRequireDefault$a(_autoprefix);
var _hover2 = hover$1;
var _hover3 = _interopRequireDefault$a(_hover2);
var _active = active$1;
var _active2 = _interopRequireDefault$a(_active);
var _loop2 = loop;
var _loop3 = _interopRequireDefault$a(_loop2);
function _interopRequireDefault$a(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
lib.hover = _hover3.default;
var handleHover = lib.handleHover = _hover3.default;
lib.handleActive = _active2.default;
lib.loop = _loop3.default;
var ReactCSS = lib.ReactCSS = function ReactCSS2(classes) {
  for (var _len = arguments.length, activations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    activations[_key - 1] = arguments[_key];
  }
  var activeNames = (0, _flattenNames2.default)(activations);
  var merged = (0, _mergeClasses2.default)(classes, activeNames);
  return (0, _autoprefix2.default)(merged);
};
var _default$a = lib.default = ReactCSS;
var calculateChange$2 = function calculateChange(e2, hsl2, direction, initialA, container2) {
  var containerWidth = container2.clientWidth;
  var containerHeight = container2.clientHeight;
  var x = typeof e2.pageX === "number" ? e2.pageX : e2.touches[0].pageX;
  var y2 = typeof e2.pageY === "number" ? e2.pageY : e2.touches[0].pageY;
  var left = x - (container2.getBoundingClientRect().left + window.pageXOffset);
  var top = y2 - (container2.getBoundingClientRect().top + window.pageYOffset);
  if (direction === "vertical") {
    var a2 = void 0;
    if (top < 0) {
      a2 = 0;
    } else if (top > containerHeight) {
      a2 = 1;
    } else {
      a2 = Math.round(top * 100 / containerHeight) / 100;
    }
    if (hsl2.a !== a2) {
      return {
        h: hsl2.h,
        s: hsl2.s,
        l: hsl2.l,
        a: a2,
        source: "rgb"
      };
    }
  } else {
    var _a = void 0;
    if (left < 0) {
      _a = 0;
    } else if (left > containerWidth) {
      _a = 1;
    } else {
      _a = Math.round(left * 100 / containerWidth) / 100;
    }
    if (initialA !== _a) {
      return {
        h: hsl2.h,
        s: hsl2.s,
        l: hsl2.l,
        a: _a,
        source: "rgb"
      };
    }
  }
  return null;
};
var checkboardCache = {};
var render = function render2(c1, c2, size, serverCanvas) {
  if (typeof document === "undefined" && !serverCanvas) {
    return null;
  }
  var canvas = serverCanvas ? new serverCanvas() : document.createElement("canvas");
  canvas.width = size * 2;
  canvas.height = size * 2;
  var ctx = canvas.getContext("2d");
  if (!ctx) {
    return null;
  }
  ctx.fillStyle = c1;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = c2;
  ctx.fillRect(0, 0, size, size);
  ctx.translate(size, size);
  ctx.fillRect(0, 0, size, size);
  return canvas.toDataURL();
};
var get$4 = function get(c1, c2, size, serverCanvas) {
  var key = c1 + "-" + c2 + "-" + size + (serverCanvas ? "-server" : "");
  if (checkboardCache[key]) {
    return checkboardCache[key];
  }
  var checkboard = render(c1, c2, size, serverCanvas);
  checkboardCache[key] = checkboard;
  return checkboard;
};
var _extends$b = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var Checkboard = function Checkboard2(_ref) {
  var white = _ref.white, grey2 = _ref.grey, size = _ref.size, renderers = _ref.renderers, borderRadius2 = _ref.borderRadius, boxShadow2 = _ref.boxShadow, children = _ref.children;
  var styles2 = _default$a({
    "default": {
      grid: {
        borderRadius: borderRadius2,
        boxShadow: boxShadow2,
        absolute: "0px 0px 0px 0px",
        background: "url(" + get$4(white, grey2, size, renderers.canvas) + ") center left"
      }
    }
  });
  return reactExports.isValidElement(children) ? React.cloneElement(children, _extends$b({}, children.props, { style: _extends$b({}, children.props.style, styles2.grid) })) : React.createElement("div", { style: styles2.grid });
};
Checkboard.defaultProps = {
  size: 8,
  white: "transparent",
  grey: "rgba(0,0,0,.08)",
  renderers: {}
};
var _extends$a = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _createClass$7 = function() {
  function defineProperties(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$7(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$7(self2, call2) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
}
function _inherits$7(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var Alpha = function(_ref) {
  _inherits$7(Alpha2, _ref);
  function Alpha2() {
    var _ref2;
    var _temp, _this, _ret;
    _classCallCheck$7(this, Alpha2);
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return _ret = (_temp = (_this = _possibleConstructorReturn$7(this, (_ref2 = Alpha2.__proto__ || Object.getPrototypeOf(Alpha2)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function(e2) {
      var change = calculateChange$2(e2, _this.props.hsl, _this.props.direction, _this.props.a, _this.container);
      change && typeof _this.props.onChange === "function" && _this.props.onChange(change, e2);
    }, _this.handleMouseDown = function(e2) {
      _this.handleChange(e2);
      window.addEventListener("mousemove", _this.handleChange);
      window.addEventListener("mouseup", _this.handleMouseUp);
    }, _this.handleMouseUp = function() {
      _this.unbindEventListeners();
    }, _this.unbindEventListeners = function() {
      window.removeEventListener("mousemove", _this.handleChange);
      window.removeEventListener("mouseup", _this.handleMouseUp);
    }, _temp), _possibleConstructorReturn$7(_this, _ret);
  }
  _createClass$7(Alpha2, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: "render",
    value: function render3() {
      var _this2 = this;
      var rgb2 = this.props.rgb;
      var styles2 = _default$a({
        "default": {
          alpha: {
            absolute: "0px 0px 0px 0px",
            borderRadius: this.props.radius
          },
          checkboard: {
            absolute: "0px 0px 0px 0px",
            overflow: "hidden",
            borderRadius: this.props.radius
          },
          gradient: {
            absolute: "0px 0px 0px 0px",
            background: "linear-gradient(to right, rgba(" + rgb2.r + "," + rgb2.g + "," + rgb2.b + ", 0) 0%,\n           rgba(" + rgb2.r + "," + rgb2.g + "," + rgb2.b + ", 1) 100%)",
            boxShadow: this.props.shadow,
            borderRadius: this.props.radius
          },
          container: {
            position: "relative",
            height: "100%",
            margin: "0 3px"
          },
          pointer: {
            position: "absolute",
            left: rgb2.a * 100 + "%"
          },
          slider: {
            width: "4px",
            borderRadius: "1px",
            height: "8px",
            boxShadow: "0 0 2px rgba(0, 0, 0, .6)",
            background: "#fff",
            marginTop: "1px",
            transform: "translateX(-2px)"
          }
        },
        "vertical": {
          gradient: {
            background: "linear-gradient(to bottom, rgba(" + rgb2.r + "," + rgb2.g + "," + rgb2.b + ", 0) 0%,\n           rgba(" + rgb2.r + "," + rgb2.g + "," + rgb2.b + ", 1) 100%)"
          },
          pointer: {
            left: 0,
            top: rgb2.a * 100 + "%"
          }
        },
        "overwrite": _extends$a({}, this.props.style)
      }, {
        vertical: this.props.direction === "vertical",
        overwrite: true
      });
      return React.createElement(
        "div",
        { style: styles2.alpha },
        React.createElement(
          "div",
          { style: styles2.checkboard },
          React.createElement(Checkboard, { renderers: this.props.renderers })
        ),
        React.createElement("div", { style: styles2.gradient }),
        React.createElement(
          "div",
          {
            style: styles2.container,
            ref: function ref(container2) {
              return _this2.container = container2;
            },
            onMouseDown: this.handleMouseDown,
            onTouchMove: this.handleChange,
            onTouchStart: this.handleChange
          },
          React.createElement(
            "div",
            { style: styles2.pointer },
            this.props.pointer ? React.createElement(this.props.pointer, this.props) : React.createElement("div", { style: styles2.slider })
          )
        )
      );
    }
  }]);
  return Alpha2;
}(reactExports.PureComponent || reactExports.Component);
var _createClass$6 = function() {
  function defineProperties(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck$6(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$6(self2, call2) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
}
function _inherits$6(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var DEFAULT_ARROW_OFFSET = 1;
var UP_KEY_CODE = 38;
var DOWN_KEY_CODE = 40;
var VALID_KEY_CODES = [UP_KEY_CODE, DOWN_KEY_CODE];
var isValidKeyCode = function isValidKeyCode2(keyCode) {
  return VALID_KEY_CODES.indexOf(keyCode) > -1;
};
var getNumberValue = function getNumberValue2(value) {
  return Number(String(value).replace(/%/g, ""));
};
var idCounter = 1;
var EditableInput = function(_ref) {
  _inherits$6(EditableInput2, _ref);
  function EditableInput2(props) {
    _classCallCheck$6(this, EditableInput2);
    var _this = _possibleConstructorReturn$6(this, (EditableInput2.__proto__ || Object.getPrototypeOf(EditableInput2)).call(this));
    _this.handleBlur = function() {
      if (_this.state.blurValue) {
        _this.setState({ value: _this.state.blurValue, blurValue: null });
      }
    };
    _this.handleChange = function(e2) {
      _this.setUpdatedValue(e2.target.value, e2);
    };
    _this.handleKeyDown = function(e2) {
      var value = getNumberValue(e2.target.value);
      if (!isNaN(value) && isValidKeyCode(e2.keyCode)) {
        var offset2 = _this.getArrowOffset();
        var updatedValue = e2.keyCode === UP_KEY_CODE ? value + offset2 : value - offset2;
        _this.setUpdatedValue(updatedValue, e2);
      }
    };
    _this.handleDrag = function(e2) {
      if (_this.props.dragLabel) {
        var newValue = Math.round(_this.props.value + e2.movementX);
        if (newValue >= 0 && newValue <= _this.props.dragMax) {
          _this.props.onChange && _this.props.onChange(_this.getValueObjectWithLabel(newValue), e2);
        }
      }
    };
    _this.handleMouseDown = function(e2) {
      if (_this.props.dragLabel) {
        e2.preventDefault();
        _this.handleDrag(e2);
        window.addEventListener("mousemove", _this.handleDrag);
        window.addEventListener("mouseup", _this.handleMouseUp);
      }
    };
    _this.handleMouseUp = function() {
      _this.unbindEventListeners();
    };
    _this.unbindEventListeners = function() {
      window.removeEventListener("mousemove", _this.handleDrag);
      window.removeEventListener("mouseup", _this.handleMouseUp);
    };
    _this.state = {
      value: String(props.value).toUpperCase(),
      blurValue: String(props.value).toUpperCase()
    };
    _this.inputId = "rc-editable-input-" + idCounter++;
    return _this;
  }
  _createClass$6(EditableInput2, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      if (this.props.value !== this.state.value && (prevProps.value !== this.props.value || prevState.value !== this.state.value)) {
        if (this.input === document.activeElement) {
          this.setState({ blurValue: String(this.props.value).toUpperCase() });
        } else {
          this.setState({ value: String(this.props.value).toUpperCase(), blurValue: !this.state.blurValue && String(this.props.value).toUpperCase() });
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: "getValueObjectWithLabel",
    value: function getValueObjectWithLabel(value) {
      return _defineProperty$1({}, this.props.label, value);
    }
  }, {
    key: "getArrowOffset",
    value: function getArrowOffset() {
      return this.props.arrowOffset || DEFAULT_ARROW_OFFSET;
    }
  }, {
    key: "setUpdatedValue",
    value: function setUpdatedValue(value, e2) {
      var onChangeValue = this.props.label ? this.getValueObjectWithLabel(value) : value;
      this.props.onChange && this.props.onChange(onChangeValue, e2);
      this.setState({ value });
    }
  }, {
    key: "render",
    value: function render3() {
      var _this2 = this;
      var styles2 = _default$a({
        "default": {
          wrap: {
            position: "relative"
          }
        },
        "user-override": {
          wrap: this.props.style && this.props.style.wrap ? this.props.style.wrap : {},
          input: this.props.style && this.props.style.input ? this.props.style.input : {},
          label: this.props.style && this.props.style.label ? this.props.style.label : {}
        },
        "dragLabel-true": {
          label: {
            cursor: "ew-resize"
          }
        }
      }, {
        "user-override": true
      }, this.props);
      return React.createElement(
        "div",
        { style: styles2.wrap },
        React.createElement("input", {
          id: this.inputId,
          style: styles2.input,
          ref: function ref(input2) {
            return _this2.input = input2;
          },
          value: this.state.value,
          onKeyDown: this.handleKeyDown,
          onChange: this.handleChange,
          onBlur: this.handleBlur,
          placeholder: this.props.placeholder,
          spellCheck: "false"
        }),
        this.props.label && !this.props.hideLabel ? React.createElement(
          "label",
          {
            htmlFor: this.inputId,
            style: styles2.label,
            onMouseDown: this.handleMouseDown
          },
          this.props.label
        ) : null
      );
    }
  }]);
  return EditableInput2;
}(reactExports.PureComponent || reactExports.Component);
var calculateChange$1 = function calculateChange2(e2, direction, hsl2, container2) {
  var containerWidth = container2.clientWidth;
  var containerHeight = container2.clientHeight;
  var x = typeof e2.pageX === "number" ? e2.pageX : e2.touches[0].pageX;
  var y2 = typeof e2.pageY === "number" ? e2.pageY : e2.touches[0].pageY;
  var left = x - (container2.getBoundingClientRect().left + window.pageXOffset);
  var top = y2 - (container2.getBoundingClientRect().top + window.pageYOffset);
  if (direction === "vertical") {
    var h2 = void 0;
    if (top < 0) {
      h2 = 359;
    } else if (top > containerHeight) {
      h2 = 0;
    } else {
      var percent = -(top * 100 / containerHeight) + 100;
      h2 = 360 * percent / 100;
    }
    if (hsl2.h !== h2) {
      return {
        h: h2,
        s: hsl2.s,
        l: hsl2.l,
        a: hsl2.a,
        source: "hsl"
      };
    }
  } else {
    var _h = void 0;
    if (left < 0) {
      _h = 0;
    } else if (left > containerWidth) {
      _h = 359;
    } else {
      var _percent = left * 100 / containerWidth;
      _h = 360 * _percent / 100;
    }
    if (hsl2.h !== _h) {
      return {
        h: _h,
        s: hsl2.s,
        l: hsl2.l,
        a: hsl2.a,
        source: "hsl"
      };
    }
  }
  return null;
};
var _createClass$5 = function() {
  function defineProperties(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$5(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$5(self2, call2) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
}
function _inherits$5(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var Hue = function(_ref) {
  _inherits$5(Hue2, _ref);
  function Hue2() {
    var _ref2;
    var _temp, _this, _ret;
    _classCallCheck$5(this, Hue2);
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return _ret = (_temp = (_this = _possibleConstructorReturn$5(this, (_ref2 = Hue2.__proto__ || Object.getPrototypeOf(Hue2)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function(e2) {
      var change = calculateChange$1(e2, _this.props.direction, _this.props.hsl, _this.container);
      change && typeof _this.props.onChange === "function" && _this.props.onChange(change, e2);
    }, _this.handleMouseDown = function(e2) {
      _this.handleChange(e2);
      window.addEventListener("mousemove", _this.handleChange);
      window.addEventListener("mouseup", _this.handleMouseUp);
    }, _this.handleMouseUp = function() {
      _this.unbindEventListeners();
    }, _temp), _possibleConstructorReturn$5(_this, _ret);
  }
  _createClass$5(Hue2, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: "unbindEventListeners",
    value: function unbindEventListeners() {
      window.removeEventListener("mousemove", this.handleChange);
      window.removeEventListener("mouseup", this.handleMouseUp);
    }
  }, {
    key: "render",
    value: function render3() {
      var _this2 = this;
      var _props$direction = this.props.direction, direction = _props$direction === void 0 ? "horizontal" : _props$direction;
      var styles2 = _default$a({
        "default": {
          hue: {
            absolute: "0px 0px 0px 0px",
            borderRadius: this.props.radius,
            boxShadow: this.props.shadow
          },
          container: {
            padding: "0 2px",
            position: "relative",
            height: "100%",
            borderRadius: this.props.radius
          },
          pointer: {
            position: "absolute",
            left: this.props.hsl.h * 100 / 360 + "%"
          },
          slider: {
            marginTop: "1px",
            width: "4px",
            borderRadius: "1px",
            height: "8px",
            boxShadow: "0 0 2px rgba(0, 0, 0, .6)",
            background: "#fff",
            transform: "translateX(-2px)"
          }
        },
        "vertical": {
          pointer: {
            left: "0px",
            top: -(this.props.hsl.h * 100 / 360) + 100 + "%"
          }
        }
      }, { vertical: direction === "vertical" });
      return React.createElement(
        "div",
        { style: styles2.hue },
        React.createElement(
          "div",
          {
            className: "hue-" + direction,
            style: styles2.container,
            ref: function ref(container2) {
              return _this2.container = container2;
            },
            onMouseDown: this.handleMouseDown,
            onTouchMove: this.handleChange,
            onTouchStart: this.handleChange
          },
          React.createElement(
            "style",
            null,
            "\n            .hue-horizontal {\n              background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0\n                33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n              background: -webkit-linear-gradient(to right, #f00 0%, #ff0\n                17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n            }\n\n            .hue-vertical {\n              background: linear-gradient(to top, #f00 0%, #ff0 17%, #0f0 33%,\n                #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n              background: -webkit-linear-gradient(to top, #f00 0%, #ff0 17%,\n                #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n            }\n          "
          ),
          React.createElement(
            "div",
            { style: styles2.pointer },
            this.props.pointer ? React.createElement(this.props.pointer, this.props) : React.createElement("div", { style: styles2.slider })
          )
        )
      );
    }
  }]);
  return Hue2;
}(reactExports.PureComponent || reactExports.Component);
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function eq$2(value, other) {
  return value === other || value !== value && other !== other;
}
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$2(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
function ListCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
const freeGlobal$1 = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$1 = freeGlobal$1 || freeSelf || Function("return this")();
const root$2 = root$1;
var Symbol$2 = root$2.Symbol;
const Symbol$3 = Symbol$2;
var objectProto$e = Object.prototype;
var hasOwnProperty$b = objectProto$e.hasOwnProperty;
var nativeObjectToString$1 = objectProto$e.toString;
var symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$d = Object.prototype;
var nativeObjectToString = objectProto$d.toString;
function objectToString(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$3 ? Symbol$3.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
function isObject$a(value) {
  var type2 = typeof value;
  return value != null && (type2 == "object" || type2 == "function");
}
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$2(value) {
  if (!isObject$a(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root$2["__core-js_shared__"];
const coreJsData$1 = coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype, objectProto$c = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$a = objectProto$c.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject$a(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var Map$1 = getNative(root$2, "Map");
const Map$2 = Map$1;
var nativeCreate = getNative(Object, "create");
const nativeCreate$1 = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$b = Object.prototype;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$9.call(data, key) ? data[key] : void 0;
}
var objectProto$a = Object.prototype;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$8.call(data, key);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
function Hash(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type2 = typeof value;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map2, key) {
  var data = map2.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
function Stack$1(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack$1.prototype.clear = stackClear;
Stack$1.prototype["delete"] = stackDelete;
Stack$1.prototype.get = stackGet;
Stack$1.prototype.has = stackHas;
Stack$1.prototype.set = stackSet;
var defineProperty$1 = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
const defineProperty$2 = defineProperty$1;
function baseAssignValue$2(object, key, value) {
  if (key == "__proto__" && defineProperty$2) {
    defineProperty$2(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
function assignMergeValue$3(object, key, value) {
  if (value !== void 0 && !eq$2(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue$2(object, key, value);
  }
}
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var baseFor$1 = createBaseFor();
const baseFor$2 = baseFor$1;
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$2 = moduleExports$2 ? root$2.Buffer : void 0, allocUnsafe = Buffer$2 ? Buffer$2.allocUnsafe : void 0;
function cloneBuffer$1(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}
var Uint8Array = root$2.Uint8Array;
const Uint8Array$1 = Uint8Array;
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}
function cloneTypedArray$1(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
function copyArray$1(source, array) {
  var index2 = -1, length = source.length;
  array || (array = Array(length));
  while (++index2 < length) {
    array[index2] = source[index2];
  }
  return array;
}
var objectCreate = Object.create;
var baseCreate = function() {
  function object() {
  }
  return function(proto2) {
    if (!isObject$a(proto2)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto2);
    }
    object.prototype = proto2;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
const baseCreate$1 = baseCreate;
function overArg(func, transform2) {
  return function(arg) {
    return func(transform2(arg));
  };
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
const getPrototype$1 = getPrototype;
var objectProto$9 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$9;
  return value === proto2;
}
function initCloneObject$1(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate$1(getPrototype$1(object)) : {};
}
function isObjectLike$1(value) {
  return value != null && typeof value == "object";
}
var argsTag$2 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike$1(value) && baseGetTag(value) == argsTag$2;
}
var objectProto$8 = Object.prototype;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$8.propertyIsEnumerable;
var isArguments$2 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$1(value) && hasOwnProperty$7.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
const isArguments$3 = isArguments$2;
var isArray$3 = Array.isArray;
const isArray$4 = isArray$3;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}
function isArrayLike$2(value) {
  return value != null && isLength(value.length) && !isFunction$2(value);
}
function isArrayLikeObject$2(value) {
  return isObjectLike$1(value) && isArrayLike$2(value);
}
function stubFalse() {
  return false;
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var Buffer$1 = moduleExports$1 ? root$2.Buffer : void 0;
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
var isBuffer$1 = nativeIsBuffer || stubFalse;
const isBuffer$2 = isBuffer$1;
var objectTag$3 = "[object Object]";
var funcProto = Function.prototype, objectProto$7 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject$2(value) {
  if (!isObjectLike$1(value) || baseGetTag(value) != objectTag$3) {
    return false;
  }
  var proto2 = getPrototype$1(value);
  if (proto2 === null) {
    return true;
  }
  var Ctor = hasOwnProperty$6.call(proto2, "constructor") && proto2.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;
function baseIsTypedArray(value) {
  return isObjectLike$1(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var freeProcess = moduleExports && freeGlobal$1.process;
var nodeUtil = function() {
  try {
    var types2 = freeModule && freeModule.require && freeModule.require("util").types;
    if (types2) {
      return types2;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e2) {
  }
}();
const nodeUtil$1 = nodeUtil;
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
var isTypedArray$1 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
const isTypedArray$2 = isTypedArray$1;
function safeGet$3(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var objectProto$6 = Object.prototype;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
function assignValue$1(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$5.call(object, key) && eq$2(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue$2(object, key, value);
  }
}
function copyObject$2(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue$2(object, key, newValue);
    } else {
      assignValue$1(object, key, newValue);
    }
  }
  return object;
}
function baseTimes(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$2(value, length) {
  var type2 = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var objectProto$5 = Object.prototype;
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray$4(value), isArg = !isArr && isArguments$3(value), isBuff = !isArr && !isArg && isBuffer$2(value), isType = !isArr && !isArg && !isBuff && isTypedArray$2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex$2(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$4 = Object.prototype;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject$a(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$3.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
function keysIn$2(object) {
  return isArrayLike$2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
function toPlainObject$2(value) {
  return copyObject$2(value, keysIn$2(value));
}
function baseMergeDeep$2(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet$3(object, key), srcValue = safeGet$3(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue$3(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray$4(srcValue), isBuff = !isArr && isBuffer$2(srcValue), isTyped = !isArr && !isBuff && isTypedArray$2(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray$4(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject$2(objValue)) {
        newValue = copyArray$1(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer$1(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray$1(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject$2(srcValue) || isArguments$3(srcValue)) {
      newValue = objValue;
      if (isArguments$3(objValue)) {
        newValue = toPlainObject$2(objValue);
      } else if (!isObject$a(objValue) || isFunction$2(objValue)) {
        newValue = initCloneObject$1(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue$3(object, key, newValue);
}
function baseMerge$3(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor$2(source, function(srcValue, key) {
    stack || (stack = new Stack$1());
    if (isObject$a(srcValue)) {
      baseMergeDeep$2(object, source, key, srcIndex, baseMerge$3, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet$3(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue$3(object, key, newValue);
    }
  }, keysIn$2);
}
function identity$2(value) {
  return value;
}
function apply$2(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var nativeMax$4 = Math.max;
function overRest$3(func, start2, transform2) {
  start2 = nativeMax$4(start2 === void 0 ? func.length - 1 : start2, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax$4(args.length - start2, 0), array = Array(length);
    while (++index2 < length) {
      array[index2] = args[start2 + index2];
    }
    index2 = -1;
    var otherArgs = Array(start2 + 1);
    while (++index2 < start2) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start2] = transform2(array);
    return apply$2(func, this, otherArgs);
  };
}
function constant$2(value) {
  return function() {
    return value;
  };
}
var baseSetToString$2 = !defineProperty$2 ? identity$2 : function(func, string) {
  return defineProperty$2(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant$2(string),
    "writable": true
  });
};
const baseSetToString$3 = baseSetToString$2;
var HOT_COUNT$1 = 800, HOT_SPAN$1 = 16;
var nativeNow$1 = Date.now;
function shortOut$2(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow$1(), remaining = HOT_SPAN$1 - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT$1) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var setToString$3 = shortOut$2(baseSetToString$3);
const setToString$4 = setToString$3;
function baseRest$2(func, start2) {
  return setToString$4(overRest$3(func, start2, identity$2), func + "");
}
function isIterateeCall$3(value, index2, object) {
  if (!isObject$a(object)) {
    return false;
  }
  var type2 = typeof index2;
  if (type2 == "number" ? isArrayLike$2(object) && isIndex$2(index2, object.length) : type2 == "string" && index2 in object) {
    return eq$2(object[index2], value);
  }
  return false;
}
function createAssigner$3(assigner) {
  return baseRest$2(function(object, sources) {
    var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall$3(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index2 < length) {
      var source = sources[index2];
      if (source) {
        assigner(object, source, index2, customizer);
      }
    }
    return object;
  });
}
var merge$3 = createAssigner$3(function(object, source, srcIndex) {
  baseMerge$3(object, source, srcIndex);
});
const merge$4 = merge$3;
var Raised = function Raised2(_ref) {
  var zDepth = _ref.zDepth, radius = _ref.radius, background = _ref.background, children = _ref.children, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles;
  var styles2 = _default$a(merge$4({
    "default": {
      wrap: {
        position: "relative",
        display: "inline-block"
      },
      content: {
        position: "relative"
      },
      bg: {
        absolute: "0px 0px 0px 0px",
        boxShadow: "0 " + zDepth + "px " + zDepth * 4 + "px rgba(0,0,0,.24)",
        borderRadius: radius,
        background
      }
    },
    "zDepth-0": {
      bg: {
        boxShadow: "none"
      }
    },
    "zDepth-1": {
      bg: {
        boxShadow: "0 2px 10px rgba(0,0,0,.12), 0 2px 5px rgba(0,0,0,.16)"
      }
    },
    "zDepth-2": {
      bg: {
        boxShadow: "0 6px 20px rgba(0,0,0,.19), 0 8px 17px rgba(0,0,0,.2)"
      }
    },
    "zDepth-3": {
      bg: {
        boxShadow: "0 17px 50px rgba(0,0,0,.19), 0 12px 15px rgba(0,0,0,.24)"
      }
    },
    "zDepth-4": {
      bg: {
        boxShadow: "0 25px 55px rgba(0,0,0,.21), 0 16px 28px rgba(0,0,0,.22)"
      }
    },
    "zDepth-5": {
      bg: {
        boxShadow: "0 40px 77px rgba(0,0,0,.22), 0 27px 24px rgba(0,0,0,.2)"
      }
    },
    "square": {
      bg: {
        borderRadius: "0"
      }
    },
    "circle": {
      bg: {
        borderRadius: "50%"
      }
    }
  }, passedStyles), { "zDepth-1": zDepth === 1 });
  return React.createElement(
    "div",
    { style: styles2.wrap },
    React.createElement("div", { style: styles2.bg }),
    React.createElement(
      "div",
      { style: styles2.content },
      children
    )
  );
};
Raised.propTypes = {
  background: PropTypes.string,
  zDepth: PropTypes.oneOf([0, 1, 2, 3, 4, 5]),
  radius: PropTypes.number,
  styles: PropTypes.object
};
Raised.defaultProps = {
  background: "#fff",
  zDepth: 1,
  radius: 2,
  styles: {}
};
var now$3 = function() {
  return root$2.Date.now();
};
const now$4 = now$3;
var reWhitespace$1 = /\s/;
function trimmedEndIndex$2(string) {
  var index2 = string.length;
  while (index2-- && reWhitespace$1.test(string.charAt(index2))) {
  }
  return index2;
}
var reTrimStart$1 = /^\s+/;
function baseTrim$2(string) {
  return string ? string.slice(0, trimmedEndIndex$2(string) + 1).replace(reTrimStart$1, "") : string;
}
var symbolTag$1 = "[object Symbol]";
function isSymbol$1(value) {
  return typeof value == "symbol" || isObjectLike$1(value) && baseGetTag(value) == symbolTag$1;
}
var NAN$1 = 0 / 0;
var reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary$1 = /^0b[01]+$/i;
var reIsOctal$1 = /^0o[0-7]+$/i;
var freeParseInt$1 = parseInt;
function toNumber$3(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol$1(value)) {
    return NAN$1;
  }
  if (isObject$a(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$a(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim$2(value);
  var isBinary = reIsBinary$1.test(value);
  return isBinary || reIsOctal$1.test(value) ? freeParseInt$1(value.slice(2), isBinary ? 2 : 8) : reIsBadHex$1.test(value) ? NAN$1 : +value;
}
var FUNC_ERROR_TEXT$3 = "Expected a function";
var nativeMax$3 = Math.max, nativeMin$1 = Math.min;
function debounce$2(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$3);
  }
  wait = toNumber$3(wait) || 0;
  if (isObject$a(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax$3(toNumber$3(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin$1(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now$4();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now$4());
  }
  function debounced() {
    var time = now$4(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var FUNC_ERROR_TEXT$2 = "Expected a function";
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  if (isObject$a(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce$2(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var calculateChange3 = function calculateChange4(e2, hsl2, container2) {
  var _container$getBoundin = container2.getBoundingClientRect(), containerWidth = _container$getBoundin.width, containerHeight = _container$getBoundin.height;
  var x = typeof e2.pageX === "number" ? e2.pageX : e2.touches[0].pageX;
  var y2 = typeof e2.pageY === "number" ? e2.pageY : e2.touches[0].pageY;
  var left = x - (container2.getBoundingClientRect().left + window.pageXOffset);
  var top = y2 - (container2.getBoundingClientRect().top + window.pageYOffset);
  if (left < 0) {
    left = 0;
  } else if (left > containerWidth) {
    left = containerWidth;
  }
  if (top < 0) {
    top = 0;
  } else if (top > containerHeight) {
    top = containerHeight;
  }
  var saturation = left / containerWidth;
  var bright = 1 - top / containerHeight;
  return {
    h: hsl2.h,
    s: saturation,
    v: bright,
    a: hsl2.a,
    source: "hsv"
  };
};
var _createClass$4 = function() {
  function defineProperties(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$4(self2, call2) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
}
function _inherits$4(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var Saturation = function(_ref) {
  _inherits$4(Saturation2, _ref);
  function Saturation2(props) {
    _classCallCheck$4(this, Saturation2);
    var _this = _possibleConstructorReturn$4(this, (Saturation2.__proto__ || Object.getPrototypeOf(Saturation2)).call(this, props));
    _this.handleChange = function(e2) {
      typeof _this.props.onChange === "function" && _this.throttle(_this.props.onChange, calculateChange3(e2, _this.props.hsl, _this.container), e2);
    };
    _this.handleMouseDown = function(e2) {
      _this.handleChange(e2);
      var renderWindow = _this.getContainerRenderWindow();
      renderWindow.addEventListener("mousemove", _this.handleChange);
      renderWindow.addEventListener("mouseup", _this.handleMouseUp);
    };
    _this.handleMouseUp = function() {
      _this.unbindEventListeners();
    };
    _this.throttle = throttle(function(fn, data, e2) {
      fn(data, e2);
    }, 50);
    return _this;
  }
  _createClass$4(Saturation2, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.throttle.cancel();
      this.unbindEventListeners();
    }
  }, {
    key: "getContainerRenderWindow",
    value: function getContainerRenderWindow() {
      var container2 = this.container;
      var renderWindow = window;
      while (!renderWindow.document.contains(container2) && renderWindow.parent !== renderWindow) {
        renderWindow = renderWindow.parent;
      }
      return renderWindow;
    }
  }, {
    key: "unbindEventListeners",
    value: function unbindEventListeners() {
      var renderWindow = this.getContainerRenderWindow();
      renderWindow.removeEventListener("mousemove", this.handleChange);
      renderWindow.removeEventListener("mouseup", this.handleMouseUp);
    }
  }, {
    key: "render",
    value: function render3() {
      var _this2 = this;
      var _ref2 = this.props.style || {}, color2 = _ref2.color, white = _ref2.white, black = _ref2.black, pointer = _ref2.pointer, circle = _ref2.circle;
      var styles2 = _default$a({
        "default": {
          color: {
            absolute: "0px 0px 0px 0px",
            background: "hsl(" + this.props.hsl.h + ",100%, 50%)",
            borderRadius: this.props.radius
          },
          white: {
            absolute: "0px 0px 0px 0px",
            borderRadius: this.props.radius
          },
          black: {
            absolute: "0px 0px 0px 0px",
            boxShadow: this.props.shadow,
            borderRadius: this.props.radius
          },
          pointer: {
            position: "absolute",
            top: -(this.props.hsv.v * 100) + 100 + "%",
            left: this.props.hsv.s * 100 + "%",
            cursor: "default"
          },
          circle: {
            width: "4px",
            height: "4px",
            boxShadow: "0 0 0 1.5px #fff, inset 0 0 1px 1px rgba(0,0,0,.3),\n            0 0 1px 2px rgba(0,0,0,.4)",
            borderRadius: "50%",
            cursor: "hand",
            transform: "translate(-2px, -2px)"
          }
        },
        "custom": {
          color: color2,
          white,
          black,
          pointer,
          circle
        }
      }, { "custom": !!this.props.style });
      return React.createElement(
        "div",
        {
          style: styles2.color,
          ref: function ref(container2) {
            return _this2.container = container2;
          },
          onMouseDown: this.handleMouseDown,
          onTouchMove: this.handleChange,
          onTouchStart: this.handleChange
        },
        React.createElement(
          "style",
          null,
          "\n          .saturation-white {\n            background: -webkit-linear-gradient(to right, #fff, rgba(255,255,255,0));\n            background: linear-gradient(to right, #fff, rgba(255,255,255,0));\n          }\n          .saturation-black {\n            background: -webkit-linear-gradient(to top, #000, rgba(0,0,0,0));\n            background: linear-gradient(to top, #000, rgba(0,0,0,0));\n          }\n        "
        ),
        React.createElement(
          "div",
          { style: styles2.white, className: "saturation-white" },
          React.createElement("div", { style: styles2.black, className: "saturation-black" }),
          React.createElement(
            "div",
            { style: styles2.pointer },
            this.props.pointer ? React.createElement(this.props.pointer, this.props) : React.createElement("div", { style: styles2.circle })
          )
        )
      );
    }
  }]);
  return Saturation2;
}(reactExports.PureComponent || reactExports.Component);
function arrayEach(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (iteratee(array[index2], index2, array) === false) {
      break;
    }
  }
  return array;
}
var nativeKeys = overArg(Object.keys, Object);
const nativeKeys$1 = nativeKeys;
var objectProto$3 = Object.prototype;
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys$1(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$2.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function keys$1(object) {
  return isArrayLike$2(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function baseForOwn$1(object, iteratee) {
  return object && baseFor$2(object, iteratee, keys$1);
}
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike$2(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var baseEach = createBaseEach(baseForOwn$1);
const baseEach$1 = baseEach;
function castFunction(value) {
  return typeof value == "function" ? value : identity$2;
}
function forEach(collection, iteratee) {
  var func = isArray$4(collection) ? arrayEach : baseEach$1;
  return func(collection, castFunction(iteratee));
}
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1(obj);
}
var trimLeft = /^\s+/;
var trimRight = /\s+$/;
function tinycolor(color2, opts) {
  color2 = color2 ? color2 : "";
  opts = opts || {};
  if (color2 instanceof tinycolor) {
    return color2;
  }
  if (!(this instanceof tinycolor)) {
    return new tinycolor(color2, opts);
  }
  var rgb2 = inputToRGB(color2);
  this._originalInput = color2, this._r = rgb2.r, this._g = rgb2.g, this._b = rgb2.b, this._a = rgb2.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb2.format;
  this._gradientType = opts.gradientType;
  if (this._r < 1)
    this._r = Math.round(this._r);
  if (this._g < 1)
    this._g = Math.round(this._g);
  if (this._b < 1)
    this._b = Math.round(this._b);
  this._ok = rgb2.ok;
}
tinycolor.prototype = {
  isDark: function isDark() {
    return this.getBrightness() < 128;
  },
  isLight: function isLight() {
    return !this.isDark();
  },
  isValid: function isValid() {
    return this._ok;
  },
  getOriginalInput: function getOriginalInput() {
    return this._originalInput;
  },
  getFormat: function getFormat() {
    return this._format;
  },
  getAlpha: function getAlpha() {
    return this._a;
  },
  getBrightness: function getBrightness() {
    var rgb2 = this.toRgb();
    return (rgb2.r * 299 + rgb2.g * 587 + rgb2.b * 114) / 1e3;
  },
  getLuminance: function getLuminance() {
    var rgb2 = this.toRgb();
    var RsRGB, GsRGB, BsRGB, R, G2, B2;
    RsRGB = rgb2.r / 255;
    GsRGB = rgb2.g / 255;
    BsRGB = rgb2.b / 255;
    if (RsRGB <= 0.03928)
      R = RsRGB / 12.92;
    else
      R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    if (GsRGB <= 0.03928)
      G2 = GsRGB / 12.92;
    else
      G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    if (BsRGB <= 0.03928)
      B2 = BsRGB / 12.92;
    else
      B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    return 0.2126 * R + 0.7152 * G2 + 0.0722 * B2;
  },
  setAlpha: function setAlpha(value) {
    this._a = boundAlpha(value);
    this._roundA = Math.round(100 * this._a) / 100;
    return this;
  },
  toHsv: function toHsv() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v,
      a: this._a
    };
  },
  toHsvString: function toHsvString() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    var h2 = Math.round(hsv.h * 360), s2 = Math.round(hsv.s * 100), v2 = Math.round(hsv.v * 100);
    return this._a == 1 ? "hsv(" + h2 + ", " + s2 + "%, " + v2 + "%)" : "hsva(" + h2 + ", " + s2 + "%, " + v2 + "%, " + this._roundA + ")";
  },
  toHsl: function toHsl() {
    var hsl2 = rgbToHsl(this._r, this._g, this._b);
    return {
      h: hsl2.h * 360,
      s: hsl2.s,
      l: hsl2.l,
      a: this._a
    };
  },
  toHslString: function toHslString() {
    var hsl2 = rgbToHsl(this._r, this._g, this._b);
    var h2 = Math.round(hsl2.h * 360), s2 = Math.round(hsl2.s * 100), l2 = Math.round(hsl2.l * 100);
    return this._a == 1 ? "hsl(" + h2 + ", " + s2 + "%, " + l2 + "%)" : "hsla(" + h2 + ", " + s2 + "%, " + l2 + "%, " + this._roundA + ")";
  },
  toHex: function toHex(allow3Char) {
    return rgbToHex(this._r, this._g, this._b, allow3Char);
  },
  toHexString: function toHexString(allow3Char) {
    return "#" + this.toHex(allow3Char);
  },
  toHex8: function toHex8(allow4Char) {
    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
  },
  toHex8String: function toHex8String(allow4Char) {
    return "#" + this.toHex8(allow4Char);
  },
  toRgb: function toRgb() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function toRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function toPercentageRgb() {
    return {
      r: Math.round(bound01(this._r, 255) * 100) + "%",
      g: Math.round(bound01(this._g, 255) * 100) + "%",
      b: Math.round(bound01(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function toPercentageRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function toName() {
    if (this._a === 0) {
      return "transparent";
    }
    if (this._a < 1) {
      return false;
    }
    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
  },
  toFilter: function toFilter(secondColor) {
    var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
    var secondHex8String = hex8String;
    var gradientType = this._gradientType ? "GradientType = 1, " : "";
    if (secondColor) {
      var s2 = tinycolor(secondColor);
      secondHex8String = "#" + rgbaToArgbHex(s2._r, s2._g, s2._b, s2._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
  },
  toString: function toString(format2) {
    var formatSet = !!format2;
    format2 = format2 || this._format;
    var formattedString = false;
    var hasAlpha = this._a < 1 && this._a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format2 === "hex" || format2 === "hex6" || format2 === "hex3" || format2 === "hex4" || format2 === "hex8" || format2 === "name");
    if (needsAlphaFormat) {
      if (format2 === "name" && this._a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format2 === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format2 === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format2 === "hex" || format2 === "hex6") {
      formattedString = this.toHexString();
    }
    if (format2 === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format2 === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format2 === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format2 === "name") {
      formattedString = this.toName();
    }
    if (format2 === "hsl") {
      formattedString = this.toHslString();
    }
    if (format2 === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  },
  clone: function clone() {
    return tinycolor(this.toString());
  },
  _applyModification: function _applyModification(fn, args) {
    var color2 = fn.apply(null, [this].concat([].slice.call(args)));
    this._r = color2._r;
    this._g = color2._g;
    this._b = color2._b;
    this.setAlpha(color2._a);
    return this;
  },
  lighten: function lighten2() {
    return this._applyModification(_lighten, arguments);
  },
  brighten: function brighten() {
    return this._applyModification(_brighten, arguments);
  },
  darken: function darken2() {
    return this._applyModification(_darken, arguments);
  },
  desaturate: function desaturate() {
    return this._applyModification(_desaturate, arguments);
  },
  saturate: function saturate() {
    return this._applyModification(_saturate, arguments);
  },
  greyscale: function greyscale() {
    return this._applyModification(_greyscale, arguments);
  },
  spin: function spin() {
    return this._applyModification(_spin, arguments);
  },
  _applyCombination: function _applyCombination(fn, args) {
    return fn.apply(null, [this].concat([].slice.call(args)));
  },
  analogous: function analogous() {
    return this._applyCombination(_analogous, arguments);
  },
  complement: function complement() {
    return this._applyCombination(_complement, arguments);
  },
  monochromatic: function monochromatic() {
    return this._applyCombination(_monochromatic, arguments);
  },
  splitcomplement: function splitcomplement() {
    return this._applyCombination(_splitcomplement, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function triad() {
    return this._applyCombination(polyad, [3]);
  },
  tetrad: function tetrad() {
    return this._applyCombination(polyad, [4]);
  }
};
tinycolor.fromRatio = function(color2, opts) {
  if (_typeof$1(color2) == "object") {
    var newColor = {};
    for (var i2 in color2) {
      if (color2.hasOwnProperty(i2)) {
        if (i2 === "a") {
          newColor[i2] = color2[i2];
        } else {
          newColor[i2] = convertToPercentage(color2[i2]);
        }
      }
    }
    color2 = newColor;
  }
  return tinycolor(color2, opts);
};
function inputToRGB(color2) {
  var rgb2 = {
    r: 0,
    g: 0,
    b: 0
  };
  var a2 = 1;
  var s2 = null;
  var v2 = null;
  var l2 = null;
  var ok = false;
  var format2 = false;
  if (typeof color2 == "string") {
    color2 = stringInputToObject(color2);
  }
  if (_typeof$1(color2) == "object") {
    if (isValidCSSUnit(color2.r) && isValidCSSUnit(color2.g) && isValidCSSUnit(color2.b)) {
      rgb2 = rgbToRgb(color2.r, color2.g, color2.b);
      ok = true;
      format2 = String(color2.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.v)) {
      s2 = convertToPercentage(color2.s);
      v2 = convertToPercentage(color2.v);
      rgb2 = hsvToRgb(color2.h, s2, v2);
      ok = true;
      format2 = "hsv";
    } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.l)) {
      s2 = convertToPercentage(color2.s);
      l2 = convertToPercentage(color2.l);
      rgb2 = hslToRgb(color2.h, s2, l2);
      ok = true;
      format2 = "hsl";
    }
    if (color2.hasOwnProperty("a")) {
      a2 = color2.a;
    }
  }
  a2 = boundAlpha(a2);
  return {
    ok,
    format: color2.format || format2,
    r: Math.min(255, Math.max(rgb2.r, 0)),
    g: Math.min(255, Math.max(rgb2.g, 0)),
    b: Math.min(255, Math.max(rgb2.b, 0)),
    a: a2
  };
}
function rgbToRgb(r2, g2, b2) {
  return {
    r: bound01(r2, 255) * 255,
    g: bound01(g2, 255) * 255,
    b: bound01(b2, 255) * 255
  };
}
function rgbToHsl(r2, g2, b2) {
  r2 = bound01(r2, 255);
  g2 = bound01(g2, 255);
  b2 = bound01(b2, 255);
  var max2 = Math.max(r2, g2, b2), min2 = Math.min(r2, g2, b2);
  var h2, s2, l2 = (max2 + min2) / 2;
  if (max2 == min2) {
    h2 = s2 = 0;
  } else {
    var d2 = max2 - min2;
    s2 = l2 > 0.5 ? d2 / (2 - max2 - min2) : d2 / (max2 + min2);
    switch (max2) {
      case r2:
        h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
        break;
      case g2:
        h2 = (b2 - r2) / d2 + 2;
        break;
      case b2:
        h2 = (r2 - g2) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return {
    h: h2,
    s: s2,
    l: l2
  };
}
function hslToRgb(h2, s2, l2) {
  var r2, g2, b2;
  h2 = bound01(h2, 360);
  s2 = bound01(s2, 100);
  l2 = bound01(l2, 100);
  function hue2rgb2(p3, q3, t2) {
    if (t2 < 0)
      t2 += 1;
    if (t2 > 1)
      t2 -= 1;
    if (t2 < 1 / 6)
      return p3 + (q3 - p3) * 6 * t2;
    if (t2 < 1 / 2)
      return q3;
    if (t2 < 2 / 3)
      return p3 + (q3 - p3) * (2 / 3 - t2) * 6;
    return p3;
  }
  if (s2 === 0) {
    r2 = g2 = b2 = l2;
  } else {
    var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
    var p2 = 2 * l2 - q2;
    r2 = hue2rgb2(p2, q2, h2 + 1 / 3);
    g2 = hue2rgb2(p2, q2, h2);
    b2 = hue2rgb2(p2, q2, h2 - 1 / 3);
  }
  return {
    r: r2 * 255,
    g: g2 * 255,
    b: b2 * 255
  };
}
function rgbToHsv(r2, g2, b2) {
  r2 = bound01(r2, 255);
  g2 = bound01(g2, 255);
  b2 = bound01(b2, 255);
  var max2 = Math.max(r2, g2, b2), min2 = Math.min(r2, g2, b2);
  var h2, s2, v2 = max2;
  var d2 = max2 - min2;
  s2 = max2 === 0 ? 0 : d2 / max2;
  if (max2 == min2) {
    h2 = 0;
  } else {
    switch (max2) {
      case r2:
        h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
        break;
      case g2:
        h2 = (b2 - r2) / d2 + 2;
        break;
      case b2:
        h2 = (r2 - g2) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return {
    h: h2,
    s: s2,
    v: v2
  };
}
function hsvToRgb(h2, s2, v2) {
  h2 = bound01(h2, 360) * 6;
  s2 = bound01(s2, 100);
  v2 = bound01(v2, 100);
  var i2 = Math.floor(h2), f2 = h2 - i2, p2 = v2 * (1 - s2), q2 = v2 * (1 - f2 * s2), t2 = v2 * (1 - (1 - f2) * s2), mod2 = i2 % 6, r2 = [v2, q2, p2, p2, t2, v2][mod2], g2 = [t2, v2, v2, q2, p2, p2][mod2], b2 = [p2, p2, t2, v2, v2, q2][mod2];
  return {
    r: r2 * 255,
    g: g2 * 255,
    b: b2 * 255
  };
}
function rgbToHex(r2, g2, b2, allow3Char) {
  var hex = [pad2(Math.round(r2).toString(16)), pad2(Math.round(g2).toString(16)), pad2(Math.round(b2).toString(16))];
  if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}
function rgbaToHex(r2, g2, b2, a2, allow4Char) {
  var hex = [pad2(Math.round(r2).toString(16)), pad2(Math.round(g2).toString(16)), pad2(Math.round(b2).toString(16)), pad2(convertDecimalToHex(a2))];
  if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join("");
}
function rgbaToArgbHex(r2, g2, b2, a2) {
  var hex = [pad2(convertDecimalToHex(a2)), pad2(Math.round(r2).toString(16)), pad2(Math.round(g2).toString(16)), pad2(Math.round(b2).toString(16))];
  return hex.join("");
}
tinycolor.equals = function(color1, color2) {
  if (!color1 || !color2)
    return false;
  return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};
tinycolor.random = function() {
  return tinycolor.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function _desaturate(color2, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl2 = tinycolor(color2).toHsl();
  hsl2.s -= amount / 100;
  hsl2.s = clamp01(hsl2.s);
  return tinycolor(hsl2);
}
function _saturate(color2, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl2 = tinycolor(color2).toHsl();
  hsl2.s += amount / 100;
  hsl2.s = clamp01(hsl2.s);
  return tinycolor(hsl2);
}
function _greyscale(color2) {
  return tinycolor(color2).desaturate(100);
}
function _lighten(color2, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl2 = tinycolor(color2).toHsl();
  hsl2.l += amount / 100;
  hsl2.l = clamp01(hsl2.l);
  return tinycolor(hsl2);
}
function _brighten(color2, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var rgb2 = tinycolor(color2).toRgb();
  rgb2.r = Math.max(0, Math.min(255, rgb2.r - Math.round(255 * -(amount / 100))));
  rgb2.g = Math.max(0, Math.min(255, rgb2.g - Math.round(255 * -(amount / 100))));
  rgb2.b = Math.max(0, Math.min(255, rgb2.b - Math.round(255 * -(amount / 100))));
  return tinycolor(rgb2);
}
function _darken(color2, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl2 = tinycolor(color2).toHsl();
  hsl2.l -= amount / 100;
  hsl2.l = clamp01(hsl2.l);
  return tinycolor(hsl2);
}
function _spin(color2, amount) {
  var hsl2 = tinycolor(color2).toHsl();
  var hue = (hsl2.h + amount) % 360;
  hsl2.h = hue < 0 ? 360 + hue : hue;
  return tinycolor(hsl2);
}
function _complement(color2) {
  var hsl2 = tinycolor(color2).toHsl();
  hsl2.h = (hsl2.h + 180) % 360;
  return tinycolor(hsl2);
}
function polyad(color2, number) {
  if (isNaN(number) || number <= 0) {
    throw new Error("Argument to polyad must be a positive number");
  }
  var hsl2 = tinycolor(color2).toHsl();
  var result = [tinycolor(color2)];
  var step = 360 / number;
  for (var i2 = 1; i2 < number; i2++) {
    result.push(tinycolor({
      h: (hsl2.h + i2 * step) % 360,
      s: hsl2.s,
      l: hsl2.l
    }));
  }
  return result;
}
function _splitcomplement(color2) {
  var hsl2 = tinycolor(color2).toHsl();
  var h2 = hsl2.h;
  return [tinycolor(color2), tinycolor({
    h: (h2 + 72) % 360,
    s: hsl2.s,
    l: hsl2.l
  }), tinycolor({
    h: (h2 + 216) % 360,
    s: hsl2.s,
    l: hsl2.l
  })];
}
function _analogous(color2, results, slices) {
  results = results || 6;
  slices = slices || 30;
  var hsl2 = tinycolor(color2).toHsl();
  var part = 360 / slices;
  var ret = [tinycolor(color2)];
  for (hsl2.h = (hsl2.h - (part * results >> 1) + 720) % 360; --results; ) {
    hsl2.h = (hsl2.h + part) % 360;
    ret.push(tinycolor(hsl2));
  }
  return ret;
}
function _monochromatic(color2, results) {
  results = results || 6;
  var hsv = tinycolor(color2).toHsv();
  var h2 = hsv.h, s2 = hsv.s, v2 = hsv.v;
  var ret = [];
  var modification = 1 / results;
  while (results--) {
    ret.push(tinycolor({
      h: h2,
      s: s2,
      v: v2
    }));
    v2 = (v2 + modification) % 1;
  }
  return ret;
}
tinycolor.mix = function(color1, color2, amount) {
  amount = amount === 0 ? 0 : amount || 50;
  var rgb1 = tinycolor(color1).toRgb();
  var rgb2 = tinycolor(color2).toRgb();
  var p2 = amount / 100;
  var rgba2 = {
    r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
    g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
    b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
    a: (rgb2.a - rgb1.a) * p2 + rgb1.a
  };
  return tinycolor(rgba2);
};
tinycolor.readability = function(color1, color2) {
  var c1 = tinycolor(color1);
  var c2 = tinycolor(color2);
  return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
};
tinycolor.isReadable = function(color1, color2, wcag2) {
  var readability = tinycolor.readability(color1, color2);
  var wcag2Parms, out;
  out = false;
  wcag2Parms = validateWCAG2Parms(wcag2);
  switch (wcag2Parms.level + wcag2Parms.size) {
    case "AAsmall":
    case "AAAlarge":
      out = readability >= 4.5;
      break;
    case "AAlarge":
      out = readability >= 3;
      break;
    case "AAAsmall":
      out = readability >= 7;
      break;
  }
  return out;
};
tinycolor.mostReadable = function(baseColor, colorList, args) {
  var bestColor = null;
  var bestScore = 0;
  var readability;
  var includeFallbackColors, level, size;
  args = args || {};
  includeFallbackColors = args.includeFallbackColors;
  level = args.level;
  size = args.size;
  for (var i2 = 0; i2 < colorList.length; i2++) {
    readability = tinycolor.readability(baseColor, colorList[i2]);
    if (readability > bestScore) {
      bestScore = readability;
      bestColor = tinycolor(colorList[i2]);
    }
  }
  if (tinycolor.isReadable(baseColor, bestColor, {
    level,
    size
  }) || !includeFallbackColors) {
    return bestColor;
  } else {
    args.includeFallbackColors = false;
    return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
  }
};
var names = tinycolor.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
var hexNames = tinycolor.hexNames = flip(names);
function flip(o) {
  var flipped = {};
  for (var i2 in o) {
    if (o.hasOwnProperty(i2)) {
      flipped[o[i2]] = i2;
    }
  }
  return flipped;
}
function boundAlpha(a2) {
  a2 = parseFloat(a2);
  if (isNaN(a2) || a2 < 0 || a2 > 1) {
    a2 = 1;
  }
  return a2;
}
function bound01(n2, max2) {
  if (isOnePointZero(n2))
    n2 = "100%";
  var processPercent = isPercentage(n2);
  n2 = Math.min(max2, Math.max(0, parseFloat(n2)));
  if (processPercent) {
    n2 = parseInt(n2 * max2, 10) / 100;
  }
  if (Math.abs(n2 - max2) < 1e-6) {
    return 1;
  }
  return n2 % max2 / parseFloat(max2);
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function isOnePointZero(n2) {
  return typeof n2 == "string" && n2.indexOf(".") != -1 && parseFloat(n2) === 1;
}
function isPercentage(n2) {
  return typeof n2 === "string" && n2.indexOf("%") != -1;
}
function pad2(c2) {
  return c2.length == 1 ? "0" + c2 : "" + c2;
}
function convertToPercentage(n2) {
  if (n2 <= 1) {
    n2 = n2 * 100 + "%";
  }
  return n2;
}
function convertDecimalToHex(d2) {
  return Math.round(parseFloat(d2) * 255).toString(16);
}
function convertHexToDecimal(h2) {
  return parseIntFromHex(h2) / 255;
}
var matchers = function() {
  var CSS_INTEGER = "[-\\+]?\\d+%?";
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
  var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();
function isValidCSSUnit(color2) {
  return !!matchers.CSS_UNIT.exec(color2);
}
function stringInputToObject(color2) {
  color2 = color2.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var named = false;
  if (names[color2]) {
    color2 = names[color2];
    named = true;
  } else if (color2 == "transparent") {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  }
  var match5;
  if (match5 = matchers.rgb.exec(color2)) {
    return {
      r: match5[1],
      g: match5[2],
      b: match5[3]
    };
  }
  if (match5 = matchers.rgba.exec(color2)) {
    return {
      r: match5[1],
      g: match5[2],
      b: match5[3],
      a: match5[4]
    };
  }
  if (match5 = matchers.hsl.exec(color2)) {
    return {
      h: match5[1],
      s: match5[2],
      l: match5[3]
    };
  }
  if (match5 = matchers.hsla.exec(color2)) {
    return {
      h: match5[1],
      s: match5[2],
      l: match5[3],
      a: match5[4]
    };
  }
  if (match5 = matchers.hsv.exec(color2)) {
    return {
      h: match5[1],
      s: match5[2],
      v: match5[3]
    };
  }
  if (match5 = matchers.hsva.exec(color2)) {
    return {
      h: match5[1],
      s: match5[2],
      v: match5[3],
      a: match5[4]
    };
  }
  if (match5 = matchers.hex8.exec(color2)) {
    return {
      r: parseIntFromHex(match5[1]),
      g: parseIntFromHex(match5[2]),
      b: parseIntFromHex(match5[3]),
      a: convertHexToDecimal(match5[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match5 = matchers.hex6.exec(color2)) {
    return {
      r: parseIntFromHex(match5[1]),
      g: parseIntFromHex(match5[2]),
      b: parseIntFromHex(match5[3]),
      format: named ? "name" : "hex"
    };
  }
  if (match5 = matchers.hex4.exec(color2)) {
    return {
      r: parseIntFromHex(match5[1] + "" + match5[1]),
      g: parseIntFromHex(match5[2] + "" + match5[2]),
      b: parseIntFromHex(match5[3] + "" + match5[3]),
      a: convertHexToDecimal(match5[4] + "" + match5[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match5 = matchers.hex3.exec(color2)) {
    return {
      r: parseIntFromHex(match5[1] + "" + match5[1]),
      g: parseIntFromHex(match5[2] + "" + match5[2]),
      b: parseIntFromHex(match5[3] + "" + match5[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function validateWCAG2Parms(parms) {
  var level, size;
  parms = parms || {
    level: "AA",
    size: "small"
  };
  level = (parms.level || "AA").toUpperCase();
  size = (parms.size || "small").toLowerCase();
  if (level !== "AA" && level !== "AAA") {
    level = "AA";
  }
  if (size !== "small" && size !== "large") {
    size = "small";
  }
  return {
    level,
    size
  };
}
var simpleCheckForValidColor = function simpleCheckForValidColor2(data) {
  var keysToCheck = ["r", "g", "b", "a", "h", "s", "l", "v"];
  var checked = 0;
  var passed = 0;
  forEach(keysToCheck, function(letter) {
    if (data[letter]) {
      checked += 1;
      if (!isNaN(data[letter])) {
        passed += 1;
      }
      if (letter === "s" || letter === "l") {
        var percentPatt = /^\d+%$/;
        if (percentPatt.test(data[letter])) {
          passed += 1;
        }
      }
    }
  });
  return checked === passed ? data : false;
};
var toState = function toState2(data, oldHue) {
  var color2 = data.hex ? tinycolor(data.hex) : tinycolor(data);
  var hsl2 = color2.toHsl();
  var hsv = color2.toHsv();
  var rgb2 = color2.toRgb();
  var hex = color2.toHex();
  if (hsl2.s === 0) {
    hsl2.h = oldHue || 0;
    hsv.h = oldHue || 0;
  }
  var transparent = hex === "000000" && rgb2.a === 0;
  return {
    hsl: hsl2,
    hex: transparent ? "transparent" : "#" + hex,
    rgb: rgb2,
    hsv,
    oldHue: data.h || oldHue || hsl2.h,
    source: data.source
  };
};
var isValidHex = function isValidHex2(hex) {
  if (hex === "transparent") {
    return true;
  }
  var lh = String(hex).charAt(0) === "#" ? 1 : 0;
  return hex.length !== 4 + lh && hex.length < 7 + lh && tinycolor(hex).isValid();
};
var getContrastingColor = function getContrastingColor2(data) {
  if (!data) {
    return "#fff";
  }
  var col = toState(data);
  if (col.hex === "transparent") {
    return "rgba(0,0,0,0.4)";
  }
  var yiq = (col.rgb.r * 299 + col.rgb.g * 587 + col.rgb.b * 114) / 1e3;
  return yiq >= 128 ? "#000" : "#fff";
};
var isvalidColorString = function isvalidColorString2(string, type2) {
  var stringWithoutDegree = string.replace("°", "");
  return tinycolor(type2 + " (" + stringWithoutDegree + ")")._ok;
};
var _extends$9 = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _createClass$3 = function() {
  function defineProperties(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$3(self2, call2) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
}
function _inherits$3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var ColorWrap = function ColorWrap2(Picker) {
  var ColorPicker2 = function(_ref) {
    _inherits$3(ColorPicker3, _ref);
    function ColorPicker3(props) {
      _classCallCheck$3(this, ColorPicker3);
      var _this = _possibleConstructorReturn$3(this, (ColorPicker3.__proto__ || Object.getPrototypeOf(ColorPicker3)).call(this));
      _this.handleChange = function(data, event) {
        var isValidColor = simpleCheckForValidColor(data);
        if (isValidColor) {
          var colors2 = toState(data, data.h || _this.state.oldHue);
          _this.setState(colors2);
          _this.props.onChangeComplete && _this.debounce(_this.props.onChangeComplete, colors2, event);
          _this.props.onChange && _this.props.onChange(colors2, event);
        }
      };
      _this.handleSwatchHover = function(data, event) {
        var isValidColor = simpleCheckForValidColor(data);
        if (isValidColor) {
          var colors2 = toState(data, data.h || _this.state.oldHue);
          _this.props.onSwatchHover && _this.props.onSwatchHover(colors2, event);
        }
      };
      _this.state = _extends$9({}, toState(props.color, 0));
      _this.debounce = debounce$2(function(fn, data, event) {
        fn(data, event);
      }, 100);
      return _this;
    }
    _createClass$3(ColorPicker3, [{
      key: "render",
      value: function render3() {
        var optionalEvents = {};
        if (this.props.onSwatchHover) {
          optionalEvents.onSwatchHover = this.handleSwatchHover;
        }
        return React.createElement(Picker, _extends$9({}, this.props, this.state, {
          onChange: this.handleChange
        }, optionalEvents));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(nextProps, state) {
        return _extends$9({}, toState(nextProps.color, state.oldHue));
      }
    }]);
    return ColorPicker3;
  }(reactExports.PureComponent || reactExports.Component);
  ColorPicker2.propTypes = _extends$9({}, Picker.propTypes);
  ColorPicker2.defaultProps = _extends$9({}, Picker.defaultProps, {
    color: {
      h: 250,
      s: 0.5,
      l: 0.2,
      a: 1
    }
  });
  return ColorPicker2;
};
var _extends$8 = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _createClass$2 = function() {
  function defineProperties(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$2(self2, call2) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
}
function _inherits$2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var handleFocus = function handleFocus2(Component) {
  var Span = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
  return function(_React$Component) {
    _inherits$2(Focus, _React$Component);
    function Focus() {
      var _ref;
      var _temp, _this, _ret;
      _classCallCheck$2(this, Focus);
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _ret = (_temp = (_this = _possibleConstructorReturn$2(this, (_ref = Focus.__proto__ || Object.getPrototypeOf(Focus)).call.apply(_ref, [this].concat(args))), _this), _this.state = { focus: false }, _this.handleFocus = function() {
        return _this.setState({ focus: true });
      }, _this.handleBlur = function() {
        return _this.setState({ focus: false });
      }, _temp), _possibleConstructorReturn$2(_this, _ret);
    }
    _createClass$2(Focus, [{
      key: "render",
      value: function render3() {
        return React.createElement(
          Span,
          { onFocus: this.handleFocus, onBlur: this.handleBlur },
          React.createElement(Component, _extends$8({}, this.props, this.state))
        );
      }
    }]);
    return Focus;
  }(React.Component);
};
var _extends$7 = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var ENTER = 13;
var Swatch = function Swatch2(_ref) {
  var color2 = _ref.color, style = _ref.style, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, onHover = _ref.onHover, _ref$title = _ref.title, title2 = _ref$title === void 0 ? color2 : _ref$title, children = _ref.children, focus = _ref.focus, _ref$focusStyle = _ref.focusStyle, focusStyle = _ref$focusStyle === void 0 ? {} : _ref$focusStyle;
  var transparent = color2 === "transparent";
  var styles2 = _default$a({
    default: {
      swatch: _extends$7({
        background: color2,
        height: "100%",
        width: "100%",
        cursor: "pointer",
        position: "relative",
        outline: "none"
      }, style, focus ? focusStyle : {})
    }
  });
  var handleClick = function handleClick2(e2) {
    return onClick(color2, e2);
  };
  var handleKeyDown = function handleKeyDown2(e2) {
    return e2.keyCode === ENTER && onClick(color2, e2);
  };
  var handleHover2 = function handleHover3(e2) {
    return onHover(color2, e2);
  };
  var optionalEvents = {};
  if (onHover) {
    optionalEvents.onMouseOver = handleHover2;
  }
  return React.createElement(
    "div",
    _extends$7({
      style: styles2.swatch,
      onClick: handleClick,
      title: title2,
      tabIndex: 0,
      onKeyDown: handleKeyDown
    }, optionalEvents),
    children,
    transparent && React.createElement(Checkboard, {
      borderRadius: styles2.swatch.borderRadius,
      boxShadow: "inset 0 0 0 1px rgba(0,0,0,0.1)"
    })
  );
};
const Swatch$1 = handleFocus(Swatch);
var AlphaPointer = function AlphaPointer2(_ref) {
  var direction = _ref.direction;
  var styles2 = _default$a({
    "default": {
      picker: {
        width: "18px",
        height: "18px",
        borderRadius: "50%",
        transform: "translate(-9px, -1px)",
        backgroundColor: "rgb(248, 248, 248)",
        boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
      }
    },
    "vertical": {
      picker: {
        transform: "translate(-3px, -9px)"
      }
    }
  }, { vertical: direction === "vertical" });
  return React.createElement("div", { style: styles2.picker });
};
var _extends$6 = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var AlphaPicker = function AlphaPicker2(_ref) {
  var rgb2 = _ref.rgb, hsl2 = _ref.hsl, width = _ref.width, height = _ref.height, onChange = _ref.onChange, direction = _ref.direction, style = _ref.style, renderers = _ref.renderers, pointer = _ref.pointer, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = _default$a({
    "default": {
      picker: {
        position: "relative",
        width,
        height
      },
      alpha: {
        radius: "2px",
        style
      }
    }
  });
  return React.createElement(
    "div",
    { style: styles2.picker, className: "alpha-picker " + className },
    React.createElement(Alpha, _extends$6({}, styles2.alpha, {
      rgb: rgb2,
      hsl: hsl2,
      pointer,
      renderers,
      onChange,
      direction
    }))
  );
};
AlphaPicker.defaultProps = {
  width: "316px",
  height: "16px",
  direction: "horizontal",
  pointer: AlphaPointer
};
ColorWrap(AlphaPicker);
function arrayMap$2(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
function setCacheHas(value) {
  return this.__data__.has(value);
}
function SetCache(values) {
  var index2 = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();
  while (++index2 < length) {
    this.add(values[index2]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
function cacheHas(cache, key) {
  return cache.has(key);
}
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
function mapToArray(map2) {
  var index2 = -1, result = Array(map2.size);
  map2.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
function setToArray(set2) {
  var index2 = -1, result = Array(set2.size);
  set2.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag$1 = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]";
var symbolProto$1 = Symbol$3 ? Symbol$3.prototype : void 0, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$1:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq$2(+object, +other);
    case errorTag:
      return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag:
      return object == other + "";
    case mapTag$1:
      var convert = mapToArray;
    case setTag$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
function arrayPush$1(array, values) {
  var index2 = -1, length = values.length, offset2 = array.length;
  while (++index2 < length) {
    array[offset2 + index2] = values[index2];
  }
  return array;
}
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$4(object) ? result : arrayPush$1(result, symbolsFunc(object));
}
function arrayFilter(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$2 = Object.prototype;
var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
const getSymbols$1 = getSymbols;
function getAllKeys(object) {
  return baseGetAllKeys(object, keys$1, getSymbols$1);
}
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var DataView = getNative(root$2, "DataView");
const DataView$1 = DataView;
var Promise$1 = getNative(root$2, "Promise");
const Promise$2 = Promise$1;
var Set$1 = getNative(root$2, "Set");
const Set$2 = Set$1;
var WeakMap$1 = getNative(root$2, "WeakMap");
const WeakMap$2 = WeakMap$1;
var mapTag = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
var dataViewTag = "[object DataView]";
var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$2);
var getTag = baseGetTag;
if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag || Map$2 && getTag(new Map$2()) != mapTag || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag) {
  getTag = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
const getTag$1 = getTag;
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$4(object), othIsArr = isArray$4(other), objTag = objIsArr ? arrayTag : getTag$1(object), othTag = othIsArr ? arrayTag : getTag$1(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$2(object)) {
    if (!isBuffer$2(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$1());
    return objIsArr || isTypedArray$2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack$1());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack$1());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike$1(value) && !isObjectLike$1(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(object, source, matchData, customizer) {
  var index2 = matchData.length, length = index2, noCustomizer = !customizer;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index2--) {
    var data = matchData[index2];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index2 < length) {
    data = matchData[index2];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack$1();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
function isStrictComparable(value) {
  return value === value && !isObject$a(value);
}
function getMatchData(object) {
  var result = keys$1(object), length = result.length;
  while (length--) {
    var key = result[length], value = object[key];
    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray$4(value)) {
    return false;
  }
  var type2 = typeof value;
  if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol$1(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var FUNC_ERROR_TEXT$1 = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match5, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match5);
  });
  return result;
});
const stringToPath$1 = stringToPath;
var INFINITY$2 = 1 / 0;
var symbolProto = Symbol$3 ? Symbol$3.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString$1(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$4(value)) {
    return arrayMap$2(value, baseToString$1) + "";
  }
  if (isSymbol$1(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$2 ? "-0" : result;
}
function toString$2(value) {
  return value == null ? "" : baseToString$1(value);
}
function castPath$4(value, object) {
  if (isArray$4(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath$1(toString$2(value));
}
var INFINITY$1 = 1 / 0;
function toKey$2(value) {
  if (typeof value == "string" || isSymbol$1(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
function baseGet$2(object, path) {
  path = castPath$4(path, object);
  var index2 = 0, length = path.length;
  while (object != null && index2 < length) {
    object = object[toKey$2(path[index2++])];
  }
  return index2 && index2 == length ? object : void 0;
}
function get$3(object, path, defaultValue4) {
  var result = object == null ? void 0 : baseGet$2(object, path);
  return result === void 0 ? defaultValue4 : result;
}
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
function hasPath(object, path, hasFunc) {
  path = castPath$4(path, object);
  var index2 = -1, length = path.length, result = false;
  while (++index2 < length) {
    var key = toKey$2(path[index2]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index2 != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex$2(key, length) && (isArray$4(object) || isArguments$3(object));
}
function hasIn$1(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey$2(path), srcValue);
  }
  return function(object) {
    var objValue = get$3(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn$1(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
function basePropertyDeep(path) {
  return function(object) {
    return baseGet$2(object, path);
  };
}
function property(path) {
  return isKey(path) ? baseProperty(toKey$2(path)) : basePropertyDeep(path);
}
function baseIteratee$2(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity$2;
  }
  if (typeof value == "object") {
    return isArray$4(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
function baseMap(collection, iteratee) {
  var index2 = -1, result = isArrayLike$2(collection) ? Array(collection.length) : [];
  baseEach$1(collection, function(value, key, collection2) {
    result[++index2] = iteratee(value, key, collection2);
  });
  return result;
}
function map$1(collection, iteratee) {
  var func = isArray$4(collection) ? arrayMap$2 : baseMap;
  return func(collection, baseIteratee$2(iteratee));
}
var BlockSwatches = function BlockSwatches2(_ref) {
  var colors2 = _ref.colors, onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover;
  var styles2 = _default$a({
    "default": {
      swatches: {
        marginRight: "-10px"
      },
      swatch: {
        width: "22px",
        height: "22px",
        float: "left",
        marginRight: "10px",
        marginBottom: "10px",
        borderRadius: "4px"
      },
      clear: {
        clear: "both"
      }
    }
  });
  return React.createElement(
    "div",
    { style: styles2.swatches },
    map$1(colors2, function(c2) {
      return React.createElement(Swatch$1, {
        key: c2,
        color: c2,
        style: styles2.swatch,
        onClick,
        onHover: onSwatchHover,
        focusStyle: {
          boxShadow: "0 0 4px " + c2
        }
      });
    }),
    React.createElement("div", { style: styles2.clear })
  );
};
var Block = function Block2(_ref) {
  var onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, hex = _ref.hex, colors2 = _ref.colors, width = _ref.width, triangle = _ref.triangle, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var transparent = hex === "transparent";
  var handleChange = function handleChange2(hexCode, e2) {
    isValidHex(hexCode) && onChange({
      hex: hexCode,
      source: "hex"
    }, e2);
  };
  var styles2 = _default$a(merge$4({
    "default": {
      card: {
        width,
        background: "#fff",
        boxShadow: "0 1px rgba(0,0,0,.1)",
        borderRadius: "6px",
        position: "relative"
      },
      head: {
        height: "110px",
        background: hex,
        borderRadius: "6px 6px 0 0",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        position: "relative"
      },
      body: {
        padding: "10px"
      },
      label: {
        fontSize: "18px",
        color: getContrastingColor(hex),
        position: "relative"
      },
      triangle: {
        width: "0px",
        height: "0px",
        borderStyle: "solid",
        borderWidth: "0 10px 10px 10px",
        borderColor: "transparent transparent " + hex + " transparent",
        position: "absolute",
        top: "-10px",
        left: "50%",
        marginLeft: "-10px"
      },
      input: {
        width: "100%",
        fontSize: "12px",
        color: "#666",
        border: "0px",
        outline: "none",
        height: "22px",
        boxShadow: "inset 0 0 0 1px #ddd",
        borderRadius: "4px",
        padding: "0 7px",
        boxSizing: "border-box"
      }
    },
    "hide-triangle": {
      triangle: {
        display: "none"
      }
    }
  }, passedStyles), { "hide-triangle": triangle === "hide" });
  return React.createElement(
    "div",
    { style: styles2.card, className: "block-picker " + className },
    React.createElement("div", { style: styles2.triangle }),
    React.createElement(
      "div",
      { style: styles2.head },
      transparent && React.createElement(Checkboard, { borderRadius: "6px 6px 0 0" }),
      React.createElement(
        "div",
        { style: styles2.label },
        hex
      )
    ),
    React.createElement(
      "div",
      { style: styles2.body },
      React.createElement(BlockSwatches, { colors: colors2, onClick: handleChange, onSwatchHover }),
      React.createElement(EditableInput, {
        style: { input: styles2.input },
        value: hex,
        onChange: handleChange
      })
    )
  );
};
Block.propTypes = {
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  colors: PropTypes.arrayOf(PropTypes.string),
  triangle: PropTypes.oneOf(["top", "hide"]),
  styles: PropTypes.object
};
Block.defaultProps = {
  width: 170,
  colors: ["#D9E3F0", "#F47373", "#697689", "#37D67A", "#2CCCE4", "#555555", "#dce775", "#ff8a65", "#ba68c8"],
  triangle: "top",
  styles: {}
};
ColorWrap(Block);
var red = { "50": "#ffebee", "100": "#ffcdd2", "200": "#ef9a9a", "300": "#e57373", "400": "#ef5350", "500": "#f44336", "600": "#e53935", "700": "#d32f2f", "800": "#c62828", "900": "#b71c1c", "a100": "#ff8a80", "a200": "#ff5252", "a400": "#ff1744", "a700": "#d50000" };
var pink = { "50": "#fce4ec", "100": "#f8bbd0", "200": "#f48fb1", "300": "#f06292", "400": "#ec407a", "500": "#e91e63", "600": "#d81b60", "700": "#c2185b", "800": "#ad1457", "900": "#880e4f", "a100": "#ff80ab", "a200": "#ff4081", "a400": "#f50057", "a700": "#c51162" };
var purple = { "50": "#f3e5f5", "100": "#e1bee7", "200": "#ce93d8", "300": "#ba68c8", "400": "#ab47bc", "500": "#9c27b0", "600": "#8e24aa", "700": "#7b1fa2", "800": "#6a1b9a", "900": "#4a148c", "a100": "#ea80fc", "a200": "#e040fb", "a400": "#d500f9", "a700": "#aa00ff" };
var deepPurple = { "50": "#ede7f6", "100": "#d1c4e9", "200": "#b39ddb", "300": "#9575cd", "400": "#7e57c2", "500": "#673ab7", "600": "#5e35b1", "700": "#512da8", "800": "#4527a0", "900": "#311b92", "a100": "#b388ff", "a200": "#7c4dff", "a400": "#651fff", "a700": "#6200ea" };
var indigo = { "50": "#e8eaf6", "100": "#c5cae9", "200": "#9fa8da", "300": "#7986cb", "400": "#5c6bc0", "500": "#3f51b5", "600": "#3949ab", "700": "#303f9f", "800": "#283593", "900": "#1a237e", "a100": "#8c9eff", "a200": "#536dfe", "a400": "#3d5afe", "a700": "#304ffe" };
var blue = { "50": "#e3f2fd", "100": "#bbdefb", "200": "#90caf9", "300": "#64b5f6", "400": "#42a5f5", "500": "#2196f3", "600": "#1e88e5", "700": "#1976d2", "800": "#1565c0", "900": "#0d47a1", "a100": "#82b1ff", "a200": "#448aff", "a400": "#2979ff", "a700": "#2962ff" };
var lightBlue = { "50": "#e1f5fe", "100": "#b3e5fc", "200": "#81d4fa", "300": "#4fc3f7", "400": "#29b6f6", "500": "#03a9f4", "600": "#039be5", "700": "#0288d1", "800": "#0277bd", "900": "#01579b", "a100": "#80d8ff", "a200": "#40c4ff", "a400": "#00b0ff", "a700": "#0091ea" };
var cyan = { "50": "#e0f7fa", "100": "#b2ebf2", "200": "#80deea", "300": "#4dd0e1", "400": "#26c6da", "500": "#00bcd4", "600": "#00acc1", "700": "#0097a7", "800": "#00838f", "900": "#006064", "a100": "#84ffff", "a200": "#18ffff", "a400": "#00e5ff", "a700": "#00b8d4" };
var teal = { "50": "#e0f2f1", "100": "#b2dfdb", "200": "#80cbc4", "300": "#4db6ac", "400": "#26a69a", "500": "#009688", "600": "#00897b", "700": "#00796b", "800": "#00695c", "900": "#004d40", "a100": "#a7ffeb", "a200": "#64ffda", "a400": "#1de9b6", "a700": "#00bfa5" };
var green = { "50": "#e8f5e9", "100": "#c8e6c9", "200": "#a5d6a7", "300": "#81c784", "400": "#66bb6a", "500": "#4caf50", "600": "#43a047", "700": "#388e3c", "800": "#2e7d32", "900": "#1b5e20", "a100": "#b9f6ca", "a200": "#69f0ae", "a400": "#00e676", "a700": "#00c853" };
var lightGreen = { "50": "#f1f8e9", "100": "#dcedc8", "200": "#c5e1a5", "300": "#aed581", "400": "#9ccc65", "500": "#8bc34a", "600": "#7cb342", "700": "#689f38", "800": "#558b2f", "900": "#33691e", "a100": "#ccff90", "a200": "#b2ff59", "a400": "#76ff03", "a700": "#64dd17" };
var lime = { "50": "#f9fbe7", "100": "#f0f4c3", "200": "#e6ee9c", "300": "#dce775", "400": "#d4e157", "500": "#cddc39", "600": "#c0ca33", "700": "#afb42b", "800": "#9e9d24", "900": "#827717", "a100": "#f4ff81", "a200": "#eeff41", "a400": "#c6ff00", "a700": "#aeea00" };
var yellow = { "50": "#fffde7", "100": "#fff9c4", "200": "#fff59d", "300": "#fff176", "400": "#ffee58", "500": "#ffeb3b", "600": "#fdd835", "700": "#fbc02d", "800": "#f9a825", "900": "#f57f17", "a100": "#ffff8d", "a200": "#ffff00", "a400": "#ffea00", "a700": "#ffd600" };
var amber = { "50": "#fff8e1", "100": "#ffecb3", "200": "#ffe082", "300": "#ffd54f", "400": "#ffca28", "500": "#ffc107", "600": "#ffb300", "700": "#ffa000", "800": "#ff8f00", "900": "#ff6f00", "a100": "#ffe57f", "a200": "#ffd740", "a400": "#ffc400", "a700": "#ffab00" };
var orange = { "50": "#fff3e0", "100": "#ffe0b2", "200": "#ffcc80", "300": "#ffb74d", "400": "#ffa726", "500": "#ff9800", "600": "#fb8c00", "700": "#f57c00", "800": "#ef6c00", "900": "#e65100", "a100": "#ffd180", "a200": "#ffab40", "a400": "#ff9100", "a700": "#ff6d00" };
var deepOrange = { "50": "#fbe9e7", "100": "#ffccbc", "200": "#ffab91", "300": "#ff8a65", "400": "#ff7043", "500": "#ff5722", "600": "#f4511e", "700": "#e64a19", "800": "#d84315", "900": "#bf360c", "a100": "#ff9e80", "a200": "#ff6e40", "a400": "#ff3d00", "a700": "#dd2c00" };
var brown = { "50": "#efebe9", "100": "#d7ccc8", "200": "#bcaaa4", "300": "#a1887f", "400": "#8d6e63", "500": "#795548", "600": "#6d4c41", "700": "#5d4037", "800": "#4e342e", "900": "#3e2723" };
var blueGrey = { "50": "#eceff1", "100": "#cfd8dc", "200": "#b0bec5", "300": "#90a4ae", "400": "#78909c", "500": "#607d8b", "600": "#546e7a", "700": "#455a64", "800": "#37474f", "900": "#263238" };
var CircleSwatch = function CircleSwatch2(_ref) {
  var color2 = _ref.color, onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover, hover3 = _ref.hover, active3 = _ref.active, circleSize = _ref.circleSize, circleSpacing = _ref.circleSpacing;
  var styles2 = _default$a({
    "default": {
      swatch: {
        width: circleSize,
        height: circleSize,
        marginRight: circleSpacing,
        marginBottom: circleSpacing,
        transform: "scale(1)",
        transition: "100ms transform ease"
      },
      Swatch: {
        borderRadius: "50%",
        background: "transparent",
        boxShadow: "inset 0 0 0 " + (circleSize / 2 + 1) + "px " + color2,
        transition: "100ms box-shadow ease"
      }
    },
    "hover": {
      swatch: {
        transform: "scale(1.2)"
      }
    },
    "active": {
      Swatch: {
        boxShadow: "inset 0 0 0 3px " + color2
      }
    }
  }, { hover: hover3, active: active3 });
  return React.createElement(
    "div",
    { style: styles2.swatch },
    React.createElement(Swatch$1, {
      style: styles2.Swatch,
      color: color2,
      onClick,
      onHover: onSwatchHover,
      focusStyle: { boxShadow: styles2.Swatch.boxShadow + ", 0 0 5px " + color2 }
    })
  );
};
CircleSwatch.defaultProps = {
  circleSize: 28,
  circleSpacing: 14
};
const CircleSwatch$1 = handleHover(CircleSwatch);
var Circle = function Circle2(_ref) {
  var width = _ref.width, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, colors2 = _ref.colors, hex = _ref.hex, circleSize = _ref.circleSize, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, circleSpacing = _ref.circleSpacing, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = _default$a(merge$4({
    "default": {
      card: {
        width,
        display: "flex",
        flexWrap: "wrap",
        marginRight: -circleSpacing,
        marginBottom: -circleSpacing
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(hexCode, e2) {
    return onChange({ hex: hexCode, source: "hex" }, e2);
  };
  return React.createElement(
    "div",
    { style: styles2.card, className: "circle-picker " + className },
    map$1(colors2, function(c2) {
      return React.createElement(CircleSwatch$1, {
        key: c2,
        color: c2,
        onClick: handleChange,
        onSwatchHover,
        active: hex === c2.toLowerCase(),
        circleSize,
        circleSpacing
      });
    })
  );
};
Circle.propTypes = {
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  circleSize: PropTypes.number,
  circleSpacing: PropTypes.number,
  styles: PropTypes.object
};
Circle.defaultProps = {
  width: 252,
  circleSize: 28,
  circleSpacing: 14,
  colors: [red["500"], pink["500"], purple["500"], deepPurple["500"], indigo["500"], blue["500"], lightBlue["500"], cyan["500"], teal["500"], green["500"], lightGreen["500"], lime["500"], yellow["500"], amber["500"], orange["500"], deepOrange["500"], brown["500"], blueGrey["500"]],
  styles: {}
};
ColorWrap(Circle);
function isUndefined$1(value) {
  return value === void 0;
}
var UnfoldMoreHorizontalIcon = {};
Object.defineProperty(UnfoldMoreHorizontalIcon, "__esModule", {
  value: true
});
var _extends$5 = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _react$1 = reactExports;
var _react2$1 = _interopRequireDefault$9(_react$1);
function _interopRequireDefault$9(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _objectWithoutProperties$1(obj, keys2) {
  var target = {};
  for (var i2 in obj) {
    if (keys2.indexOf(i2) >= 0)
      continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i2))
      continue;
    target[i2] = obj[i2];
  }
  return target;
}
var DEFAULT_SIZE$1 = 24;
var _default$9 = UnfoldMoreHorizontalIcon.default = function(_ref) {
  var _ref$fill = _ref.fill, fill = _ref$fill === void 0 ? "currentColor" : _ref$fill, _ref$width = _ref.width, width = _ref$width === void 0 ? DEFAULT_SIZE$1 : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? DEFAULT_SIZE$1 : _ref$height, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style, props = _objectWithoutProperties$1(_ref, ["fill", "width", "height", "style"]);
  return _react2$1.default.createElement(
    "svg",
    _extends$5({
      viewBox: "0 0 " + DEFAULT_SIZE$1 + " " + DEFAULT_SIZE$1,
      style: _extends$5({ fill, width, height }, style)
    }, props),
    _react2$1.default.createElement("path", { d: "M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z" })
  );
};
var _createClass$1 = function() {
  function defineProperties(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$1(self2, call2) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var ChromeFields = function(_React$Component) {
  _inherits$1(ChromeFields2, _React$Component);
  function ChromeFields2(props) {
    _classCallCheck$1(this, ChromeFields2);
    var _this = _possibleConstructorReturn$1(this, (ChromeFields2.__proto__ || Object.getPrototypeOf(ChromeFields2)).call(this));
    _this.toggleViews = function() {
      if (_this.state.view === "hex") {
        _this.setState({ view: "rgb" });
      } else if (_this.state.view === "rgb") {
        _this.setState({ view: "hsl" });
      } else if (_this.state.view === "hsl") {
        if (_this.props.hsl.a === 1) {
          _this.setState({ view: "hex" });
        } else {
          _this.setState({ view: "rgb" });
        }
      }
    };
    _this.handleChange = function(data, e2) {
      if (data.hex) {
        isValidHex(data.hex) && _this.props.onChange({
          hex: data.hex,
          source: "hex"
        }, e2);
      } else if (data.r || data.g || data.b) {
        _this.props.onChange({
          r: data.r || _this.props.rgb.r,
          g: data.g || _this.props.rgb.g,
          b: data.b || _this.props.rgb.b,
          source: "rgb"
        }, e2);
      } else if (data.a) {
        if (data.a < 0) {
          data.a = 0;
        } else if (data.a > 1) {
          data.a = 1;
        }
        _this.props.onChange({
          h: _this.props.hsl.h,
          s: _this.props.hsl.s,
          l: _this.props.hsl.l,
          a: Math.round(data.a * 100) / 100,
          source: "rgb"
        }, e2);
      } else if (data.h || data.s || data.l) {
        if (typeof data.s === "string" && data.s.includes("%")) {
          data.s = data.s.replace("%", "");
        }
        if (typeof data.l === "string" && data.l.includes("%")) {
          data.l = data.l.replace("%", "");
        }
        if (data.s == 1) {
          data.s = 0.01;
        } else if (data.l == 1) {
          data.l = 0.01;
        }
        _this.props.onChange({
          h: data.h || _this.props.hsl.h,
          s: Number(!isUndefined$1(data.s) ? data.s : _this.props.hsl.s),
          l: Number(!isUndefined$1(data.l) ? data.l : _this.props.hsl.l),
          source: "hsl"
        }, e2);
      }
    };
    _this.showHighlight = function(e2) {
      e2.currentTarget.style.background = "#eee";
    };
    _this.hideHighlight = function(e2) {
      e2.currentTarget.style.background = "transparent";
    };
    if (props.hsl.a !== 1 && props.view === "hex") {
      _this.state = {
        view: "rgb"
      };
    } else {
      _this.state = {
        view: props.view
      };
    }
    return _this;
  }
  _createClass$1(ChromeFields2, [{
    key: "render",
    value: function render3() {
      var _this2 = this;
      var styles2 = _default$a({
        "default": {
          wrap: {
            paddingTop: "16px",
            display: "flex"
          },
          fields: {
            flex: "1",
            display: "flex",
            marginLeft: "-6px"
          },
          field: {
            paddingLeft: "6px",
            width: "100%"
          },
          alpha: {
            paddingLeft: "6px",
            width: "100%"
          },
          toggle: {
            width: "32px",
            textAlign: "right",
            position: "relative"
          },
          icon: {
            marginRight: "-4px",
            marginTop: "12px",
            cursor: "pointer",
            position: "relative"
          },
          iconHighlight: {
            position: "absolute",
            width: "24px",
            height: "28px",
            background: "#eee",
            borderRadius: "4px",
            top: "10px",
            left: "12px",
            display: "none"
          },
          input: {
            fontSize: "11px",
            color: "#333",
            width: "100%",
            borderRadius: "2px",
            border: "none",
            boxShadow: "inset 0 0 0 1px #dadada",
            height: "21px",
            textAlign: "center"
          },
          label: {
            textTransform: "uppercase",
            fontSize: "11px",
            lineHeight: "11px",
            color: "#969696",
            textAlign: "center",
            display: "block",
            marginTop: "12px"
          },
          svg: {
            fill: "#333",
            width: "24px",
            height: "24px",
            border: "1px transparent solid",
            borderRadius: "5px"
          }
        },
        "disableAlpha": {
          alpha: {
            display: "none"
          }
        }
      }, this.props, this.state);
      var fields = void 0;
      if (this.state.view === "hex") {
        fields = React.createElement(
          "div",
          { style: styles2.fields, className: "flexbox-fix" },
          React.createElement(
            "div",
            { style: styles2.field },
            React.createElement(EditableInput, {
              style: { input: styles2.input, label: styles2.label },
              label: "hex",
              value: this.props.hex,
              onChange: this.handleChange
            })
          )
        );
      } else if (this.state.view === "rgb") {
        fields = React.createElement(
          "div",
          { style: styles2.fields, className: "flexbox-fix" },
          React.createElement(
            "div",
            { style: styles2.field },
            React.createElement(EditableInput, {
              style: { input: styles2.input, label: styles2.label },
              label: "r",
              value: this.props.rgb.r,
              onChange: this.handleChange
            })
          ),
          React.createElement(
            "div",
            { style: styles2.field },
            React.createElement(EditableInput, {
              style: { input: styles2.input, label: styles2.label },
              label: "g",
              value: this.props.rgb.g,
              onChange: this.handleChange
            })
          ),
          React.createElement(
            "div",
            { style: styles2.field },
            React.createElement(EditableInput, {
              style: { input: styles2.input, label: styles2.label },
              label: "b",
              value: this.props.rgb.b,
              onChange: this.handleChange
            })
          ),
          React.createElement(
            "div",
            { style: styles2.alpha },
            React.createElement(EditableInput, {
              style: { input: styles2.input, label: styles2.label },
              label: "a",
              value: this.props.rgb.a,
              arrowOffset: 0.01,
              onChange: this.handleChange
            })
          )
        );
      } else if (this.state.view === "hsl") {
        fields = React.createElement(
          "div",
          { style: styles2.fields, className: "flexbox-fix" },
          React.createElement(
            "div",
            { style: styles2.field },
            React.createElement(EditableInput, {
              style: { input: styles2.input, label: styles2.label },
              label: "h",
              value: Math.round(this.props.hsl.h),
              onChange: this.handleChange
            })
          ),
          React.createElement(
            "div",
            { style: styles2.field },
            React.createElement(EditableInput, {
              style: { input: styles2.input, label: styles2.label },
              label: "s",
              value: Math.round(this.props.hsl.s * 100) + "%",
              onChange: this.handleChange
            })
          ),
          React.createElement(
            "div",
            { style: styles2.field },
            React.createElement(EditableInput, {
              style: { input: styles2.input, label: styles2.label },
              label: "l",
              value: Math.round(this.props.hsl.l * 100) + "%",
              onChange: this.handleChange
            })
          ),
          React.createElement(
            "div",
            { style: styles2.alpha },
            React.createElement(EditableInput, {
              style: { input: styles2.input, label: styles2.label },
              label: "a",
              value: this.props.hsl.a,
              arrowOffset: 0.01,
              onChange: this.handleChange
            })
          )
        );
      }
      return React.createElement(
        "div",
        { style: styles2.wrap, className: "flexbox-fix" },
        fields,
        React.createElement(
          "div",
          { style: styles2.toggle },
          React.createElement(
            "div",
            { style: styles2.icon, onClick: this.toggleViews, ref: function ref(icon) {
              return _this2.icon = icon;
            } },
            React.createElement(_default$9, {
              style: styles2.svg,
              onMouseOver: this.showHighlight,
              onMouseEnter: this.showHighlight,
              onMouseOut: this.hideHighlight
            })
          )
        )
      );
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, state) {
      if (nextProps.hsl.a !== 1 && state.view === "hex") {
        return { view: "rgb" };
      }
      return null;
    }
  }]);
  return ChromeFields2;
}(React.Component);
ChromeFields.defaultProps = {
  view: "hex"
};
var ChromePointer = function ChromePointer2() {
  var styles2 = _default$a({
    "default": {
      picker: {
        width: "12px",
        height: "12px",
        borderRadius: "6px",
        transform: "translate(-6px, -1px)",
        backgroundColor: "rgb(248, 248, 248)",
        boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
      }
    }
  });
  return React.createElement("div", { style: styles2.picker });
};
var ChromePointerCircle = function ChromePointerCircle2() {
  var styles2 = _default$a({
    "default": {
      picker: {
        width: "12px",
        height: "12px",
        borderRadius: "6px",
        boxShadow: "inset 0 0 0 1px #fff",
        transform: "translate(-6px, -6px)"
      }
    }
  });
  return React.createElement("div", { style: styles2.picker });
};
var Chrome = function Chrome2(_ref) {
  var width = _ref.width, onChange = _ref.onChange, disableAlpha = _ref.disableAlpha, rgb2 = _ref.rgb, hsl2 = _ref.hsl, hsv = _ref.hsv, hex = _ref.hex, renderers = _ref.renderers, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className, defaultView = _ref.defaultView;
  var styles2 = _default$a(merge$4({
    "default": {
      picker: {
        width,
        background: "#fff",
        borderRadius: "2px",
        boxShadow: "0 0 2px rgba(0,0,0,.3), 0 4px 8px rgba(0,0,0,.3)",
        boxSizing: "initial",
        fontFamily: "Menlo"
      },
      saturation: {
        width: "100%",
        paddingBottom: "55%",
        position: "relative",
        borderRadius: "2px 2px 0 0",
        overflow: "hidden"
      },
      Saturation: {
        radius: "2px 2px 0 0"
      },
      body: {
        padding: "16px 16px 12px"
      },
      controls: {
        display: "flex"
      },
      color: {
        width: "32px"
      },
      swatch: {
        marginTop: "6px",
        width: "16px",
        height: "16px",
        borderRadius: "8px",
        position: "relative",
        overflow: "hidden"
      },
      active: {
        absolute: "0px 0px 0px 0px",
        borderRadius: "8px",
        boxShadow: "inset 0 0 0 1px rgba(0,0,0,.1)",
        background: "rgba(" + rgb2.r + ", " + rgb2.g + ", " + rgb2.b + ", " + rgb2.a + ")",
        zIndex: "2"
      },
      toggles: {
        flex: "1"
      },
      hue: {
        height: "10px",
        position: "relative",
        marginBottom: "8px"
      },
      Hue: {
        radius: "2px"
      },
      alpha: {
        height: "10px",
        position: "relative"
      },
      Alpha: {
        radius: "2px"
      }
    },
    "disableAlpha": {
      color: {
        width: "22px"
      },
      alpha: {
        display: "none"
      },
      hue: {
        marginBottom: "0px"
      },
      swatch: {
        width: "10px",
        height: "10px",
        marginTop: "0px"
      }
    }
  }, passedStyles), { disableAlpha });
  return React.createElement(
    "div",
    { style: styles2.picker, className: "chrome-picker " + className },
    React.createElement(
      "div",
      { style: styles2.saturation },
      React.createElement(Saturation, {
        style: styles2.Saturation,
        hsl: hsl2,
        hsv,
        pointer: ChromePointerCircle,
        onChange
      })
    ),
    React.createElement(
      "div",
      { style: styles2.body },
      React.createElement(
        "div",
        { style: styles2.controls, className: "flexbox-fix" },
        React.createElement(
          "div",
          { style: styles2.color },
          React.createElement(
            "div",
            { style: styles2.swatch },
            React.createElement("div", { style: styles2.active }),
            React.createElement(Checkboard, { renderers })
          )
        ),
        React.createElement(
          "div",
          { style: styles2.toggles },
          React.createElement(
            "div",
            { style: styles2.hue },
            React.createElement(Hue, {
              style: styles2.Hue,
              hsl: hsl2,
              pointer: ChromePointer,
              onChange
            })
          ),
          React.createElement(
            "div",
            { style: styles2.alpha },
            React.createElement(Alpha, {
              style: styles2.Alpha,
              rgb: rgb2,
              hsl: hsl2,
              pointer: ChromePointer,
              renderers,
              onChange
            })
          )
        )
      ),
      React.createElement(ChromeFields, {
        rgb: rgb2,
        hsl: hsl2,
        hex,
        view: defaultView,
        onChange,
        disableAlpha
      })
    )
  );
};
Chrome.propTypes = {
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  disableAlpha: PropTypes.bool,
  styles: PropTypes.object,
  defaultView: PropTypes.oneOf(["hex", "rgb", "hsl"])
};
Chrome.defaultProps = {
  width: 225,
  disableAlpha: false,
  styles: {}
};
ColorWrap(Chrome);
var CompactColor = function CompactColor2(_ref) {
  var color2 = _ref.color, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, onSwatchHover = _ref.onSwatchHover, active3 = _ref.active;
  var styles2 = _default$a({
    "default": {
      color: {
        background: color2,
        width: "15px",
        height: "15px",
        float: "left",
        marginRight: "5px",
        marginBottom: "5px",
        position: "relative",
        cursor: "pointer"
      },
      dot: {
        absolute: "5px 5px 5px 5px",
        background: getContrastingColor(color2),
        borderRadius: "50%",
        opacity: "0"
      }
    },
    "active": {
      dot: {
        opacity: "1"
      }
    },
    "color-#FFFFFF": {
      color: {
        boxShadow: "inset 0 0 0 1px #ddd"
      },
      dot: {
        background: "#000"
      }
    },
    "transparent": {
      dot: {
        background: "#000"
      }
    }
  }, { active: active3, "color-#FFFFFF": color2 === "#FFFFFF", "transparent": color2 === "transparent" });
  return React.createElement(
    Swatch$1,
    {
      style: styles2.color,
      color: color2,
      onClick,
      onHover: onSwatchHover,
      focusStyle: { boxShadow: "0 0 4px " + color2 }
    },
    React.createElement("div", { style: styles2.dot })
  );
};
var CompactFields = function CompactFields2(_ref) {
  var hex = _ref.hex, rgb2 = _ref.rgb, onChange = _ref.onChange;
  var styles2 = _default$a({
    "default": {
      fields: {
        display: "flex",
        paddingBottom: "6px",
        paddingRight: "5px",
        position: "relative"
      },
      active: {
        position: "absolute",
        top: "6px",
        left: "5px",
        height: "9px",
        width: "9px",
        background: hex
      },
      HEXwrap: {
        flex: "6",
        position: "relative"
      },
      HEXinput: {
        width: "80%",
        padding: "0px",
        paddingLeft: "20%",
        border: "none",
        outline: "none",
        background: "none",
        fontSize: "12px",
        color: "#333",
        height: "16px"
      },
      HEXlabel: {
        display: "none"
      },
      RGBwrap: {
        flex: "3",
        position: "relative"
      },
      RGBinput: {
        width: "70%",
        padding: "0px",
        paddingLeft: "30%",
        border: "none",
        outline: "none",
        background: "none",
        fontSize: "12px",
        color: "#333",
        height: "16px"
      },
      RGBlabel: {
        position: "absolute",
        top: "3px",
        left: "0px",
        lineHeight: "16px",
        textTransform: "uppercase",
        fontSize: "12px",
        color: "#999"
      }
    }
  });
  var handleChange = function handleChange2(data, e2) {
    if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb2.r,
        g: data.g || rgb2.g,
        b: data.b || rgb2.b,
        source: "rgb"
      }, e2);
    } else {
      onChange({
        hex: data.hex,
        source: "hex"
      }, e2);
    }
  };
  return React.createElement(
    "div",
    { style: styles2.fields, className: "flexbox-fix" },
    React.createElement("div", { style: styles2.active }),
    React.createElement(EditableInput, {
      style: { wrap: styles2.HEXwrap, input: styles2.HEXinput, label: styles2.HEXlabel },
      label: "hex",
      value: hex,
      onChange: handleChange
    }),
    React.createElement(EditableInput, {
      style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
      label: "r",
      value: rgb2.r,
      onChange: handleChange
    }),
    React.createElement(EditableInput, {
      style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
      label: "g",
      value: rgb2.g,
      onChange: handleChange
    }),
    React.createElement(EditableInput, {
      style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
      label: "b",
      value: rgb2.b,
      onChange: handleChange
    })
  );
};
var Compact = function Compact2(_ref) {
  var onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, colors2 = _ref.colors, hex = _ref.hex, rgb2 = _ref.rgb, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = _default$a(merge$4({
    "default": {
      Compact: {
        background: "#f6f6f6",
        radius: "4px"
      },
      compact: {
        paddingTop: "5px",
        paddingLeft: "5px",
        boxSizing: "initial",
        width: "240px"
      },
      clear: {
        clear: "both"
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(data, e2) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: "hex"
      }, e2);
    } else {
      onChange(data, e2);
    }
  };
  return React.createElement(
    Raised,
    { style: styles2.Compact, styles: passedStyles },
    React.createElement(
      "div",
      { style: styles2.compact, className: "compact-picker " + className },
      React.createElement(
        "div",
        null,
        map$1(colors2, function(c2) {
          return React.createElement(CompactColor, {
            key: c2,
            color: c2,
            active: c2.toLowerCase() === hex,
            onClick: handleChange,
            onSwatchHover
          });
        }),
        React.createElement("div", { style: styles2.clear })
      ),
      React.createElement(CompactFields, { hex, rgb: rgb2, onChange: handleChange })
    )
  );
};
Compact.propTypes = {
  colors: PropTypes.arrayOf(PropTypes.string),
  styles: PropTypes.object
};
Compact.defaultProps = {
  colors: ["#4D4D4D", "#999999", "#FFFFFF", "#F44E3B", "#FE9200", "#FCDC00", "#DBDF00", "#A4DD00", "#68CCCA", "#73D8FF", "#AEA1FF", "#FDA1FF", "#333333", "#808080", "#cccccc", "#D33115", "#E27300", "#FCC400", "#B0BC00", "#68BC00", "#16A5A5", "#009CE0", "#7B64FF", "#FA28FF", "#000000", "#666666", "#B3B3B3", "#9F0500", "#C45100", "#FB9E00", "#808900", "#194D33", "#0C797D", "#0062B1", "#653294", "#AB149E"],
  styles: {}
};
ColorWrap(Compact);
var GithubSwatch = function GithubSwatch2(_ref) {
  var hover3 = _ref.hover, color2 = _ref.color, onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover;
  var hoverSwatch = {
    position: "relative",
    zIndex: "2",
    outline: "2px solid #fff",
    boxShadow: "0 0 5px 2px rgba(0,0,0,0.25)"
  };
  var styles2 = _default$a({
    "default": {
      swatch: {
        width: "25px",
        height: "25px",
        fontSize: "0"
      }
    },
    "hover": {
      swatch: hoverSwatch
    }
  }, { hover: hover3 });
  return React.createElement(
    "div",
    { style: styles2.swatch },
    React.createElement(Swatch$1, {
      color: color2,
      onClick,
      onHover: onSwatchHover,
      focusStyle: hoverSwatch
    })
  );
};
const GithubSwatch$1 = handleHover(GithubSwatch);
var Github = function Github2(_ref) {
  var width = _ref.width, colors2 = _ref.colors, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, triangle = _ref.triangle, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = _default$a(merge$4({
    "default": {
      card: {
        width,
        background: "#fff",
        border: "1px solid rgba(0,0,0,0.2)",
        boxShadow: "0 3px 12px rgba(0,0,0,0.15)",
        borderRadius: "4px",
        position: "relative",
        padding: "5px",
        display: "flex",
        flexWrap: "wrap"
      },
      triangle: {
        position: "absolute",
        border: "7px solid transparent",
        borderBottomColor: "#fff"
      },
      triangleShadow: {
        position: "absolute",
        border: "8px solid transparent",
        borderBottomColor: "rgba(0,0,0,0.15)"
      }
    },
    "hide-triangle": {
      triangle: {
        display: "none"
      },
      triangleShadow: {
        display: "none"
      }
    },
    "top-left-triangle": {
      triangle: {
        top: "-14px",
        left: "10px"
      },
      triangleShadow: {
        top: "-16px",
        left: "9px"
      }
    },
    "top-right-triangle": {
      triangle: {
        top: "-14px",
        right: "10px"
      },
      triangleShadow: {
        top: "-16px",
        right: "9px"
      }
    },
    "bottom-left-triangle": {
      triangle: {
        top: "35px",
        left: "10px",
        transform: "rotate(180deg)"
      },
      triangleShadow: {
        top: "37px",
        left: "9px",
        transform: "rotate(180deg)"
      }
    },
    "bottom-right-triangle": {
      triangle: {
        top: "35px",
        right: "10px",
        transform: "rotate(180deg)"
      },
      triangleShadow: {
        top: "37px",
        right: "9px",
        transform: "rotate(180deg)"
      }
    }
  }, passedStyles), {
    "hide-triangle": triangle === "hide",
    "top-left-triangle": triangle === "top-left",
    "top-right-triangle": triangle === "top-right",
    "bottom-left-triangle": triangle === "bottom-left",
    "bottom-right-triangle": triangle === "bottom-right"
  });
  var handleChange = function handleChange2(hex, e2) {
    return onChange({ hex, source: "hex" }, e2);
  };
  return React.createElement(
    "div",
    { style: styles2.card, className: "github-picker " + className },
    React.createElement("div", { style: styles2.triangleShadow }),
    React.createElement("div", { style: styles2.triangle }),
    map$1(colors2, function(c2) {
      return React.createElement(GithubSwatch$1, {
        color: c2,
        key: c2,
        onClick: handleChange,
        onSwatchHover
      });
    })
  );
};
Github.propTypes = {
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  colors: PropTypes.arrayOf(PropTypes.string),
  triangle: PropTypes.oneOf(["hide", "top-left", "top-right", "bottom-left", "bottom-right"]),
  styles: PropTypes.object
};
Github.defaultProps = {
  width: 200,
  colors: ["#B80000", "#DB3E00", "#FCCB00", "#008B02", "#006B76", "#1273DE", "#004DCF", "#5300EB", "#EB9694", "#FAD0C3", "#FEF3BD", "#C1E1C5", "#BEDADC", "#C4DEF6", "#BED3F3", "#D4C4FB"],
  triangle: "top-left",
  styles: {}
};
ColorWrap(Github);
var SliderPointer$1 = function SliderPointer(_ref) {
  var direction = _ref.direction;
  var styles2 = _default$a({
    "default": {
      picker: {
        width: "18px",
        height: "18px",
        borderRadius: "50%",
        transform: "translate(-9px, -1px)",
        backgroundColor: "rgb(248, 248, 248)",
        boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
      }
    },
    "vertical": {
      picker: {
        transform: "translate(-3px, -9px)"
      }
    }
  }, { vertical: direction === "vertical" });
  return React.createElement("div", { style: styles2.picker });
};
var _extends$4 = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var HuePicker = function HuePicker2(_ref) {
  var width = _ref.width, height = _ref.height, onChange = _ref.onChange, hsl2 = _ref.hsl, direction = _ref.direction, pointer = _ref.pointer, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = _default$a(merge$4({
    "default": {
      picker: {
        position: "relative",
        width,
        height
      },
      hue: {
        radius: "2px"
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(data) {
    return onChange({ a: 1, h: data.h, l: 0.5, s: 1 });
  };
  return React.createElement(
    "div",
    { style: styles2.picker, className: "hue-picker " + className },
    React.createElement(Hue, _extends$4({}, styles2.hue, {
      hsl: hsl2,
      pointer,
      onChange: handleChange,
      direction
    }))
  );
};
HuePicker.propTypes = {
  styles: PropTypes.object
};
HuePicker.defaultProps = {
  width: "316px",
  height: "16px",
  direction: "horizontal",
  pointer: SliderPointer$1,
  styles: {}
};
ColorWrap(HuePicker);
var Material = function Material2(_ref) {
  var onChange = _ref.onChange, hex = _ref.hex, rgb2 = _ref.rgb, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = _default$a(merge$4({
    "default": {
      material: {
        width: "98px",
        height: "98px",
        padding: "16px",
        fontFamily: "Roboto"
      },
      HEXwrap: {
        position: "relative"
      },
      HEXinput: {
        width: "100%",
        marginTop: "12px",
        fontSize: "15px",
        color: "#333",
        padding: "0px",
        border: "0px",
        borderBottom: "2px solid " + hex,
        outline: "none",
        height: "30px"
      },
      HEXlabel: {
        position: "absolute",
        top: "0px",
        left: "0px",
        fontSize: "11px",
        color: "#999999",
        textTransform: "capitalize"
      },
      Hex: {
        style: {}
      },
      RGBwrap: {
        position: "relative"
      },
      RGBinput: {
        width: "100%",
        marginTop: "12px",
        fontSize: "15px",
        color: "#333",
        padding: "0px",
        border: "0px",
        borderBottom: "1px solid #eee",
        outline: "none",
        height: "30px"
      },
      RGBlabel: {
        position: "absolute",
        top: "0px",
        left: "0px",
        fontSize: "11px",
        color: "#999999",
        textTransform: "capitalize"
      },
      split: {
        display: "flex",
        marginRight: "-10px",
        paddingTop: "11px"
      },
      third: {
        flex: "1",
        paddingRight: "10px"
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(data, e2) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: "hex"
      }, e2);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb2.r,
        g: data.g || rgb2.g,
        b: data.b || rgb2.b,
        source: "rgb"
      }, e2);
    }
  };
  return React.createElement(
    Raised,
    { styles: passedStyles },
    React.createElement(
      "div",
      { style: styles2.material, className: "material-picker " + className },
      React.createElement(EditableInput, {
        style: { wrap: styles2.HEXwrap, input: styles2.HEXinput, label: styles2.HEXlabel },
        label: "hex",
        value: hex,
        onChange: handleChange
      }),
      React.createElement(
        "div",
        { style: styles2.split, className: "flexbox-fix" },
        React.createElement(
          "div",
          { style: styles2.third },
          React.createElement(EditableInput, {
            style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
            label: "r",
            value: rgb2.r,
            onChange: handleChange
          })
        ),
        React.createElement(
          "div",
          { style: styles2.third },
          React.createElement(EditableInput, {
            style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
            label: "g",
            value: rgb2.g,
            onChange: handleChange
          })
        ),
        React.createElement(
          "div",
          { style: styles2.third },
          React.createElement(EditableInput, {
            style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
            label: "b",
            value: rgb2.b,
            onChange: handleChange
          })
        )
      )
    )
  );
};
ColorWrap(Material);
var PhotoshopPicker = function PhotoshopPicker2(_ref) {
  var onChange = _ref.onChange, rgb2 = _ref.rgb, hsv = _ref.hsv, hex = _ref.hex;
  var styles2 = _default$a({
    "default": {
      fields: {
        paddingTop: "5px",
        paddingBottom: "9px",
        width: "80px",
        position: "relative"
      },
      divider: {
        height: "5px"
      },
      RGBwrap: {
        position: "relative"
      },
      RGBinput: {
        marginLeft: "40%",
        width: "40%",
        height: "18px",
        border: "1px solid #888888",
        boxShadow: "inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC",
        marginBottom: "5px",
        fontSize: "13px",
        paddingLeft: "3px",
        marginRight: "10px"
      },
      RGBlabel: {
        left: "0px",
        top: "0px",
        width: "34px",
        textTransform: "uppercase",
        fontSize: "13px",
        height: "18px",
        lineHeight: "22px",
        position: "absolute"
      },
      HEXwrap: {
        position: "relative"
      },
      HEXinput: {
        marginLeft: "20%",
        width: "80%",
        height: "18px",
        border: "1px solid #888888",
        boxShadow: "inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC",
        marginBottom: "6px",
        fontSize: "13px",
        paddingLeft: "3px"
      },
      HEXlabel: {
        position: "absolute",
        top: "0px",
        left: "0px",
        width: "14px",
        textTransform: "uppercase",
        fontSize: "13px",
        height: "18px",
        lineHeight: "22px"
      },
      fieldSymbols: {
        position: "absolute",
        top: "5px",
        right: "-7px",
        fontSize: "13px"
      },
      symbol: {
        height: "20px",
        lineHeight: "22px",
        paddingBottom: "7px"
      }
    }
  });
  var handleChange = function handleChange2(data, e2) {
    if (data["#"]) {
      isValidHex(data["#"]) && onChange({
        hex: data["#"],
        source: "hex"
      }, e2);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb2.r,
        g: data.g || rgb2.g,
        b: data.b || rgb2.b,
        source: "rgb"
      }, e2);
    } else if (data.h || data.s || data.v) {
      onChange({
        h: data.h || hsv.h,
        s: data.s || hsv.s,
        v: data.v || hsv.v,
        source: "hsv"
      }, e2);
    }
  };
  return React.createElement(
    "div",
    { style: styles2.fields },
    React.createElement(EditableInput, {
      style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
      label: "h",
      value: Math.round(hsv.h),
      onChange: handleChange
    }),
    React.createElement(EditableInput, {
      style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
      label: "s",
      value: Math.round(hsv.s * 100),
      onChange: handleChange
    }),
    React.createElement(EditableInput, {
      style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
      label: "v",
      value: Math.round(hsv.v * 100),
      onChange: handleChange
    }),
    React.createElement("div", { style: styles2.divider }),
    React.createElement(EditableInput, {
      style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
      label: "r",
      value: rgb2.r,
      onChange: handleChange
    }),
    React.createElement(EditableInput, {
      style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
      label: "g",
      value: rgb2.g,
      onChange: handleChange
    }),
    React.createElement(EditableInput, {
      style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
      label: "b",
      value: rgb2.b,
      onChange: handleChange
    }),
    React.createElement("div", { style: styles2.divider }),
    React.createElement(EditableInput, {
      style: { wrap: styles2.HEXwrap, input: styles2.HEXinput, label: styles2.HEXlabel },
      label: "#",
      value: hex.replace("#", ""),
      onChange: handleChange
    }),
    React.createElement(
      "div",
      { style: styles2.fieldSymbols },
      React.createElement(
        "div",
        { style: styles2.symbol },
        "°"
      ),
      React.createElement(
        "div",
        { style: styles2.symbol },
        "%"
      ),
      React.createElement(
        "div",
        { style: styles2.symbol },
        "%"
      )
    )
  );
};
var PhotoshopPointerCircle$1 = function PhotoshopPointerCircle(_ref) {
  var hsl2 = _ref.hsl;
  var styles2 = _default$a({
    "default": {
      picker: {
        width: "12px",
        height: "12px",
        borderRadius: "6px",
        boxShadow: "inset 0 0 0 1px #fff",
        transform: "translate(-6px, -6px)"
      }
    },
    "black-outline": {
      picker: {
        boxShadow: "inset 0 0 0 1px #000"
      }
    }
  }, { "black-outline": hsl2.l > 0.5 });
  return React.createElement("div", { style: styles2.picker });
};
var PhotoshopPointerCircle2 = function PhotoshopPointerCircle3() {
  var styles2 = _default$a({
    "default": {
      triangle: {
        width: 0,
        height: 0,
        borderStyle: "solid",
        borderWidth: "4px 0 4px 6px",
        borderColor: "transparent transparent transparent #fff",
        position: "absolute",
        top: "1px",
        left: "1px"
      },
      triangleBorder: {
        width: 0,
        height: 0,
        borderStyle: "solid",
        borderWidth: "5px 0 5px 8px",
        borderColor: "transparent transparent transparent #555"
      },
      left: {
        Extend: "triangleBorder",
        transform: "translate(-13px, -4px)"
      },
      leftInside: {
        Extend: "triangle",
        transform: "translate(-8px, -5px)"
      },
      right: {
        Extend: "triangleBorder",
        transform: "translate(20px, -14px) rotate(180deg)"
      },
      rightInside: {
        Extend: "triangle",
        transform: "translate(-8px, -5px)"
      }
    }
  });
  return React.createElement(
    "div",
    { style: styles2.pointer },
    React.createElement(
      "div",
      { style: styles2.left },
      React.createElement("div", { style: styles2.leftInside })
    ),
    React.createElement(
      "div",
      { style: styles2.right },
      React.createElement("div", { style: styles2.rightInside })
    )
  );
};
var PhotoshopButton = function PhotoshopButton2(_ref) {
  var onClick = _ref.onClick, label2 = _ref.label, children = _ref.children, active3 = _ref.active;
  var styles2 = _default$a({
    "default": {
      button: {
        backgroundImage: "linear-gradient(-180deg, #FFFFFF 0%, #E6E6E6 100%)",
        border: "1px solid #878787",
        borderRadius: "2px",
        height: "20px",
        boxShadow: "0 1px 0 0 #EAEAEA",
        fontSize: "14px",
        color: "#000",
        lineHeight: "20px",
        textAlign: "center",
        marginBottom: "10px",
        cursor: "pointer"
      }
    },
    "active": {
      button: {
        boxShadow: "0 0 0 1px #878787"
      }
    }
  }, { active: active3 });
  return React.createElement(
    "div",
    { style: styles2.button, onClick },
    label2 || children
  );
};
var PhotoshopPreviews = function PhotoshopPreviews2(_ref) {
  var rgb2 = _ref.rgb, currentColor = _ref.currentColor;
  var styles2 = _default$a({
    "default": {
      swatches: {
        border: "1px solid #B3B3B3",
        borderBottom: "1px solid #F0F0F0",
        marginBottom: "2px",
        marginTop: "1px"
      },
      new: {
        height: "34px",
        background: "rgb(" + rgb2.r + "," + rgb2.g + ", " + rgb2.b + ")",
        boxShadow: "inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 1px 0 #000"
      },
      current: {
        height: "34px",
        background: currentColor,
        boxShadow: "inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 -1px 0 #000"
      },
      label: {
        fontSize: "14px",
        color: "#000",
        textAlign: "center"
      }
    }
  });
  return React.createElement(
    "div",
    null,
    React.createElement(
      "div",
      { style: styles2.label },
      "new"
    ),
    React.createElement(
      "div",
      { style: styles2.swatches },
      React.createElement("div", { style: styles2.new }),
      React.createElement("div", { style: styles2.current })
    ),
    React.createElement(
      "div",
      { style: styles2.label },
      "current"
    )
  );
};
var _createClass = function() {
  function defineProperties(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn(self2, call2) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var Photoshop = function(_React$Component) {
  _inherits(Photoshop2, _React$Component);
  function Photoshop2(props) {
    _classCallCheck(this, Photoshop2);
    var _this = _possibleConstructorReturn(this, (Photoshop2.__proto__ || Object.getPrototypeOf(Photoshop2)).call(this));
    _this.state = {
      currentColor: props.hex
    };
    return _this;
  }
  _createClass(Photoshop2, [{
    key: "render",
    value: function render3() {
      var _props = this.props, _props$styles = _props.styles, passedStyles = _props$styles === void 0 ? {} : _props$styles, _props$className = _props.className, className = _props$className === void 0 ? "" : _props$className;
      var styles2 = _default$a(merge$4({
        "default": {
          picker: {
            background: "#DCDCDC",
            borderRadius: "4px",
            boxShadow: "0 0 0 1px rgba(0,0,0,.25), 0 8px 16px rgba(0,0,0,.15)",
            boxSizing: "initial",
            width: "513px"
          },
          head: {
            backgroundImage: "linear-gradient(-180deg, #F0F0F0 0%, #D4D4D4 100%)",
            borderBottom: "1px solid #B1B1B1",
            boxShadow: "inset 0 1px 0 0 rgba(255,255,255,.2), inset 0 -1px 0 0 rgba(0,0,0,.02)",
            height: "23px",
            lineHeight: "24px",
            borderRadius: "4px 4px 0 0",
            fontSize: "13px",
            color: "#4D4D4D",
            textAlign: "center"
          },
          body: {
            padding: "15px 15px 0",
            display: "flex"
          },
          saturation: {
            width: "256px",
            height: "256px",
            position: "relative",
            border: "2px solid #B3B3B3",
            borderBottom: "2px solid #F0F0F0",
            overflow: "hidden"
          },
          hue: {
            position: "relative",
            height: "256px",
            width: "19px",
            marginLeft: "10px",
            border: "2px solid #B3B3B3",
            borderBottom: "2px solid #F0F0F0"
          },
          controls: {
            width: "180px",
            marginLeft: "10px"
          },
          top: {
            display: "flex"
          },
          previews: {
            width: "60px"
          },
          actions: {
            flex: "1",
            marginLeft: "20px"
          }
        }
      }, passedStyles));
      return React.createElement(
        "div",
        { style: styles2.picker, className: "photoshop-picker " + className },
        React.createElement(
          "div",
          { style: styles2.head },
          this.props.header
        ),
        React.createElement(
          "div",
          { style: styles2.body, className: "flexbox-fix" },
          React.createElement(
            "div",
            { style: styles2.saturation },
            React.createElement(Saturation, {
              hsl: this.props.hsl,
              hsv: this.props.hsv,
              pointer: PhotoshopPointerCircle$1,
              onChange: this.props.onChange
            })
          ),
          React.createElement(
            "div",
            { style: styles2.hue },
            React.createElement(Hue, {
              direction: "vertical",
              hsl: this.props.hsl,
              pointer: PhotoshopPointerCircle2,
              onChange: this.props.onChange
            })
          ),
          React.createElement(
            "div",
            { style: styles2.controls },
            React.createElement(
              "div",
              { style: styles2.top, className: "flexbox-fix" },
              React.createElement(
                "div",
                { style: styles2.previews },
                React.createElement(PhotoshopPreviews, {
                  rgb: this.props.rgb,
                  currentColor: this.state.currentColor
                })
              ),
              React.createElement(
                "div",
                { style: styles2.actions },
                React.createElement(PhotoshopButton, { label: "OK", onClick: this.props.onAccept, active: true }),
                React.createElement(PhotoshopButton, { label: "Cancel", onClick: this.props.onCancel }),
                React.createElement(PhotoshopPicker, {
                  onChange: this.props.onChange,
                  rgb: this.props.rgb,
                  hsv: this.props.hsv,
                  hex: this.props.hex
                })
              )
            )
          )
        )
      );
    }
  }]);
  return Photoshop2;
}(React.Component);
Photoshop.propTypes = {
  header: PropTypes.string,
  styles: PropTypes.object
};
Photoshop.defaultProps = {
  header: "Color Picker",
  styles: {}
};
ColorWrap(Photoshop);
var SketchFields = function SketchFields2(_ref) {
  var onChange = _ref.onChange, rgb2 = _ref.rgb, hsl2 = _ref.hsl, hex = _ref.hex, disableAlpha = _ref.disableAlpha;
  var styles2 = _default$a({
    "default": {
      fields: {
        display: "flex",
        paddingTop: "4px"
      },
      single: {
        flex: "1",
        paddingLeft: "6px"
      },
      alpha: {
        flex: "1",
        paddingLeft: "6px"
      },
      double: {
        flex: "2"
      },
      input: {
        width: "80%",
        padding: "4px 10% 3px",
        border: "none",
        boxShadow: "inset 0 0 0 1px #ccc",
        fontSize: "11px"
      },
      label: {
        display: "block",
        textAlign: "center",
        fontSize: "11px",
        color: "#222",
        paddingTop: "3px",
        paddingBottom: "4px",
        textTransform: "capitalize"
      }
    },
    "disableAlpha": {
      alpha: {
        display: "none"
      }
    }
  }, { disableAlpha });
  var handleChange = function handleChange2(data, e2) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: "hex"
      }, e2);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb2.r,
        g: data.g || rgb2.g,
        b: data.b || rgb2.b,
        a: rgb2.a,
        source: "rgb"
      }, e2);
    } else if (data.a) {
      if (data.a < 0) {
        data.a = 0;
      } else if (data.a > 100) {
        data.a = 100;
      }
      data.a /= 100;
      onChange({
        h: hsl2.h,
        s: hsl2.s,
        l: hsl2.l,
        a: data.a,
        source: "rgb"
      }, e2);
    }
  };
  return React.createElement(
    "div",
    { style: styles2.fields, className: "flexbox-fix" },
    React.createElement(
      "div",
      { style: styles2.double },
      React.createElement(EditableInput, {
        style: { input: styles2.input, label: styles2.label },
        label: "hex",
        value: hex.replace("#", ""),
        onChange: handleChange
      })
    ),
    React.createElement(
      "div",
      { style: styles2.single },
      React.createElement(EditableInput, {
        style: { input: styles2.input, label: styles2.label },
        label: "r",
        value: rgb2.r,
        onChange: handleChange,
        dragLabel: "true",
        dragMax: "255"
      })
    ),
    React.createElement(
      "div",
      { style: styles2.single },
      React.createElement(EditableInput, {
        style: { input: styles2.input, label: styles2.label },
        label: "g",
        value: rgb2.g,
        onChange: handleChange,
        dragLabel: "true",
        dragMax: "255"
      })
    ),
    React.createElement(
      "div",
      { style: styles2.single },
      React.createElement(EditableInput, {
        style: { input: styles2.input, label: styles2.label },
        label: "b",
        value: rgb2.b,
        onChange: handleChange,
        dragLabel: "true",
        dragMax: "255"
      })
    ),
    React.createElement(
      "div",
      { style: styles2.alpha },
      React.createElement(EditableInput, {
        style: { input: styles2.input, label: styles2.label },
        label: "a",
        value: Math.round(rgb2.a * 100),
        onChange: handleChange,
        dragLabel: "true",
        dragMax: "100"
      })
    )
  );
};
var _extends$3 = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var SketchPresetColors = function SketchPresetColors2(_ref) {
  var colors2 = _ref.colors, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, onSwatchHover = _ref.onSwatchHover;
  var styles2 = _default$a({
    "default": {
      colors: {
        margin: "0 -10px",
        padding: "10px 0 0 10px",
        borderTop: "1px solid #eee",
        display: "flex",
        flexWrap: "wrap",
        position: "relative"
      },
      swatchWrap: {
        width: "16px",
        height: "16px",
        margin: "0 10px 10px 0"
      },
      swatch: {
        borderRadius: "3px",
        boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15)"
      }
    },
    "no-presets": {
      colors: {
        display: "none"
      }
    }
  }, {
    "no-presets": !colors2 || !colors2.length
  });
  var handleClick = function handleClick2(hex, e2) {
    onClick({
      hex,
      source: "hex"
    }, e2);
  };
  return React.createElement(
    "div",
    { style: styles2.colors, className: "flexbox-fix" },
    colors2.map(function(colorObjOrString) {
      var c2 = typeof colorObjOrString === "string" ? { color: colorObjOrString } : colorObjOrString;
      var key = "" + c2.color + (c2.title || "");
      return React.createElement(
        "div",
        { key, style: styles2.swatchWrap },
        React.createElement(Swatch$1, _extends$3({}, c2, {
          style: styles2.swatch,
          onClick: handleClick,
          onHover: onSwatchHover,
          focusStyle: {
            boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15), 0 0 4px " + c2.color
          }
        }))
      );
    })
  );
};
SketchPresetColors.propTypes = {
  colors: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.shape({
    color: PropTypes.string,
    title: PropTypes.string
  })])).isRequired
};
var _extends$2 = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var Sketch = function Sketch2(_ref) {
  var width = _ref.width, rgb2 = _ref.rgb, hex = _ref.hex, hsv = _ref.hsv, hsl2 = _ref.hsl, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, disableAlpha = _ref.disableAlpha, presetColors = _ref.presetColors, renderers = _ref.renderers, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = _default$a(merge$4({
    "default": _extends$2({
      picker: {
        width,
        padding: "10px 10px 0",
        boxSizing: "initial",
        background: "#fff",
        borderRadius: "4px",
        boxShadow: "0 0 0 1px rgba(0,0,0,.15), 0 8px 16px rgba(0,0,0,.15)"
      },
      saturation: {
        width: "100%",
        paddingBottom: "75%",
        position: "relative",
        overflow: "hidden"
      },
      Saturation: {
        radius: "3px",
        shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
      },
      controls: {
        display: "flex"
      },
      sliders: {
        padding: "4px 0",
        flex: "1"
      },
      color: {
        width: "24px",
        height: "24px",
        position: "relative",
        marginTop: "4px",
        marginLeft: "4px",
        borderRadius: "3px"
      },
      activeColor: {
        absolute: "0px 0px 0px 0px",
        borderRadius: "2px",
        background: "rgba(" + rgb2.r + "," + rgb2.g + "," + rgb2.b + "," + rgb2.a + ")",
        boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
      },
      hue: {
        position: "relative",
        height: "10px",
        overflow: "hidden"
      },
      Hue: {
        radius: "2px",
        shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
      },
      alpha: {
        position: "relative",
        height: "10px",
        marginTop: "4px",
        overflow: "hidden"
      },
      Alpha: {
        radius: "2px",
        shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
      }
    }, passedStyles),
    "disableAlpha": {
      color: {
        height: "10px"
      },
      hue: {
        height: "10px"
      },
      alpha: {
        display: "none"
      }
    }
  }, passedStyles), { disableAlpha });
  return React.createElement(
    "div",
    { style: styles2.picker, className: "sketch-picker " + className },
    React.createElement(
      "div",
      { style: styles2.saturation },
      React.createElement(Saturation, {
        style: styles2.Saturation,
        hsl: hsl2,
        hsv,
        onChange
      })
    ),
    React.createElement(
      "div",
      { style: styles2.controls, className: "flexbox-fix" },
      React.createElement(
        "div",
        { style: styles2.sliders },
        React.createElement(
          "div",
          { style: styles2.hue },
          React.createElement(Hue, {
            style: styles2.Hue,
            hsl: hsl2,
            onChange
          })
        ),
        React.createElement(
          "div",
          { style: styles2.alpha },
          React.createElement(Alpha, {
            style: styles2.Alpha,
            rgb: rgb2,
            hsl: hsl2,
            renderers,
            onChange
          })
        )
      ),
      React.createElement(
        "div",
        { style: styles2.color },
        React.createElement(Checkboard, null),
        React.createElement("div", { style: styles2.activeColor })
      )
    ),
    React.createElement(SketchFields, {
      rgb: rgb2,
      hsl: hsl2,
      hex,
      onChange,
      disableAlpha
    }),
    React.createElement(SketchPresetColors, {
      colors: presetColors,
      onClick: onChange,
      onSwatchHover
    })
  );
};
Sketch.propTypes = {
  disableAlpha: PropTypes.bool,
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  styles: PropTypes.object
};
Sketch.defaultProps = {
  disableAlpha: false,
  width: 200,
  styles: {},
  presetColors: ["#D0021B", "#F5A623", "#F8E71C", "#8B572A", "#7ED321", "#417505", "#BD10E0", "#9013FE", "#4A90E2", "#50E3C2", "#B8E986", "#000000", "#4A4A4A", "#9B9B9B", "#FFFFFF"]
};
ColorWrap(Sketch);
var SliderSwatch = function SliderSwatch2(_ref) {
  var hsl2 = _ref.hsl, offset2 = _ref.offset, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, active3 = _ref.active, first = _ref.first, last2 = _ref.last;
  var styles2 = _default$a({
    "default": {
      swatch: {
        height: "12px",
        background: "hsl(" + hsl2.h + ", 50%, " + offset2 * 100 + "%)",
        cursor: "pointer"
      }
    },
    "first": {
      swatch: {
        borderRadius: "2px 0 0 2px"
      }
    },
    "last": {
      swatch: {
        borderRadius: "0 2px 2px 0"
      }
    },
    "active": {
      swatch: {
        transform: "scaleY(1.8)",
        borderRadius: "3.6px/2px"
      }
    }
  }, { active: active3, first, last: last2 });
  var handleClick = function handleClick2(e2) {
    return onClick({
      h: hsl2.h,
      s: 0.5,
      l: offset2,
      source: "hsl"
    }, e2);
  };
  return React.createElement("div", { style: styles2.swatch, onClick: handleClick });
};
var SliderSwatches = function SliderSwatches2(_ref) {
  var onClick = _ref.onClick, hsl2 = _ref.hsl;
  var styles2 = _default$a({
    "default": {
      swatches: {
        marginTop: "20px"
      },
      swatch: {
        boxSizing: "border-box",
        width: "20%",
        paddingRight: "1px",
        float: "left"
      },
      clear: {
        clear: "both"
      }
    }
  });
  var epsilon = 0.1;
  return React.createElement(
    "div",
    { style: styles2.swatches },
    React.createElement(
      "div",
      { style: styles2.swatch },
      React.createElement(SliderSwatch, {
        hsl: hsl2,
        offset: ".80",
        active: Math.abs(hsl2.l - 0.8) < epsilon && Math.abs(hsl2.s - 0.5) < epsilon,
        onClick,
        first: true
      })
    ),
    React.createElement(
      "div",
      { style: styles2.swatch },
      React.createElement(SliderSwatch, {
        hsl: hsl2,
        offset: ".65",
        active: Math.abs(hsl2.l - 0.65) < epsilon && Math.abs(hsl2.s - 0.5) < epsilon,
        onClick
      })
    ),
    React.createElement(
      "div",
      { style: styles2.swatch },
      React.createElement(SliderSwatch, {
        hsl: hsl2,
        offset: ".50",
        active: Math.abs(hsl2.l - 0.5) < epsilon && Math.abs(hsl2.s - 0.5) < epsilon,
        onClick
      })
    ),
    React.createElement(
      "div",
      { style: styles2.swatch },
      React.createElement(SliderSwatch, {
        hsl: hsl2,
        offset: ".35",
        active: Math.abs(hsl2.l - 0.35) < epsilon && Math.abs(hsl2.s - 0.5) < epsilon,
        onClick
      })
    ),
    React.createElement(
      "div",
      { style: styles2.swatch },
      React.createElement(SliderSwatch, {
        hsl: hsl2,
        offset: ".20",
        active: Math.abs(hsl2.l - 0.2) < epsilon && Math.abs(hsl2.s - 0.5) < epsilon,
        onClick,
        last: true
      })
    ),
    React.createElement("div", { style: styles2.clear })
  );
};
var SliderPointer2 = function SliderPointer3() {
  var styles2 = _default$a({
    "default": {
      picker: {
        width: "14px",
        height: "14px",
        borderRadius: "6px",
        transform: "translate(-7px, -1px)",
        backgroundColor: "rgb(248, 248, 248)",
        boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
      }
    }
  });
  return React.createElement("div", { style: styles2.picker });
};
var Slider2 = function Slider3(_ref) {
  var hsl2 = _ref.hsl, onChange = _ref.onChange, pointer = _ref.pointer, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = _default$a(merge$4({
    "default": {
      hue: {
        height: "12px",
        position: "relative"
      },
      Hue: {
        radius: "2px"
      }
    }
  }, passedStyles));
  return React.createElement(
    "div",
    { style: styles2.wrap || {}, className: "slider-picker " + className },
    React.createElement(
      "div",
      { style: styles2.hue },
      React.createElement(Hue, {
        style: styles2.Hue,
        hsl: hsl2,
        pointer,
        onChange
      })
    ),
    React.createElement(
      "div",
      { style: styles2.swatches },
      React.createElement(SliderSwatches, { hsl: hsl2, onClick: onChange })
    )
  );
};
Slider2.propTypes = {
  styles: PropTypes.object
};
Slider2.defaultProps = {
  pointer: SliderPointer2,
  styles: {}
};
ColorWrap(Slider2);
var CheckIcon = {};
Object.defineProperty(CheckIcon, "__esModule", {
  value: true
});
var _extends$1 = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _react = reactExports;
var _react2 = _interopRequireDefault$8(_react);
function _interopRequireDefault$8(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _objectWithoutProperties(obj, keys2) {
  var target = {};
  for (var i2 in obj) {
    if (keys2.indexOf(i2) >= 0)
      continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i2))
      continue;
    target[i2] = obj[i2];
  }
  return target;
}
var DEFAULT_SIZE = 24;
var _default$8 = CheckIcon.default = function(_ref) {
  var _ref$fill = _ref.fill, fill = _ref$fill === void 0 ? "currentColor" : _ref$fill, _ref$width = _ref.width, width = _ref$width === void 0 ? DEFAULT_SIZE : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? DEFAULT_SIZE : _ref$height, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style, props = _objectWithoutProperties(_ref, ["fill", "width", "height", "style"]);
  return _react2.default.createElement(
    "svg",
    _extends$1({
      viewBox: "0 0 " + DEFAULT_SIZE + " " + DEFAULT_SIZE,
      style: _extends$1({ fill, width, height }, style)
    }, props),
    _react2.default.createElement("path", { d: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" })
  );
};
var SwatchesColor = function SwatchesColor2(_ref) {
  var color2 = _ref.color, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, onSwatchHover = _ref.onSwatchHover, first = _ref.first, last2 = _ref.last, active3 = _ref.active;
  var styles2 = _default$a({
    "default": {
      color: {
        width: "40px",
        height: "24px",
        cursor: "pointer",
        background: color2,
        marginBottom: "1px"
      },
      check: {
        color: getContrastingColor(color2),
        marginLeft: "8px",
        display: "none"
      }
    },
    "first": {
      color: {
        overflow: "hidden",
        borderRadius: "2px 2px 0 0"
      }
    },
    "last": {
      color: {
        overflow: "hidden",
        borderRadius: "0 0 2px 2px"
      }
    },
    "active": {
      check: {
        display: "block"
      }
    },
    "color-#FFFFFF": {
      color: {
        boxShadow: "inset 0 0 0 1px #ddd"
      },
      check: {
        color: "#333"
      }
    },
    "transparent": {
      check: {
        color: "#333"
      }
    }
  }, {
    first,
    last: last2,
    active: active3,
    "color-#FFFFFF": color2 === "#FFFFFF",
    "transparent": color2 === "transparent"
  });
  return React.createElement(
    Swatch$1,
    {
      color: color2,
      style: styles2.color,
      onClick,
      onHover: onSwatchHover,
      focusStyle: { boxShadow: "0 0 4px " + color2 }
    },
    React.createElement(
      "div",
      { style: styles2.check },
      React.createElement(_default$8, null)
    )
  );
};
var SwatchesGroup = function SwatchesGroup2(_ref) {
  var onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover, group3 = _ref.group, active3 = _ref.active;
  var styles2 = _default$a({
    "default": {
      group: {
        paddingBottom: "10px",
        width: "40px",
        float: "left",
        marginRight: "10px"
      }
    }
  });
  return React.createElement(
    "div",
    { style: styles2.group },
    map$1(group3, function(color2, i2) {
      return React.createElement(SwatchesColor, {
        key: color2,
        color: color2,
        active: color2.toLowerCase() === active3,
        first: i2 === 0,
        last: i2 === group3.length - 1,
        onClick,
        onSwatchHover
      });
    })
  );
};
var Swatches = function Swatches2(_ref) {
  var width = _ref.width, height = _ref.height, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, colors2 = _ref.colors, hex = _ref.hex, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = _default$a(merge$4({
    "default": {
      picker: {
        width,
        height
      },
      overflow: {
        height,
        overflowY: "scroll"
      },
      body: {
        padding: "16px 0 6px 16px"
      },
      clear: {
        clear: "both"
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(data, e2) {
    return onChange({ hex: data, source: "hex" }, e2);
  };
  return React.createElement(
    "div",
    { style: styles2.picker, className: "swatches-picker " + className },
    React.createElement(
      Raised,
      null,
      React.createElement(
        "div",
        { style: styles2.overflow },
        React.createElement(
          "div",
          { style: styles2.body },
          map$1(colors2, function(group3) {
            return React.createElement(SwatchesGroup, {
              key: group3.toString(),
              group: group3,
              active: hex,
              onClick: handleChange,
              onSwatchHover
            });
          }),
          React.createElement("div", { style: styles2.clear })
        )
      )
    )
  );
};
Swatches.propTypes = {
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  colors: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)),
  styles: PropTypes.object
  /* eslint-disable max-len */
};
Swatches.defaultProps = {
  width: 320,
  height: 240,
  colors: [[red["900"], red["700"], red["500"], red["300"], red["100"]], [pink["900"], pink["700"], pink["500"], pink["300"], pink["100"]], [purple["900"], purple["700"], purple["500"], purple["300"], purple["100"]], [deepPurple["900"], deepPurple["700"], deepPurple["500"], deepPurple["300"], deepPurple["100"]], [indigo["900"], indigo["700"], indigo["500"], indigo["300"], indigo["100"]], [blue["900"], blue["700"], blue["500"], blue["300"], blue["100"]], [lightBlue["900"], lightBlue["700"], lightBlue["500"], lightBlue["300"], lightBlue["100"]], [cyan["900"], cyan["700"], cyan["500"], cyan["300"], cyan["100"]], [teal["900"], teal["700"], teal["500"], teal["300"], teal["100"]], ["#194D33", green["700"], green["500"], green["300"], green["100"]], [lightGreen["900"], lightGreen["700"], lightGreen["500"], lightGreen["300"], lightGreen["100"]], [lime["900"], lime["700"], lime["500"], lime["300"], lime["100"]], [yellow["900"], yellow["700"], yellow["500"], yellow["300"], yellow["100"]], [amber["900"], amber["700"], amber["500"], amber["300"], amber["100"]], [orange["900"], orange["700"], orange["500"], orange["300"], orange["100"]], [deepOrange["900"], deepOrange["700"], deepOrange["500"], deepOrange["300"], deepOrange["100"]], [brown["900"], brown["700"], brown["500"], brown["300"], brown["100"]], [blueGrey["900"], blueGrey["700"], blueGrey["500"], blueGrey["300"], blueGrey["100"]], ["#000000", "#525252", "#969696", "#D9D9D9", "#FFFFFF"]],
  styles: {}
};
const SwatchesPicker = ColorWrap(Swatches);
var Twitter = function Twitter2(_ref) {
  var onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, hex = _ref.hex, colors2 = _ref.colors, width = _ref.width, triangle = _ref.triangle, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = _default$a(merge$4({
    "default": {
      card: {
        width,
        background: "#fff",
        border: "0 solid rgba(0,0,0,0.25)",
        boxShadow: "0 1px 4px rgba(0,0,0,0.25)",
        borderRadius: "4px",
        position: "relative"
      },
      body: {
        padding: "15px 9px 9px 15px"
      },
      label: {
        fontSize: "18px",
        color: "#fff"
      },
      triangle: {
        width: "0px",
        height: "0px",
        borderStyle: "solid",
        borderWidth: "0 9px 10px 9px",
        borderColor: "transparent transparent #fff transparent",
        position: "absolute"
      },
      triangleShadow: {
        width: "0px",
        height: "0px",
        borderStyle: "solid",
        borderWidth: "0 9px 10px 9px",
        borderColor: "transparent transparent rgba(0,0,0,.1) transparent",
        position: "absolute"
      },
      hash: {
        background: "#F0F0F0",
        height: "30px",
        width: "30px",
        borderRadius: "4px 0 0 4px",
        float: "left",
        color: "#98A1A4",
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      },
      input: {
        width: "100px",
        fontSize: "14px",
        color: "#666",
        border: "0px",
        outline: "none",
        height: "28px",
        boxShadow: "inset 0 0 0 1px #F0F0F0",
        boxSizing: "content-box",
        borderRadius: "0 4px 4px 0",
        float: "left",
        paddingLeft: "8px"
      },
      swatch: {
        width: "30px",
        height: "30px",
        float: "left",
        borderRadius: "4px",
        margin: "0 6px 6px 0"
      },
      clear: {
        clear: "both"
      }
    },
    "hide-triangle": {
      triangle: {
        display: "none"
      },
      triangleShadow: {
        display: "none"
      }
    },
    "top-left-triangle": {
      triangle: {
        top: "-10px",
        left: "12px"
      },
      triangleShadow: {
        top: "-11px",
        left: "12px"
      }
    },
    "top-right-triangle": {
      triangle: {
        top: "-10px",
        right: "12px"
      },
      triangleShadow: {
        top: "-11px",
        right: "12px"
      }
    }
  }, passedStyles), {
    "hide-triangle": triangle === "hide",
    "top-left-triangle": triangle === "top-left",
    "top-right-triangle": triangle === "top-right"
  });
  var handleChange = function handleChange2(hexcode, e2) {
    isValidHex(hexcode) && onChange({
      hex: hexcode,
      source: "hex"
    }, e2);
  };
  return React.createElement(
    "div",
    { style: styles2.card, className: "twitter-picker " + className },
    React.createElement("div", { style: styles2.triangleShadow }),
    React.createElement("div", { style: styles2.triangle }),
    React.createElement(
      "div",
      { style: styles2.body },
      map$1(colors2, function(c2, i2) {
        return React.createElement(Swatch$1, {
          key: i2,
          color: c2,
          hex: c2,
          style: styles2.swatch,
          onClick: handleChange,
          onHover: onSwatchHover,
          focusStyle: {
            boxShadow: "0 0 4px " + c2
          }
        });
      }),
      React.createElement(
        "div",
        { style: styles2.hash },
        "#"
      ),
      React.createElement(EditableInput, {
        label: null,
        style: { input: styles2.input },
        value: hex.replace("#", ""),
        onChange: handleChange
      }),
      React.createElement("div", { style: styles2.clear })
    )
  );
};
Twitter.propTypes = {
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  triangle: PropTypes.oneOf(["hide", "top-left", "top-right"]),
  colors: PropTypes.arrayOf(PropTypes.string),
  styles: PropTypes.object
};
Twitter.defaultProps = {
  width: 276,
  colors: ["#FF6900", "#FCB900", "#7BDCB5", "#00D084", "#8ED1FC", "#0693E3", "#ABB8C3", "#EB144C", "#F78DA7", "#9900EF"],
  triangle: "top-left",
  styles: {}
};
ColorWrap(Twitter);
var GooglePointerCircle = function GooglePointerCircle2(props) {
  var styles2 = _default$a({
    "default": {
      picker: {
        width: "20px",
        height: "20px",
        borderRadius: "22px",
        border: "2px #fff solid",
        transform: "translate(-12px, -13px)",
        background: "hsl(" + Math.round(props.hsl.h) + ", " + Math.round(props.hsl.s * 100) + "%, " + Math.round(props.hsl.l * 100) + "%)"
      }
    }
  });
  return React.createElement("div", { style: styles2.picker });
};
GooglePointerCircle.propTypes = {
  hsl: PropTypes.shape({
    h: PropTypes.number,
    s: PropTypes.number,
    l: PropTypes.number,
    a: PropTypes.number
  })
};
GooglePointerCircle.defaultProps = {
  hsl: { a: 1, h: 249.94, l: 0.2, s: 0.5 }
};
var GooglePointer = function GooglePointer2(props) {
  var styles2 = _default$a({
    "default": {
      picker: {
        width: "20px",
        height: "20px",
        borderRadius: "22px",
        transform: "translate(-10px, -7px)",
        background: "hsl(" + Math.round(props.hsl.h) + ", 100%, 50%)",
        border: "2px white solid"
      }
    }
  });
  return React.createElement("div", { style: styles2.picker });
};
GooglePointer.propTypes = {
  hsl: PropTypes.shape({
    h: PropTypes.number,
    s: PropTypes.number,
    l: PropTypes.number,
    a: PropTypes.number
  })
};
GooglePointer.defaultProps = {
  hsl: { a: 1, h: 249.94, l: 0.2, s: 0.5 }
};
var GoogleFields = function GoogleFields2(_ref) {
  var onChange = _ref.onChange, rgb2 = _ref.rgb, hsl2 = _ref.hsl, hex = _ref.hex, hsv = _ref.hsv;
  var handleChange = function handleChange2(data, e2) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: "hex"
      }, e2);
    } else if (data.rgb) {
      var values = data.rgb.split(",");
      isvalidColorString(data.rgb, "rgb") && onChange({
        r: values[0],
        g: values[1],
        b: values[2],
        a: 1,
        source: "rgb"
      }, e2);
    } else if (data.hsv) {
      var _values = data.hsv.split(",");
      if (isvalidColorString(data.hsv, "hsv")) {
        _values[2] = _values[2].replace("%", "");
        _values[1] = _values[1].replace("%", "");
        _values[0] = _values[0].replace("°", "");
        if (_values[1] == 1) {
          _values[1] = 0.01;
        } else if (_values[2] == 1) {
          _values[2] = 0.01;
        }
        onChange({
          h: Number(_values[0]),
          s: Number(_values[1]),
          v: Number(_values[2]),
          source: "hsv"
        }, e2);
      }
    } else if (data.hsl) {
      var _values2 = data.hsl.split(",");
      if (isvalidColorString(data.hsl, "hsl")) {
        _values2[2] = _values2[2].replace("%", "");
        _values2[1] = _values2[1].replace("%", "");
        _values2[0] = _values2[0].replace("°", "");
        if (hsvValue[1] == 1) {
          hsvValue[1] = 0.01;
        } else if (hsvValue[2] == 1) {
          hsvValue[2] = 0.01;
        }
        onChange({
          h: Number(_values2[0]),
          s: Number(_values2[1]),
          v: Number(_values2[2]),
          source: "hsl"
        }, e2);
      }
    }
  };
  var styles2 = _default$a({
    "default": {
      wrap: {
        display: "flex",
        height: "100px",
        marginTop: "4px"
      },
      fields: {
        width: "100%"
      },
      column: {
        paddingTop: "10px",
        display: "flex",
        justifyContent: "space-between"
      },
      double: {
        padding: "0px 4.4px",
        boxSizing: "border-box"
      },
      input: {
        width: "100%",
        height: "38px",
        boxSizing: "border-box",
        padding: "4px 10% 3px",
        textAlign: "center",
        border: "1px solid #dadce0",
        fontSize: "11px",
        textTransform: "lowercase",
        borderRadius: "5px",
        outline: "none",
        fontFamily: "Roboto,Arial,sans-serif"
      },
      input2: {
        height: "38px",
        width: "100%",
        border: "1px solid #dadce0",
        boxSizing: "border-box",
        fontSize: "11px",
        textTransform: "lowercase",
        borderRadius: "5px",
        outline: "none",
        paddingLeft: "10px",
        fontFamily: "Roboto,Arial,sans-serif"
      },
      label: {
        textAlign: "center",
        fontSize: "12px",
        background: "#fff",
        position: "absolute",
        textTransform: "uppercase",
        color: "#3c4043",
        width: "35px",
        top: "-6px",
        left: "0",
        right: "0",
        marginLeft: "auto",
        marginRight: "auto",
        fontFamily: "Roboto,Arial,sans-serif"
      },
      label2: {
        left: "10px",
        textAlign: "center",
        fontSize: "12px",
        background: "#fff",
        position: "absolute",
        textTransform: "uppercase",
        color: "#3c4043",
        width: "32px",
        top: "-6px",
        fontFamily: "Roboto,Arial,sans-serif"
      },
      single: {
        flexGrow: "1",
        margin: "0px 4.4px"
      }
    }
  });
  var rgbValue = rgb2.r + ", " + rgb2.g + ", " + rgb2.b;
  var hslValue = Math.round(hsl2.h) + "°, " + Math.round(hsl2.s * 100) + "%, " + Math.round(hsl2.l * 100) + "%";
  var hsvValue = Math.round(hsv.h) + "°, " + Math.round(hsv.s * 100) + "%, " + Math.round(hsv.v * 100) + "%";
  return React.createElement(
    "div",
    { style: styles2.wrap, className: "flexbox-fix" },
    React.createElement(
      "div",
      { style: styles2.fields },
      React.createElement(
        "div",
        { style: styles2.double },
        React.createElement(EditableInput, {
          style: { input: styles2.input, label: styles2.label },
          label: "hex",
          value: hex,
          onChange: handleChange
        })
      ),
      React.createElement(
        "div",
        { style: styles2.column },
        React.createElement(
          "div",
          { style: styles2.single },
          React.createElement(EditableInput, {
            style: { input: styles2.input2, label: styles2.label2 },
            label: "rgb",
            value: rgbValue,
            onChange: handleChange
          })
        ),
        React.createElement(
          "div",
          { style: styles2.single },
          React.createElement(EditableInput, {
            style: { input: styles2.input2, label: styles2.label2 },
            label: "hsv",
            value: hsvValue,
            onChange: handleChange
          })
        ),
        React.createElement(
          "div",
          { style: styles2.single },
          React.createElement(EditableInput, {
            style: { input: styles2.input2, label: styles2.label2 },
            label: "hsl",
            value: hslValue,
            onChange: handleChange
          })
        )
      )
    )
  );
};
var Google = function Google2(_ref) {
  var width = _ref.width, onChange = _ref.onChange, rgb2 = _ref.rgb, hsl2 = _ref.hsl, hsv = _ref.hsv, hex = _ref.hex, header = _ref.header, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = _default$a(merge$4({
    "default": {
      picker: {
        width,
        background: "#fff",
        border: "1px solid #dfe1e5",
        boxSizing: "initial",
        display: "flex",
        flexWrap: "wrap",
        borderRadius: "8px 8px 0px 0px"
      },
      head: {
        height: "57px",
        width: "100%",
        paddingTop: "16px",
        paddingBottom: "16px",
        paddingLeft: "16px",
        fontSize: "20px",
        boxSizing: "border-box",
        fontFamily: "Roboto-Regular,HelveticaNeue,Arial,sans-serif"
      },
      saturation: {
        width: "70%",
        padding: "0px",
        position: "relative",
        overflow: "hidden"
      },
      swatch: {
        width: "30%",
        height: "228px",
        padding: "0px",
        background: "rgba(" + rgb2.r + ", " + rgb2.g + ", " + rgb2.b + ", 1)",
        position: "relative",
        overflow: "hidden"
      },
      body: {
        margin: "auto",
        width: "95%"
      },
      controls: {
        display: "flex",
        boxSizing: "border-box",
        height: "52px",
        paddingTop: "22px"
      },
      color: {
        width: "32px"
      },
      hue: {
        height: "8px",
        position: "relative",
        margin: "0px 16px 0px 16px",
        width: "100%"
      },
      Hue: {
        radius: "2px"
      }
    }
  }, passedStyles));
  return React.createElement(
    "div",
    { style: styles2.picker, className: "google-picker " + className },
    React.createElement(
      "div",
      { style: styles2.head },
      header
    ),
    React.createElement("div", { style: styles2.swatch }),
    React.createElement(
      "div",
      { style: styles2.saturation },
      React.createElement(Saturation, {
        hsl: hsl2,
        hsv,
        pointer: GooglePointerCircle,
        onChange
      })
    ),
    React.createElement(
      "div",
      { style: styles2.body },
      React.createElement(
        "div",
        { style: styles2.controls, className: "flexbox-fix" },
        React.createElement(
          "div",
          { style: styles2.hue },
          React.createElement(Hue, {
            style: styles2.Hue,
            hsl: hsl2,
            radius: "4px",
            pointer: GooglePointer,
            onChange
          })
        )
      ),
      React.createElement(GoogleFields, {
        rgb: rgb2,
        hsl: hsl2,
        hex,
        hsv,
        onChange
      })
    )
  );
};
Google.propTypes = {
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  styles: PropTypes.object,
  header: PropTypes.string
};
Google.defaultProps = {
  width: 652,
  styles: {},
  header: "Color picker"
};
ColorWrap(Google);
function ColorPicker(props) {
  const [showColorPicker, setShowColorPicker] = reactExports.useState(false);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          backgroundColor: props.color || props.default
        },
        className: styles$d.swatch,
        onClick: (e2) => setShowColorPicker(true),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$d.color })
      }
    ),
    showColorPicker ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: styles$d.cover,
          onClick: (e2) => setShowColorPicker(false)
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SwatchesPicker,
        {
          onChange: (e2) => {
            props.handleChange(e2.hex);
            setShowColorPicker(false);
          }
        }
      )
    ] }) : null
  ] });
}
const themingItem = "_themingItem_1o98o_1";
const themingItemBody = "_themingItemBody_1o98o_6";
const styles$c = {
  themingItem,
  themingItemBody
};
function ThemingItem(props) {
  const listFont = [
    "Alegreya",
    "Amatic SC",
    "Arial",
    "Bree Serif",
    "Calibri",
    "Cambria",
    "Caveat",
    "Comfortaa",
    "Comic Sans MS",
    "Courier New",
    "EB Garamond",
    "Georgia",
    "Google Sans",
    "Impact",
    "Lexend",
    "Lobster",
    "Lora",
    "Merriweather",
    "Montserrat",
    "Nunito",
    "Oswald",
    "Pacifico",
    "Permanent Marker",
    "Pinyon Script",
    "Playfair Display",
    "Proxima Nova",
    "Roboto",
    "Roboto Mono",
    "Roboto Serif",
    "Spectral",
    "Times New Roman",
    "Trebuchet MS",
    "Ultra",
    "Varela Round",
    "Verdana"
  ];
  const listFontSize = Array.from({ length: 12 }, (_, index2) => index2 * 2 + 10);
  function handleChange(key, value) {
    props.onChange({ ...props.value, [key]: value });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$c.themingItem, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$c.themingItemBody, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Select,
        {
          size: "small",
          className: "mr-10",
          value: props.value.font || props.default.font,
          onChange: (e2) => handleChange("font", e2.target.value),
          children: listFont && listFont.length > 0 && listFont.map((el, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            MenuItem,
            {
              sx: { fontFamily: el },
              value: el,
              children: el
            },
            `fontFamily-${index2}`
          ))
        },
        "fontFamily"
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Select,
        {
          size: "small",
          value: props.value.size || props.default.size,
          onChange: (e2) => handleChange("size", e2.target.value),
          children: listFontSize && listFontSize.length > 0 && listFontSize.map((el, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: el, children: el }, `fontSize-${index2}`))
        },
        "fontSize"
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ColorPicker,
      {
        color: props.value.color,
        default: props.default.color,
        handleChange: (value) => handleChange("color", value)
      }
    )
  ] });
}
var Image = {};
var _interopRequireDefault$7 = interopRequireDefaultExports;
Object.defineProperty(Image, "__esModule", {
  value: true
});
var default_1$7 = Image.default = void 0;
var _createSvgIcon$7 = _interopRequireDefault$7(requireCreateSvgIcon());
var _jsxRuntime$7 = jsxRuntimeExports;
var _default$7 = (0, _createSvgIcon$7.default)(/* @__PURE__ */ (0, _jsxRuntime$7.jsx)("path", {
  d: "M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"
}), "Image");
default_1$7 = Image.default = _default$7;
function Theming({ t: t2 }) {
  const dispatch = useDispatch();
  const theme = useSelector((state) => {
    return state.designState.Survey.theme;
  });
  function handleChange(key, val) {
    dispatch(
      changeAttribute({
        code: "Survey",
        key: "theme",
        value: { ...theme, [key]: val }
      })
    );
  }
  function handleImageChange(e2) {
    e2.preventDefault();
    let file = e2.target.files[0];
    DesignService.uploadResource(file).then((response) => {
      dispatch(
        changeResources({
          code: "Survey",
          key: "headerImage",
          value: file.name
        })
      );
    }).catch((err) => {
      console.error(err);
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$e.theming, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { children: t2("text_style") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h6", { children: t2("group_title") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ThemingItem,
      {
        value: theme.textStyles.group,
        default: defaultSurveyTheme.textStyles.group,
        onChange: (val) => {
          handleChange("textStyles", { ...theme.textStyles, ["group"]: val });
        }
      },
      "group"
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h6", { children: t2("question_title") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ThemingItem,
      {
        value: theme.textStyles.question,
        default: defaultSurveyTheme.textStyles.question,
        onChange: (val) => handleChange("textStyles", { ...theme.textStyles, ["question"]: val })
      },
      "question"
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h6", { children: t2("theme_text") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ThemingItem,
      {
        value: theme.textStyles.text,
        default: defaultSurveyTheme.textStyles.text,
        onChange: (val) => handleChange("textStyles", { ...theme.textStyles, ["text"]: val })
      },
      "text"
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { children: t2("highlight_color") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ColorPicker,
      {
        color: theme.primaryColor,
        default: defaultSurveyTheme.primaryColor,
        handleChange: (value) => handleChange("primaryColor", value)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { children: t2("background_color") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ColorPicker,
      {
        color: theme.bgColor,
        default: defaultSurveyTheme.bgColor,
        handleChange: (value) => handleChange("bgColor", value)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { children: t2("foreground_color") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ColorPicker,
      {
        color: theme.paperColor,
        default: defaultSurveyTheme.paperColor,
        handleChange: (value) => handleChange("paperColor", value)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { children: t2("theme_header") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { variant: "outlined", component: "label", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$7, { className: "mr-10" }),
      t2("choose_image"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          hidden: true,
          accept: "image/*",
          multiple: true,
          type: "file",
          onChange: handleImageChange
        }
      )
    ] })
  ] });
}
function ownKeys$w(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$w(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$w(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _slicedToArray(arr, i2) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray$6(arr, i2) || _nonIterableRest();
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArrayLimit(arr, i2) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _unsupportedIterableToArray$6(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$6(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$6(o, minLen);
}
function _arrayLikeToArray$6(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var ConfirmContext = /* @__PURE__ */ reactExports.createContext();
var ConfirmationDialog = function ConfirmationDialog2(_ref) {
  var open = _ref.open, options = _ref.options, onCancel = _ref.onCancel, onConfirm = _ref.onConfirm, onClose = _ref.onClose;
  var title2 = options.title, description = options.description, content = options.content, confirmationText = options.confirmationText, cancellationText = options.cancellationText, dialogProps = options.dialogProps, dialogActionsProps = options.dialogActionsProps, confirmationButtonProps = options.confirmationButtonProps, cancellationButtonProps = options.cancellationButtonProps, titleProps = options.titleProps, contentProps = options.contentProps, allowClose = options.allowClose, confirmationKeyword = options.confirmationKeyword, confirmationKeywordTextFieldProps = options.confirmationKeywordTextFieldProps, hideCancelButton = options.hideCancelButton, buttonOrder = options.buttonOrder;
  var _React$useState = React.useState(""), _React$useState2 = _slicedToArray(_React$useState, 2), confirmationKeywordValue = _React$useState2[0], setConfirmationKeywordValue = _React$useState2[1];
  var confirmationButtonDisabled = confirmationKeyword && confirmationKeywordValue !== confirmationKeyword;
  var confirmationContent = /* @__PURE__ */ React.createElement(React.Fragment, null, confirmationKeyword && /* @__PURE__ */ React.createElement(TextField, _extends({
    onChange: function onChange(e2) {
      return setConfirmationKeywordValue(e2.target.value);
    },
    value: confirmationKeywordValue,
    fullWidth: true
  }, confirmationKeywordTextFieldProps)));
  var dialogActions = buttonOrder.map(function(buttonType) {
    if (buttonType === "cancel") {
      return !hideCancelButton && /* @__PURE__ */ React.createElement(Button, _extends({
        key: "cancel"
      }, cancellationButtonProps, {
        onClick: onCancel
      }), cancellationText);
    }
    if (buttonType === "confirm") {
      return /* @__PURE__ */ React.createElement(Button, _extends({
        key: "confirm",
        color: "primary",
        disabled: confirmationButtonDisabled
      }, confirmationButtonProps, {
        onClick: onConfirm
      }), confirmationText);
    }
    throw new Error('Supported button types are only "confirm" and "cancel", got: '.concat(buttonType));
  });
  return /* @__PURE__ */ React.createElement(Dialog, _extends({
    fullWidth: true
  }, dialogProps, {
    open,
    onClose: allowClose ? onClose : null
  }), title2 && /* @__PURE__ */ React.createElement(DialogTitle, titleProps, title2), content ? /* @__PURE__ */ React.createElement(DialogContent, contentProps, content, confirmationContent) : description ? /* @__PURE__ */ React.createElement(DialogContent, contentProps, /* @__PURE__ */ React.createElement(DialogContentText$1, null, description), confirmationContent) : confirmationKeyword && /* @__PURE__ */ React.createElement(DialogContent, contentProps, confirmationContent), /* @__PURE__ */ React.createElement(DialogActions, dialogActionsProps, dialogActions));
};
var DEFAULT_OPTIONS = {
  title: "Are you sure?",
  description: "",
  content: null,
  confirmationText: "Ok",
  cancellationText: "Cancel",
  dialogProps: {},
  dialogActionsProps: {},
  confirmationButtonProps: {},
  cancellationButtonProps: {},
  titleProps: {},
  contentProps: {},
  allowClose: true,
  confirmationKeywordTextFieldProps: {},
  hideCancelButton: false,
  buttonOrder: ["cancel", "confirm"]
};
var buildOptions = function buildOptions2(defaultOptions, options) {
  var dialogProps = _objectSpread2(_objectSpread2({}, defaultOptions.dialogProps || DEFAULT_OPTIONS.dialogProps), options.dialogProps || {});
  var dialogActionsProps = _objectSpread2(_objectSpread2({}, defaultOptions.dialogActionsProps || DEFAULT_OPTIONS.dialogActionsProps), options.dialogActionsProps || {});
  var confirmationButtonProps = _objectSpread2(_objectSpread2({}, defaultOptions.confirmationButtonProps || DEFAULT_OPTIONS.confirmationButtonProps), options.confirmationButtonProps || {});
  var cancellationButtonProps = _objectSpread2(_objectSpread2({}, defaultOptions.cancellationButtonProps || DEFAULT_OPTIONS.cancellationButtonProps), options.cancellationButtonProps || {});
  var titleProps = _objectSpread2(_objectSpread2({}, defaultOptions.titleProps || DEFAULT_OPTIONS.titleProps), options.titleProps || {});
  var contentProps = _objectSpread2(_objectSpread2({}, defaultOptions.contentProps || DEFAULT_OPTIONS.contentProps), options.contentProps || {});
  var confirmationKeywordTextFieldProps = _objectSpread2(_objectSpread2({}, defaultOptions.confirmationKeywordTextFieldProps || DEFAULT_OPTIONS.confirmationKeywordTextFieldProps), options.confirmationKeywordTextFieldProps || {});
  return _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, DEFAULT_OPTIONS), defaultOptions), options), {}, {
    dialogProps,
    dialogActionsProps,
    confirmationButtonProps,
    cancellationButtonProps,
    titleProps,
    contentProps,
    confirmationKeywordTextFieldProps
  });
};
var ConfirmProvider = function ConfirmProvider2(_ref) {
  var children = _ref.children, _ref$defaultOptions = _ref.defaultOptions, defaultOptions = _ref$defaultOptions === void 0 ? {} : _ref$defaultOptions;
  var _useState = reactExports.useState({}), _useState2 = _slicedToArray(_useState, 2), options = _useState2[0], setOptions = _useState2[1];
  var _useState3 = reactExports.useState([]), _useState4 = _slicedToArray(_useState3, 2), resolveReject = _useState4[0], setResolveReject = _useState4[1];
  var _resolveReject = _slicedToArray(resolveReject, 2), resolve = _resolveReject[0], reject = _resolveReject[1];
  var confirm2 = reactExports.useCallback(function() {
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return new Promise(function(resolve2, reject2) {
      setOptions(options2);
      setResolveReject([resolve2, reject2]);
    });
  }, []);
  var handleClose = reactExports.useCallback(function() {
    setResolveReject([]);
  }, []);
  var handleCancel = reactExports.useCallback(function() {
    if (reject) {
      reject();
      handleClose();
    }
  }, [reject, handleClose]);
  var handleConfirm = reactExports.useCallback(function() {
    if (resolve) {
      resolve();
      handleClose();
    }
  }, [resolve, handleClose]);
  return /* @__PURE__ */ React.createElement(reactExports.Fragment, null, /* @__PURE__ */ React.createElement(ConfirmContext.Provider, {
    value: confirm2
  }, children), /* @__PURE__ */ React.createElement(ConfirmationDialog, {
    open: resolveReject.length === 2,
    options: buildOptions(defaultOptions, options),
    onClose: handleClose,
    onCancel: handleCancel,
    onConfirm: handleConfirm
  }));
};
var useConfirm = function useConfirm2() {
  var confirm2 = reactExports.useContext(ConfirmContext);
  return confirm2;
};
//! moment.js
//! version : 2.29.4
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
var hookCallback;
function hooks() {
  return hookCallback.apply(null, arguments);
}
function setHookCallback(callback) {
  hookCallback = callback;
}
function isArray$2(input2) {
  return input2 instanceof Array || Object.prototype.toString.call(input2) === "[object Array]";
}
function isObject$9(input2) {
  return input2 != null && Object.prototype.toString.call(input2) === "[object Object]";
}
function hasOwnProp(a2, b2) {
  return Object.prototype.hasOwnProperty.call(a2, b2);
}
function isObjectEmpty(obj) {
  if (Object.getOwnPropertyNames) {
    return Object.getOwnPropertyNames(obj).length === 0;
  } else {
    var k2;
    for (k2 in obj) {
      if (hasOwnProp(obj, k2)) {
        return false;
      }
    }
    return true;
  }
}
function isUndefined(input2) {
  return input2 === void 0;
}
function isNumber(input2) {
  return typeof input2 === "number" || Object.prototype.toString.call(input2) === "[object Number]";
}
function isDate(input2) {
  return input2 instanceof Date || Object.prototype.toString.call(input2) === "[object Date]";
}
function map(arr, fn) {
  var res = [], i2, arrLen = arr.length;
  for (i2 = 0; i2 < arrLen; ++i2) {
    res.push(fn(arr[i2], i2));
  }
  return res;
}
function extend2(a2, b2) {
  for (var i2 in b2) {
    if (hasOwnProp(b2, i2)) {
      a2[i2] = b2[i2];
    }
  }
  if (hasOwnProp(b2, "toString")) {
    a2.toString = b2.toString;
  }
  if (hasOwnProp(b2, "valueOf")) {
    a2.valueOf = b2.valueOf;
  }
  return a2;
}
function createUTC(input2, format2, locale2, strict) {
  return createLocalOrUTC(input2, format2, locale2, strict, true).utc();
}
function defaultParsingFlags() {
  return {
    empty: false,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: false,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: false,
    userInvalidated: false,
    iso: false,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: false,
    weekdayMismatch: false
  };
}
function getParsingFlags(m2) {
  if (m2._pf == null) {
    m2._pf = defaultParsingFlags();
  }
  return m2._pf;
}
var some;
if (Array.prototype.some) {
  some = Array.prototype.some;
} else {
  some = function(fun) {
    var t2 = Object(this), len = t2.length >>> 0, i2;
    for (i2 = 0; i2 < len; i2++) {
      if (i2 in t2 && fun.call(this, t2[i2], i2, t2)) {
        return true;
      }
    }
    return false;
  };
}
function isValid2(m2) {
  if (m2._isValid == null) {
    var flags = getParsingFlags(m2), parsedParts = some.call(flags.parsedDateParts, function(i2) {
      return i2 != null;
    }), isNowValid = !isNaN(m2._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
    if (m2._strict) {
      isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
    }
    if (Object.isFrozen == null || !Object.isFrozen(m2)) {
      m2._isValid = isNowValid;
    } else {
      return isNowValid;
    }
  }
  return m2._isValid;
}
function createInvalid(flags) {
  var m2 = createUTC(NaN);
  if (flags != null) {
    extend2(getParsingFlags(m2), flags);
  } else {
    getParsingFlags(m2).userInvalidated = true;
  }
  return m2;
}
var momentProperties = hooks.momentProperties = [], updateInProgress = false;
function copyConfig(to2, from2) {
  var i2, prop, val, momentPropertiesLen = momentProperties.length;
  if (!isUndefined(from2._isAMomentObject)) {
    to2._isAMomentObject = from2._isAMomentObject;
  }
  if (!isUndefined(from2._i)) {
    to2._i = from2._i;
  }
  if (!isUndefined(from2._f)) {
    to2._f = from2._f;
  }
  if (!isUndefined(from2._l)) {
    to2._l = from2._l;
  }
  if (!isUndefined(from2._strict)) {
    to2._strict = from2._strict;
  }
  if (!isUndefined(from2._tzm)) {
    to2._tzm = from2._tzm;
  }
  if (!isUndefined(from2._isUTC)) {
    to2._isUTC = from2._isUTC;
  }
  if (!isUndefined(from2._offset)) {
    to2._offset = from2._offset;
  }
  if (!isUndefined(from2._pf)) {
    to2._pf = getParsingFlags(from2);
  }
  if (!isUndefined(from2._locale)) {
    to2._locale = from2._locale;
  }
  if (momentPropertiesLen > 0) {
    for (i2 = 0; i2 < momentPropertiesLen; i2++) {
      prop = momentProperties[i2];
      val = from2[prop];
      if (!isUndefined(val)) {
        to2[prop] = val;
      }
    }
  }
  return to2;
}
function Moment(config2) {
  copyConfig(this, config2);
  this._d = new Date(config2._d != null ? config2._d.getTime() : NaN);
  if (!this.isValid()) {
    this._d = /* @__PURE__ */ new Date(NaN);
  }
  if (updateInProgress === false) {
    updateInProgress = true;
    hooks.updateOffset(this);
    updateInProgress = false;
  }
}
function isMoment(obj) {
  return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
}
function warn(msg) {
  if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
    console.warn("Deprecation warning: " + msg);
  }
}
function deprecate(msg, fn) {
  var firstTime = true;
  return extend2(function() {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(null, msg);
    }
    if (firstTime) {
      var args = [], arg, i2, key, argLen = arguments.length;
      for (i2 = 0; i2 < argLen; i2++) {
        arg = "";
        if (typeof arguments[i2] === "object") {
          arg += "\n[" + i2 + "] ";
          for (key in arguments[0]) {
            if (hasOwnProp(arguments[0], key)) {
              arg += key + ": " + arguments[0][key] + ", ";
            }
          }
          arg = arg.slice(0, -2);
        } else {
          arg = arguments[i2];
        }
        args.push(arg);
      }
      warn(
        msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
      );
      firstTime = false;
    }
    return fn.apply(this, arguments);
  }, fn);
}
var deprecations = {};
function deprecateSimple(name, msg) {
  if (hooks.deprecationHandler != null) {
    hooks.deprecationHandler(name, msg);
  }
  if (!deprecations[name]) {
    warn(msg);
    deprecations[name] = true;
  }
}
hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;
function isFunction$1(input2) {
  return typeof Function !== "undefined" && input2 instanceof Function || Object.prototype.toString.call(input2) === "[object Function]";
}
function set(config2) {
  var prop, i2;
  for (i2 in config2) {
    if (hasOwnProp(config2, i2)) {
      prop = config2[i2];
      if (isFunction$1(prop)) {
        this[i2] = prop;
      } else {
        this["_" + i2] = prop;
      }
    }
  }
  this._config = config2;
  this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function mergeConfigs(parentConfig, childConfig) {
  var res = extend2({}, parentConfig), prop;
  for (prop in childConfig) {
    if (hasOwnProp(childConfig, prop)) {
      if (isObject$9(parentConfig[prop]) && isObject$9(childConfig[prop])) {
        res[prop] = {};
        extend2(res[prop], parentConfig[prop]);
        extend2(res[prop], childConfig[prop]);
      } else if (childConfig[prop] != null) {
        res[prop] = childConfig[prop];
      } else {
        delete res[prop];
      }
    }
  }
  for (prop in parentConfig) {
    if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject$9(parentConfig[prop])) {
      res[prop] = extend2({}, res[prop]);
    }
  }
  return res;
}
function Locale(config2) {
  if (config2 != null) {
    this.set(config2);
  }
}
var keys;
if (Object.keys) {
  keys = Object.keys;
} else {
  keys = function(obj) {
    var i2, res = [];
    for (i2 in obj) {
      if (hasOwnProp(obj, i2)) {
        res.push(i2);
      }
    }
    return res;
  };
}
var defaultCalendar = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function calendar(key, mom, now2) {
  var output = this._calendar[key] || this._calendar["sameElse"];
  return isFunction$1(output) ? output.call(mom, now2) : output;
}
function zeroFill(number, targetLength, forceSign) {
  var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
  return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}
var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
function addFormatToken(token2, padded, ordinal2, callback) {
  var func = callback;
  if (typeof callback === "string") {
    func = function() {
      return this[callback]();
    };
  }
  if (token2) {
    formatTokenFunctions[token2] = func;
  }
  if (padded) {
    formatTokenFunctions[padded[0]] = function() {
      return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
    };
  }
  if (ordinal2) {
    formatTokenFunctions[ordinal2] = function() {
      return this.localeData().ordinal(
        func.apply(this, arguments),
        token2
      );
    };
  }
}
function removeFormattingTokens(input2) {
  if (input2.match(/\[[\s\S]/)) {
    return input2.replace(/^\[|\]$/g, "");
  }
  return input2.replace(/\\/g, "");
}
function makeFormatFunction(format2) {
  var array = format2.match(formattingTokens), i2, length;
  for (i2 = 0, length = array.length; i2 < length; i2++) {
    if (formatTokenFunctions[array[i2]]) {
      array[i2] = formatTokenFunctions[array[i2]];
    } else {
      array[i2] = removeFormattingTokens(array[i2]);
    }
  }
  return function(mom) {
    var output = "", i3;
    for (i3 = 0; i3 < length; i3++) {
      output += isFunction$1(array[i3]) ? array[i3].call(mom, format2) : array[i3];
    }
    return output;
  };
}
function formatMoment(m2, format2) {
  if (!m2.isValid()) {
    return m2.localeData().invalidDate();
  }
  format2 = expandFormat(format2, m2.localeData());
  formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
  return formatFunctions[format2](m2);
}
function expandFormat(format2, locale2) {
  var i2 = 5;
  function replaceLongDateFormatTokens(input2) {
    return locale2.longDateFormat(input2) || input2;
  }
  localFormattingTokens.lastIndex = 0;
  while (i2 >= 0 && localFormattingTokens.test(format2)) {
    format2 = format2.replace(
      localFormattingTokens,
      replaceLongDateFormatTokens
    );
    localFormattingTokens.lastIndex = 0;
    i2 -= 1;
  }
  return format2;
}
var defaultLongDateFormat = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function longDateFormat(key) {
  var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
  if (format2 || !formatUpper) {
    return format2;
  }
  this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
    if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
      return tok.slice(1);
    }
    return tok;
  }).join("");
  return this._longDateFormat[key];
}
var defaultInvalidDate = "Invalid date";
function invalidDate() {
  return this._invalidDate;
}
var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
function ordinal(number) {
  return this._ordinal.replace("%d", number);
}
var defaultRelativeTime = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function relativeTime(number, withoutSuffix, string, isFuture) {
  var output = this._relativeTime[string];
  return isFunction$1(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
}
function pastFuture(diff2, output) {
  var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
  return isFunction$1(format2) ? format2(output) : format2.replace(/%s/i, output);
}
var aliases = {};
function addUnitAlias(unit, shorthand) {
  var lowerCase = unit.toLowerCase();
  aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
}
function normalizeUnits(units) {
  return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
}
function normalizeObjectUnits(inputObject) {
  var normalizedInput = {}, normalizedProp, prop;
  for (prop in inputObject) {
    if (hasOwnProp(inputObject, prop)) {
      normalizedProp = normalizeUnits(prop);
      if (normalizedProp) {
        normalizedInput[normalizedProp] = inputObject[prop];
      }
    }
  }
  return normalizedInput;
}
var priorities = {};
function addUnitPriority(unit, priority) {
  priorities[unit] = priority;
}
function getPrioritizedUnits(unitsObj) {
  var units = [], u2;
  for (u2 in unitsObj) {
    if (hasOwnProp(unitsObj, u2)) {
      units.push({ unit: u2, priority: priorities[u2] });
    }
  }
  units.sort(function(a2, b2) {
    return a2.priority - b2.priority;
  });
  return units;
}
function isLeapYear(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
function absFloor(number) {
  if (number < 0) {
    return Math.ceil(number) || 0;
  } else {
    return Math.floor(number);
  }
}
function toInt(argumentForCoercion) {
  var coercedNumber = +argumentForCoercion, value = 0;
  if (coercedNumber !== 0 && isFinite(coercedNumber)) {
    value = absFloor(coercedNumber);
  }
  return value;
}
function makeGetSet(unit, keepTime) {
  return function(value) {
    if (value != null) {
      set$1(this, unit, value);
      hooks.updateOffset(this, keepTime);
      return this;
    } else {
      return get2(this, unit);
    }
  };
}
function get2(mom, unit) {
  return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
}
function set$1(mom, unit, value) {
  if (mom.isValid() && !isNaN(value)) {
    if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
      value = toInt(value);
      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
        value,
        mom.month(),
        daysInMonth(value, mom.month())
      );
    } else {
      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
    }
  }
}
function stringGet(units) {
  units = normalizeUnits(units);
  if (isFunction$1(this[units])) {
    return this[units]();
  }
  return this;
}
function stringSet(units, value) {
  if (typeof units === "object") {
    units = normalizeObjectUnits(units);
    var prioritized = getPrioritizedUnits(units), i2, prioritizedLen = prioritized.length;
    for (i2 = 0; i2 < prioritizedLen; i2++) {
      this[prioritized[i2].unit](units[prioritized[i2].unit]);
    }
  } else {
    units = normalizeUnits(units);
    if (isFunction$1(this[units])) {
      return this[units](value);
    }
  }
  return this;
}
var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
regexes = {};
function addRegexToken(token2, regex, strictRegex) {
  regexes[token2] = isFunction$1(regex) ? regex : function(isStrict, localeData2) {
    return isStrict && strictRegex ? strictRegex : regex;
  };
}
function getParseRegexForToken(token2, config2) {
  if (!hasOwnProp(regexes, token2)) {
    return new RegExp(unescapeFormat(token2));
  }
  return regexes[token2](config2._strict, config2._locale);
}
function unescapeFormat(s2) {
  return regexEscape(
    s2.replace("\\", "").replace(
      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
      function(matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }
    )
  );
}
function regexEscape(s2) {
  return s2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var tokens = {};
function addParseToken(token2, callback) {
  var i2, func = callback, tokenLen;
  if (typeof token2 === "string") {
    token2 = [token2];
  }
  if (isNumber(callback)) {
    func = function(input2, array) {
      array[callback] = toInt(input2);
    };
  }
  tokenLen = token2.length;
  for (i2 = 0; i2 < tokenLen; i2++) {
    tokens[token2[i2]] = func;
  }
}
function addWeekParseToken(token2, callback) {
  addParseToken(token2, function(input2, array, config2, token3) {
    config2._w = config2._w || {};
    callback(input2, config2._w, config2, token3);
  });
}
function addTimeToArrayFromToken(token2, input2, config2) {
  if (input2 != null && hasOwnProp(tokens, token2)) {
    tokens[token2](input2, config2._a, config2, token2);
  }
}
var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
function mod(n2, x) {
  return (n2 % x + x) % x;
}
var indexOf;
if (Array.prototype.indexOf) {
  indexOf = Array.prototype.indexOf;
} else {
  indexOf = function(o) {
    var i2;
    for (i2 = 0; i2 < this.length; ++i2) {
      if (this[i2] === o) {
        return i2;
      }
    }
    return -1;
  };
}
function daysInMonth(year, month) {
  if (isNaN(year) || isNaN(month)) {
    return NaN;
  }
  var modMonth = mod(month, 12);
  year += (month - modMonth) / 12;
  return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
}
addFormatToken("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
addFormatToken("MMM", 0, 0, function(format2) {
  return this.localeData().monthsShort(this, format2);
});
addFormatToken("MMMM", 0, 0, function(format2) {
  return this.localeData().months(this, format2);
});
addUnitAlias("month", "M");
addUnitPriority("month", 8);
addRegexToken("M", match1to2);
addRegexToken("MM", match1to2, match2);
addRegexToken("MMM", function(isStrict, locale2) {
  return locale2.monthsShortRegex(isStrict);
});
addRegexToken("MMMM", function(isStrict, locale2) {
  return locale2.monthsRegex(isStrict);
});
addParseToken(["M", "MM"], function(input2, array) {
  array[MONTH] = toInt(input2) - 1;
});
addParseToken(["MMM", "MMMM"], function(input2, array, config2, token2) {
  var month = config2._locale.monthsParse(input2, token2, config2._strict);
  if (month != null) {
    array[MONTH] = month;
  } else {
    getParsingFlags(config2).invalidMonth = input2;
  }
});
var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
  "_"
), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
function localeMonths(m2, format2) {
  if (!m2) {
    return isArray$2(this._months) ? this._months : this._months["standalone"];
  }
  return isArray$2(this._months) ? this._months[m2.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m2.month()];
}
function localeMonthsShort(m2, format2) {
  if (!m2) {
    return isArray$2(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
  }
  return isArray$2(this._monthsShort) ? this._monthsShort[m2.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m2.month()];
}
function handleStrictParse(monthName, format2, strict) {
  var i2, ii, mom, llc = monthName.toLocaleLowerCase();
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
    for (i2 = 0; i2 < 12; ++i2) {
      mom = createUTC([2e3, i2]);
      this._shortMonthsParse[i2] = this.monthsShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._longMonthsParse[i2] = this.months(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format2 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeMonthsParse(monthName, format2, strict) {
  var i2, mom, regex;
  if (this._monthsParseExact) {
    return handleStrictParse.call(this, monthName, format2, strict);
  }
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
  }
  for (i2 = 0; i2 < 12; i2++) {
    mom = createUTC([2e3, i2]);
    if (strict && !this._longMonthsParse[i2]) {
      this._longMonthsParse[i2] = new RegExp(
        "^" + this.months(mom, "").replace(".", "") + "$",
        "i"
      );
      this._shortMonthsParse[i2] = new RegExp(
        "^" + this.monthsShort(mom, "").replace(".", "") + "$",
        "i"
      );
    }
    if (!strict && !this._monthsParse[i2]) {
      regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
      this._monthsParse[i2] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format2 === "MMMM" && this._longMonthsParse[i2].test(monthName)) {
      return i2;
    } else if (strict && format2 === "MMM" && this._shortMonthsParse[i2].test(monthName)) {
      return i2;
    } else if (!strict && this._monthsParse[i2].test(monthName)) {
      return i2;
    }
  }
}
function setMonth(mom, value) {
  var dayOfMonth;
  if (!mom.isValid()) {
    return mom;
  }
  if (typeof value === "string") {
    if (/^\d+$/.test(value)) {
      value = toInt(value);
    } else {
      value = mom.localeData().monthsParse(value);
      if (!isNumber(value)) {
        return mom;
      }
    }
  }
  dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
  mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
  return mom;
}
function getSetMonth(value) {
  if (value != null) {
    setMonth(this, value);
    hooks.updateOffset(this, true);
    return this;
  } else {
    return get2(this, "Month");
  }
}
function getDaysInMonth() {
  return daysInMonth(this.year(), this.month());
}
function monthsShortRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsShortStrictRegex;
    } else {
      return this._monthsShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsShortRegex")) {
      this._monthsShortRegex = defaultMonthsShortRegex;
    }
    return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
  }
}
function monthsRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsStrictRegex;
    } else {
      return this._monthsRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsRegex")) {
      this._monthsRegex = defaultMonthsRegex;
    }
    return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
  }
}
function computeMonthsParse() {
  function cmpLenRev(a2, b2) {
    return b2.length - a2.length;
  }
  var shortPieces = [], longPieces = [], mixedPieces = [], i2, mom;
  for (i2 = 0; i2 < 12; i2++) {
    mom = createUTC([2e3, i2]);
    shortPieces.push(this.monthsShort(mom, ""));
    longPieces.push(this.months(mom, ""));
    mixedPieces.push(this.months(mom, ""));
    mixedPieces.push(this.monthsShort(mom, ""));
  }
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  for (i2 = 0; i2 < 12; i2++) {
    shortPieces[i2] = regexEscape(shortPieces[i2]);
    longPieces[i2] = regexEscape(longPieces[i2]);
  }
  for (i2 = 0; i2 < 24; i2++) {
    mixedPieces[i2] = regexEscape(mixedPieces[i2]);
  }
  this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._monthsShortRegex = this._monthsRegex;
  this._monthsStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._monthsShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
}
addFormatToken("Y", 0, 0, function() {
  var y2 = this.year();
  return y2 <= 9999 ? zeroFill(y2, 4) : "+" + y2;
});
addFormatToken(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
addFormatToken(0, ["YYYY", 4], 0, "year");
addFormatToken(0, ["YYYYY", 5], 0, "year");
addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
addUnitAlias("year", "y");
addUnitPriority("year", 1);
addRegexToken("Y", matchSigned);
addRegexToken("YY", match1to2, match2);
addRegexToken("YYYY", match1to4, match4);
addRegexToken("YYYYY", match1to6, match6);
addRegexToken("YYYYYY", match1to6, match6);
addParseToken(["YYYYY", "YYYYYY"], YEAR);
addParseToken("YYYY", function(input2, array) {
  array[YEAR] = input2.length === 2 ? hooks.parseTwoDigitYear(input2) : toInt(input2);
});
addParseToken("YY", function(input2, array) {
  array[YEAR] = hooks.parseTwoDigitYear(input2);
});
addParseToken("Y", function(input2, array) {
  array[YEAR] = parseInt(input2, 10);
});
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
hooks.parseTwoDigitYear = function(input2) {
  return toInt(input2) + (toInt(input2) > 68 ? 1900 : 2e3);
};
var getSetYear = makeGetSet("FullYear", true);
function getIsLeapYear() {
  return isLeapYear(this.year());
}
function createDate(y2, m2, d2, h2, M, s2, ms) {
  var date;
  if (y2 < 100 && y2 >= 0) {
    date = new Date(y2 + 400, m2, d2, h2, M, s2, ms);
    if (isFinite(date.getFullYear())) {
      date.setFullYear(y2);
    }
  } else {
    date = new Date(y2, m2, d2, h2, M, s2, ms);
  }
  return date;
}
function createUTCDate(y2) {
  var date, args;
  if (y2 < 100 && y2 >= 0) {
    args = Array.prototype.slice.call(arguments);
    args[0] = y2 + 400;
    date = new Date(Date.UTC.apply(null, args));
    if (isFinite(date.getUTCFullYear())) {
      date.setUTCFullYear(y2);
    }
  } else {
    date = new Date(Date.UTC.apply(null, arguments));
  }
  return date;
}
function firstWeekOffset(year, dow, doy) {
  var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
  var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
  if (dayOfYear <= 0) {
    resYear = year - 1;
    resDayOfYear = daysInYear(resYear) + dayOfYear;
  } else if (dayOfYear > daysInYear(year)) {
    resYear = year + 1;
    resDayOfYear = dayOfYear - daysInYear(year);
  } else {
    resYear = year;
    resDayOfYear = dayOfYear;
  }
  return {
    year: resYear,
    dayOfYear: resDayOfYear
  };
}
function weekOfYear(mom, dow, doy) {
  var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
  if (week < 1) {
    resYear = mom.year() - 1;
    resWeek = week + weeksInYear(resYear, dow, doy);
  } else if (week > weeksInYear(mom.year(), dow, doy)) {
    resWeek = week - weeksInYear(mom.year(), dow, doy);
    resYear = mom.year() + 1;
  } else {
    resYear = mom.year();
    resWeek = week;
  }
  return {
    week: resWeek,
    year: resYear
  };
}
function weeksInYear(year, dow, doy) {
  var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
  return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}
addFormatToken("w", ["ww", 2], "wo", "week");
addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
addUnitAlias("week", "w");
addUnitAlias("isoWeek", "W");
addUnitPriority("week", 5);
addUnitPriority("isoWeek", 5);
addRegexToken("w", match1to2);
addRegexToken("ww", match1to2, match2);
addRegexToken("W", match1to2);
addRegexToken("WW", match1to2, match2);
addWeekParseToken(
  ["w", "ww", "W", "WW"],
  function(input2, week, config2, token2) {
    week[token2.substr(0, 1)] = toInt(input2);
  }
);
function localeWeek(mom) {
  return weekOfYear(mom, this._week.dow, this._week.doy).week;
}
var defaultLocaleWeek = {
  dow: 0,
  // Sunday is the first day of the week.
  doy: 6
  // The week that contains Jan 6th is the first week of the year.
};
function localeFirstDayOfWeek() {
  return this._week.dow;
}
function localeFirstDayOfYear() {
  return this._week.doy;
}
function getSetWeek(input2) {
  var week = this.localeData().week(this);
  return input2 == null ? week : this.add((input2 - week) * 7, "d");
}
function getSetISOWeek(input2) {
  var week = weekOfYear(this, 1, 4).week;
  return input2 == null ? week : this.add((input2 - week) * 7, "d");
}
addFormatToken("d", 0, "do", "day");
addFormatToken("dd", 0, 0, function(format2) {
  return this.localeData().weekdaysMin(this, format2);
});
addFormatToken("ddd", 0, 0, function(format2) {
  return this.localeData().weekdaysShort(this, format2);
});
addFormatToken("dddd", 0, 0, function(format2) {
  return this.localeData().weekdays(this, format2);
});
addFormatToken("e", 0, 0, "weekday");
addFormatToken("E", 0, 0, "isoWeekday");
addUnitAlias("day", "d");
addUnitAlias("weekday", "e");
addUnitAlias("isoWeekday", "E");
addUnitPriority("day", 11);
addUnitPriority("weekday", 11);
addUnitPriority("isoWeekday", 11);
addRegexToken("d", match1to2);
addRegexToken("e", match1to2);
addRegexToken("E", match1to2);
addRegexToken("dd", function(isStrict, locale2) {
  return locale2.weekdaysMinRegex(isStrict);
});
addRegexToken("ddd", function(isStrict, locale2) {
  return locale2.weekdaysShortRegex(isStrict);
});
addRegexToken("dddd", function(isStrict, locale2) {
  return locale2.weekdaysRegex(isStrict);
});
addWeekParseToken(["dd", "ddd", "dddd"], function(input2, week, config2, token2) {
  var weekday = config2._locale.weekdaysParse(input2, token2, config2._strict);
  if (weekday != null) {
    week.d = weekday;
  } else {
    getParsingFlags(config2).invalidWeekday = input2;
  }
});
addWeekParseToken(["d", "e", "E"], function(input2, week, config2, token2) {
  week[token2] = toInt(input2);
});
function parseWeekday(input2, locale2) {
  if (typeof input2 !== "string") {
    return input2;
  }
  if (!isNaN(input2)) {
    return parseInt(input2, 10);
  }
  input2 = locale2.weekdaysParse(input2);
  if (typeof input2 === "number") {
    return input2;
  }
  return null;
}
function parseIsoWeekday(input2, locale2) {
  if (typeof input2 === "string") {
    return locale2.weekdaysParse(input2) % 7 || 7;
  }
  return isNaN(input2) ? null : input2;
}
function shiftWeekdays(ws, n2) {
  return ws.slice(n2, 7).concat(ws.slice(0, n2));
}
var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
function localeWeekdays(m2, format2) {
  var weekdays = isArray$2(this._weekdays) ? this._weekdays : this._weekdays[m2 && m2 !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
  return m2 === true ? shiftWeekdays(weekdays, this._week.dow) : m2 ? weekdays[m2.day()] : weekdays;
}
function localeWeekdaysShort(m2) {
  return m2 === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m2 ? this._weekdaysShort[m2.day()] : this._weekdaysShort;
}
function localeWeekdaysMin(m2) {
  return m2 === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m2 ? this._weekdaysMin[m2.day()] : this._weekdaysMin;
}
function handleStrictParse$1(weekdayName, format2, strict) {
  var i2, ii, mom, llc = weekdayName.toLocaleLowerCase();
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._minWeekdaysParse = [];
    for (i2 = 0; i2 < 7; ++i2) {
      mom = createUTC([2e3, 1]).day(i2);
      this._minWeekdaysParse[i2] = this.weekdaysMin(
        mom,
        ""
      ).toLocaleLowerCase();
      this._shortWeekdaysParse[i2] = this.weekdaysShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._weekdaysParse[i2] = this.weekdays(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format2 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format2 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format2 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeWeekdaysParse(weekdayName, format2, strict) {
  var i2, mom, regex;
  if (this._weekdaysParseExact) {
    return handleStrictParse$1.call(this, weekdayName, format2, strict);
  }
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._minWeekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._fullWeekdaysParse = [];
  }
  for (i2 = 0; i2 < 7; i2++) {
    mom = createUTC([2e3, 1]).day(i2);
    if (strict && !this._fullWeekdaysParse[i2]) {
      this._fullWeekdaysParse[i2] = new RegExp(
        "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._shortWeekdaysParse[i2] = new RegExp(
        "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._minWeekdaysParse[i2] = new RegExp(
        "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
    }
    if (!this._weekdaysParse[i2]) {
      regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
      this._weekdaysParse[i2] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format2 === "dddd" && this._fullWeekdaysParse[i2].test(weekdayName)) {
      return i2;
    } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i2].test(weekdayName)) {
      return i2;
    } else if (strict && format2 === "dd" && this._minWeekdaysParse[i2].test(weekdayName)) {
      return i2;
    } else if (!strict && this._weekdaysParse[i2].test(weekdayName)) {
      return i2;
    }
  }
}
function getSetDayOfWeek(input2) {
  if (!this.isValid()) {
    return input2 != null ? this : NaN;
  }
  var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
  if (input2 != null) {
    input2 = parseWeekday(input2, this.localeData());
    return this.add(input2 - day, "d");
  } else {
    return day;
  }
}
function getSetLocaleDayOfWeek(input2) {
  if (!this.isValid()) {
    return input2 != null ? this : NaN;
  }
  var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return input2 == null ? weekday : this.add(input2 - weekday, "d");
}
function getSetISODayOfWeek(input2) {
  if (!this.isValid()) {
    return input2 != null ? this : NaN;
  }
  if (input2 != null) {
    var weekday = parseIsoWeekday(input2, this.localeData());
    return this.day(this.day() % 7 ? weekday : weekday - 7);
  } else {
    return this.day() || 7;
  }
}
function weekdaysRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysStrictRegex;
    } else {
      return this._weekdaysRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      this._weekdaysRegex = defaultWeekdaysRegex;
    }
    return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
  }
}
function weekdaysShortRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysShortStrictRegex;
    } else {
      return this._weekdaysShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysShortRegex")) {
      this._weekdaysShortRegex = defaultWeekdaysShortRegex;
    }
    return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
  }
}
function weekdaysMinRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysMinStrictRegex;
    } else {
      return this._weekdaysMinRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysMinRegex")) {
      this._weekdaysMinRegex = defaultWeekdaysMinRegex;
    }
    return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
  }
}
function computeWeekdaysParse() {
  function cmpLenRev(a2, b2) {
    return b2.length - a2.length;
  }
  var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i2, mom, minp, shortp, longp;
  for (i2 = 0; i2 < 7; i2++) {
    mom = createUTC([2e3, 1]).day(i2);
    minp = regexEscape(this.weekdaysMin(mom, ""));
    shortp = regexEscape(this.weekdaysShort(mom, ""));
    longp = regexEscape(this.weekdays(mom, ""));
    minPieces.push(minp);
    shortPieces.push(shortp);
    longPieces.push(longp);
    mixedPieces.push(minp);
    mixedPieces.push(shortp);
    mixedPieces.push(longp);
  }
  minPieces.sort(cmpLenRev);
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._weekdaysShortRegex = this._weekdaysRegex;
  this._weekdaysMinRegex = this._weekdaysRegex;
  this._weekdaysStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._weekdaysShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
  this._weekdaysMinStrictRegex = new RegExp(
    "^(" + minPieces.join("|") + ")",
    "i"
  );
}
function hFormat() {
  return this.hours() % 12 || 12;
}
function kFormat() {
  return this.hours() || 24;
}
addFormatToken("H", ["HH", 2], 0, "hour");
addFormatToken("h", ["hh", 2], 0, hFormat);
addFormatToken("k", ["kk", 2], 0, kFormat);
addFormatToken("hmm", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});
addFormatToken("hmmss", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
addFormatToken("Hmm", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2);
});
addFormatToken("Hmmss", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
function meridiem(token2, lowercase) {
  addFormatToken(token2, 0, 0, function() {
    return this.localeData().meridiem(
      this.hours(),
      this.minutes(),
      lowercase
    );
  });
}
meridiem("a", true);
meridiem("A", false);
addUnitAlias("hour", "h");
addUnitPriority("hour", 13);
function matchMeridiem(isStrict, locale2) {
  return locale2._meridiemParse;
}
addRegexToken("a", matchMeridiem);
addRegexToken("A", matchMeridiem);
addRegexToken("H", match1to2);
addRegexToken("h", match1to2);
addRegexToken("k", match1to2);
addRegexToken("HH", match1to2, match2);
addRegexToken("hh", match1to2, match2);
addRegexToken("kk", match1to2, match2);
addRegexToken("hmm", match3to4);
addRegexToken("hmmss", match5to6);
addRegexToken("Hmm", match3to4);
addRegexToken("Hmmss", match5to6);
addParseToken(["H", "HH"], HOUR);
addParseToken(["k", "kk"], function(input2, array, config2) {
  var kInput = toInt(input2);
  array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(["a", "A"], function(input2, array, config2) {
  config2._isPm = config2._locale.isPM(input2);
  config2._meridiem = input2;
});
addParseToken(["h", "hh"], function(input2, array, config2) {
  array[HOUR] = toInt(input2);
  getParsingFlags(config2).bigHour = true;
});
addParseToken("hmm", function(input2, array, config2) {
  var pos = input2.length - 2;
  array[HOUR] = toInt(input2.substr(0, pos));
  array[MINUTE] = toInt(input2.substr(pos));
  getParsingFlags(config2).bigHour = true;
});
addParseToken("hmmss", function(input2, array, config2) {
  var pos1 = input2.length - 4, pos2 = input2.length - 2;
  array[HOUR] = toInt(input2.substr(0, pos1));
  array[MINUTE] = toInt(input2.substr(pos1, 2));
  array[SECOND] = toInt(input2.substr(pos2));
  getParsingFlags(config2).bigHour = true;
});
addParseToken("Hmm", function(input2, array, config2) {
  var pos = input2.length - 2;
  array[HOUR] = toInt(input2.substr(0, pos));
  array[MINUTE] = toInt(input2.substr(pos));
});
addParseToken("Hmmss", function(input2, array, config2) {
  var pos1 = input2.length - 4, pos2 = input2.length - 2;
  array[HOUR] = toInt(input2.substr(0, pos1));
  array[MINUTE] = toInt(input2.substr(pos1, 2));
  array[SECOND] = toInt(input2.substr(pos2));
});
function localeIsPM(input2) {
  return (input2 + "").toLowerCase().charAt(0) === "p";
}
var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
function localeMeridiem(hours2, minutes2, isLower) {
  if (hours2 > 11) {
    return isLower ? "pm" : "PM";
  } else {
    return isLower ? "am" : "AM";
  }
}
var baseConfig = {
  calendar: defaultCalendar,
  longDateFormat: defaultLongDateFormat,
  invalidDate: defaultInvalidDate,
  ordinal: defaultOrdinal,
  dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
  relativeTime: defaultRelativeTime,
  months: defaultLocaleMonths,
  monthsShort: defaultLocaleMonthsShort,
  week: defaultLocaleWeek,
  weekdays: defaultLocaleWeekdays,
  weekdaysMin: defaultLocaleWeekdaysMin,
  weekdaysShort: defaultLocaleWeekdaysShort,
  meridiemParse: defaultLocaleMeridiemParse
};
var locales = {}, localeFamilies = {}, globalLocale;
function commonPrefix(arr1, arr2) {
  var i2, minl = Math.min(arr1.length, arr2.length);
  for (i2 = 0; i2 < minl; i2 += 1) {
    if (arr1[i2] !== arr2[i2]) {
      return i2;
    }
  }
  return minl;
}
function normalizeLocale(key) {
  return key ? key.toLowerCase().replace("_", "-") : key;
}
function chooseLocale(names2) {
  var i2 = 0, j, next, locale2, split;
  while (i2 < names2.length) {
    split = normalizeLocale(names2[i2]).split("-");
    j = split.length;
    next = normalizeLocale(names2[i2 + 1]);
    next = next ? next.split("-") : null;
    while (j > 0) {
      locale2 = loadLocale(split.slice(0, j).join("-"));
      if (locale2) {
        return locale2;
      }
      if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
        break;
      }
      j--;
    }
    i2++;
  }
  return globalLocale;
}
function isLocaleNameSane(name) {
  return name.match("^[^/\\\\]*$") != null;
}
function loadLocale(name) {
  var oldLocale = null, aliasedRequire;
  if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
    try {
      oldLocale = globalLocale._abbr;
      aliasedRequire = require;
      aliasedRequire("./locale/" + name);
      getSetGlobalLocale(oldLocale);
    } catch (e2) {
      locales[name] = null;
    }
  }
  return locales[name];
}
function getSetGlobalLocale(key, values) {
  var data;
  if (key) {
    if (isUndefined(values)) {
      data = getLocale(key);
    } else {
      data = defineLocale(key, values);
    }
    if (data) {
      globalLocale = data;
    } else {
      if (typeof console !== "undefined" && console.warn) {
        console.warn(
          "Locale " + key + " not found. Did you forget to load it?"
        );
      }
    }
  }
  return globalLocale._abbr;
}
function defineLocale(name, config2) {
  if (config2 !== null) {
    var locale2, parentConfig = baseConfig;
    config2.abbr = name;
    if (locales[name] != null) {
      deprecateSimple(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      );
      parentConfig = locales[name]._config;
    } else if (config2.parentLocale != null) {
      if (locales[config2.parentLocale] != null) {
        parentConfig = locales[config2.parentLocale]._config;
      } else {
        locale2 = loadLocale(config2.parentLocale);
        if (locale2 != null) {
          parentConfig = locale2._config;
        } else {
          if (!localeFamilies[config2.parentLocale]) {
            localeFamilies[config2.parentLocale] = [];
          }
          localeFamilies[config2.parentLocale].push({
            name,
            config: config2
          });
          return null;
        }
      }
    }
    locales[name] = new Locale(mergeConfigs(parentConfig, config2));
    if (localeFamilies[name]) {
      localeFamilies[name].forEach(function(x) {
        defineLocale(x.name, x.config);
      });
    }
    getSetGlobalLocale(name);
    return locales[name];
  } else {
    delete locales[name];
    return null;
  }
}
function updateLocale(name, config2) {
  if (config2 != null) {
    var locale2, tmpLocale, parentConfig = baseConfig;
    if (locales[name] != null && locales[name].parentLocale != null) {
      locales[name].set(mergeConfigs(locales[name]._config, config2));
    } else {
      tmpLocale = loadLocale(name);
      if (tmpLocale != null) {
        parentConfig = tmpLocale._config;
      }
      config2 = mergeConfigs(parentConfig, config2);
      if (tmpLocale == null) {
        config2.abbr = name;
      }
      locale2 = new Locale(config2);
      locale2.parentLocale = locales[name];
      locales[name] = locale2;
    }
    getSetGlobalLocale(name);
  } else {
    if (locales[name] != null) {
      if (locales[name].parentLocale != null) {
        locales[name] = locales[name].parentLocale;
        if (name === getSetGlobalLocale()) {
          getSetGlobalLocale(name);
        }
      } else if (locales[name] != null) {
        delete locales[name];
      }
    }
  }
  return locales[name];
}
function getLocale(key) {
  var locale2;
  if (key && key._locale && key._locale._abbr) {
    key = key._locale._abbr;
  }
  if (!key) {
    return globalLocale;
  }
  if (!isArray$2(key)) {
    locale2 = loadLocale(key);
    if (locale2) {
      return locale2;
    }
    key = [key];
  }
  return chooseLocale(key);
}
function listLocales() {
  return keys(locales);
}
function checkOverflow(m2) {
  var overflow, a2 = m2._a;
  if (a2 && getParsingFlags(m2).overflow === -2) {
    overflow = a2[MONTH] < 0 || a2[MONTH] > 11 ? MONTH : a2[DATE] < 1 || a2[DATE] > daysInMonth(a2[YEAR], a2[MONTH]) ? DATE : a2[HOUR] < 0 || a2[HOUR] > 24 || a2[HOUR] === 24 && (a2[MINUTE] !== 0 || a2[SECOND] !== 0 || a2[MILLISECOND] !== 0) ? HOUR : a2[MINUTE] < 0 || a2[MINUTE] > 59 ? MINUTE : a2[SECOND] < 0 || a2[SECOND] > 59 ? SECOND : a2[MILLISECOND] < 0 || a2[MILLISECOND] > 999 ? MILLISECOND : -1;
    if (getParsingFlags(m2)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
      overflow = DATE;
    }
    if (getParsingFlags(m2)._overflowWeeks && overflow === -1) {
      overflow = WEEK;
    }
    if (getParsingFlags(m2)._overflowWeekday && overflow === -1) {
      overflow = WEEKDAY;
    }
    getParsingFlags(m2).overflow = overflow;
  }
  return m2;
}
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, false],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, false],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, false],
  ["YYYY", /\d{4}/, false]
], isoTimes = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
  UT: 0,
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function configFromISO(config2) {
  var i2, l2, string = config2._i, match5 = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
  if (match5) {
    getParsingFlags(config2).iso = true;
    for (i2 = 0, l2 = isoDatesLen; i2 < l2; i2++) {
      if (isoDates[i2][1].exec(match5[1])) {
        dateFormat = isoDates[i2][0];
        allowTime = isoDates[i2][2] !== false;
        break;
      }
    }
    if (dateFormat == null) {
      config2._isValid = false;
      return;
    }
    if (match5[3]) {
      for (i2 = 0, l2 = isoTimesLen; i2 < l2; i2++) {
        if (isoTimes[i2][1].exec(match5[3])) {
          timeFormat = (match5[2] || " ") + isoTimes[i2][0];
          break;
        }
      }
      if (timeFormat == null) {
        config2._isValid = false;
        return;
      }
    }
    if (!allowTime && timeFormat != null) {
      config2._isValid = false;
      return;
    }
    if (match5[4]) {
      if (tzRegex.exec(match5[4])) {
        tzFormat = "Z";
      } else {
        config2._isValid = false;
        return;
      }
    }
    config2._f = dateFormat + (timeFormat || "") + (tzFormat || "");
    configFromStringAndFormat(config2);
  } else {
    config2._isValid = false;
  }
}
function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  var result = [
    untruncateYear(yearStr),
    defaultLocaleMonthsShort.indexOf(monthStr),
    parseInt(dayStr, 10),
    parseInt(hourStr, 10),
    parseInt(minuteStr, 10)
  ];
  if (secondStr) {
    result.push(parseInt(secondStr, 10));
  }
  return result;
}
function untruncateYear(yearStr) {
  var year = parseInt(yearStr, 10);
  if (year <= 49) {
    return 2e3 + year;
  } else if (year <= 999) {
    return 1900 + year;
  }
  return year;
}
function preprocessRFC2822(s2) {
  return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function checkWeekday(weekdayStr, parsedInput, config2) {
  if (weekdayStr) {
    var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
      parsedInput[0],
      parsedInput[1],
      parsedInput[2]
    ).getDay();
    if (weekdayProvided !== weekdayActual) {
      getParsingFlags(config2).weekdayMismatch = true;
      config2._isValid = false;
      return false;
    }
  }
  return true;
}
function calculateOffset(obsOffset, militaryOffset, numOffset) {
  if (obsOffset) {
    return obsOffsets[obsOffset];
  } else if (militaryOffset) {
    return 0;
  } else {
    var hm = parseInt(numOffset, 10), m2 = hm % 100, h2 = (hm - m2) / 100;
    return h2 * 60 + m2;
  }
}
function configFromRFC2822(config2) {
  var match5 = rfc2822.exec(preprocessRFC2822(config2._i)), parsedArray;
  if (match5) {
    parsedArray = extractFromRFC2822Strings(
      match5[4],
      match5[3],
      match5[2],
      match5[5],
      match5[6],
      match5[7]
    );
    if (!checkWeekday(match5[1], parsedArray, config2)) {
      return;
    }
    config2._a = parsedArray;
    config2._tzm = calculateOffset(match5[8], match5[9], match5[10]);
    config2._d = createUTCDate.apply(null, config2._a);
    config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
    getParsingFlags(config2).rfc2822 = true;
  } else {
    config2._isValid = false;
  }
}
function configFromString(config2) {
  var matched = aspNetJsonRegex.exec(config2._i);
  if (matched !== null) {
    config2._d = /* @__PURE__ */ new Date(+matched[1]);
    return;
  }
  configFromISO(config2);
  if (config2._isValid === false) {
    delete config2._isValid;
  } else {
    return;
  }
  configFromRFC2822(config2);
  if (config2._isValid === false) {
    delete config2._isValid;
  } else {
    return;
  }
  if (config2._strict) {
    config2._isValid = false;
  } else {
    hooks.createFromInputFallback(config2);
  }
}
hooks.createFromInputFallback = deprecate(
  "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
  function(config2) {
    config2._d = /* @__PURE__ */ new Date(config2._i + (config2._useUTC ? " UTC" : ""));
  }
);
function defaults(a2, b2, c2) {
  if (a2 != null) {
    return a2;
  }
  if (b2 != null) {
    return b2;
  }
  return c2;
}
function currentDateArray(config2) {
  var nowValue = new Date(hooks.now());
  if (config2._useUTC) {
    return [
      nowValue.getUTCFullYear(),
      nowValue.getUTCMonth(),
      nowValue.getUTCDate()
    ];
  }
  return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}
function configFromArray(config2) {
  var i2, date, input2 = [], currentDate, expectedWeekday, yearToUse;
  if (config2._d) {
    return;
  }
  currentDate = currentDateArray(config2);
  if (config2._w && config2._a[DATE] == null && config2._a[MONTH] == null) {
    dayOfYearFromWeekInfo(config2);
  }
  if (config2._dayOfYear != null) {
    yearToUse = defaults(config2._a[YEAR], currentDate[YEAR]);
    if (config2._dayOfYear > daysInYear(yearToUse) || config2._dayOfYear === 0) {
      getParsingFlags(config2)._overflowDayOfYear = true;
    }
    date = createUTCDate(yearToUse, 0, config2._dayOfYear);
    config2._a[MONTH] = date.getUTCMonth();
    config2._a[DATE] = date.getUTCDate();
  }
  for (i2 = 0; i2 < 3 && config2._a[i2] == null; ++i2) {
    config2._a[i2] = input2[i2] = currentDate[i2];
  }
  for (; i2 < 7; i2++) {
    config2._a[i2] = input2[i2] = config2._a[i2] == null ? i2 === 2 ? 1 : 0 : config2._a[i2];
  }
  if (config2._a[HOUR] === 24 && config2._a[MINUTE] === 0 && config2._a[SECOND] === 0 && config2._a[MILLISECOND] === 0) {
    config2._nextDay = true;
    config2._a[HOUR] = 0;
  }
  config2._d = (config2._useUTC ? createUTCDate : createDate).apply(
    null,
    input2
  );
  expectedWeekday = config2._useUTC ? config2._d.getUTCDay() : config2._d.getDay();
  if (config2._tzm != null) {
    config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
  }
  if (config2._nextDay) {
    config2._a[HOUR] = 24;
  }
  if (config2._w && typeof config2._w.d !== "undefined" && config2._w.d !== expectedWeekday) {
    getParsingFlags(config2).weekdayMismatch = true;
  }
}
function dayOfYearFromWeekInfo(config2) {
  var w2, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
  w2 = config2._w;
  if (w2.GG != null || w2.W != null || w2.E != null) {
    dow = 1;
    doy = 4;
    weekYear = defaults(
      w2.GG,
      config2._a[YEAR],
      weekOfYear(createLocal(), 1, 4).year
    );
    week = defaults(w2.W, 1);
    weekday = defaults(w2.E, 1);
    if (weekday < 1 || weekday > 7) {
      weekdayOverflow = true;
    }
  } else {
    dow = config2._locale._week.dow;
    doy = config2._locale._week.doy;
    curWeek = weekOfYear(createLocal(), dow, doy);
    weekYear = defaults(w2.gg, config2._a[YEAR], curWeek.year);
    week = defaults(w2.w, curWeek.week);
    if (w2.d != null) {
      weekday = w2.d;
      if (weekday < 0 || weekday > 6) {
        weekdayOverflow = true;
      }
    } else if (w2.e != null) {
      weekday = w2.e + dow;
      if (w2.e < 0 || w2.e > 6) {
        weekdayOverflow = true;
      }
    } else {
      weekday = dow;
    }
  }
  if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
    getParsingFlags(config2)._overflowWeeks = true;
  } else if (weekdayOverflow != null) {
    getParsingFlags(config2)._overflowWeekday = true;
  } else {
    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
    config2._a[YEAR] = temp.year;
    config2._dayOfYear = temp.dayOfYear;
  }
}
hooks.ISO_8601 = function() {
};
hooks.RFC_2822 = function() {
};
function configFromStringAndFormat(config2) {
  if (config2._f === hooks.ISO_8601) {
    configFromISO(config2);
    return;
  }
  if (config2._f === hooks.RFC_2822) {
    configFromRFC2822(config2);
    return;
  }
  config2._a = [];
  getParsingFlags(config2).empty = true;
  var string = "" + config2._i, i2, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
  tokens2 = expandFormat(config2._f, config2._locale).match(formattingTokens) || [];
  tokenLen = tokens2.length;
  for (i2 = 0; i2 < tokenLen; i2++) {
    token2 = tokens2[i2];
    parsedInput = (string.match(getParseRegexForToken(token2, config2)) || [])[0];
    if (parsedInput) {
      skipped = string.substr(0, string.indexOf(parsedInput));
      if (skipped.length > 0) {
        getParsingFlags(config2).unusedInput.push(skipped);
      }
      string = string.slice(
        string.indexOf(parsedInput) + parsedInput.length
      );
      totalParsedInputLength += parsedInput.length;
    }
    if (formatTokenFunctions[token2]) {
      if (parsedInput) {
        getParsingFlags(config2).empty = false;
      } else {
        getParsingFlags(config2).unusedTokens.push(token2);
      }
      addTimeToArrayFromToken(token2, parsedInput, config2);
    } else if (config2._strict && !parsedInput) {
      getParsingFlags(config2).unusedTokens.push(token2);
    }
  }
  getParsingFlags(config2).charsLeftOver = stringLength - totalParsedInputLength;
  if (string.length > 0) {
    getParsingFlags(config2).unusedInput.push(string);
  }
  if (config2._a[HOUR] <= 12 && getParsingFlags(config2).bigHour === true && config2._a[HOUR] > 0) {
    getParsingFlags(config2).bigHour = void 0;
  }
  getParsingFlags(config2).parsedDateParts = config2._a.slice(0);
  getParsingFlags(config2).meridiem = config2._meridiem;
  config2._a[HOUR] = meridiemFixWrap(
    config2._locale,
    config2._a[HOUR],
    config2._meridiem
  );
  era = getParsingFlags(config2).era;
  if (era !== null) {
    config2._a[YEAR] = config2._locale.erasConvertYear(era, config2._a[YEAR]);
  }
  configFromArray(config2);
  checkOverflow(config2);
}
function meridiemFixWrap(locale2, hour, meridiem2) {
  var isPm;
  if (meridiem2 == null) {
    return hour;
  }
  if (locale2.meridiemHour != null) {
    return locale2.meridiemHour(hour, meridiem2);
  } else if (locale2.isPM != null) {
    isPm = locale2.isPM(meridiem2);
    if (isPm && hour < 12) {
      hour += 12;
    }
    if (!isPm && hour === 12) {
      hour = 0;
    }
    return hour;
  } else {
    return hour;
  }
}
function configFromStringAndArray(config2) {
  var tempConfig, bestMoment, scoreToBeat, i2, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config2._f.length;
  if (configfLen === 0) {
    getParsingFlags(config2).invalidFormat = true;
    config2._d = /* @__PURE__ */ new Date(NaN);
    return;
  }
  for (i2 = 0; i2 < configfLen; i2++) {
    currentScore = 0;
    validFormatFound = false;
    tempConfig = copyConfig({}, config2);
    if (config2._useUTC != null) {
      tempConfig._useUTC = config2._useUTC;
    }
    tempConfig._f = config2._f[i2];
    configFromStringAndFormat(tempConfig);
    if (isValid2(tempConfig)) {
      validFormatFound = true;
    }
    currentScore += getParsingFlags(tempConfig).charsLeftOver;
    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
    getParsingFlags(tempConfig).score = currentScore;
    if (!bestFormatIsValid) {
      if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
        if (validFormatFound) {
          bestFormatIsValid = true;
        }
      }
    } else {
      if (currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
  }
  extend2(config2, bestMoment || tempConfig);
}
function configFromObject(config2) {
  if (config2._d) {
    return;
  }
  var i2 = normalizeObjectUnits(config2._i), dayOrDate = i2.day === void 0 ? i2.date : i2.day;
  config2._a = map(
    [i2.year, i2.month, dayOrDate, i2.hour, i2.minute, i2.second, i2.millisecond],
    function(obj) {
      return obj && parseInt(obj, 10);
    }
  );
  configFromArray(config2);
}
function createFromConfig(config2) {
  var res = new Moment(checkOverflow(prepareConfig(config2)));
  if (res._nextDay) {
    res.add(1, "d");
    res._nextDay = void 0;
  }
  return res;
}
function prepareConfig(config2) {
  var input2 = config2._i, format2 = config2._f;
  config2._locale = config2._locale || getLocale(config2._l);
  if (input2 === null || format2 === void 0 && input2 === "") {
    return createInvalid({ nullInput: true });
  }
  if (typeof input2 === "string") {
    config2._i = input2 = config2._locale.preparse(input2);
  }
  if (isMoment(input2)) {
    return new Moment(checkOverflow(input2));
  } else if (isDate(input2)) {
    config2._d = input2;
  } else if (isArray$2(format2)) {
    configFromStringAndArray(config2);
  } else if (format2) {
    configFromStringAndFormat(config2);
  } else {
    configFromInput(config2);
  }
  if (!isValid2(config2)) {
    config2._d = null;
  }
  return config2;
}
function configFromInput(config2) {
  var input2 = config2._i;
  if (isUndefined(input2)) {
    config2._d = new Date(hooks.now());
  } else if (isDate(input2)) {
    config2._d = new Date(input2.valueOf());
  } else if (typeof input2 === "string") {
    configFromString(config2);
  } else if (isArray$2(input2)) {
    config2._a = map(input2.slice(0), function(obj) {
      return parseInt(obj, 10);
    });
    configFromArray(config2);
  } else if (isObject$9(input2)) {
    configFromObject(config2);
  } else if (isNumber(input2)) {
    config2._d = new Date(input2);
  } else {
    hooks.createFromInputFallback(config2);
  }
}
function createLocalOrUTC(input2, format2, locale2, strict, isUTC) {
  var c2 = {};
  if (format2 === true || format2 === false) {
    strict = format2;
    format2 = void 0;
  }
  if (locale2 === true || locale2 === false) {
    strict = locale2;
    locale2 = void 0;
  }
  if (isObject$9(input2) && isObjectEmpty(input2) || isArray$2(input2) && input2.length === 0) {
    input2 = void 0;
  }
  c2._isAMomentObject = true;
  c2._useUTC = c2._isUTC = isUTC;
  c2._l = locale2;
  c2._i = input2;
  c2._f = format2;
  c2._strict = strict;
  return createFromConfig(c2);
}
function createLocal(input2, format2, locale2, strict) {
  return createLocalOrUTC(input2, format2, locale2, strict, false);
}
var prototypeMin = deprecate(
  "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other < this ? this : other;
    } else {
      return createInvalid();
    }
  }
), prototypeMax = deprecate(
  "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other > this ? this : other;
    } else {
      return createInvalid();
    }
  }
);
function pickBy$2(fn, moments) {
  var res, i2;
  if (moments.length === 1 && isArray$2(moments[0])) {
    moments = moments[0];
  }
  if (!moments.length) {
    return createLocal();
  }
  res = moments[0];
  for (i2 = 1; i2 < moments.length; ++i2) {
    if (!moments[i2].isValid() || moments[i2][fn](res)) {
      res = moments[i2];
    }
  }
  return res;
}
function min() {
  var args = [].slice.call(arguments, 0);
  return pickBy$2("isBefore", args);
}
function max() {
  var args = [].slice.call(arguments, 0);
  return pickBy$2("isAfter", args);
}
var now$2 = function() {
  return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
};
var ordering = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function isDurationValid(m2) {
  var key, unitHasDecimal = false, i2, orderLen = ordering.length;
  for (key in m2) {
    if (hasOwnProp(m2, key) && !(indexOf.call(ordering, key) !== -1 && (m2[key] == null || !isNaN(m2[key])))) {
      return false;
    }
  }
  for (i2 = 0; i2 < orderLen; ++i2) {
    if (m2[ordering[i2]]) {
      if (unitHasDecimal) {
        return false;
      }
      if (parseFloat(m2[ordering[i2]]) !== toInt(m2[ordering[i2]])) {
        unitHasDecimal = true;
      }
    }
  }
  return true;
}
function isValid$1() {
  return this._isValid;
}
function createInvalid$1() {
  return createDuration(NaN);
}
function Duration(duration) {
  var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
  this._isValid = isDurationValid(normalizedInput);
  this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
  minutes2 * 6e4 + // 1000 * 60
  hours2 * 1e3 * 60 * 60;
  this._days = +days2 + weeks2 * 7;
  this._months = +months2 + quarters * 3 + years2 * 12;
  this._data = {};
  this._locale = getLocale();
  this._bubble();
}
function isDuration(obj) {
  return obj instanceof Duration;
}
function absRound(number) {
  if (number < 0) {
    return Math.round(-1 * number) * -1;
  } else {
    return Math.round(number);
  }
}
function compareArrays(array1, array2, dontConvert) {
  var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i2;
  for (i2 = 0; i2 < len; i2++) {
    if (dontConvert && array1[i2] !== array2[i2] || !dontConvert && toInt(array1[i2]) !== toInt(array2[i2])) {
      diffs++;
    }
  }
  return diffs + lengthDiff;
}
function offset(token2, separator) {
  addFormatToken(token2, 0, 0, function() {
    var offset2 = this.utcOffset(), sign2 = "+";
    if (offset2 < 0) {
      offset2 = -offset2;
      sign2 = "-";
    }
    return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
  });
}
offset("Z", ":");
offset("ZZ", "");
addRegexToken("Z", matchShortOffset);
addRegexToken("ZZ", matchShortOffset);
addParseToken(["Z", "ZZ"], function(input2, array, config2) {
  config2._useUTC = true;
  config2._tzm = offsetFromString(matchShortOffset, input2);
});
var chunkOffset = /([\+\-]|\d\d)/gi;
function offsetFromString(matcher, string) {
  var matches = (string || "").match(matcher), chunk, parts, minutes2;
  if (matches === null) {
    return null;
  }
  chunk = matches[matches.length - 1] || [];
  parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
  minutes2 = +(parts[1] * 60) + toInt(parts[2]);
  return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
}
function cloneWithOffset(input2, model) {
  var res, diff2;
  if (model._isUTC) {
    res = model.clone();
    diff2 = (isMoment(input2) || isDate(input2) ? input2.valueOf() : createLocal(input2).valueOf()) - res.valueOf();
    res._d.setTime(res._d.valueOf() + diff2);
    hooks.updateOffset(res, false);
    return res;
  } else {
    return createLocal(input2).local();
  }
}
function getDateOffset(m2) {
  return -Math.round(m2._d.getTimezoneOffset());
}
hooks.updateOffset = function() {
};
function getSetOffset(input2, keepLocalTime, keepMinutes) {
  var offset2 = this._offset || 0, localAdjust;
  if (!this.isValid()) {
    return input2 != null ? this : NaN;
  }
  if (input2 != null) {
    if (typeof input2 === "string") {
      input2 = offsetFromString(matchShortOffset, input2);
      if (input2 === null) {
        return this;
      }
    } else if (Math.abs(input2) < 16 && !keepMinutes) {
      input2 = input2 * 60;
    }
    if (!this._isUTC && keepLocalTime) {
      localAdjust = getDateOffset(this);
    }
    this._offset = input2;
    this._isUTC = true;
    if (localAdjust != null) {
      this.add(localAdjust, "m");
    }
    if (offset2 !== input2) {
      if (!keepLocalTime || this._changeInProgress) {
        addSubtract(
          this,
          createDuration(input2 - offset2, "m"),
          1,
          false
        );
      } else if (!this._changeInProgress) {
        this._changeInProgress = true;
        hooks.updateOffset(this, true);
        this._changeInProgress = null;
      }
    }
    return this;
  } else {
    return this._isUTC ? offset2 : getDateOffset(this);
  }
}
function getSetZone(input2, keepLocalTime) {
  if (input2 != null) {
    if (typeof input2 !== "string") {
      input2 = -input2;
    }
    this.utcOffset(input2, keepLocalTime);
    return this;
  } else {
    return -this.utcOffset();
  }
}
function setOffsetToUTC(keepLocalTime) {
  return this.utcOffset(0, keepLocalTime);
}
function setOffsetToLocal(keepLocalTime) {
  if (this._isUTC) {
    this.utcOffset(0, keepLocalTime);
    this._isUTC = false;
    if (keepLocalTime) {
      this.subtract(getDateOffset(this), "m");
    }
  }
  return this;
}
function setOffsetToParsedOffset() {
  if (this._tzm != null) {
    this.utcOffset(this._tzm, false, true);
  } else if (typeof this._i === "string") {
    var tZone = offsetFromString(matchOffset, this._i);
    if (tZone != null) {
      this.utcOffset(tZone);
    } else {
      this.utcOffset(0, true);
    }
  }
  return this;
}
function hasAlignedHourOffset(input2) {
  if (!this.isValid()) {
    return false;
  }
  input2 = input2 ? createLocal(input2).utcOffset() : 0;
  return (this.utcOffset() - input2) % 60 === 0;
}
function isDaylightSavingTime() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function isDaylightSavingTimeShifted() {
  if (!isUndefined(this._isDSTShifted)) {
    return this._isDSTShifted;
  }
  var c2 = {}, other;
  copyConfig(c2, this);
  c2 = prepareConfig(c2);
  if (c2._a) {
    other = c2._isUTC ? createUTC(c2._a) : createLocal(c2._a);
    this._isDSTShifted = this.isValid() && compareArrays(c2._a, other.toArray()) > 0;
  } else {
    this._isDSTShifted = false;
  }
  return this._isDSTShifted;
}
function isLocal() {
  return this.isValid() ? !this._isUTC : false;
}
function isUtcOffset() {
  return this.isValid() ? this._isUTC : false;
}
function isUtc() {
  return this.isValid() ? this._isUTC && this._offset === 0 : false;
}
var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function createDuration(input2, key) {
  var duration = input2, match5 = null, sign2, ret, diffRes;
  if (isDuration(input2)) {
    duration = {
      ms: input2._milliseconds,
      d: input2._days,
      M: input2._months
    };
  } else if (isNumber(input2) || !isNaN(+input2)) {
    duration = {};
    if (key) {
      duration[key] = +input2;
    } else {
      duration.milliseconds = +input2;
    }
  } else if (match5 = aspNetRegex.exec(input2)) {
    sign2 = match5[1] === "-" ? -1 : 1;
    duration = {
      y: 0,
      d: toInt(match5[DATE]) * sign2,
      h: toInt(match5[HOUR]) * sign2,
      m: toInt(match5[MINUTE]) * sign2,
      s: toInt(match5[SECOND]) * sign2,
      ms: toInt(absRound(match5[MILLISECOND] * 1e3)) * sign2
      // the millisecond decimal point is included in the match
    };
  } else if (match5 = isoRegex.exec(input2)) {
    sign2 = match5[1] === "-" ? -1 : 1;
    duration = {
      y: parseIso(match5[2], sign2),
      M: parseIso(match5[3], sign2),
      w: parseIso(match5[4], sign2),
      d: parseIso(match5[5], sign2),
      h: parseIso(match5[6], sign2),
      m: parseIso(match5[7], sign2),
      s: parseIso(match5[8], sign2)
    };
  } else if (duration == null) {
    duration = {};
  } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
    diffRes = momentsDifference(
      createLocal(duration.from),
      createLocal(duration.to)
    );
    duration = {};
    duration.ms = diffRes.milliseconds;
    duration.M = diffRes.months;
  }
  ret = new Duration(duration);
  if (isDuration(input2) && hasOwnProp(input2, "_locale")) {
    ret._locale = input2._locale;
  }
  if (isDuration(input2) && hasOwnProp(input2, "_isValid")) {
    ret._isValid = input2._isValid;
  }
  return ret;
}
createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;
function parseIso(inp, sign2) {
  var res = inp && parseFloat(inp.replace(",", "."));
  return (isNaN(res) ? 0 : res) * sign2;
}
function positiveMomentsDifference(base, other) {
  var res = {};
  res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
  if (base.clone().add(res.months, "M").isAfter(other)) {
    --res.months;
  }
  res.milliseconds = +other - +base.clone().add(res.months, "M");
  return res;
}
function momentsDifference(base, other) {
  var res;
  if (!(base.isValid() && other.isValid())) {
    return { milliseconds: 0, months: 0 };
  }
  other = cloneWithOffset(other, base);
  if (base.isBefore(other)) {
    res = positiveMomentsDifference(base, other);
  } else {
    res = positiveMomentsDifference(other, base);
    res.milliseconds = -res.milliseconds;
    res.months = -res.months;
  }
  return res;
}
function createAdder(direction, name) {
  return function(val, period) {
    var dur, tmp;
    if (period !== null && !isNaN(+period)) {
      deprecateSimple(
        name,
        "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
      );
      tmp = val;
      val = period;
      period = tmp;
    }
    dur = createDuration(val, period);
    addSubtract(this, dur, direction);
    return this;
  };
}
function addSubtract(mom, duration, isAdding, updateOffset) {
  var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
  if (!mom.isValid()) {
    return;
  }
  updateOffset = updateOffset == null ? true : updateOffset;
  if (months2) {
    setMonth(mom, get2(mom, "Month") + months2 * isAdding);
  }
  if (days2) {
    set$1(mom, "Date", get2(mom, "Date") + days2 * isAdding);
  }
  if (milliseconds2) {
    mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
  }
  if (updateOffset) {
    hooks.updateOffset(mom, days2 || months2);
  }
}
var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
function isString(input2) {
  return typeof input2 === "string" || input2 instanceof String;
}
function isMomentInput(input2) {
  return isMoment(input2) || isDate(input2) || isString(input2) || isNumber(input2) || isNumberOrStringArray(input2) || isMomentInputObject(input2) || input2 === null || input2 === void 0;
}
function isMomentInputObject(input2) {
  var objectTest = isObject$9(input2) && !isObjectEmpty(input2), propertyTest = false, properties = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], i2, property2, propertyLen = properties.length;
  for (i2 = 0; i2 < propertyLen; i2 += 1) {
    property2 = properties[i2];
    propertyTest = propertyTest || hasOwnProp(input2, property2);
  }
  return objectTest && propertyTest;
}
function isNumberOrStringArray(input2) {
  var arrayTest = isArray$2(input2), dataTypeTest = false;
  if (arrayTest) {
    dataTypeTest = input2.filter(function(item) {
      return !isNumber(item) && isString(input2);
    }).length === 0;
  }
  return arrayTest && dataTypeTest;
}
function isCalendarSpec(input2) {
  var objectTest = isObject$9(input2) && !isObjectEmpty(input2), propertyTest = false, properties = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], i2, property2;
  for (i2 = 0; i2 < properties.length; i2 += 1) {
    property2 = properties[i2];
    propertyTest = propertyTest || hasOwnProp(input2, property2);
  }
  return objectTest && propertyTest;
}
function getCalendarFormat(myMoment, now2) {
  var diff2 = myMoment.diff(now2, "days", true);
  return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
}
function calendar$1(time, formats) {
  if (arguments.length === 1) {
    if (!arguments[0]) {
      time = void 0;
      formats = void 0;
    } else if (isMomentInput(arguments[0])) {
      time = arguments[0];
      formats = void 0;
    } else if (isCalendarSpec(arguments[0])) {
      formats = arguments[0];
      time = void 0;
    }
  }
  var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction$1(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
  return this.format(
    output || this.localeData().calendar(format2, this, createLocal(now2))
  );
}
function clone$5() {
  return new Moment(this);
}
function isAfter(input2, units) {
  var localInput = isMoment(input2) ? input2 : createLocal(input2);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() > localInput.valueOf();
  } else {
    return localInput.valueOf() < this.clone().startOf(units).valueOf();
  }
}
function isBefore(input2, units) {
  var localInput = isMoment(input2) ? input2 : createLocal(input2);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() < localInput.valueOf();
  } else {
    return this.clone().endOf(units).valueOf() < localInput.valueOf();
  }
}
function isBetween(from2, to2, units, inclusivity) {
  var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
  if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
    return false;
  }
  inclusivity = inclusivity || "()";
  return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
}
function isSame(input2, units) {
  var localInput = isMoment(input2) ? input2 : createLocal(input2), inputMs;
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() === localInput.valueOf();
  } else {
    inputMs = localInput.valueOf();
    return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
  }
}
function isSameOrAfter(input2, units) {
  return this.isSame(input2, units) || this.isAfter(input2, units);
}
function isSameOrBefore(input2, units) {
  return this.isSame(input2, units) || this.isBefore(input2, units);
}
function diff(input2, units, asFloat) {
  var that, zoneDelta, output;
  if (!this.isValid()) {
    return NaN;
  }
  that = cloneWithOffset(input2, this);
  if (!that.isValid()) {
    return NaN;
  }
  zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
  units = normalizeUnits(units);
  switch (units) {
    case "year":
      output = monthDiff(this, that) / 12;
      break;
    case "month":
      output = monthDiff(this, that);
      break;
    case "quarter":
      output = monthDiff(this, that) / 3;
      break;
    case "second":
      output = (this - that) / 1e3;
      break;
    case "minute":
      output = (this - that) / 6e4;
      break;
    case "hour":
      output = (this - that) / 36e5;
      break;
    case "day":
      output = (this - that - zoneDelta) / 864e5;
      break;
    case "week":
      output = (this - that - zoneDelta) / 6048e5;
      break;
    default:
      output = this - that;
  }
  return asFloat ? output : absFloor(output);
}
function monthDiff(a2, b2) {
  if (a2.date() < b2.date()) {
    return -monthDiff(b2, a2);
  }
  var wholeMonthDiff = (b2.year() - a2.year()) * 12 + (b2.month() - a2.month()), anchor = a2.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
  if (b2 - anchor < 0) {
    anchor2 = a2.clone().add(wholeMonthDiff - 1, "months");
    adjust = (b2 - anchor) / (anchor - anchor2);
  } else {
    anchor2 = a2.clone().add(wholeMonthDiff + 1, "months");
    adjust = (b2 - anchor) / (anchor2 - anchor);
  }
  return -(wholeMonthDiff + adjust) || 0;
}
hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function toString$1() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function toISOString(keepOffset) {
  if (!this.isValid()) {
    return null;
  }
  var utc = keepOffset !== true, m2 = utc ? this.clone().utc() : this;
  if (m2.year() < 0 || m2.year() > 9999) {
    return formatMoment(
      m2,
      utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
    );
  }
  if (isFunction$1(Date.prototype.toISOString)) {
    if (utc) {
      return this.toDate().toISOString();
    } else {
      return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m2, "Z"));
    }
  }
  return formatMoment(
    m2,
    utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
  );
}
function inspect() {
  if (!this.isValid()) {
    return "moment.invalid(/* " + this._i + " */)";
  }
  var func = "moment", zone = "", prefix, year, datetime, suffix;
  if (!this.isLocal()) {
    func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
    zone = "Z";
  }
  prefix = "[" + func + '("]';
  year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
  datetime = "-MM-DD[T]HH:mm:ss.SSS";
  suffix = zone + '[")]';
  return this.format(prefix + year + datetime + suffix);
}
function format(inputString) {
  if (!inputString) {
    inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
  }
  var output = formatMoment(this, inputString);
  return this.localeData().postformat(output);
}
function from(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function fromNow(withoutSuffix) {
  return this.from(createLocal(), withoutSuffix);
}
function to(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function toNow(withoutSuffix) {
  return this.to(createLocal(), withoutSuffix);
}
function locale(key) {
  var newLocaleData;
  if (key === void 0) {
    return this._locale._abbr;
  } else {
    newLocaleData = getLocale(key);
    if (newLocaleData != null) {
      this._locale = newLocaleData;
    }
    return this;
  }
}
var lang = deprecate(
  "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
  function(key) {
    if (key === void 0) {
      return this.localeData();
    } else {
      return this.locale(key);
    }
  }
);
function localeData() {
  return this._locale;
}
var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
function mod$1(dividend, divisor) {
  return (dividend % divisor + divisor) % divisor;
}
function localStartOfDate(y2, m2, d2) {
  if (y2 < 100 && y2 >= 0) {
    return new Date(y2 + 400, m2, d2) - MS_PER_400_YEARS;
  } else {
    return new Date(y2, m2, d2).valueOf();
  }
}
function utcStartOfDate(y2, m2, d2) {
  if (y2 < 100 && y2 >= 0) {
    return Date.UTC(y2 + 400, m2, d2) - MS_PER_400_YEARS;
  } else {
    return Date.UTC(y2, m2, d2);
  }
}
function startOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year(), 0, 1);
      break;
    case "quarter":
      time = startOfDate(
        this.year(),
        this.month() - this.month() % 3,
        1
      );
      break;
    case "month":
      time = startOfDate(this.year(), this.month(), 1);
      break;
    case "week":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday()
      );
      break;
    case "isoWeek":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1)
      );
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date());
      break;
    case "hour":
      time = this._d.valueOf();
      time -= mod$1(
        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      );
      break;
    case "minute":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_MINUTE);
      break;
    case "second":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_SECOND);
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function endOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      time = startOfDate(
        this.year(),
        this.month() - this.month() % 3 + 3,
        1
      ) - 1;
      break;
    case "month":
      time = startOfDate(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday() + 7
      ) - 1;
      break;
    case "isoWeek":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1) + 7
      ) - 1;
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      time = this._d.valueOf();
      time += MS_PER_HOUR - mod$1(
        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      ) - 1;
      break;
    case "minute":
      time = this._d.valueOf();
      time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
      break;
    case "second":
      time = this._d.valueOf();
      time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function valueOf() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function unix() {
  return Math.floor(this.valueOf() / 1e3);
}
function toDate() {
  return new Date(this.valueOf());
}
function toArray() {
  var m2 = this;
  return [
    m2.year(),
    m2.month(),
    m2.date(),
    m2.hour(),
    m2.minute(),
    m2.second(),
    m2.millisecond()
  ];
}
function toObject() {
  var m2 = this;
  return {
    years: m2.year(),
    months: m2.month(),
    date: m2.date(),
    hours: m2.hours(),
    minutes: m2.minutes(),
    seconds: m2.seconds(),
    milliseconds: m2.milliseconds()
  };
}
function toJSON() {
  return this.isValid() ? this.toISOString() : null;
}
function isValid$2() {
  return isValid2(this);
}
function parsingFlags() {
  return extend2({}, getParsingFlags(this));
}
function invalidAt() {
  return getParsingFlags(this).overflow;
}
function creationData() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
addFormatToken("N", 0, 0, "eraAbbr");
addFormatToken("NN", 0, 0, "eraAbbr");
addFormatToken("NNN", 0, 0, "eraAbbr");
addFormatToken("NNNN", 0, 0, "eraName");
addFormatToken("NNNNN", 0, 0, "eraNarrow");
addFormatToken("y", ["y", 1], "yo", "eraYear");
addFormatToken("y", ["yy", 2], 0, "eraYear");
addFormatToken("y", ["yyy", 3], 0, "eraYear");
addFormatToken("y", ["yyyy", 4], 0, "eraYear");
addRegexToken("N", matchEraAbbr);
addRegexToken("NN", matchEraAbbr);
addRegexToken("NNN", matchEraAbbr);
addRegexToken("NNNN", matchEraName);
addRegexToken("NNNNN", matchEraNarrow);
addParseToken(
  ["N", "NN", "NNN", "NNNN", "NNNNN"],
  function(input2, array, config2, token2) {
    var era = config2._locale.erasParse(input2, token2, config2._strict);
    if (era) {
      getParsingFlags(config2).era = era;
    } else {
      getParsingFlags(config2).invalidEra = input2;
    }
  }
);
addRegexToken("y", matchUnsigned);
addRegexToken("yy", matchUnsigned);
addRegexToken("yyy", matchUnsigned);
addRegexToken("yyyy", matchUnsigned);
addRegexToken("yo", matchEraYearOrdinal);
addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
addParseToken(["yo"], function(input2, array, config2, token2) {
  var match5;
  if (config2._locale._eraYearOrdinalRegex) {
    match5 = input2.match(config2._locale._eraYearOrdinalRegex);
  }
  if (config2._locale.eraYearOrdinalParse) {
    array[YEAR] = config2._locale.eraYearOrdinalParse(input2, match5);
  } else {
    array[YEAR] = parseInt(input2, 10);
  }
});
function localeEras(m2, format2) {
  var i2, l2, date, eras = this._eras || getLocale("en")._eras;
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    switch (typeof eras[i2].since) {
      case "string":
        date = hooks(eras[i2].since).startOf("day");
        eras[i2].since = date.valueOf();
        break;
    }
    switch (typeof eras[i2].until) {
      case "undefined":
        eras[i2].until = Infinity;
        break;
      case "string":
        date = hooks(eras[i2].until).startOf("day").valueOf();
        eras[i2].until = date.valueOf();
        break;
    }
  }
  return eras;
}
function localeErasParse(eraName, format2, strict) {
  var i2, l2, eras = this.eras(), name, abbr, narrow;
  eraName = eraName.toUpperCase();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    name = eras[i2].name.toUpperCase();
    abbr = eras[i2].abbr.toUpperCase();
    narrow = eras[i2].narrow.toUpperCase();
    if (strict) {
      switch (format2) {
        case "N":
        case "NN":
        case "NNN":
          if (abbr === eraName) {
            return eras[i2];
          }
          break;
        case "NNNN":
          if (name === eraName) {
            return eras[i2];
          }
          break;
        case "NNNNN":
          if (narrow === eraName) {
            return eras[i2];
          }
          break;
      }
    } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
      return eras[i2];
    }
  }
}
function localeErasConvertYear(era, year) {
  var dir = era.since <= era.until ? 1 : -1;
  if (year === void 0) {
    return hooks(era.since).year();
  } else {
    return hooks(era.since).year() + (year - era.offset) * dir;
  }
}
function getEraName() {
  var i2, l2, val, eras = this.localeData().eras();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until) {
      return eras[i2].name;
    }
    if (eras[i2].until <= val && val <= eras[i2].since) {
      return eras[i2].name;
    }
  }
  return "";
}
function getEraNarrow() {
  var i2, l2, val, eras = this.localeData().eras();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until) {
      return eras[i2].narrow;
    }
    if (eras[i2].until <= val && val <= eras[i2].since) {
      return eras[i2].narrow;
    }
  }
  return "";
}
function getEraAbbr() {
  var i2, l2, val, eras = this.localeData().eras();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until) {
      return eras[i2].abbr;
    }
    if (eras[i2].until <= val && val <= eras[i2].since) {
      return eras[i2].abbr;
    }
  }
  return "";
}
function getEraYear() {
  var i2, l2, dir, val, eras = this.localeData().eras();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    dir = eras[i2].since <= eras[i2].until ? 1 : -1;
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until || eras[i2].until <= val && val <= eras[i2].since) {
      return (this.year() - hooks(eras[i2].since).year()) * dir + eras[i2].offset;
    }
  }
  return this.year();
}
function erasNameRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNameRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNameRegex : this._erasRegex;
}
function erasAbbrRegex(isStrict) {
  if (!hasOwnProp(this, "_erasAbbrRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasAbbrRegex : this._erasRegex;
}
function erasNarrowRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNarrowRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNarrowRegex : this._erasRegex;
}
function matchEraAbbr(isStrict, locale2) {
  return locale2.erasAbbrRegex(isStrict);
}
function matchEraName(isStrict, locale2) {
  return locale2.erasNameRegex(isStrict);
}
function matchEraNarrow(isStrict, locale2) {
  return locale2.erasNarrowRegex(isStrict);
}
function matchEraYearOrdinal(isStrict, locale2) {
  return locale2._eraYearOrdinalRegex || matchUnsigned;
}
function computeErasParse() {
  var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i2, l2, eras = this.eras();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    namePieces.push(regexEscape(eras[i2].name));
    abbrPieces.push(regexEscape(eras[i2].abbr));
    narrowPieces.push(regexEscape(eras[i2].narrow));
    mixedPieces.push(regexEscape(eras[i2].name));
    mixedPieces.push(regexEscape(eras[i2].abbr));
    mixedPieces.push(regexEscape(eras[i2].narrow));
  }
  this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
  this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
  this._erasNarrowRegex = new RegExp(
    "^(" + narrowPieces.join("|") + ")",
    "i"
  );
}
addFormatToken(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
addFormatToken(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function addWeekYearFormatToken(token2, getter) {
  addFormatToken(0, [token2, token2.length], 0, getter);
}
addWeekYearFormatToken("gggg", "weekYear");
addWeekYearFormatToken("ggggg", "weekYear");
addWeekYearFormatToken("GGGG", "isoWeekYear");
addWeekYearFormatToken("GGGGG", "isoWeekYear");
addUnitAlias("weekYear", "gg");
addUnitAlias("isoWeekYear", "GG");
addUnitPriority("weekYear", 1);
addUnitPriority("isoWeekYear", 1);
addRegexToken("G", matchSigned);
addRegexToken("g", matchSigned);
addRegexToken("GG", match1to2, match2);
addRegexToken("gg", match1to2, match2);
addRegexToken("GGGG", match1to4, match4);
addRegexToken("gggg", match1to4, match4);
addRegexToken("GGGGG", match1to6, match6);
addRegexToken("ggggg", match1to6, match6);
addWeekParseToken(
  ["gggg", "ggggg", "GGGG", "GGGGG"],
  function(input2, week, config2, token2) {
    week[token2.substr(0, 2)] = toInt(input2);
  }
);
addWeekParseToken(["gg", "GG"], function(input2, week, config2, token2) {
  week[token2] = hooks.parseTwoDigitYear(input2);
});
function getSetWeekYear(input2) {
  return getSetWeekYearHelper.call(
    this,
    input2,
    this.week(),
    this.weekday(),
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function getSetISOWeekYear(input2) {
  return getSetWeekYearHelper.call(
    this,
    input2,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function getISOWeeksInYear() {
  return weeksInYear(this.year(), 1, 4);
}
function getISOWeeksInISOWeekYear() {
  return weeksInYear(this.isoWeekYear(), 1, 4);
}
function getWeeksInYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}
function getWeeksInWeekYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
}
function getSetWeekYearHelper(input2, week, weekday, dow, doy) {
  var weeksTarget;
  if (input2 == null) {
    return weekOfYear(this, dow, doy).year;
  } else {
    weeksTarget = weeksInYear(input2, dow, doy);
    if (week > weeksTarget) {
      week = weeksTarget;
    }
    return setWeekAll.call(this, input2, week, weekday, dow, doy);
  }
}
function setWeekAll(weekYear, week, weekday, dow, doy) {
  var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
  this.year(date.getUTCFullYear());
  this.month(date.getUTCMonth());
  this.date(date.getUTCDate());
  return this;
}
addFormatToken("Q", 0, "Qo", "quarter");
addUnitAlias("quarter", "Q");
addUnitPriority("quarter", 7);
addRegexToken("Q", match1);
addParseToken("Q", function(input2, array) {
  array[MONTH] = (toInt(input2) - 1) * 3;
});
function getSetQuarter(input2) {
  return input2 == null ? Math.ceil((this.month() + 1) / 3) : this.month((input2 - 1) * 3 + this.month() % 3);
}
addFormatToken("D", ["DD", 2], "Do", "date");
addUnitAlias("date", "D");
addUnitPriority("date", 9);
addRegexToken("D", match1to2);
addRegexToken("DD", match1to2, match2);
addRegexToken("Do", function(isStrict, locale2) {
  return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
});
addParseToken(["D", "DD"], DATE);
addParseToken("Do", function(input2, array) {
  array[DATE] = toInt(input2.match(match1to2)[0]);
});
var getSetDayOfMonth = makeGetSet("Date", true);
addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
addUnitAlias("dayOfYear", "DDD");
addUnitPriority("dayOfYear", 4);
addRegexToken("DDD", match1to3);
addRegexToken("DDDD", match3);
addParseToken(["DDD", "DDDD"], function(input2, array, config2) {
  config2._dayOfYear = toInt(input2);
});
function getSetDayOfYear(input2) {
  var dayOfYear = Math.round(
    (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
  ) + 1;
  return input2 == null ? dayOfYear : this.add(input2 - dayOfYear, "d");
}
addFormatToken("m", ["mm", 2], 0, "minute");
addUnitAlias("minute", "m");
addUnitPriority("minute", 14);
addRegexToken("m", match1to2);
addRegexToken("mm", match1to2, match2);
addParseToken(["m", "mm"], MINUTE);
var getSetMinute = makeGetSet("Minutes", false);
addFormatToken("s", ["ss", 2], 0, "second");
addUnitAlias("second", "s");
addUnitPriority("second", 15);
addRegexToken("s", match1to2);
addRegexToken("ss", match1to2, match2);
addParseToken(["s", "ss"], SECOND);
var getSetSecond = makeGetSet("Seconds", false);
addFormatToken("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
addFormatToken(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
addFormatToken(0, ["SSS", 3], 0, "millisecond");
addFormatToken(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
addFormatToken(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
addFormatToken(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
addFormatToken(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
addUnitAlias("millisecond", "ms");
addUnitPriority("millisecond", 16);
addRegexToken("S", match1to3, match1);
addRegexToken("SS", match1to3, match2);
addRegexToken("SSS", match1to3, match3);
var token, getSetMillisecond;
for (token = "SSSS"; token.length <= 9; token += "S") {
  addRegexToken(token, matchUnsigned);
}
function parseMs(input2, array) {
  array[MILLISECOND] = toInt(("0." + input2) * 1e3);
}
for (token = "S"; token.length <= 9; token += "S") {
  addParseToken(token, parseMs);
}
getSetMillisecond = makeGetSet("Milliseconds", false);
addFormatToken("z", 0, 0, "zoneAbbr");
addFormatToken("zz", 0, 0, "zoneName");
function getZoneAbbr() {
  return this._isUTC ? "UTC" : "";
}
function getZoneName() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var proto = Moment.prototype;
proto.add = add;
proto.calendar = calendar$1;
proto.clone = clone$5;
proto.diff = diff;
proto.endOf = endOf;
proto.format = format;
proto.from = from;
proto.fromNow = fromNow;
proto.to = to;
proto.toNow = toNow;
proto.get = stringGet;
proto.invalidAt = invalidAt;
proto.isAfter = isAfter;
proto.isBefore = isBefore;
proto.isBetween = isBetween;
proto.isSame = isSame;
proto.isSameOrAfter = isSameOrAfter;
proto.isSameOrBefore = isSameOrBefore;
proto.isValid = isValid$2;
proto.lang = lang;
proto.locale = locale;
proto.localeData = localeData;
proto.max = prototypeMax;
proto.min = prototypeMin;
proto.parsingFlags = parsingFlags;
proto.set = stringSet;
proto.startOf = startOf;
proto.subtract = subtract;
proto.toArray = toArray;
proto.toObject = toObject;
proto.toDate = toDate;
proto.toISOString = toISOString;
proto.inspect = inspect;
if (typeof Symbol !== "undefined" && Symbol.for != null) {
  proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
    return "Moment<" + this.format() + ">";
  };
}
proto.toJSON = toJSON;
proto.toString = toString$1;
proto.unix = unix;
proto.valueOf = valueOf;
proto.creationData = creationData;
proto.eraName = getEraName;
proto.eraNarrow = getEraNarrow;
proto.eraAbbr = getEraAbbr;
proto.eraYear = getEraYear;
proto.year = getSetYear;
proto.isLeapYear = getIsLeapYear;
proto.weekYear = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;
proto.quarter = proto.quarters = getSetQuarter;
proto.month = getSetMonth;
proto.daysInMonth = getDaysInMonth;
proto.week = proto.weeks = getSetWeek;
proto.isoWeek = proto.isoWeeks = getSetISOWeek;
proto.weeksInYear = getWeeksInYear;
proto.weeksInWeekYear = getWeeksInWeekYear;
proto.isoWeeksInYear = getISOWeeksInYear;
proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
proto.date = getSetDayOfMonth;
proto.day = proto.days = getSetDayOfWeek;
proto.weekday = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear = getSetDayOfYear;
proto.hour = proto.hours = getSetHour;
proto.minute = proto.minutes = getSetMinute;
proto.second = proto.seconds = getSetSecond;
proto.millisecond = proto.milliseconds = getSetMillisecond;
proto.utcOffset = getSetOffset;
proto.utc = setOffsetToUTC;
proto.local = setOffsetToLocal;
proto.parseZone = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST = isDaylightSavingTime;
proto.isLocal = isLocal;
proto.isUtcOffset = isUtcOffset;
proto.isUtc = isUtc;
proto.isUTC = isUtc;
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;
proto.dates = deprecate(
  "dates accessor is deprecated. Use date instead.",
  getSetDayOfMonth
);
proto.months = deprecate(
  "months accessor is deprecated. Use month instead",
  getSetMonth
);
proto.years = deprecate(
  "years accessor is deprecated. Use year instead",
  getSetYear
);
proto.zone = deprecate(
  "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
  getSetZone
);
proto.isDSTShifted = deprecate(
  "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
  isDaylightSavingTimeShifted
);
function createUnix(input2) {
  return createLocal(input2 * 1e3);
}
function createInZone() {
  return createLocal.apply(null, arguments).parseZone();
}
function preParsePostFormat(string) {
  return string;
}
var proto$1 = Locale.prototype;
proto$1.calendar = calendar;
proto$1.longDateFormat = longDateFormat;
proto$1.invalidDate = invalidDate;
proto$1.ordinal = ordinal;
proto$1.preparse = preParsePostFormat;
proto$1.postformat = preParsePostFormat;
proto$1.relativeTime = relativeTime;
proto$1.pastFuture = pastFuture;
proto$1.set = set;
proto$1.eras = localeEras;
proto$1.erasParse = localeErasParse;
proto$1.erasConvertYear = localeErasConvertYear;
proto$1.erasAbbrRegex = erasAbbrRegex;
proto$1.erasNameRegex = erasNameRegex;
proto$1.erasNarrowRegex = erasNarrowRegex;
proto$1.months = localeMonths;
proto$1.monthsShort = localeMonthsShort;
proto$1.monthsParse = localeMonthsParse;
proto$1.monthsRegex = monthsRegex;
proto$1.monthsShortRegex = monthsShortRegex;
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;
proto$1.weekdays = localeWeekdays;
proto$1.weekdaysMin = localeWeekdaysMin;
proto$1.weekdaysShort = localeWeekdaysShort;
proto$1.weekdaysParse = localeWeekdaysParse;
proto$1.weekdaysRegex = weekdaysRegex;
proto$1.weekdaysShortRegex = weekdaysShortRegex;
proto$1.weekdaysMinRegex = weekdaysMinRegex;
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;
function get$1(format2, index2, field, setter) {
  var locale2 = getLocale(), utc = createUTC().set(setter, index2);
  return locale2[field](utc, format2);
}
function listMonthsImpl(format2, index2, field) {
  if (isNumber(format2)) {
    index2 = format2;
    format2 = void 0;
  }
  format2 = format2 || "";
  if (index2 != null) {
    return get$1(format2, index2, field, "month");
  }
  var i2, out = [];
  for (i2 = 0; i2 < 12; i2++) {
    out[i2] = get$1(format2, i2, field, "month");
  }
  return out;
}
function listWeekdaysImpl(localeSorted, format2, index2, field) {
  if (typeof localeSorted === "boolean") {
    if (isNumber(format2)) {
      index2 = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  } else {
    format2 = localeSorted;
    index2 = format2;
    localeSorted = false;
    if (isNumber(format2)) {
      index2 = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  }
  var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i2, out = [];
  if (index2 != null) {
    return get$1(format2, (index2 + shift) % 7, field, "day");
  }
  for (i2 = 0; i2 < 7; i2++) {
    out[i2] = get$1(format2, (i2 + shift) % 7, field, "day");
  }
  return out;
}
function listMonths(format2, index2) {
  return listMonthsImpl(format2, index2, "months");
}
function listMonthsShort(format2, index2) {
  return listMonthsImpl(format2, index2, "monthsShort");
}
function listWeekdays(localeSorted, format2, index2) {
  return listWeekdaysImpl(localeSorted, format2, index2, "weekdays");
}
function listWeekdaysShort(localeSorted, format2, index2) {
  return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysShort");
}
function listWeekdaysMin(localeSorted, format2, index2) {
  return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysMin");
}
getSetGlobalLocale("en", {
  eras: [
    {
      since: "0001-01-01",
      until: Infinity,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -Infinity,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(number) {
    var b2 = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b2 === 1 ? "st" : b2 === 2 ? "nd" : b2 === 3 ? "rd" : "th";
    return number + output;
  }
});
hooks.lang = deprecate(
  "moment.lang is deprecated. Use moment.locale instead.",
  getSetGlobalLocale
);
hooks.langData = deprecate(
  "moment.langData is deprecated. Use moment.localeData instead.",
  getLocale
);
var mathAbs = Math.abs;
function abs() {
  var data = this._data;
  this._milliseconds = mathAbs(this._milliseconds);
  this._days = mathAbs(this._days);
  this._months = mathAbs(this._months);
  data.milliseconds = mathAbs(data.milliseconds);
  data.seconds = mathAbs(data.seconds);
  data.minutes = mathAbs(data.minutes);
  data.hours = mathAbs(data.hours);
  data.months = mathAbs(data.months);
  data.years = mathAbs(data.years);
  return this;
}
function addSubtract$1(duration, input2, value, direction) {
  var other = createDuration(input2, value);
  duration._milliseconds += direction * other._milliseconds;
  duration._days += direction * other._days;
  duration._months += direction * other._months;
  return duration._bubble();
}
function add$1(input2, value) {
  return addSubtract$1(this, input2, value, 1);
}
function subtract$1(input2, value) {
  return addSubtract$1(this, input2, value, -1);
}
function absCeil(number) {
  if (number < 0) {
    return Math.floor(number);
  } else {
    return Math.ceil(number);
  }
}
function bubble() {
  var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
  if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
    milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
    days2 = 0;
    months2 = 0;
  }
  data.milliseconds = milliseconds2 % 1e3;
  seconds2 = absFloor(milliseconds2 / 1e3);
  data.seconds = seconds2 % 60;
  minutes2 = absFloor(seconds2 / 60);
  data.minutes = minutes2 % 60;
  hours2 = absFloor(minutes2 / 60);
  data.hours = hours2 % 24;
  days2 += absFloor(hours2 / 24);
  monthsFromDays = absFloor(daysToMonths(days2));
  months2 += monthsFromDays;
  days2 -= absCeil(monthsToDays(monthsFromDays));
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  data.days = days2;
  data.months = months2;
  data.years = years2;
  return this;
}
function daysToMonths(days2) {
  return days2 * 4800 / 146097;
}
function monthsToDays(months2) {
  return months2 * 146097 / 4800;
}
function as(units) {
  if (!this.isValid()) {
    return NaN;
  }
  var days2, months2, milliseconds2 = this._milliseconds;
  units = normalizeUnits(units);
  if (units === "month" || units === "quarter" || units === "year") {
    days2 = this._days + milliseconds2 / 864e5;
    months2 = this._months + daysToMonths(days2);
    switch (units) {
      case "month":
        return months2;
      case "quarter":
        return months2 / 3;
      case "year":
        return months2 / 12;
    }
  } else {
    days2 = this._days + Math.round(monthsToDays(this._months));
    switch (units) {
      case "week":
        return days2 / 7 + milliseconds2 / 6048e5;
      case "day":
        return days2 + milliseconds2 / 864e5;
      case "hour":
        return days2 * 24 + milliseconds2 / 36e5;
      case "minute":
        return days2 * 1440 + milliseconds2 / 6e4;
      case "second":
        return days2 * 86400 + milliseconds2 / 1e3;
      case "millisecond":
        return Math.floor(days2 * 864e5) + milliseconds2;
      default:
        throw new Error("Unknown unit " + units);
    }
  }
}
function valueOf$1() {
  if (!this.isValid()) {
    return NaN;
  }
  return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
}
function makeAs(alias) {
  return function() {
    return this.as(alias);
  };
}
var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
function clone$1$1() {
  return createDuration(this);
}
function get$2(units) {
  units = normalizeUnits(units);
  return this.isValid() ? this[units + "s"]() : NaN;
}
function makeGetter(name) {
  return function() {
    return this.isValid() ? this._data[name] : NaN;
  };
}
var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
function weeks() {
  return absFloor(this.days() / 7);
}
var round = Math.round, thresholds = {
  ss: 44,
  // a few seconds to seconds
  s: 45,
  // seconds to minute
  m: 45,
  // minutes to hour
  h: 22,
  // hours to day
  d: 26,
  // days to month/week
  w: null,
  // weeks to month
  M: 11
  // months to year
};
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
  return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}
function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
  var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a2 = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
  if (thresholds2.w != null) {
    a2 = a2 || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
  }
  a2 = a2 || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
  a2[2] = withoutSuffix;
  a2[3] = +posNegDuration > 0;
  a2[4] = locale2;
  return substituteTimeAgo.apply(null, a2);
}
function getSetRelativeTimeRounding(roundingFunction) {
  if (roundingFunction === void 0) {
    return round;
  }
  if (typeof roundingFunction === "function") {
    round = roundingFunction;
    return true;
  }
  return false;
}
function getSetRelativeTimeThreshold(threshold, limit) {
  if (thresholds[threshold] === void 0) {
    return false;
  }
  if (limit === void 0) {
    return thresholds[threshold];
  }
  thresholds[threshold] = limit;
  if (threshold === "s") {
    thresholds.ss = limit - 1;
  }
  return true;
}
function humanize(argWithSuffix, argThresholds) {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var withSuffix = false, th = thresholds, locale2, output;
  if (typeof argWithSuffix === "object") {
    argThresholds = argWithSuffix;
    argWithSuffix = false;
  }
  if (typeof argWithSuffix === "boolean") {
    withSuffix = argWithSuffix;
  }
  if (typeof argThresholds === "object") {
    th = Object.assign({}, thresholds, argThresholds);
    if (argThresholds.s != null && argThresholds.ss == null) {
      th.ss = argThresholds.s - 1;
    }
  }
  locale2 = this.localeData();
  output = relativeTime$1(this, !withSuffix, th, locale2);
  if (withSuffix) {
    output = locale2.pastFuture(+this, output);
  }
  return locale2.postformat(output);
}
var abs$1 = Math.abs;
function sign(x) {
  return (x > 0) - (x < 0) || +x;
}
function toISOString$1() {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s2, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
  if (!total) {
    return "P0D";
  }
  minutes2 = absFloor(seconds2 / 60);
  hours2 = absFloor(minutes2 / 60);
  seconds2 %= 60;
  minutes2 %= 60;
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  s2 = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
  totalSign = total < 0 ? "-" : "";
  ymSign = sign(this._months) !== sign(total) ? "-" : "";
  daysSign = sign(this._days) !== sign(total) ? "-" : "";
  hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
  return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s2 + "S" : "");
}
var proto$2 = Duration.prototype;
proto$2.isValid = isValid$1;
proto$2.abs = abs;
proto$2.add = add$1;
proto$2.subtract = subtract$1;
proto$2.as = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds = asSeconds;
proto$2.asMinutes = asMinutes;
proto$2.asHours = asHours;
proto$2.asDays = asDays;
proto$2.asWeeks = asWeeks;
proto$2.asMonths = asMonths;
proto$2.asQuarters = asQuarters;
proto$2.asYears = asYears;
proto$2.valueOf = valueOf$1;
proto$2._bubble = bubble;
proto$2.clone = clone$1$1;
proto$2.get = get$2;
proto$2.milliseconds = milliseconds;
proto$2.seconds = seconds;
proto$2.minutes = minutes;
proto$2.hours = hours;
proto$2.days = days;
proto$2.weeks = weeks;
proto$2.months = months;
proto$2.years = years;
proto$2.humanize = humanize;
proto$2.toISOString = toISOString$1;
proto$2.toString = toISOString$1;
proto$2.toJSON = toISOString$1;
proto$2.locale = locale;
proto$2.localeData = localeData;
proto$2.toIsoString = deprecate(
  "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
  toISOString$1
);
proto$2.lang = lang;
addFormatToken("X", 0, 0, "unix");
addFormatToken("x", 0, 0, "valueOf");
addRegexToken("x", matchSigned);
addRegexToken("X", matchTimestamp);
addParseToken("X", function(input2, array, config2) {
  config2._d = new Date(parseFloat(input2) * 1e3);
});
addParseToken("x", function(input2, array, config2) {
  config2._d = new Date(toInt(input2));
});
//! moment.js
hooks.version = "2.29.4";
setHookCallback(createLocal);
hooks.fn = proto;
hooks.min = min;
hooks.max = max;
hooks.now = now$2;
hooks.utc = createUTC;
hooks.unix = createUnix;
hooks.months = listMonths;
hooks.isDate = isDate;
hooks.locale = getSetGlobalLocale;
hooks.invalid = createInvalid;
hooks.duration = createDuration;
hooks.isMoment = isMoment;
hooks.weekdays = listWeekdays;
hooks.parseZone = createInZone;
hooks.localeData = getLocale;
hooks.isDuration = isDuration;
hooks.monthsShort = listMonthsShort;
hooks.weekdaysMin = listWeekdaysMin;
hooks.defineLocale = defineLocale;
hooks.updateLocale = updateLocale;
hooks.locales = listLocales;
hooks.weekdaysShort = listWeekdaysShort;
hooks.normalizeUnits = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat = getCalendarFormat;
hooks.prototype = proto;
hooks.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  // <input type="datetime-local" />
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  // <input type="datetime-local" step="1" />
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  // <input type="datetime-local" step="0.001" />
  DATE: "YYYY-MM-DD",
  // <input type="date" />
  TIME: "HH:mm",
  // <input type="time" />
  TIME_SECONDS: "HH:mm:ss",
  // <input type="time" step="1" />
  TIME_MS: "HH:mm:ss.SSS",
  // <input type="time" step="0.001" />
  WEEK: "GGGG-[W]WW",
  // <input type="week" />
  MONTH: "YYYY-MM"
  // <input type="month" />
};
var defaultFormats = {
  normalDateWithWeekday: "ddd, MMM D",
  normalDate: "D MMMM",
  shortDate: "MMM D",
  monthAndDate: "MMMM D",
  dayOfMonth: "D",
  year: "YYYY",
  month: "MMMM",
  monthShort: "MMM",
  monthAndYear: "MMMM YYYY",
  weekday: "dddd",
  weekdayShort: "ddd",
  minutes: "mm",
  hours12h: "hh",
  hours24h: "HH",
  seconds: "ss",
  fullTime: "LT",
  fullTime12h: "hh:mm A",
  fullTime24h: "HH:mm",
  fullDate: "ll",
  fullDateWithWeekday: "dddd, LL",
  fullDateTime: "lll",
  fullDateTime12h: "ll hh:mm A",
  fullDateTime24h: "ll HH:mm",
  keyboardDate: "L",
  keyboardDateTime: "L LT",
  keyboardDateTime12h: "L hh:mm A",
  keyboardDateTime24h: "L HH:mm"
};
var MomentUtils = (
  /** @class */
  function() {
    function MomentUtils2(_a) {
      var _this = this;
      var _b = _a === void 0 ? {} : _a, locale2 = _b.locale, formats = _b.formats, instance = _b.instance;
      this.lib = "moment";
      this.is12HourCycleInCurrentLocale = function() {
        return /A|a/.test(_this.moment.localeData(_this.getCurrentLocaleCode()).longDateFormat("LT"));
      };
      this.getFormatHelperText = function(format2) {
        var localFormattingTokens2 = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})|./g;
        return format2.match(localFormattingTokens2).map(function(token2) {
          var firstCharacter = token2[0];
          if (firstCharacter === "L" || firstCharacter === ";") {
            return _this.moment.localeData(_this.getCurrentLocaleCode()).longDateFormat(token2);
          }
          return token2;
        }).join("").replace(/a/gi, "(a|p)m").toLocaleLowerCase();
      };
      this.getCurrentLocaleCode = function() {
        return _this.locale || _this.moment.locale();
      };
      this.parseISO = function(isoString) {
        return _this.moment(isoString, true);
      };
      this.toISO = function(value) {
        return value.toISOString();
      };
      this.parse = function(value, format2) {
        if (value === "") {
          return null;
        }
        if (_this.locale) {
          return _this.moment(value, format2, _this.locale, true);
        }
        return _this.moment(value, format2, true);
      };
      this.date = function(value) {
        if (value === null) {
          return null;
        }
        var moment2 = _this.moment(value);
        moment2.locale(_this.locale);
        return moment2;
      };
      this.toJsDate = function(value) {
        return value.toDate();
      };
      this.isValid = function(value) {
        return _this.moment(value).isValid();
      };
      this.isNull = function(date) {
        return date === null;
      };
      this.getDiff = function(date, comparing, unit) {
        return date.diff(comparing, unit);
      };
      this.isAfter = function(date, value) {
        return date.isAfter(value);
      };
      this.isBefore = function(date, value) {
        return date.isBefore(value);
      };
      this.isAfterDay = function(date, value) {
        return date.isAfter(value, "day");
      };
      this.isBeforeDay = function(date, value) {
        return date.isBefore(value, "day");
      };
      this.isBeforeYear = function(date, value) {
        return date.isBefore(value, "year");
      };
      this.isAfterYear = function(date, value) {
        return date.isAfter(value, "year");
      };
      this.startOfDay = function(date) {
        return date.clone().startOf("day");
      };
      this.endOfDay = function(date) {
        return date.clone().endOf("day");
      };
      this.format = function(date, formatKey) {
        return _this.formatByString(date, _this.formats[formatKey]);
      };
      this.formatByString = function(date, formatString) {
        var clonedDate = date.clone();
        clonedDate.locale(_this.locale);
        return clonedDate.format(formatString);
      };
      this.formatNumber = function(numberToFormat) {
        return numberToFormat;
      };
      this.getHours = function(date) {
        return date.get("hours");
      };
      this.addSeconds = function(date, count) {
        return count < 0 ? date.clone().subtract(Math.abs(count), "seconds") : date.clone().add(count, "seconds");
      };
      this.addMinutes = function(date, count) {
        return count < 0 ? date.clone().subtract(Math.abs(count), "minutes") : date.clone().add(count, "minutes");
      };
      this.addHours = function(date, count) {
        return count < 0 ? date.clone().subtract(Math.abs(count), "hours") : date.clone().add(count, "hours");
      };
      this.addDays = function(date, count) {
        return count < 0 ? date.clone().subtract(Math.abs(count), "days") : date.clone().add(count, "days");
      };
      this.addWeeks = function(date, count) {
        return count < 0 ? date.clone().subtract(Math.abs(count), "weeks") : date.clone().add(count, "weeks");
      };
      this.addMonths = function(date, count) {
        return count < 0 ? date.clone().subtract(Math.abs(count), "months") : date.clone().add(count, "months");
      };
      this.addYears = function(date, count) {
        return count < 0 ? date.clone().subtract(Math.abs(count), "years") : date.clone().add(count, "years");
      };
      this.setHours = function(date, count) {
        return date.clone().hours(count);
      };
      this.getMinutes = function(date) {
        return date.get("minutes");
      };
      this.setMinutes = function(date, count) {
        return date.clone().minutes(count);
      };
      this.getSeconds = function(date) {
        return date.get("seconds");
      };
      this.setSeconds = function(date, count) {
        return date.clone().seconds(count);
      };
      this.getMonth = function(date) {
        return date.get("month");
      };
      this.getDaysInMonth = function(date) {
        return date.daysInMonth();
      };
      this.isSameDay = function(date, comparing) {
        return date.isSame(comparing, "day");
      };
      this.isSameMonth = function(date, comparing) {
        return date.isSame(comparing, "month");
      };
      this.isSameYear = function(date, comparing) {
        return date.isSame(comparing, "year");
      };
      this.isSameHour = function(date, comparing) {
        return date.isSame(comparing, "hour");
      };
      this.setMonth = function(date, count) {
        return date.clone().month(count);
      };
      this.getMeridiemText = function(ampm) {
        if (_this.is12HourCycleInCurrentLocale()) {
          return _this.moment.localeData(_this.getCurrentLocaleCode()).meridiem(ampm === "am" ? 0 : 13, 0, false);
        }
        return ampm === "am" ? "AM" : "PM";
      };
      this.startOfYear = function(date) {
        return date.clone().startOf("year");
      };
      this.endOfYear = function(date) {
        return date.clone().endOf("year");
      };
      this.startOfMonth = function(date) {
        return date.clone().startOf("month");
      };
      this.endOfMonth = function(date) {
        return date.clone().endOf("month");
      };
      this.startOfWeek = function(date) {
        return date.clone().startOf("week");
      };
      this.endOfWeek = function(date) {
        return date.clone().endOf("week");
      };
      this.getNextMonth = function(date) {
        return date.clone().add(1, "month");
      };
      this.getPreviousMonth = function(date) {
        return date.clone().subtract(1, "month");
      };
      this.getMonthArray = function(date) {
        var firstMonth = date.clone().startOf("year");
        var monthArray = [firstMonth];
        while (monthArray.length < 12) {
          var prevMonth = monthArray[monthArray.length - 1];
          monthArray.push(_this.getNextMonth(prevMonth));
        }
        return monthArray;
      };
      this.getYear = function(date) {
        return date.get("year");
      };
      this.setYear = function(date, year) {
        return date.clone().set("year", year);
      };
      this.getDate = function(date) {
        return date.get("date");
      };
      this.setDate = function(date, year) {
        return date.clone().set("date", year);
      };
      this.mergeDateAndTime = function(date, time) {
        return date.hour(time.hour()).minute(time.minute()).second(time.second());
      };
      this.getWeekdays = function() {
        return _this.moment.weekdaysShort(true);
      };
      this.isEqual = function(value, comparing) {
        if (value === null && comparing === null) {
          return true;
        }
        return _this.moment(value).isSame(comparing);
      };
      this.getWeekArray = function(date) {
        var start2 = date.clone().startOf("month").startOf("week");
        var end = date.clone().endOf("month").endOf("week");
        var count = 0;
        var current = start2;
        var nestedWeeks = [];
        while (current.isBefore(end)) {
          var weekNumber = Math.floor(count / 7);
          nestedWeeks[weekNumber] = nestedWeeks[weekNumber] || [];
          nestedWeeks[weekNumber].push(current);
          current = current.clone().add(1, "day");
          count += 1;
        }
        return nestedWeeks;
      };
      this.getYearRange = function(start2, end) {
        var startDate = _this.moment(start2).startOf("year");
        var endDate = _this.moment(end).endOf("year");
        var years2 = [];
        var current = startDate;
        while (current.isBefore(endDate)) {
          years2.push(current);
          current = current.clone().add(1, "year");
        }
        return years2;
      };
      this.isWithinRange = function(date, _a2) {
        var start2 = _a2[0], end = _a2[1];
        return date.isBetween(start2, end, null, "[]");
      };
      this.moment = instance || hooks;
      this.locale = locale2;
      this.formats = Object.assign({}, defaultFormats, formats);
    }
    return MomentUtils2;
  }()
);
const MuiTextWidget$1 = function(props) {
  var value = props.value, setValue4 = props.setValue;
  props.config;
  var readonly = props.readonly, placeholder2 = props.placeholder, customProps = props.customProps, maxLength = props.maxLength;
  var onChange = function onChange2(e2) {
    var val = e2.target.value;
    if (val === "")
      val = void 0;
    setValue4(val);
  };
  var textValue = value || "";
  return /* @__PURE__ */ React.createElement(FormControl, null, /* @__PURE__ */ React.createElement(TextField, _extends$h({
    variant: "standard",
    value: textValue,
    placeholder: !readonly ? placeholder2 : "",
    InputProps: {
      readOnly: readonly
    },
    inputProps: {
      maxLength
    },
    disabled: readonly,
    onChange,
    size: "small"
  }, customProps)));
};
const MuiTextAreaWidget$1 = function(props) {
  var value = props.value, setValue4 = props.setValue, config2 = props.config, readonly = props.readonly, placeholder2 = props.placeholder, customProps = props.customProps, maxLength = props.maxLength, maxRows = props.maxRows, fullWidth2 = props.fullWidth;
  var defaultMaxRows = config2.settings.defaultMaxRows;
  var onChange = function onChange2(e2) {
    var val = e2.target.value;
    if (val === "")
      val = void 0;
    setValue4(val);
  };
  var textValue = value || "";
  return /* @__PURE__ */ React.createElement(FormControl, {
    fullWidth: fullWidth2
  }, /* @__PURE__ */ React.createElement(TextField, _extends$h({
    variant: "standard",
    fullWidth: fullWidth2,
    maxRows: maxRows || defaultMaxRows,
    multiline: true,
    value: textValue,
    placeholder: !readonly ? placeholder2 : "",
    InputProps: {
      readOnly: readonly
    },
    inputProps: {
      maxLength
    },
    disabled: readonly,
    onChange,
    size: "small"
  }, customProps)));
};
const MuiDateWidget$1 = function(props) {
  var value = props.value, setValue4 = props.setValue, readonly = props.readonly, customProps = props.customProps, dateFormat = props.dateFormat, valueFormat = props.valueFormat, placeholder2 = props.placeholder;
  var formatSingleValue = function formatSingleValue2(value2) {
    return value2 && value2.isValid() ? value2.format(valueFormat) : void 0;
  };
  var handleChange = function handleChange2(value2) {
    setValue4(formatSingleValue(value2));
  };
  var renderInput = function renderInput2(params) {
    return /* @__PURE__ */ React.createElement(TextField, _extends$h({
      size: "small",
      variant: "standard"
    }, params));
  };
  return /* @__PURE__ */ React.createElement(FormControl, null, /* @__PURE__ */ React.createElement(DatePicker, _extends$h({
    readOnly: readonly,
    disabled: readonly,
    toolbarPlaceholder: !readonly ? placeholder2 : "",
    inputFormat: dateFormat,
    value: value || null,
    onChange: handleChange,
    renderInput
  }, customProps)));
};
const MuiDateTimeWidget$1 = function(props) {
  var value = props.value, setValue4 = props.setValue, use12Hours = props.use12Hours, readonly = props.readonly, placeholder2 = props.placeholder, dateFormat = props.dateFormat, timeFormat = props.timeFormat, valueFormat = props.valueFormat, customProps = props.customProps;
  var formatSingleValue = function formatSingleValue2(value2) {
    return value2 && value2.isValid() ? value2.format(valueFormat) : void 0;
  };
  var handleChange = function handleChange2(value2) {
    setValue4(formatSingleValue(value2));
  };
  var dateTimeFormat = dateFormat + " " + timeFormat;
  var renderInput = function renderInput2(params) {
    return /* @__PURE__ */ React.createElement(TextField, _extends$h({
      size: "small",
      variant: "standard"
    }, params));
  };
  return /* @__PURE__ */ React.createElement(FormControl, null, /* @__PURE__ */ React.createElement(DateTimePicker, _extends$h({
    readOnly: readonly,
    disabled: readonly,
    ampm: !!use12Hours,
    toolbarPlaceholder: !readonly ? placeholder2 : "",
    inputFormat: dateTimeFormat,
    value: value || null,
    onChange: handleChange,
    renderInput
  }, customProps)));
};
var immutable = { exports: {} };
(function(module2, exports2) {
  (function(global2, factory26) {
    module2.exports = factory26();
  })(commonjsGlobal, function() {
    var SLICE$0 = Array.prototype.slice;
    function createClass(ctor, superClass) {
      if (superClass) {
        ctor.prototype = Object.create(superClass.prototype);
      }
      ctor.prototype.constructor = ctor;
    }
    function Iterable(value) {
      return isIterable(value) ? value : Seq(value);
    }
    createClass(KeyedIterable, Iterable);
    function KeyedIterable(value) {
      return isKeyed(value) ? value : KeyedSeq(value);
    }
    createClass(IndexedIterable, Iterable);
    function IndexedIterable(value) {
      return isIndexed(value) ? value : IndexedSeq(value);
    }
    createClass(SetIterable, Iterable);
    function SetIterable(value) {
      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
    }
    function isIterable(maybeIterable) {
      return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
    }
    function isKeyed(maybeKeyed) {
      return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
    }
    function isIndexed(maybeIndexed) {
      return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
    }
    function isAssociative(maybeAssociative) {
      return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
    }
    function isOrdered(maybeOrdered) {
      return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
    }
    Iterable.isIterable = isIterable;
    Iterable.isKeyed = isKeyed;
    Iterable.isIndexed = isIndexed;
    Iterable.isAssociative = isAssociative;
    Iterable.isOrdered = isOrdered;
    Iterable.Keyed = KeyedIterable;
    Iterable.Indexed = IndexedIterable;
    Iterable.Set = SetIterable;
    var IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@";
    var IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@";
    var IS_INDEXED_SENTINEL = "@@__IMMUTABLE_INDEXED__@@";
    var IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@";
    var DELETE = "delete";
    var SHIFT = 5;
    var SIZE = 1 << SHIFT;
    var MASK = SIZE - 1;
    var NOT_SET = {};
    var CHANGE_LENGTH = { value: false };
    var DID_ALTER = { value: false };
    function MakeRef(ref) {
      ref.value = false;
      return ref;
    }
    function SetRef(ref) {
      ref && (ref.value = true);
    }
    function OwnerID() {
    }
    function arrCopy(arr, offset2) {
      offset2 = offset2 || 0;
      var len = Math.max(0, arr.length - offset2);
      var newArr = new Array(len);
      for (var ii = 0; ii < len; ii++) {
        newArr[ii] = arr[ii + offset2];
      }
      return newArr;
    }
    function ensureSize(iter) {
      if (iter.size === void 0) {
        iter.size = iter.__iterate(returnTrue);
      }
      return iter.size;
    }
    function wrapIndex(iter, index2) {
      if (typeof index2 !== "number") {
        var uint32Index = index2 >>> 0;
        if ("" + uint32Index !== index2 || uint32Index === 4294967295) {
          return NaN;
        }
        index2 = uint32Index;
      }
      return index2 < 0 ? ensureSize(iter) + index2 : index2;
    }
    function returnTrue() {
      return true;
    }
    function wholeSlice(begin, end, size) {
      return (begin === 0 || size !== void 0 && begin <= -size) && (end === void 0 || size !== void 0 && end >= size);
    }
    function resolveBegin(begin, size) {
      return resolveIndex(begin, size, 0);
    }
    function resolveEnd(end, size) {
      return resolveIndex(end, size, size);
    }
    function resolveIndex(index2, size, defaultIndex) {
      return index2 === void 0 ? defaultIndex : index2 < 0 ? Math.max(0, size + index2) : size === void 0 ? index2 : Math.min(size, index2);
    }
    var ITERATE_KEYS = 0;
    var ITERATE_VALUES = 1;
    var ITERATE_ENTRIES = 2;
    var REAL_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = "@@iterator";
    var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
    function Iterator(next) {
      this.next = next;
    }
    Iterator.prototype.toString = function() {
      return "[Iterator]";
    };
    Iterator.KEYS = ITERATE_KEYS;
    Iterator.VALUES = ITERATE_VALUES;
    Iterator.ENTRIES = ITERATE_ENTRIES;
    Iterator.prototype.inspect = Iterator.prototype.toSource = function() {
      return this.toString();
    };
    Iterator.prototype[ITERATOR_SYMBOL] = function() {
      return this;
    };
    function iteratorValue(type2, k2, v2, iteratorResult) {
      var value = type2 === 0 ? k2 : type2 === 1 ? v2 : [k2, v2];
      iteratorResult ? iteratorResult.value = value : iteratorResult = {
        value,
        done: false
      };
      return iteratorResult;
    }
    function iteratorDone() {
      return { value: void 0, done: true };
    }
    function hasIterator(maybeIterable) {
      return !!getIteratorFn(maybeIterable);
    }
    function isIterator(maybeIterator) {
      return maybeIterator && typeof maybeIterator.next === "function";
    }
    function getIterator(iterable) {
      var iteratorFn = getIteratorFn(iterable);
      return iteratorFn && iteratorFn.call(iterable);
    }
    function getIteratorFn(iterable) {
      var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);
      if (typeof iteratorFn === "function") {
        return iteratorFn;
      }
    }
    function isArrayLike2(value) {
      return value && typeof value.length === "number";
    }
    createClass(Seq, Iterable);
    function Seq(value) {
      return value === null || value === void 0 ? emptySequence() : isIterable(value) ? value.toSeq() : seqFromValue(value);
    }
    Seq.of = function() {
      return Seq(arguments);
    };
    Seq.prototype.toSeq = function() {
      return this;
    };
    Seq.prototype.toString = function() {
      return this.__toString("Seq {", "}");
    };
    Seq.prototype.cacheResult = function() {
      if (!this._cache && this.__iterateUncached) {
        this._cache = this.entrySeq().toArray();
        this.size = this._cache.length;
      }
      return this;
    };
    Seq.prototype.__iterate = function(fn, reverse) {
      return seqIterate(this, fn, reverse, true);
    };
    Seq.prototype.__iterator = function(type2, reverse) {
      return seqIterator(this, type2, reverse, true);
    };
    createClass(KeyedSeq, Seq);
    function KeyedSeq(value) {
      return value === null || value === void 0 ? emptySequence().toKeyedSeq() : isIterable(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : keyedSeqFromValue(value);
    }
    KeyedSeq.prototype.toKeyedSeq = function() {
      return this;
    };
    createClass(IndexedSeq, Seq);
    function IndexedSeq(value) {
      return value === null || value === void 0 ? emptySequence() : !isIterable(value) ? indexedSeqFromValue(value) : isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
    }
    IndexedSeq.of = function() {
      return IndexedSeq(arguments);
    };
    IndexedSeq.prototype.toIndexedSeq = function() {
      return this;
    };
    IndexedSeq.prototype.toString = function() {
      return this.__toString("Seq [", "]");
    };
    IndexedSeq.prototype.__iterate = function(fn, reverse) {
      return seqIterate(this, fn, reverse, false);
    };
    IndexedSeq.prototype.__iterator = function(type2, reverse) {
      return seqIterator(this, type2, reverse, false);
    };
    createClass(SetSeq, Seq);
    function SetSeq(value) {
      return (value === null || value === void 0 ? emptySequence() : !isIterable(value) ? indexedSeqFromValue(value) : isKeyed(value) ? value.entrySeq() : value).toSetSeq();
    }
    SetSeq.of = function() {
      return SetSeq(arguments);
    };
    SetSeq.prototype.toSetSeq = function() {
      return this;
    };
    Seq.isSeq = isSeq;
    Seq.Keyed = KeyedSeq;
    Seq.Set = SetSeq;
    Seq.Indexed = IndexedSeq;
    var IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@";
    Seq.prototype[IS_SEQ_SENTINEL] = true;
    createClass(ArraySeq, IndexedSeq);
    function ArraySeq(array) {
      this._array = array;
      this.size = array.length;
    }
    ArraySeq.prototype.get = function(index2, notSetValue) {
      return this.has(index2) ? this._array[wrapIndex(this, index2)] : notSetValue;
    };
    ArraySeq.prototype.__iterate = function(fn, reverse) {
      var array = this._array;
      var maxIndex = array.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };
    ArraySeq.prototype.__iterator = function(type2, reverse) {
      var array = this._array;
      var maxIndex = array.length - 1;
      var ii = 0;
      return new Iterator(
        function() {
          return ii > maxIndex ? iteratorDone() : iteratorValue(type2, ii, array[reverse ? maxIndex - ii++ : ii++]);
        }
      );
    };
    createClass(ObjectSeq, KeyedSeq);
    function ObjectSeq(object) {
      var keys2 = Object.keys(object);
      this._object = object;
      this._keys = keys2;
      this.size = keys2.length;
    }
    ObjectSeq.prototype.get = function(key, notSetValue) {
      if (notSetValue !== void 0 && !this.has(key)) {
        return notSetValue;
      }
      return this._object[key];
    };
    ObjectSeq.prototype.has = function(key) {
      return this._object.hasOwnProperty(key);
    };
    ObjectSeq.prototype.__iterate = function(fn, reverse) {
      var object = this._object;
      var keys2 = this._keys;
      var maxIndex = keys2.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        var key = keys2[reverse ? maxIndex - ii : ii];
        if (fn(object[key], key, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };
    ObjectSeq.prototype.__iterator = function(type2, reverse) {
      var object = this._object;
      var keys2 = this._keys;
      var maxIndex = keys2.length - 1;
      var ii = 0;
      return new Iterator(function() {
        var key = keys2[reverse ? maxIndex - ii : ii];
        return ii++ > maxIndex ? iteratorDone() : iteratorValue(type2, key, object[key]);
      });
    };
    ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;
    createClass(IterableSeq, IndexedSeq);
    function IterableSeq(iterable) {
      this._iterable = iterable;
      this.size = iterable.length || iterable.size;
    }
    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterable = this._iterable;
      var iterator = getIterator(iterable);
      var iterations = 0;
      if (isIterator(iterator)) {
        var step;
        while (!(step = iterator.next()).done) {
          if (fn(step.value, iterations++, this) === false) {
            break;
          }
        }
      }
      return iterations;
    };
    IterableSeq.prototype.__iteratorUncached = function(type2, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type2, reverse);
      }
      var iterable = this._iterable;
      var iterator = getIterator(iterable);
      if (!isIterator(iterator)) {
        return new Iterator(iteratorDone);
      }
      var iterations = 0;
      return new Iterator(function() {
        var step = iterator.next();
        return step.done ? step : iteratorValue(type2, iterations++, step.value);
      });
    };
    createClass(IteratorSeq, IndexedSeq);
    function IteratorSeq(iterator) {
      this._iterator = iterator;
      this._iteratorCache = [];
    }
    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      while (iterations < cache.length) {
        if (fn(cache[iterations], iterations++, this) === false) {
          return iterations;
        }
      }
      var step;
      while (!(step = iterator.next()).done) {
        var val = step.value;
        cache[iterations] = val;
        if (fn(val, iterations++, this) === false) {
          break;
        }
      }
      return iterations;
    };
    IteratorSeq.prototype.__iteratorUncached = function(type2, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type2, reverse);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      return new Iterator(function() {
        if (iterations >= cache.length) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          cache[iterations] = step.value;
        }
        return iteratorValue(type2, iterations, cache[iterations++]);
      });
    };
    function isSeq(maybeSeq) {
      return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
    }
    var EMPTY_SEQ;
    function emptySequence() {
      return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
    }
    function keyedSeqFromValue(value) {
      var seq = Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() : isIterator(value) ? new IteratorSeq(value).fromEntrySeq() : hasIterator(value) ? new IterableSeq(value).fromEntrySeq() : typeof value === "object" ? new ObjectSeq(value) : void 0;
      if (!seq) {
        throw new TypeError(
          "Expected Array or iterable object of [k, v] entries, or keyed object: " + value
        );
      }
      return seq;
    }
    function indexedSeqFromValue(value) {
      var seq = maybeIndexedSeqFromValue(value);
      if (!seq) {
        throw new TypeError(
          "Expected Array or iterable object of values: " + value
        );
      }
      return seq;
    }
    function seqFromValue(value) {
      var seq = maybeIndexedSeqFromValue(value) || typeof value === "object" && new ObjectSeq(value);
      if (!seq) {
        throw new TypeError(
          "Expected Array or iterable object of values, or keyed object: " + value
        );
      }
      return seq;
    }
    function maybeIndexedSeqFromValue(value) {
      return isArrayLike2(value) ? new ArraySeq(value) : isIterator(value) ? new IteratorSeq(value) : hasIterator(value) ? new IterableSeq(value) : void 0;
    }
    function seqIterate(seq, fn, reverse, useKeys) {
      var cache = seq._cache;
      if (cache) {
        var maxIndex = cache.length - 1;
        for (var ii = 0; ii <= maxIndex; ii++) {
          var entry = cache[reverse ? maxIndex - ii : ii];
          if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
            return ii + 1;
          }
        }
        return ii;
      }
      return seq.__iterateUncached(fn, reverse);
    }
    function seqIterator(seq, type2, reverse, useKeys) {
      var cache = seq._cache;
      if (cache) {
        var maxIndex = cache.length - 1;
        var ii = 0;
        return new Iterator(function() {
          var entry = cache[reverse ? maxIndex - ii : ii];
          return ii++ > maxIndex ? iteratorDone() : iteratorValue(type2, useKeys ? entry[0] : ii - 1, entry[1]);
        });
      }
      return seq.__iteratorUncached(type2, reverse);
    }
    function fromJS(json, converter) {
      return converter ? fromJSWith(converter, json, "", { "": json }) : fromJSDefault(json);
    }
    function fromJSWith(converter, json, key, parentJSON) {
      if (Array.isArray(json)) {
        return converter.call(parentJSON, key, IndexedSeq(json).map(function(v2, k2) {
          return fromJSWith(converter, v2, k2, json);
        }));
      }
      if (isPlainObj(json)) {
        return converter.call(parentJSON, key, KeyedSeq(json).map(function(v2, k2) {
          return fromJSWith(converter, v2, k2, json);
        }));
      }
      return json;
    }
    function fromJSDefault(json) {
      if (Array.isArray(json)) {
        return IndexedSeq(json).map(fromJSDefault).toList();
      }
      if (isPlainObj(json)) {
        return KeyedSeq(json).map(fromJSDefault).toMap();
      }
      return json;
    }
    function isPlainObj(value) {
      return value && (value.constructor === Object || value.constructor === void 0);
    }
    function is2(valueA, valueB) {
      if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
        return true;
      }
      if (!valueA || !valueB) {
        return false;
      }
      if (typeof valueA.valueOf === "function" && typeof valueB.valueOf === "function") {
        valueA = valueA.valueOf();
        valueB = valueB.valueOf();
        if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
          return true;
        }
        if (!valueA || !valueB) {
          return false;
        }
      }
      if (typeof valueA.equals === "function" && typeof valueB.equals === "function" && valueA.equals(valueB)) {
        return true;
      }
      return false;
    }
    function deepEqual3(a2, b2) {
      if (a2 === b2) {
        return true;
      }
      if (!isIterable(b2) || a2.size !== void 0 && b2.size !== void 0 && a2.size !== b2.size || a2.__hash !== void 0 && b2.__hash !== void 0 && a2.__hash !== b2.__hash || isKeyed(a2) !== isKeyed(b2) || isIndexed(a2) !== isIndexed(b2) || isOrdered(a2) !== isOrdered(b2)) {
        return false;
      }
      if (a2.size === 0 && b2.size === 0) {
        return true;
      }
      var notAssociative = !isAssociative(a2);
      if (isOrdered(a2)) {
        var entries = a2.entries();
        return b2.every(function(v2, k2) {
          var entry = entries.next().value;
          return entry && is2(entry[1], v2) && (notAssociative || is2(entry[0], k2));
        }) && entries.next().done;
      }
      var flipped = false;
      if (a2.size === void 0) {
        if (b2.size === void 0) {
          if (typeof a2.cacheResult === "function") {
            a2.cacheResult();
          }
        } else {
          flipped = true;
          var _ = a2;
          a2 = b2;
          b2 = _;
        }
      }
      var allEqual = true;
      var bSize = b2.__iterate(function(v2, k2) {
        if (notAssociative ? !a2.has(v2) : flipped ? !is2(v2, a2.get(k2, NOT_SET)) : !is2(a2.get(k2, NOT_SET), v2)) {
          allEqual = false;
          return false;
        }
      });
      return allEqual && a2.size === bSize;
    }
    createClass(Repeat, IndexedSeq);
    function Repeat(value, times) {
      if (!(this instanceof Repeat)) {
        return new Repeat(value, times);
      }
      this._value = value;
      this.size = times === void 0 ? Infinity : Math.max(0, times);
      if (this.size === 0) {
        if (EMPTY_REPEAT) {
          return EMPTY_REPEAT;
        }
        EMPTY_REPEAT = this;
      }
    }
    Repeat.prototype.toString = function() {
      if (this.size === 0) {
        return "Repeat []";
      }
      return "Repeat [ " + this._value + " " + this.size + " times ]";
    };
    Repeat.prototype.get = function(index2, notSetValue) {
      return this.has(index2) ? this._value : notSetValue;
    };
    Repeat.prototype.includes = function(searchValue) {
      return is2(this._value, searchValue);
    };
    Repeat.prototype.slice = function(begin, end) {
      var size = this.size;
      return wholeSlice(begin, end, size) ? this : new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
    };
    Repeat.prototype.reverse = function() {
      return this;
    };
    Repeat.prototype.indexOf = function(searchValue) {
      if (is2(this._value, searchValue)) {
        return 0;
      }
      return -1;
    };
    Repeat.prototype.lastIndexOf = function(searchValue) {
      if (is2(this._value, searchValue)) {
        return this.size;
      }
      return -1;
    };
    Repeat.prototype.__iterate = function(fn, reverse) {
      for (var ii = 0; ii < this.size; ii++) {
        if (fn(this._value, ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };
    Repeat.prototype.__iterator = function(type2, reverse) {
      var this$0 = this;
      var ii = 0;
      return new Iterator(
        function() {
          return ii < this$0.size ? iteratorValue(type2, ii++, this$0._value) : iteratorDone();
        }
      );
    };
    Repeat.prototype.equals = function(other) {
      return other instanceof Repeat ? is2(this._value, other._value) : deepEqual3(other);
    };
    var EMPTY_REPEAT;
    function invariant(condition, error2) {
      if (!condition)
        throw new Error(error2);
    }
    createClass(Range, IndexedSeq);
    function Range(start2, end, step) {
      if (!(this instanceof Range)) {
        return new Range(start2, end, step);
      }
      invariant(step !== 0, "Cannot step a Range by 0");
      start2 = start2 || 0;
      if (end === void 0) {
        end = Infinity;
      }
      step = step === void 0 ? 1 : Math.abs(step);
      if (end < start2) {
        step = -step;
      }
      this._start = start2;
      this._end = end;
      this._step = step;
      this.size = Math.max(0, Math.ceil((end - start2) / step - 1) + 1);
      if (this.size === 0) {
        if (EMPTY_RANGE) {
          return EMPTY_RANGE;
        }
        EMPTY_RANGE = this;
      }
    }
    Range.prototype.toString = function() {
      if (this.size === 0) {
        return "Range []";
      }
      return "Range [ " + this._start + "..." + this._end + (this._step !== 1 ? " by " + this._step : "") + " ]";
    };
    Range.prototype.get = function(index2, notSetValue) {
      return this.has(index2) ? this._start + wrapIndex(this, index2) * this._step : notSetValue;
    };
    Range.prototype.includes = function(searchValue) {
      var possibleIndex = (searchValue - this._start) / this._step;
      return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
    };
    Range.prototype.slice = function(begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      begin = resolveBegin(begin, this.size);
      end = resolveEnd(end, this.size);
      if (end <= begin) {
        return new Range(0, 0);
      }
      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
    };
    Range.prototype.indexOf = function(searchValue) {
      var offsetValue = searchValue - this._start;
      if (offsetValue % this._step === 0) {
        var index2 = offsetValue / this._step;
        if (index2 >= 0 && index2 < this.size) {
          return index2;
        }
      }
      return -1;
    };
    Range.prototype.lastIndexOf = function(searchValue) {
      return this.indexOf(searchValue);
    };
    Range.prototype.__iterate = function(fn, reverse) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse ? this._start + maxIndex * step : this._start;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(value, ii, this) === false) {
          return ii + 1;
        }
        value += reverse ? -step : step;
      }
      return ii;
    };
    Range.prototype.__iterator = function(type2, reverse) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse ? this._start + maxIndex * step : this._start;
      var ii = 0;
      return new Iterator(function() {
        var v2 = value;
        value += reverse ? -step : step;
        return ii > maxIndex ? iteratorDone() : iteratorValue(type2, ii++, v2);
      });
    };
    Range.prototype.equals = function(other) {
      return other instanceof Range ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual3(this, other);
    };
    var EMPTY_RANGE;
    createClass(Collection, Iterable);
    function Collection() {
      throw TypeError("Abstract");
    }
    createClass(KeyedCollection, Collection);
    function KeyedCollection() {
    }
    createClass(IndexedCollection, Collection);
    function IndexedCollection() {
    }
    createClass(SetCollection, Collection);
    function SetCollection() {
    }
    Collection.Keyed = KeyedCollection;
    Collection.Indexed = IndexedCollection;
    Collection.Set = SetCollection;
    var imul = typeof Math.imul === "function" && Math.imul(4294967295, 2) === -2 ? Math.imul : function imul2(a2, b2) {
      a2 = a2 | 0;
      b2 = b2 | 0;
      var c2 = a2 & 65535;
      var d2 = b2 & 65535;
      return c2 * d2 + ((a2 >>> 16) * d2 + c2 * (b2 >>> 16) << 16 >>> 0) | 0;
    };
    function smi(i32) {
      return i32 >>> 1 & 1073741824 | i32 & 3221225471;
    }
    function hash(o) {
      if (o === false || o === null || o === void 0) {
        return 0;
      }
      if (typeof o.valueOf === "function") {
        o = o.valueOf();
        if (o === false || o === null || o === void 0) {
          return 0;
        }
      }
      if (o === true) {
        return 1;
      }
      var type2 = typeof o;
      if (type2 === "number") {
        if (o !== o || o === Infinity) {
          return 0;
        }
        var h2 = o | 0;
        if (h2 !== o) {
          h2 ^= o * 4294967295;
        }
        while (o > 4294967295) {
          o /= 4294967295;
          h2 ^= o;
        }
        return smi(h2);
      }
      if (type2 === "string") {
        return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
      }
      if (typeof o.hashCode === "function") {
        return o.hashCode();
      }
      if (type2 === "object") {
        return hashJSObj(o);
      }
      if (typeof o.toString === "function") {
        return hashString(o.toString());
      }
      throw new Error("Value type " + type2 + " cannot be hashed.");
    }
    function cachedHashString(string) {
      var hash2 = stringHashCache[string];
      if (hash2 === void 0) {
        hash2 = hashString(string);
        if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
          STRING_HASH_CACHE_SIZE = 0;
          stringHashCache = {};
        }
        STRING_HASH_CACHE_SIZE++;
        stringHashCache[string] = hash2;
      }
      return hash2;
    }
    function hashString(string) {
      var hash2 = 0;
      for (var ii = 0; ii < string.length; ii++) {
        hash2 = 31 * hash2 + string.charCodeAt(ii) | 0;
      }
      return smi(hash2);
    }
    function hashJSObj(obj) {
      var hash2;
      if (usingWeakMap) {
        hash2 = weakMap.get(obj);
        if (hash2 !== void 0) {
          return hash2;
        }
      }
      hash2 = obj[UID_HASH_KEY];
      if (hash2 !== void 0) {
        return hash2;
      }
      if (!canDefineProperty) {
        hash2 = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
        if (hash2 !== void 0) {
          return hash2;
        }
        hash2 = getIENodeHash(obj);
        if (hash2 !== void 0) {
          return hash2;
        }
      }
      hash2 = ++objHashUID;
      if (objHashUID & 1073741824) {
        objHashUID = 0;
      }
      if (usingWeakMap) {
        weakMap.set(obj, hash2);
      } else if (isExtensible !== void 0 && isExtensible(obj) === false) {
        throw new Error("Non-extensible objects are not allowed as keys.");
      } else if (canDefineProperty) {
        Object.defineProperty(obj, UID_HASH_KEY, {
          "enumerable": false,
          "configurable": false,
          "writable": false,
          "value": hash2
        });
      } else if (obj.propertyIsEnumerable !== void 0 && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
        obj.propertyIsEnumerable = function() {
          return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
        };
        obj.propertyIsEnumerable[UID_HASH_KEY] = hash2;
      } else if (obj.nodeType !== void 0) {
        obj[UID_HASH_KEY] = hash2;
      } else {
        throw new Error("Unable to set a non-enumerable property on object.");
      }
      return hash2;
    }
    var isExtensible = Object.isExtensible;
    var canDefineProperty = function() {
      try {
        Object.defineProperty({}, "@", {});
        return true;
      } catch (e2) {
        return false;
      }
    }();
    function getIENodeHash(node) {
      if (node && node.nodeType > 0) {
        switch (node.nodeType) {
          case 1:
            return node.uniqueID;
          case 9:
            return node.documentElement && node.documentElement.uniqueID;
        }
      }
    }
    var usingWeakMap = typeof WeakMap === "function";
    var weakMap;
    if (usingWeakMap) {
      weakMap = /* @__PURE__ */ new WeakMap();
    }
    var objHashUID = 0;
    var UID_HASH_KEY = "__immutablehash__";
    if (typeof Symbol === "function") {
      UID_HASH_KEY = Symbol(UID_HASH_KEY);
    }
    var STRING_HASH_CACHE_MIN_STRLEN = 16;
    var STRING_HASH_CACHE_MAX_SIZE = 255;
    var STRING_HASH_CACHE_SIZE = 0;
    var stringHashCache = {};
    function assertNotInfinite(size) {
      invariant(
        size !== Infinity,
        "Cannot perform this action with an infinite size."
      );
    }
    createClass(Map2, KeyedCollection);
    function Map2(value) {
      return value === null || value === void 0 ? emptyMap() : isMap2(value) && !isOrdered(value) ? value : emptyMap().withMutations(function(map2) {
        var iter = KeyedIterable(value);
        assertNotInfinite(iter.size);
        iter.forEach(function(v2, k2) {
          return map2.set(k2, v2);
        });
      });
    }
    Map2.of = function() {
      var keyValues = SLICE$0.call(arguments, 0);
      return emptyMap().withMutations(function(map2) {
        for (var i2 = 0; i2 < keyValues.length; i2 += 2) {
          if (i2 + 1 >= keyValues.length) {
            throw new Error("Missing value for key: " + keyValues[i2]);
          }
          map2.set(keyValues[i2], keyValues[i2 + 1]);
        }
      });
    };
    Map2.prototype.toString = function() {
      return this.__toString("Map {", "}");
    };
    Map2.prototype.get = function(k2, notSetValue) {
      return this._root ? this._root.get(0, void 0, k2, notSetValue) : notSetValue;
    };
    Map2.prototype.set = function(k2, v2) {
      return updateMap(this, k2, v2);
    };
    Map2.prototype.setIn = function(keyPath, v2) {
      return this.updateIn(keyPath, NOT_SET, function() {
        return v2;
      });
    };
    Map2.prototype.remove = function(k2) {
      return updateMap(this, k2, NOT_SET);
    };
    Map2.prototype.deleteIn = function(keyPath) {
      return this.updateIn(keyPath, function() {
        return NOT_SET;
      });
    };
    Map2.prototype.update = function(k2, notSetValue, updater) {
      return arguments.length === 1 ? k2(this) : this.updateIn([k2], notSetValue, updater);
    };
    Map2.prototype.updateIn = function(keyPath, notSetValue, updater) {
      if (!updater) {
        updater = notSetValue;
        notSetValue = void 0;
      }
      var updatedValue = updateInDeepMap(
        this,
        forceIterator(keyPath),
        notSetValue,
        updater
      );
      return updatedValue === NOT_SET ? void 0 : updatedValue;
    };
    Map2.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._root = null;
        this.__hash = void 0;
        this.__altered = true;
        return this;
      }
      return emptyMap();
    };
    Map2.prototype.merge = function() {
      return mergeIntoMapWith(this, void 0, arguments);
    };
    Map2.prototype.mergeWith = function(merger) {
      var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, merger, iters);
    };
    Map2.prototype.mergeIn = function(keyPath) {
      var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(
        keyPath,
        emptyMap(),
        function(m2) {
          return typeof m2.merge === "function" ? m2.merge.apply(m2, iters) : iters[iters.length - 1];
        }
      );
    };
    Map2.prototype.mergeDeep = function() {
      return mergeIntoMapWith(this, deepMerger, arguments);
    };
    Map2.prototype.mergeDeepWith = function(merger) {
      var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
    };
    Map2.prototype.mergeDeepIn = function(keyPath) {
      var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(
        keyPath,
        emptyMap(),
        function(m2) {
          return typeof m2.mergeDeep === "function" ? m2.mergeDeep.apply(m2, iters) : iters[iters.length - 1];
        }
      );
    };
    Map2.prototype.sort = function(comparator) {
      return OrderedMap(sortFactory(this, comparator));
    };
    Map2.prototype.sortBy = function(mapper, comparator) {
      return OrderedMap(sortFactory(this, comparator, mapper));
    };
    Map2.prototype.withMutations = function(fn) {
      var mutable = this.asMutable();
      fn(mutable);
      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
    };
    Map2.prototype.asMutable = function() {
      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
    };
    Map2.prototype.asImmutable = function() {
      return this.__ensureOwner();
    };
    Map2.prototype.wasAltered = function() {
      return this.__altered;
    };
    Map2.prototype.__iterator = function(type2, reverse) {
      return new MapIterator(this, type2, reverse);
    };
    Map2.prototype.__iterate = function(fn, reverse) {
      var this$0 = this;
      var iterations = 0;
      this._root && this._root.iterate(function(entry) {
        iterations++;
        return fn(entry[1], entry[0], this$0);
      }, reverse);
      return iterations;
    };
    Map2.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeMap(this.size, this._root, ownerID, this.__hash);
    };
    function isMap2(maybeMap) {
      return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
    }
    Map2.isMap = isMap2;
    var IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@";
    var MapPrototype = Map2.prototype;
    MapPrototype[IS_MAP_SENTINEL] = true;
    MapPrototype[DELETE] = MapPrototype.remove;
    MapPrototype.removeIn = MapPrototype.deleteIn;
    function ArrayMapNode(ownerID, entries) {
      this.ownerID = ownerID;
      this.entries = entries;
    }
    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      var entries = this.entries;
      for (var ii = 0, len = entries.length; ii < len; ii++) {
        if (is2(key, entries[ii][0])) {
          return entries[ii][1];
        }
      }
      return notSetValue;
    };
    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;
      var entries = this.entries;
      var idx = 0;
      for (var len = entries.length; idx < len; idx++) {
        if (is2(key, entries[idx][0])) {
          break;
        }
      }
      var exists = idx < len;
      if (exists ? entries[idx][1] === value : removed) {
        return this;
      }
      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);
      if (removed && entries.length === 1) {
        return;
      }
      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
        return createNodes(ownerID, entries, key, value);
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries : arrCopy(entries);
      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }
      if (isEditable) {
        this.entries = newEntries;
        return this;
      }
      return new ArrayMapNode(ownerID, newEntries);
    };
    function BitmapIndexedNode(ownerID, bitmap, nodes) {
      this.ownerID = ownerID;
      this.bitmap = bitmap;
      this.nodes = nodes;
    }
    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      if (keyHash === void 0) {
        keyHash = hash(key);
      }
      var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
      var bitmap = this.bitmap;
      return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key, notSetValue);
    };
    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === void 0) {
        keyHash = hash(key);
      }
      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var bit = 1 << keyHashFrag;
      var bitmap = this.bitmap;
      var exists = (bitmap & bit) !== 0;
      if (!exists && value === NOT_SET) {
        return this;
      }
      var idx = popCount(bitmap & bit - 1);
      var nodes = this.nodes;
      var node = exists ? nodes[idx] : void 0;
      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
      if (newNode === node) {
        return this;
      }
      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
      }
      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
        return nodes[idx ^ 1];
      }
      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
        return newNode;
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
      var newNodes = exists ? newNode ? setIn(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
      if (isEditable) {
        this.bitmap = newBitmap;
        this.nodes = newNodes;
        return this;
      }
      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
    };
    function HashArrayMapNode(ownerID, count, nodes) {
      this.ownerID = ownerID;
      this.count = count;
      this.nodes = nodes;
    }
    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      if (keyHash === void 0) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var node = this.nodes[idx];
      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
    };
    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === void 0) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var removed = value === NOT_SET;
      var nodes = this.nodes;
      var node = nodes[idx];
      if (removed && !node) {
        return this;
      }
      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
      if (newNode === node) {
        return this;
      }
      var newCount = this.count;
      if (!node) {
        newCount++;
      } else if (!newNode) {
        newCount--;
        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
          return packNodes(ownerID, nodes, newCount, idx);
        }
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newNodes = setIn(nodes, idx, newNode, isEditable);
      if (isEditable) {
        this.count = newCount;
        this.nodes = newNodes;
        return this;
      }
      return new HashArrayMapNode(ownerID, newCount, newNodes);
    };
    function HashCollisionNode(ownerID, keyHash, entries) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entries = entries;
    }
    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      var entries = this.entries;
      for (var ii = 0, len = entries.length; ii < len; ii++) {
        if (is2(key, entries[ii][0])) {
          return entries[ii][1];
        }
      }
      return notSetValue;
    };
    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === void 0) {
        keyHash = hash(key);
      }
      var removed = value === NOT_SET;
      if (keyHash !== this.keyHash) {
        if (removed) {
          return this;
        }
        SetRef(didAlter);
        SetRef(didChangeSize);
        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
      }
      var entries = this.entries;
      var idx = 0;
      for (var len = entries.length; idx < len; idx++) {
        if (is2(key, entries[idx][0])) {
          break;
        }
      }
      var exists = idx < len;
      if (exists ? entries[idx][1] === value : removed) {
        return this;
      }
      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);
      if (removed && len === 2) {
        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries : arrCopy(entries);
      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }
      if (isEditable) {
        this.entries = newEntries;
        return this;
      }
      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
    };
    function ValueNode(ownerID, keyHash, entry) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entry = entry;
    }
    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      return is2(key, this.entry[0]) ? this.entry[1] : notSetValue;
    };
    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;
      var keyMatch = is2(key, this.entry[0]);
      if (keyMatch ? value === this.entry[1] : removed) {
        return this;
      }
      SetRef(didAlter);
      if (removed) {
        SetRef(didChangeSize);
        return;
      }
      if (keyMatch) {
        if (ownerID && ownerID === this.ownerID) {
          this.entry[1] = value;
          return this;
        }
        return new ValueNode(ownerID, this.keyHash, [key, value]);
      }
      SetRef(didChangeSize);
      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
    };
    ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function(fn, reverse) {
      var entries = this.entries;
      for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
        if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
          return false;
        }
      }
    };
    BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function(fn, reverse) {
      var nodes = this.nodes;
      for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
        var node = nodes[reverse ? maxIndex - ii : ii];
        if (node && node.iterate(fn, reverse) === false) {
          return false;
        }
      }
    };
    ValueNode.prototype.iterate = function(fn, reverse) {
      return fn(this.entry);
    };
    createClass(MapIterator, Iterator);
    function MapIterator(map2, type2, reverse) {
      this._type = type2;
      this._reverse = reverse;
      this._stack = map2._root && mapIteratorFrame(map2._root);
    }
    MapIterator.prototype.next = function() {
      var type2 = this._type;
      var stack = this._stack;
      while (stack) {
        var node = stack.node;
        var index2 = stack.index++;
        var maxIndex;
        if (node.entry) {
          if (index2 === 0) {
            return mapIteratorValue(type2, node.entry);
          }
        } else if (node.entries) {
          maxIndex = node.entries.length - 1;
          if (index2 <= maxIndex) {
            return mapIteratorValue(type2, node.entries[this._reverse ? maxIndex - index2 : index2]);
          }
        } else {
          maxIndex = node.nodes.length - 1;
          if (index2 <= maxIndex) {
            var subNode = node.nodes[this._reverse ? maxIndex - index2 : index2];
            if (subNode) {
              if (subNode.entry) {
                return mapIteratorValue(type2, subNode.entry);
              }
              stack = this._stack = mapIteratorFrame(subNode, stack);
            }
            continue;
          }
        }
        stack = this._stack = this._stack.__prev;
      }
      return iteratorDone();
    };
    function mapIteratorValue(type2, entry) {
      return iteratorValue(type2, entry[0], entry[1]);
    }
    function mapIteratorFrame(node, prev) {
      return {
        node,
        index: 0,
        __prev: prev
      };
    }
    function makeMap(size, root2, ownerID, hash2) {
      var map2 = Object.create(MapPrototype);
      map2.size = size;
      map2._root = root2;
      map2.__ownerID = ownerID;
      map2.__hash = hash2;
      map2.__altered = false;
      return map2;
    }
    var EMPTY_MAP;
    function emptyMap() {
      return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
    }
    function updateMap(map2, k2, v2) {
      var newRoot;
      var newSize;
      if (!map2._root) {
        if (v2 === NOT_SET) {
          return map2;
        }
        newSize = 1;
        newRoot = new ArrayMapNode(map2.__ownerID, [[k2, v2]]);
      } else {
        var didChangeSize = MakeRef(CHANGE_LENGTH);
        var didAlter = MakeRef(DID_ALTER);
        newRoot = updateNode(map2._root, map2.__ownerID, 0, void 0, k2, v2, didChangeSize, didAlter);
        if (!didAlter.value) {
          return map2;
        }
        newSize = map2.size + (didChangeSize.value ? v2 === NOT_SET ? -1 : 1 : 0);
      }
      if (map2.__ownerID) {
        map2.size = newSize;
        map2._root = newRoot;
        map2.__hash = void 0;
        map2.__altered = true;
        return map2;
      }
      return newRoot ? makeMap(newSize, newRoot) : emptyMap();
    }
    function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (!node) {
        if (value === NOT_SET) {
          return node;
        }
        SetRef(didAlter);
        SetRef(didChangeSize);
        return new ValueNode(ownerID, keyHash, [key, value]);
      }
      return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
    }
    function isLeafNode(node) {
      return node.constructor === ValueNode || node.constructor === HashCollisionNode;
    }
    function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
      if (node.keyHash === keyHash) {
        return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
      }
      var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
      var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var newNode;
      var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);
      return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
    }
    function createNodes(ownerID, entries, key, value) {
      if (!ownerID) {
        ownerID = new OwnerID();
      }
      var node = new ValueNode(ownerID, hash(key), [key, value]);
      for (var ii = 0; ii < entries.length; ii++) {
        var entry = entries[ii];
        node = node.update(ownerID, 0, void 0, entry[0], entry[1]);
      }
      return node;
    }
    function packNodes(ownerID, nodes, count, excluding) {
      var bitmap = 0;
      var packedII = 0;
      var packedNodes = new Array(count);
      for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
        var node = nodes[ii];
        if (node !== void 0 && ii !== excluding) {
          bitmap |= bit;
          packedNodes[packedII++] = node;
        }
      }
      return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
    }
    function expandNodes(ownerID, nodes, bitmap, including, node) {
      var count = 0;
      var expandedNodes = new Array(SIZE);
      for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
        expandedNodes[ii] = bitmap & 1 ? nodes[count++] : void 0;
      }
      expandedNodes[including] = node;
      return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
    }
    function mergeIntoMapWith(map2, merger, iterables) {
      var iters = [];
      for (var ii = 0; ii < iterables.length; ii++) {
        var value = iterables[ii];
        var iter = KeyedIterable(value);
        if (!isIterable(value)) {
          iter = iter.map(function(v2) {
            return fromJS(v2);
          });
        }
        iters.push(iter);
      }
      return mergeIntoCollectionWith(map2, merger, iters);
    }
    function deepMerger(existing, value, key) {
      return existing && existing.mergeDeep && isIterable(value) ? existing.mergeDeep(value) : is2(existing, value) ? existing : value;
    }
    function deepMergerWith(merger) {
      return function(existing, value, key) {
        if (existing && existing.mergeDeepWith && isIterable(value)) {
          return existing.mergeDeepWith(merger, value);
        }
        var nextValue = merger(existing, value, key);
        return is2(existing, nextValue) ? existing : nextValue;
      };
    }
    function mergeIntoCollectionWith(collection, merger, iters) {
      iters = iters.filter(function(x) {
        return x.size !== 0;
      });
      if (iters.length === 0) {
        return collection;
      }
      if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
        return collection.constructor(iters[0]);
      }
      return collection.withMutations(function(collection2) {
        var mergeIntoMap = merger ? function(value, key) {
          collection2.update(
            key,
            NOT_SET,
            function(existing) {
              return existing === NOT_SET ? value : merger(existing, value, key);
            }
          );
        } : function(value, key) {
          collection2.set(key, value);
        };
        for (var ii = 0; ii < iters.length; ii++) {
          iters[ii].forEach(mergeIntoMap);
        }
      });
    }
    function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
      var isNotSet = existing === NOT_SET;
      var step = keyPathIter.next();
      if (step.done) {
        var existingValue = isNotSet ? notSetValue : existing;
        var newValue = updater(existingValue);
        return newValue === existingValue ? existing : newValue;
      }
      invariant(
        isNotSet || existing && existing.set,
        "invalid keyPath"
      );
      var key = step.value;
      var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
      var nextUpdated = updateInDeepMap(
        nextExisting,
        keyPathIter,
        notSetValue,
        updater
      );
      return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? existing.remove(key) : (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
    }
    function popCount(x) {
      x = x - (x >> 1 & 1431655765);
      x = (x & 858993459) + (x >> 2 & 858993459);
      x = x + (x >> 4) & 252645135;
      x = x + (x >> 8);
      x = x + (x >> 16);
      return x & 127;
    }
    function setIn(array, idx, val, canEdit) {
      var newArray = canEdit ? array : arrCopy(array);
      newArray[idx] = val;
      return newArray;
    }
    function spliceIn(array, idx, val, canEdit) {
      var newLen = array.length + 1;
      if (canEdit && idx + 1 === newLen) {
        array[idx] = val;
        return array;
      }
      var newArray = new Array(newLen);
      var after = 0;
      for (var ii = 0; ii < newLen; ii++) {
        if (ii === idx) {
          newArray[ii] = val;
          after = -1;
        } else {
          newArray[ii] = array[ii + after];
        }
      }
      return newArray;
    }
    function spliceOut(array, idx, canEdit) {
      var newLen = array.length - 1;
      if (canEdit && idx === newLen) {
        array.pop();
        return array;
      }
      var newArray = new Array(newLen);
      var after = 0;
      for (var ii = 0; ii < newLen; ii++) {
        if (ii === idx) {
          after = 1;
        }
        newArray[ii] = array[ii + after];
      }
      return newArray;
    }
    var MAX_ARRAY_MAP_SIZE = SIZE / 4;
    var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
    var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
    createClass(List, IndexedCollection);
    function List(value) {
      var empty = emptyList();
      if (value === null || value === void 0) {
        return empty;
      }
      if (isList(value)) {
        return value;
      }
      var iter = IndexedIterable(value);
      var size = iter.size;
      if (size === 0) {
        return empty;
      }
      assertNotInfinite(size);
      if (size > 0 && size < SIZE) {
        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
      }
      return empty.withMutations(function(list2) {
        list2.setSize(size);
        iter.forEach(function(v2, i2) {
          return list2.set(i2, v2);
        });
      });
    }
    List.of = function() {
      return this(arguments);
    };
    List.prototype.toString = function() {
      return this.__toString("List [", "]");
    };
    List.prototype.get = function(index2, notSetValue) {
      index2 = wrapIndex(this, index2);
      if (index2 >= 0 && index2 < this.size) {
        index2 += this._origin;
        var node = listNodeFor(this, index2);
        return node && node.array[index2 & MASK];
      }
      return notSetValue;
    };
    List.prototype.set = function(index2, value) {
      return updateList(this, index2, value);
    };
    List.prototype.remove = function(index2) {
      return !this.has(index2) ? this : index2 === 0 ? this.shift() : index2 === this.size - 1 ? this.pop() : this.splice(index2, 1);
    };
    List.prototype.insert = function(index2, value) {
      return this.splice(index2, 0, value);
    };
    List.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = this._origin = this._capacity = 0;
        this._level = SHIFT;
        this._root = this._tail = null;
        this.__hash = void 0;
        this.__altered = true;
        return this;
      }
      return emptyList();
    };
    List.prototype.push = function() {
      var values = arguments;
      var oldSize = this.size;
      return this.withMutations(function(list2) {
        setListBounds(list2, 0, oldSize + values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list2.set(oldSize + ii, values[ii]);
        }
      });
    };
    List.prototype.pop = function() {
      return setListBounds(this, 0, -1);
    };
    List.prototype.unshift = function() {
      var values = arguments;
      return this.withMutations(function(list2) {
        setListBounds(list2, -values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list2.set(ii, values[ii]);
        }
      });
    };
    List.prototype.shift = function() {
      return setListBounds(this, 1);
    };
    List.prototype.merge = function() {
      return mergeIntoListWith(this, void 0, arguments);
    };
    List.prototype.mergeWith = function(merger) {
      var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, merger, iters);
    };
    List.prototype.mergeDeep = function() {
      return mergeIntoListWith(this, deepMerger, arguments);
    };
    List.prototype.mergeDeepWith = function(merger) {
      var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, deepMergerWith(merger), iters);
    };
    List.prototype.setSize = function(size) {
      return setListBounds(this, 0, size);
    };
    List.prototype.slice = function(begin, end) {
      var size = this.size;
      if (wholeSlice(begin, end, size)) {
        return this;
      }
      return setListBounds(
        this,
        resolveBegin(begin, size),
        resolveEnd(end, size)
      );
    };
    List.prototype.__iterator = function(type2, reverse) {
      var index2 = 0;
      var values = iterateList(this, reverse);
      return new Iterator(function() {
        var value = values();
        return value === DONE ? iteratorDone() : iteratorValue(type2, index2++, value);
      });
    };
    List.prototype.__iterate = function(fn, reverse) {
      var index2 = 0;
      var values = iterateList(this, reverse);
      var value;
      while ((value = values()) !== DONE) {
        if (fn(value, index2++, this) === false) {
          break;
        }
      }
      return index2;
    };
    List.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        return this;
      }
      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
    };
    function isList(maybeList) {
      return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
    }
    List.isList = isList;
    var IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@";
    var ListPrototype = List.prototype;
    ListPrototype[IS_LIST_SENTINEL] = true;
    ListPrototype[DELETE] = ListPrototype.remove;
    ListPrototype.setIn = MapPrototype.setIn;
    ListPrototype.deleteIn = ListPrototype.removeIn = MapPrototype.removeIn;
    ListPrototype.update = MapPrototype.update;
    ListPrototype.updateIn = MapPrototype.updateIn;
    ListPrototype.mergeIn = MapPrototype.mergeIn;
    ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
    ListPrototype.withMutations = MapPrototype.withMutations;
    ListPrototype.asMutable = MapPrototype.asMutable;
    ListPrototype.asImmutable = MapPrototype.asImmutable;
    ListPrototype.wasAltered = MapPrototype.wasAltered;
    function VNode(array, ownerID) {
      this.array = array;
      this.ownerID = ownerID;
    }
    VNode.prototype.removeBefore = function(ownerID, level, index2) {
      if (index2 === level ? 1 << level : this.array.length === 0) {
        return this;
      }
      var originIndex = index2 >>> level & MASK;
      if (originIndex >= this.array.length) {
        return new VNode([], ownerID);
      }
      var removingFirst = originIndex === 0;
      var newChild;
      if (level > 0) {
        var oldChild = this.array[originIndex];
        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index2);
        if (newChild === oldChild && removingFirst) {
          return this;
        }
      }
      if (removingFirst && !newChild) {
        return this;
      }
      var editable = editableVNode(this, ownerID);
      if (!removingFirst) {
        for (var ii = 0; ii < originIndex; ii++) {
          editable.array[ii] = void 0;
        }
      }
      if (newChild) {
        editable.array[originIndex] = newChild;
      }
      return editable;
    };
    VNode.prototype.removeAfter = function(ownerID, level, index2) {
      if (index2 === (level ? 1 << level : 0) || this.array.length === 0) {
        return this;
      }
      var sizeIndex = index2 - 1 >>> level & MASK;
      if (sizeIndex >= this.array.length) {
        return this;
      }
      var newChild;
      if (level > 0) {
        var oldChild = this.array[sizeIndex];
        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index2);
        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
          return this;
        }
      }
      var editable = editableVNode(this, ownerID);
      editable.array.splice(sizeIndex + 1);
      if (newChild) {
        editable.array[sizeIndex] = newChild;
      }
      return editable;
    };
    var DONE = {};
    function iterateList(list2, reverse) {
      var left = list2._origin;
      var right = list2._capacity;
      var tailPos = getTailOffset(right);
      var tail = list2._tail;
      return iterateNodeOrLeaf(list2._root, list2._level, 0);
      function iterateNodeOrLeaf(node, level, offset2) {
        return level === 0 ? iterateLeaf(node, offset2) : iterateNode(node, level, offset2);
      }
      function iterateLeaf(node, offset2) {
        var array = offset2 === tailPos ? tail && tail.array : node && node.array;
        var from2 = offset2 > left ? 0 : left - offset2;
        var to2 = right - offset2;
        if (to2 > SIZE) {
          to2 = SIZE;
        }
        return function() {
          if (from2 === to2) {
            return DONE;
          }
          var idx = reverse ? --to2 : from2++;
          return array && array[idx];
        };
      }
      function iterateNode(node, level, offset2) {
        var values;
        var array = node && node.array;
        var from2 = offset2 > left ? 0 : left - offset2 >> level;
        var to2 = (right - offset2 >> level) + 1;
        if (to2 > SIZE) {
          to2 = SIZE;
        }
        return function() {
          do {
            if (values) {
              var value = values();
              if (value !== DONE) {
                return value;
              }
              values = null;
            }
            if (from2 === to2) {
              return DONE;
            }
            var idx = reverse ? --to2 : from2++;
            values = iterateNodeOrLeaf(
              array && array[idx],
              level - SHIFT,
              offset2 + (idx << level)
            );
          } while (true);
        };
      }
    }
    function makeList(origin, capacity, level, root2, tail, ownerID, hash2) {
      var list2 = Object.create(ListPrototype);
      list2.size = capacity - origin;
      list2._origin = origin;
      list2._capacity = capacity;
      list2._level = level;
      list2._root = root2;
      list2._tail = tail;
      list2.__ownerID = ownerID;
      list2.__hash = hash2;
      list2.__altered = false;
      return list2;
    }
    var EMPTY_LIST;
    function emptyList() {
      return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
    }
    function updateList(list2, index2, value) {
      index2 = wrapIndex(list2, index2);
      if (index2 !== index2) {
        return list2;
      }
      if (index2 >= list2.size || index2 < 0) {
        return list2.withMutations(function(list3) {
          index2 < 0 ? setListBounds(list3, index2).set(0, value) : setListBounds(list3, 0, index2 + 1).set(index2, value);
        });
      }
      index2 += list2._origin;
      var newTail = list2._tail;
      var newRoot = list2._root;
      var didAlter = MakeRef(DID_ALTER);
      if (index2 >= getTailOffset(list2._capacity)) {
        newTail = updateVNode(newTail, list2.__ownerID, 0, index2, value, didAlter);
      } else {
        newRoot = updateVNode(newRoot, list2.__ownerID, list2._level, index2, value, didAlter);
      }
      if (!didAlter.value) {
        return list2;
      }
      if (list2.__ownerID) {
        list2._root = newRoot;
        list2._tail = newTail;
        list2.__hash = void 0;
        list2.__altered = true;
        return list2;
      }
      return makeList(list2._origin, list2._capacity, list2._level, newRoot, newTail);
    }
    function updateVNode(node, ownerID, level, index2, value, didAlter) {
      var idx = index2 >>> level & MASK;
      var nodeHas = node && idx < node.array.length;
      if (!nodeHas && value === void 0) {
        return node;
      }
      var newNode;
      if (level > 0) {
        var lowerNode = node && node.array[idx];
        var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index2, value, didAlter);
        if (newLowerNode === lowerNode) {
          return node;
        }
        newNode = editableVNode(node, ownerID);
        newNode.array[idx] = newLowerNode;
        return newNode;
      }
      if (nodeHas && node.array[idx] === value) {
        return node;
      }
      SetRef(didAlter);
      newNode = editableVNode(node, ownerID);
      if (value === void 0 && idx === newNode.array.length - 1) {
        newNode.array.pop();
      } else {
        newNode.array[idx] = value;
      }
      return newNode;
    }
    function editableVNode(node, ownerID) {
      if (ownerID && node && ownerID === node.ownerID) {
        return node;
      }
      return new VNode(node ? node.array.slice() : [], ownerID);
    }
    function listNodeFor(list2, rawIndex) {
      if (rawIndex >= getTailOffset(list2._capacity)) {
        return list2._tail;
      }
      if (rawIndex < 1 << list2._level + SHIFT) {
        var node = list2._root;
        var level = list2._level;
        while (node && level > 0) {
          node = node.array[rawIndex >>> level & MASK];
          level -= SHIFT;
        }
        return node;
      }
    }
    function setListBounds(list2, begin, end) {
      if (begin !== void 0) {
        begin = begin | 0;
      }
      if (end !== void 0) {
        end = end | 0;
      }
      var owner = list2.__ownerID || new OwnerID();
      var oldOrigin = list2._origin;
      var oldCapacity = list2._capacity;
      var newOrigin = oldOrigin + begin;
      var newCapacity = end === void 0 ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
      if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
        return list2;
      }
      if (newOrigin >= newCapacity) {
        return list2.clear();
      }
      var newLevel = list2._level;
      var newRoot = list2._root;
      var offsetShift = 0;
      while (newOrigin + offsetShift < 0) {
        newRoot = new VNode(newRoot && newRoot.array.length ? [void 0, newRoot] : [], owner);
        newLevel += SHIFT;
        offsetShift += 1 << newLevel;
      }
      if (offsetShift) {
        newOrigin += offsetShift;
        oldOrigin += offsetShift;
        newCapacity += offsetShift;
        oldCapacity += offsetShift;
      }
      var oldTailOffset = getTailOffset(oldCapacity);
      var newTailOffset = getTailOffset(newCapacity);
      while (newTailOffset >= 1 << newLevel + SHIFT) {
        newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
        newLevel += SHIFT;
      }
      var oldTail = list2._tail;
      var newTail = newTailOffset < oldTailOffset ? listNodeFor(list2, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
      if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
        newRoot = editableVNode(newRoot, owner);
        var node = newRoot;
        for (var level = newLevel; level > SHIFT; level -= SHIFT) {
          var idx = oldTailOffset >>> level & MASK;
          node = node.array[idx] = editableVNode(node.array[idx], owner);
        }
        node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
      }
      if (newCapacity < oldCapacity) {
        newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
      }
      if (newOrigin >= newTailOffset) {
        newOrigin -= newTailOffset;
        newCapacity -= newTailOffset;
        newLevel = SHIFT;
        newRoot = null;
        newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
      } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
        offsetShift = 0;
        while (newRoot) {
          var beginIndex = newOrigin >>> newLevel & MASK;
          if (beginIndex !== newTailOffset >>> newLevel & MASK) {
            break;
          }
          if (beginIndex) {
            offsetShift += (1 << newLevel) * beginIndex;
          }
          newLevel -= SHIFT;
          newRoot = newRoot.array[beginIndex];
        }
        if (newRoot && newOrigin > oldOrigin) {
          newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
        }
        if (newRoot && newTailOffset < oldTailOffset) {
          newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
        }
        if (offsetShift) {
          newOrigin -= offsetShift;
          newCapacity -= offsetShift;
        }
      }
      if (list2.__ownerID) {
        list2.size = newCapacity - newOrigin;
        list2._origin = newOrigin;
        list2._capacity = newCapacity;
        list2._level = newLevel;
        list2._root = newRoot;
        list2._tail = newTail;
        list2.__hash = void 0;
        list2.__altered = true;
        return list2;
      }
      return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
    }
    function mergeIntoListWith(list2, merger, iterables) {
      var iters = [];
      var maxSize = 0;
      for (var ii = 0; ii < iterables.length; ii++) {
        var value = iterables[ii];
        var iter = IndexedIterable(value);
        if (iter.size > maxSize) {
          maxSize = iter.size;
        }
        if (!isIterable(value)) {
          iter = iter.map(function(v2) {
            return fromJS(v2);
          });
        }
        iters.push(iter);
      }
      if (maxSize > list2.size) {
        list2 = list2.setSize(maxSize);
      }
      return mergeIntoCollectionWith(list2, merger, iters);
    }
    function getTailOffset(size) {
      return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;
    }
    createClass(OrderedMap, Map2);
    function OrderedMap(value) {
      return value === null || value === void 0 ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function(map2) {
        var iter = KeyedIterable(value);
        assertNotInfinite(iter.size);
        iter.forEach(function(v2, k2) {
          return map2.set(k2, v2);
        });
      });
    }
    OrderedMap.of = function() {
      return this(arguments);
    };
    OrderedMap.prototype.toString = function() {
      return this.__toString("OrderedMap {", "}");
    };
    OrderedMap.prototype.get = function(k2, notSetValue) {
      var index2 = this._map.get(k2);
      return index2 !== void 0 ? this._list.get(index2)[1] : notSetValue;
    };
    OrderedMap.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._map.clear();
        this._list.clear();
        return this;
      }
      return emptyOrderedMap();
    };
    OrderedMap.prototype.set = function(k2, v2) {
      return updateOrderedMap(this, k2, v2);
    };
    OrderedMap.prototype.remove = function(k2) {
      return updateOrderedMap(this, k2, NOT_SET);
    };
    OrderedMap.prototype.wasAltered = function() {
      return this._map.wasAltered() || this._list.wasAltered();
    };
    OrderedMap.prototype.__iterate = function(fn, reverse) {
      var this$0 = this;
      return this._list.__iterate(
        function(entry) {
          return entry && fn(entry[1], entry[0], this$0);
        },
        reverse
      );
    };
    OrderedMap.prototype.__iterator = function(type2, reverse) {
      return this._list.fromEntrySeq().__iterator(type2, reverse);
    };
    OrderedMap.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      var newList = this._list.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        this._list = newList;
        return this;
      }
      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
    };
    function isOrderedMap(maybeOrderedMap) {
      return isMap2(maybeOrderedMap) && isOrdered(maybeOrderedMap);
    }
    OrderedMap.isOrderedMap = isOrderedMap;
    OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
    OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
    function makeOrderedMap(map2, list2, ownerID, hash2) {
      var omap = Object.create(OrderedMap.prototype);
      omap.size = map2 ? map2.size : 0;
      omap._map = map2;
      omap._list = list2;
      omap.__ownerID = ownerID;
      omap.__hash = hash2;
      return omap;
    }
    var EMPTY_ORDERED_MAP;
    function emptyOrderedMap() {
      return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
    }
    function updateOrderedMap(omap, k2, v2) {
      var map2 = omap._map;
      var list2 = omap._list;
      var i2 = map2.get(k2);
      var has = i2 !== void 0;
      var newMap;
      var newList;
      if (v2 === NOT_SET) {
        if (!has) {
          return omap;
        }
        if (list2.size >= SIZE && list2.size >= map2.size * 2) {
          newList = list2.filter(function(entry, idx) {
            return entry !== void 0 && i2 !== idx;
          });
          newMap = newList.toKeyedSeq().map(function(entry) {
            return entry[0];
          }).flip().toMap();
          if (omap.__ownerID) {
            newMap.__ownerID = newList.__ownerID = omap.__ownerID;
          }
        } else {
          newMap = map2.remove(k2);
          newList = i2 === list2.size - 1 ? list2.pop() : list2.set(i2, void 0);
        }
      } else {
        if (has) {
          if (v2 === list2.get(i2)[1]) {
            return omap;
          }
          newMap = map2;
          newList = list2.set(i2, [k2, v2]);
        } else {
          newMap = map2.set(k2, list2.size);
          newList = list2.set(list2.size, [k2, v2]);
        }
      }
      if (omap.__ownerID) {
        omap.size = newMap.size;
        omap._map = newMap;
        omap._list = newList;
        omap.__hash = void 0;
        return omap;
      }
      return makeOrderedMap(newMap, newList);
    }
    createClass(ToKeyedSequence, KeyedSeq);
    function ToKeyedSequence(indexed, useKeys) {
      this._iter = indexed;
      this._useKeys = useKeys;
      this.size = indexed.size;
    }
    ToKeyedSequence.prototype.get = function(key, notSetValue) {
      return this._iter.get(key, notSetValue);
    };
    ToKeyedSequence.prototype.has = function(key) {
      return this._iter.has(key);
    };
    ToKeyedSequence.prototype.valueSeq = function() {
      return this._iter.valueSeq();
    };
    ToKeyedSequence.prototype.reverse = function() {
      var this$0 = this;
      var reversedSequence = reverseFactory(this, true);
      if (!this._useKeys) {
        reversedSequence.valueSeq = function() {
          return this$0._iter.toSeq().reverse();
        };
      }
      return reversedSequence;
    };
    ToKeyedSequence.prototype.map = function(mapper, context2) {
      var this$0 = this;
      var mappedSequence = mapFactory(this, mapper, context2);
      if (!this._useKeys) {
        mappedSequence.valueSeq = function() {
          return this$0._iter.toSeq().map(mapper, context2);
        };
      }
      return mappedSequence;
    };
    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {
      var this$0 = this;
      var ii;
      return this._iter.__iterate(
        this._useKeys ? function(v2, k2) {
          return fn(v2, k2, this$0);
        } : (ii = reverse ? resolveSize(this) : 0, function(v2) {
          return fn(v2, reverse ? --ii : ii++, this$0);
        }),
        reverse
      );
    };
    ToKeyedSequence.prototype.__iterator = function(type2, reverse) {
      if (this._useKeys) {
        return this._iter.__iterator(type2, reverse);
      }
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      var ii = reverse ? resolveSize(this) : 0;
      return new Iterator(function() {
        var step = iterator.next();
        return step.done ? step : iteratorValue(type2, reverse ? --ii : ii++, step.value, step);
      });
    };
    ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;
    createClass(ToIndexedSequence, IndexedSeq);
    function ToIndexedSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }
    ToIndexedSequence.prototype.includes = function(value) {
      return this._iter.includes(value);
    };
    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {
      var this$0 = this;
      var iterations = 0;
      return this._iter.__iterate(function(v2) {
        return fn(v2, iterations++, this$0);
      }, reverse);
    };
    ToIndexedSequence.prototype.__iterator = function(type2, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      var iterations = 0;
      return new Iterator(function() {
        var step = iterator.next();
        return step.done ? step : iteratorValue(type2, iterations++, step.value, step);
      });
    };
    createClass(ToSetSequence, SetSeq);
    function ToSetSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }
    ToSetSequence.prototype.has = function(key) {
      return this._iter.includes(key);
    };
    ToSetSequence.prototype.__iterate = function(fn, reverse) {
      var this$0 = this;
      return this._iter.__iterate(function(v2) {
        return fn(v2, v2, this$0);
      }, reverse);
    };
    ToSetSequence.prototype.__iterator = function(type2, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new Iterator(function() {
        var step = iterator.next();
        return step.done ? step : iteratorValue(type2, step.value, step.value, step);
      });
    };
    createClass(FromEntriesSequence, KeyedSeq);
    function FromEntriesSequence(entries) {
      this._iter = entries;
      this.size = entries.size;
    }
    FromEntriesSequence.prototype.entrySeq = function() {
      return this._iter.toSeq();
    };
    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {
      var this$0 = this;
      return this._iter.__iterate(function(entry) {
        if (entry) {
          validateEntry(entry);
          var indexedIterable = isIterable(entry);
          return fn(
            indexedIterable ? entry.get(1) : entry[1],
            indexedIterable ? entry.get(0) : entry[0],
            this$0
          );
        }
      }, reverse);
    };
    FromEntriesSequence.prototype.__iterator = function(type2, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new Iterator(function() {
        while (true) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          if (entry) {
            validateEntry(entry);
            var indexedIterable = isIterable(entry);
            return iteratorValue(
              type2,
              indexedIterable ? entry.get(0) : entry[0],
              indexedIterable ? entry.get(1) : entry[1],
              step
            );
          }
        }
      });
    };
    ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;
    function flipFactory(iterable) {
      var flipSequence = makeSequence(iterable);
      flipSequence._iter = iterable;
      flipSequence.size = iterable.size;
      flipSequence.flip = function() {
        return iterable;
      };
      flipSequence.reverse = function() {
        var reversedSequence = iterable.reverse.apply(this);
        reversedSequence.flip = function() {
          return iterable.reverse();
        };
        return reversedSequence;
      };
      flipSequence.has = function(key) {
        return iterable.includes(key);
      };
      flipSequence.includes = function(key) {
        return iterable.has(key);
      };
      flipSequence.cacheResult = cacheResultThrough;
      flipSequence.__iterateUncached = function(fn, reverse) {
        var this$0 = this;
        return iterable.__iterate(function(v2, k2) {
          return fn(k2, v2, this$0) !== false;
        }, reverse);
      };
      flipSequence.__iteratorUncached = function(type2, reverse) {
        if (type2 === ITERATE_ENTRIES) {
          var iterator = iterable.__iterator(type2, reverse);
          return new Iterator(function() {
            var step = iterator.next();
            if (!step.done) {
              var k2 = step.value[0];
              step.value[0] = step.value[1];
              step.value[1] = k2;
            }
            return step;
          });
        }
        return iterable.__iterator(
          type2 === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
          reverse
        );
      };
      return flipSequence;
    }
    function mapFactory(iterable, mapper, context2) {
      var mappedSequence = makeSequence(iterable);
      mappedSequence.size = iterable.size;
      mappedSequence.has = function(key) {
        return iterable.has(key);
      };
      mappedSequence.get = function(key, notSetValue) {
        var v2 = iterable.get(key, NOT_SET);
        return v2 === NOT_SET ? notSetValue : mapper.call(context2, v2, key, iterable);
      };
      mappedSequence.__iterateUncached = function(fn, reverse) {
        var this$0 = this;
        return iterable.__iterate(
          function(v2, k2, c2) {
            return fn(mapper.call(context2, v2, k2, c2), k2, this$0) !== false;
          },
          reverse
        );
      };
      mappedSequence.__iteratorUncached = function(type2, reverse) {
        var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
        return new Iterator(function() {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          var key = entry[0];
          return iteratorValue(
            type2,
            key,
            mapper.call(context2, entry[1], key, iterable),
            step
          );
        });
      };
      return mappedSequence;
    }
    function reverseFactory(iterable, useKeys) {
      var reversedSequence = makeSequence(iterable);
      reversedSequence._iter = iterable;
      reversedSequence.size = iterable.size;
      reversedSequence.reverse = function() {
        return iterable;
      };
      if (iterable.flip) {
        reversedSequence.flip = function() {
          var flipSequence = flipFactory(iterable);
          flipSequence.reverse = function() {
            return iterable.flip();
          };
          return flipSequence;
        };
      }
      reversedSequence.get = function(key, notSetValue) {
        return iterable.get(useKeys ? key : -1 - key, notSetValue);
      };
      reversedSequence.has = function(key) {
        return iterable.has(useKeys ? key : -1 - key);
      };
      reversedSequence.includes = function(value) {
        return iterable.includes(value);
      };
      reversedSequence.cacheResult = cacheResultThrough;
      reversedSequence.__iterate = function(fn, reverse) {
        var this$0 = this;
        return iterable.__iterate(function(v2, k2) {
          return fn(v2, k2, this$0);
        }, !reverse);
      };
      reversedSequence.__iterator = function(type2, reverse) {
        return iterable.__iterator(type2, !reverse);
      };
      return reversedSequence;
    }
    function filterFactory(iterable, predicate, context2, useKeys) {
      var filterSequence = makeSequence(iterable);
      if (useKeys) {
        filterSequence.has = function(key) {
          var v2 = iterable.get(key, NOT_SET);
          return v2 !== NOT_SET && !!predicate.call(context2, v2, key, iterable);
        };
        filterSequence.get = function(key, notSetValue) {
          var v2 = iterable.get(key, NOT_SET);
          return v2 !== NOT_SET && predicate.call(context2, v2, key, iterable) ? v2 : notSetValue;
        };
      }
      filterSequence.__iterateUncached = function(fn, reverse) {
        var this$0 = this;
        var iterations = 0;
        iterable.__iterate(function(v2, k2, c2) {
          if (predicate.call(context2, v2, k2, c2)) {
            iterations++;
            return fn(v2, useKeys ? k2 : iterations - 1, this$0);
          }
        }, reverse);
        return iterations;
      };
      filterSequence.__iteratorUncached = function(type2, reverse) {
        var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
        var iterations = 0;
        return new Iterator(function() {
          while (true) {
            var step = iterator.next();
            if (step.done) {
              return step;
            }
            var entry = step.value;
            var key = entry[0];
            var value = entry[1];
            if (predicate.call(context2, value, key, iterable)) {
              return iteratorValue(type2, useKeys ? key : iterations++, value, step);
            }
          }
        });
      };
      return filterSequence;
    }
    function countByFactory(iterable, grouper, context2) {
      var groups = Map2().asMutable();
      iterable.__iterate(function(v2, k2) {
        groups.update(
          grouper.call(context2, v2, k2, iterable),
          0,
          function(a2) {
            return a2 + 1;
          }
        );
      });
      return groups.asImmutable();
    }
    function groupByFactory(iterable, grouper, context2) {
      var isKeyedIter = isKeyed(iterable);
      var groups = (isOrdered(iterable) ? OrderedMap() : Map2()).asMutable();
      iterable.__iterate(function(v2, k2) {
        groups.update(
          grouper.call(context2, v2, k2, iterable),
          function(a2) {
            return a2 = a2 || [], a2.push(isKeyedIter ? [k2, v2] : v2), a2;
          }
        );
      });
      var coerce = iterableClass(iterable);
      return groups.map(function(arr) {
        return reify(iterable, coerce(arr));
      });
    }
    function sliceFactory(iterable, begin, end, useKeys) {
      var originalSize = iterable.size;
      if (begin !== void 0) {
        begin = begin | 0;
      }
      if (end !== void 0) {
        if (end === Infinity) {
          end = originalSize;
        } else {
          end = end | 0;
        }
      }
      if (wholeSlice(begin, end, originalSize)) {
        return iterable;
      }
      var resolvedBegin = resolveBegin(begin, originalSize);
      var resolvedEnd = resolveEnd(end, originalSize);
      if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
        return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
      }
      var resolvedSize = resolvedEnd - resolvedBegin;
      var sliceSize;
      if (resolvedSize === resolvedSize) {
        sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
      }
      var sliceSeq = makeSequence(iterable);
      sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || void 0;
      if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
        sliceSeq.get = function(index2, notSetValue) {
          index2 = wrapIndex(this, index2);
          return index2 >= 0 && index2 < sliceSize ? iterable.get(index2 + resolvedBegin, notSetValue) : notSetValue;
        };
      }
      sliceSeq.__iterateUncached = function(fn, reverse) {
        var this$0 = this;
        if (sliceSize === 0) {
          return 0;
        }
        if (reverse) {
          return this.cacheResult().__iterate(fn, reverse);
        }
        var skipped = 0;
        var isSkipping = true;
        var iterations = 0;
        iterable.__iterate(function(v2, k2) {
          if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
            iterations++;
            return fn(v2, useKeys ? k2 : iterations - 1, this$0) !== false && iterations !== sliceSize;
          }
        });
        return iterations;
      };
      sliceSeq.__iteratorUncached = function(type2, reverse) {
        if (sliceSize !== 0 && reverse) {
          return this.cacheResult().__iterator(type2, reverse);
        }
        var iterator = sliceSize !== 0 && iterable.__iterator(type2, reverse);
        var skipped = 0;
        var iterations = 0;
        return new Iterator(function() {
          while (skipped++ < resolvedBegin) {
            iterator.next();
          }
          if (++iterations > sliceSize) {
            return iteratorDone();
          }
          var step = iterator.next();
          if (useKeys || type2 === ITERATE_VALUES) {
            return step;
          } else if (type2 === ITERATE_KEYS) {
            return iteratorValue(type2, iterations - 1, void 0, step);
          } else {
            return iteratorValue(type2, iterations - 1, step.value[1], step);
          }
        });
      };
      return sliceSeq;
    }
    function takeWhileFactory(iterable, predicate, context2) {
      var takeSequence = makeSequence(iterable);
      takeSequence.__iterateUncached = function(fn, reverse) {
        var this$0 = this;
        if (reverse) {
          return this.cacheResult().__iterate(fn, reverse);
        }
        var iterations = 0;
        iterable.__iterate(
          function(v2, k2, c2) {
            return predicate.call(context2, v2, k2, c2) && ++iterations && fn(v2, k2, this$0);
          }
        );
        return iterations;
      };
      takeSequence.__iteratorUncached = function(type2, reverse) {
        var this$0 = this;
        if (reverse) {
          return this.cacheResult().__iterator(type2, reverse);
        }
        var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
        var iterating = true;
        return new Iterator(function() {
          if (!iterating) {
            return iteratorDone();
          }
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          var k2 = entry[0];
          var v2 = entry[1];
          if (!predicate.call(context2, v2, k2, this$0)) {
            iterating = false;
            return iteratorDone();
          }
          return type2 === ITERATE_ENTRIES ? step : iteratorValue(type2, k2, v2, step);
        });
      };
      return takeSequence;
    }
    function skipWhileFactory(iterable, predicate, context2, useKeys) {
      var skipSequence = makeSequence(iterable);
      skipSequence.__iterateUncached = function(fn, reverse) {
        var this$0 = this;
        if (reverse) {
          return this.cacheResult().__iterate(fn, reverse);
        }
        var isSkipping = true;
        var iterations = 0;
        iterable.__iterate(function(v2, k2, c2) {
          if (!(isSkipping && (isSkipping = predicate.call(context2, v2, k2, c2)))) {
            iterations++;
            return fn(v2, useKeys ? k2 : iterations - 1, this$0);
          }
        });
        return iterations;
      };
      skipSequence.__iteratorUncached = function(type2, reverse) {
        var this$0 = this;
        if (reverse) {
          return this.cacheResult().__iterator(type2, reverse);
        }
        var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
        var skipping = true;
        var iterations = 0;
        return new Iterator(function() {
          var step, k2, v2;
          do {
            step = iterator.next();
            if (step.done) {
              if (useKeys || type2 === ITERATE_VALUES) {
                return step;
              } else if (type2 === ITERATE_KEYS) {
                return iteratorValue(type2, iterations++, void 0, step);
              } else {
                return iteratorValue(type2, iterations++, step.value[1], step);
              }
            }
            var entry = step.value;
            k2 = entry[0];
            v2 = entry[1];
            skipping && (skipping = predicate.call(context2, v2, k2, this$0));
          } while (skipping);
          return type2 === ITERATE_ENTRIES ? step : iteratorValue(type2, k2, v2, step);
        });
      };
      return skipSequence;
    }
    function concatFactory(iterable, values) {
      var isKeyedIterable = isKeyed(iterable);
      var iters = [iterable].concat(values).map(function(v2) {
        if (!isIterable(v2)) {
          v2 = isKeyedIterable ? keyedSeqFromValue(v2) : indexedSeqFromValue(Array.isArray(v2) ? v2 : [v2]);
        } else if (isKeyedIterable) {
          v2 = KeyedIterable(v2);
        }
        return v2;
      }).filter(function(v2) {
        return v2.size !== 0;
      });
      if (iters.length === 0) {
        return iterable;
      }
      if (iters.length === 1) {
        var singleton = iters[0];
        if (singleton === iterable || isKeyedIterable && isKeyed(singleton) || isIndexed(iterable) && isIndexed(singleton)) {
          return singleton;
        }
      }
      var concatSeq = new ArraySeq(iters);
      if (isKeyedIterable) {
        concatSeq = concatSeq.toKeyedSeq();
      } else if (!isIndexed(iterable)) {
        concatSeq = concatSeq.toSetSeq();
      }
      concatSeq = concatSeq.flatten(true);
      concatSeq.size = iters.reduce(
        function(sum, seq) {
          if (sum !== void 0) {
            var size = seq.size;
            if (size !== void 0) {
              return sum + size;
            }
          }
        },
        0
      );
      return concatSeq;
    }
    function flattenFactory(iterable, depth, useKeys) {
      var flatSequence = makeSequence(iterable);
      flatSequence.__iterateUncached = function(fn, reverse) {
        var iterations = 0;
        var stopped = false;
        function flatDeep(iter, currentDepth) {
          var this$0 = this;
          iter.__iterate(function(v2, k2) {
            if ((!depth || currentDepth < depth) && isIterable(v2)) {
              flatDeep(v2, currentDepth + 1);
            } else if (fn(v2, useKeys ? k2 : iterations++, this$0) === false) {
              stopped = true;
            }
            return !stopped;
          }, reverse);
        }
        flatDeep(iterable, 0);
        return iterations;
      };
      flatSequence.__iteratorUncached = function(type2, reverse) {
        var iterator = iterable.__iterator(type2, reverse);
        var stack = [];
        var iterations = 0;
        return new Iterator(function() {
          while (iterator) {
            var step = iterator.next();
            if (step.done !== false) {
              iterator = stack.pop();
              continue;
            }
            var v2 = step.value;
            if (type2 === ITERATE_ENTRIES) {
              v2 = v2[1];
            }
            if ((!depth || stack.length < depth) && isIterable(v2)) {
              stack.push(iterator);
              iterator = v2.__iterator(type2, reverse);
            } else {
              return useKeys ? step : iteratorValue(type2, iterations++, v2, step);
            }
          }
          return iteratorDone();
        });
      };
      return flatSequence;
    }
    function flatMapFactory(iterable, mapper, context2) {
      var coerce = iterableClass(iterable);
      return iterable.toSeq().map(
        function(v2, k2) {
          return coerce(mapper.call(context2, v2, k2, iterable));
        }
      ).flatten(true);
    }
    function interposeFactory(iterable, separator) {
      var interposedSequence = makeSequence(iterable);
      interposedSequence.size = iterable.size && iterable.size * 2 - 1;
      interposedSequence.__iterateUncached = function(fn, reverse) {
        var this$0 = this;
        var iterations = 0;
        iterable.__iterate(
          function(v2, k2) {
            return (!iterations || fn(separator, iterations++, this$0) !== false) && fn(v2, iterations++, this$0) !== false;
          },
          reverse
        );
        return iterations;
      };
      interposedSequence.__iteratorUncached = function(type2, reverse) {
        var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
        var iterations = 0;
        var step;
        return new Iterator(function() {
          if (!step || iterations % 2) {
            step = iterator.next();
            if (step.done) {
              return step;
            }
          }
          return iterations % 2 ? iteratorValue(type2, iterations++, separator) : iteratorValue(type2, iterations++, step.value, step);
        });
      };
      return interposedSequence;
    }
    function sortFactory(iterable, comparator, mapper) {
      if (!comparator) {
        comparator = defaultComparator;
      }
      var isKeyedIterable = isKeyed(iterable);
      var index2 = 0;
      var entries = iterable.toSeq().map(
        function(v2, k2) {
          return [k2, v2, index2++, mapper ? mapper(v2, k2, iterable) : v2];
        }
      ).toArray();
      entries.sort(function(a2, b2) {
        return comparator(a2[3], b2[3]) || a2[2] - b2[2];
      }).forEach(
        isKeyedIterable ? function(v2, i2) {
          entries[i2].length = 2;
        } : function(v2, i2) {
          entries[i2] = v2[1];
        }
      );
      return isKeyedIterable ? KeyedSeq(entries) : isIndexed(iterable) ? IndexedSeq(entries) : SetSeq(entries);
    }
    function maxFactory(iterable, comparator, mapper) {
      if (!comparator) {
        comparator = defaultComparator;
      }
      if (mapper) {
        var entry = iterable.toSeq().map(function(v2, k2) {
          return [v2, mapper(v2, k2, iterable)];
        }).reduce(function(a2, b2) {
          return maxCompare(comparator, a2[1], b2[1]) ? b2 : a2;
        });
        return entry && entry[0];
      } else {
        return iterable.reduce(function(a2, b2) {
          return maxCompare(comparator, a2, b2) ? b2 : a2;
        });
      }
    }
    function maxCompare(comparator, a2, b2) {
      var comp = comparator(b2, a2);
      return comp === 0 && b2 !== a2 && (b2 === void 0 || b2 === null || b2 !== b2) || comp > 0;
    }
    function zipWithFactory(keyIter, zipper, iters) {
      var zipSequence = makeSequence(keyIter);
      zipSequence.size = new ArraySeq(iters).map(function(i2) {
        return i2.size;
      }).min();
      zipSequence.__iterate = function(fn, reverse) {
        var iterator = this.__iterator(ITERATE_VALUES, reverse);
        var step;
        var iterations = 0;
        while (!(step = iterator.next()).done) {
          if (fn(step.value, iterations++, this) === false) {
            break;
          }
        }
        return iterations;
      };
      zipSequence.__iteratorUncached = function(type2, reverse) {
        var iterators = iters.map(
          function(i2) {
            return i2 = Iterable(i2), getIterator(reverse ? i2.reverse() : i2);
          }
        );
        var iterations = 0;
        var isDone = false;
        return new Iterator(function() {
          var steps;
          if (!isDone) {
            steps = iterators.map(function(i2) {
              return i2.next();
            });
            isDone = steps.some(function(s2) {
              return s2.done;
            });
          }
          if (isDone) {
            return iteratorDone();
          }
          return iteratorValue(
            type2,
            iterations++,
            zipper.apply(null, steps.map(function(s2) {
              return s2.value;
            }))
          );
        });
      };
      return zipSequence;
    }
    function reify(iter, seq) {
      return isSeq(iter) ? seq : iter.constructor(seq);
    }
    function validateEntry(entry) {
      if (entry !== Object(entry)) {
        throw new TypeError("Expected [K, V] tuple: " + entry);
      }
    }
    function resolveSize(iter) {
      assertNotInfinite(iter.size);
      return ensureSize(iter);
    }
    function iterableClass(iterable) {
      return isKeyed(iterable) ? KeyedIterable : isIndexed(iterable) ? IndexedIterable : SetIterable;
    }
    function makeSequence(iterable) {
      return Object.create(
        (isKeyed(iterable) ? KeyedSeq : isIndexed(iterable) ? IndexedSeq : SetSeq).prototype
      );
    }
    function cacheResultThrough() {
      if (this._iter.cacheResult) {
        this._iter.cacheResult();
        this.size = this._iter.size;
        return this;
      } else {
        return Seq.prototype.cacheResult.call(this);
      }
    }
    function defaultComparator(a2, b2) {
      return a2 > b2 ? 1 : a2 < b2 ? -1 : 0;
    }
    function forceIterator(keyPath) {
      var iter = getIterator(keyPath);
      if (!iter) {
        if (!isArrayLike2(keyPath)) {
          throw new TypeError("Expected iterable or array-like: " + keyPath);
        }
        iter = getIterator(Iterable(keyPath));
      }
      return iter;
    }
    createClass(Record, KeyedCollection);
    function Record(defaultValues, name) {
      var hasInitialized;
      var RecordType = function Record2(values) {
        if (values instanceof RecordType) {
          return values;
        }
        if (!(this instanceof RecordType)) {
          return new RecordType(values);
        }
        if (!hasInitialized) {
          hasInitialized = true;
          var keys2 = Object.keys(defaultValues);
          setProps(RecordTypePrototype, keys2);
          RecordTypePrototype.size = keys2.length;
          RecordTypePrototype._name = name;
          RecordTypePrototype._keys = keys2;
          RecordTypePrototype._defaultValues = defaultValues;
        }
        this._map = Map2(values);
      };
      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
      RecordTypePrototype.constructor = RecordType;
      return RecordType;
    }
    Record.prototype.toString = function() {
      return this.__toString(recordName(this) + " {", "}");
    };
    Record.prototype.has = function(k2) {
      return this._defaultValues.hasOwnProperty(k2);
    };
    Record.prototype.get = function(k2, notSetValue) {
      if (!this.has(k2)) {
        return notSetValue;
      }
      var defaultVal = this._defaultValues[k2];
      return this._map ? this._map.get(k2, defaultVal) : defaultVal;
    };
    Record.prototype.clear = function() {
      if (this.__ownerID) {
        this._map && this._map.clear();
        return this;
      }
      var RecordType = this.constructor;
      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
    };
    Record.prototype.set = function(k2, v2) {
      if (!this.has(k2)) {
        throw new Error('Cannot set unknown key "' + k2 + '" on ' + recordName(this));
      }
      if (this._map && !this._map.has(k2)) {
        var defaultVal = this._defaultValues[k2];
        if (v2 === defaultVal) {
          return this;
        }
      }
      var newMap = this._map && this._map.set(k2, v2);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };
    Record.prototype.remove = function(k2) {
      if (!this.has(k2)) {
        return this;
      }
      var newMap = this._map && this._map.remove(k2);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };
    Record.prototype.wasAltered = function() {
      return this._map.wasAltered();
    };
    Record.prototype.__iterator = function(type2, reverse) {
      var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function(_, k2) {
        return this$0.get(k2);
      }).__iterator(type2, reverse);
    };
    Record.prototype.__iterate = function(fn, reverse) {
      var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function(_, k2) {
        return this$0.get(k2);
      }).__iterate(fn, reverse);
    };
    Record.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map && this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return makeRecord(this, newMap, ownerID);
    };
    var RecordPrototype = Record.prototype;
    RecordPrototype[DELETE] = RecordPrototype.remove;
    RecordPrototype.deleteIn = RecordPrototype.removeIn = MapPrototype.removeIn;
    RecordPrototype.merge = MapPrototype.merge;
    RecordPrototype.mergeWith = MapPrototype.mergeWith;
    RecordPrototype.mergeIn = MapPrototype.mergeIn;
    RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
    RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
    RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
    RecordPrototype.setIn = MapPrototype.setIn;
    RecordPrototype.update = MapPrototype.update;
    RecordPrototype.updateIn = MapPrototype.updateIn;
    RecordPrototype.withMutations = MapPrototype.withMutations;
    RecordPrototype.asMutable = MapPrototype.asMutable;
    RecordPrototype.asImmutable = MapPrototype.asImmutable;
    function makeRecord(likeRecord, map2, ownerID) {
      var record = Object.create(Object.getPrototypeOf(likeRecord));
      record._map = map2;
      record.__ownerID = ownerID;
      return record;
    }
    function recordName(record) {
      return record._name || record.constructor.name || "Record";
    }
    function setProps(prototype, names2) {
      try {
        names2.forEach(setProp.bind(void 0, prototype));
      } catch (error2) {
      }
    }
    function setProp(prototype, name) {
      Object.defineProperty(prototype, name, {
        get: function() {
          return this.get(name);
        },
        set: function(value) {
          invariant(this.__ownerID, "Cannot set on an immutable record.");
          this.set(name, value);
        }
      });
    }
    createClass(Set2, SetCollection);
    function Set2(value) {
      return value === null || value === void 0 ? emptySet() : isSet2(value) && !isOrdered(value) ? value : emptySet().withMutations(function(set2) {
        var iter = SetIterable(value);
        assertNotInfinite(iter.size);
        iter.forEach(function(v2) {
          return set2.add(v2);
        });
      });
    }
    Set2.of = function() {
      return this(arguments);
    };
    Set2.fromKeys = function(value) {
      return this(KeyedIterable(value).keySeq());
    };
    Set2.prototype.toString = function() {
      return this.__toString("Set {", "}");
    };
    Set2.prototype.has = function(value) {
      return this._map.has(value);
    };
    Set2.prototype.add = function(value) {
      return updateSet(this, this._map.set(value, true));
    };
    Set2.prototype.remove = function(value) {
      return updateSet(this, this._map.remove(value));
    };
    Set2.prototype.clear = function() {
      return updateSet(this, this._map.clear());
    };
    Set2.prototype.union = function() {
      var iters = SLICE$0.call(arguments, 0);
      iters = iters.filter(function(x) {
        return x.size !== 0;
      });
      if (iters.length === 0) {
        return this;
      }
      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
        return this.constructor(iters[0]);
      }
      return this.withMutations(function(set2) {
        for (var ii = 0; ii < iters.length; ii++) {
          SetIterable(iters[ii]).forEach(function(value) {
            return set2.add(value);
          });
        }
      });
    };
    Set2.prototype.intersect = function() {
      var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function(iter) {
        return SetIterable(iter);
      });
      var originalSet = this;
      return this.withMutations(function(set2) {
        originalSet.forEach(function(value) {
          if (!iters.every(function(iter) {
            return iter.includes(value);
          })) {
            set2.remove(value);
          }
        });
      });
    };
    Set2.prototype.subtract = function() {
      var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function(iter) {
        return SetIterable(iter);
      });
      var originalSet = this;
      return this.withMutations(function(set2) {
        originalSet.forEach(function(value) {
          if (iters.some(function(iter) {
            return iter.includes(value);
          })) {
            set2.remove(value);
          }
        });
      });
    };
    Set2.prototype.merge = function() {
      return this.union.apply(this, arguments);
    };
    Set2.prototype.mergeWith = function(merger) {
      var iters = SLICE$0.call(arguments, 1);
      return this.union.apply(this, iters);
    };
    Set2.prototype.sort = function(comparator) {
      return OrderedSet(sortFactory(this, comparator));
    };
    Set2.prototype.sortBy = function(mapper, comparator) {
      return OrderedSet(sortFactory(this, comparator, mapper));
    };
    Set2.prototype.wasAltered = function() {
      return this._map.wasAltered();
    };
    Set2.prototype.__iterate = function(fn, reverse) {
      var this$0 = this;
      return this._map.__iterate(function(_, k2) {
        return fn(k2, k2, this$0);
      }, reverse);
    };
    Set2.prototype.__iterator = function(type2, reverse) {
      return this._map.map(function(_, k2) {
        return k2;
      }).__iterator(type2, reverse);
    };
    Set2.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return this.__make(newMap, ownerID);
    };
    function isSet2(maybeSet) {
      return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
    }
    Set2.isSet = isSet2;
    var IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@";
    var SetPrototype = Set2.prototype;
    SetPrototype[IS_SET_SENTINEL] = true;
    SetPrototype[DELETE] = SetPrototype.remove;
    SetPrototype.mergeDeep = SetPrototype.merge;
    SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
    SetPrototype.withMutations = MapPrototype.withMutations;
    SetPrototype.asMutable = MapPrototype.asMutable;
    SetPrototype.asImmutable = MapPrototype.asImmutable;
    SetPrototype.__empty = emptySet;
    SetPrototype.__make = makeSet;
    function updateSet(set2, newMap) {
      if (set2.__ownerID) {
        set2.size = newMap.size;
        set2._map = newMap;
        return set2;
      }
      return newMap === set2._map ? set2 : newMap.size === 0 ? set2.__empty() : set2.__make(newMap);
    }
    function makeSet(map2, ownerID) {
      var set2 = Object.create(SetPrototype);
      set2.size = map2 ? map2.size : 0;
      set2._map = map2;
      set2.__ownerID = ownerID;
      return set2;
    }
    var EMPTY_SET;
    function emptySet() {
      return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
    }
    createClass(OrderedSet, Set2);
    function OrderedSet(value) {
      return value === null || value === void 0 ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function(set2) {
        var iter = SetIterable(value);
        assertNotInfinite(iter.size);
        iter.forEach(function(v2) {
          return set2.add(v2);
        });
      });
    }
    OrderedSet.of = function() {
      return this(arguments);
    };
    OrderedSet.fromKeys = function(value) {
      return this(KeyedIterable(value).keySeq());
    };
    OrderedSet.prototype.toString = function() {
      return this.__toString("OrderedSet {", "}");
    };
    function isOrderedSet(maybeOrderedSet) {
      return isSet2(maybeOrderedSet) && isOrdered(maybeOrderedSet);
    }
    OrderedSet.isOrderedSet = isOrderedSet;
    var OrderedSetPrototype = OrderedSet.prototype;
    OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;
    OrderedSetPrototype.__empty = emptyOrderedSet;
    OrderedSetPrototype.__make = makeOrderedSet;
    function makeOrderedSet(map2, ownerID) {
      var set2 = Object.create(OrderedSetPrototype);
      set2.size = map2 ? map2.size : 0;
      set2._map = map2;
      set2.__ownerID = ownerID;
      return set2;
    }
    var EMPTY_ORDERED_SET;
    function emptyOrderedSet() {
      return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
    }
    createClass(Stack2, IndexedCollection);
    function Stack2(value) {
      return value === null || value === void 0 ? emptyStack() : isStack(value) ? value : emptyStack().unshiftAll(value);
    }
    Stack2.of = function() {
      return this(arguments);
    };
    Stack2.prototype.toString = function() {
      return this.__toString("Stack [", "]");
    };
    Stack2.prototype.get = function(index2, notSetValue) {
      var head = this._head;
      index2 = wrapIndex(this, index2);
      while (head && index2--) {
        head = head.next;
      }
      return head ? head.value : notSetValue;
    };
    Stack2.prototype.peek = function() {
      return this._head && this._head.value;
    };
    Stack2.prototype.push = function() {
      if (arguments.length === 0) {
        return this;
      }
      var newSize = this.size + arguments.length;
      var head = this._head;
      for (var ii = arguments.length - 1; ii >= 0; ii--) {
        head = {
          value: arguments[ii],
          next: head
        };
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = void 0;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };
    Stack2.prototype.pushAll = function(iter) {
      iter = IndexedIterable(iter);
      if (iter.size === 0) {
        return this;
      }
      assertNotInfinite(iter.size);
      var newSize = this.size;
      var head = this._head;
      iter.reverse().forEach(function(value) {
        newSize++;
        head = {
          value,
          next: head
        };
      });
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = void 0;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };
    Stack2.prototype.pop = function() {
      return this.slice(1);
    };
    Stack2.prototype.unshift = function() {
      return this.push.apply(this, arguments);
    };
    Stack2.prototype.unshiftAll = function(iter) {
      return this.pushAll(iter);
    };
    Stack2.prototype.shift = function() {
      return this.pop.apply(this, arguments);
    };
    Stack2.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._head = void 0;
        this.__hash = void 0;
        this.__altered = true;
        return this;
      }
      return emptyStack();
    };
    Stack2.prototype.slice = function(begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      var resolvedBegin = resolveBegin(begin, this.size);
      var resolvedEnd = resolveEnd(end, this.size);
      if (resolvedEnd !== this.size) {
        return IndexedCollection.prototype.slice.call(this, begin, end);
      }
      var newSize = this.size - resolvedBegin;
      var head = this._head;
      while (resolvedBegin--) {
        head = head.next;
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = void 0;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };
    Stack2.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeStack(this.size, this._head, ownerID, this.__hash);
    };
    Stack2.prototype.__iterate = function(fn, reverse) {
      if (reverse) {
        return this.reverse().__iterate(fn);
      }
      var iterations = 0;
      var node = this._head;
      while (node) {
        if (fn(node.value, iterations++, this) === false) {
          break;
        }
        node = node.next;
      }
      return iterations;
    };
    Stack2.prototype.__iterator = function(type2, reverse) {
      if (reverse) {
        return this.reverse().__iterator(type2);
      }
      var iterations = 0;
      var node = this._head;
      return new Iterator(function() {
        if (node) {
          var value = node.value;
          node = node.next;
          return iteratorValue(type2, iterations++, value);
        }
        return iteratorDone();
      });
    };
    function isStack(maybeStack) {
      return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
    }
    Stack2.isStack = isStack;
    var IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@";
    var StackPrototype = Stack2.prototype;
    StackPrototype[IS_STACK_SENTINEL] = true;
    StackPrototype.withMutations = MapPrototype.withMutations;
    StackPrototype.asMutable = MapPrototype.asMutable;
    StackPrototype.asImmutable = MapPrototype.asImmutable;
    StackPrototype.wasAltered = MapPrototype.wasAltered;
    function makeStack(size, head, ownerID, hash2) {
      var map2 = Object.create(StackPrototype);
      map2.size = size;
      map2._head = head;
      map2.__ownerID = ownerID;
      map2.__hash = hash2;
      map2.__altered = false;
      return map2;
    }
    var EMPTY_STACK;
    function emptyStack() {
      return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
    }
    function mixin(ctor, methods) {
      var keyCopier = function(key) {
        ctor.prototype[key] = methods[key];
      };
      Object.keys(methods).forEach(keyCopier);
      Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
      return ctor;
    }
    Iterable.Iterator = Iterator;
    mixin(Iterable, {
      // ### Conversion to other types
      toArray: function() {
        assertNotInfinite(this.size);
        var array = new Array(this.size || 0);
        this.valueSeq().__iterate(function(v2, i2) {
          array[i2] = v2;
        });
        return array;
      },
      toIndexedSeq: function() {
        return new ToIndexedSequence(this);
      },
      toJS: function() {
        return this.toSeq().map(
          function(value) {
            return value && typeof value.toJS === "function" ? value.toJS() : value;
          }
        ).__toJS();
      },
      toJSON: function() {
        return this.toSeq().map(
          function(value) {
            return value && typeof value.toJSON === "function" ? value.toJSON() : value;
          }
        ).__toJS();
      },
      toKeyedSeq: function() {
        return new ToKeyedSequence(this, true);
      },
      toMap: function() {
        return Map2(this.toKeyedSeq());
      },
      toObject: function() {
        assertNotInfinite(this.size);
        var object = {};
        this.__iterate(function(v2, k2) {
          object[k2] = v2;
        });
        return object;
      },
      toOrderedMap: function() {
        return OrderedMap(this.toKeyedSeq());
      },
      toOrderedSet: function() {
        return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
      },
      toSet: function() {
        return Set2(isKeyed(this) ? this.valueSeq() : this);
      },
      toSetSeq: function() {
        return new ToSetSequence(this);
      },
      toSeq: function() {
        return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
      },
      toStack: function() {
        return Stack2(isKeyed(this) ? this.valueSeq() : this);
      },
      toList: function() {
        return List(isKeyed(this) ? this.valueSeq() : this);
      },
      // ### Common JavaScript methods and properties
      toString: function() {
        return "[Iterable]";
      },
      __toString: function(head, tail) {
        if (this.size === 0) {
          return head + tail;
        }
        return head + " " + this.toSeq().map(this.__toStringMapper).join(", ") + " " + tail;
      },
      // ### ES6 Collection methods (ES6 Array and Map)
      concat: function() {
        var values = SLICE$0.call(arguments, 0);
        return reify(this, concatFactory(this, values));
      },
      includes: function(searchValue) {
        return this.some(function(value) {
          return is2(value, searchValue);
        });
      },
      entries: function() {
        return this.__iterator(ITERATE_ENTRIES);
      },
      every: function(predicate, context2) {
        assertNotInfinite(this.size);
        var returnValue = true;
        this.__iterate(function(v2, k2, c2) {
          if (!predicate.call(context2, v2, k2, c2)) {
            returnValue = false;
            return false;
          }
        });
        return returnValue;
      },
      filter: function(predicate, context2) {
        return reify(this, filterFactory(this, predicate, context2, true));
      },
      find: function(predicate, context2, notSetValue) {
        var entry = this.findEntry(predicate, context2);
        return entry ? entry[1] : notSetValue;
      },
      forEach: function(sideEffect, context2) {
        assertNotInfinite(this.size);
        return this.__iterate(context2 ? sideEffect.bind(context2) : sideEffect);
      },
      join: function(separator) {
        assertNotInfinite(this.size);
        separator = separator !== void 0 ? "" + separator : ",";
        var joined = "";
        var isFirst = true;
        this.__iterate(function(v2) {
          isFirst ? isFirst = false : joined += separator;
          joined += v2 !== null && v2 !== void 0 ? v2.toString() : "";
        });
        return joined;
      },
      keys: function() {
        return this.__iterator(ITERATE_KEYS);
      },
      map: function(mapper, context2) {
        return reify(this, mapFactory(this, mapper, context2));
      },
      reduce: function(reducer, initialReduction, context2) {
        assertNotInfinite(this.size);
        var reduction;
        var useFirst;
        if (arguments.length < 2) {
          useFirst = true;
        } else {
          reduction = initialReduction;
        }
        this.__iterate(function(v2, k2, c2) {
          if (useFirst) {
            useFirst = false;
            reduction = v2;
          } else {
            reduction = reducer.call(context2, reduction, v2, k2, c2);
          }
        });
        return reduction;
      },
      reduceRight: function(reducer, initialReduction, context2) {
        var reversed = this.toKeyedSeq().reverse();
        return reversed.reduce.apply(reversed, arguments);
      },
      reverse: function() {
        return reify(this, reverseFactory(this, true));
      },
      slice: function(begin, end) {
        return reify(this, sliceFactory(this, begin, end, true));
      },
      some: function(predicate, context2) {
        return !this.every(not(predicate), context2);
      },
      sort: function(comparator) {
        return reify(this, sortFactory(this, comparator));
      },
      values: function() {
        return this.__iterator(ITERATE_VALUES);
      },
      // ### More sequential methods
      butLast: function() {
        return this.slice(0, -1);
      },
      isEmpty: function() {
        return this.size !== void 0 ? this.size === 0 : !this.some(function() {
          return true;
        });
      },
      count: function(predicate, context2) {
        return ensureSize(
          predicate ? this.toSeq().filter(predicate, context2) : this
        );
      },
      countBy: function(grouper, context2) {
        return countByFactory(this, grouper, context2);
      },
      equals: function(other) {
        return deepEqual3(this, other);
      },
      entrySeq: function() {
        var iterable = this;
        if (iterable._cache) {
          return new ArraySeq(iterable._cache);
        }
        var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
        entriesSequence.fromEntrySeq = function() {
          return iterable.toSeq();
        };
        return entriesSequence;
      },
      filterNot: function(predicate, context2) {
        return this.filter(not(predicate), context2);
      },
      findEntry: function(predicate, context2, notSetValue) {
        var found = notSetValue;
        this.__iterate(function(v2, k2, c2) {
          if (predicate.call(context2, v2, k2, c2)) {
            found = [k2, v2];
            return false;
          }
        });
        return found;
      },
      findKey: function(predicate, context2) {
        var entry = this.findEntry(predicate, context2);
        return entry && entry[0];
      },
      findLast: function(predicate, context2, notSetValue) {
        return this.toKeyedSeq().reverse().find(predicate, context2, notSetValue);
      },
      findLastEntry: function(predicate, context2, notSetValue) {
        return this.toKeyedSeq().reverse().findEntry(predicate, context2, notSetValue);
      },
      findLastKey: function(predicate, context2) {
        return this.toKeyedSeq().reverse().findKey(predicate, context2);
      },
      first: function() {
        return this.find(returnTrue);
      },
      flatMap: function(mapper, context2) {
        return reify(this, flatMapFactory(this, mapper, context2));
      },
      flatten: function(depth) {
        return reify(this, flattenFactory(this, depth, true));
      },
      fromEntrySeq: function() {
        return new FromEntriesSequence(this);
      },
      get: function(searchKey, notSetValue) {
        return this.find(function(_, key) {
          return is2(key, searchKey);
        }, void 0, notSetValue);
      },
      getIn: function(searchKeyPath, notSetValue) {
        var nested = this;
        var iter = forceIterator(searchKeyPath);
        var step;
        while (!(step = iter.next()).done) {
          var key = step.value;
          nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
          if (nested === NOT_SET) {
            return notSetValue;
          }
        }
        return nested;
      },
      groupBy: function(grouper, context2) {
        return groupByFactory(this, grouper, context2);
      },
      has: function(searchKey) {
        return this.get(searchKey, NOT_SET) !== NOT_SET;
      },
      hasIn: function(searchKeyPath) {
        return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
      },
      isSubset: function(iter) {
        iter = typeof iter.includes === "function" ? iter : Iterable(iter);
        return this.every(function(value) {
          return iter.includes(value);
        });
      },
      isSuperset: function(iter) {
        iter = typeof iter.isSubset === "function" ? iter : Iterable(iter);
        return iter.isSubset(this);
      },
      keyOf: function(searchValue) {
        return this.findKey(function(value) {
          return is2(value, searchValue);
        });
      },
      keySeq: function() {
        return this.toSeq().map(keyMapper).toIndexedSeq();
      },
      last: function() {
        return this.toSeq().reverse().first();
      },
      lastKeyOf: function(searchValue) {
        return this.toKeyedSeq().reverse().keyOf(searchValue);
      },
      max: function(comparator) {
        return maxFactory(this, comparator);
      },
      maxBy: function(mapper, comparator) {
        return maxFactory(this, comparator, mapper);
      },
      min: function(comparator) {
        return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
      },
      minBy: function(mapper, comparator) {
        return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
      },
      rest: function() {
        return this.slice(1);
      },
      skip: function(amount) {
        return this.slice(Math.max(0, amount));
      },
      skipLast: function(amount) {
        return reify(this, this.toSeq().reverse().skip(amount).reverse());
      },
      skipWhile: function(predicate, context2) {
        return reify(this, skipWhileFactory(this, predicate, context2, true));
      },
      skipUntil: function(predicate, context2) {
        return this.skipWhile(not(predicate), context2);
      },
      sortBy: function(mapper, comparator) {
        return reify(this, sortFactory(this, comparator, mapper));
      },
      take: function(amount) {
        return this.slice(0, Math.max(0, amount));
      },
      takeLast: function(amount) {
        return reify(this, this.toSeq().reverse().take(amount).reverse());
      },
      takeWhile: function(predicate, context2) {
        return reify(this, takeWhileFactory(this, predicate, context2));
      },
      takeUntil: function(predicate, context2) {
        return this.takeWhile(not(predicate), context2);
      },
      valueSeq: function() {
        return this.toIndexedSeq();
      },
      // ### Hashable Object
      hashCode: function() {
        return this.__hash || (this.__hash = hashIterable(this));
      }
      // ### Internal
      // abstract __iterate(fn, reverse)
      // abstract __iterator(type, reverse)
    });
    var IterablePrototype = Iterable.prototype;
    IterablePrototype[IS_ITERABLE_SENTINEL] = true;
    IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
    IterablePrototype.__toJS = IterablePrototype.toArray;
    IterablePrototype.__toStringMapper = quoteString;
    IterablePrototype.inspect = IterablePrototype.toSource = function() {
      return this.toString();
    };
    IterablePrototype.chain = IterablePrototype.flatMap;
    IterablePrototype.contains = IterablePrototype.includes;
    mixin(KeyedIterable, {
      // ### More sequential methods
      flip: function() {
        return reify(this, flipFactory(this));
      },
      mapEntries: function(mapper, context2) {
        var this$0 = this;
        var iterations = 0;
        return reify(
          this,
          this.toSeq().map(
            function(v2, k2) {
              return mapper.call(context2, [k2, v2], iterations++, this$0);
            }
          ).fromEntrySeq()
        );
      },
      mapKeys: function(mapper, context2) {
        var this$0 = this;
        return reify(
          this,
          this.toSeq().flip().map(
            function(k2, v2) {
              return mapper.call(context2, k2, v2, this$0);
            }
          ).flip()
        );
      }
    });
    var KeyedIterablePrototype = KeyedIterable.prototype;
    KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
    KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
    KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
    KeyedIterablePrototype.__toStringMapper = function(v2, k2) {
      return JSON.stringify(k2) + ": " + quoteString(v2);
    };
    mixin(IndexedIterable, {
      // ### Conversion to other types
      toKeyedSeq: function() {
        return new ToKeyedSequence(this, false);
      },
      // ### ES6 Collection methods (ES6 Array and Map)
      filter: function(predicate, context2) {
        return reify(this, filterFactory(this, predicate, context2, false));
      },
      findIndex: function(predicate, context2) {
        var entry = this.findEntry(predicate, context2);
        return entry ? entry[0] : -1;
      },
      indexOf: function(searchValue) {
        var key = this.keyOf(searchValue);
        return key === void 0 ? -1 : key;
      },
      lastIndexOf: function(searchValue) {
        var key = this.lastKeyOf(searchValue);
        return key === void 0 ? -1 : key;
      },
      reverse: function() {
        return reify(this, reverseFactory(this, false));
      },
      slice: function(begin, end) {
        return reify(this, sliceFactory(this, begin, end, false));
      },
      splice: function(index2, removeNum) {
        var numArgs = arguments.length;
        removeNum = Math.max(removeNum | 0, 0);
        if (numArgs === 0 || numArgs === 2 && !removeNum) {
          return this;
        }
        index2 = resolveBegin(index2, index2 < 0 ? this.count() : this.size);
        var spliced = this.slice(0, index2);
        return reify(
          this,
          numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index2 + removeNum))
        );
      },
      // ### More collection methods
      findLastIndex: function(predicate, context2) {
        var entry = this.findLastEntry(predicate, context2);
        return entry ? entry[0] : -1;
      },
      first: function() {
        return this.get(0);
      },
      flatten: function(depth) {
        return reify(this, flattenFactory(this, depth, false));
      },
      get: function(index2, notSetValue) {
        index2 = wrapIndex(this, index2);
        return index2 < 0 || (this.size === Infinity || this.size !== void 0 && index2 > this.size) ? notSetValue : this.find(function(_, key) {
          return key === index2;
        }, void 0, notSetValue);
      },
      has: function(index2) {
        index2 = wrapIndex(this, index2);
        return index2 >= 0 && (this.size !== void 0 ? this.size === Infinity || index2 < this.size : this.indexOf(index2) !== -1);
      },
      interpose: function(separator) {
        return reify(this, interposeFactory(this, separator));
      },
      interleave: function() {
        var iterables = [this].concat(arrCopy(arguments));
        var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
        var interleaved = zipped.flatten(true);
        if (zipped.size) {
          interleaved.size = zipped.size * iterables.length;
        }
        return reify(this, interleaved);
      },
      keySeq: function() {
        return Range(0, this.size);
      },
      last: function() {
        return this.get(-1);
      },
      skipWhile: function(predicate, context2) {
        return reify(this, skipWhileFactory(this, predicate, context2, false));
      },
      zip: function() {
        var iterables = [this].concat(arrCopy(arguments));
        return reify(this, zipWithFactory(this, defaultZipper, iterables));
      },
      zipWith: function(zipper) {
        var iterables = arrCopy(arguments);
        iterables[0] = this;
        return reify(this, zipWithFactory(this, zipper, iterables));
      }
    });
    IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
    IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;
    mixin(SetIterable, {
      // ### ES6 Collection methods (ES6 Array and Map)
      get: function(value, notSetValue) {
        return this.has(value) ? value : notSetValue;
      },
      includes: function(value) {
        return this.has(value);
      },
      // ### More sequential methods
      keySeq: function() {
        return this.valueSeq();
      }
    });
    SetIterable.prototype.has = IterablePrototype.includes;
    SetIterable.prototype.contains = SetIterable.prototype.includes;
    mixin(KeyedSeq, KeyedIterable.prototype);
    mixin(IndexedSeq, IndexedIterable.prototype);
    mixin(SetSeq, SetIterable.prototype);
    mixin(KeyedCollection, KeyedIterable.prototype);
    mixin(IndexedCollection, IndexedIterable.prototype);
    mixin(SetCollection, SetIterable.prototype);
    function keyMapper(v2, k2) {
      return k2;
    }
    function entryMapper(v2, k2) {
      return [k2, v2];
    }
    function not(predicate) {
      return function() {
        return !predicate.apply(this, arguments);
      };
    }
    function neg(predicate) {
      return function() {
        return -predicate.apply(this, arguments);
      };
    }
    function quoteString(value) {
      return typeof value === "string" ? JSON.stringify(value) : String(value);
    }
    function defaultZipper() {
      return arrCopy(arguments);
    }
    function defaultNegComparator(a2, b2) {
      return a2 < b2 ? 1 : a2 > b2 ? -1 : 0;
    }
    function hashIterable(iterable) {
      if (iterable.size === Infinity) {
        return 0;
      }
      var ordered = isOrdered(iterable);
      var keyed = isKeyed(iterable);
      var h2 = ordered ? 1 : 0;
      var size = iterable.__iterate(
        keyed ? ordered ? function(v2, k2) {
          h2 = 31 * h2 + hashMerge(hash(v2), hash(k2)) | 0;
        } : function(v2, k2) {
          h2 = h2 + hashMerge(hash(v2), hash(k2)) | 0;
        } : ordered ? function(v2) {
          h2 = 31 * h2 + hash(v2) | 0;
        } : function(v2) {
          h2 = h2 + hash(v2) | 0;
        }
      );
      return murmurHashOfSize(size, h2);
    }
    function murmurHashOfSize(size, h2) {
      h2 = imul(h2, 3432918353);
      h2 = imul(h2 << 15 | h2 >>> -15, 461845907);
      h2 = imul(h2 << 13 | h2 >>> -13, 5);
      h2 = (h2 + 3864292196 | 0) ^ size;
      h2 = imul(h2 ^ h2 >>> 16, 2246822507);
      h2 = imul(h2 ^ h2 >>> 13, 3266489909);
      h2 = smi(h2 ^ h2 >>> 16);
      return h2;
    }
    function hashMerge(a2, b2) {
      return a2 ^ b2 + 2654435769 + (a2 << 6) + (a2 >> 2) | 0;
    }
    var Immutable2 = {
      Iterable,
      Seq,
      Collection,
      Map: Map2,
      OrderedMap,
      List,
      Stack: Stack2,
      Set: Set2,
      OrderedSet,
      Record,
      Range,
      Repeat,
      is: is2,
      fromJS
    };
    return Immutable2;
  });
})(immutable);
var immutableExports = immutable.exports;
const Immutable = /* @__PURE__ */ getDefaultExportFromCjs(immutableExports);
var defaultValue$1 = function defaultValue(value, _default2) {
  return typeof value === "undefined" ? _default2 : value;
};
var deepEqual = function deepEqual2(v1, v2) {
  if (v1 === v2) {
    return true;
  } else if (immutableExports.Map.isMap(v1)) {
    return v1.equals(v2);
  } else {
    return JSON.stringify(v1) == JSON.stringify(v2);
  }
};
var shallowEqual$2 = function shallowEqual(a2, b2) {
  var deep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (a2 === b2) {
    return true;
  } else if (Array.isArray(a2))
    return shallowEqualArrays$1(a2, b2, deep);
  else if (immutableExports.Map.isMap(a2))
    return a2.equals(b2);
  else if (_typeof$2(a2) == "object")
    return shallowEqualObjects$1(a2, b2, deep);
  else
    return a2 === b2;
};
function shallowEqualArrays$1(arrA, arrB) {
  var deep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (arrA === arrB) {
    return true;
  }
  if (!arrA || !arrB) {
    return false;
  }
  var len = arrA.length;
  if (arrB.length !== len) {
    return false;
  }
  for (var i2 = 0; i2 < len; i2++) {
    var isEqual2 = deep ? shallowEqual$2(arrA[i2], arrB[i2], deep) : arrA[i2] === arrB[i2];
    if (!isEqual2) {
      return false;
    }
  }
  return true;
}
function shallowEqualObjects$1(objA, objB) {
  var deep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (objA === objB) {
    return true;
  }
  if (!objA || !objB) {
    return false;
  }
  var aKeys = Object.keys(objA);
  var bKeys = Object.keys(objB);
  var len = aKeys.length;
  if (bKeys.length !== len) {
    return false;
  }
  for (var i2 = 0; i2 < len; i2++) {
    var key = aKeys[i2];
    var isEqual2 = deep ? shallowEqual$2(objA[key], objB[key], deep) : objA[key] === objB[key];
    if (!isEqual2) {
      return false;
    }
  }
  return true;
}
var isImmutable = function isImmutable2(v2) {
  return _typeof$2(v2) === "object" && v2 !== null && typeof v2.toJS === "function";
};
function toImmutableList(v2) {
  return isImmutable(v2) ? v2 : new Immutable.List(v2);
}
function applyToJS(v2) {
  return isImmutable(v2) ? v2.toJS() : v2;
}
var escapeRegExp = function escapeRegExp2(string) {
  return string.replace(/[.*+?^${}()|[\]\\/]/g, "\\$&");
};
var isJsonLogic = function isJsonLogic2(logic) {
  return _typeof$2(logic) === "object" && logic !== null && !Array.isArray(logic) && Object.keys(logic).length === 1;
};
function sleep(delay) {
  return new Promise(function(resolve) {
    setTimeout(resolve, delay);
  });
}
function mergeArraysSmart(arr1, arr2) {
  if (!arr1)
    arr1 = [];
  if (!arr2)
    arr2 = [];
  return arr2.map(function(op) {
    return [op, arr1.indexOf(op)];
  }).map(function(_ref, i2, orig) {
    var _ref2 = _slicedToArray$1(_ref, 2), op = _ref2[0], ind = _ref2[1];
    if (ind == -1) {
      var next = orig.slice(i2 + 1);
      var prev = orig.slice(0, i2);
      var after = prev.reverse().find(function(_ref3) {
        var _ref4 = _slicedToArray$1(_ref3, 2);
        _ref4[0];
        var ci = _ref4[1];
        return ci != -1;
      });
      var before = next.find(function(_ref5) {
        var _ref6 = _slicedToArray$1(_ref5, 2);
        _ref6[0];
        var ci = _ref6[1];
        return ci != -1;
      });
      if (before)
        return [op, "before", before[0]];
      else if (after)
        return [op, "after", after[0]];
      else
        return [op, "append", null];
    } else {
      return null;
    }
  }).filter(function(x) {
    return x !== null;
  }).reduce(function(acc, _ref7) {
    var _ref8 = _slicedToArray$1(_ref7, 3), newOp = _ref8[0], rel = _ref8[1], relOp = _ref8[2];
    var ind = acc.indexOf(relOp);
    if (acc.indexOf(newOp) == -1) {
      if (ind > -1) {
        acc.splice(ind + (rel == "after" ? 1 : 0), 0, newOp);
      } else {
        acc.splice(rel == "append" ? Infinity : 0, 0, newOp);
      }
    }
    return acc;
  }, arr1.slice());
}
var isDev$1 = function isDev() {
  return typeof process !== "undefined" && {} && false;
};
var getLogger$1 = function getLogger() {
  var devMode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
  var verbose = devMode != void 0 ? devMode : isDev$1();
  return verbose ? console : {
    error: function error2() {
    },
    log: function log() {
    },
    warn: function warn2() {
    },
    debug: function debug() {
    },
    info: function info() {
    }
  };
};
var getFirstDefined = function getFirstDefined2() {
  var arr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var ret;
  for (var i2 = 0; i2 < arr.length; i2++) {
    var v2 = arr[i2];
    if (v2 !== void 0) {
      ret = v2;
      break;
    }
  }
  return ret;
};
var logger$1 = getLogger$1();
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$8(arr);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$8(arr) || _nonIterableSpread();
}
var baseAssignValue$1 = _baseAssignValue, eq$1 = eq_1;
function assignMergeValue$2(object, key, value) {
  if (value !== void 0 && !eq$1(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue$1(object, key, value);
  }
}
var _assignMergeValue = assignMergeValue$2;
var isArrayLike$1 = isArrayLike_1, isObjectLike = isObjectLike_1;
function isArrayLikeObject$1(value) {
  return isObjectLike(value) && isArrayLike$1(value);
}
var isArrayLikeObject_1 = isArrayLikeObject$1;
function safeGet$2(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var _safeGet = safeGet$2;
var copyObject$1 = _copyObject, keysIn$1 = keysIn_1;
function toPlainObject$1(value) {
  return copyObject$1(value, keysIn$1(value));
}
var toPlainObject_1 = toPlainObject$1;
var assignMergeValue$1 = _assignMergeValue, cloneBuffer = _cloneBufferExports, cloneTypedArray = _cloneTypedArray, copyArray = _copyArray, initCloneObject = _initCloneObject, isArguments$1 = isArguments_1, isArray$1 = isArray_1, isArrayLikeObject = isArrayLikeObject_1, isBuffer = isBufferExports, isFunction = isFunction_1, isObject$8 = isObject_1, isPlainObject$1 = isPlainObject_1, isTypedArray = isTypedArray_1, safeGet$1 = _safeGet, toPlainObject = toPlainObject_1;
function baseMergeDeep$1(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet$1(object, key), srcValue = safeGet$1(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue$1(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray$1(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray$1(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject$1(srcValue) || isArguments$1(srcValue)) {
      newValue = objValue;
      if (isArguments$1(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject$8(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue$1(object, key, newValue);
}
var _baseMergeDeep = baseMergeDeep$1;
var Stack = _Stack, assignMergeValue = _assignMergeValue, baseFor = _baseFor, baseMergeDeep = _baseMergeDeep, isObject$7 = isObject_1, keysIn = keysIn_1, safeGet = _safeGet;
function baseMerge$2(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack());
    if (isObject$7(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge$2, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}
var _baseMerge = baseMerge$2;
function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var _apply = apply$1;
var apply = _apply;
var nativeMax$2 = Math.max;
function overRest$2(func, start2, transform2) {
  start2 = nativeMax$2(start2 === void 0 ? func.length - 1 : start2, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax$2(args.length - start2, 0), array = Array(length);
    while (++index2 < length) {
      array[index2] = args[start2 + index2];
    }
    index2 = -1;
    var otherArgs = Array(start2 + 1);
    while (++index2 < start2) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start2] = transform2(array);
    return apply(func, this, otherArgs);
  };
}
var _overRest = overRest$2;
function constant$1(value) {
  return function() {
    return value;
  };
}
var constant_1 = constant$1;
var constant = constant_1, defineProperty = _defineProperty$2, identity$1 = identity_1;
var baseSetToString$1 = !defineProperty ? identity$1 : function(func, string) {
  return defineProperty(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var _baseSetToString = baseSetToString$1;
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut$1(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$1;
var baseSetToString = _baseSetToString, shortOut = _shortOut;
var setToString$2 = shortOut(baseSetToString);
var _setToString = setToString$2;
var identity = identity_1, overRest$1 = _overRest, setToString$1 = _setToString;
function baseRest$1(func, start2) {
  return setToString$1(overRest$1(func, start2, identity), func + "");
}
var _baseRest = baseRest$1;
var eq = eq_1, isArrayLike = isArrayLike_1, isIndex$1 = _isIndex, isObject$6 = isObject_1;
function isIterateeCall$2(value, index2, object) {
  if (!isObject$6(object)) {
    return false;
  }
  var type2 = typeof index2;
  if (type2 == "number" ? isArrayLike(object) && isIndex$1(index2, object.length) : type2 == "string" && index2 in object) {
    return eq(object[index2], value);
  }
  return false;
}
var _isIterateeCall = isIterateeCall$2;
var baseRest = _baseRest, isIterateeCall$1 = _isIterateeCall;
function createAssigner$2(assigner) {
  return baseRest(function(object, sources) {
    var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall$1(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index2 < length) {
      var source = sources[index2];
      if (source) {
        assigner(object, source, index2, customizer);
      }
    }
    return object;
  });
}
var _createAssigner = createAssigner$2;
var baseMerge$1 = _baseMerge, createAssigner$1 = _createAssigner;
var merge$1 = createAssigner$1(function(object, source, srcIndex) {
  baseMerge$1(object, source, srcIndex);
});
var merge_1 = merge$1;
const merge$2 = /* @__PURE__ */ getDefaultExportFromCjs(merge_1);
var query_builder_seed = 0;
const uuid$1 = function() {
  var timePart = ((/* @__PURE__ */ new Date()).getTime().toString(16) + "FF").substr(0, 11);
  var s2 = "ssssssss-xxxx-4xxx-yxxx-x".replace(/[xys]/g, function(c2) {
    var r2 = c2 === "s" ? Math.floor(Math.random() * 16) : query_builder_seed++ & 15;
    var v2 = c2 === "x" ? r2 : r2 & 3 | 8;
    return v2.toString(16);
  });
  return s2 + timePart;
};
var baseMerge = _baseMerge, createAssigner = _createAssigner;
var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
  baseMerge(object, source, srcIndex, customizer);
});
var mergeWith_1 = mergeWith;
const mergeWith$1 = /* @__PURE__ */ getDefaultExportFromCjs(mergeWith_1);
var settings$4 = {
  formatField: function formatField(field, parts, label2, fieldDefinition, config2, isForDisplay) {
    if (isForDisplay)
      return label2;
    else
      return field;
  },
  valueSourcesInfo: {
    value: {}
  },
  fieldSeparator: ".",
  fieldSeparatorDisplay: ".",
  canReorder: true,
  canRegroup: true,
  canDeleteLocked: false,
  canLeaveEmptyGroup: true,
  shouldCreateEmptyGroup: false,
  canShortMongoQuery: true,
  removeEmptyGroupsOnLoad: true,
  removeIncompleteRulesOnLoad: true,
  removeInvalidMultiSelectValuesOnLoad: true,
  setOpOnChangeField: ["keep", "default"],
  // 'default' (default if present), 'keep' (keep prev from last field), 'first', 'none'
  groupOperators: ["some", "all", "none"],
  defaultGroupConjunction: "AND",
  // localization
  locale: {
    moment: "en"
  },
  valueLabel: "Value",
  valuePlaceholder: "Value",
  fieldLabel: "Field",
  operatorLabel: "Operator",
  funcLabel: "Function",
  fieldPlaceholder: "Select field",
  funcPlaceholder: "Select function",
  operatorPlaceholder: "Select operator",
  lockLabel: "Lock",
  lockedLabel: "Locked",
  deleteLabel: null,
  addGroupLabel: "Add group",
  addCaseLabel: "Add condition",
  addDefaultCaseLabel: "Add default condition",
  defaultCaseLabel: "Default:",
  addRuleLabel: "Add rule",
  addSubRuleLabel: "Add sub rule",
  delGroupLabel: "",
  notLabel: "Not",
  valueSourcesPopupTitle: "Select value source",
  removeRuleConfirmOptions: null,
  removeGroupConfirmOptions: null
};
function _createForOfIteratorHelper$5(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i2 = 0;
      var F2 = function F3() {
      };
      return { s: F2, n: function n2() {
        if (i2 >= o.length)
          return { done: true };
        return { done: false, value: o[i2++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F2 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it = it.call(o);
  }, n: function n2() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f2() {
    try {
      if (!normalCompletion && it["return"] != null)
        it["return"]();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray$5(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$5(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$5(o, minLen);
}
function _arrayLikeToArray$5(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
var isObject$5 = function isObject(v2) {
  return _typeof$2(v2) == "object" && v2 !== null;
};
var listValue = function listValue2(v2, title2) {
  return isObject$5(v2) ? v2 : {
    value: v2,
    title: title2 !== void 0 ? title2 : v2
  };
};
var listValuesToArray$1 = function listValuesToArray(listValuesObj) {
  if (!isObject$5(listValuesObj))
    return listValuesObj;
  if (Array.isArray(listValuesObj))
    return listValuesObj.map(function(v3) {
      return listValue(v3);
    });
  var listValuesArr = [];
  for (var v2 in listValuesObj) {
    var title2 = listValuesObj[v2];
    listValuesArr.push(listValue(v2, title2));
  }
  return listValuesArr;
};
var getItemInListValues = function getItemInListValues2(listValues2, value) {
  if (Array.isArray(listValues2)) {
    var values = listValues2.map(function(v2) {
      return listValue(v2);
    });
    return values.find(function(v2) {
      return v2.value === value;
    }) || values.find(function(v2) {
      return "".concat(v2.value) === value;
    });
  } else {
    return listValues2[value] !== void 0 ? listValue(value, listValues2[value]) : void 0;
  }
};
var getTitleInListValues$1 = function getTitleInListValues(listValues2, value) {
  if (listValues2 == void 0)
    return value;
  var it = getItemInListValues(listValues2, value);
  return it !== void 0 ? it.title : value;
};
var getValueInListValues = function getValueInListValues2(listValues2, value) {
  if (listValues2 == void 0)
    return value;
  var it = getItemInListValues(listValues2, value);
  return it !== void 0 ? it.value : value;
};
var mapListValues$5 = function mapListValues(listValues2, mapFn) {
  var ret = [];
  if (Array.isArray(listValues2)) {
    var _iterator = _createForOfIteratorHelper$5(listValues2), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var v2 = _step.value;
        var lv = mapFn(listValue(v2));
        if (lv != null)
          ret.push(lv);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    for (var value in listValues2) {
      var _lv = mapFn(listValue(value, listValues2[value]));
      if (_lv != null)
        ret.push(_lv);
    }
  }
  return ret;
};
const listValues = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getItemInListValues,
  getTitleInListValues: getTitleInListValues$1,
  getValueInListValues,
  listValuesToArray: listValuesToArray$1,
  mapListValues: mapListValues$5
}, Symbol.toStringTag, { value: "Module" }));
function ownKeys$v(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$v(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$v(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$v(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var defaultField = function defaultField2(config2) {
  var canGetFirst = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var parentRuleGroupPath = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  return typeof config2.settings.defaultField === "function" ? config2.settings.defaultField(parentRuleGroupPath) : config2.settings.defaultField || (canGetFirst ? getFirstField(config2, parentRuleGroupPath) : null);
};
var defaultOperator = function defaultOperator2(config2, field) {
  var canGetFirst = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var fieldConfig = getFieldConfig$8(config2, field);
  var fieldOperators = fieldConfig && fieldConfig.operators || [];
  var fieldDefaultOperator = fieldConfig && fieldConfig.defaultOperator;
  if (!fieldOperators.includes(fieldDefaultOperator))
    fieldDefaultOperator = null;
  if (!fieldDefaultOperator && canGetFirst)
    fieldDefaultOperator = getFirstOperator(config2, field);
  var op = typeof config2.settings.defaultOperator === "function" ? config2.settings.defaultOperator(field, fieldConfig) : fieldDefaultOperator;
  return op;
};
var defaultOperatorOptions = function defaultOperatorOptions2(config2, operator, field) {
  var operatorConfig = operator ? getOperatorConfig$4(config2, operator, field) : null;
  if (!operatorConfig)
    return null;
  return operatorConfig.options ? new Immutable.Map(operatorConfig.options && operatorConfig.options.defaults || {}) : null;
};
var defaultRuleProperties = function defaultRuleProperties2(config2) {
  var parentRuleGroupPath = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  var item = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  var field = null, operator = null;
  var _config$settings = config2.settings, setDefaultFieldAndOp = _config$settings.setDefaultFieldAndOp, showErrorMessage = _config$settings.showErrorMessage;
  if (item) {
    var _item$properties, _item$properties2;
    field = item === null || item === void 0 ? void 0 : (_item$properties = item.properties) === null || _item$properties === void 0 ? void 0 : _item$properties.field;
    operator = item === null || item === void 0 ? void 0 : (_item$properties2 = item.properties) === null || _item$properties2 === void 0 ? void 0 : _item$properties2.operator;
  } else if (setDefaultFieldAndOp) {
    field = defaultField(config2, true, parentRuleGroupPath);
    operator = defaultOperator(config2, field);
  }
  var current = new Immutable.Map({
    field,
    operator,
    value: new Immutable.List(),
    valueSrc: new Immutable.List(),
    //used for complex operators like proximity
    operatorOptions: defaultOperatorOptions(config2, operator, field)
  });
  if (showErrorMessage) {
    current = current.set("valueError", new Immutable.List());
  }
  if (field && operator) {
    var _getNewValueForFieldO = getNewValueForFieldOp(config2, config2, current, field, operator, "operator", false), newValue = _getNewValueForFieldO.newValue, newValueSrc = _getNewValueForFieldO.newValueSrc, newValueType = _getNewValueForFieldO.newValueType, newValueError = _getNewValueForFieldO.newValueError;
    current = current.set("value", newValue).set("valueSrc", newValueSrc).set("valueType", newValueType);
    if (showErrorMessage) {
      current = current.set("valueError", newValueError);
    }
  }
  return current;
};
var defaultGroupConjunction$1 = function defaultGroupConjunction(config2) {
  var fieldConfig = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  fieldConfig = getFieldConfig$8(config2, fieldConfig);
  var conjs = fieldConfig && fieldConfig.conjunctions || Object.keys(config2.conjunctions);
  if (conjs.length == 1)
    return conjs[0];
  return config2.settings.defaultGroupConjunction || config2.settings.defaultConjunction || conjs[0];
};
var defaultConjunction = function defaultConjunction2(config2) {
  return config2.settings.defaultConjunction || Object.keys(config2.conjunctions)[0];
};
var defaultGroupProperties = function defaultGroupProperties2(config2) {
  var fieldConfig = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  return new Immutable.Map({
    conjunction: defaultGroupConjunction$1(config2, fieldConfig),
    not: false
  });
};
var defaultItemProperties = function defaultItemProperties2(config2, item) {
  var _item$properties3;
  return item && item.type == "group" ? defaultGroupProperties(config2, item === null || item === void 0 ? void 0 : (_item$properties3 = item.properties) === null || _item$properties3 === void 0 ? void 0 : _item$properties3.field) : defaultRuleProperties(config2, null, item);
};
var defaultRule = function defaultRule2(id, config2) {
  return _defineProperty$4({}, id, new Immutable.Map({
    type: "rule",
    id,
    properties: defaultRuleProperties(config2)
  }));
};
var defaultRoot$1 = function defaultRoot(config2) {
  return new Immutable.Map({
    type: "group",
    id: uuid$1(),
    children1: new Immutable.OrderedMap(_objectSpread$v({}, defaultRule(uuid$1(), config2))),
    properties: defaultGroupProperties(config2)
  });
};
var createListFromArray$2 = function createListFromArray(ids) {
  return new Immutable.List(ids);
};
var emptyProperies$1 = function emptyProperies() {
  return new Immutable.Map();
};
const defaultUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createListFromArray: createListFromArray$2,
  defaultConjunction,
  defaultField,
  defaultGroupConjunction: defaultGroupConjunction$1,
  defaultGroupProperties,
  defaultItemProperties,
  defaultOperator,
  defaultOperatorOptions,
  defaultRoot: defaultRoot$1,
  defaultRule,
  defaultRuleProperties,
  emptyProperies: emptyProperies$1
}, Symbol.toStringTag, { value: "Module" }));
var expandTreePath = function expandTreePath2(path) {
  for (var _len = arguments.length, suffix = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    suffix[_key - 1] = arguments[_key];
  }
  return path.interpose("children1").withMutations(function(list2) {
    list2.skip(1);
    list2.push.apply(list2, suffix);
    return list2;
  });
};
var expandTreeSubpath = function expandTreeSubpath2(path) {
  for (var _len2 = arguments.length, suffix = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    suffix[_key2 - 1] = arguments[_key2];
  }
  return path.interpose("children1").withMutations(function(list2) {
    list2.push.apply(list2, suffix);
    return list2;
  });
};
var getItemByPath = function getItemByPath2(tree2, path) {
  var children = new Immutable.OrderedMap(_defineProperty$4({}, tree2.get("id"), tree2));
  var res = tree2;
  path.forEach(function(id) {
    res = children.get(id);
    children = res.get("children1");
  });
  return res;
};
var removePathsInTree = function removePathsInTree2(tree2) {
  var newTree = tree2;
  function _processNode(item, path) {
    var itemPath = path.push(item.get("id"));
    if (item.get("path")) {
      newTree = newTree.removeIn(expandTreePath(itemPath, "path"));
    }
    var children = item.get("children1");
    if (children) {
      children.map(function(child, _childId) {
        _processNode(child, itemPath);
      });
    }
  }
  _processNode(tree2, new Immutable.List());
  return newTree;
};
var removeIsLockedInTree = function removeIsLockedInTree2(tree2) {
  var newTree = tree2;
  function _processNode(item, path) {
    var isParentLocked = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var itemPath = path.push(item.get("id"));
    var isLocked = item.getIn(["properties", "isLocked"]);
    if (isParentLocked && isLocked) {
      newTree = newTree.deleteIn(expandTreePath(itemPath, "properties", "isLocked"));
    }
    var children = item.get("children1");
    if (children) {
      children.map(function(child, _childId) {
        _processNode(child, itemPath, isLocked || isParentLocked);
      });
    }
  }
  _processNode(tree2, new Immutable.List());
  return newTree;
};
var fixPathsInTree = function fixPathsInTree2(tree2) {
  var newTree = tree2;
  function _processNode(item, path, lev, nodeId) {
    if (!item)
      return;
    var currPath = item.get("path");
    var currId = item.get("id");
    var itemId = currId || nodeId;
    var itemPath = path.push(itemId);
    if (!currPath || !currPath.equals(itemPath)) {
      newTree = newTree.setIn(expandTreePath(itemPath, "path"), itemPath);
    }
    if (!currId) {
      newTree = newTree.setIn(expandTreePath(itemPath, "id"), itemId);
    }
    var children = item.get("children1");
    if (children) {
      if (children.constructor.name == "Map") {
        newTree = newTree.setIn(expandTreePath(itemPath, "children1"), new Immutable.OrderedMap(children));
      }
      children.map(function(child, childId) {
        _processNode(child, itemPath, lev + 1, childId);
      });
    }
  }
  _processNode(tree2, new Immutable.List(), 0);
  return newTree;
};
var fixEmptyGroupsInTree = function fixEmptyGroupsInTree2(tree2) {
  var newTree = tree2;
  function _processNode(item, path, lev, nodeId) {
    if (!item)
      return false;
    var itemId = item.get("id") || nodeId;
    var itemPath = path.push(itemId);
    var children = item.get("children1");
    if (children) {
      var allChildrenGone = children.map(function(child, childId) {
        return _processNode(child, itemPath, lev + 1, childId);
      }).reduce(function(curr, v2) {
        return curr && v2;
      }, true);
      if ((children.size == 0 || allChildrenGone) && lev > 0) {
        newTree = newTree.deleteIn(expandTreePath(itemPath));
        return true;
      }
    }
    return false;
  }
  _processNode(tree2, new Immutable.List(), 0);
  return newTree;
};
var getFlatTree$1 = function getFlatTree(tree2) {
  var flat = [];
  var items = {};
  var realHeight = 0;
  function _flatizeTree(item2, path, insideCollapsed, insideLocked, insideRuleGroup, lev, info, parentType, caseId) {
    var type2 = item2.get("type");
    var collapsed = item2.get("collapsed");
    var id = item2.get("id");
    var children = item2.get("children1");
    var isLocked = item2.getIn(["properties", "isLocked"]);
    var childrenIds = children ? children.map(function(_child, childId) {
      return childId;
    }) : null;
    var isRuleGroup = type2 == "rule_group";
    var isLeaf = !insideRuleGroup && (!children || isRuleGroup);
    var itemsBefore = flat.length;
    var top = realHeight;
    flat.push(id);
    if (!insideCollapsed)
      realHeight += 1;
    info.height = (info.height || 0) + 1;
    items[id] = {
      type: type2,
      parent: path.length ? path[path.length - 1] : null,
      parentType,
      caseId: type2 == "case_group" ? id : caseId,
      isDefaultCase: type2 == "case_group" && !children,
      path: path.concat(id),
      lev,
      leaf: !children,
      index: itemsBefore,
      id,
      children: childrenIds,
      leafsCount: 0,
      _top: itemsBefore,
      //_height: (itemsAfter - itemsBefore),
      top: insideCollapsed ? null : top,
      //height: height,
      //bottom: (insideCollapsed ? null : top) + height,
      collapsed,
      node: item2,
      isLocked: isLocked || insideLocked
    };
    if (children) {
      var subinfo = {};
      children.map(function(child, _childId) {
        _flatizeTree(child, path.concat(id), insideCollapsed || collapsed, insideLocked || isLocked, insideRuleGroup || isRuleGroup, lev + 1, subinfo, type2, type2 == "case_group" ? id : caseId);
      });
      if (!collapsed) {
        info.height = (info.height || 0) + (subinfo.height || 0);
      }
    }
    if (caseId && isLeaf) {
      items[caseId].leafsCount++;
    }
    var itemsAfter = flat.length;
    var height = info.height;
    Object.assign(items[id], {
      _height: itemsAfter - itemsBefore,
      height,
      bottom: (insideCollapsed ? null : top) + height
    });
  }
  _flatizeTree(tree2, [], false, false, false, 0, {}, null, null);
  for (var i2 = 0; i2 < flat.length; i2++) {
    var prevId = i2 > 0 ? flat[i2 - 1] : null;
    var nextId2 = i2 < flat.length - 1 ? flat[i2 + 1] : null;
    var item = items[flat[i2]];
    item.prev = prevId;
    item.next = nextId2;
  }
  return {
    flat,
    items
  };
};
var getTotalReordableNodesCountInTree$2 = function getTotalReordableNodesCountInTree(tree2) {
  if (!tree2)
    return -1;
  var cnt = 0;
  function _processNode(item, path, lev) {
    var id, children, type2;
    if (typeof item.get === "function") {
      id = item.get("id");
      children = item.get("children1");
      type2 = item.get("type");
    } else {
      id = item.id;
      children = item.children1;
      type2 = item.type;
    }
    var isRuleGroup = type2 == "rule_group";
    cnt++;
    if (children && !isRuleGroup) {
      children.map(function(child, _childId) {
        _processNode(child, path.concat(id));
      });
    }
  }
  _processNode(tree2, []);
  return cnt - 1;
};
var getTotalRulesCountInTree$2 = function getTotalRulesCountInTree(tree2) {
  if (!tree2)
    return -1;
  var cnt = 0;
  function _processNode(item, path, lev) {
    var id, children, type2;
    if (typeof item.get === "function") {
      id = item.get("id");
      children = item.get("children1");
      type2 = item.get("type");
    } else {
      id = item.id;
      children = item.children1;
      type2 = item.type;
    }
    if (type2 == "rule" || type2 == "rule_group") {
      cnt++;
    } else if (children) {
      children.map(function(child, _childId) {
        _processNode(child, path.concat(id));
      });
    }
  }
  _processNode(tree2, []);
  return cnt;
};
var getTreeBadFields = function getTreeBadFields2(tree2) {
  var badFields = [];
  function _processNode(item, path, lev) {
    var id = item.get("id");
    var children = item.get("children1");
    var valueError = item.getIn(["properties", "valueError"]);
    var field = item.getIn(["properties", "field"]);
    if (valueError && valueError.size > 0 && valueError.filter(function(v2) {
      return v2 != null;
    }).size > 0) {
      badFields.push(field);
    }
    if (children) {
      children.map(function(child, _childId) {
        _processNode(child, path.concat(id));
      });
    }
  }
  if (tree2)
    _processNode(tree2, []);
  return Array.from(new Set(badFields));
};
var getLightTree = function getLightTree2(tree2) {
  var children1AsArray = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var newTree = tree2;
  function _processNode(item, itemId) {
    if (item.path)
      delete item.path;
    if (!children1AsArray && itemId)
      delete item.id;
    var properties = item.properties;
    if (properties) {
      if (properties.operatorOptions == null)
        delete properties.operatorOptions;
    }
    var children = item.children1;
    if (children) {
      for (var id in children) {
        _processNode(children[id], id);
      }
      if (children1AsArray) {
        item.children1 = Object.values(children);
      }
    }
  }
  _processNode(tree2, null);
  return newTree;
};
var getSwitchValues = function getSwitchValues2(tree2) {
  var vals = [];
  var children = tree2.get("children1");
  if (children) {
    children.map(function(child) {
      var value = child.getIn(["properties", "value"]);
      var caseValue;
      if (value && value.size == 1) {
        caseValue = value.get(0);
        if (Array.isArray(caseValue) && caseValue.length == 0) {
          caseValue = null;
        }
      } else {
        caseValue = null;
      }
      vals = [].concat(_toConsumableArray(vals), [caseValue]);
    });
  }
  return vals;
};
var isEmptyTree = function isEmptyTree2(tree2) {
  return !tree2.get("children1") || tree2.get("children1").size == 0;
};
var hasChildren = function hasChildren2(tree2, path) {
  return tree2.getIn(expandTreePath(path, "children1")).size > 0;
};
const treeUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  expandTreePath,
  expandTreeSubpath,
  fixEmptyGroupsInTree,
  fixPathsInTree,
  getFlatTree: getFlatTree$1,
  getItemByPath,
  getLightTree,
  getSwitchValues,
  getTotalReordableNodesCountInTree: getTotalReordableNodesCountInTree$2,
  getTotalRulesCountInTree: getTotalRulesCountInTree$2,
  getTreeBadFields,
  hasChildren,
  isEmptyTree,
  removeIsLockedInTree,
  removePathsInTree
}, Symbol.toStringTag, { value: "Module" }));
function last$1(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : void 0;
}
var last_1 = last$1;
const last$2 = /* @__PURE__ */ getDefaultExportFromCjs(last_1);
function baseSlice$1(array, start2, end) {
  var index2 = -1, length = array.length;
  if (start2 < 0) {
    start2 = -start2 > length ? 0 : length + start2;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start2 > end ? 0 : end - start2 >>> 0;
  start2 >>>= 0;
  var result = Array(length);
  while (++index2 < length) {
    result[index2] = array[index2 + start2];
  }
  return result;
}
var _baseSlice = baseSlice$1;
var baseGet$1 = _baseGet, baseSlice = _baseSlice;
function parent$1(object, path) {
  return path.length < 2 ? object : baseGet$1(object, baseSlice(path, 0, -1));
}
var _parent = parent$1;
var castPath$3 = _castPath, last = last_1, parent = _parent, toKey$1 = _toKey;
function baseUnset$1(object, path) {
  path = castPath$3(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey$1(last(path))];
}
var _baseUnset = baseUnset$1;
var isPlainObject = isPlainObject_1;
function customOmitClone$1(value) {
  return isPlainObject(value) ? void 0 : value;
}
var _customOmitClone = customOmitClone$1;
var Symbol$1 = _Symbol, isArguments = isArguments_1, isArray = isArray_1;
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function isFlattenable$1(value) {
  return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var _isFlattenable = isFlattenable$1;
var arrayPush = _arrayPush, isFlattenable = _isFlattenable;
function baseFlatten$1(array, depth, predicate, isStrict, result) {
  var index2 = -1, length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index2 < length) {
    var value = array[index2];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten$1(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var _baseFlatten = baseFlatten$1;
var baseFlatten = _baseFlatten;
function flatten$1(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}
var flatten_1 = flatten$1;
var flatten = flatten_1, overRest = _overRest, setToString = _setToString;
function flatRest$2(func) {
  return setToString(overRest(func, void 0, flatten), func + "");
}
var _flatRest = flatRest$2;
var arrayMap$1 = _arrayMap, baseClone = _baseClone, baseUnset = _baseUnset, castPath$2 = _castPath, copyObject = _copyObject, customOmitClone = _customOmitClone, flatRest$1 = _flatRest, getAllKeysIn$1 = _getAllKeysIn;
var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
var omit = flatRest$1(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap$1(paths, function(path) {
    path = castPath$2(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object, getAllKeysIn$1(object), result);
  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    baseUnset(result, paths[length]);
  }
  return result;
});
var omit_1 = omit;
const omit$1 = /* @__PURE__ */ getDefaultExportFromCjs(omit_1);
var typeOf = function typeOf2(v2) {
  if (_typeof$2(v2) == "object" && v2 !== null && Array.isArray(v2))
    return "array";
  else
    return _typeof$2(v2);
};
var isTypeOf = function isTypeOf2(v2, type2) {
  if (typeOf(v2) == type2)
    return true;
  if (type2 == "number" && !isNaN(v2))
    return true;
  return false;
};
var validateAndFixTree$1 = function validateAndFixTree(newTree, _oldTree, newConfig, oldConfig, removeEmptyGroups, removeIncompleteRules) {
  var tree2 = validateTree(newTree, _oldTree, newConfig, oldConfig, removeEmptyGroups, removeIncompleteRules);
  tree2 = fixPathsInTree(tree2);
  return tree2;
};
var validateTree = function validateTree2(tree2, _oldTree, config2, oldConfig, removeEmptyGroups, removeIncompleteRules) {
  if (removeEmptyGroups === void 0) {
    removeEmptyGroups = config2.settings.removeEmptyGroupsOnLoad;
  }
  if (removeIncompleteRules === void 0) {
    removeIncompleteRules = config2.settings.removeIncompleteRulesOnLoad;
  }
  var c2 = {
    config: config2,
    oldConfig,
    removeEmptyGroups,
    removeIncompleteRules
  };
  return validateItem(tree2, [], null, {}, c2);
};
function validateItem(item, path, itemId, meta, c2) {
  var type2 = item.get("type");
  var children = item.get("children1");
  if ((type2 === "group" || type2 === "rule_group" || type2 == "case_group" || type2 == "switch_group") && children && children.size) {
    return validateGroup(item, path, itemId, meta, c2);
  } else if (type2 === "rule") {
    return validateRule(item, path, itemId, meta, c2);
  } else {
    return item;
  }
}
function validateGroup(item, path, itemId, meta, c2) {
  var removeEmptyGroups = c2.removeEmptyGroups;
  var id = item.get("id");
  var children = item.get("children1");
  var oldChildren = children;
  if (!id && itemId) {
    id = itemId;
    item = item.set("id", id);
    meta.sanitized = true;
  }
  var submeta = {};
  children = children.map(function(currentChild, childId) {
    return validateItem(currentChild, path.concat(id), childId, submeta, c2);
  });
  if (removeEmptyGroups)
    children = children.filter(function(currentChild) {
      return currentChild != void 0;
    });
  var sanitized = submeta.sanitized || oldChildren.size != children.size;
  if (!children.size && removeEmptyGroups && path.length) {
    sanitized = true;
    item = void 0;
  }
  if (sanitized)
    meta.sanitized = true;
  if (sanitized && item)
    item = item.set("children1", children);
  return item;
}
function validateRule(item, path, itemId, meta, c2) {
  var removeIncompleteRules = c2.removeIncompleteRules, config2 = c2.config, oldConfig = c2.oldConfig;
  var showErrorMessage = config2.settings.showErrorMessage;
  var id = item.get("id");
  var properties = item.get("properties");
  var field = properties.get("field") || null;
  var operator = properties.get("operator") || null;
  var operatorOptions = properties.get("operatorOptions");
  var valueSrc = properties.get("valueSrc");
  var value = properties.get("value");
  var valueError = properties.get("valueError");
  var oldSerialized = {
    field,
    operator,
    operatorOptions: operatorOptions ? operatorOptions.toJS() : {},
    valueSrc: valueSrc ? valueSrc.toJS() : null,
    value: value ? value.toJS() : null,
    valueError: valueError ? valueError.toJS() : null
  };
  field && operator && value && !value.includes(void 0);
  if (!id && itemId) {
    id = itemId;
    item = item.set("id", id);
    meta.sanitized = true;
  }
  var fieldDefinition = field ? getFieldConfig$8(config2, field) : null;
  if (field && !fieldDefinition) {
    logger$1.warn("No config for field ".concat(field));
    field = null;
  }
  if (field == null) {
    properties = ["operator", "operatorOptions", "valueSrc", "value"].reduce(function(map2, key) {
      return map2["delete"](key);
    }, properties);
    operator = null;
  }
  if (operator == "range_between" || operator == "range_not_between") {
    operator = operator == "range_between" ? "between" : "not_between";
    console.info("Fixed operator ".concat(properties.get("operator"), " to ").concat(operator));
    properties = properties.set("operator", operator);
  }
  var operatorDefinition = operator ? getOperatorConfig$4(config2, operator, field) : null;
  if (operator && !operatorDefinition) {
    console.warn("No config for operator ".concat(operator));
    operator = null;
  }
  var availOps = field ? getOperatorsForField(config2, field) : [];
  if (!availOps) {
    console.warn("Type of field ".concat(field, " is not supported"));
    operator = null;
  } else if (operator && availOps.indexOf(operator) == -1) {
    if (operator == "is_empty" || operator == "is_not_empty") {
      operator = operator == "is_empty" ? "is_null" : "is_not_null";
      console.info("Fixed operator ".concat(properties.get("operator"), " to ").concat(operator, " for ").concat(field));
      properties = properties.set("operator", operator);
    } else {
      console.warn("Operator ".concat(operator, " is not supported for field ").concat(field));
      operator = null;
    }
  }
  if (operator == null) {
    properties = properties["delete"]("operatorOptions");
    properties = properties["delete"]("valueSrc");
    properties = properties["delete"]("value");
  }
  operatorOptions = properties.get("operatorOptions");
  operator ? defaultValue$1(operatorDefinition.cardinality, 1) : null;
  if (!operator || operatorOptions && !operatorDefinition.options) {
    operatorOptions = null;
    properties = properties["delete"]("operatorOptions");
  } else if (operator && !operatorOptions && operatorDefinition.options) {
    operatorOptions = defaultOperatorOptions(config2, operator, field);
    properties = properties.set("operatorOptions", operatorOptions);
  }
  valueSrc = properties.get("valueSrc");
  value = properties.get("value");
  var canFix = !showErrorMessage;
  var isEndValue = true;
  var _getNewValueForFieldO = getNewValueForFieldOp(config2, oldConfig, properties, field, operator, null, canFix, isEndValue), newValue = _getNewValueForFieldO.newValue, newValueSrc = _getNewValueForFieldO.newValueSrc, newValueError = _getNewValueForFieldO.newValueError;
  value = newValue;
  valueSrc = newValueSrc;
  valueError = newValueError;
  properties = properties.set("value", value);
  properties = properties.set("valueSrc", valueSrc);
  if (showErrorMessage) {
    properties = properties.set("valueError", valueError);
  }
  var newSerialized = {
    field,
    operator,
    operatorOptions: operatorOptions ? operatorOptions.toJS() : {},
    valueSrc: valueSrc ? valueSrc.toJS() : null,
    value: value ? value.toJS() : null,
    valueError: valueError ? valueError.toJS() : null
  };
  var sanitized = !deepEqual(oldSerialized, newSerialized);
  var isComplete = field && operator && value && !value.includes(void 0);
  if (sanitized)
    meta.sanitized = true;
  if (!isComplete && removeIncompleteRules)
    item = void 0;
  else if (sanitized)
    item = item.set("properties", properties);
  return item;
}
var validateValue = function validateValue2(config2, leftField, field, operator, value, valueType, valueSrc, asyncListValues) {
  var canFix = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : false;
  var isEndValue = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : false;
  var isRawValue = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : true;
  var validError = null;
  var fixedValue = value;
  if (value != null) {
    if (valueSrc == "field") {
      var _validateFieldValue = validateFieldValue(leftField, field, value, valueSrc, valueType, asyncListValues, config2);
      var _validateFieldValue2 = _slicedToArray$1(_validateFieldValue, 2);
      validError = _validateFieldValue2[0];
      fixedValue = _validateFieldValue2[1];
    } else if (valueSrc == "func") {
      var _validateFuncValue = validateFuncValue(leftField, field, value, valueSrc, valueType, asyncListValues, config2, operator, isEndValue, canFix);
      var _validateFuncValue2 = _slicedToArray$1(_validateFuncValue, 2);
      validError = _validateFuncValue2[0];
      fixedValue = _validateFuncValue2[1];
    } else if (valueSrc == "value" || !valueSrc) {
      var _validateNormalValue = validateNormalValue(leftField, field, value, valueSrc, valueType, asyncListValues, config2, operator, isEndValue, canFix);
      var _validateNormalValue2 = _slicedToArray$1(_validateNormalValue, 2);
      validError = _validateNormalValue2[0];
      fixedValue = _validateNormalValue2[1];
    }
    if (!validError) {
      getFieldConfig$8(config2, field);
      var w2 = getWidgetForFieldOp$3(config2, field, operator, valueSrc);
      var operatorDefinition = operator ? getOperatorConfig$4(config2, operator, field) : null;
      var fieldWidgetDefinition = omit$1(getFieldWidgetConfig$3(config2, field, operator, w2, valueSrc), ["factory"]);
      var rightFieldDefinition = valueSrc == "field" ? getFieldConfig$8(config2, value) : null;
      var fieldSettings = fieldWidgetDefinition;
      var fn = fieldWidgetDefinition.validateValue;
      if (typeof fn == "function") {
        var args = [fixedValue, fieldSettings, operator, operatorDefinition];
        if (valueSrc == "field")
          args.push(rightFieldDefinition);
        var validResult = fn.apply(void 0, args);
        if (typeof validResult == "boolean") {
          if (validResult == false)
            validError = "Invalid value";
        } else {
          validError = validResult;
        }
      }
    }
  }
  if (isRawValue && validError) {
    console.warn("[RAQB validate]", "Field ".concat(field, ": ").concat(validError));
  }
  return [validError, fixedValue];
};
var validateValueInList = function validateValueInList2(value, listValues2, canFix, isEndValue, removeInvalidMultiSelectValuesOnLoad) {
  var values = immutableExports.List.isList(value) ? value.toJS() : value instanceof Array ? _toConsumableArray(value) : void 0;
  if (values) {
    var _values$reduce = values.reduce(function(_ref, val) {
      var _ref2 = _slicedToArray$1(_ref, 2), goodVals = _ref2[0], badVals = _ref2[1];
      var vv2 = getItemInListValues(listValues2, val);
      if (vv2 == void 0) {
        return [goodVals, [].concat(_toConsumableArray(badVals), [val])];
      } else {
        return [[].concat(_toConsumableArray(goodVals), [vv2.value]), badVals];
      }
    }, [[], []]), _values$reduce2 = _slicedToArray$1(_values$reduce, 2), goodValues = _values$reduce2[0], badValues = _values$reduce2[1];
    var plural = badValues.length > 1;
    var err = badValues.length ? "".concat(plural ? "Values" : "Value", " ").concat(badValues.join(", "), " ").concat(plural ? "are" : "is", " not in list of values") : null;
    if (removeInvalidMultiSelectValuesOnLoad !== void 0) {
      canFix = removeInvalidMultiSelectValuesOnLoad;
    } else {
      canFix = canFix || isEndValue;
    }
    return [err, canFix ? goodValues : value];
  } else {
    var vv = getItemInListValues(listValues2, value);
    if (vv == void 0) {
      return ["Value ".concat(value, " is not in list of values"), value];
    } else {
      value = vv.value;
    }
    return [null, value];
  }
};
var validateNormalValue = function validateNormalValue2(leftField, field, value, valueSrc, valueType, asyncListValues, config2) {
  var operator = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null;
  var isEndValue = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : false;
  var canFix = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : false;
  if (field) {
    var fieldConfig = getFieldConfig$8(config2, field);
    var w2 = getWidgetForFieldOp$3(config2, field, operator, valueSrc);
    var wConfig = config2.widgets[w2];
    var wType = wConfig.type;
    var jsType = wConfig.jsType;
    var fieldSettings = fieldConfig.fieldSettings;
    var listValues2 = fieldSettings.treeValues || fieldSettings.listValues;
    if (valueType && valueType != wType)
      return ["Value should have type ".concat(wType, ", but got value of type ").concat(valueType), value];
    if (jsType && !isTypeOf(value, jsType) && !listValues2) {
      return ["Value should have JS type ".concat(jsType, ", but got value of type ").concat(_typeof$2(value)), value];
    }
    if (fieldSettings) {
      var realListValues = asyncListValues || listValues2;
      if (realListValues && !fieldSettings.allowCustomValues) {
        return validateValueInList(value, realListValues, canFix, isEndValue, config2.settings.removeInvalidMultiSelectValuesOnLoad);
      }
      if (fieldSettings.min != null && value < fieldSettings.min) {
        return ["Value ".concat(value, " < min ").concat(fieldSettings.min), canFix ? fieldSettings.min : value];
      }
      if (fieldSettings.max != null && value > fieldSettings.max) {
        return ["Value ".concat(value, " > max ").concat(fieldSettings.max), canFix ? fieldSettings.max : value];
      }
    }
  }
  return [null, value];
};
var validateFieldValue = function validateFieldValue2(leftField, field, value, _valueSrc, valueType, asyncListValues, config2) {
  var fieldSeparator = config2.settings.fieldSeparator;
  var isFuncArg = _typeof$2(field) == "object" && (field === null || field === void 0 ? void 0 : field._isFuncArg);
  var leftFieldStr = Array.isArray(leftField) ? leftField.join(fieldSeparator) : leftField;
  var rightFieldStr = Array.isArray(value) ? value.join(fieldSeparator) : value;
  var rightFieldDefinition = getFieldConfig$8(config2, value);
  if (!rightFieldDefinition)
    return ["Unknown field ".concat(value), value];
  if (rightFieldStr == leftFieldStr && !isFuncArg)
    return ["Can't compare field ".concat(leftField, " with itself"), value];
  if (valueType && valueType != rightFieldDefinition.type)
    return ["Field ".concat(value, " is of type ").concat(rightFieldDefinition.type, ", but expected ").concat(valueType), value];
  return [null, value];
};
var validateFuncValue = function validateFuncValue2(leftField, field, value, _valueSrc, valueType, asyncListValues, config2) {
  var operator = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null;
  var isEndValue = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : false;
  var canFix = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : false;
  var fixedValue = value;
  if (value) {
    var funcKey = value.get("func");
    if (funcKey) {
      var funcConfig = getFuncConfig$2(config2, funcKey);
      if (funcConfig) {
        if (valueType && funcConfig.returnType != valueType)
          return ["Function ".concat(funcKey, " should return value of type ").concat(funcConfig.returnType, ", but got ").concat(valueType), value];
        for (var argKey in funcConfig.args) {
          var argConfig = funcConfig.args[argKey];
          var args = fixedValue.get("args");
          var argVal = args ? args.get(argKey) : void 0;
          var fieldDef = getFieldConfig$8(config2, argConfig);
          var argValue = argVal ? argVal.get("value") : void 0;
          var argValueSrc = argVal ? argVal.get("valueSrc") : void 0;
          if (argValue !== void 0) {
            var _validateValue = validateValue(config2, leftField, fieldDef, operator, argValue, argConfig.type, argValueSrc, asyncListValues, canFix, isEndValue, false), _validateValue2 = _slicedToArray$1(_validateValue, 2), argValidError = _validateValue2[0], fixedArgVal = _validateValue2[1];
            if (argValidError !== null) {
              if (canFix) {
                fixedValue = fixedValue.deleteIn(["args", argKey]);
                if (argConfig.defaultValue !== void 0) {
                  fixedValue = fixedValue.setIn(["args", argKey, "value"], argConfig.defaultValue);
                  fixedValue = fixedValue.setIn(["args", argKey, "valueSrc"], "value");
                }
              } else {
                return ["Invalid value of arg ".concat(argKey, " for func ").concat(funcKey, ": ").concat(argValidError), value];
              }
            } else if (fixedArgVal !== argValue) {
              fixedValue = fixedValue.setIn(["args", argKey, "value"], fixedArgVal);
            }
          } else if (isEndValue && argConfig.defaultValue === void 0 && !canFix) {
            return ["Value of arg ".concat(argKey, " for func ").concat(funcKey, " is required"), value];
          }
        }
      } else
        return ["Unknown function ".concat(funcKey), value];
    }
  }
  return [null, fixedValue];
};
var selectTypes = ["select", "multiselect", "treeselect", "treemultiselect"];
var getNewValueForFieldOp = function getNewValueForFieldOp2(config2) {
  var oldConfig = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  var current = arguments.length > 2 ? arguments[2] : void 0;
  var newField = arguments.length > 3 ? arguments[3] : void 0;
  var newOperator = arguments.length > 4 ? arguments[4] : void 0;
  var changedProp = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null;
  var canFix = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : true;
  var isEndValue = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false;
  if (!oldConfig)
    oldConfig = config2;
  var currentField = current.get("field");
  var currentOperator = current.get("operator");
  var currentValue = current.get("value");
  var currentValueSrc = current.get("valueSrc", new Immutable.List());
  var currentValueType = current.get("valueType", new Immutable.List());
  var currentAsyncListValues = current.get("asyncListValues");
  var _config$settings = config2.settings, convertableWidgets = _config$settings.convertableWidgets, clearValueOnChangeField = _config$settings.clearValueOnChangeField, clearValueOnChangeOp = _config$settings.clearValueOnChangeOp, showErrorMessage = _config$settings.showErrorMessage;
  var newOperatorConfig = getOperatorConfig$4(config2, newOperator, newField);
  var operatorCardinality = newOperator ? defaultValue$1(newOperatorConfig.cardinality, 1) : null;
  var currentFieldConfig = getFieldConfig$8(oldConfig, currentField);
  var newFieldConfig = getFieldConfig$8(config2, newField);
  var canReuseValue = currentField && currentOperator && newOperator && currentValue != void 0 && (!changedProp || changedProp == "field" && !clearValueOnChangeField || changedProp == "operator" && !clearValueOnChangeOp) && currentFieldConfig && newFieldConfig && currentFieldConfig.type == newFieldConfig.type;
  if (canReuseValue && selectTypes.includes(currentFieldConfig.type) && changedProp == "field") {
    canReuseValue = false;
  }
  for (var i2 = 0; i2 < operatorCardinality; i2++) {
    var vs = currentValueSrc.get(i2) || null;
    var currentWidget = getWidgetForFieldOp$3(oldConfig, currentField, currentOperator, vs);
    var newWidget = getWidgetForFieldOp$3(config2, newField, newOperator, vs);
    var currentValueWidget = vs == "value" ? currentWidget : getWidgetForFieldOp$3(oldConfig, currentField, currentOperator, "value");
    var newValueWidget = vs == "value" ? newWidget : getWidgetForFieldOp$3(config2, newField, newOperator, "value");
    var canReuseWidget = newValueWidget == currentValueWidget || (convertableWidgets[currentValueWidget] || []).includes(newValueWidget);
    if (!canReuseWidget)
      canReuseValue = false;
  }
  if (currentOperator != newOperator && [currentOperator, newOperator].includes("proximity"))
    canReuseValue = false;
  var firstWidgetConfig = getFieldWidgetConfig$3(config2, newField, newOperator, null, currentValueSrc.first());
  var valueSources = getValueSourcesForFieldOp$1(config2, newField, newOperator);
  var valueFixes = {};
  var valueErrors = Array.from({
    length: operatorCardinality
  }, function() {
    return null;
  });
  if (canReuseValue) {
    var _loop = function _loop4() {
      var v2 = currentValue.get(_i);
      var vType = currentValueType.get(_i) || null;
      var vSrc = currentValueSrc.get(_i) || null;
      var isValidSrc = valueSources.find(function(v3) {
        return v3 == vSrc;
      }) != null;
      if (!isValidSrc && _i > 0 && vSrc == null)
        isValidSrc = true;
      var asyncListValues = currentAsyncListValues;
      var _validateValue = validateValue(config2, newField, newField, newOperator, v2, vType, vSrc, asyncListValues, canFix, isEndValue), _validateValue2 = _slicedToArray$1(_validateValue, 2), validateError = _validateValue2[0], fixedValue = _validateValue2[1];
      var isValid3 = !validateError;
      var fixValue = fixedValue !== v2;
      var dropValue = !isValidSrc || !isValid3 && (changedProp == "field" || !showErrorMessage && !fixValue);
      var showValueError = !!validateError && showErrorMessage && !dropValue && !fixValue;
      if (showValueError) {
        valueErrors[_i] = validateError;
      }
      if (fixValue) {
        valueFixes[_i] = fixedValue;
      }
      if (dropValue) {
        canReuseValue = false;
        return "break";
      }
    };
    for (var _i = 0; _i < operatorCardinality; _i++) {
      var _ret = _loop();
      if (_ret === "break")
        break;
    }
  }
  var newValue = null, newValueSrc = null, newValueType = null, newValueError = null;
  newValue = new Immutable.List(Array.from({
    length: operatorCardinality
  }, function(_ignore, i3) {
    var v2 = void 0;
    if (canReuseValue) {
      if (i3 < currentValue.size) {
        v2 = currentValue.get(i3);
        if (valueFixes[i3] !== void 0) {
          v2 = valueFixes[i3];
        }
      }
    } else if (operatorCardinality == 1) {
      var _newFieldConfig$field;
      v2 = getFirstDefined([newFieldConfig === null || newFieldConfig === void 0 ? void 0 : newFieldConfig.defaultValue, newFieldConfig === null || newFieldConfig === void 0 ? void 0 : (_newFieldConfig$field = newFieldConfig.fieldSettings) === null || _newFieldConfig$field === void 0 ? void 0 : _newFieldConfig$field.defaultValue, firstWidgetConfig === null || firstWidgetConfig === void 0 ? void 0 : firstWidgetConfig.defaultValue]);
    }
    return v2;
  }));
  newValueSrc = new Immutable.List(Array.from({
    length: operatorCardinality
  }, function(_ignore, i3) {
    var vs2 = null;
    if (canReuseValue) {
      if (i3 < currentValueSrc.size)
        vs2 = currentValueSrc.get(i3);
    } else if (valueSources.length == 1) {
      vs2 = valueSources[0];
    } else if (valueSources.length > 1) {
      vs2 = valueSources[0];
    }
    return vs2;
  }));
  if (showErrorMessage) {
    if (newOperatorConfig && newOperatorConfig.validateValues && newValueSrc.toJS().filter(function(vs2) {
      return vs2 == "value" || vs2 == null;
    }).length == operatorCardinality) {
      var jsValues = firstWidgetConfig && firstWidgetConfig.toJS ? newValue.toJS().map(function(v2) {
        return firstWidgetConfig.toJS(v2, firstWidgetConfig);
      }) : newValue.toJS();
      var rangeValidateError = newOperatorConfig.validateValues(jsValues);
      if (showErrorMessage) {
        valueErrors.push(rangeValidateError);
      }
    }
    newValueError = new Immutable.List(valueErrors);
  }
  newValueType = new Immutable.List(Array.from({
    length: operatorCardinality
  }, function(_ignore, i3) {
    var vt = null;
    if (canReuseValue) {
      if (i3 < currentValueType.size)
        vt = currentValueType.get(i3);
    } else if (operatorCardinality == 1 && firstWidgetConfig && firstWidgetConfig.type !== void 0) {
      vt = firstWidgetConfig.type;
    } else if (operatorCardinality == 1 && newFieldConfig && newFieldConfig.type !== void 0) {
      vt = newFieldConfig.type == "!group" ? "number" : newFieldConfig.type;
    }
    return vt;
  }));
  return {
    canReuseValue,
    newValue,
    newValueSrc,
    newValueType,
    newValueError,
    operatorCardinality
  };
};
var getFirstField = function getFirstField2(config2) {
  var parentRuleGroupPath = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  var fieldSeparator = config2.settings.fieldSeparator;
  var parentPathArr = typeof parentRuleGroupPath == "string" ? parentRuleGroupPath.split(fieldSeparator) : parentRuleGroupPath;
  var parentField = parentRuleGroupPath ? getFieldRawConfig(config2, parentRuleGroupPath) : config2;
  var firstField = parentField, key = null, keysPath = [];
  do {
    var subfields = firstField === config2 ? config2.fields : firstField.subfields;
    if (!subfields || !Object.keys(subfields).length) {
      firstField = key = null;
      break;
    }
    key = Object.keys(subfields)[0];
    keysPath.push(key);
    firstField = subfields[key];
  } while (firstField.type == "!struct" || firstField.type == "!group");
  return (parentPathArr || []).concat(keysPath).join(fieldSeparator);
};
var getOperatorsForField = function getOperatorsForField2(config2, field) {
  var fieldConfig = getFieldConfig$8(config2, field);
  var fieldOps = fieldConfig ? fieldConfig.operators : [];
  return fieldOps;
};
var getFirstOperator = function getFirstOperator2(config2, field) {
  var fieldOps = getOperatorsForField(config2, field);
  return fieldOps ? fieldOps[0] : null;
};
var getFieldPath$3 = function getFieldPath(field, config2) {
  var onlyKeys = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (!field)
    return null;
  var fieldSeparator = config2.settings.fieldSeparator;
  var parts = Array.isArray(field) ? field : field.split(fieldSeparator);
  if (onlyKeys)
    return parts;
  else
    return parts.map(function(_curr, ind, arr) {
      return arr.slice(0, ind + 1);
    }).map(function(parts2) {
      return parts2.join(fieldSeparator);
    });
};
var getFuncPathLabels$1 = function getFuncPathLabels(field, config2) {
  var parentField = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  return getFieldPathLabels$3(field, config2, parentField, "funcs", "subfields");
};
var getFieldPathLabels$3 = function getFieldPathLabels(field, config2) {
  var parentField = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  var fieldsKey = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "fields";
  var subfieldsKey = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "subfields";
  if (!field)
    return null;
  var fieldSeparator = config2.settings.fieldSeparator;
  var parts = Array.isArray(field) ? field : field.split(fieldSeparator);
  var parentParts = parentField ? Array.isArray(parentField) ? parentField : parentField.split(fieldSeparator) : [];
  return parts.slice(parentParts.length).map(function(_curr, ind, arr) {
    return arr.slice(0, ind + 1);
  }).map(function(parts2) {
    return [].concat(_toConsumableArray(parentParts), _toConsumableArray(parts2)).join(fieldSeparator);
  }).map(function(part) {
    var cnf = getFieldRawConfig(config2, part, fieldsKey, subfieldsKey);
    return cnf && cnf.label || cnf && last$2(part.split(fieldSeparator));
  }).filter(function(label2) {
    return label2 != null;
  });
};
var getFieldPartsConfigs = function getFieldPartsConfigs2(field, config2) {
  var parentField = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  if (!field)
    return null;
  var parentFieldDef = parentField && getFieldRawConfig(config2, parentField) || null;
  var fieldSeparator = config2.settings.fieldSeparator;
  var parts = Array.isArray(field) ? field : field.split(fieldSeparator);
  var parentParts = parentField ? Array.isArray(parentField) ? parentField : parentField.split(fieldSeparator) : [];
  return parts.slice(parentParts.length).map(function(_curr, ind, arr) {
    return arr.slice(0, ind + 1);
  }).map(function(parts2) {
    return {
      part: [].concat(_toConsumableArray(parentParts), _toConsumableArray(parts2)).join(fieldSeparator),
      key: parts2[parts2.length - 1]
    };
  }).map(function(_ref) {
    var part = _ref.part, key = _ref.key;
    var cnf = getFieldRawConfig(config2, part);
    return {
      key,
      cnf
    };
  }).map(function(_ref2, ind, arr) {
    var key = _ref2.key, cnf = _ref2.cnf;
    var parentCnf = ind > 0 ? arr[ind - 1].cnf : parentFieldDef;
    return [key, cnf, parentCnf];
  });
};
var getValueLabel$1 = function getValueLabel(config2, field, operator, delta) {
  var valueSrc = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
  var isSpecialRange = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
  var isFuncArg = field && _typeof$2(field) == "object" && !!field.func && !!field.arg;
  var showLabels = config2.settings.showLabels;
  var fieldConfig = getFieldConfig$8(config2, field);
  var fieldWidgetConfig = getFieldWidgetConfig$3(config2, field, operator, null, valueSrc) || {};
  var mergedOpConfig = getOperatorConfig$4(config2, operator, field) || {};
  var cardinality = isSpecialRange ? 1 : mergedOpConfig.cardinality;
  var ret = null;
  if (cardinality > 1) {
    var valueLabels = fieldWidgetConfig.valueLabels || mergedOpConfig.valueLabels;
    if (valueLabels)
      ret = valueLabels[delta];
    if (ret && _typeof$2(ret) != "object") {
      ret = {
        label: ret,
        placeholder: ret
      };
    }
    if (!ret) {
      ret = {
        label: config2.settings.valueLabel + " " + (delta + 1),
        placeholder: config2.settings.valuePlaceholder + " " + (delta + 1)
      };
    }
  } else {
    var label2 = fieldWidgetConfig.valueLabel;
    var placeholder2 = fieldWidgetConfig.valuePlaceholder;
    if (isFuncArg) {
      if (!label2)
        label2 = fieldConfig.label || field.arg;
      if (!placeholder2 && !showLabels)
        placeholder2 = fieldConfig.label || field.arg;
    }
    ret = {
      label: label2 || config2.settings.valueLabel,
      placeholder: placeholder2 || config2.settings.valuePlaceholder
    };
  }
  return ret;
};
function _getWidgetsAndSrcsForFieldOp(config2, field) {
  var operator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  var valueSrc = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var widgets2 = [];
  var valueSrcs = [];
  if (!field)
    return {
      widgets: widgets2,
      valueSrcs
    };
  var isFuncArg = _typeof$2(field) == "object" && (!!field.func && !!field.arg || field._isFuncArg);
  var fieldConfig = getFieldConfig$8(config2, field);
  var opConfig = operator ? config2.operators[operator] : null;
  if (fieldConfig && fieldConfig.widgets) {
    var _loop22 = function _loop23() {
      var widgetConfig = fieldConfig.widgets[widget];
      var widgetValueSrc = config2.widgets[widget].valueSrc || "value";
      var canAdd = true;
      if (widget == "field") {
        canAdd = canAdd && filterValueSourcesForField(config2, ["field"], fieldConfig).length > 0;
      }
      if (widget == "func") {
        canAdd = canAdd && filterValueSourcesForField(config2, ["func"], fieldConfig).length > 0;
      }
      if (valueSrc == "value" && !widgetConfig.operators && !isFuncArg && field != "!case_value")
        canAdd = false;
      if (widgetConfig.operators && operator)
        canAdd = canAdd && widgetConfig.operators.indexOf(operator) != -1;
      if (valueSrc && valueSrc != widgetValueSrc && valueSrc != "const")
        canAdd = false;
      if (opConfig && opConfig.cardinality == 0 && widgetValueSrc != "value")
        canAdd = false;
      if (canAdd) {
        widgets2.push(widget);
        var canAddValueSrc = fieldConfig.valueSources && fieldConfig.valueSources.indexOf(widgetValueSrc) != -1;
        if (opConfig && opConfig.valueSources && opConfig.valueSources.indexOf(widgetValueSrc) == -1)
          canAddValueSrc = false;
        if (canAddValueSrc && !valueSrcs.find(function(v2) {
          return v2 == widgetValueSrc;
        }))
          valueSrcs.push(widgetValueSrc);
      }
    };
    for (var widget in fieldConfig.widgets) {
      _loop22();
    }
  }
  var widgetWeight = function widgetWeight2(w2) {
    var wg = 0;
    if (fieldConfig.preferWidgets) {
      if (fieldConfig.preferWidgets.includes(w2))
        wg += 10 - fieldConfig.preferWidgets.indexOf(w2);
    } else if (w2 == fieldConfig.mainWidget) {
      wg += 100;
    }
    if (w2 == "field") {
      wg -= 1;
    }
    if (w2 == "func") {
      wg -= 2;
    }
    return wg;
  };
  widgets2.sort(function(w1, w2) {
    return widgetWeight(w2) - widgetWeight(w1);
  });
  return {
    widgets: widgets2,
    valueSrcs
  };
}
var getWidgetsForFieldOp$1 = function getWidgetsForFieldOp(config2, field, operator) {
  var valueSrc = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var _getWidgetsAndSrcsFor = _getWidgetsAndSrcsForFieldOp(config2, field, operator, valueSrc), widgets2 = _getWidgetsAndSrcsFor.widgets;
  return widgets2;
};
var filterValueSourcesForField = function filterValueSourcesForField2(config2, valueSrcs, fieldDefinition) {
  if (!fieldDefinition)
    return valueSrcs;
  return valueSrcs.filter(function(vs) {
    var canAdd = true;
    if (vs == "field") {
      if (config2._fieldsCntByType) {
        var minCnt = fieldDefinition._isFuncArg ? 0 : 1;
        canAdd = canAdd && config2._fieldsCntByType[fieldDefinition.type] > minCnt;
      }
    }
    if (vs == "func") {
      if (config2._funcsCntByType)
        canAdd = canAdd && !!config2._funcsCntByType[fieldDefinition.type];
      if (fieldDefinition.funcs)
        canAdd = canAdd && fieldDefinition.funcs.length > 0;
    }
    return canAdd;
  });
};
var getValueSourcesForFieldOp$1 = function getValueSourcesForFieldOp(config2, field, operator) {
  var fieldDefinition = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var _getWidgetsAndSrcsFor2 = _getWidgetsAndSrcsForFieldOp(config2, field, operator, null), valueSrcs = _getWidgetsAndSrcsFor2.valueSrcs;
  var filteredValueSrcs = filterValueSourcesForField(config2, valueSrcs, fieldDefinition);
  return filteredValueSrcs;
};
var getWidgetForFieldOp$3 = function getWidgetForFieldOp(config2, field, operator) {
  var valueSrc = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var _getWidgetsAndSrcsFor3 = _getWidgetsAndSrcsForFieldOp(config2, field, operator, valueSrc), widgets2 = _getWidgetsAndSrcsFor3.widgets;
  var widget = null;
  if (widgets2.length)
    widget = widgets2[0];
  return widget;
};
var formatFieldName$1 = function formatFieldName(field, config2, meta) {
  var parentField = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  if (!field)
    return;
  var fieldDef = getFieldConfig$8(config2, field) || {};
  var fieldSeparator = config2.settings.fieldSeparator;
  var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);
  var fieldName = Array.isArray(field) ? field.join(fieldSeparator) : field;
  if (fieldDef.tableName) {
    var fieldPartsCopy = _toConsumableArray(fieldParts);
    fieldPartsCopy[0] = fieldDef.tableName;
    fieldName = fieldPartsCopy.join(fieldSeparator);
  }
  if (fieldDef.fieldName) {
    fieldName = fieldDef.fieldName;
  }
  if (parentField) {
    var parentFieldDef = getFieldConfig$8(config2, parentField) || {};
    var parentFieldName = parentField;
    if (parentFieldDef.fieldName) {
      parentFieldName = parentFieldDef.fieldName;
    }
    if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {
      fieldName = fieldName.slice((parentFieldName + fieldSeparator).length);
    } else {
      meta.errors.push("Can't cut group ".concat(parentFieldName, " from field ").concat(fieldName));
    }
  }
  return fieldName;
};
const ruleUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  filterValueSourcesForField,
  formatFieldName: formatFieldName$1,
  getFieldPartsConfigs,
  getFieldPath: getFieldPath$3,
  getFieldPathLabels: getFieldPathLabels$3,
  getFirstField,
  getFirstOperator,
  getFuncPathLabels: getFuncPathLabels$1,
  getNewValueForFieldOp,
  getOperatorsForField,
  getValueLabel: getValueLabel$1,
  getValueSourcesForFieldOp: getValueSourcesForFieldOp$1,
  getWidgetForFieldOp: getWidgetForFieldOp$3,
  getWidgetsForFieldOp: getWidgetsForFieldOp$1
}, Symbol.toStringTag, { value: "Module" }));
var clone$4 = { exports: {} };
(function(module2) {
  var clone3 = function() {
    function _instanceof(obj, type2) {
      return type2 != null && obj instanceof type2;
    }
    var nativeMap;
    try {
      nativeMap = Map;
    } catch (_) {
      nativeMap = function() {
      };
    }
    var nativeSet;
    try {
      nativeSet = Set;
    } catch (_) {
      nativeSet = function() {
      };
    }
    var nativePromise;
    try {
      nativePromise = Promise;
    } catch (_) {
      nativePromise = function() {
      };
    }
    function clone4(parent2, circular, depth, prototype, includeNonEnumerable) {
      if (typeof circular === "object") {
        depth = circular.depth;
        prototype = circular.prototype;
        includeNonEnumerable = circular.includeNonEnumerable;
        circular = circular.circular;
      }
      var allParents = [];
      var allChildren = [];
      var useBuffer = typeof Buffer != "undefined";
      if (typeof circular == "undefined")
        circular = true;
      if (typeof depth == "undefined")
        depth = Infinity;
      function _clone(parent3, depth2) {
        if (parent3 === null)
          return null;
        if (depth2 === 0)
          return parent3;
        var child;
        var proto2;
        if (typeof parent3 != "object") {
          return parent3;
        }
        if (_instanceof(parent3, nativeMap)) {
          child = new nativeMap();
        } else if (_instanceof(parent3, nativeSet)) {
          child = new nativeSet();
        } else if (_instanceof(parent3, nativePromise)) {
          child = new nativePromise(function(resolve, reject) {
            parent3.then(function(value) {
              resolve(_clone(value, depth2 - 1));
            }, function(err) {
              reject(_clone(err, depth2 - 1));
            });
          });
        } else if (clone4.__isArray(parent3)) {
          child = [];
        } else if (clone4.__isRegExp(parent3)) {
          child = new RegExp(parent3.source, __getRegExpFlags(parent3));
          if (parent3.lastIndex)
            child.lastIndex = parent3.lastIndex;
        } else if (clone4.__isDate(parent3)) {
          child = new Date(parent3.getTime());
        } else if (useBuffer && Buffer.isBuffer(parent3)) {
          if (Buffer.allocUnsafe) {
            child = Buffer.allocUnsafe(parent3.length);
          } else {
            child = new Buffer(parent3.length);
          }
          parent3.copy(child);
          return child;
        } else if (_instanceof(parent3, Error)) {
          child = Object.create(parent3);
        } else {
          if (typeof prototype == "undefined") {
            proto2 = Object.getPrototypeOf(parent3);
            child = Object.create(proto2);
          } else {
            child = Object.create(prototype);
            proto2 = prototype;
          }
        }
        if (circular) {
          var index2 = allParents.indexOf(parent3);
          if (index2 != -1) {
            return allChildren[index2];
          }
          allParents.push(parent3);
          allChildren.push(child);
        }
        if (_instanceof(parent3, nativeMap)) {
          parent3.forEach(function(value, key) {
            var keyChild = _clone(key, depth2 - 1);
            var valueChild = _clone(value, depth2 - 1);
            child.set(keyChild, valueChild);
          });
        }
        if (_instanceof(parent3, nativeSet)) {
          parent3.forEach(function(value) {
            var entryChild = _clone(value, depth2 - 1);
            child.add(entryChild);
          });
        }
        for (var i2 in parent3) {
          var attrs;
          if (proto2) {
            attrs = Object.getOwnPropertyDescriptor(proto2, i2);
          }
          if (attrs && attrs.set == null) {
            continue;
          }
          child[i2] = _clone(parent3[i2], depth2 - 1);
        }
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(parent3);
          for (var i2 = 0; i2 < symbols.length; i2++) {
            var symbol = symbols[i2];
            var descriptor = Object.getOwnPropertyDescriptor(parent3, symbol);
            if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
              continue;
            }
            child[symbol] = _clone(parent3[symbol], depth2 - 1);
            if (!descriptor.enumerable) {
              Object.defineProperty(child, symbol, {
                enumerable: false
              });
            }
          }
        }
        if (includeNonEnumerable) {
          var allPropertyNames = Object.getOwnPropertyNames(parent3);
          for (var i2 = 0; i2 < allPropertyNames.length; i2++) {
            var propertyName = allPropertyNames[i2];
            var descriptor = Object.getOwnPropertyDescriptor(parent3, propertyName);
            if (descriptor && descriptor.enumerable) {
              continue;
            }
            child[propertyName] = _clone(parent3[propertyName], depth2 - 1);
            Object.defineProperty(child, propertyName, {
              enumerable: false
            });
          }
        }
        return child;
      }
      return _clone(parent2, depth);
    }
    clone4.clonePrototype = function clonePrototype(parent2) {
      if (parent2 === null)
        return null;
      var c2 = function() {
      };
      c2.prototype = parent2;
      return new c2();
    };
    function __objToStr(o) {
      return Object.prototype.toString.call(o);
    }
    clone4.__objToStr = __objToStr;
    function __isDate(o) {
      return typeof o === "object" && __objToStr(o) === "[object Date]";
    }
    clone4.__isDate = __isDate;
    function __isArray(o) {
      return typeof o === "object" && __objToStr(o) === "[object Array]";
    }
    clone4.__isArray = __isArray;
    function __isRegExp(o) {
      return typeof o === "object" && __objToStr(o) === "[object RegExp]";
    }
    clone4.__isRegExp = __isRegExp;
    function __getRegExpFlags(re) {
      var flags = "";
      if (re.global)
        flags += "g";
      if (re.ignoreCase)
        flags += "i";
      if (re.multiline)
        flags += "m";
      return flags;
    }
    clone4.__getRegExpFlags = __getRegExpFlags;
    return clone4;
  }();
  if (module2.exports) {
    module2.exports = clone3;
  }
})(clone$4);
var cloneExports = clone$4.exports;
const clone$3 = /* @__PURE__ */ getDefaultExportFromCjs(cloneExports);
function _createForOfIteratorHelper$4(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i2 = 0;
      var F2 = function F3() {
      };
      return { s: F2, n: function n2() {
        if (i2 >= o.length)
          return { done: true };
        return { done: false, value: o[i2++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F2 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it = it.call(o);
  }, n: function n2() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f2() {
    try {
      if (!normalCompletion && it["return"] != null)
        it["return"]();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray$4(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$4(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$4(o, minLen);
}
function _arrayLikeToArray$4(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
function ownKeys$u(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$u(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$u(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$u(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var extendConfig$1 = function extendConfig(config2, configId) {
  if (config2.__configId) {
    return config2;
  }
  config2 = _objectSpread$u({}, config2);
  config2.settings = merge$2({}, settings$4, config2.settings);
  config2._fieldsCntByType = {};
  config2._funcsCntByType = {};
  config2.types = clone$3(config2.types);
  _extendTypesConfig(config2.types, config2);
  config2.fields = clone$3(config2.fields);
  config2.__fieldNames = {};
  _extendFieldsConfig(config2.fields, config2);
  config2.funcs = clone$3(config2.funcs);
  _extendFuncArgsConfig(config2.funcs, config2);
  hooks.locale(config2.settings.locale.moment);
  Object.defineProperty(config2, "__configId", {
    enumerable: false,
    writable: false,
    value: configId || uuid$1()
  });
  return config2;
};
function _extendTypesConfig(typesConfig, config2) {
  for (var type2 in typesConfig) {
    var typeConfig = typesConfig[type2];
    _extendTypeConfig(type2, typeConfig, config2);
  }
}
function _extendTypeConfig(type2, typeConfig, config2) {
  var operators2 = null, defaultOperator3 = null;
  typeConfig.mainWidget = typeConfig.mainWidget || Object.keys(typeConfig.widgets).filter(function(w2) {
    return w2 != "field" && w2 != "func";
  })[0];
  for (var widget in typeConfig.widgets) {
    var typeWidgetConfig = typeConfig.widgets[widget];
    if (typeWidgetConfig.operators) {
      var typeWidgetOperators = typeWidgetConfig.operators;
      if (typeConfig.excludeOperators) {
        typeWidgetOperators = typeWidgetOperators.filter(function(op) {
          return !typeConfig.excludeOperators.includes(op);
        });
      }
      operators2 = mergeArraysSmart(operators2, typeWidgetOperators);
    }
    if (typeWidgetConfig.defaultOperator)
      defaultOperator3 = typeWidgetConfig.defaultOperator;
    if (widget == typeConfig.mainWidget) {
      typeWidgetConfig = merge$2({}, {
        widgetProps: typeConfig.mainWidgetProps || {}
      }, typeWidgetConfig);
    }
    typeConfig.widgets[widget] = typeWidgetConfig;
  }
  if (!typeConfig.valueSources)
    typeConfig.valueSources = Object.keys(config2.settings.valueSourcesInfo);
  var _iterator = _createForOfIteratorHelper$4(typeConfig.valueSources), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var valueSrc = _step.value;
      if (valueSrc != "value" && !typeConfig.widgets[valueSrc]) {
        typeConfig.widgets[valueSrc] = {};
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (!typeConfig.operators && operators2)
    typeConfig.operators = Array.from(new Set(operators2));
  if (!typeConfig.defaultOperator && defaultOperator3)
    typeConfig.defaultOperator = defaultOperator3;
}
function _extendFieldsConfig(subconfig, config2) {
  var path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  for (var field in subconfig) {
    _extendFieldConfig(subconfig[field], config2, [].concat(_toConsumableArray(path), [field]));
    if (subconfig[field].subfields) {
      _extendFieldsConfig(subconfig[field].subfields, config2, [].concat(_toConsumableArray(path), [field]));
    }
  }
}
function _extendFuncArgsConfig(subconfig, config2) {
  if (!subconfig)
    return;
  for (var funcKey in subconfig) {
    var funcDef = subconfig[funcKey];
    if (funcDef.returnType) {
      if (!config2._funcsCntByType[funcDef.returnType])
        config2._funcsCntByType[funcDef.returnType] = 0;
      config2._funcsCntByType[funcDef.returnType]++;
    }
    for (var argKey in funcDef.args) {
      _extendFieldConfig(funcDef.args[argKey], config2, null, true);
    }
    if (funcDef.args) {
      var argKeys = Object.keys(funcDef.args);
      var tmpIsOptional = true;
      var _iterator2 = _createForOfIteratorHelper$4(argKeys.reverse()), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var _argKey = _step2.value;
          var argDef = funcDef.args[_argKey];
          if (!tmpIsOptional && argDef.isOptional) {
            delete argDef.isOptional;
          }
          if (!argDef.isOptional)
            tmpIsOptional = false;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
    if (funcDef.subfields) {
      _extendFuncArgsConfig(funcDef.subfields, config2);
    }
  }
}
function _extendFieldConfig(fieldConfig, config2) {
  var path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  var isFuncArg = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var operators2 = null, defaultOperator3 = null;
  var typeConfig = config2.types[fieldConfig.type];
  var excludeOperatorsForField = fieldConfig.excludeOperators || [];
  if (fieldConfig.type != "!struct" && fieldConfig.type != "!group") {
    var keysToPutInFieldSettings = ["listValues", "treeValues", "allowCustomValues", "validateValue"];
    if (!fieldConfig.fieldSettings)
      fieldConfig.fieldSettings = {};
    for (var _i = 0, _keysToPutInFieldSett = keysToPutInFieldSettings; _i < _keysToPutInFieldSett.length; _i++) {
      var k2 = _keysToPutInFieldSett[_i];
      if (fieldConfig[k2]) {
        fieldConfig.fieldSettings[k2] = fieldConfig[k2];
        delete fieldConfig[k2];
      }
    }
    if (fieldConfig.fieldSettings.listValues) {
      if (config2.settings.normalizeListValues) {
        fieldConfig.fieldSettings.listValues = config2.settings.normalizeListValues(fieldConfig.fieldSettings.listValues, fieldConfig.type, fieldConfig.fieldSettings);
      }
    }
    if (fieldConfig.fieldSettings.treeValues) {
      if (config2.settings.normalizeListValues) {
        fieldConfig.fieldSettings.treeValues = config2.settings.normalizeListValues(fieldConfig.fieldSettings.treeValues, fieldConfig.type, fieldConfig.fieldSettings);
      }
    }
    if (!typeConfig) {
      fieldConfig.disabled = true;
      return;
    }
    if (!isFuncArg) {
      if (!config2._fieldsCntByType[fieldConfig.type])
        config2._fieldsCntByType[fieldConfig.type] = 0;
      config2._fieldsCntByType[fieldConfig.type]++;
    }
    if (!fieldConfig.widgets)
      fieldConfig.widgets = {};
    if (isFuncArg)
      fieldConfig._isFuncArg = true;
    fieldConfig.mainWidget = fieldConfig.mainWidget || typeConfig.mainWidget;
    fieldConfig.valueSources = fieldConfig.valueSources || typeConfig.valueSources;
    var excludeOperatorsForType = typeConfig.excludeOperators || [];
    var _loop = function _loop4() {
      var fieldWidgetConfig = fieldConfig.widgets[widget] || {};
      var typeWidgetConfig = typeConfig.widgets[widget] || {};
      if (!isFuncArg) {
        var excludeOperators = [].concat(_toConsumableArray(excludeOperatorsForField), _toConsumableArray(excludeOperatorsForType));
        var shouldIncludeOperators = fieldConfig.preferWidgets && (widget == "field" || fieldConfig.preferWidgets.includes(widget)) || excludeOperators.length > 0;
        if (fieldWidgetConfig.operators) {
          var addOperators = fieldWidgetConfig.operators.filter(function(o) {
            return !excludeOperators.includes(o);
          });
          operators2 = [].concat(_toConsumableArray(operators2 || []), _toConsumableArray(addOperators));
        } else if (shouldIncludeOperators && typeWidgetConfig.operators) {
          var _addOperators = typeWidgetConfig.operators.filter(function(o) {
            return !excludeOperators.includes(o);
          });
          operators2 = [].concat(_toConsumableArray(operators2 || []), _toConsumableArray(_addOperators));
        }
        if (fieldWidgetConfig.defaultOperator)
          defaultOperator3 = fieldWidgetConfig.defaultOperator;
      }
      if (widget == fieldConfig.mainWidget) {
        fieldWidgetConfig = merge$2({}, {
          widgetProps: fieldConfig.mainWidgetProps || {}
        }, fieldWidgetConfig);
      }
      fieldConfig.widgets[widget] = fieldWidgetConfig;
    };
    for (var widget in typeConfig.widgets) {
      _loop();
    }
    if (!isFuncArg) {
      if (!fieldConfig.operators && operators2)
        fieldConfig.operators = Array.from(new Set(operators2));
      if (!fieldConfig.defaultOperator && defaultOperator3)
        fieldConfig.defaultOperator = defaultOperator3;
    }
  }
  var computedFieldName = computeFieldName(config2, path);
  if (computedFieldName) {
    fieldConfig.fieldName = computedFieldName;
  }
  if (path && fieldConfig.fieldName) {
    config2.__fieldNames[fieldConfig.fieldName] = path;
  }
}
var getFieldRawConfig = function getFieldRawConfig2(config2, field) {
  var fieldsKey = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "fields";
  var subfieldsKey = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "subfields";
  if (!field)
    return null;
  if (field == "!case_value") {
    return {
      type: "case_value",
      mainWidget: "case_value",
      widgets: {
        "case_value": config2.widgets["case_value"]
      }
    };
  }
  var fieldSeparator = config2.settings.fieldSeparator;
  var parts = Array.isArray(field) ? field : field.split(fieldSeparator);
  var targetFields = config2[fieldsKey];
  if (!targetFields)
    return null;
  var fields = targetFields;
  var fieldConfig = null;
  var path = [];
  for (var i2 = 0; i2 < parts.length; i2++) {
    var part = parts[i2];
    path.push(part);
    var pathKey = path.join(fieldSeparator);
    fieldConfig = fields[pathKey];
    if (i2 < parts.length - 1) {
      if (fieldConfig && fieldConfig[subfieldsKey]) {
        fields = fieldConfig[subfieldsKey];
        path = [];
      } else {
        fieldConfig = null;
      }
    }
  }
  return fieldConfig;
};
var computeFieldName = function computeFieldName2(config2, path) {
  if (!path)
    return null;
  var fieldSeparator = config2.settings.fieldSeparator;
  var l2 = _toConsumableArray(path), r2 = [], f2, fConfig;
  while ((f2 = l2.pop()) !== void 0 && l2.length > 0) {
    r2.unshift(f2);
    fConfig = getFieldRawConfig(config2, l2);
    if (fConfig.fieldName) {
      return [fConfig.fieldName].concat(r2).join(fieldSeparator);
    }
  }
  return null;
};
var normalizeField = function normalizeField2(config2, field) {
  var fieldSeparator = config2.settings.fieldSeparator;
  var fieldStr = Array.isArray(field) ? field.join(fieldSeparator) : field;
  if (config2.__fieldNames[fieldStr]) {
    return config2.__fieldNames[fieldStr].join(fieldSeparator);
  }
  return fieldStr;
};
var getFuncConfig$2 = function getFuncConfig(config2, func) {
  if (!func)
    return null;
  var funcConfig = getFieldRawConfig(config2, func, "funcs", "subfields");
  if (!funcConfig)
    return null;
  return funcConfig;
};
var getFuncArgConfig = function getFuncArgConfig2(config2, funcKey, argKey) {
  var funcConfig = getFuncConfig$2(config2, funcKey);
  if (!funcConfig)
    return null;
  var argConfig = funcConfig.args && funcConfig.args[argKey] || null;
  if (!argConfig)
    return null;
  var typeConfig = config2.types[argConfig.type] || {};
  var ret = mergeWith$1({}, typeConfig, argConfig || {}, function(objValue, srcValue, _key, _object, _source, _stack) {
    if (Array.isArray(objValue)) {
      return srcValue;
    }
  });
  return ret;
};
var getFieldConfig$8 = function getFieldConfig(config2, field) {
  if (!field)
    return null;
  if (_typeof$2(field) == "object" && !field.func && !!field.type)
    return field;
  if (_typeof$2(field) == "object" && field.func && field.arg)
    return getFuncArgConfig(config2, field.func, field.arg);
  var fieldConfig = getFieldRawConfig(config2, field);
  if (!fieldConfig)
    return null;
  var typeConfig = config2.types[fieldConfig.type] || {};
  var ret = mergeWith$1({}, typeConfig, fieldConfig || {}, function(objValue, srcValue, _key, _object, _source, _stack) {
    if (Array.isArray(objValue)) {
      return srcValue;
    }
  });
  return ret;
};
var getOperatorConfig$4 = function getOperatorConfig(config2, operator) {
  var field = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  if (!operator)
    return null;
  var opConfig = config2.operators[operator];
  if (field) {
    var fieldConfig = getFieldConfig$8(config2, field);
    var widget = getWidgetForFieldOp$3(config2, field, operator);
    var widgetConfig = config2.widgets[widget] || {};
    var fieldWidgetConfig = (fieldConfig && fieldConfig.widgets ? fieldConfig.widgets[widget] : {}) || {};
    var widgetOpProps = (widgetConfig.opProps || {})[operator];
    var fieldWidgetOpProps = (fieldWidgetConfig.opProps || {})[operator];
    var mergedOpConfig = merge$2({}, opConfig, widgetOpProps, fieldWidgetOpProps);
    return mergedOpConfig;
  } else {
    return opConfig;
  }
};
var getFieldWidgetConfig$3 = function getFieldWidgetConfig(config2, field, operator) {
  var widget = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var valueSrc = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
  if (!field)
    return null;
  if (!(operator || widget) && valueSrc != "const" && field != "!case_value")
    return null;
  var fieldConfig = getFieldConfig$8(config2, field);
  if (!widget)
    widget = getWidgetForFieldOp$3(config2, field, operator, valueSrc);
  var widgetConfig = config2.widgets[widget] || {};
  var fieldWidgetConfig = (fieldConfig && fieldConfig.widgets ? fieldConfig.widgets[widget] : {}) || {};
  var fieldWidgetProps = fieldWidgetConfig.widgetProps || {};
  var valueFieldSettings = (valueSrc == "value" || !valueSrc) && fieldConfig && fieldConfig.fieldSettings || {};
  var mergedConfig = merge$2({}, widgetConfig, fieldWidgetProps, valueFieldSettings);
  return mergedConfig;
};
const configUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  extendConfig: extendConfig$1,
  getFieldConfig: getFieldConfig$8,
  getFieldRawConfig,
  getFieldWidgetConfig: getFieldWidgetConfig$3,
  getFuncArgConfig,
  getFuncConfig: getFuncConfig$2,
  getOperatorConfig: getOperatorConfig$4,
  normalizeField
}, Symbol.toStringTag, { value: "Module" }));
var isObject$4 = function isObject2(v2) {
  return _typeof$2(v2) == "object" && v2 !== null && !Array.isArray(v2);
};
var completeValue = function completeValue2(value, valueSrc, config2) {
  if (valueSrc == "func")
    return completeFuncValue(value, config2);
  else
    return value;
};
var completeFuncValue = function completeFuncValue2(value, config2) {
  var _checkFuncValue = function _checkFuncValue2(value2) {
    if (!value2)
      return void 0;
    var funcKey = value2.get("func");
    var funcConfig = funcKey && getFuncConfig$2(config2, funcKey);
    if (!funcConfig)
      return void 0;
    var complValue = value2;
    var tmpHasOptional = false;
    for (var argKey in funcConfig.args) {
      var argConfig = funcConfig.args[argKey];
      var valueSources = argConfig.valueSources, isOptional = argConfig.isOptional, defaultValue4 = argConfig.defaultValue;
      var filteredValueSources = filterValueSourcesForField(config2, valueSources, argConfig);
      var args = complValue.get("args");
      var argDefaultValueSrc = filteredValueSources.length == 1 ? filteredValueSources[0] : void 0;
      var argVal = args ? args.get(argKey) : void 0;
      var argValue = argVal ? argVal.get("value") : void 0;
      var argValueSrc = (argVal ? argVal.get("valueSrc") : void 0) || argDefaultValueSrc;
      if (argValue !== void 0) {
        var completeArgValue = completeValue(argValue, argValueSrc, config2);
        if (completeArgValue === void 0) {
          return void 0;
        } else if (completeArgValue !== argValue) {
          complValue = complValue.setIn(["args", argKey, "value"], completeArgValue);
        }
        if (tmpHasOptional) {
          return void 0;
        }
      } else if (defaultValue4 !== void 0 && !isObject$4(defaultValue4)) {
        complValue = complValue.setIn(["args", argKey, "value"], getDefaultArgValue(argConfig));
        complValue = complValue.setIn(["args", argKey, "valueSrc"], "value");
      } else if (isOptional) {
        tmpHasOptional = true;
      } else {
        return void 0;
      }
    }
    return complValue;
  };
  return _checkFuncValue(value);
};
var setFunc$1 = function setFunc(value, funcKey, config2) {
  var fieldSeparator = config2.settings.fieldSeparator;
  value = value || new Immutable.Map();
  if (Array.isArray(funcKey)) {
    funcKey = funcKey.join(fieldSeparator);
  }
  value = value.set("func", funcKey);
  value = value.set("args", new Immutable.Map());
  var funcConfig = funcKey && getFuncConfig$2(config2, funcKey);
  if (funcConfig) {
    for (var argKey in funcConfig.args) {
      var argConfig = funcConfig.args[argKey];
      var valueSources = argConfig.valueSources, defaultValue4 = argConfig.defaultValue;
      var filteredValueSources = filterValueSourcesForField(config2, valueSources, argConfig);
      var firstValueSrc = filteredValueSources.length ? filteredValueSources[0] : void 0;
      var defaultValueSrc = defaultValue4 ? isObject$4(defaultValue4) && !!defaultValue4.func ? "func" : "value" : void 0;
      var argDefaultValueSrc = defaultValueSrc || firstValueSrc;
      if (defaultValue4 !== void 0) {
        value = value.setIn(["args", argKey, "value"], getDefaultArgValue(argConfig));
      }
      if (argDefaultValueSrc) {
        value = value.setIn(["args", argKey, "valueSrc"], argDefaultValueSrc);
      }
    }
  }
  return value;
};
var getDefaultArgValue = function getDefaultArgValue2(_ref) {
  var value = _ref.defaultValue;
  if (isObject$4(value) && !Immutable.Map.isMap(value) && value.func) {
    return Immutable.fromJS(value, function(k2, v2) {
      return Immutable.Iterable.isIndexed(v2) ? v2.toList() : v2.toOrderedMap();
    });
  }
  return value;
};
var setArgValue$1 = function setArgValue(value, argKey, argVal, argConfig, config2) {
  if (value && value.get("func")) {
    value = value.setIn(["args", argKey, "value"], argVal);
    var valueSources = argConfig.valueSources;
    var filteredValueSources = filterValueSourcesForField(config2, valueSources, argConfig);
    var argDefaultValueSrc = filteredValueSources.length == 1 ? filteredValueSources[0] : void 0;
    if (argDefaultValueSrc) {
      value = value.setIn(["args", argKey, "valueSrc"], argDefaultValueSrc);
    }
  }
  return value;
};
var setArgValueSrc$1 = function setArgValueSrc(value, argKey, argValSrc, _argConfig, _config) {
  if (value && value.get("func")) {
    value = value.setIn(["args", argKey], new Immutable.Map({
      valueSrc: argValSrc
    }));
  }
  return value;
};
const funcUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  completeFuncValue,
  completeValue,
  setArgValue: setArgValue$1,
  setArgValueSrc: setArgValueSrc$1,
  setFunc: setFunc$1
}, Symbol.toStringTag, { value: "Module" }));
function ownKeys$t(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$t(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$t(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$t(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var queryBuilderFormat = function queryBuilderFormat2(item, config2) {
  var meta = {
    usedFields: []
  };
  var res = formatItem$5(item, config2, meta);
  if (!res)
    return void 0;
  return _objectSpread$t(_objectSpread$t({}, res), meta);
};
var formatItem$5 = function formatItem(item, config2, meta) {
  if (!item)
    return void 0;
  var type2 = item.get("type");
  var children = item.get("children1");
  if ((type2 === "group" || type2 === "rule_group") && children && children.size) {
    return formatGroup$5(item, config2, meta);
  } else if (type2 === "rule") {
    return formatRule$5(item, config2, meta);
  }
  return void 0;
};
var formatGroup$5 = function formatGroup(item, config2, meta) {
  var properties = item.get("properties") || new immutableExports.Map();
  var children = item.get("children1");
  var id = item.get("id");
  var list2 = children.map(function(currentChild) {
    return formatItem$5(currentChild, config2, meta);
  }).filter(function(currentChild) {
    return typeof currentChild !== "undefined";
  });
  if (!list2.size)
    return void 0;
  var conjunction = properties.get("conjunction");
  if (!conjunction)
    conjunction = defaultConjunction(config2);
  var not = properties.get("not");
  var resultQuery = {
    id,
    rules: list2.toList(),
    condition: conjunction.toUpperCase(),
    not
  };
  return resultQuery;
};
var formatRule$5 = function formatRule(item, config2, meta) {
  var properties = item.get("properties") || new immutableExports.Map();
  var id = item.get("id");
  var operator = properties.get("operator");
  var options = properties.get("operatorOptions");
  var field = properties.get("field");
  var value = properties.get("value");
  var valueSrc = properties.get("valueSrc");
  var valueType = properties.get("valueType");
  var hasUndefinedValues = value.filter(function(v2) {
    return v2 === void 0;
  }).size > 0;
  if (field == null || operator == null || hasUndefinedValues)
    return void 0;
  var fieldDefinition = getFieldConfig$8(config2, field) || {};
  var operatorDefinition = getOperatorConfig$4(config2, operator, field) || {};
  var fieldType = fieldDefinition.type || "undefined";
  var cardinality = defaultValue$1(operatorDefinition.cardinality, 1);
  var typeConfig = config2.types[fieldDefinition.type] || {};
  var fieldName = formatFieldName$1(field, config2, meta);
  if (value.size < cardinality)
    return void 0;
  if (meta.usedFields.indexOf(field) == -1)
    meta.usedFields.push(field);
  value = value.toArray();
  valueSrc = valueSrc.toArray();
  valueType = valueType.toArray();
  var values = [];
  for (var i2 = 0; i2 < value.length; i2++) {
    var val = {
      type: valueType[i2],
      value: value[i2]
    };
    values.push(val);
    if (valueSrc[i2] == "field") {
      var secondField = value[i2];
      if (meta.usedFields.indexOf(secondField) == -1)
        meta.usedFields.push(secondField);
    }
  }
  var operatorOptions = options ? options.toJS() : null;
  if (operatorOptions && !Object.keys(operatorOptions).length)
    operatorOptions = null;
  var ruleQuery = {
    id,
    fieldName,
    type: fieldType,
    input: typeConfig.mainWidget,
    operator
  };
  if (operatorOptions)
    ruleQuery.operatorOptions = operatorOptions;
  ruleQuery.values = values;
  return ruleQuery;
};
var assignValue = _assignValue, castPath$1 = _castPath, isIndex = _isIndex, isObject$3 = isObject_1, toKey = _toKey;
function baseSet$1(object, path, value, customizer) {
  if (!isObject$3(object)) {
    return object;
  }
  path = castPath$1(path, object);
  var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index2 < length) {
    var key = toKey(path[index2]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index2 != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject$3(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var _baseSet = baseSet$1;
var baseGet = _baseGet, baseSet = _baseSet, castPath = _castPath;
function basePickBy$2(object, paths, predicate) {
  var index2 = -1, length = paths.length, result = {};
  while (++index2 < length) {
    var path = paths[index2], value = baseGet(object, path);
    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}
var _basePickBy = basePickBy$2;
var basePickBy$1 = _basePickBy, hasIn = hasIn_1;
function basePick$1(object, paths) {
  return basePickBy$1(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}
var _basePick = basePick$1;
var basePick = _basePick, flatRest = _flatRest;
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});
var pick_1 = pick;
const pick$1 = /* @__PURE__ */ getDefaultExportFromCjs(pick_1);
function ownKeys$s(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$s(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$s(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$s(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createForOfIteratorHelper$3(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i2 = 0;
      var F2 = function F3() {
      };
      return { s: F2, n: function n2() {
        if (i2 >= o.length)
          return { done: true };
        return { done: false, value: o[i2++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F2 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it = it.call(o);
  }, n: function n2() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f2() {
    try {
      if (!normalCompletion && it["return"] != null)
        it["return"]();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray$3(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$3(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$3(o, minLen);
}
function _arrayLikeToArray$3(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
var jsonLogicFormat = function jsonLogicFormat2(item, config2) {
  var meta = {
    usedFields: [],
    errors: []
  };
  var logic = formatItem$4(item, config2, meta, true);
  var errors = meta.errors, usedFields = meta.usedFields;
  var fieldSeparator = config2.settings.fieldSeparator;
  var data = {};
  var _iterator = _createForOfIteratorHelper$3(usedFields), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var ff = _step.value;
      var def = getFieldConfig$8(config2, ff) || {};
      var parts = ff.split(fieldSeparator);
      var tmp = data;
      for (var i2 = 0; i2 < parts.length; i2++) {
        var p2 = parts[i2];
        var pdef = getFieldConfig$8(config2, parts.slice(0, i2 + 1)) || {};
        if (i2 != parts.length - 1) {
          if (pdef.type == "!group" && pdef.mode != "struct") {
            if (!tmp[p2])
              tmp[p2] = [{}];
            tmp = tmp[p2][0];
          } else {
            if (!tmp[p2])
              tmp[p2] = {};
            tmp = tmp[p2];
          }
        } else {
          if (!tmp[p2])
            tmp[p2] = null;
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return {
    errors,
    logic,
    data
  };
};
var formatItem$4 = function formatItem2(item, config2, meta, isRoot) {
  var parentField = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
  if (!item)
    return void 0;
  var type2 = item.get("type");
  var properties = item.get("properties") || new immutableExports.Map();
  var isLocked = properties.get("isLocked");
  var lockedOp = config2.settings.jsonLogic.lockedOp;
  var ret;
  if (type2 === "group" || type2 === "rule_group") {
    ret = formatGroup$4(item, config2, meta, isRoot, parentField);
  } else if (type2 === "rule") {
    ret = formatRule$4(item, config2, meta, parentField);
  }
  if (isLocked && ret && lockedOp) {
    ret = _defineProperty$4({}, lockedOp, ret);
  }
  return ret;
};
var formatGroup$4 = function formatGroup2(item, config2, meta, isRoot) {
  var parentField = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
  var type2 = item.get("type");
  var properties = item.get("properties") || new immutableExports.Map();
  var mode = properties.get("mode");
  var children = item.get("children1") || new immutableExports.List();
  var field = properties.get("field");
  var conjunction = properties.get("conjunction");
  if (!conjunction)
    conjunction = defaultConjunction(config2);
  var conjunctionDefinition = config2.conjunctions[conjunction];
  var conj = conjunctionDefinition.jsonLogicConj || conjunction.toLowerCase();
  var not = properties.get("not");
  if (conj != "and" && conj != "or") {
    meta.errors.push("Conjunction ".concat(conj, " is not supported"));
    return void 0;
  }
  var isRuleGroup = type2 === "rule_group" && !isRoot;
  var groupField = isRuleGroup && mode != "struct" ? field : parentField;
  var groupOperator = properties.get("operator");
  var groupOperatorDefinition = groupOperator && getOperatorConfig$4(config2, groupOperator, field) || null;
  var formattedValue = formatItemValue$2(config2, properties, meta, groupOperator, parentField);
  var isGroup0 = isRuleGroup && (!groupOperator || groupOperatorDefinition.cardinality == 0);
  var list2 = children.map(function(currentChild) {
    return formatItem$4(currentChild, config2, meta, false, groupField);
  }).filter(function(currentChild) {
    return typeof currentChild !== "undefined";
  });
  if (isRuleGroup && mode != "struct" && !isGroup0) {
    if (formattedValue == void 0)
      return void 0;
  } else {
    if (!list2.size)
      return void 0;
  }
  var resultQuery = {};
  if (list2.size == 1 && !isRoot)
    resultQuery = list2.first();
  else
    resultQuery[conj] = list2.toList().toJS();
  if (not) {
    resultQuery = {
      "!": resultQuery
    };
  }
  if (isRuleGroup && mode != "struct") {
    var formattedField = formatField$3(meta, config2, field, parentField);
    if (isGroup0) {
      var op = groupOperator || "some";
      resultQuery = _defineProperty$4({}, op, [formattedField, resultQuery]);
    } else {
      var filter = !list2.size ? formattedField : {
        "filter": [formattedField, resultQuery]
      };
      var count = {
        "reduce": [filter, {
          "+": [1, {
            "var": "accumulator"
          }]
        }, 0]
      };
      resultQuery = formatLogic(config2, properties, count, formattedValue, groupOperator);
    }
  }
  return resultQuery;
};
var formatRule$4 = function formatRule2(item, config2, meta) {
  var parentField = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var properties = item.get("properties") || new immutableExports.Map();
  var field = properties.get("field");
  var operator = properties.get("operator");
  var operatorOptions = properties.get("operatorOptions");
  operatorOptions = operatorOptions ? operatorOptions.toJS() : null;
  if (operatorOptions && !Object.keys(operatorOptions).length)
    operatorOptions = null;
  if (field == null || operator == null)
    return void 0;
  var fieldDefinition = getFieldConfig$8(config2, field) || {};
  var operatorDefinition = getOperatorConfig$4(config2, operator, field) || {};
  var reversedOp = operatorDefinition.reversedOp;
  var revOperatorDefinition = getOperatorConfig$4(config2, reversedOp, field) || {};
  var isRev = false;
  if (!operatorDefinition.jsonLogic && !revOperatorDefinition.jsonLogic) {
    meta.errors.push("Operator ".concat(operator, " is not supported"));
    return void 0;
  }
  if (!operatorDefinition.jsonLogic && revOperatorDefinition.jsonLogic) {
    isRev = true;
    var _ref = [reversedOp, operator];
    operator = _ref[0];
    reversedOp = _ref[1];
    var _ref2 = [revOperatorDefinition, operatorDefinition];
    operatorDefinition = _ref2[0];
    revOperatorDefinition = _ref2[1];
  }
  var formattedValue = formatItemValue$2(config2, properties, meta, operator, parentField);
  if (formattedValue === void 0)
    return void 0;
  var formattedField = formatField$3(meta, config2, field, parentField);
  return formatLogic(config2, properties, formattedField, formattedValue, operator, operatorOptions, fieldDefinition, isRev);
};
var formatItemValue$2 = function formatItemValue(config2, properties, meta, operator, parentField) {
  var field = properties.get("field");
  var iValueSrc = properties.get("valueSrc");
  var iValueType = properties.get("valueType");
  var fieldDefinition = getFieldConfig$8(config2, field) || {};
  var operatorDefinition = getOperatorConfig$4(config2, operator, field) || {};
  var cardinality = defaultValue$1(operatorDefinition.cardinality, 1);
  var iValue = properties.get("value");
  var asyncListValues = properties.get("asyncListValues");
  if (iValue == void 0)
    return void 0;
  var oldUsedFields = meta.usedFields;
  var fvalue = iValue.map(function(currentValue, ind) {
    var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;
    var valueType = iValueType ? iValueType.get(ind) : null;
    var cValue = completeValue(currentValue, valueSrc, config2);
    var widget = getWidgetForFieldOp$3(config2, field, operator, valueSrc);
    var fieldWidgetDef = omit$1(getFieldWidgetConfig$3(config2, field, operator, widget, valueSrc), ["factory"]);
    var fv = formatValue$4(meta, config2, cValue, valueSrc, valueType, fieldWidgetDef, fieldDefinition, operator, operatorDefinition, parentField, asyncListValues);
    return fv;
  });
  var hasUndefinedValues = fvalue.filter(function(v2) {
    return v2 === void 0;
  }).size > 0;
  if (fvalue.size < cardinality || hasUndefinedValues) {
    meta.usedFields = oldUsedFields;
    return void 0;
  }
  return cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;
};
var formatValue$4 = function formatValue(meta, config2, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef) {
  var parentField = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : null;
  var asyncListValues = arguments.length > 10 ? arguments[10] : void 0;
  if (currentValue === void 0)
    return void 0;
  var ret;
  if (valueSrc == "field") {
    ret = formatField$3(meta, config2, currentValue, parentField);
  } else if (valueSrc == "func") {
    ret = formatFunc$4(meta, config2, currentValue, parentField);
  } else if (typeof fieldWidgetDef.jsonLogic === "function") {
    var fn = fieldWidgetDef.jsonLogic;
    var args = [
      currentValue,
      _objectSpread$s(_objectSpread$s({}, pick$1(fieldDef, ["fieldSettings", "listValues"])), {}, {
        asyncListValues
      }),
      //useful options: valueFormat for date/time
      omit$1(fieldWidgetDef, ["formatValue", "mongoFormatValue", "sqlFormatValue", "jsonLogic", "elasticSearchFormatValue", "spelFormatValue"])
    ];
    if (operator) {
      args.push(operator);
      args.push(operatorDef);
    }
    ret = fn.apply(void 0, args);
  } else {
    ret = currentValue;
  }
  return ret;
};
var formatFunc$4 = function formatFunc(meta, config2, currentValue) {
  var parentField = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var funcKey = currentValue.get("func");
  var args = currentValue.get("args");
  var funcConfig = getFuncConfig$2(config2, funcKey);
  if (!funcConfig.jsonLogic) {
    meta.errors.push("Func ".concat(funcKey, " is not supported"));
    return void 0;
  }
  var formattedArgs = {};
  for (var argKey in funcConfig.args) {
    var argConfig = funcConfig.args[argKey];
    var fieldDef = getFieldConfig$8(config2, argConfig);
    var argVal = args ? args.get(argKey) : void 0;
    var argValue = argVal ? argVal.get("value") : void 0;
    var argValueSrc = argVal ? argVal.get("valueSrc") : void 0;
    var formattedArgVal = formatValue$4(meta, config2, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, parentField);
    if (argValue != void 0 && formattedArgVal === void 0) {
      meta.errors.push("Can't format value of arg ".concat(argKey, " for func ").concat(funcKey));
      return void 0;
    }
    if (formattedArgVal !== void 0) {
      formattedArgs[argKey] = formattedArgVal;
    }
  }
  var formattedArgsArr = Object.values(formattedArgs);
  var ret;
  if (typeof funcConfig.jsonLogic === "function") {
    var fn = funcConfig.jsonLogic;
    var _args = [formattedArgs];
    ret = fn.apply(void 0, _args);
  } else {
    var funcName = funcConfig.jsonLogic || funcKey;
    var isMethod = !!funcConfig.jsonLogicIsMethod;
    if (isMethod) {
      var obj = formattedArgsArr[0], params = formattedArgsArr.slice(1);
      if (params.length) {
        ret = {
          "method": [obj, funcName, params]
        };
      } else {
        ret = {
          "method": [obj, funcName]
        };
      }
    } else {
      ret = _defineProperty$4({}, funcName, formattedArgsArr);
    }
  }
  return ret;
};
var formatField$3 = function formatField2(meta, config2, field) {
  var parentField = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var _config$settings = config2.settings, fieldSeparator = _config$settings.fieldSeparator, jsonLogic6 = _config$settings.jsonLogic;
  var ret;
  if (field) {
    if (Array.isArray(field))
      field = field.join(fieldSeparator);
    var fieldDef = getFieldConfig$8(config2, field) || {};
    var fieldName = field;
    if (fieldDef.fieldName) {
      fieldName = fieldDef.fieldName;
    }
    if (parentField) {
      var parentFieldDef = getFieldConfig$8(config2, parentField) || {};
      var parentFieldName = parentField;
      if (parentFieldDef.fieldName) {
        parentFieldName = parentFieldDef.fieldName;
      }
      if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {
        fieldName = fieldName.slice((parentFieldName + fieldSeparator).length);
      } else {
        meta.errors.push("Can't cut group ".concat(parentFieldName, " from field ").concat(fieldName));
      }
    }
    var varName = fieldDef.jsonLogicVar || (fieldDef.type == "!group" ? jsonLogic6.groupVarKey : "var");
    ret = _defineProperty$4({}, varName, fieldName);
    if (meta.usedFields.indexOf(field) == -1)
      meta.usedFields.push(field);
  }
  return ret;
};
var buildFnToFormatOp$3 = function buildFnToFormatOp(operator, operatorDefinition, formattedField, formattedValue) {
  var formatteOp = operator;
  var cardinality = defaultValue$1(operatorDefinition.cardinality, 1);
  var isReverseArgs = defaultValue$1(operatorDefinition._jsonLogicIsRevArgs, false);
  if (typeof operatorDefinition.jsonLogic == "string")
    formatteOp = operatorDefinition.jsonLogic;
  var rangeOps = ["<", "<=", ">", ">="];
  var eqOps = ["==", "!="];
  var fn = function fn2(field, op, val, opDef, opOpts) {
    if (cardinality == 0 && eqOps.includes(formatteOp))
      return _defineProperty$4({}, formatteOp, [formattedField, null]);
    else if (cardinality == 0)
      return _defineProperty$4({}, formatteOp, formattedField);
    else if (cardinality == 1 && isReverseArgs)
      return _defineProperty$4({}, formatteOp, [formattedValue, formattedField]);
    else if (cardinality == 1)
      return _defineProperty$4({}, formatteOp, [formattedField, formattedValue]);
    else if (cardinality == 2 && rangeOps.includes(formatteOp))
      return _defineProperty$4({}, formatteOp, [formattedValue[0], formattedField, formattedValue[1]]);
    else
      return _defineProperty$4({}, formatteOp, [formattedField].concat(_toConsumableArray(formattedValue)));
  };
  return fn;
};
var formatLogic = function formatLogic2(config2, properties, formattedField, formattedValue, operator) {
  var operatorOptions = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null;
  var fieldDefinition = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null;
  var isRev = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false;
  var field = properties.get("field");
  var operatorDefinition = getOperatorConfig$4(config2, operator, field) || {};
  var fn = typeof operatorDefinition.jsonLogic == "function" ? operatorDefinition.jsonLogic : buildFnToFormatOp$3(operator, operatorDefinition, formattedField, formattedValue);
  var args = [formattedField, operator, formattedValue, omit$1(operatorDefinition, ["formatOp", "mongoFormatOp", "sqlFormatOp", "jsonLogic", "spelFormatOp"]), operatorOptions, fieldDefinition];
  var ruleQuery = fn.apply(void 0, args);
  if (isRev) {
    ruleQuery = {
      "!": ruleQuery
    };
  }
  return ruleQuery;
};
function ownKeys$r(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$r(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$r(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$r(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var isObject$2 = function isObject3(v2) {
  return _typeof$2(v2) == "object" && v2 !== null && !Array.isArray(v2);
};
var mongodbFormat = function mongodbFormat2(tree2, config2) {
  return _mongodbFormat(tree2, config2, false);
};
var _mongodbFormat = function _mongodbFormat2(tree2, config2) {
  var returnErrors = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var meta = {
    errors: []
  };
  var res = formatItem$3([], tree2, config2, meta);
  if (returnErrors) {
    return [res, meta.errors];
  } else {
    if (meta.errors.length)
      console.warn("Errors while exporting to MongoDb:", meta.errors);
    return res;
  }
};
var formatItem$3 = function formatItem3(parents2, item, config2, meta) {
  var _not = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  var _canWrapExpr = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
  var _fieldName = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : void 0;
  var _value = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : void 0;
  if (!item)
    return void 0;
  var type2 = item.get("type");
  if (type2 === "group" || type2 === "rule_group") {
    return formatGroup$3(parents2, item, config2, meta, _not, _canWrapExpr, _fieldName, _value);
  } else if (type2 === "rule") {
    return formatRule$3(parents2, item, config2, meta, _not, _canWrapExpr, _fieldName, _value);
  }
  return void 0;
};
var formatGroup$3 = function formatGroup3(parents2, item, config2, meta) {
  var _not = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  var type2 = item.get("type");
  var properties = item.get("properties") || new immutableExports.Map();
  var children = item.get("children1") || new immutableExports.List();
  var canShortMongoQuery = config2.settings.canShortMongoQuery;
  var hasParentRuleGroup = parents2.filter(function(it) {
    return it.get("type") == "rule_group";
  }).length > 0;
  var parentPath = parents2.filter(function(it) {
    return it.get("type") == "rule_group";
  }).map(function(it) {
    return it.get("properties").get("field");
  }).slice(-1).pop();
  var realParentPath = hasParentRuleGroup && parentPath;
  var groupField = type2 === "rule_group" ? properties.get("field") : null;
  var groupFieldName = formatFieldName2(groupField, config2, meta, realParentPath);
  var groupFieldDef = getFieldConfig$8(config2, groupField) || {};
  var mode = groupFieldDef.mode;
  var canHaveEmptyChildren = groupField && mode == "array";
  var not = _not ? !properties.get("not") : properties.get("not");
  var list2 = children.map(function(currentChild) {
    return formatItem$3([].concat(_toConsumableArray(parents2), [item]), currentChild, config2, meta, not, mode != "array", mode == "array" ? function(f2) {
      return "$$el.".concat(f2);
    } : void 0);
  }).filter(function(currentChild) {
    return typeof currentChild !== "undefined";
  });
  if (!canHaveEmptyChildren && !list2.size)
    return void 0;
  var conjunction = properties.get("conjunction");
  if (!conjunction)
    conjunction = defaultConjunction(config2);
  var conjunctionDefinition = config2.conjunctions[conjunction];
  var reversedConj = conjunctionDefinition.reversedConj;
  if (not && reversedConj) {
    conjunction = reversedConj;
    conjunctionDefinition = config2.conjunctions[conjunction];
  }
  var mongoConj = conjunctionDefinition.mongoConj;
  var resultQuery;
  if (list2.size == 1) {
    resultQuery = list2.first();
  } else if (list2.size > 1) {
    var rules = list2.toList().toJS();
    var canShort = canShortMongoQuery && mongoConj == "$and";
    if (canShort) {
      resultQuery = rules.reduce(function(acc, rule3) {
        if (!acc)
          return void 0;
        for (var k2 in rule3) {
          if (k2[0] == "$") {
            acc = void 0;
            break;
          }
          if (acc[k2] == void 0) {
            acc[k2] = rule3[k2];
          } else {
            var prev = acc[k2], next = rule3[k2];
            if (!isObject$2(prev)) {
              prev = {
                "$eq": prev
              };
            }
            if (!isObject$2(next)) {
              next = {
                "$eq": next
              };
            }
            var prevOp = Object.keys(prev)[0], nextOp = Object.keys(next)[0];
            if (prevOp == nextOp) {
              acc = void 0;
              break;
            }
            acc[k2] = Object.assign({}, prev, next);
          }
        }
        return acc;
      }, {});
    }
    if (!resultQuery)
      resultQuery = _defineProperty$4({}, mongoConj, rules);
  }
  if (groupField) {
    if (mode == "array") {
      var totalQuery = {
        "$size": groupFieldName
      };
      var filterQuery = resultQuery ? {
        "$size": {
          "$ifNull": [{
            "$filter": {
              input: "$" + groupFieldName,
              as: "el",
              cond: resultQuery
            }
          }, []]
        }
      } : totalQuery;
      resultQuery = formatItem$3(parents2, item.set("type", "rule"), config2, meta, false, false, function(_f) {
        return filterQuery;
      }, totalQuery);
      resultQuery = {
        "$expr": resultQuery
      };
    } else {
      resultQuery = _defineProperty$4({}, groupFieldName, {
        "$elemMatch": resultQuery
      });
    }
  }
  return resultQuery;
};
var formatRule$3 = function formatRule3(parents2, item, config2, meta) {
  var _not = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  var _canWrapExpr = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
  var _fieldName = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : void 0;
  var _value = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : void 0;
  var properties = item.get("properties") || new immutableExports.Map();
  var hasParentRuleGroup = parents2.filter(function(it) {
    return it.get("type") == "rule_group";
  }).length > 0;
  var parentPath = parents2.filter(function(it) {
    return it.get("type") == "rule_group";
  }).map(function(it) {
    return it.get("properties").get("field");
  }).slice(-1).pop();
  var realParentPath = hasParentRuleGroup && parentPath;
  var operator = properties.get("operator");
  var operatorOptions = properties.get("operatorOptions");
  var field = properties.get("field");
  var iValue = properties.get("value");
  var iValueSrc = properties.get("valueSrc");
  var iValueType = properties.get("valueType");
  var asyncListValues = properties.get("asyncListValues");
  if (field == null || operator == null || iValue === void 0)
    return void 0;
  var fieldDef = getFieldConfig$8(config2, field) || {};
  var operatorDefinition = getOperatorConfig$4(config2, operator, field) || {};
  var reversedOp = operatorDefinition.reversedOp;
  var revOperatorDefinition = getOperatorConfig$4(config2, reversedOp, field) || {};
  var cardinality = defaultValue$1(operatorDefinition.cardinality, 1);
  var not = _not;
  if (not && reversedOp) {
    var _ref = [reversedOp, operator];
    operator = _ref[0];
    reversedOp = _ref[1];
    var _ref2 = [revOperatorDefinition, operatorDefinition];
    operatorDefinition = _ref2[0];
    revOperatorDefinition = _ref2[1];
    not = false;
  }
  var fieldName = formatFieldName2(field, config2, meta, realParentPath);
  var valueSrcs = [];
  var valueTypes = [];
  var useExpr = false;
  var fvalue = iValue.map(function(currentValue, ind) {
    var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;
    var valueType = iValueType ? iValueType.get(ind) : null;
    var cValue = completeValue(currentValue, valueSrc, config2);
    var widget = getWidgetForFieldOp$3(config2, field, operator, valueSrc);
    var fieldWidgetDef = omit$1(getFieldWidgetConfig$3(config2, field, operator, widget, valueSrc), ["factory"]);
    var _formatValue = formatValue$3(meta, config2, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, realParentPath, operator, operatorDefinition, asyncListValues), _formatValue2 = _slicedToArray$1(_formatValue, 2), fv = _formatValue2[0], fvUseExpr = _formatValue2[1];
    if (fv !== void 0) {
      useExpr = useExpr || fvUseExpr;
      valueSrcs.push(valueSrc);
      valueTypes.push(valueType);
    }
    return fv;
  });
  if (_fieldName)
    useExpr = true;
  var wrapExpr = useExpr && _canWrapExpr;
  var hasUndefinedValues = fvalue.filter(function(v2) {
    return v2 === void 0;
  }).size > 0;
  if (fvalue.size < cardinality || hasUndefinedValues)
    return void 0;
  var formattedValue = cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;
  var fn = operatorDefinition.mongoFormatOp;
  if (!fn) {
    meta.errors.push("Operator ".concat(operator, " is not supported"));
    return void 0;
  }
  var args = [_fieldName ? _fieldName(fieldName) : fieldName, operator, _value !== void 0 && formattedValue == null ? _value : formattedValue, useExpr, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0], omit$1(operatorDefinition, ["formatOp", "mongoFormatOp", "sqlFormatOp", "jsonLogic", "spelFormatOp"]), operatorOptions, fieldDef];
  var ruleQuery = fn.apply(void 0, args);
  if (wrapExpr) {
    ruleQuery = {
      "$expr": ruleQuery
    };
  }
  if (not) {
    ruleQuery = {
      "$not": ruleQuery
    };
  }
  return ruleQuery;
};
var formatValue$3 = function formatValue2(meta, config2, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, parentPath, operator, operatorDef, asyncListValues) {
  if (currentValue === void 0)
    return [void 0, false];
  var ret;
  var useExpr = false;
  if (valueSrc == "field") {
    var _formatRightField = formatRightField(meta, config2, currentValue, parentPath);
    var _formatRightField2 = _slicedToArray$1(_formatRightField, 2);
    ret = _formatRightField2[0];
    useExpr = _formatRightField2[1];
  } else if (valueSrc == "func") {
    var _formatFunc = formatFunc$3(meta, config2, currentValue, parentPath);
    var _formatFunc2 = _slicedToArray$1(_formatFunc, 2);
    ret = _formatFunc2[0];
    useExpr = _formatFunc2[1];
  } else {
    if (typeof fieldWidgetDef.mongoFormatValue === "function") {
      var fn = fieldWidgetDef.mongoFormatValue;
      var args = [
        currentValue,
        _objectSpread$r(_objectSpread$r({}, pick$1(fieldDef, ["fieldSettings", "listValues"])), {}, {
          asyncListValues
        }),
        //useful options: valueFormat for date/time
        omit$1(fieldWidgetDef, ["formatValue", "mongoFormatValue", "sqlFormatValue", "jsonLogic", "elasticSearchFormatValue", "spelFormatValue"])
      ];
      if (operator) {
        args.push(operator);
        args.push(operatorDef);
      }
      ret = fn.apply(void 0, args);
    } else {
      ret = currentValue;
    }
  }
  return [ret, useExpr];
};
var formatFieldName2 = function formatFieldName3(field, config2, meta, parentPath) {
  if (!field)
    return;
  var fieldDef = getFieldConfig$8(config2, field) || {};
  var fieldSeparator = config2.settings.fieldSeparator;
  Array.isArray(field) ? field : field.split(fieldSeparator);
  var fieldName = Array.isArray(field) ? field.join(fieldSeparator) : field;
  if (fieldDef.fieldName) {
    fieldName = fieldDef.fieldName;
  }
  if (parentPath) {
    var parentFieldDef = getFieldConfig$8(config2, parentPath) || {};
    var parentFieldName = parentPath;
    if (parentFieldDef.fieldName) {
      parentFieldName = parentFieldDef.fieldName;
    }
    if (fieldName.indexOf(parentFieldName + ".") == 0) {
      fieldName = fieldName.slice((parentFieldName + ".").length);
    } else {
      meta.errors.push("Can't cut group ".concat(parentFieldName, " from field ").concat(fieldName));
    }
  }
  return fieldName;
};
var formatRightField = function formatRightField2(meta, config2, rightField, parentPath) {
  var fieldSeparator = config2.settings.fieldSeparator;
  var ret;
  var useExpr = true;
  if (rightField) {
    var rightFieldDefinition = getFieldConfig$8(config2, rightField) || {};
    var fieldParts = Array.isArray(rightField) ? rightField : rightField.split(fieldSeparator);
    getFieldPath$3(rightField, config2);
    var fieldPartsLabels = getFieldPathLabels$3(rightField, config2);
    var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparator) : null;
    var formatFieldFn = config2.settings.formatField;
    var rightFieldName = formatFieldName2(rightField, config2, meta, parentPath);
    var formattedField = formatFieldFn(rightFieldName, fieldParts, fieldFullLabel, rightFieldDefinition, config2, false);
    ret = "$" + formattedField;
  }
  return [ret, useExpr];
};
var formatFunc$3 = function formatFunc2(meta, config2, currentValue, parentPath) {
  var useExpr = true;
  var ret;
  var funcKey = currentValue.get("func");
  var args = currentValue.get("args");
  var funcConfig = getFuncConfig$2(config2, funcKey);
  var funcName = funcConfig.mongoFunc || funcKey;
  var mongoArgsAsObject = funcConfig.mongoArgsAsObject;
  var formattedArgs = {};
  var argsCnt = 0;
  var lastArg = void 0;
  for (var argKey in funcConfig.args) {
    var argConfig = funcConfig.args[argKey];
    var fieldDef = getFieldConfig$8(config2, argConfig);
    var argVal = args ? args.get(argKey) : void 0;
    var argValue = argVal ? argVal.get("value") : void 0;
    var argValueSrc = argVal ? argVal.get("valueSrc") : void 0;
    var argAsyncListValues = argVal ? argVal.get("asyncListValues") : void 0;
    var widget = getWidgetForFieldOp$3(config2, fieldDef, null, argValueSrc);
    var fieldWidgetDef = omit$1(getFieldWidgetConfig$3(config2, fieldDef, null, widget, argValueSrc), ["factory"]);
    var _formatValue3 = formatValue$3(meta, config2, argValue, argValueSrc, argConfig.type, fieldWidgetDef, fieldDef, parentPath, null, null, argAsyncListValues), _formatValue4 = _slicedToArray$1(_formatValue3, 2), formattedArgVal = _formatValue4[0];
    _formatValue4[1];
    if (argValue != void 0 && formattedArgVal === void 0) {
      meta.errors.push("Can't format value of arg ".concat(argKey, " for func ").concat(funcKey));
      return [void 0, false];
    }
    argsCnt++;
    if (formattedArgVal !== void 0) {
      formattedArgs[argKey] = formattedArgVal;
      lastArg = formattedArgVal;
    }
  }
  if (typeof funcConfig.mongoFormatFunc === "function") {
    var fn = funcConfig.mongoFormatFunc;
    var _args = [formattedArgs];
    ret = fn.apply(void 0, _args);
  } else if (funcConfig.mongoFormatFunc === null) {
    meta.errors.push("Functon ".concat(funcName, " is not supported"));
    return [void 0, false];
  } else {
    if (mongoArgsAsObject)
      ret = _defineProperty$4({}, funcName, formattedArgs);
    else if (argsCnt == 1 && lastArg !== void 0)
      ret = _defineProperty$4({}, funcName, lastArg);
    else
      ret = _defineProperty$4({}, funcName, Object.values(formattedArgs));
  }
  return [ret, useExpr];
};
var SqlString$2 = {};
(function(exports2) {
  var SqlString2 = exports2;
  var ID_GLOBAL_REGEXP = /`/g;
  var QUAL_GLOBAL_REGEXP = /\./g;
  var CHARS_GLOBAL_REGEXP = /[\0\b\t\n\r\x1a\"\'\\]/g;
  var CHARS_ESCAPE_MAP = {
    "\0": "\\0",
    "\b": "\\b",
    "	": "\\t",
    "\n": "\\n",
    "\r": "\\r",
    "": "\\Z",
    '"': '\\"',
    "'": "\\'",
    "\\": "\\\\"
  };
  SqlString2.escapeId = function escapeId(val, forbidQualified) {
    if (Array.isArray(val)) {
      var sql = "";
      for (var i2 = 0; i2 < val.length; i2++) {
        sql += (i2 === 0 ? "" : ", ") + SqlString2.escapeId(val[i2], forbidQualified);
      }
      return sql;
    } else if (forbidQualified) {
      return "`" + String(val).replace(ID_GLOBAL_REGEXP, "``") + "`";
    } else {
      return "`" + String(val).replace(ID_GLOBAL_REGEXP, "``").replace(QUAL_GLOBAL_REGEXP, "`.`") + "`";
    }
  };
  SqlString2.escape = function escape(val, stringifyObjects, timeZone) {
    if (val === void 0 || val === null) {
      return "NULL";
    }
    switch (typeof val) {
      case "boolean":
        return val ? "true" : "false";
      case "number":
        return val + "";
      case "object":
        if (Object.prototype.toString.call(val) === "[object Date]") {
          return SqlString2.dateToString(val, timeZone || "local");
        } else if (Array.isArray(val)) {
          return SqlString2.arrayToList(val, timeZone);
        } else if (Buffer.isBuffer(val)) {
          return SqlString2.bufferToString(val);
        } else if (typeof val.toSqlString === "function") {
          return String(val.toSqlString());
        } else if (stringifyObjects) {
          return escapeString(val.toString());
        } else {
          return SqlString2.objectToValues(val, timeZone);
        }
      default:
        return escapeString(val);
    }
  };
  SqlString2.arrayToList = function arrayToList(array, timeZone) {
    var sql = "";
    for (var i2 = 0; i2 < array.length; i2++) {
      var val = array[i2];
      if (Array.isArray(val)) {
        sql += (i2 === 0 ? "" : ", ") + "(" + SqlString2.arrayToList(val, timeZone) + ")";
      } else {
        sql += (i2 === 0 ? "" : ", ") + SqlString2.escape(val, true, timeZone);
      }
    }
    return sql;
  };
  SqlString2.format = function format2(sql, values, stringifyObjects, timeZone) {
    if (values == null) {
      return sql;
    }
    if (!Array.isArray(values)) {
      values = [values];
    }
    var chunkIndex = 0;
    var placeholdersRegex = /\?+/g;
    var result = "";
    var valuesIndex = 0;
    var match5;
    while (valuesIndex < values.length && (match5 = placeholdersRegex.exec(sql))) {
      var len = match5[0].length;
      if (len > 2) {
        continue;
      }
      var value = len === 2 ? SqlString2.escapeId(values[valuesIndex]) : SqlString2.escape(values[valuesIndex], stringifyObjects, timeZone);
      result += sql.slice(chunkIndex, match5.index) + value;
      chunkIndex = placeholdersRegex.lastIndex;
      valuesIndex++;
    }
    if (chunkIndex === 0) {
      return sql;
    }
    if (chunkIndex < sql.length) {
      return result + sql.slice(chunkIndex);
    }
    return result;
  };
  SqlString2.dateToString = function dateToString(date, timeZone) {
    var dt = new Date(date);
    if (isNaN(dt.getTime())) {
      return "NULL";
    }
    var year;
    var month;
    var day;
    var hour;
    var minute;
    var second;
    var millisecond;
    if (timeZone === "local") {
      year = dt.getFullYear();
      month = dt.getMonth() + 1;
      day = dt.getDate();
      hour = dt.getHours();
      minute = dt.getMinutes();
      second = dt.getSeconds();
      millisecond = dt.getMilliseconds();
    } else {
      var tz = convertTimezone(timeZone);
      if (tz !== false && tz !== 0) {
        dt.setTime(dt.getTime() + tz * 6e4);
      }
      year = dt.getUTCFullYear();
      month = dt.getUTCMonth() + 1;
      day = dt.getUTCDate();
      hour = dt.getUTCHours();
      minute = dt.getUTCMinutes();
      second = dt.getUTCSeconds();
      millisecond = dt.getUTCMilliseconds();
    }
    var str = zeroPad(year, 4) + "-" + zeroPad(month, 2) + "-" + zeroPad(day, 2) + " " + zeroPad(hour, 2) + ":" + zeroPad(minute, 2) + ":" + zeroPad(second, 2) + "." + zeroPad(millisecond, 3);
    return escapeString(str);
  };
  SqlString2.bufferToString = function bufferToString(buffer) {
    return "X" + escapeString(buffer.toString("hex"));
  };
  SqlString2.objectToValues = function objectToValues(object, timeZone) {
    var sql = "";
    for (var key in object) {
      var val = object[key];
      if (typeof val === "function") {
        continue;
      }
      sql += (sql.length === 0 ? "" : ", ") + SqlString2.escapeId(key) + " = " + SqlString2.escape(val, true, timeZone);
    }
    return sql;
  };
  SqlString2.raw = function raw(sql) {
    if (typeof sql !== "string") {
      throw new TypeError("argument sql must be a string");
    }
    return {
      toSqlString: function toSqlString() {
        return sql;
      }
    };
  };
  function escapeString(val) {
    var chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex = 0;
    var escapedVal = "";
    var match5;
    while (match5 = CHARS_GLOBAL_REGEXP.exec(val)) {
      escapedVal += val.slice(chunkIndex, match5.index) + CHARS_ESCAPE_MAP[match5[0]];
      chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex;
    }
    if (chunkIndex === 0) {
      return "'" + val + "'";
    }
    if (chunkIndex < val.length) {
      return "'" + escapedVal + val.slice(chunkIndex) + "'";
    }
    return "'" + escapedVal + "'";
  }
  function zeroPad(number, length) {
    number = number.toString();
    while (number.length < length) {
      number = "0" + number;
    }
    return number;
  }
  function convertTimezone(tz) {
    if (tz === "Z") {
      return 0;
    }
    var m2 = tz.match(/([\+\-\s])(\d\d):?(\d\d)?/);
    if (m2) {
      return (m2[1] === "-" ? -1 : 1) * (parseInt(m2[2], 10) + (m2[3] ? parseInt(m2[3], 10) : 0) / 60) * 60;
    }
    return false;
  }
})(SqlString$2);
var sqlstring = SqlString$2;
const SqlStringOrig = /* @__PURE__ */ getDefaultExportFromCjs(sqlstring);
var SqlString$1 = SqlStringOrig;
SqlString$1.trim = function(val) {
  if (val.charAt(0) == "'")
    return val.substring(1, val.length - 1);
  else
    return val;
};
SqlString$1.escapeLike = function(val) {
  var any_start = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var any_end = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var res = SqlString$1.escape(val);
  res = SqlString$1.trim(res);
  res = res.replace(/[%_]/g, "\\$&");
  res = (any_start ? "%" : "") + res + (any_end ? "%" : "");
  res = "'" + res + "'";
  return res;
};
var sqlEmptyValue = function sqlEmptyValue2(fieldDef) {
  var v2 = "''";
  var type2 = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.type;
  if (type2 == "date") {
    v2 = "'0000-00-00'";
  } else if (type2 == "datetime") {
    v2 = "'0000-00-00 00:00'";
  } else if (type2 == "time") {
    v2 = "'00:00'";
  } else if (type2 == "number") {
    v2 = "0";
  }
  return v2;
};
var mongoEmptyValue = function mongoEmptyValue2(fieldDef) {
  var v2 = "";
  var type2 = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.type;
  if (type2 == "number") {
    v2 = 0;
  }
  return v2;
};
var spelEscapeString = function spelEscapeString2(val) {
  return "'" + val.replace(/'/g, "''") + "'";
};
var spelInlineList = function spelInlineList2(vals) {
  var toArray2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var javaType;
  var jt;
  var numberJavaTypes = ["int", "float"];
  vals.map(function(v2) {
    if (v2 !== void 0 && v2 !== null) {
      if (typeof v2 === "string") {
        jt = "String";
      } else if (typeof v2 === "number") {
        jt = Number.isInteger(v2) ? "int" : "float";
      } else
        throw new Error("spelEscape: Can't use value ".concat(v2, " in array"));
      if (!javaType) {
        javaType = jt;
      } else if (javaType != jt) {
        if (numberJavaTypes.includes(javaType) && numberJavaTypes.includes(jt)) {
          javaType = "float";
        } else
          throw new Error("spelEscape: Can't use different types in array: found ".concat(javaType, " and ").concat(jt));
      }
    }
  });
  if (!javaType) {
    javaType = "String";
  }
  var escapedVals;
  if (javaType == "float") {
    escapedVals = vals.map(function(v2) {
      return spelEscape(v2, true);
    });
  } else {
    escapedVals = vals.map(function(v2) {
      return spelEscape(v2);
    });
  }
  var res;
  if (toArray2) {
    res = "new ".concat(javaType, "[]{").concat(escapedVals.join(", "), "}");
  } else {
    res = "{".concat(escapedVals.join(", "), "}");
  }
  return res;
};
var spelFixList = function spelFixList2(val) {
  return "".concat(val, ".?[true]");
};
var spelEscape = function spelEscape2(val) {
  var numberToFloat = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var arrayToArray = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (val === void 0 || val === null) {
    return "null";
  }
  switch (_typeof$2(val)) {
    case "boolean":
      return val ? "true" : "false";
    case "number":
      if (!Number.isFinite(val) || isNaN(val))
        return void 0;
      return val + (!Number.isInteger(val) || numberToFloat ? "f" : "");
    case "object":
      if (Array.isArray(val)) {
        return spelInlineList(val, arrayToArray);
      } else {
        throw new Error("spelEscape: Object is not supported");
      }
    default:
      return spelEscapeString(val);
  }
};
var spelFormatConcat = function spelFormatConcat2(parts) {
  if (parts && Array.isArray(parts) && parts.length) {
    return parts.map(function(part) {
      if (part.type == "const") {
        return spelEscape(part.value);
      } else if (part.type == "property") {
        return "" + part.value;
      } else if (part.type == "variable") {
        return "#" + part.value;
      }
      return void 0;
    }).filter(function(r2) {
      return r2 != void 0;
    }).join(" + ");
  } else {
    return "null";
  }
};
var spelImportConcat = function spelImportConcat2(val) {
  if (val == void 0)
    return [void 0, []];
  var errors = [];
  var parts = val.valueType == "case_value" ? val.value : [val];
  var res = parts.map(function(child) {
    if (child.valueSrc == "value") {
      if (child.value === null) {
        return void 0;
      } else {
        return {
          type: "const",
          value: child.value
        };
      }
    } else if (child.valueSrc == "field") {
      return {
        type: child.isVariable ? "variable" : "property",
        value: child.value
      };
    } else {
      errors.push("Unsupported valueSrc ".concat(child.valueSrc, " in concatenation"));
    }
  }).filter(function(v2) {
    return v2 != void 0;
  });
  return [res, errors];
};
var stringifyForDisplay$1 = function stringifyForDisplay(v2) {
  return v2 == null ? "NULL" : v2.toString();
};
const _export = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  SqlString: SqlString$1,
  mongoEmptyValue,
  spelEscape,
  spelFixList,
  spelFormatConcat,
  spelImportConcat,
  sqlEmptyValue,
  stringifyForDisplay: stringifyForDisplay$1
}, Symbol.toStringTag, { value: "Module" }));
function ownKeys$q(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$q(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$q(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$q(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var sqlFormat = function sqlFormat2(tree2, config2) {
  return _sqlFormat(tree2, config2, false);
};
var _sqlFormat = function _sqlFormat2(tree2, config2) {
  var returnErrors = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var meta = {
    errors: []
  };
  var res = formatItem$2(tree2, config2, meta);
  if (returnErrors) {
    return [res, meta.errors];
  } else {
    if (meta.errors.length)
      console.warn("Errors while exporting to SQL:", meta.errors);
    return res;
  }
};
var formatItem$2 = function formatItem4(item, config2, meta) {
  if (!item)
    return void 0;
  var type2 = item.get("type");
  item.get("children1");
  if (type2 === "group" || type2 === "rule_group") {
    return formatGroup$2(item, config2, meta);
  } else if (type2 === "rule") {
    return formatRule$2(item, config2, meta);
  }
  return void 0;
};
var formatGroup$2 = function formatGroup4(item, config2, meta) {
  var type2 = item.get("type");
  var properties = item.get("properties") || new immutableExports.Map();
  var children = item.get("children1") || new immutableExports.List();
  var isRuleGroup = type2 === "rule_group";
  var groupField = isRuleGroup ? properties.get("field") : null;
  var groupFieldDef = getFieldConfig$8(config2, groupField) || {};
  var mode = groupFieldDef.mode;
  if (mode == "array") {
    meta.errors.push("Aggregation is not supported for ".concat(groupField));
  }
  var not = properties.get("not");
  var list2 = children.map(function(currentChild) {
    return formatItem$2(currentChild, config2, meta);
  }).filter(function(currentChild) {
    return typeof currentChild !== "undefined";
  });
  if (!list2.size)
    return void 0;
  var conjunction = properties.get("conjunction");
  if (!conjunction)
    conjunction = defaultConjunction(config2);
  var conjunctionDefinition = config2.conjunctions[conjunction];
  return conjunctionDefinition.sqlFormatConj(list2, conjunction, not);
};
var buildFnToFormatOp$2 = function buildFnToFormatOp2(operator, operatorDefinition) {
  var sqlOp = operatorDefinition.sqlOp || operator;
  var cardinality = defaultValue$1(operatorDefinition.cardinality, 1);
  var fn;
  if (cardinality == 0) {
    fn = function fn2(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
      return "".concat(field, " ").concat(sqlOp);
    };
  } else if (cardinality == 1) {
    fn = function fn2(field, op, value, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
      return "".concat(field, " ").concat(sqlOp, " ").concat(value);
    };
  } else if (cardinality == 2) {
    fn = function fn2(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
      var valFrom = values.first();
      var valTo = values.get(1);
      return "".concat(field, " ").concat(sqlOp, " ").concat(valFrom, " AND ").concat(valTo);
    };
  }
  return fn;
};
var formatRule$2 = function formatRule4(item, config2, meta) {
  var properties = item.get("properties") || new immutableExports.Map();
  var field = properties.get("field");
  var operator = properties.get("operator");
  var operatorOptions = properties.get("operatorOptions");
  var iValueSrc = properties.get("valueSrc");
  var iValueType = properties.get("valueType");
  var iValue = properties.get("value");
  var asyncListValues = properties.get("asyncListValues");
  if (field == null || operator == null)
    return void 0;
  var fieldDefinition = getFieldConfig$8(config2, field) || {};
  var opDef = getOperatorConfig$4(config2, operator, field) || {};
  var reversedOp = opDef.reversedOp;
  var revOpDef = getOperatorConfig$4(config2, reversedOp, field) || {};
  var cardinality = defaultValue$1(opDef.cardinality, 1);
  var isRev = false;
  var canFormatOp = opDef.sqlOp || opDef.sqlFormatOp;
  var canFormatRevOp = revOpDef.sqlOp || revOpDef.sqlFormatOp;
  if (!canFormatOp && !canFormatRevOp) {
    meta.errors.push("Operator ".concat(operator, " is not supported"));
    return void 0;
  }
  if (!canFormatRevOp && canFormatRevOp) {
    isRev = true;
    var _ref = [reversedOp, operator];
    operator = _ref[0];
    reversedOp = _ref[1];
    var _ref2 = [revOpDef, opDef];
    opDef = _ref2[0];
    revOpDef = _ref2[1];
  }
  var valueSrcs = [];
  var valueTypes = [];
  var fvalue = iValue.map(function(currentValue, ind) {
    var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;
    var valueType = iValueType ? iValueType.get(ind) : null;
    var cValue = completeValue(currentValue, valueSrc, config2);
    var widget = getWidgetForFieldOp$3(config2, field, operator, valueSrc);
    var fieldWidgetDefinition = omit$1(getFieldWidgetConfig$3(config2, field, operator, widget, valueSrc), ["factory"]);
    var fv = formatValue$2(meta, config2, cValue, valueSrc, valueType, fieldWidgetDefinition, fieldDefinition, operator, opDef, asyncListValues);
    if (fv !== void 0) {
      valueSrcs.push(valueSrc);
      valueTypes.push(valueType);
    }
    return fv;
  });
  var hasUndefinedValues = fvalue.filter(function(v2) {
    return v2 === void 0;
  }).size > 0;
  if (hasUndefinedValues || fvalue.size < cardinality)
    return void 0;
  var formattedValue = cardinality == 1 ? fvalue.first() : fvalue;
  var fn = opDef.sqlFormatOp || buildFnToFormatOp$2(operator, opDef);
  if (!fn) {
    meta.errors.push("Operator ".concat(operator, " is not supported"));
    return void 0;
  }
  var formattedField = formatField$2(meta, config2, field);
  var args = [formattedField, operator, formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0], omit$1(opDef, ["formatOp", "mongoFormatOp", "sqlFormatOp", "jsonLogic", "spelFormatOp"]), operatorOptions, fieldDefinition];
  var ret;
  ret = fn.apply(void 0, args);
  if (isRev) {
    ret = config2.settings.sqlFormatReverse(ret);
  }
  if (ret === void 0) {
    meta.errors.push("Operator ".concat(operator, " is not supported for value source ").concat(valueSrcs.join(", ")));
    return void 0;
  }
  return ret;
};
var formatValue$2 = function formatValue3(meta, config2, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef, asyncListValues) {
  if (currentValue === void 0)
    return void 0;
  var ret;
  if (valueSrc == "field") {
    ret = formatField$2(meta, config2, currentValue);
  } else if (valueSrc == "func") {
    ret = formatFunc$2(meta, config2, currentValue);
  } else {
    if (typeof fieldWidgetDef.sqlFormatValue === "function") {
      var fn = fieldWidgetDef.sqlFormatValue;
      var args = [
        currentValue,
        _objectSpread$q(_objectSpread$q({}, pick$1(fieldDef, ["fieldSettings", "listValues"])), {}, {
          asyncListValues
        }),
        //useful options: valueFormat for date/time
        omit$1(fieldWidgetDef, ["formatValue", "mongoFormatValue", "sqlFormatValue", "jsonLogic", "elasticSearchFormatValue", "spelFormatValue"])
      ];
      if (operator) {
        args.push(operator);
        args.push(operatorDef);
      }
      if (valueSrc == "field") {
        var valFieldDefinition = getFieldConfig$8(config2, currentValue) || {};
        args.push(valFieldDefinition);
      }
      ret = fn.apply(void 0, args);
    } else {
      if (Array.isArray(currentValue)) {
        ret = currentValue.map(function(v2) {
          return SqlString$1.escape(v2);
        });
      } else {
        ret = SqlString$1.escape(currentValue);
      }
    }
  }
  return ret;
};
var formatField$2 = function formatField3(meta, config2, field) {
  if (!field)
    return;
  var fieldSeparator = config2.settings.fieldSeparator;
  var fieldDefinition = getFieldConfig$8(config2, field) || {};
  var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);
  getFieldPath$3(field, config2);
  var fieldPartsLabels = getFieldPathLabels$3(field, config2);
  var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparator) : null;
  var formatFieldFn = config2.settings.formatField;
  var fieldName = formatFieldName$1(field, config2, meta);
  var formattedField = formatFieldFn(fieldName, fieldParts, fieldFullLabel, fieldDefinition, config2);
  return formattedField;
};
var formatFunc$2 = function formatFunc3(meta, config2, currentValue) {
  var funcKey = currentValue.get("func");
  var args = currentValue.get("args");
  var funcConfig = getFuncConfig$2(config2, funcKey);
  var funcName = funcConfig.sqlFunc || funcKey;
  var formattedArgs = {};
  for (var argKey in funcConfig.args) {
    var argConfig = funcConfig.args[argKey];
    var fieldDef = getFieldConfig$8(config2, argConfig);
    var argVal = args ? args.get(argKey) : void 0;
    var argValue = argVal ? argVal.get("value") : void 0;
    var argValueSrc = argVal ? argVal.get("valueSrc") : void 0;
    var argAsyncListValues = argVal ? argVal.get("asyncListValues") : void 0;
    var formattedArgVal = formatValue$2(meta, config2, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, argAsyncListValues);
    if (argValue != void 0 && formattedArgVal === void 0) {
      meta.errors.push("Can't format value of arg ".concat(argKey, " for func ").concat(funcKey));
      return void 0;
    }
    if (formattedArgVal !== void 0) {
      formattedArgs[argKey] = formattedArgVal;
    }
  }
  var ret;
  if (typeof funcConfig.sqlFormatFunc === "function") {
    var fn = funcConfig.sqlFormatFunc;
    var _args = [formattedArgs];
    ret = fn.apply(void 0, _args);
  } else {
    var argsStr = Object.entries(formattedArgs).map(function(_ref3) {
      var _ref4 = _slicedToArray$1(_ref3, 2);
      _ref4[0];
      var v2 = _ref4[1];
      return v2;
    }).join(", ");
    ret = "".concat(funcName, "(").concat(argsStr, ")");
  }
  return ret;
};
function ownKeys$p(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$p(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$p(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$p(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var spelFormat = function spelFormat2(tree2, config2) {
  return _spelFormat(tree2, config2, false);
};
var _spelFormat = function _spelFormat2(tree2, config2) {
  var returnErrors = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var meta = {
    errors: []
  };
  var res = formatItem$1(tree2, config2, meta, null);
  if (returnErrors) {
    return [res, meta.errors];
  } else {
    if (meta.errors.length)
      console.warn("Errors while exporting to SpEL:", meta.errors);
    return res;
  }
};
var formatItem$1 = function formatItem5(item, config2, meta) {
  var parentField = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  if (!item)
    return void 0;
  var type2 = item.get("type");
  if (type2 === "group" || type2 === "rule_group") {
    return formatGroup$1(item, config2, meta, parentField);
  } else if (type2 === "rule") {
    return formatRule$1(item, config2, meta, parentField);
  } else if (type2 == "switch_group") {
    return formatSwitch(item, config2, meta);
  } else if (type2 == "case_group") {
    return formatCase(item, config2, meta, parentField);
  }
  return void 0;
};
var formatCase = function formatCase2(item, config2, meta) {
  var parentField = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var type2 = item.get("type");
  if (type2 != "case_group") {
    meta.errors.push("Unexpected child of type ".concat(type2, " inside switch"));
    return void 0;
  }
  var properties = item.get("properties") || new immutableExports.Map();
  var _formatItemValue = formatItemValue$1(config2, properties, meta, null, parentField, "!case_value"), _formatItemValue2 = _slicedToArray$1(_formatItemValue, 3), formattedValue = _formatItemValue2[0];
  _formatItemValue2[1];
  _formatItemValue2[2];
  var cond = formatGroup$1(item, config2, meta, parentField);
  return [cond, formattedValue];
};
var formatSwitch = function formatSwitch2(item, config2, meta) {
  item.get("properties") || new immutableExports.Map();
  var children = item.get("children1");
  if (!children)
    return void 0;
  var cases = children.map(function(currentChild) {
    return formatCase(currentChild, config2, meta, null);
  }).filter(function(currentChild) {
    return typeof currentChild !== "undefined";
  }).toArray();
  if (!cases.length)
    return void 0;
  if (cases.length == 1 && !cases[0][0]) {
    return cases[0][1];
  }
  var filteredCases = [];
  for (var i2 = 0; i2 < cases.length; i2++) {
    if (i2 != cases.length - 1 && !cases[i2][0]) {
      meta.errors.push("No condition for case ".concat(i2));
    } else {
      filteredCases.push(cases[i2]);
      if (i2 == cases.length - 1 && cases[i2][0]) {
        filteredCases.push([void 0, null]);
      }
    }
  }
  var left = "", right = "";
  for (var _i = 0; _i < filteredCases.length; _i++) {
    var _filteredCases$_i = _slicedToArray$1(filteredCases[_i], 2), cond = _filteredCases$_i[0], value = _filteredCases$_i[1];
    if (value == void 0)
      value = "null";
    if (cond == void 0)
      cond = "true";
    if (_i != filteredCases.length - 1) {
      left += "(".concat(cond, " ? ").concat(value, " : ");
      right += ")";
    } else {
      left += "".concat(value);
    }
  }
  return left + right;
};
var formatGroup$1 = function formatGroup5(item, config2, meta) {
  var parentField = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var type2 = item.get("type");
  var properties = item.get("properties") || new immutableExports.Map();
  var mode = properties.get("mode");
  var children = item.get("children1") || new immutableExports.List();
  var field = properties.get("field");
  var conjunction = properties.get("conjunction");
  if (!conjunction)
    conjunction = defaultConjunction(config2);
  var conjunctionDefinition = config2.conjunctions[conjunction];
  var not = properties.get("not");
  var isRuleGroup = type2 === "rule_group";
  var isRuleGroupArray = isRuleGroup && mode != "struct";
  var groupField = isRuleGroupArray ? field : parentField;
  var groupFieldDef = getFieldConfig$8(config2, groupField) || {};
  var isSpelArray = groupFieldDef.isSpelArray;
  var groupOperator = properties.get("operator");
  if (!groupOperator && (!mode || mode == "some")) {
    groupOperator = "some";
  }
  var realGroupOperator = checkOp(config2, groupOperator, field);
  var isGroupOpRev = realGroupOperator != groupOperator;
  var realGroupOperatorDefinition = groupOperator && getOperatorConfig$4(config2, realGroupOperator, field) || null;
  var isGroup0 = isRuleGroup && (!realGroupOperator || realGroupOperatorDefinition.cardinality == 0);
  var _formatItemValue3 = formatItemValue$1(config2, properties, meta, realGroupOperator, parentField, null), _formatItemValue4 = _slicedToArray$1(_formatItemValue3, 3), formattedValue = _formatItemValue4[0], valueSrc = _formatItemValue4[1], valueType = _formatItemValue4[2];
  var list2 = children.map(function(currentChild) {
    return formatItem$1(currentChild, config2, meta, groupField);
  }).filter(function(currentChild) {
    return typeof currentChild !== "undefined";
  });
  if (isRuleGroupArray && !isGroup0) {
    if (formattedValue == void 0)
      return void 0;
  } else {
    if (!list2.size)
      return void 0;
  }
  var omitBrackets = isRuleGroup;
  var filter = list2.size ? conjunctionDefinition.spelFormatConj(list2, conjunction, not, omitBrackets) : null;
  var ret;
  if (isRuleGroupArray) {
    var formattedField = formatField$1(meta, config2, field, parentField);
    var getSize = isSpelArray ? ".length" : ".size()";
    var fullSize = "".concat(formattedField).concat(getSize);
    var filteredSize = filter ? "".concat(formattedField, ".?[").concat(filter, "]").concat(getSize) : fullSize;
    var groupValue = isGroup0 ? fullSize : formattedValue;
    ret = formatExpression(meta, config2, properties, filteredSize, groupValue, realGroupOperator, valueSrc, valueType, isGroupOpRev);
  } else {
    ret = filter;
  }
  return ret;
};
var buildFnToFormatOp$1 = function buildFnToFormatOp3(operator, operatorDefinition) {
  var spelOp = operatorDefinition.spelOp;
  if (!spelOp)
    return void 0;
  var objectIsFirstArg = spelOp[0] == "$";
  var isMethod = spelOp[0] == "." || objectIsFirstArg;
  var isFunction2 = spelOp.substring(spelOp.length - 2) == "()";
  var sop = isMethod ? spelOp.slice(1) : isFunction2 ? spelOp.substring(0, spelOp.length - 2) : spelOp;
  var fn;
  var cardinality = defaultValue$1(operatorDefinition.cardinality, 1);
  if (cardinality == 0) {
    fn = function fn2(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
      if (isMethod)
        return "".concat(field, ".").concat(sop, "()");
      else
        return "".concat(field, " ").concat(sop);
    };
  } else if (cardinality == 1) {
    fn = function fn2(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
      if (objectIsFirstArg)
        return "".concat(values, ".").concat(sop, "(").concat(field, ")");
      else if (isFunction2)
        return "".concat(sop, "(").concat(field, ", ").concat(values, ")");
      else if (isMethod)
        return "".concat(field, ".").concat(sop, "(").concat(values, ")");
      else
        return "".concat(field, " ").concat(sop, " ").concat(values);
    };
  }
  return fn;
};
var formatExpression = function formatExpression2(meta, config2, properties, formattedField, formattedValue, operator, valueSrc, valueType) {
  var isRev = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : false;
  var field = properties.get("field");
  var opDef = getOperatorConfig$4(config2, operator, field) || {};
  var fieldDef = getFieldConfig$8(config2, field) || {};
  var operatorOptions = properties.get("operatorOptions");
  var fn = opDef.spelFormatOp || buildFnToFormatOp$1(operator, opDef);
  if (!fn) {
    meta.errors.push("Operator ".concat(operator, " is not supported"));
    return void 0;
  }
  var args = [formattedField, operator, formattedValue, valueSrc, valueType, omit$1(opDef, ["formatOp", "mongoFormatOp", "sqlFormatOp", "jsonLogic", "spelFormatOp"]), operatorOptions, fieldDef];
  var ret;
  ret = fn.apply(void 0, args);
  if (isRev) {
    ret = config2.settings.spelFormatReverse(ret);
  }
  if (ret === void 0) {
    meta.errors.push("Operator ".concat(operator, " is not supported for value source ").concat(valueSrc));
  }
  return ret;
};
var checkOp = function checkOp2(config2, operator, field) {
  if (!operator)
    return void 0;
  var opDef = getOperatorConfig$4(config2, operator, field) || {};
  var reversedOp = opDef.reversedOp;
  var revOpDef = getOperatorConfig$4(config2, reversedOp, field) || {};
  var canFormatOp = opDef.spelOp || opDef.spelFormatOp;
  var canFormatRevOp = revOpDef.spelOp || revOpDef.spelFormatOp;
  if (!canFormatOp && !canFormatRevOp) {
    return void 0;
  }
  if (!canFormatOp && canFormatRevOp) {
    var _ref = [reversedOp, operator];
    operator = _ref[0];
    reversedOp = _ref[1];
    var _ref2 = [revOpDef, opDef];
    opDef = _ref2[0];
    revOpDef = _ref2[1];
  }
  return operator;
};
var formatRule$1 = function formatRule5(item, config2, meta) {
  var parentField = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var properties = item.get("properties") || new immutableExports.Map();
  var field = properties.get("field");
  var operator = properties.get("operator");
  if (field == null || operator == null)
    return void 0;
  var realOp = checkOp(config2, operator, field);
  if (!realOp) {
    meta.errors.push("Operator ".concat(operator, " is not supported"));
    return void 0;
  }
  var isRev = realOp != operator;
  var _formatItemValue5 = formatItemValue$1(config2, properties, meta, realOp, parentField, null), _formatItemValue6 = _slicedToArray$1(_formatItemValue5, 3), formattedValue = _formatItemValue6[0], valueSrc = _formatItemValue6[1], valueType = _formatItemValue6[2];
  if (formattedValue === void 0)
    return void 0;
  var formattedField = formatField$1(meta, config2, field, parentField);
  var res = formatExpression(meta, config2, properties, formattedField, formattedValue, realOp, valueSrc, valueType, isRev);
  return res;
};
var formatItemValue$1 = function formatItemValue2(config2, properties, meta, operator, parentField) {
  var expectedValueType = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null;
  var field = properties.get("field");
  var iValueSrc = properties.get("valueSrc");
  var iValueType = properties.get("valueType");
  if (expectedValueType == "!case_value" || iValueType && iValueType.get(0) == "case_value") {
    field = "!case_value";
  }
  var fieldDef = getFieldConfig$8(config2, field) || {};
  var operatorDefinition = getOperatorConfig$4(config2, operator, field) || {};
  var cardinality = defaultValue$1(operatorDefinition.cardinality, 1);
  var iValue = properties.get("value");
  var asyncListValues = properties.get("asyncListValues");
  var valueSrcs = [];
  var valueTypes = [];
  var formattedValue;
  if (iValue != void 0) {
    var fvalue = iValue.map(function(currentValue, ind) {
      var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;
      var valueType = iValueType ? iValueType.get(ind) : null;
      var cValue = completeValue(currentValue, valueSrc, config2);
      var widget = getWidgetForFieldOp$3(config2, field, operator, valueSrc);
      var fieldWidgetDef = omit$1(getFieldWidgetConfig$3(config2, field, operator, widget, valueSrc), ["factory"]);
      var fv = formatValue$1(meta, config2, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDefinition, parentField, asyncListValues);
      if (fv !== void 0) {
        valueSrcs.push(valueSrc);
        valueTypes.push(valueType);
      }
      return fv;
    });
    var hasUndefinedValues = fvalue.filter(function(v2) {
      return v2 === void 0;
    }).size > 0;
    if (!(fvalue.size < cardinality || hasUndefinedValues)) {
      formattedValue = cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;
    }
  }
  return [formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0]];
};
var formatValue$1 = function formatValue4(meta, config2, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef) {
  var parentField = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : null;
  var asyncListValues = arguments.length > 10 ? arguments[10] : void 0;
  if (currentValue === void 0)
    return void 0;
  var ret;
  if (valueSrc == "field") {
    ret = formatField$1(meta, config2, currentValue, parentField);
  } else if (valueSrc == "func") {
    ret = formatFunc$1(meta, config2, currentValue, parentField);
  } else {
    if (typeof fieldWidgetDef.spelFormatValue === "function") {
      var fn = fieldWidgetDef.spelFormatValue;
      var args = [
        currentValue,
        _objectSpread$p(_objectSpread$p({}, pick$1(fieldDef, ["fieldSettings", "listValues"])), {}, {
          asyncListValues
        }),
        //useful options: valueFormat for date/time
        omit$1(fieldWidgetDef, ["formatValue", "mongoFormatValue", "sqlFormatValue", "jsonLogic", "elasticSearchFormatValue", "spelFormatValue"])
      ];
      if (operator) {
        args.push(operator);
        args.push(operatorDef);
      }
      if (valueSrc == "field") {
        var valFieldDefinition = getFieldConfig$8(config2, currentValue) || {};
        args.push(valFieldDefinition);
      }
      ret = fn.apply(void 0, args);
    } else {
      ret = spelEscape(currentValue);
    }
  }
  return ret;
};
var formatField$1 = function formatField4(meta, config2, field) {
  var parentField = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  if (!field)
    return;
  var fieldSeparator = config2.settings.fieldSeparator;
  var fieldDefinition = getFieldConfig$8(config2, field) || {};
  var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);
  getFieldPath$3(field, config2, parentField);
  var fieldPartsConfigs = getFieldPartsConfigs(field, config2, parentField);
  var formatFieldFn = config2.settings.formatSpelField;
  var fieldName = formatFieldName$1(field, config2, meta);
  if (parentField) {
    var parentFieldDef = getFieldConfig$8(config2, parentField) || {};
    var parentFieldName = parentField;
    if (parentFieldDef.fieldName) {
      parentFieldName = parentFieldDef.fieldName;
    }
    if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {
      fieldName = fieldName.slice((parentFieldName + fieldSeparator).length);
    } else {
      meta.errors.push("Can't cut group ".concat(parentFieldName, " from field ").concat(fieldName));
    }
  }
  var fieldPartsMeta = fieldPartsConfigs.map(function(_ref3) {
    var _ref4 = _slicedToArray$1(_ref3, 3), key = _ref4[0], cnf = _ref4[1], parentCnf = _ref4[2];
    var parent2;
    if (parentCnf) {
      if (parentCnf.type == "!struct" || parentCnf.type == "!group" && parentCnf.mode == "struct")
        parent2 = cnf.isSpelMap ? "map" : "class";
      else if (parentCnf.type == "!group")
        parent2 = cnf.isSpelItemMap ? "[map]" : "[class]";
      else
        parent2 = "class";
    }
    var isSpelVariable = cnf === null || cnf === void 0 ? void 0 : cnf.isSpelVariable;
    return {
      key,
      parent: parent2,
      isSpelVariable
    };
  });
  var formattedField = formatFieldFn(fieldName, parentField, fieldParts, fieldPartsMeta, fieldDefinition, config2);
  return formattedField;
};
var formatFunc$1 = function formatFunc4(meta, config2, currentValue) {
  var parentField = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var funcKey = currentValue.get("func");
  var args = currentValue.get("args");
  var funcConfig = getFuncConfig$2(config2, funcKey);
  var funcName = funcConfig.spelFunc || funcKey;
  var formattedArgs = {};
  for (var argKey in funcConfig.args) {
    var argConfig = funcConfig.args[argKey];
    var fieldDef = getFieldConfig$8(config2, argConfig);
    var argVal = args ? args.get(argKey) : void 0;
    var argValue = argVal ? argVal.get("value") : void 0;
    var argValueSrc = argVal ? argVal.get("valueSrc") : void 0;
    var argAsyncListValues = argVal ? argVal.get("asyncListValues") : void 0;
    var formattedArgVal = formatValue$1(meta, config2, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, parentField, argAsyncListValues);
    if (argValue != void 0 && formattedArgVal === void 0) {
      meta.errors.push("Can't format value of arg ".concat(argKey, " for func ").concat(funcKey));
      return void 0;
    }
    if (formattedArgVal !== void 0) {
      formattedArgs[argKey] = formattedArgVal;
    }
  }
  var ret;
  if (typeof funcConfig.spelFormatFunc === "function") {
    var fn = funcConfig.spelFormatFunc;
    var _args = [formattedArgs];
    ret = fn.apply(void 0, _args);
  } else {
    var _args2 = Object.entries(formattedArgs).map(function(_ref5) {
      var _ref6 = _slicedToArray$1(_ref5, 2);
      _ref6[0];
      var v2 = _ref6[1];
      return v2;
    });
    if (funcName[0] == "." && _args2.length) {
      var _args3 = _toArray(_args2), obj = _args3[0], params = _args3.slice(1);
      ret = "".concat(obj).concat(funcName, "(").concat(params.join(", "), ")");
    } else {
      ret = "".concat(funcName, "(").concat(_args2.join(", "), ")");
    }
  }
  return ret;
};
function ownKeys$o(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$o(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$o(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$o(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var queryString = function queryString2(item, config2) {
  var isForDisplay = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var meta = {
    errors: []
  };
  var res = formatItem6(item, config2, meta, isForDisplay, null);
  if (meta.errors.length)
    console.warn("Errors while exporting to string:", meta.errors);
  return res;
};
var formatItem6 = function formatItem7(item, config2, meta) {
  var isForDisplay = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var parentField = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
  if (!item)
    return void 0;
  var type2 = item.get("type");
  item.get("children1");
  if (type2 === "group" || type2 === "rule_group") {
    return formatGroup6(item, config2, meta, isForDisplay, parentField);
  } else if (type2 === "rule") {
    return formatRule6(item, config2, meta, isForDisplay, parentField);
  }
  return void 0;
};
var formatGroup6 = function formatGroup7(item, config2, meta) {
  var isForDisplay = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var parentField = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
  var type2 = item.get("type");
  var properties = item.get("properties") || new immutableExports.Map();
  var mode = properties.get("mode");
  var children = item.get("children1") || new immutableExports.List();
  var isRuleGroup = type2 === "rule_group";
  var groupField = isRuleGroup && mode == "array" ? properties.get("field") : null;
  var canHaveEmptyChildren = isRuleGroup && mode == "array";
  var not = properties.get("not");
  var list2 = children.map(function(currentChild) {
    return formatItem6(currentChild, config2, meta, isForDisplay, groupField);
  }).filter(function(currentChild) {
    return typeof currentChild !== "undefined";
  });
  if (!canHaveEmptyChildren && !list2.size)
    return void 0;
  var conjunction = properties.get("conjunction");
  if (!conjunction)
    conjunction = defaultConjunction(config2);
  var conjunctionDefinition = config2.conjunctions[conjunction];
  var conjStr = list2.size ? conjunctionDefinition.formatConj(list2, conjunction, not, isForDisplay) : null;
  var ret;
  if (groupField) {
    var aggrArgs = formatRule6(item, config2, meta, isForDisplay, parentField, true);
    if (aggrArgs) {
      var _config$settings;
      var isRev = aggrArgs.pop();
      var args = [conjStr].concat(_toConsumableArray(aggrArgs));
      ret = (_config$settings = config2.settings).formatAggr.apply(_config$settings, _toConsumableArray(args));
      if (isRev) {
        ret = config2.settings.formatReverse(ret, null, null, null, null, isForDisplay);
      }
    }
  } else {
    ret = conjStr;
  }
  return ret;
};
var formatItemValue3 = function formatItemValue4(config2, properties, meta, _operator, isForDisplay, parentField) {
  var field = properties.get("field");
  var iValueSrc = properties.get("valueSrc");
  var iValueType = properties.get("valueType");
  var fieldDef = getFieldConfig$8(config2, field) || {};
  var operator = _operator || properties.get("operator");
  var operatorDef = getOperatorConfig$4(config2, operator, field) || {};
  var cardinality = defaultValue$1(operatorDef.cardinality, 1);
  var iValue = properties.get("value");
  var asyncListValues = properties.get("asyncListValues");
  var valueSrcs = [];
  var valueTypes = [];
  var formattedValue;
  if (iValue != void 0) {
    var fvalue = iValue.map(function(currentValue, ind) {
      var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;
      var valueType = iValueType ? iValueType.get(ind) : null;
      var cValue = completeValue(currentValue, valueSrc, config2);
      var widget = getWidgetForFieldOp$3(config2, field, operator, valueSrc);
      var fieldWidgetDef = omit$1(getFieldWidgetConfig$3(config2, field, operator, widget, valueSrc), ["factory"]);
      var fv = formatValue5(config2, meta, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef, isForDisplay, parentField, asyncListValues);
      if (fv !== void 0) {
        valueSrcs.push(valueSrc);
        valueTypes.push(valueType);
      }
      return fv;
    });
    var hasUndefinedValues = fvalue.filter(function(v2) {
      return v2 === void 0;
    }).size > 0;
    if (!(hasUndefinedValues || fvalue.size < cardinality)) {
      formattedValue = cardinality == 1 ? fvalue.first() : fvalue;
    }
  }
  return [formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0]];
};
var buildFnToFormatOp4 = function buildFnToFormatOp5(operator, operatorDefinition) {
  var fop = operatorDefinition.labelForFormat || operator;
  var cardinality = defaultValue$1(operatorDefinition.cardinality, 1);
  var fn;
  if (cardinality == 0) {
    fn = function fn2(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      return "".concat(field, " ").concat(fop);
    };
  } else if (cardinality == 1) {
    fn = function fn2(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      return "".concat(field, " ").concat(fop, " ").concat(values);
    };
  } else if (cardinality == 2) {
    fn = function fn2(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      var valFrom = values.first();
      var valTo = values.get(1);
      return "".concat(field, " ").concat(fop, " ").concat(valFrom, " AND ").concat(valTo);
    };
  }
  return fn;
};
var formatRule6 = function formatRule7(item, config2, meta) {
  var isForDisplay = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var parentField = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
  var returnArgs = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
  var properties = item.get("properties") || new immutableExports.Map();
  var field = properties.get("field");
  var operator = properties.get("operator");
  var operatorOptions = properties.get("operatorOptions");
  if (field == null || operator == null)
    return void 0;
  var fieldDef = getFieldConfig$8(config2, field) || {};
  var operatorDef = getOperatorConfig$4(config2, operator, field) || {};
  var reversedOp = operatorDef.reversedOp;
  var revOperatorDef = getOperatorConfig$4(config2, reversedOp, field) || {};
  var isRev = false;
  var fn = operatorDef.formatOp;
  if (!fn && reversedOp) {
    fn = revOperatorDef.formatOp;
    if (fn) {
      isRev = true;
      var _ref = [reversedOp, operator];
      operator = _ref[0];
      reversedOp = _ref[1];
      var _ref2 = [revOperatorDef, operatorDef];
      operatorDef = _ref2[0];
      revOperatorDef = _ref2[1];
    }
  }
  if (!fn)
    fn = buildFnToFormatOp4(operator, operatorDef);
  if (!fn)
    return void 0;
  var formattedField = formatField5(config2, meta, field, isForDisplay, parentField);
  var _formatItemValue = formatItemValue3(config2, properties, meta, operator, isForDisplay, parentField), _formatItemValue2 = _slicedToArray$1(_formatItemValue, 3), formattedValue = _formatItemValue2[0], valueSrc = _formatItemValue2[1], valueType = _formatItemValue2[2];
  if (formattedValue === void 0)
    return void 0;
  var args = [formattedField, operator, formattedValue, valueSrc, valueType, omit$1(operatorDef, ["formatOp", "mongoFormatOp", "sqlFormatOp", "jsonLogic", "spelFormatOp"]), operatorOptions, isForDisplay, fieldDef, isRev];
  if (returnArgs) {
    return args;
  } else {
    var ret = fn.apply(void 0, args);
    if (isRev) {
      ret = config2.settings.formatReverse(ret, operator, reversedOp, operatorDef, revOperatorDef, isForDisplay);
    }
    return ret;
  }
};
var formatValue5 = function formatValue6(config2, meta, value, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, opDef, isForDisplay) {
  var parentField = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : null;
  var asyncListValues = arguments.length > 11 ? arguments[11] : void 0;
  if (value === void 0)
    return void 0;
  var ret;
  if (valueSrc == "field") {
    ret = formatField5(config2, meta, value, isForDisplay, parentField);
  } else if (valueSrc == "func") {
    ret = formatFunc5(config2, meta, value, isForDisplay, parentField);
  } else {
    if (typeof fieldWidgetDef.formatValue === "function") {
      var fn = fieldWidgetDef.formatValue;
      var args = [
        value,
        _objectSpread$o(_objectSpread$o({}, pick$1(fieldDef, ["fieldSettings", "listValues"])), {}, {
          asyncListValues
        }),
        //useful options: valueFormat for date/time
        omit$1(fieldWidgetDef, ["formatValue", "mongoFormatValue", "sqlFormatValue", "jsonLogic", "elasticSearchFormatValue", "spelFormatValue"]),
        isForDisplay
      ];
      if (operator) {
        args.push(operator);
        args.push(opDef);
      }
      if (valueSrc == "field") {
        var valFieldDefinition = getFieldConfig$8(config2, value) || {};
        args.push(valFieldDefinition);
      }
      ret = fn.apply(void 0, args);
    } else {
      ret = value;
    }
  }
  return ret;
};
var formatField5 = function formatField6(config2, meta, field, isForDisplay) {
  var parentField = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
  var cutParentField = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
  var _config$settings2 = config2.settings, fieldSeparator = _config$settings2.fieldSeparator, fieldSeparatorDisplay = _config$settings2.fieldSeparatorDisplay;
  var ret = null;
  if (field) {
    var fieldDefinition = getFieldConfig$8(config2, field) || {};
    var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);
    getFieldPath$3(field, config2);
    var fieldPartsLabels = getFieldPathLabels$3(field, config2, cutParentField ? parentField : null);
    var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparatorDisplay) : null;
    var fieldLabel2 = fieldDefinition.label2 || fieldFullLabel;
    var formatFieldFn = config2.settings.formatField;
    var fieldName = formatFieldName$1(field, config2, meta, cutParentField ? parentField : null);
    ret = formatFieldFn(fieldName, fieldParts, fieldLabel2, fieldDefinition, config2, isForDisplay);
  }
  return ret;
};
var formatFunc5 = function formatFunc6(config2, meta, funcValue, isForDisplay) {
  var parentField = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
  var funcKey = funcValue.get("func");
  var args = funcValue.get("args");
  var funcConfig = getFuncConfig$2(config2, funcKey);
  var funcName = isForDisplay && funcConfig.label || funcKey;
  var formattedArgs = {};
  var formattedArgsWithNames = {};
  for (var argKey in funcConfig.args) {
    var argConfig = funcConfig.args[argKey];
    var fieldDef = getFieldConfig$8(config2, argConfig);
    var argVal = args ? args.get(argKey) : void 0;
    var argValue = argVal ? argVal.get("value") : void 0;
    var argValueSrc = argVal ? argVal.get("valueSrc") : void 0;
    var argAsyncListValues = argVal ? argVal.get("asyncListValues") : void 0;
    var formattedArgVal = formatValue5(config2, meta, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, isForDisplay, parentField, argAsyncListValues);
    var argName = isForDisplay && argConfig.label || argKey;
    if (formattedArgVal !== void 0) {
      formattedArgs[argKey] = formattedArgVal;
      formattedArgsWithNames[argName] = formattedArgVal;
    }
  }
  var ret = null;
  if (typeof funcConfig.formatFunc === "function") {
    var fn = funcConfig.formatFunc;
    var _args = [formattedArgs, isForDisplay];
    ret = fn.apply(void 0, _args);
  } else {
    var argsStr = Object.entries(formattedArgsWithNames).map(function(_ref3) {
      var _ref4 = _slicedToArray$1(_ref3, 2), k2 = _ref4[0], v2 = _ref4[1];
      return isForDisplay ? "".concat(k2, ": ").concat(v2) : "".concat(v2);
    }).join(", ");
    ret = "".concat(funcName, "(").concat(argsStr, ")");
  }
  return ret;
};
function ownKeys$n(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$n(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$n(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$n(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function buildEsGeoPoint(geoPointString) {
  if (geoPointString == null) {
    return null;
  }
  var coordsNumberArray = geoPointString.split(",").map(Number);
  return {
    top_left: {
      lat: coordsNumberArray[0],
      lon: coordsNumberArray[1]
    },
    bottom_right: {
      lat: coordsNumberArray[2],
      lon: coordsNumberArray[3]
    }
  };
}
function buildEsRangeParameters(value, operator) {
  if (value.length > 1) {
    return {
      gte: "".concat(value[0]),
      lte: "".concat(value[1])
    };
  }
  var dateTime = value[0];
  switch (operator) {
    case "on_date":
    case "not_on_date":
    case "equal":
    case "select_equals":
    case "not_equal":
      return {
        gte: "".concat(dateTime, "||/d"),
        lte: "".concat(dateTime, "||+1d")
      };
    case "less_or_equal":
      return {
        lte: "".concat(dateTime)
      };
    case "greater_or_equal":
      return {
        gte: "".concat(dateTime)
      };
    case "less":
      return {
        lt: "".concat(dateTime)
      };
    case "greater":
      return {
        gt: "".concat(dateTime)
      };
    default:
      return void 0;
  }
}
function buildEsWildcardParameters(value) {
  return {
    value: "*" + value + "*"
  };
}
function determineOccurrence(combinator, not) {
  switch (combinator) {
    case "AND":
      return not ? "must_not" : "must";
    case "OR":
      return not ? "should_not" : "should";
    case "NOT":
      return not ? "must" : "must_not";
    default:
      return void 0;
  }
}
function buildRegexpParameters(value) {
  return {
    value
  };
}
function determineField(fieldName, config2) {
  return fieldName;
}
function buildParameters(queryType, value, operator, fieldName, config2, syntax) {
  var textField = determineField(fieldName);
  switch (queryType) {
    case "filter":
      return {
        script: config2.operators[operator].elasticSearchScript(fieldName, value)
      };
    case "exists":
      return {
        field: fieldName
      };
    case "match":
      return _defineProperty$4({}, textField, value[0]);
    case "term":
      return syntax === ES_7_SYNTAX ? _defineProperty$4({}, fieldName, {
        value: value[0]
      }) : _defineProperty$4({}, fieldName, value[0]);
    case "geo_bounding_box":
      return _defineProperty$4({}, fieldName, buildEsGeoPoint(value[0]));
    case "range":
      return _defineProperty$4({}, fieldName, buildEsRangeParameters(value, operator));
    case "wildcard":
      return _defineProperty$4({}, fieldName, buildEsWildcardParameters(value[0]));
    case "regexp":
      return _defineProperty$4({}, fieldName, buildRegexpParameters(value[0]));
    default:
      return void 0;
  }
}
function buildEsRule(fieldName, value, operator, config2, valueSrc, syntax) {
  if (!fieldName || !operator || value == void 0)
    return void 0;
  var op = operator;
  var opConfig = config2.operators[op];
  if (!opConfig)
    return void 0;
  var _opConfig = opConfig, elasticSearchQueryType2 = _opConfig.elasticSearchQueryType;
  var not = false;
  if (!elasticSearchQueryType2 && opConfig.reversedOp) {
    not = true;
    op = opConfig.reversedOp;
    opConfig = config2.operators[op];
    var _opConfig2 = opConfig;
    elasticSearchQueryType2 = _opConfig2.elasticSearchQueryType;
  }
  var widget = getWidgetForFieldOp$3(config2, fieldName, op, valueSrc);
  var widgetConfig = config2.widgets[widget];
  if (!widgetConfig)
    return void 0;
  var elasticSearchFormatValue2 = widgetConfig.elasticSearchFormatValue;
  var queryType;
  if (typeof elasticSearchQueryType2 === "function") {
    queryType = elasticSearchQueryType2(widget);
  } else {
    queryType = elasticSearchQueryType2;
  }
  if (!queryType) {
    return void 0;
  }
  var parameters;
  if (typeof elasticSearchFormatValue2 === "function") {
    parameters = elasticSearchFormatValue2(queryType, value, op, fieldName, config2);
  } else {
    parameters = buildParameters(queryType, value, op, fieldName, config2, syntax);
  }
  if (not) {
    return {
      bool: {
        must_not: _defineProperty$4({}, queryType, _objectSpread$n({}, parameters))
      }
    };
  } else {
    return _defineProperty$4({}, queryType, _objectSpread$n({}, parameters));
  }
}
function buildEsGroup(children, conjunction, not, recursiveFxn, config2, syntax) {
  if (!children || !children.size)
    return void 0;
  var childrenArray = children.valueSeq().toArray();
  var occurrence = determineOccurrence(conjunction, not);
  var result = childrenArray.map(function(c2) {
    return recursiveFxn(c2, config2, syntax);
  }).filter(function(v2) {
    return v2 !== void 0;
  });
  if (!result.length)
    return void 0;
  var resultFlat = result.flat(Infinity);
  return {
    bool: _defineProperty$4({}, occurrence, resultFlat)
  };
}
var ES_7_SYNTAX = "ES_7_SYNTAX";
var ES_6_SYNTAX = "ES_6_SYNTAX";
function elasticSearchFormat(tree2, config2) {
  var syntax = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ES_6_SYNTAX;
  if (!tree2)
    return void 0;
  var type2 = tree2.get("type");
  var properties = tree2.get("properties") || /* @__PURE__ */ new Map();
  if (type2 === "rule" && properties.get("field")) {
    var _properties$get, _properties$get2;
    var operator = properties.get("operator");
    var field = properties.get("field");
    var value = properties.get("value").toJS();
    (_properties$get = properties.get("valueType")) === null || _properties$get === void 0 ? void 0 : _properties$get.get(0);
    var valueSrc = (_properties$get2 = properties.get("valueSrc")) === null || _properties$get2 === void 0 ? void 0 : _properties$get2.get(0);
    if (valueSrc === "func") {
      return;
    }
    if (value && Array.isArray(value[0])) {
      return value[0].map(function(val) {
        return buildEsRule(field, [val], operator, config2, valueSrc, syntax);
      });
    } else {
      return buildEsRule(field, value, operator, config2, valueSrc, syntax);
    }
  }
  if (type2 === "group" || type2 === "rule_group") {
    var not = properties.get("not");
    var conjunction = properties.get("conjunction");
    if (!conjunction)
      conjunction = defaultConjunction(config2);
    var children = tree2.get("children1");
    return buildEsGroup(children, conjunction, not, elasticSearchFormat, config2, syntax);
  }
}
const Export = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ES_6_SYNTAX,
  ES_7_SYNTAX,
  _mongodbFormat,
  _spelFormat,
  _sqlFormat,
  elasticSearchFormat,
  jsonLogicFormat,
  mongodbFormat,
  queryBuilderFormat,
  queryString,
  spelFormat,
  sqlFormat
}, Symbol.toStringTag, { value: "Module" }));
var getTree = function getTree2(immutableTree) {
  var light = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var children1AsArray = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  if (!immutableTree)
    return void 0;
  var tree2 = immutableTree;
  tree2 = tree2.toJS();
  if (light)
    tree2 = getLightTree(tree2, children1AsArray);
  return tree2;
};
var loadTree = function loadTree2(serTree) {
  if (isImmutableTree(serTree)) {
    return serTree;
  } else if (isTree(serTree)) {
    return jsTreeToImmutable(serTree);
  } else if (typeof serTree == "string" && serTree.startsWith('["~#iM"')) {
    throw "You are trying to load query in obsolete serialization format (Immutable string) which is not supported in versions starting from 2.1.17";
  } else if (typeof serTree == "string") {
    return jsTreeToImmutable(JSON.parse(serTree));
  } else
    throw "Can't load tree!";
};
var checkTree = function checkTree2(tree2, config2) {
  if (!tree2)
    return void 0;
  var extendedConfig = extendConfig$1(config2);
  return validateTree(tree2, null, extendedConfig, extendedConfig);
};
var isValidTree = function isValidTree2(tree2) {
  return getTreeBadFields(tree2).length == 0;
};
var isImmutableTree = function isImmutableTree2(tree2) {
  return immutableExports.Map.isMap(tree2);
};
var isTree = function isTree2(tree2) {
  return _typeof$2(tree2) == "object" && (tree2.type == "group" || tree2.type == "switch_group");
};
function jsTreeToImmutable(tree2) {
  return immutableExports.fromJS(tree2, function(key, value) {
    var outValue;
    if (key == "properties") {
      outValue = value.toOrderedMap();
      for (var i2 = 0; i2 < 2; i2++) {
        var _outValue$get;
        if (((_outValue$get = outValue.get("value")) === null || _outValue$get === void 0 ? void 0 : _outValue$get.get(i2)) === null) {
          outValue = outValue.setIn(["value", i2], void 0);
        }
      }
    } else if (key == "value" && value.get(0) && value.get(0).toJS !== void 0) {
      var valueJs = value.get(0).toJS();
      if (valueJs.func) {
        outValue = value.toOrderedMap();
      } else {
        outValue = Immutable.List.of(valueJs);
      }
    } else if (key == "asyncListValues") {
      outValue = value.toJS();
    } else if (key == "children1" && Immutable.Iterable.isIndexed(value)) {
      outValue = new Immutable.OrderedMap(value.map(function(child) {
        return [child.get("id"), child];
      }));
    } else {
      outValue = Immutable.Iterable.isIndexed(value) ? value.toList() : value.toOrderedMap();
    }
    return outValue;
  });
}
function ownKeys$m(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$m(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$m(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$m(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var arrayUniq = function arrayUniq2(arr) {
  return Array.from(new Set(arr));
};
var loadFromJsonLogic = function loadFromJsonLogic2(logicTree, config2) {
  return _loadFromJsonLogic(logicTree, config2, false);
};
var _loadFromJsonLogic = function _loadFromJsonLogic2(logicTree, config2) {
  var returnErrors = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var meta = {
    errors: []
  };
  var extendedConfig = extendConfig$1(config2);
  var conv = buildConv$1(extendedConfig);
  var jsTree = logicTree ? convertFromLogic(logicTree, conv, extendedConfig, "rule", meta) : void 0;
  if (jsTree && jsTree.type != "group") {
    jsTree = wrapInDefaultConj$1(jsTree, extendedConfig);
  }
  var immTree = jsTree ? loadTree(jsTree) : void 0;
  if (returnErrors) {
    return [immTree, meta.errors];
  } else {
    if (meta.errors.length)
      console.warn("Errors while importing from JsonLogic:", meta.errors);
    return immTree;
  }
};
var buildConv$1 = function buildConv(config2) {
  var operators2 = {};
  for (var opKey in config2.operators) {
    var opConfig = config2.operators[opKey];
    if (typeof opConfig.jsonLogic == "string") {
      var opk = (opConfig._jsonLogicIsRevArgs ? "#" : "") + opConfig.jsonLogic + "/" + defaultValue$1(opConfig.cardinality, 1);
      if (!operators2[opk])
        operators2[opk] = [];
      operators2[opk].push(opKey);
    } else if (typeof opConfig.jsonLogic2 == "string") {
      var _opk = opConfig.jsonLogic2 + "/" + defaultValue$1(opConfig.cardinality, 1);
      if (!operators2[_opk])
        operators2[_opk] = [];
      operators2[_opk].push(opKey);
    }
  }
  var conjunctions2 = {};
  for (var conjKey in config2.conjunctions) {
    var conjunctionDefinition = config2.conjunctions[conjKey];
    var ck = conjunctionDefinition.jsonLogicConj || conjKey.toLowerCase();
    conjunctions2[ck] = conjKey;
  }
  var funcs2 = {};
  for (var funcKey in config2.funcs) {
    var funcConfig = config2.funcs[funcKey];
    var fk = void 0;
    if (funcConfig.jsonLogicIsMethod) {
      fk = "#" + funcConfig.jsonLogic;
    } else if (typeof funcConfig.jsonLogic == "string") {
      fk = funcConfig.jsonLogic;
    }
    if (fk) {
      if (!funcs2[fk])
        funcs2[fk] = [];
      funcs2[fk].push(funcKey);
    }
  }
  var _config$settings$json = config2.settings.jsonLogic, groupVarKey = _config$settings$json.groupVarKey, altVarKey = _config$settings$json.altVarKey;
  return {
    operators: operators2,
    conjunctions: conjunctions2,
    funcs: funcs2,
    varKeys: ["var", groupVarKey, altVarKey]
  };
};
var convertFromLogic = function convertFromLogic2(logic, conv, config2, expectedType, meta) {
  var not = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
  var fieldConfig = arguments.length > 6 ? arguments[6] : void 0;
  var widget = arguments.length > 7 ? arguments[7] : void 0;
  var parentField = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : null;
  var op, vals;
  if (isJsonLogic(logic)) {
    op = Object.keys(logic)[0];
    vals = logic[op];
    if (!Array.isArray(vals))
      vals = [vals];
  }
  var ret;
  var beforeErrorsCnt = meta.errors.length;
  var lockedOp = config2.settings.jsonLogic.lockedOp;
  var isEmptyOp = op == "!" && vals.length == 1 && vals[0] && isJsonLogic(vals[0]) && conv.varKeys.includes(Object.keys(vals[0])[0]);
  var isRev = op == "!" && !isEmptyOp;
  var isLocked = lockedOp && op == lockedOp;
  if (isLocked) {
    ret = convertFromLogic2(vals[0], conv, config2, expectedType, meta, not, fieldConfig, widget, parentField, true);
  } else if (isRev) {
    ret = convertFromLogic2(vals[0], conv, config2, expectedType, meta, !not, fieldConfig, widget, parentField);
  } else if (expectedType == "val") {
    ret = convertField(op, vals, conv, config2, not, meta, parentField) || convertFunc(op, vals, conv, config2, not, fieldConfig, meta, parentField) || convertVal(logic, fieldConfig, widget, config2, meta);
  } else if (expectedType == "rule") {
    ret = convertConj(op, vals, conv, config2, not, meta, parentField, false) || convertOp(op, vals, conv, config2, not, meta, parentField);
  }
  var afterErrorsCnt = meta.errors.length;
  if (op != "!" && ret === void 0 && afterErrorsCnt == beforeErrorsCnt) {
    meta.errors.push("Can't parse logic ".concat(JSON.stringify(logic)));
  }
  if (isLocked) {
    ret.properties.isLocked = true;
  }
  return ret;
};
var convertVal = function convertVal2(val, fieldConfig, widget, config2, meta) {
  if (val === void 0)
    return void 0;
  var widgetConfig = config2.widgets[widget || fieldConfig.mainWidget];
  if (!widgetConfig) {
    meta.errors.push("No widget for type ".concat(fieldConfig.type));
    return void 0;
  }
  if (isJsonLogic(val)) {
    meta.errors.push("Unexpected logic in value: ".concat(JSON.stringify(val)));
    return void 0;
  }
  if (fieldConfig && fieldConfig.type == "time" && typeof val == "number") {
    var h2 = Math.floor(val / 60 / 60) % 24, m2 = Math.floor(val / 60) % 60, s2 = val % 60;
    var valueFormat = widgetConfig.valueFormat;
    if (valueFormat) {
      var dateVal = new Date(val);
      dateVal.setMilliseconds(0);
      dateVal.setHours(h2);
      dateVal.setMinutes(m2);
      dateVal.setSeconds(s2);
      val = hooks(dateVal).format(valueFormat);
    } else {
      val = "".concat(h2, ":").concat(m2, ":").concat(s2);
    }
  }
  if (fieldConfig && ["date", "datetime"].includes(fieldConfig.type) && val && !(val instanceof Date)) {
    try {
      var _dateVal = new Date(val);
      if (_dateVal instanceof Date && _dateVal.toISOString() === val) {
        val = _dateVal;
      }
    } catch (e2) {
      meta.errors.push("Can't convert value ".concat(val, " as Date"));
      val = void 0;
    }
  }
  if (val instanceof Date && fieldConfig) {
    var _valueFormat = widgetConfig.valueFormat;
    if (_valueFormat) {
      val = hooks(val).format(_valueFormat);
    }
  }
  var asyncListValues;
  if (val && fieldConfig.fieldSettings && fieldConfig.fieldSettings.asyncFetch) {
    var vals = Array.isArray(val) ? val : [val];
    asyncListValues = vals;
  }
  return {
    valueSrc: "value",
    value: val,
    valueType: widgetConfig.type,
    asyncListValues
  };
};
var convertField = function convertField2(op, vals, conv, config2, not, meta) {
  var parentField = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null;
  var fieldSeparator = config2.settings.fieldSeparator;
  if (conv.varKeys.includes(op) && typeof vals[0] == "string") {
    var field = vals[0];
    if (parentField)
      field = [parentField, field].join(fieldSeparator);
    field = normalizeField(config2, field);
    var fieldConfig = getFieldConfig$8(config2, field);
    if (!fieldConfig) {
      meta.errors.push("No config for field ".concat(field));
      return void 0;
    }
    return {
      valueSrc: "field",
      value: field,
      valueType: fieldConfig.type
    };
  }
  return void 0;
};
var convertFunc = function convertFunc2(op, vals, conv, config2, not, fieldConfig, meta) {
  var parentField = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null;
  if (!op)
    return void 0;
  var func, argsArr, funcKey;
  var jsonLogicIsMethod = op == "method";
  if (jsonLogicIsMethod) {
    var obj, opts;
    var _vals = _toArray(vals);
    obj = _vals[0];
    func = _vals[1];
    opts = _vals.slice(2);
    argsArr = [obj].concat(_toConsumableArray(opts));
  } else {
    func = op;
    argsArr = vals;
  }
  var fk = (jsonLogicIsMethod ? "#" : "") + func;
  var funcKeys = (conv.funcs[fk] || []).filter(function(k2) {
    return fieldConfig ? config2.funcs[k2].returnType == fieldConfig.type : true;
  });
  if (funcKeys.length) {
    funcKey = funcKeys[0];
  } else {
    var v2 = _defineProperty$4({}, op, vals);
    for (var _i = 0, _Object$entries = Object.entries(config2.funcs || {}); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray$1(_Object$entries[_i], 2), f2 = _Object$entries$_i[0], fc = _Object$entries$_i[1];
      if (fc.jsonLogicImport && fc.returnType == fieldConfig.type) {
        var parsed = void 0;
        try {
          parsed = fc.jsonLogicImport(v2);
        } catch (_e) {
        }
        if (parsed) {
          funcKey = f2;
          argsArr = parsed;
        }
      }
    }
  }
  if (!funcKey)
    return void 0;
  if (funcKey) {
    var funcConfig = config2.funcs[funcKey];
    var argKeys = Object.keys(funcConfig.args || {});
    var args = argsArr.reduce(function(acc, val, ind) {
      var argKey = argKeys[ind];
      var argConfig = funcConfig.args[argKey];
      var argVal = convertFromLogic(val, conv, config2, "val", meta, false, argConfig, null, parentField);
      if (argVal === void 0) {
        argVal = argConfig.defaultValue;
        if (argVal === void 0) {
          meta.errors.push("No value for arg ".concat(argKey, " of func ").concat(funcKey));
          return void 0;
        }
      }
      return _objectSpread$m(_objectSpread$m({}, acc), {}, _defineProperty$4({}, argKey, argVal));
    }, {});
    return {
      valueSrc: "func",
      value: {
        func: funcKey,
        args
      },
      valueType: funcConfig.returnType
    };
  }
  return void 0;
};
var convertConj = function convertConj2(op, vals, conv, config2, not, meta) {
  var parentField = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null;
  var conjKey = conv.conjunctions[op];
  var fieldSeparator = config2.settings.fieldSeparator;
  var parentFieldConfig = parentField ? getFieldConfig$8(config2, parentField) : null;
  (parentFieldConfig === null || parentFieldConfig === void 0 ? void 0 : parentFieldConfig.type) == "!group";
  if (conjKey) {
    var type2 = "group";
    var children = vals.map(function(v2) {
      return convertFromLogic(v2, conv, config2, "rule", meta, false, null, null, parentField);
    }).filter(function(r2) {
      return r2 !== void 0;
    }).reduce(function(acc, r2) {
      return _objectSpread$m(_objectSpread$m({}, acc), {}, _defineProperty$4({}, r2.id, r2));
    }, {});
    var complexFields = Object.values(children).map(function(v2) {
      var _v$properties;
      return v2 === null || v2 === void 0 ? void 0 : (_v$properties = v2.properties) === null || _v$properties === void 0 ? void 0 : _v$properties.field;
    }).filter(function(f2) {
      return f2 && f2.includes(fieldSeparator);
    });
    var complexFieldsGroupAncestors = Object.fromEntries(arrayUniq(complexFields).map(function(f2) {
      var parts = f2.split(fieldSeparator);
      var ancs = Object.fromEntries(parts.slice(0, -1).map(function(f3, i2, parts2) {
        return [].concat(_toConsumableArray(parts2.slice(0, i2)), [f3]);
      }).map(function(fp) {
        return [fp.join(fieldSeparator), getFieldConfig$8(config2, fp)];
      }).filter(function(_ref3) {
        var _ref4 = _slicedToArray$1(_ref3, 2);
        _ref4[0];
        var fc = _ref4[1];
        return fc.type == "!group";
      }));
      return [f2, Object.keys(ancs)];
    }));
    Object.values(children).map(function(v2) {
      var _v$properties2;
      return v2 === null || v2 === void 0 ? void 0 : (_v$properties2 = v2.properties) === null || _v$properties2 === void 0 ? void 0 : _v$properties2.field;
    }).map(function(f2) {
      return complexFieldsGroupAncestors[f2];
    }).filter(function(ancs) {
      return ancs && ancs.length;
    });
    var usedRuleGroups = arrayUniq(Object.values(complexFieldsGroupAncestors).flat());
    topLevelFieldsFilter(usedRuleGroups);
    var properties = {
      conjunction: conjKey,
      not
    };
    var id = uuid$1();
    var children1 = {};
    var groupToId = {};
    Object.entries(children).map(function(_ref5) {
      var _ref6 = _slicedToArray$1(_ref5, 2), k2 = _ref6[0], v2 = _ref6[1];
      if (v2.type == "group" || v2.type == "rule_group") {
        children1[k2] = v2;
      } else {
        var _v$properties3;
        var field = v2 === null || v2 === void 0 ? void 0 : (_v$properties3 = v2.properties) === null || _v$properties3 === void 0 ? void 0 : _v$properties3.field;
        var groupAncestors = complexFieldsGroupAncestors[field];
        var groupField = groupAncestors === null || groupAncestors === void 0 ? void 0 : groupAncestors.at(-1);
        if (!groupField) {
          children1[k2] = v2;
        } else {
          var ch = children1;
          var parentFieldParts = parentField ? parentField.split(fieldSeparator) : [];
          var isInParent = shallowEqual$2(parentFieldParts, groupField.split(fieldSeparator).slice(0, parentFieldParts.length));
          if (!isInParent)
            parentFieldParts = [];
          var traverseGroupFields = groupField.split(fieldSeparator).slice(parentFieldParts.length).map(function(f2, i2, parts) {
            return [].concat(_toConsumableArray(parentFieldParts), _toConsumableArray(parts.slice(0, i2)), [f2]).join(fieldSeparator);
          }).map(function(f2) {
            return normalizeField(config2, f2);
          }).map(function(f2) {
            return {
              f: f2,
              fc: getFieldConfig$8(config2, f2) || {}
            };
          }).filter(function(_ref7) {
            var fc = _ref7.fc;
            return fc.type != "!struct";
          });
          traverseGroupFields.map(function(_ref8, i2) {
            var gf = _ref8.f, gfc = _ref8.fc;
            var groupId = groupToId[gf];
            if (!groupId) {
              groupId = uuid$1();
              groupToId[gf] = groupId;
              ch[groupId] = {
                type: "rule_group",
                id: groupId,
                children1: {},
                properties: {
                  conjunction: conjKey,
                  not: false,
                  field: gf,
                  mode: gfc.mode
                }
              };
            }
            ch = ch[groupId].children1;
          });
          ch[k2] = v2;
        }
      }
    });
    return {
      type: type2,
      id,
      children1,
      properties
    };
  }
  return void 0;
};
var topLevelFieldsFilter = function topLevelFieldsFilter2(fields) {
  var arr = _toConsumableArray(fields).sort(function(a2, b2) {
    return a2.length - b2.length;
  });
  for (var i2 = 0; i2 < arr.length; i2++) {
    for (var j = i2 + 1; j < arr.length; j++) {
      if (arr[j].indexOf(arr[i2]) == 0) {
        arr.splice(j, 1);
        j--;
      }
    }
  }
  return arr;
};
var wrapInDefaultConjRuleGroup = function wrapInDefaultConjRuleGroup2(rule3, parentField, parentFieldConfig, config2, conj) {
  if (!rule3)
    return void 0;
  return {
    type: "rule_group",
    id: uuid$1(),
    children1: _defineProperty$4({}, rule3.id, rule3),
    properties: {
      conjunction: conj || defaultGroupConjunction$1(config2, parentFieldConfig),
      not: false,
      field: parentField
    }
  };
};
var wrapInDefaultConj$1 = function wrapInDefaultConj(rule3, config2) {
  var not = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  return {
    type: "group",
    id: uuid$1(),
    children1: _defineProperty$4({}, rule3.id, rule3),
    properties: {
      conjunction: defaultConjunction(config2),
      not
    }
  };
};
var parseRule = function parseRule2(op, arity, vals, parentField, conv, config2, meta) {
  var errors = [];
  var res = _parseRule(op, arity, vals, parentField, conv, config2, errors, false) || _parseRule(op, arity, vals, parentField, conv, config2, errors, true);
  if (!res) {
    meta.errors.push(errors.join("; ") || "Unknown op ".concat(op, "/").concat(arity));
    return void 0;
  }
  return res;
};
var _parseRule = function _parseRule2(op, arity, vals, parentField, conv, config2, errors, isRevArgs) {
  var isAllOrSomeInForMultiselect = (op == "all" || op == "some") && isJsonLogic(vals[1]) && Object.keys(vals[1])[0] == "in";
  var isGroup0 = !isAllOrSomeInForMultiselect && config2.settings.groupOperators.includes(op);
  var eqOps = ["==", "!="];
  var cardinality = isGroup0 ? 0 : arity - 1;
  if (isGroup0)
    cardinality = 0;
  else if (eqOps.includes(op) && cardinality == 1 && vals[1] === null) {
    arity = 1;
    cardinality = 0;
    vals = [vals[0]];
  }
  var opk = op + "/" + cardinality;
  var fieldSeparator = config2.settings.fieldSeparator;
  var opKeys = conv.operators[(isRevArgs ? "#" : "") + opk];
  if (!opKeys)
    return;
  var jlField, args = [];
  var rangeOps = ["<", "<=", ">", ">="];
  if (rangeOps.includes(op) && arity == 3) {
    jlField = vals[1];
    args = [vals[0], vals[2]];
  } else if (isRevArgs) {
    jlField = vals[1];
    args = [vals[0]];
  } else {
    var _vals2 = vals;
    var _vals3 = _toArray(_vals2);
    jlField = _vals3[0];
    args = _vals3.slice(1);
  }
  if (!isJsonLogic(jlField)) {
    errors.push("Incorrect operands for ".concat(op, ": ").concat(JSON.stringify(vals)));
    return;
  }
  var k2 = Object.keys(jlField)[0];
  var v2 = Object.values(jlField)[0];
  var field, having;
  if (conv.varKeys.includes(k2) && typeof v2 == "string") {
    field = v2;
  }
  if (isGroup0) {
    having = args[0];
    args = [];
  }
  if (k2 == "reduce" && Array.isArray(v2) && v2.length == 3) {
    var _v2 = v2, _v3 = _slicedToArray$1(_v2, 3), filter = _v3[0], acc = _v3[1], init = _v3[2];
    if (isJsonLogic(filter) && init == 0 && isJsonLogic(acc) && Array.isArray(acc["+"]) && acc["+"][0] == 1 && isJsonLogic(acc["+"][1]) && acc["+"][1]["var"] == "accumulator") {
      k2 = Object.keys(filter)[0];
      v2 = Object.values(filter)[0];
      if (k2 == "filter") {
        var _v4 = v2, _v5 = _slicedToArray$1(_v4, 2), group3 = _v5[0], _filter = _v5[1];
        if (isJsonLogic(group3)) {
          k2 = Object.keys(group3)[0];
          v2 = Object.values(group3)[0];
          if (conv.varKeys.includes(k2) && typeof v2 == "string") {
            field = v2;
            having = _filter;
          }
        }
      } else if (conv.varKeys.includes(k2) && typeof v2 == "string") {
        field = v2;
      }
    }
  }
  if (!field) {
    errors.push("Unknown field ".concat(JSON.stringify(jlField)));
    return;
  }
  if (parentField)
    field = [parentField, field].join(fieldSeparator);
  field = normalizeField(config2, field);
  var fieldConfig = getFieldConfig$8(config2, field);
  if (!fieldConfig) {
    errors.push("No config for field ".concat(field));
    return;
  }
  var opKey = opKeys[0];
  if (opKeys.length > 1 && fieldConfig && fieldConfig.operators) {
    opKeys = opKeys.filter(function(k3) {
      return fieldConfig.operators.includes(k3);
    });
    if (opKeys.length == 0) {
      errors.push("No corresponding ops for field ".concat(field));
      return;
    }
    opKey = opKeys[0];
  }
  return {
    field,
    fieldConfig,
    opKey,
    args,
    having
  };
};
var convertOp = function convertOp2(op, vals, conv, config2, not, meta) {
  var parentField = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null;
  if (!op)
    return void 0;
  var arity = vals.length;
  if ((op == "all" || op == "some") && isJsonLogic(vals[1])) {
    var op2 = Object.keys(vals[1])[0];
    if (op2 == "in") {
      vals = [vals[0], vals[1][op2][1]];
      op = op + "-" + op2;
    }
  }
  var parseRes = parseRule(op, arity, vals, parentField, conv, config2, meta);
  if (!parseRes)
    return void 0;
  var field = parseRes.field, fieldConfig = parseRes.fieldConfig, opKey = parseRes.opKey, args = parseRes.args, having = parseRes.having;
  var opConfig = config2.operators[opKey];
  fieldConfig.showNot !== void 0 ? fieldConfig.showNot : config2.settings.showNot;
  var canRev = true;
  var conj;
  var havingVals;
  var havingNot = false;
  if (fieldConfig.type == "!group" && having) {
    conj = Object.keys(having)[0];
    havingVals = having[conj];
    if (!Array.isArray(havingVals))
      havingVals = [havingVals];
    var isEmptyOp = conj == "!" && havingVals.length == 1 && havingVals[0] && isJsonLogic(havingVals[0]) && conv.varKeys.includes(Object.keys(havingVals[0])[0]);
    if (conj == "!" && !isEmptyOp) {
      havingNot = true;
      having = having["!"];
      conj = Object.keys(having)[0];
      havingVals = having[conj];
      if (!Array.isArray(havingVals))
        havingVals = [havingVals];
    }
  }
  if (not && canRev && opConfig.reversedOp) {
    not = false;
    opKey = opConfig.reversedOp;
    opConfig = config2.operators[opKey];
  }
  var widget = getWidgetForFieldOp$3(config2, field, opKey);
  var convertedArgs = args.map(function(v2) {
    return convertFromLogic(v2, conv, config2, "val", meta, false, fieldConfig, widget, parentField);
  });
  if (convertedArgs.filter(function(v2) {
    return v2 === void 0;
  }).length) {
    return void 0;
  }
  var res;
  if (fieldConfig.type == "!group" && having) {
    if (conv.conjunctions[conj] !== void 0) {
      res = convertConj(conj, havingVals, conv, config2, havingNot, meta, field, true);
      havingNot = false;
    } else {
      var rule3 = convertOp2(conj, havingVals, conv, config2, havingNot, meta, field);
      havingNot = false;
      res = wrapInDefaultConjRuleGroup(rule3, field, fieldConfig, config2, conv.conjunctions["and"]);
    }
    if (!res)
      return void 0;
    res.type = "rule_group";
    Object.assign(res.properties, {
      field,
      mode: fieldConfig.mode,
      operator: opKey
    });
    if (fieldConfig.mode == "array") {
      Object.assign(res.properties, {
        value: convertedArgs.map(function(v2) {
          return v2.value;
        }),
        valueSrc: convertedArgs.map(function(v2) {
          return v2.valueSrc;
        }),
        valueType: convertedArgs.map(function(v2) {
          return v2.valueType;
        })
      });
    }
    if (not) {
      res = wrapInDefaultConj$1(res, config2, not);
    }
  } else if (fieldConfig.type == "!group" && !having) {
    res = {
      type: "rule_group",
      id: uuid$1(),
      children1: {},
      properties: {
        conjunction: defaultGroupConjunction$1(config2, fieldConfig),
        not,
        mode: fieldConfig.mode,
        field,
        operator: opKey
      }
    };
    if (fieldConfig.mode == "array") {
      Object.assign(res.properties, {
        value: convertedArgs.map(function(v2) {
          return v2.value;
        }),
        valueSrc: convertedArgs.map(function(v2) {
          return v2.valueSrc;
        }),
        valueType: convertedArgs.map(function(v2) {
          return v2.valueType;
        })
      });
    }
  } else {
    var asyncListValuesArr = convertedArgs.map(function(v2) {
      return v2.asyncListValues;
    }).filter(function(v2) {
      return v2 != void 0;
    });
    var asyncListValues = asyncListValuesArr.length ? asyncListValuesArr[0] : void 0;
    res = {
      type: "rule",
      id: uuid$1(),
      properties: {
        field,
        operator: opKey,
        value: convertedArgs.map(function(v2) {
          return v2.value;
        }),
        valueSrc: convertedArgs.map(function(v2) {
          return v2.valueSrc;
        }),
        valueType: convertedArgs.map(function(v2) {
          return v2.valueType;
        }),
        asyncListValues
      }
    };
    if (not) {
      res = wrapInDefaultConj$1(res, config2, not);
    }
  }
  return res;
};
var spel2js = { exports: {} };
(function(module2, exports2) {
  (function webpackUniversalModuleDefinition(root2, factory26) {
    module2.exports = factory26();
  })(commonjsGlobal, function() {
    return (
      /******/
      function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          var module3 = installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {}
            /******/
          };
          modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
          module3.l = true;
          return module3.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports3, name, getter) {
          if (!__webpack_require__.o(exports3, name)) {
            Object.defineProperty(exports3, name, {
              /******/
              configurable: false,
              /******/
              enumerable: true,
              /******/
              get: getter
              /******/
            });
          }
        };
        __webpack_require__.n = function(module3) {
          var getter = module3 && module3.__esModule ? (
            /******/
            function getDefault() {
              return module3["default"];
            }
          ) : (
            /******/
            function getModuleExports() {
              return module3;
            }
          );
          __webpack_require__.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__.o = function(object, property2) {
          return Object.prototype.hasOwnProperty.call(object, property2);
        };
        __webpack_require__.p = "";
        return __webpack_require__(__webpack_require__.s = 3);
      }([
        /* 0 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          function createSpelNode(nodeType, position) {
            var node = {}, type2 = nodeType || "Abstract", children = [], parent2 = null, activeContext;
            node._type = type2;
            node.getType = function() {
              return type2;
            };
            node.setType = function(nodeType2) {
              type2 = nodeType2;
            };
            node.getChildren = function() {
              return children;
            };
            node.addChild = function(childNode) {
              if (!childNode) {
                return;
              }
              if (!childNode.setParent) {
                throw {
                  name: "Error",
                  message: "Trying to add a child which is not a node: " + JSON.stringify(childNode)
                };
              }
              childNode.setParent(node);
              children.push(childNode);
            };
            node.getParent = function() {
              return parent2;
            };
            node.setParent = function(parentNode) {
              parent2 = parentNode;
            };
            node.getContext = function(state) {
              return activeContext || state.activeContext.peek();
            };
            node.setContext = function(nodeContext) {
              activeContext = nodeContext;
            };
            node.getStartPosition = function() {
              return position >> 16;
            };
            node.getEndPosition = function() {
              return position & 65535;
            };
            node.getValue = function() {
              throw {
                name: "MethodNotImplementedException",
                message: "SpelNode#getValue() must be overridden."
              };
            };
            node.toString = function() {
              var s2 = "Kind: " + node.getType();
              s2 += ", Children: [";
              for (var i2 = 0, l2 = node.getChildren().length; i2 < l2; i2 += 1) {
                s2 += "{" + node.getChildren()[i2] + "}, ";
              }
              s2 += "]";
              return s2;
            };
            if (position === 0) {
              throw {
                name: "Error",
                message: "Position cannot be 0"
              };
            }
            for (var _len = arguments.length, operands = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              operands[_key - 2] = arguments[_key];
            }
            if (operands) {
              operands.forEach(function(operand) {
                node.addChild(operand);
              });
            }
            return node;
          }
          exports3.SpelNode = {
            create: createSpelNode
          };
        },
        /* 1 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.Stack = Stack2;
          function Stack2(startingElements) {
            this.elements = startingElements || [];
          }
          Stack2.prototype.push = function(el) {
            this.elements.push(el);
            return el;
          };
          Stack2.prototype.pop = function() {
            return this.elements.pop();
          };
          Stack2.prototype.peek = function() {
            return this.elements[this.elements.length - 1];
          };
          Stack2.prototype.empty = function() {
            return this.elements.length > 0;
          };
          Stack2.prototype.search = function(el) {
            return this.elements.length - this.elements.indexOf(el);
          };
        },
        /* 2 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var types2 = {
            LITERAL_INT: 1,
            //tested
            LITERAL_LONG: 2,
            //tested
            LITERAL_HEXINT: 3,
            //tested
            LITERAL_HEXLONG: 4,
            //tested
            LITERAL_STRING: 5,
            //tested
            LITERAL_REAL: 6,
            //tested
            LITERAL_REAL_FLOAT: 7,
            //tested
            LPAREN: "(",
            //tested
            RPAREN: ")",
            //tested
            COMMA: ",",
            //tested
            IDENTIFIER: 0,
            //tested
            COLON: ":",
            //tested
            HASH: "#",
            //tested
            RSQUARE: "]",
            //tested
            LSQUARE: "[",
            //tested
            LCURLY: "{",
            //tested
            RCURLY: "}",
            //tested
            DOT: ".",
            //tested
            PLUS: "+",
            //tested
            STAR: "*",
            //tested
            MINUS: "-",
            //tested
            SELECT_FIRST: "^[",
            //tested
            SELECT_LAST: "$[",
            //tested
            QMARK: "?",
            //tested
            PROJECT: "![",
            //tested
            DIV: "/",
            //tested
            GE: ">=",
            //tested
            GT: ">",
            //tested
            LE: "<=",
            //tested
            LT: "<",
            //tested
            EQ: "==",
            //tested
            NE: "!=",
            //tested
            MOD: "%",
            //tested
            NOT: "!",
            //tested
            ASSIGN: "=",
            //tested
            INSTANCEOF: "instanceof",
            //test fails
            MATCHES: "matches",
            //test fails
            BETWEEN: "between",
            //test fails
            SELECT: "?[",
            //tested
            POWER: "^",
            //tested
            ELVIS: "?:",
            //tested
            SAFE_NAVI: "?.",
            //tested
            BEAN_REF: "@",
            //tested
            SYMBOLIC_OR: "||",
            //tested
            SYMBOLIC_AND: "&&",
            //tested
            INC: "++",
            //tested
            DEC: "--"
            //tested
          };
          function TokenKind(type2) {
            this.type = type2;
            this.tokenChars = types2[type2];
            this._hasPayload = typeof types2[type2] !== "string";
            if (typeof types2[type2] === "number") {
              this._ordinal = types2[type2];
            }
          }
          for (var t2 in types2) {
            if (types2.hasOwnProperty(t2)) {
              TokenKind[t2] = new TokenKind(t2);
            }
          }
          TokenKind.prototype.toString = function() {
            return this.type + (this.tokenChars.length !== 0 ? "(" + this.tokenChars + ")" : "");
          };
          TokenKind.prototype.getLength = function() {
            return this.tokenChars.length;
          };
          TokenKind.prototype.hasPayload = function() {
            return this._hasPayload;
          };
          TokenKind.prototype.valueOf = function(id) {
            for (var t3 in types2) {
              if (types2.hasOwnProperty(t3) && types2[t3] === id) {
                return TokenKind[t3];
              }
            }
          };
          TokenKind.prototype.ordinal = function() {
            return this._ordinal;
          };
          exports3.TokenKind = TokenKind;
        },
        /* 3 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.StandardContext = exports3.SpelExpressionEvaluator = void 0;
          var _SpelExpressionEvaluator = __webpack_require__(4);
          var _StandardContext = __webpack_require__(50);
          exports3.SpelExpressionEvaluator = _SpelExpressionEvaluator.SpelExpressionEvaluator;
          exports3.StandardContext = _StandardContext.StandardContext;
        },
        /* 4 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.SpelExpressionEvaluator = void 0;
          var _SpelExpressionParser = __webpack_require__(5);
          var _Stack2 = __webpack_require__(1);
          var spelExpressionEvaluator = {};
          function evalCompiled(compiledExpression, context2, locals) {
            var activeContext = new _Stack2.Stack(), state;
            if (!context2) {
              context2 = {};
            }
            activeContext.push(context2);
            state = {
              rootContext: context2,
              activeContext,
              locals
            };
            return compiledExpression.getValue(state);
          }
          spelExpressionEvaluator.compile = function(expression) {
            var compiledExpression = (0, _SpelExpressionParser.SpelExpressionParser)().parse(expression);
            return {
              eval: function _eval(context2, locals) {
                return evalCompiled(compiledExpression, context2, locals);
              },
              _compiledExpression: compiledExpression
            };
          };
          spelExpressionEvaluator.eval = function(expression, context2, locals) {
            return spelExpressionEvaluator.compile(expression).eval(context2, locals);
          };
          exports3.SpelExpressionEvaluator = spelExpressionEvaluator;
        },
        /* 5 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.SpelExpressionParser = void 0;
          var _TokenKind = __webpack_require__(2);
          var _Tokenizer = __webpack_require__(6);
          var _BooleanLiteral = __webpack_require__(8);
          var _NumberLiteral = __webpack_require__(9);
          var _StringLiteral = __webpack_require__(10);
          var _NullLiteral = __webpack_require__(11);
          var _FunctionReference = __webpack_require__(12);
          var _MethodReference = __webpack_require__(13);
          var _PropertyReference = __webpack_require__(14);
          var _VariableReference = __webpack_require__(15);
          var _CompoundExpression = __webpack_require__(16);
          var _Indexer = __webpack_require__(17);
          var _Assign = __webpack_require__(18);
          var _OpEQ = __webpack_require__(19);
          var _OpNE = __webpack_require__(20);
          var _OpGE = __webpack_require__(21);
          var _OpGT = __webpack_require__(22);
          var _OpLE = __webpack_require__(23);
          var _OpLT = __webpack_require__(24);
          var _OpPlus = __webpack_require__(25);
          var _OpMinus = __webpack_require__(26);
          var _OpMultiply = __webpack_require__(27);
          var _OpDivide = __webpack_require__(28);
          var _OpModulus = __webpack_require__(29);
          var _OpPower = __webpack_require__(30);
          var _OpInc = __webpack_require__(31);
          var _OpDec = __webpack_require__(32);
          var _OpNot = __webpack_require__(33);
          var _OpAnd = __webpack_require__(34);
          var _OpOr = __webpack_require__(35);
          var _OpMatches = __webpack_require__(36);
          var _Ternary = __webpack_require__(37);
          var _Elvis = __webpack_require__(38);
          var _InlineList = __webpack_require__(39);
          var _InlineMap = __webpack_require__(40);
          var _Selection = __webpack_require__(41);
          var _Projection = __webpack_require__(42);
          var _OpInstanceof = __webpack_require__(43);
          var _OpBetween = __webpack_require__(44);
          var _TypeReference = __webpack_require__(45);
          var _BeanReference = __webpack_require__(46);
          var _Identifier = __webpack_require__(47);
          var _QualifiedIdentifier = __webpack_require__(48);
          var _ConstructorReference = __webpack_require__(49);
          exports3.SpelExpressionParser = function SpelExpressionParser() {
            var VALID_QUALIFIED_ID_PATTERN = new RegExp("[\\p{L}\\p{N}_$]+");
            var constructedNodes = [];
            var expressionString;
            var tokenStream;
            var tokenStreamLength;
            var tokenStreamPointer;
            function setConfiguration(config2) {
            }
            function parse(expression, context2) {
              try {
                expressionString = expression;
                tokenStream = _Tokenizer.Tokenizer.tokenize(expression);
                tokenStreamLength = tokenStream.length;
                tokenStreamPointer = 0;
                constructedNodes = [];
                var ast = eatExpression();
                if (moreTokens()) {
                  raiseInternalException(peekToken().startPos, "MORE_INPUT", nextToken().toString());
                }
                return ast;
              } catch (e2) {
                throw e2.message;
              }
            }
            function eatExpression() {
              var expr = eatLogicalOrExpression();
              if (moreTokens()) {
                var token2 = peekToken();
                if (token2.getKind() === _TokenKind.TokenKind.ASSIGN) {
                  if (expr === null) {
                    expr = _NullLiteral.NullLiteral.create(toPosBounds(token2.startPos - 1, token2.endPos - 1));
                  }
                  nextToken();
                  var assignedValue = eatLogicalOrExpression();
                  return _Assign.Assign.create(toPosToken(token2), expr, assignedValue);
                }
                if (token2.getKind() === _TokenKind.TokenKind.ELVIS) {
                  if (expr === null) {
                    expr = _NullLiteral.NullLiteral.create(toPosBounds(token2.startPos - 1, token2.endPos - 2));
                  }
                  nextToken();
                  var valueIfNull = eatExpression();
                  if (valueIfNull === null) {
                    valueIfNull = _NullLiteral.NullLiteral.create(toPosBounds(token2.startPos + 1, token2.endPos + 1));
                  }
                  return _Elvis.Elvis.create(toPosToken(token2), expr, valueIfNull);
                }
                if (token2.getKind() === _TokenKind.TokenKind.QMARK) {
                  if (expr === null) {
                    expr = _NullLiteral.NullLiteral.create(toPosBounds(token2.startPos - 1, token2.endPos - 1));
                  }
                  nextToken();
                  var ifTrueExprValue = eatExpression();
                  eatToken(_TokenKind.TokenKind.COLON);
                  var ifFalseExprValue = eatExpression();
                  return _Ternary.Ternary.create(toPosToken(token2), expr, ifTrueExprValue, ifFalseExprValue);
                }
              }
              return expr;
            }
            function eatLogicalOrExpression() {
              var expr = eatLogicalAndExpression();
              while (peekIdentifierToken("or") || peekTokenOne(_TokenKind.TokenKind.SYMBOLIC_OR)) {
                var token2 = nextToken();
                var rhExpr = eatLogicalAndExpression();
                checkOperands(token2, expr, rhExpr);
                expr = _OpOr.OpOr.create(toPosToken(token2), expr, rhExpr);
              }
              return expr;
            }
            function eatLogicalAndExpression() {
              var expr = eatRelationalExpression();
              while (peekIdentifierToken("and") || peekTokenOne(_TokenKind.TokenKind.SYMBOLIC_AND)) {
                var token2 = nextToken();
                var rhExpr = eatRelationalExpression();
                checkOperands(token2, expr, rhExpr);
                expr = _OpAnd.OpAnd.create(toPosToken(token2), expr, rhExpr);
              }
              return expr;
            }
            function eatRelationalExpression() {
              var expr = eatSumExpression();
              var relationalOperatorToken = maybeEatRelationalOperator();
              if (relationalOperatorToken !== null) {
                var token2 = nextToken();
                var rhExpr = eatSumExpression();
                checkOperands(token2, expr, rhExpr);
                var tk = relationalOperatorToken.kind;
                if (relationalOperatorToken.isNumericRelationalOperator()) {
                  var pos = toPosToken(token2);
                  if (tk === _TokenKind.TokenKind.GT) {
                    return _OpGT.OpGT.create(pos, expr, rhExpr);
                  }
                  if (tk === _TokenKind.TokenKind.LT) {
                    return _OpLT.OpLT.create(pos, expr, rhExpr);
                  }
                  if (tk === _TokenKind.TokenKind.LE) {
                    return _OpLE.OpLE.create(pos, expr, rhExpr);
                  }
                  if (tk === _TokenKind.TokenKind.GE) {
                    return _OpGE.OpGE.create(pos, expr, rhExpr);
                  }
                  if (tk === _TokenKind.TokenKind.EQ) {
                    return _OpEQ.OpEQ.create(pos, expr, rhExpr);
                  }
                  return _OpNE.OpNE.create(pos, expr, rhExpr);
                }
                if (tk === _TokenKind.TokenKind.INSTANCEOF) {
                  return _OpInstanceof.OpInstanceof.create(toPosToken(token2), expr, rhExpr);
                }
                if (tk === _TokenKind.TokenKind.MATCHES) {
                  return _OpMatches.OpMatches.create(toPosToken(token2), expr, rhExpr);
                }
                return _OpBetween.OpBetween.create(toPosToken(token2), expr, rhExpr);
              }
              return expr;
            }
            function eatSumExpression() {
              var expr = eatProductExpression();
              while (peekTokenAny(_TokenKind.TokenKind.PLUS, _TokenKind.TokenKind.MINUS, _TokenKind.TokenKind.INC)) {
                var token2 = nextToken();
                var rhExpr = eatProductExpression();
                checkRightOperand(token2, rhExpr);
                if (token2.getKind() === _TokenKind.TokenKind.PLUS) {
                  expr = _OpPlus.OpPlus.create(toPosToken(token2), expr, rhExpr);
                } else if (token2.getKind() === _TokenKind.TokenKind.MINUS) {
                  expr = _OpMinus.OpMinus.create(toPosToken(token2), expr, rhExpr);
                }
              }
              return expr;
            }
            function eatProductExpression() {
              var expr = eatPowerIncDecExpression();
              while (peekTokenAny(_TokenKind.TokenKind.STAR, _TokenKind.TokenKind.DIV, _TokenKind.TokenKind.MOD)) {
                var token2 = nextToken();
                var rhExpr = eatPowerIncDecExpression();
                checkOperands(token2, expr, rhExpr);
                if (token2.getKind() === _TokenKind.TokenKind.STAR) {
                  expr = _OpMultiply.OpMultiply.create(toPosToken(token2), expr, rhExpr);
                } else if (token2.getKind() === _TokenKind.TokenKind.DIV) {
                  expr = _OpDivide.OpDivide.create(toPosToken(token2), expr, rhExpr);
                } else {
                  expr = _OpModulus.OpModulus.create(toPosToken(token2), expr, rhExpr);
                }
              }
              return expr;
            }
            function eatPowerIncDecExpression() {
              var expr = eatUnaryExpression(), token2;
              if (peekTokenOne(_TokenKind.TokenKind.POWER)) {
                token2 = nextToken();
                var rhExpr = eatUnaryExpression();
                checkRightOperand(token2, rhExpr);
                return _OpPower.OpPower.create(toPosToken(token2), expr, rhExpr);
              }
              if (expr !== null && peekTokenAny(_TokenKind.TokenKind.INC, _TokenKind.TokenKind.DEC)) {
                token2 = nextToken();
                if (token2.getKind() === _TokenKind.TokenKind.INC) {
                  return _OpInc.OpInc.create(toPosToken(token2), true, expr);
                }
                return _OpDec.OpDec.create(toPosToken(token2), true, expr);
              }
              return expr;
            }
            function eatUnaryExpression() {
              var token2, expr;
              if (peekTokenAny(_TokenKind.TokenKind.PLUS, _TokenKind.TokenKind.MINUS, _TokenKind.TokenKind.NOT)) {
                token2 = nextToken();
                expr = eatUnaryExpression();
                if (token2.getKind() === _TokenKind.TokenKind.NOT) {
                  return _OpNot.OpNot.create(toPosToken(token2), expr);
                }
                if (token2.getKind() === _TokenKind.TokenKind.PLUS) {
                  return _OpPlus.OpPlus.create(toPosToken(token2), expr);
                }
                return _OpMinus.OpMinus.create(toPosToken(token2), expr);
              }
              if (peekTokenAny(_TokenKind.TokenKind.INC, _TokenKind.TokenKind.DEC)) {
                token2 = nextToken();
                expr = eatUnaryExpression();
                if (token2.getKind() === _TokenKind.TokenKind.INC) {
                  return _OpInc.OpInc.create(toPosToken(token2), false, expr);
                }
                return _OpDec.OpDec.create(toPosToken(token2), false, expr);
              }
              return eatPrimaryExpression();
            }
            function eatPrimaryExpression() {
              var nodes = [];
              var start2 = eatStartNode();
              nodes.push(start2);
              while (maybeEatNode()) {
                nodes.push(pop());
              }
              if (nodes.length === 1) {
                return nodes[0];
              }
              return _CompoundExpression.CompoundExpression.create(toPosBounds(start2.getStartPosition(), nodes[nodes.length - 1].getEndPosition()), nodes);
            }
            function maybeEatNode() {
              var expr = null;
              if (peekTokenAny(_TokenKind.TokenKind.DOT, _TokenKind.TokenKind.SAFE_NAVI)) {
                expr = eatDottedNode();
              } else {
                expr = maybeEatNonDottedNode();
              }
              if (expr === null) {
                return false;
              } else {
                push(expr);
                return true;
              }
            }
            function maybeEatNonDottedNode() {
              if (peekTokenOne(_TokenKind.TokenKind.LSQUARE)) {
                if (maybeEatIndexer()) {
                  return pop();
                }
              }
              return null;
            }
            function eatDottedNode() {
              var token2 = nextToken();
              var nullSafeNavigation = token2.getKind() === _TokenKind.TokenKind.SAFE_NAVI;
              if (maybeEatMethodOrProperty(nullSafeNavigation) || maybeEatFunctionOrVar() || maybeEatProjection(nullSafeNavigation) || maybeEatSelection(nullSafeNavigation)) {
                return pop();
              }
              if (peekToken() === null) {
                raiseInternalException(token2.startPos, "OOD");
              } else {
                raiseInternalException(token2.startPos, "UNEXPECTED_DATA_AFTER_DOT", toString3(peekToken()));
              }
              return null;
            }
            function maybeEatFunctionOrVar() {
              if (!peekTokenOne(_TokenKind.TokenKind.HASH)) {
                return false;
              }
              var token2 = nextToken();
              var functionOrVariableName = eatToken(_TokenKind.TokenKind.IDENTIFIER);
              var args = maybeEatMethodArgs();
              if (args === null) {
                push(_VariableReference.VariableReference.create(functionOrVariableName.data, toPosBounds(token2.startPos, functionOrVariableName.endPos)));
                return true;
              }
              push(_FunctionReference.FunctionReference.create(functionOrVariableName.data, toPosBounds(token2.startPos, functionOrVariableName.endPos), args));
              return true;
            }
            function maybeEatMethodArgs() {
              if (!peekTokenOne(_TokenKind.TokenKind.LPAREN)) {
                return null;
              }
              var args = [];
              consumeArguments(args);
              eatToken(_TokenKind.TokenKind.RPAREN);
              return args;
            }
            function eatConstructorArgs(accumulatedArguments) {
              if (!peekTokenOne(_TokenKind.TokenKind.LPAREN)) {
                raiseInternalException(toPosToken(peekToken()), "MISSING_CONSTRUCTOR_ARGS");
              }
              consumeArguments(accumulatedArguments);
              eatToken(_TokenKind.TokenKind.RPAREN);
            }
            function consumeArguments(accumulatedArguments) {
              var pos = peekToken().startPos;
              var next;
              do {
                nextToken();
                var token2 = peekToken();
                if (token2 === null) {
                  raiseInternalException(pos, "RUN_OUT_OF_ARGUMENTS");
                }
                if (token2.getKind() !== _TokenKind.TokenKind.RPAREN) {
                  accumulatedArguments.push(eatExpression());
                }
                next = peekToken();
              } while (next !== null && next.kind === _TokenKind.TokenKind.COMMA);
              if (next === null) {
                raiseInternalException(pos, "RUN_OUT_OF_ARGUMENTS");
              }
            }
            function eatStartNode() {
              if (maybeEatLiteral()) {
                return pop();
              } else if (maybeEatParenExpression()) {
                return pop();
              } else if (maybeEatTypeReference() || maybeEatNullReference() || maybeEatConstructorReference() || maybeEatMethodOrProperty(false) || maybeEatFunctionOrVar()) {
                return pop();
              } else if (maybeEatBeanReference()) {
                return pop();
              } else if (maybeEatProjection(false) || maybeEatSelection(false) || maybeEatIndexer()) {
                return pop();
              } else if (maybeEatInlineListOrMap()) {
                return pop();
              } else {
                return null;
              }
            }
            function maybeEatBeanReference() {
              if (peekTokenOne(_TokenKind.TokenKind.BEAN_REF)) {
                var beanRefToken = nextToken();
                var beanNameToken = null;
                var beanName = null;
                if (peekTokenOne(_TokenKind.TokenKind.IDENTIFIER)) {
                  beanNameToken = eatToken(_TokenKind.TokenKind.IDENTIFIER);
                  beanName = beanNameToken.data;
                } else if (peekTokenOne(_TokenKind.TokenKind.LITERAL_STRING)) {
                  beanNameToken = eatToken(_TokenKind.TokenKind.LITERAL_STRING);
                  beanName = beanNameToken.stringValue();
                  beanName = beanName.substring(1, beanName.length() - 1);
                } else {
                  raiseInternalException(beanRefToken.startPos, "INVALID_BEAN_REFERENCE");
                }
                var beanReference = _BeanReference.BeanReference.create(toPosToken(beanNameToken), beanName);
                push(beanReference);
                return true;
              }
              return false;
            }
            function maybeEatTypeReference() {
              if (peekTokenOne(_TokenKind.TokenKind.IDENTIFIER)) {
                var typeName = peekToken();
                if (typeName.stringValue() !== "T") {
                  return false;
                }
                var token2 = nextToken();
                if (peekTokenOne(_TokenKind.TokenKind.RSQUARE)) {
                  push(_PropertyReference.PropertyReference.create(token2.stringValue(), toPosToken(token2)));
                  return true;
                }
                eatToken(_TokenKind.TokenKind.LPAREN);
                var node = eatPossiblyQualifiedId();
                var dims = 0;
                while (peekTokenConsumeIfMatched(_TokenKind.TokenKind.LSQUARE, true)) {
                  eatToken(_TokenKind.TokenKind.RSQUARE);
                  dims++;
                }
                eatToken(_TokenKind.TokenKind.RPAREN);
                push(_TypeReference.TypeReference.create(toPosToken(typeName), node, dims));
                return true;
              }
              return false;
            }
            function maybeEatNullReference() {
              if (peekTokenOne(_TokenKind.TokenKind.IDENTIFIER)) {
                var nullToken = peekToken();
                if (nullToken.stringValue().toLowerCase() !== "null") {
                  return false;
                }
                nextToken();
                push(_NullLiteral.NullLiteral.create(toPosToken(nullToken)));
                return true;
              }
              return false;
            }
            function maybeEatProjection(nullSafeNavigation) {
              var token2 = peekToken();
              if (!peekTokenConsumeIfMatched(_TokenKind.TokenKind.PROJECT, true)) {
                return false;
              }
              var expr = eatExpression();
              eatToken(_TokenKind.TokenKind.RSQUARE);
              push(_Projection.Projection.create(nullSafeNavigation, toPosToken(token2), expr));
              return true;
            }
            function maybeEatInlineListOrMap() {
              var token2 = peekToken(), listElements = [];
              if (!peekTokenConsumeIfMatched(_TokenKind.TokenKind.LCURLY, true)) {
                return false;
              }
              var expr = null;
              var closingCurly = peekToken();
              if (peekTokenConsumeIfMatched(_TokenKind.TokenKind.RCURLY, true)) {
                expr = _InlineList.InlineList.create(toPosBounds(token2.startPos, closingCurly.endPos));
              } else if (peekTokenConsumeIfMatched(_TokenKind.TokenKind.COLON, true)) {
                closingCurly = eatToken(_TokenKind.TokenKind.RCURLY);
                expr = _InlineMap.InlineMap.create(toPosBounds(token2.startPos, closingCurly.endPos));
              } else {
                var firstExpression = eatExpression();
                if (peekTokenOne(_TokenKind.TokenKind.RCURLY)) {
                  listElements.push(firstExpression);
                  closingCurly = eatToken(_TokenKind.TokenKind.RCURLY);
                  expr = _InlineList.InlineList.create(toPosBounds(token2.startPos, closingCurly.endPos), listElements);
                } else if (peekTokenConsumeIfMatched(_TokenKind.TokenKind.COMMA, true)) {
                  listElements.push(firstExpression);
                  do {
                    listElements.push(eatExpression());
                  } while (peekTokenConsumeIfMatched(_TokenKind.TokenKind.COMMA, true));
                  closingCurly = eatToken(_TokenKind.TokenKind.RCURLY);
                  expr = _InlineList.InlineList.create(toPosToken(token2.startPos, closingCurly.endPos), listElements);
                } else if (peekTokenConsumeIfMatched(_TokenKind.TokenKind.COLON, true)) {
                  var mapElements = [];
                  mapElements.push(firstExpression);
                  mapElements.push(eatExpression());
                  while (peekTokenConsumeIfMatched(_TokenKind.TokenKind.COMMA, true)) {
                    mapElements.push(eatExpression());
                    eatToken(_TokenKind.TokenKind.COLON);
                    mapElements.push(eatExpression());
                  }
                  closingCurly = eatToken(_TokenKind.TokenKind.RCURLY);
                  expr = _InlineMap.InlineMap.create(toPosBounds(token2.startPos, closingCurly.endPos), mapElements);
                } else {
                  raiseInternalException(token2.startPos, "OOD");
                }
              }
              push(expr);
              return true;
            }
            function maybeEatIndexer() {
              var token2 = peekToken();
              if (!peekTokenConsumeIfMatched(_TokenKind.TokenKind.LSQUARE, true)) {
                return false;
              }
              var expr = eatExpression();
              eatToken(_TokenKind.TokenKind.RSQUARE);
              push(_Indexer.Indexer.create(toPosToken(token2), expr));
              return true;
            }
            function maybeEatSelection(nullSafeNavigation) {
              var token2 = peekToken();
              if (!peekSelectToken()) {
                return false;
              }
              nextToken();
              var expr = eatExpression();
              if (expr === null) {
                raiseInternalException(toPosToken(token2), "MISSING_SELECTION_EXPRESSION");
              }
              eatToken(_TokenKind.TokenKind.RSQUARE);
              if (token2.getKind() === _TokenKind.TokenKind.SELECT_FIRST) {
                push(_Selection.Selection.create(nullSafeNavigation, _Selection.Selection.FIRST, toPosToken(token2), expr));
              } else if (token2.getKind() === _TokenKind.TokenKind.SELECT_LAST) {
                push(_Selection.Selection.create(nullSafeNavigation, _Selection.Selection.LAST, toPosToken(token2), expr));
              } else {
                push(_Selection.Selection.create(nullSafeNavigation, _Selection.Selection.ALL, toPosToken(token2), expr));
              }
              return true;
            }
            function eatPossiblyQualifiedId() {
              var qualifiedIdPieces = [];
              var node = peekToken();
              while (isValidQualifiedId(node)) {
                nextToken();
                if (node.kind !== _TokenKind.TokenKind.DOT) {
                  qualifiedIdPieces.push(_Identifier.Identifier.create(node.stringValue(), toPosToken(node)));
                }
                node = peekToken();
              }
              if (!qualifiedIdPieces.length) {
                if (node === null) {
                  raiseInternalException(expressionString.length(), "OOD");
                }
                raiseInternalException(node.startPos, "NOT_EXPECTED_TOKEN", "qualified ID", node.getKind().toString().toLowerCase());
              }
              var pos = toPosBounds(qualifiedIdPieces[0].getStartPosition(), qualifiedIdPieces[qualifiedIdPieces.length - 1].getEndPosition());
              return _QualifiedIdentifier.QualifiedIdentifier.create(pos, qualifiedIdPieces);
            }
            function isValidQualifiedId(node) {
              if (node === null || node.kind === _TokenKind.TokenKind.LITERAL_STRING) {
                return false;
              }
              if (node.kind === _TokenKind.TokenKind.DOT || node.kind === _TokenKind.TokenKind.IDENTIFIER) {
                return true;
              }
              var value = node.stringValue();
              return value && value.length && VALID_QUALIFIED_ID_PATTERN.test(value);
            }
            function maybeEatMethodOrProperty(nullSafeNavigation) {
              if (peekTokenOne(_TokenKind.TokenKind.IDENTIFIER)) {
                var methodOrPropertyName = nextToken();
                var args = maybeEatMethodArgs();
                if (args === null) {
                  push(_PropertyReference.PropertyReference.create(nullSafeNavigation, methodOrPropertyName.stringValue(), toPosToken(methodOrPropertyName)));
                  return true;
                }
                push(_MethodReference.MethodReference.create(nullSafeNavigation, methodOrPropertyName.stringValue(), toPosToken(methodOrPropertyName), args));
                return true;
              }
              return false;
            }
            function maybeEatConstructorReference() {
              if (peekIdentifierToken("new")) {
                var newToken = nextToken();
                if (peekTokenOne(_TokenKind.TokenKind.RSQUARE)) {
                  push(_PropertyReference.PropertyReference.create(newToken.stringValue(), toPosToken(newToken)));
                  return true;
                }
                var possiblyQualifiedConstructorName = eatPossiblyQualifiedId();
                var nodes = [];
                nodes.push(possiblyQualifiedConstructorName);
                if (peekTokenOne(_TokenKind.TokenKind.LSQUARE)) {
                  var dimensions = [];
                  while (peekTokenConsumeIfMatched(_TokenKind.TokenKind.LSQUARE, true)) {
                    if (!peekTokenOne(_TokenKind.TokenKind.RSQUARE)) {
                      dimensions.push(eatExpression());
                    } else {
                      dimensions.push(null);
                    }
                    eatToken(_TokenKind.TokenKind.RSQUARE);
                  }
                  if (maybeEatInlineListOrMap()) {
                    nodes.push(pop());
                  }
                  push(_ConstructorReference.ConstructorReference.create(toPosToken(newToken), dimensions, nodes));
                } else {
                  eatConstructorArgs(nodes);
                  push(_ConstructorReference.ConstructorReference.create(toPosToken(newToken), nodes));
                }
                return true;
              }
              return false;
            }
            function push(newNode) {
              constructedNodes.push(newNode);
            }
            function pop() {
              return constructedNodes.pop();
            }
            function maybeEatLiteral() {
              var token2 = peekToken();
              if (token2 === null) {
                return false;
              }
              if (token2.getKind() === _TokenKind.TokenKind.LITERAL_INT || token2.getKind() === _TokenKind.TokenKind.LITERAL_LONG) {
                push(_NumberLiteral.NumberLiteral.create(parseInt(token2.stringValue(), 10), toPosToken(token2)));
              } else if (token2.getKind() === _TokenKind.TokenKind.LITERAL_REAL || token2.getKind() === _TokenKind.TokenKind.LITERAL_REAL_FLOAT) {
                push(_NumberLiteral.NumberLiteral.create(parseFloat(token2.stringValue()), toPosToken(token2)));
              } else if (token2.getKind() === _TokenKind.TokenKind.LITERAL_HEXINT || token2.getKind() === _TokenKind.TokenKind.LITERAL_HEXLONG) {
                push(_NumberLiteral.NumberLiteral.create(parseInt(token2.stringValue(), 16), toPosToken(token2)));
              } else if (peekIdentifierToken("true")) {
                push(_BooleanLiteral.BooleanLiteral.create(true, toPosToken(token2)));
              } else if (peekIdentifierToken("false")) {
                push(_BooleanLiteral.BooleanLiteral.create(false, toPosToken(token2)));
              } else if (token2.getKind() === _TokenKind.TokenKind.LITERAL_STRING) {
                push(_StringLiteral.StringLiteral.create(token2.stringValue(), toPosToken(token2)));
              } else {
                return false;
              }
              nextToken();
              return true;
            }
            function maybeEatParenExpression() {
              if (peekTokenOne(_TokenKind.TokenKind.LPAREN)) {
                nextToken();
                var expr = eatExpression();
                eatToken(_TokenKind.TokenKind.RPAREN);
                push(expr);
                return true;
              } else {
                return false;
              }
            }
            function maybeEatRelationalOperator() {
              var token2 = peekToken();
              if (token2 === null) {
                return null;
              }
              if (token2.isNumericRelationalOperator()) {
                return token2;
              }
              if (token2.isIdentifier()) {
                var idString = token2.stringValue();
                if (idString.toLowerCase() === "instanceof") {
                  return token2.asInstanceOfToken();
                }
                if (idString.toLowerCase() === "matches") {
                  return token2.asMatchesToken();
                }
                if (idString.toLowerCase() === "between") {
                  return token2.asBetweenToken();
                }
              }
              return null;
            }
            function eatToken(expectedKind) {
              var token2 = nextToken();
              if (token2 === null) {
                raiseInternalException(expressionString.length, "OOD");
              }
              if (token2.getKind() !== expectedKind) {
                raiseInternalException(token2.startPos, "NOT_EXPECTED_TOKEN", expectedKind.toString().toLowerCase(), token2.getKind().toString().toLowerCase());
              }
              return token2;
            }
            function peekTokenOne(desiredTokenKind) {
              return peekTokenConsumeIfMatched(desiredTokenKind, false);
            }
            function peekTokenConsumeIfMatched(desiredTokenKind, consumeIfMatched) {
              if (!moreTokens()) {
                return false;
              }
              var token2 = peekToken();
              if (token2.getKind() === desiredTokenKind) {
                if (consumeIfMatched) {
                  tokenStreamPointer++;
                }
                return true;
              }
              if (desiredTokenKind === _TokenKind.TokenKind.IDENTIFIER) {
                if (token2.getKind().ordinal() >= _TokenKind.TokenKind.DIV.ordinal() && token2.getKind().ordinal() <= _TokenKind.TokenKind.NOT.ordinal() && token2.data !== null) {
                  return true;
                }
              }
              return false;
            }
            function peekTokenAny() {
              if (!moreTokens()) {
                return false;
              }
              var token2 = peekToken();
              var args = Array.prototype.slice.call(arguments);
              for (var i2 = 0, l2 = args.length; i2 < l2; i2 += 1) {
                if (token2.getKind() === args[i2]) {
                  return true;
                }
              }
              return false;
            }
            function peekIdentifierToken(identifierString) {
              if (!moreTokens()) {
                return false;
              }
              var token2 = peekToken();
              return token2.getKind() === _TokenKind.TokenKind.IDENTIFIER && token2.stringValue().toLowerCase() === identifierString.toLowerCase();
            }
            function peekSelectToken() {
              if (!moreTokens()) {
                return false;
              }
              var token2 = peekToken();
              return token2.getKind() === _TokenKind.TokenKind.SELECT || token2.getKind() === _TokenKind.TokenKind.SELECT_FIRST || token2.getKind() === _TokenKind.TokenKind.SELECT_LAST;
            }
            function moreTokens() {
              return tokenStreamPointer < tokenStream.length;
            }
            function nextToken() {
              if (tokenStreamPointer >= tokenStreamLength) {
                return null;
              }
              return tokenStream[tokenStreamPointer++];
            }
            function peekToken() {
              if (tokenStreamPointer >= tokenStreamLength) {
                return null;
              }
              return tokenStream[tokenStreamPointer];
            }
            function raiseInternalException(pos, message, expected, actual) {
              if (expected) {
                message += "\nExpected: " + expected;
              }
              if (actual) {
                message += "\nActual: " + actual;
              }
              throw {
                name: "InternalParseException",
                message: "Error occurred while attempting to parse expression '" + expressionString + "' at position " + pos + ". Message: " + message
              };
            }
            function toString3(token2) {
              if (token2.getKind().hasPayload()) {
                return token2.stringValue();
              }
              return token2.getKind().toString().toLowerCase();
            }
            function checkOperands(token2, left, right) {
              checkLeftOperand(token2, left);
              checkRightOperand(token2, right);
            }
            function checkLeftOperand(token2, operandExpression) {
              if (operandExpression === null) {
                raiseInternalException(token2.startPos, "LEFT_OPERAND_PROBLEM");
              }
            }
            function checkRightOperand(token2, operandExpression) {
              if (operandExpression === null) {
                raiseInternalException(token2.startPos, "RIGHT_OPERAND_PROBLEM");
              }
            }
            function toPosToken(token2) {
              return (token2.startPos << 16) + token2.endPos;
            }
            function toPosBounds(start2, end) {
              return (start2 << 16) + end;
            }
            return {
              setConfiguration,
              parse
            };
          };
        },
        /* 6 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.Tokenizer = void 0;
          var _Token = __webpack_require__(7);
          var _TokenKind = __webpack_require__(2);
          var ALTERNATIVE_OPERATOR_NAMES = ["DIV", "EQ", "GE", "GT", "LE", "LT", "MOD", "NE", "NOT"], FLAGS = [], IS_DIGIT = 1, IS_HEXDIGIT = 2, IS_ALPHA = 4;
          function init() {
            var ch;
            for (ch = "0".charCodeAt(0); ch <= "9".charCodeAt(0); ch += 1) {
              FLAGS[ch] |= IS_DIGIT | IS_HEXDIGIT;
            }
            for (ch = "A".charCodeAt(0); ch <= "F".charCodeAt(0); ch += 1) {
              FLAGS[ch] |= IS_HEXDIGIT;
            }
            for (ch = "a".charCodeAt(0); ch <= "f".charCodeAt(0); ch += 1) {
              FLAGS[ch] |= IS_HEXDIGIT;
            }
            for (ch = "A".charCodeAt(0); ch <= "Z".charCodeAt(0); ch += 1) {
              FLAGS[ch] |= IS_ALPHA;
            }
            for (ch = "a".charCodeAt(0); ch <= "z".charCodeAt(0); ch += 1) {
              FLAGS[ch] |= IS_ALPHA;
            }
          }
          init();
          function tokenize(inputData) {
            var expressionString = inputData, toProcess = inputData + "\0", max2 = toProcess.length, pos = 0, tokens2 = [];
            function process2() {
              var ch;
              while (pos < max2) {
                ch = toProcess[pos];
                if (isAlphabetic(ch)) {
                  lexIdentifier();
                } else {
                  switch (ch) {
                    case "+":
                      if (isTwoCharToken(_TokenKind.TokenKind.INC)) {
                        pushPairToken(_TokenKind.TokenKind.INC);
                      } else {
                        pushCharToken(_TokenKind.TokenKind.PLUS);
                      }
                      break;
                    case "_":
                      lexIdentifier();
                      break;
                    case "-":
                      if (isTwoCharToken(_TokenKind.TokenKind.DEC)) {
                        pushPairToken(_TokenKind.TokenKind.DEC);
                      } else {
                        pushCharToken(_TokenKind.TokenKind.MINUS);
                      }
                      break;
                    case ":":
                      pushCharToken(_TokenKind.TokenKind.COLON);
                      break;
                    case ".":
                      pushCharToken(_TokenKind.TokenKind.DOT);
                      break;
                    case ",":
                      pushCharToken(_TokenKind.TokenKind.COMMA);
                      break;
                    case "*":
                      pushCharToken(_TokenKind.TokenKind.STAR);
                      break;
                    case "/":
                      pushCharToken(_TokenKind.TokenKind.DIV);
                      break;
                    case "%":
                      pushCharToken(_TokenKind.TokenKind.MOD);
                      break;
                    case "(":
                      pushCharToken(_TokenKind.TokenKind.LPAREN);
                      break;
                    case ")":
                      pushCharToken(_TokenKind.TokenKind.RPAREN);
                      break;
                    case "[":
                      pushCharToken(_TokenKind.TokenKind.LSQUARE);
                      break;
                    case "#":
                      pushCharToken(_TokenKind.TokenKind.HASH);
                      break;
                    case "]":
                      pushCharToken(_TokenKind.TokenKind.RSQUARE);
                      break;
                    case "{":
                      pushCharToken(_TokenKind.TokenKind.LCURLY);
                      break;
                    case "}":
                      pushCharToken(_TokenKind.TokenKind.RCURLY);
                      break;
                    case "@":
                      pushCharToken(_TokenKind.TokenKind.BEAN_REF);
                      break;
                    case "^":
                      if (isTwoCharToken(_TokenKind.TokenKind.SELECT_FIRST)) {
                        pushPairToken(_TokenKind.TokenKind.SELECT_FIRST);
                      } else {
                        pushCharToken(_TokenKind.TokenKind.POWER);
                      }
                      break;
                    case "!":
                      if (isTwoCharToken(_TokenKind.TokenKind.NE)) {
                        pushPairToken(_TokenKind.TokenKind.NE);
                      } else if (isTwoCharToken(_TokenKind.TokenKind.PROJECT)) {
                        pushPairToken(_TokenKind.TokenKind.PROJECT);
                      } else {
                        pushCharToken(_TokenKind.TokenKind.NOT);
                      }
                      break;
                    case "=":
                      if (isTwoCharToken(_TokenKind.TokenKind.EQ)) {
                        pushPairToken(_TokenKind.TokenKind.EQ);
                      } else {
                        pushCharToken(_TokenKind.TokenKind.ASSIGN);
                      }
                      break;
                    case "&":
                      if (!isTwoCharToken(_TokenKind.TokenKind.SYMBOLIC_AND)) {
                        throw {
                          name: "SpelParseException",
                          message: "Missing character '&' in expression (" + expressionString + ") at position " + pos
                        };
                      }
                      pushPairToken(_TokenKind.TokenKind.SYMBOLIC_AND);
                      break;
                    case "|":
                      if (!isTwoCharToken(_TokenKind.TokenKind.SYMBOLIC_OR)) {
                        throw {
                          name: "SpelParseException",
                          message: "Missing character '|' in expression (" + expressionString + ") at position " + pos
                        };
                      }
                      pushPairToken(_TokenKind.TokenKind.SYMBOLIC_OR);
                      break;
                    case "?":
                      if (isTwoCharToken(_TokenKind.TokenKind.SELECT)) {
                        pushPairToken(_TokenKind.TokenKind.SELECT);
                      } else if (isTwoCharToken(_TokenKind.TokenKind.ELVIS)) {
                        pushPairToken(_TokenKind.TokenKind.ELVIS);
                      } else if (isTwoCharToken(_TokenKind.TokenKind.SAFE_NAVI)) {
                        pushPairToken(_TokenKind.TokenKind.SAFE_NAVI);
                      } else {
                        pushCharToken(_TokenKind.TokenKind.QMARK);
                      }
                      break;
                    case "$":
                      if (isTwoCharToken(_TokenKind.TokenKind.SELECT_LAST)) {
                        pushPairToken(_TokenKind.TokenKind.SELECT_LAST);
                      } else {
                        lexIdentifier();
                      }
                      break;
                    case ">":
                      if (isTwoCharToken(_TokenKind.TokenKind.GE)) {
                        pushPairToken(_TokenKind.TokenKind.GE);
                      } else {
                        pushCharToken(_TokenKind.TokenKind.GT);
                      }
                      break;
                    case "<":
                      if (isTwoCharToken(_TokenKind.TokenKind.LE)) {
                        pushPairToken(_TokenKind.TokenKind.LE);
                      } else {
                        pushCharToken(_TokenKind.TokenKind.LT);
                      }
                      break;
                    case "0":
                    case "1":
                    case "2":
                    case "3":
                    case "4":
                    case "5":
                    case "6":
                    case "7":
                    case "8":
                    case "9":
                      lexNumericLiteral(ch === "0");
                      break;
                    case " ":
                    case "	":
                    case "\r":
                    case "\n":
                      pos += 1;
                      break;
                    case "'":
                      lexQuotedStringLiteral();
                      break;
                    case '"':
                      lexDoubleQuotedStringLiteral();
                      break;
                    case "\0":
                      pos += 1;
                      break;
                    case "\\":
                      throw {
                        name: "SpelParseException",
                        message: "Unexpected escape character in expression (" + expressionString + ") at position " + pos
                      };
                    default:
                      throw {
                        name: "SpelParseException",
                        message: "Cannot handle character '" + ch + "' in expression (" + expressionString + ") at position " + pos
                      };
                  }
                }
              }
            }
            function lexQuotedStringLiteral() {
              var start2 = pos, terminated = false, ch;
              while (!terminated) {
                pos += 1;
                ch = toProcess[pos];
                if (ch === "'") {
                  if (toProcess[pos + 1] === "'") {
                    pos += 1;
                  } else {
                    terminated = true;
                  }
                }
                if (ch.charCodeAt(0) === 0) {
                  throw {
                    name: "SpelParseException",
                    message: "Non-terminating quoted string in expression (" + expressionString + ") at position " + pos
                  };
                }
              }
              pos += 1;
              tokens2.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_STRING, subarray(start2, pos), start2, pos));
            }
            function lexDoubleQuotedStringLiteral() {
              var start2 = pos, terminated = false, ch;
              while (!terminated) {
                pos += 1;
                ch = toProcess[pos];
                if (ch === '"') {
                  if (toProcess[pos + 1] === '"') {
                    pos += 1;
                  } else {
                    terminated = true;
                  }
                }
                if (ch.charCodeAt(0) === 0) {
                  throw {
                    name: "SpelParseException",
                    message: "Non-terminating double-quoted string in expression (" + expressionString + ") at position " + pos
                  };
                }
              }
              pos += 1;
              tokens2.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_STRING, subarray(start2, pos), start2, pos));
            }
            function lexNumericLiteral(firstCharIsZero) {
              var isReal = false, start2 = pos, ch = toProcess[pos + 1], isHex = ch === "x" || ch === "X", dotpos, endOfNumber, possibleSign, isFloat;
              if (firstCharIsZero && isHex) {
                pos = pos + 1;
                do {
                  pos += 1;
                } while (isHexadecimalDigit(toProcess[pos]));
                if (isChar("L", "l")) {
                  pushHexIntToken(subarray(start2 + 2, pos), true, start2, pos);
                  pos += 1;
                } else {
                  pushHexIntToken(subarray(start2 + 2, pos), false, start2, pos);
                }
                return;
              }
              do {
                pos += 1;
              } while (isDigit(toProcess[pos]));
              ch = toProcess[pos];
              if (ch === ".") {
                isReal = true;
                dotpos = pos;
                do {
                  pos += 1;
                } while (isDigit(toProcess[pos]));
                if (pos === dotpos + 1) {
                  pos = dotpos;
                  pushIntToken(subarray(start2, pos), false, start2, pos);
                  return;
                }
              }
              endOfNumber = pos;
              if (isChar("L", "l")) {
                if (isReal) {
                  throw {
                    name: "SpelParseException",
                    message: "Real cannot be long in expression (" + expressionString + ") at position " + pos
                  };
                }
                pushIntToken(subarray(start2, endOfNumber), true, start2, endOfNumber);
                pos += 1;
              } else if (isExponentChar(toProcess[pos])) {
                isReal = true;
                pos += 1;
                possibleSign = toProcess[pos];
                if (isSign(possibleSign)) {
                  pos += 1;
                }
                do {
                  pos += 1;
                } while (isDigit(toProcess[pos]));
                isFloat = false;
                if (isFloatSuffix(toProcess[pos])) {
                  isFloat = true;
                  pos += 1;
                  endOfNumber = pos;
                } else if (isDoubleSuffix(toProcess[pos])) {
                  pos += 1;
                  endOfNumber = pos;
                }
                pushRealToken(subarray(start2, pos), isFloat, start2, pos);
              } else {
                ch = toProcess[pos];
                isFloat = false;
                if (isFloatSuffix(ch)) {
                  isReal = true;
                  isFloat = true;
                  pos += 1;
                  endOfNumber = pos;
                } else if (isDoubleSuffix(ch)) {
                  isReal = true;
                  pos += 1;
                  endOfNumber = pos;
                }
                if (isReal) {
                  pushRealToken(subarray(start2, endOfNumber), isFloat, start2, endOfNumber);
                } else {
                  pushIntToken(subarray(start2, endOfNumber), false, start2, endOfNumber);
                }
              }
            }
            function lexIdentifier() {
              var start2 = pos, substring, asString, idx;
              do {
                pos += 1;
              } while (isIdentifier(toProcess[pos]));
              substring = subarray(start2, pos);
              if (pos - start2 === 2 || pos - start2 === 3) {
                asString = substring.toUpperCase();
                idx = ALTERNATIVE_OPERATOR_NAMES.indexOf(asString);
                if (idx >= 0) {
                  pushOneCharOrTwoCharToken(_TokenKind.TokenKind.valueOf(asString), start2, substring);
                  return;
                }
              }
              tokens2.push(new _Token.Token(_TokenKind.TokenKind.IDENTIFIER, substring.replace("\0", ""), start2, pos));
            }
            function pushIntToken(data, isLong, start2, end) {
              if (isLong) {
                tokens2.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_LONG, data, start2, end));
              } else {
                tokens2.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_INT, data, start2, end));
              }
            }
            function pushHexIntToken(data, isLong, start2, end) {
              if (data.length === 0) {
                if (isLong) {
                  throw {
                    name: "SpelParseException",
                    message: "Not a long in expression (" + expressionString + ") at position " + pos
                  };
                } else {
                  throw {
                    name: "SpelParseException",
                    message: "Not an int in expression (" + expressionString + ") at position " + pos
                  };
                }
              }
              if (isLong) {
                tokens2.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_HEXLONG, data, start2, end));
              } else {
                tokens2.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_HEXINT, data, start2, end));
              }
            }
            function pushRealToken(data, isFloat, start2, end) {
              if (isFloat) {
                tokens2.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_REAL_FLOAT, data, start2, end));
              } else {
                tokens2.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_REAL, data, start2, end));
              }
            }
            function subarray(start2, end) {
              return toProcess.substring(start2, end);
            }
            function isTwoCharToken(kind) {
              if (kind.tokenChars.length === 2 && toProcess[pos] === kind.tokenChars[0]) {
                return toProcess[pos + 1] === kind.tokenChars[1];
              }
              return false;
            }
            function pushCharToken(kind) {
              tokens2.push(new _Token.Token(kind, null, pos, pos + 1));
              pos += 1;
            }
            function pushPairToken(kind) {
              tokens2.push(new _Token.Token(kind, null, pos, pos + 2));
              pos += 2;
            }
            function pushOneCharOrTwoCharToken(kind, pos2, data) {
              tokens2.push(new _Token.Token(kind, data, pos2, pos2 + kind.getLength()));
            }
            function isIdentifier(ch) {
              return isAlphabetic(ch) || isDigit(ch) || ch === "_" || ch === "$";
            }
            function isChar(a2, b2) {
              var ch = toProcess[pos];
              return ch === a2 || ch === b2;
            }
            function isExponentChar(ch) {
              return ch === "e" || ch === "E";
            }
            function isFloatSuffix(ch) {
              return ch === "f" || ch === "F";
            }
            function isDoubleSuffix(ch) {
              return ch === "d" || ch === "D";
            }
            function isSign(ch) {
              return ch === "+" || ch === "-";
            }
            function isDigit(ch) {
              if (ch.charCodeAt(0) > 255) {
                return false;
              }
              return (FLAGS[ch.charCodeAt(0)] & IS_DIGIT) !== 0;
            }
            function isAlphabetic(ch) {
              if (ch.charCodeAt(0) > 255) {
                return false;
              }
              return (FLAGS[ch.charCodeAt(0)] & IS_ALPHA) !== 0;
            }
            function isHexadecimalDigit(ch) {
              if (ch.charCodeAt(0) > 255) {
                return false;
              }
              return (FLAGS[ch.charCodeAt(0)] & IS_HEXDIGIT) !== 0;
            }
            process2();
            return tokens2;
          }
          exports3.Tokenizer = {
            tokenize
          };
        },
        /* 7 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.Token = void 0;
          var _TokenKind = __webpack_require__(2);
          function Token(tokenKind, tokenData, startPos, endPos) {
            this.kind = tokenKind;
            this.startPos = startPos;
            this.endPos = endPos;
            if (tokenData) {
              this.data = tokenData;
            }
          }
          Token.prototype.getKind = function() {
            return this.kind;
          };
          Token.prototype.toString = function() {
            var s2 = "[";
            s2 += this.kind.toString();
            if (this.kind.hasPayload()) {
              s2 += ":" + this.data;
            }
            s2 += "]";
            s2 += "(" + this.startPos + "," + this.endPos + ")";
            return s2;
          };
          Token.prototype.isIdentifier = function() {
            return this.kind === _TokenKind.TokenKind.IDENTIFIER;
          };
          Token.prototype.isNumericRelationalOperator = function() {
            return this.kind === _TokenKind.TokenKind.GT || this.kind === _TokenKind.TokenKind.GE || this.kind === _TokenKind.TokenKind.LT || this.kind === _TokenKind.TokenKind.LE || this.kind === _TokenKind.TokenKind.EQ || this.kind === _TokenKind.TokenKind.NE;
          };
          Token.prototype.stringValue = function() {
            return this.data;
          };
          Token.prototype.asInstanceOfToken = function() {
            return new Token(_TokenKind.TokenKind.INSTANCEOF, this.startPos, this.endPos);
          };
          Token.prototype.asMatchesToken = function() {
            return new Token(_TokenKind.TokenKind.MATCHES, this.startPos, this.endPos);
          };
          Token.prototype.asBetweenToken = function() {
            return new Token(_TokenKind.TokenKind.BETWEEN, this.startPos, this.endPos);
          };
          Token.prototype.getStartPosition = function() {
            return this.startPos;
          };
          Token.prototype.getEndPosition = function() {
            return this.endPos;
          };
          exports3.Token = Token;
        },
        /* 8 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.BooleanLiteral = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(value, position) {
            var node = _SpelNode.SpelNode.create("boolean", position);
            node.getValue = function() {
              return value;
            };
            node.setValue = function(newValue) {
              return value = newValue;
            };
            return node;
          }
          exports3.BooleanLiteral = {
            create: createNode
          };
        },
        /* 9 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.NumberLiteral = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(value, position) {
            var node = _SpelNode.SpelNode.create("number", position);
            node.getValue = function() {
              return value;
            };
            node.setValue = function(newValue) {
              return value = newValue;
            };
            return node;
          }
          exports3.NumberLiteral = {
            create: createNode
          };
        },
        /* 10 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.StringLiteral = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(value, position) {
            var node = _SpelNode.SpelNode.create("string", position);
            function stripQuotes(value2) {
              if (value2[0] === "'" && value2[value2.length - 1] === "'" || value2[0] === '"' && value2[value2.length - 1] === '"') {
                value2 = value2.substring(1, value2.length - 1);
              }
              return value2.replace(/''/g, "'").replace(/""/g, '"');
            }
            value = stripQuotes(value);
            node.getValue = function() {
              return value;
            };
            node.setValue = function(newValue) {
              return value = newValue;
            };
            return node;
          }
          exports3.StringLiteral = {
            create: createNode
          };
        },
        /* 11 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.NullLiteral = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(value, position) {
            var node = _SpelNode.SpelNode.create("null", position);
            node.getValue = function() {
              return null;
            };
            return node;
          }
          exports3.NullLiteral = {
            create: createNode
          };
        },
        /* 12 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.FunctionReference = void 0;
          var _SpelNode = __webpack_require__(0);
          var _Stack2 = __webpack_require__(1);
          function createNode(functionName, position, args) {
            var node = _SpelNode.SpelNode.create("function", position);
            node.getRaw = function() {
              return {
                functionName,
                args
              };
            };
            node.getValue = function(state) {
              var locals = state.locals || {}, context2 = state.rootContext, compiledArgs = [];
              args.forEach(function(arg) {
                var currentActiveContext = state.activeContext;
                state.activeContext = new _Stack2.Stack();
                state.activeContext.push(state.rootContext);
                compiledArgs.push(arg.getValue(state));
                state.activeContext = currentActiveContext;
              });
              if (locals[functionName]) {
                return locals[functionName].apply(context2, compiledArgs);
              }
              throw {
                name: "FunctionDoesNotExistException",
                message: "Function '" + functionName + "' does not exist."
              };
            };
            return node;
          }
          exports3.FunctionReference = {
            create: createNode
          };
        },
        /* 13 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.MethodReference = void 0;
          var _SpelNode = __webpack_require__(0);
          var _Stack2 = __webpack_require__(1);
          function createNode(nullSafeNavigation, methodName, position, args) {
            var node = _SpelNode.SpelNode.create("method", position);
            node.getRaw = function() {
              return {
                methodName,
                args
              };
            };
            node.getValue = function(state) {
              var context2 = state.activeContext.peek(), compiledArgs = [], method;
              if (!context2) {
                throw {
                  name: "ContextDoesNotExistException",
                  message: "Attempting to look up property '" + methodName + "' for an undefined context."
                };
              }
              function maybeHandleNullSafeNavigation(member) {
                if (member === void 0 || member === null) {
                  if (nullSafeNavigation) {
                    return null;
                  }
                  throw {
                    name: "NullPointerException",
                    message: "Method " + methodName + " does not exist."
                  };
                }
                return member;
              }
              args.forEach(function(arg) {
                var currentActiveContext = state.activeContext;
                state.activeContext = new _Stack2.Stack();
                state.activeContext.push(state.rootContext);
                compiledArgs.push(arg.getValue(state));
                state.activeContext = currentActiveContext;
              });
              if (methodName.substr(0, 3) === "get" && !context2[methodName]) {
                return maybeHandleNullSafeNavigation(context2[methodName.charAt(3).toLowerCase() + methodName.substring(4)]);
              }
              if (methodName.substr(0, 3) === "set" && !context2[methodName]) {
                return context2[methodName.charAt(3).toLowerCase() + methodName.substring(4)] = compiledArgs[0];
              }
              if (Array.isArray(context2)) {
                if (methodName === "size") {
                  return context2.length;
                }
                if (methodName === "contains") {
                  return context2.includes(compiledArgs[0]);
                }
              }
              method = maybeHandleNullSafeNavigation(context2[methodName]);
              if (method) {
                return method.apply(context2, compiledArgs);
              }
              return null;
            };
            return node;
          }
          exports3.MethodReference = {
            create: createNode
          };
        },
        /* 14 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.PropertyReference = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(nullSafeNavigation, propertyName, position) {
            var node = _SpelNode.SpelNode.create("property", position);
            node.getRaw = function() {
              return propertyName;
            };
            node.getValue = function(state) {
              var context2 = state.activeContext.peek();
              if (!context2) {
                if (nullSafeNavigation) {
                  return null;
                }
                throw {
                  name: "ContextDoesNotExistException",
                  message: "Attempting to look up property '" + propertyName + "' for an undefined context."
                };
              }
              if (context2[propertyName] === void 0 || context2[propertyName] === null) {
                if (nullSafeNavigation) {
                  return null;
                }
                if (propertyName === "size" && Array.isArray(context2)) {
                  return context2.length;
                }
                throw {
                  name: "NullPointerException",
                  message: "Property '" + propertyName + "' does not exist."
                };
              }
              return context2[propertyName];
            };
            node.setValue = function(value, state) {
              var context2 = state.activeContext.peek();
              if (!context2) {
                throw {
                  name: "ContextDoesNotExistException",
                  message: "Attempting to assign property '" + propertyName + "' for an undefined context."
                };
              }
              return context2[propertyName] = value;
            };
            node.getName = function() {
              return propertyName;
            };
            return node;
          }
          exports3.PropertyReference = {
            create: createNode
          };
        },
        /* 15 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.VariableReference = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(variableName, position) {
            var node = _SpelNode.SpelNode.create("variable", position);
            node.getRaw = function() {
              return variableName;
            };
            node.getValue = function(state) {
              var context2 = state.activeContext.peek(), locals = state.locals;
              if (!context2) {
                throw {
                  name: "ContextDoesNotExistException",
                  message: "Attempting to look up variable '" + variableName + "' for an undefined context."
                };
              }
              if (variableName === "this") {
                return context2;
              }
              if (variableName === "root") {
                return state.rootContext;
              }
              return locals[variableName];
            };
            node.setValue = function(value, state) {
              var locals = state.locals;
              return locals[variableName] = value;
            };
            return node;
          }
          exports3.VariableReference = {
            create: createNode
          };
        },
        /* 16 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.CompoundExpression = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, expressionComponents) {
            var node = _SpelNode.SpelNode.create.apply(null, ["compound", position].concat(expressionComponents));
            function buildContextStack(state) {
              var childrenCount = node.getChildren().length, i2;
              for (i2 = 0; i2 < childrenCount; i2 += 1) {
                if (node.getChildren()[i2].getType() === "indexer") {
                  state.activeContext.push(state.activeContext.peek()[node.getChildren()[i2].getValue(state)]);
                } else {
                  state.activeContext.push(node.getChildren()[i2].getValue(state));
                }
              }
              return function unbuildContextStack() {
                for (i2 = 0; i2 < childrenCount; i2 += 1) {
                  state.activeContext.pop();
                }
              };
            }
            node.getValue = function(state) {
              var context2 = state.activeContext.peek(), value;
              if (!context2) {
                throw {
                  name: "ContextDoesNotExistException",
                  message: "Attempting to evaluate compound expression with an undefined context."
                };
              }
              var unbuildContextStack = buildContextStack(state);
              value = state.activeContext.peek();
              unbuildContextStack();
              return value;
            };
            node.setValue = function(value, state) {
              var unbuildContextStack = buildContextStack(state), childCount = node.getChildren().length;
              state.activeContext.pop();
              value = node.getChildren()[childCount - 1].setValue(value, state);
              state.activeContext.push(null);
              unbuildContextStack();
              return value;
            };
            return node;
          }
          exports3.CompoundExpression = {
            create: createNode
          };
        },
        /* 17 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.Indexer = void 0;
          var _SpelNode = __webpack_require__(0);
          var _Stack2 = __webpack_require__(1);
          function createNode(position, expressionComponents) {
            var node = _SpelNode.SpelNode.create.apply(null, ["indexer", position].concat(expressionComponents));
            node.getValue = function(state) {
              var activeContext = state.activeContext, context2, childrenCount = node.getChildren().length, i2, value;
              state.activeContext = new _Stack2.Stack();
              state.activeContext.push(state.rootContext);
              context2 = state.activeContext.peek();
              if (!context2) {
                throw {
                  name: "ContextDoesNotExistException",
                  message: "Attempting to evaluate compound expression with an undefined context."
                };
              }
              for (i2 = 0; i2 < childrenCount; i2 += 1) {
                state.activeContext.push(node.getChildren()[i2].getValue(state));
              }
              value = state.activeContext.peek();
              for (i2 = 0; i2 < childrenCount; i2 += 1) {
                state.activeContext.pop();
              }
              state.activeContext = activeContext;
              return value;
            };
            return node;
          }
          exports3.Indexer = {
            create: createNode
          };
        },
        /* 18 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.Assign = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, property2, assignedValue) {
            var node = _SpelNode.SpelNode.create("assign", position, property2, assignedValue);
            node.getValue = function(state) {
              var context2 = state.activeContext.peek();
              if (!context2) {
                throw {
                  name: "ContextDoesNotExistException",
                  message: "Attempting to assign property '" + property2.getValue(state) + "' for an undefined context."
                };
              }
              return property2.setValue(assignedValue.getValue(state), state);
            };
            return node;
          }
          exports3.Assign = {
            create: createNode
          };
        },
        /* 19 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpEQ = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("op-eq", position, left, right);
            node.getValue = function(state) {
              return left.getValue(state) === right.getValue(state);
            };
            return node;
          }
          exports3.OpEQ = {
            create: createNode
          };
        },
        /* 20 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpNE = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("op-ne", position, left, right);
            node.getValue = function(state) {
              return left.getValue(state) !== right.getValue(state);
            };
            return node;
          }
          exports3.OpNE = {
            create: createNode
          };
        },
        /* 21 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpGE = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("op-ge", position, left, right);
            node.getValue = function(state) {
              return left.getValue(state) >= right.getValue(state);
            };
            return node;
          }
          exports3.OpGE = {
            create: createNode
          };
        },
        /* 22 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpGT = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("op-gt", position, left, right);
            node.getValue = function(state) {
              return left.getValue(state) > right.getValue(state);
            };
            return node;
          }
          exports3.OpGT = {
            create: createNode
          };
        },
        /* 23 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpLE = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("op-le", position, left, right);
            node.getValue = function(state) {
              return left.getValue(state) <= right.getValue(state);
            };
            return node;
          }
          exports3.OpLE = {
            create: createNode
          };
        },
        /* 24 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpLT = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("op-lt", position, left, right);
            node.getValue = function(state) {
              return left.getValue(state) < right.getValue(state);
            };
            return node;
          }
          exports3.OpLT = {
            create: createNode
          };
        },
        /* 25 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpPlus = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("op-plus", position, left, right);
            node.getValue = function(state) {
              if (!right) {
                return +left.getValue(state);
              }
              return left.getValue(state) + right.getValue(state);
            };
            return node;
          }
          exports3.OpPlus = {
            create: createNode
          };
        },
        /* 26 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpMinus = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("op-minus", position, left, right);
            node.getValue = function(state) {
              if (!right) {
                return -left.getValue(state);
              }
              return left.getValue(state) - right.getValue(state);
            };
            return node;
          }
          exports3.OpMinus = {
            create: createNode
          };
        },
        /* 27 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpMultiply = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("op-multiply", position, left, right);
            node.getValue = function(state) {
              var leftValue = left.getValue(state), rightValue = right.getValue(state);
              if (typeof leftValue === "number" && typeof rightValue === "number") {
                return leftValue * rightValue;
              }
              if (typeof leftValue === "string" && typeof rightValue === "number") {
                var s2 = "", i2 = 0;
                for (; i2 < rightValue; i2 += 1) {
                  s2 += leftValue;
                }
                return s2;
              }
              return null;
            };
            return node;
          }
          exports3.OpMultiply = {
            create: createNode
          };
        },
        /* 28 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpDivide = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("op-divide", position, left, right);
            node.getValue = function(state) {
              return left.getValue(state) / right.getValue(state);
            };
            return node;
          }
          exports3.OpDivide = {
            create: createNode
          };
        },
        /* 29 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpModulus = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("op-modulus", position, left, right);
            node.getValue = function(state) {
              return left.getValue(state) % right.getValue(state);
            };
            return node;
          }
          exports3.OpModulus = {
            create: createNode
          };
        },
        /* 30 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpPower = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, base, exp) {
            var node = _SpelNode.SpelNode.create("op-power", position, base, exp);
            node.getValue = function(state) {
              return Math.pow(base.getValue(state), exp.getValue(state));
            };
            return node;
          }
          exports3.OpPower = {
            create: createNode
          };
        },
        /* 31 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpInc = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, postfix, int) {
            var node = _SpelNode.SpelNode.create("op-inc", position, int);
            node.getValue = function(state) {
              var cur = int.getValue(state);
              int.setValue(cur + 1, state);
              if (postfix) {
                return cur;
              }
              return cur + 1;
            };
            return node;
          }
          exports3.OpInc = {
            create: createNode
          };
        },
        /* 32 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpDec = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, postfix, int) {
            var node = _SpelNode.SpelNode.create("op-dec", position, int);
            node.getValue = function(state) {
              var cur = int.getValue(state);
              int.setValue(cur - 1, state);
              if (postfix) {
                return cur;
              }
              return cur - 1;
            };
            return node;
          }
          exports3.OpDec = {
            create: createNode
          };
        },
        /* 33 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpNot = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, expr) {
            var node = _SpelNode.SpelNode.create("op-not", position, expr);
            node.getValue = function(state) {
              return !expr.getValue(state);
            };
            return node;
          }
          exports3.OpNot = {
            create: createNode
          };
        },
        /* 34 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpAnd = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("op-and", position, left, right);
            node.getValue = function(state) {
              return !!left.getValue(state) && !!right.getValue(state);
            };
            return node;
          }
          exports3.OpAnd = {
            create: createNode
          };
        },
        /* 35 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpOr = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("op-or", position, left, right);
            node.getValue = function(state) {
              return !!left.getValue(state) || !!right.getValue(state);
            };
            return node;
          }
          exports3.OpOr = {
            create: createNode
          };
        },
        /* 36 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpMatches = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("matches", position, left, right);
            node.getValue = function(state) {
              var data = left.getValue(state);
              var regexpString = right.getValue(state);
              try {
                var regexp = new RegExp(regexpString);
                return !!regexp.exec(data);
              } catch (error2) {
                throw {
                  name: "EvaluationException",
                  message: error2.toString()
                };
              }
            };
            return node;
          }
          exports3.OpMatches = {
            create: createNode
          };
        },
        /* 37 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.Ternary = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, expression, ifTrue, ifFalse) {
            var node = _SpelNode.SpelNode.create("ternary", position, expression, ifTrue, ifFalse);
            node.getValue = function(state) {
              return expression.getValue(state) ? ifTrue.getValue(state) : ifFalse.getValue(state);
            };
            return node;
          }
          exports3.Ternary = {
            create: createNode
          };
        },
        /* 38 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.Elvis = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, expression, ifFalse) {
            var node = _SpelNode.SpelNode.create("elvis", position, expression, ifFalse);
            node.getValue = function(state) {
              return expression.getValue(state) !== null ? expression.getValue(state) : ifFalse.getValue(state);
            };
            return node;
          }
          exports3.Elvis = {
            create: createNode
          };
        },
        /* 39 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.InlineList = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, elements2) {
            var node = _SpelNode.SpelNode.create("list", position), list2 = [].concat(elements2 || []);
            node.getRaw = function() {
              return list2;
            };
            node.getValue = function(state) {
              return list2.map(function(element) {
                return element.getValue(state);
              });
            };
            return node;
          }
          exports3.InlineList = {
            create: createNode
          };
        },
        /* 40 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.InlineMap = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, elements2) {
            var node = _SpelNode.SpelNode.create("map", position), mapPieces = [].concat(elements2 || []);
            node.getValue = function(state) {
              var key = true, keyValue = null, map2 = {};
              mapPieces.forEach(function(piece) {
                if (key) {
                  if (piece.getType() === "property") {
                    keyValue = piece.getName();
                  } else {
                    keyValue = piece.getValue(state);
                  }
                } else {
                  map2[keyValue] = piece.getValue(state);
                }
                key = !key;
              });
              return map2;
            };
            return node;
          }
          exports3.InlineMap = {
            create: createNode
          };
        },
        /* 41 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.Selection = void 0;
          var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
            return typeof obj;
          } : function(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
          var _SpelNode = __webpack_require__(0);
          function matches(element, expr, state) {
            var doesMatch = false;
            state.activeContext.push(element);
            doesMatch = expr.getValue(state);
            state.activeContext.pop();
            return doesMatch;
          }
          function selectFromArray(collection, whichElement, expr, state) {
            var newCollection = collection.filter(function(element) {
              return matches(element, expr, state);
            });
            switch (whichElement) {
              case "ALL":
                return newCollection;
              case "FIRST":
                return newCollection[0] || null;
              case "LAST":
                if (newCollection.length) {
                  return newCollection[newCollection.length - 1];
                }
                return null;
            }
          }
          function selectFromMap(collection, whichElement, expr, state) {
            var newCollection = {}, entry, key, entries = [], returnValue = {};
            for (key in collection) {
              if (collection.hasOwnProperty(key)) {
                entry = {
                  key,
                  value: collection[key]
                };
                if (matches(entry, expr, state)) {
                  entries.push(entry);
                }
              }
            }
            switch (whichElement) {
              case "ALL":
                entries.forEach(function(entry2) {
                  newCollection[entry2.key] = entry2.value;
                });
                return newCollection;
              case "FIRST":
                if (entries.length) {
                  returnValue[entries[0].key] = entries[0].value;
                  return returnValue;
                }
                return null;
              case "LAST":
                if (entries.length) {
                  returnValue[entries[entries.length - 1].key] = entries[entries.length - 1].value;
                  return returnValue;
                }
                return null;
            }
            entries.forEach(function(entry2) {
              newCollection[entry2.key] = entry2.value;
            });
          }
          function createNode(nullSafeNavigation, whichElement, position, expr) {
            var node = _SpelNode.SpelNode.create("selection", position, expr);
            node.getValue = function(state) {
              var collection = state.activeContext.peek();
              if (collection) {
                if (Array.isArray(collection)) {
                  return selectFromArray(collection, whichElement, expr, state);
                } else if ((typeof collection === "undefined" ? "undefined" : _typeof2(collection)) === "object") {
                  return selectFromMap(collection, whichElement, expr, state);
                }
              }
              return null;
            };
            return node;
          }
          exports3.Selection = {
            create: createNode,
            FIRST: "FIRST",
            LAST: "LAST",
            ALL: "ALL"
          };
        },
        /* 42 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.Projection = void 0;
          var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
            return typeof obj;
          } : function(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
          var _SpelNode = __webpack_require__(0);
          function projectCollection(collection, expr, state) {
            return collection.map(function(element) {
              var matches;
              state.activeContext.push(element);
              matches = expr.getValue(state);
              state.activeContext.pop();
              return matches;
            });
          }
          function createNode(nullSafeNavigation, position, expr) {
            var node = _SpelNode.SpelNode.create("projection", position, expr);
            node.getValue = function(state) {
              var collection = state.activeContext.peek(), entries = [], key;
              if (Array.isArray(collection)) {
                return projectCollection(collection, expr, state);
              } else if ((typeof collection === "undefined" ? "undefined" : _typeof2(collection)) === "object") {
                for (key in collection) {
                  if (collection.hasOwnProperty(key)) {
                    entries.push(collection[key]);
                  }
                }
                return projectCollection(entries, expr, state);
              }
              return null;
            };
            return node;
          }
          exports3.Projection = {
            create: createNode
          };
        },
        /* 43 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpInstanceof = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("instanceof", position, left, right);
            node.getValue = function(state) {
              throw {
                name: "MethodNotImplementedException",
                message: "OpInstanceOf: Not implemented"
              };
            };
            return node;
          }
          exports3.OpInstanceof = {
            create: createNode
          };
        },
        /* 44 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.OpBetween = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, left, right) {
            var node = _SpelNode.SpelNode.create("between", position, left, right);
            node.getValue = function(state) {
              throw {
                name: "MethodNotImplementedException",
                message: "OpBetween: Not implemented"
              };
            };
            return node;
          }
          exports3.OpBetween = {
            create: createNode
          };
        },
        /* 45 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.TypeReference = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, node, _dims) {
            var node = _SpelNode.SpelNode.create("typeref", position, node);
            node.getValue = function(state) {
              throw {
                name: "MethodNotImplementedException",
                message: "TypeReference: Not implemented"
              };
            };
            return node;
          }
          exports3.TypeReference = {
            create: createNode
          };
        },
        /* 46 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.BeanReference = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(position, beanName) {
            var node = _SpelNode.SpelNode.create("beanref", position);
            node.getValue = function(state) {
              throw {
                name: "MethodNotImplementedException",
                message: "BeanReference: Not implemented"
              };
            };
            return node;
          }
          exports3.BeanReference = {
            create: createNode
          };
        },
        /* 47 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.Identifier = void 0;
          var _SpelNode = __webpack_require__(0);
          function createNode(identifierName, position) {
            var node = _SpelNode.SpelNode.create("identifier", position);
            node.getRaw = function() {
              return identifierName;
            };
            node.getValue = function(state) {
              throw {
                name: "MethodNotImplementedException",
                message: "Identifier: Not implemented"
              };
            };
            return node;
          }
          exports3.Identifier = {
            create: createNode
          };
        },
        /* 48 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.QualifiedIdentifier = void 0;
          var _SpelNode = __webpack_require__(0);
          function _toConsumableArray2(arr) {
            if (Array.isArray(arr)) {
              for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++) {
                arr2[i2] = arr[i2];
              }
              return arr2;
            } else {
              return Array.from(arr);
            }
          }
          function createNode(position, pieces) {
            var node = _SpelNode.SpelNode.create.apply(_SpelNode.SpelNode, ["qualifiedidentifier", position].concat(_toConsumableArray2(pieces)));
            node.getRaw = function() {
              return pieces.map(function(p2) {
                return p2.getRaw();
              });
            };
            node.getValue = function(state) {
              throw {
                name: "MethodNotImplementedException",
                message: "QualifiedIdentifier: Not implemented"
              };
            };
            return node;
          }
          exports3.QualifiedIdentifier = {
            create: createNode
          };
        },
        /* 49 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.ConstructorReference = void 0;
          var _SpelNode = __webpack_require__(0);
          var _Stack2 = __webpack_require__(1);
          function _toConsumableArray2(arr) {
            if (Array.isArray(arr)) {
              for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++) {
                arr2[i2] = arr[i2];
              }
              return arr2;
            } else {
              return Array.from(arr);
            }
          }
          function _toArray2(arr) {
            return Array.isArray(arr) ? arr : Array.from(arr);
          }
          function createNode(position, dimensions, nodes) {
            var isArray2 = nodes !== void 0;
            var dimension;
            if (isArray2) {
              dimension = dimensions.length && dimensions[0] && dimensions[0].getType() === "number" ? dimensions[0].getValue() : null;
            } else {
              nodes = dimensions;
              dimensions = void 0;
            }
            var _nodes = nodes, _nodes2 = _toArray2(_nodes);
            _nodes2[0];
            var args = _nodes2.slice(1);
            var node = _SpelNode.SpelNode.create.apply(_SpelNode.SpelNode, ["constructorref", position].concat(_toConsumableArray2(nodes)));
            node.getRaw = function() {
              return dimension;
            };
            node.getValue = function(state) {
              if (isArray2 && args.length <= 1) {
                var compiledArgs = [];
                args.forEach(function(arg) {
                  var currentActiveContext = state.activeContext;
                  state.activeContext = new _Stack2.Stack();
                  state.activeContext.push(state.rootContext);
                  compiledArgs.push(arg.getValue(state));
                  state.activeContext = currentActiveContext;
                });
                if (args.length === 1) {
                  return compiledArgs[0];
                } else {
                  return dimension ? new Array(dimension) : [];
                }
              }
              throw {
                name: "MethodNotImplementedException",
                message: "ConstructorReference: Not implemented"
              };
            };
            return node;
          }
          exports3.ConstructorReference = {
            create: createNode
          };
        },
        /* 50 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          function create(authentication, principal) {
            var context2 = {};
            context2.authentication = authentication || {};
            context2.principal = principal || {};
            context2.hasRole = function(role) {
              var hasRole = false;
              if (!role) {
                return false;
              }
              if (!context2.authentication && !Array.isArray(context2.authentication.authorities)) {
                return false;
              }
              context2.authentication.authorities.forEach(function(grantedAuthority) {
                if (grantedAuthority.authority.toLowerCase() === role.toLowerCase()) {
                  hasRole = true;
                }
              });
              return hasRole;
            };
            context2.hasPermission = function() {
              var args = Array.prototype.slice.call(arguments);
              if (args.length === 1) {
                return context2.hasRole(args[0]);
              }
            };
            return context2;
          }
          exports3.StandardContext = {
            create
          };
        }
        /******/
      ])
    );
  });
})(spel2js);
var spel2jsExports = spel2js.exports;
function ownKeys$l(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$l(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$l(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$l(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var loadFromSpel = function loadFromSpel2(logicTree, config2) {
  return _loadFromSpel(logicTree, config2, true);
};
var _loadFromSpel = function _loadFromSpel2(spelStr, config2) {
  var returnErrors = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var meta = {
    errors: []
  };
  var extendedConfig = extendConfig$1(config2);
  var conv = buildConv2(extendedConfig);
  var compiledExpression;
  var convertedObj;
  var jsTree = void 0;
  try {
    var compileRes = spel2jsExports.SpelExpressionEvaluator.compile(spelStr);
    compiledExpression = compileRes._compiledExpression;
  } catch (e2) {
    meta.errors.push(e2);
  }
  if (compiledExpression) {
    logger$1.debug("compiledExpression:", compiledExpression);
    convertedObj = convertCompiled(compiledExpression, meta);
    logger$1.debug("convertedObj:", convertedObj, meta);
    jsTree = convertToTree(convertedObj, conv, extendedConfig, meta);
    if (jsTree && jsTree.type != "group" && jsTree.type != "switch_group") {
      jsTree = wrapInDefaultConj2(jsTree, extendedConfig, convertedObj["not"]);
    }
    logger$1.debug("jsTree:", jsTree);
  }
  var immTree = jsTree ? loadTree(jsTree) : void 0;
  if (returnErrors) {
    return [immTree, meta.errors];
  } else {
    if (meta.errors.length)
      console.warn("Errors while importing from SpEL:", meta.errors);
    return immTree;
  }
};
var convertCompiled = function convertCompiled2(expr, meta) {
  var parentExpr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  var type2 = expr.getType();
  var children = expr.getChildren().map(function(child) {
    return convertCompiled2(child, meta, expr);
  });
  if (type2 == "op-or" || type2 == "op-and") {
    children = children.reduce(function(acc, child) {
      var canFlatize = child.type == type2 && !child.not;
      var flat = canFlatize ? child.children : [child];
      return [].concat(_toConsumableArray(acc), _toConsumableArray(flat));
    }, []);
  }
  if (type2 == "op-not") {
    if (children.length != 1) {
      meta.errors.push("Operator NOT should have 1 child, but got ".concat(children.length, "}"));
    }
    return _objectSpread$l(_objectSpread$l({}, children[0]), {}, {
      not: !(children[0].not || false)
    });
  }
  if (type2 == "compound") {
    children = children.filter(function(child) {
      var isListFix = child.type == "selection" && child.children.length == 1 && child.children[0].type == "boolean" && child.children[0].val == true;
      return !isListFix;
    });
    var selection = children.find(function(child) {
      return child.type == "selection";
    });
    if (selection && selection.children.length != 1) {
      meta.errors.push("Selection should have 1 child, but got ".concat(selection.children.length));
    }
    var filter = selection ? selection.children[0] : null;
    var lastChild = children[children.length - 1];
    var isSize = lastChild.type == "method" && lastChild.val.methodName == "size" || lastChild.type == "!func" && lastChild.methodName == "size";
    var isLength2 = lastChild.type == "property" && lastChild.val == "length";
    var sourceParts = children.filter(function(child) {
      return child !== selection && child !== lastChild;
    });
    var source = {
      type: "compound",
      children: sourceParts
    };
    if (isSize || isLength2) {
      return {
        type: "!aggr",
        filter,
        source
      };
    }
    children = children.filter(function(child) {
      var isThis = child.type == "variable" && child.val == "this";
      var isRoot = child.type == "variable" && child.val == "root";
      return !(isThis || isRoot);
    });
    children = children.map(function(child) {
      if (child.type == "indexer" && child.children.length == 1) {
        return {
          type: "indexer",
          val: child.children[0].val,
          itype: child.children[0].type
        };
      } else {
        return child;
      }
    });
    if (lastChild.type == "method") {
      var obj = children.filter(function(child) {
        return child !== lastChild;
      });
      return {
        type: "!func",
        obj,
        methodName: lastChild.val.methodName,
        args: lastChild.val.args
      };
    }
    if (lastChild.type == "!func") {
      var _obj = children.filter(function(child) {
        return child !== lastChild;
      });
      return _objectSpread$l(_objectSpread$l({}, lastChild), {}, {
        obj: _obj
      });
    }
  }
  var val;
  try {
    if (expr.getRaw) {
      val = expr.getRaw();
    } else if (expr.getValue.length == 0) {
      val = expr.getValue();
    }
  } catch (e2) {
    logger$1.error("[spel2js] Error in getValue()", e2);
  }
  if (type2 == "ternary") {
    val = flatizeTernary(children);
  }
  if (_typeof$2(val) === "object" && val !== null) {
    if (val.methodName || val.functionName) {
      val.args = val.args.map(function(child) {
        return convertCompiled2(child, meta, expr);
      });
    }
  }
  if (type2 == "list") {
    val = val.map(function(item) {
      return convertCompiled2(item, meta, expr);
    });
    if (!parentExpr && val.length == 1) {
      return val[0];
    }
  }
  if (type2 == "constructorref") {
    var qid = children.find(function(child) {
      return child.type == "qualifiedidentifier";
    });
    var cls = qid === null || qid === void 0 ? void 0 : qid.val;
    if (!cls) {
      meta.errors.push("Can't find qualifiedidentifier in constructorref children: ".concat(JSON.stringify(children)));
      return void 0;
    }
    var args = children.filter(function(child) {
      return child.type != "qualifiedidentifier";
    });
    return {
      type: "!new",
      cls,
      args
    };
  }
  if (type2 == "typeref") {
    var _qid = children.find(function(child) {
      return child.type == "qualifiedidentifier";
    });
    var _cls = _qid === null || _qid === void 0 ? void 0 : _qid.val;
    if (!_cls) {
      meta.errors.push("Can't find qualifiedidentifier in typeref children: ".concat(JSON.stringify(children)));
      return void 0;
    }
    children.filter(function(child) {
      return child.type != "qualifiedidentifier";
    });
    return {
      type: "!type",
      cls: _cls
    };
  }
  if (type2 == "function" || type2 == "method") {
    var _val = val, functionName = _val.functionName, methodName = _val.methodName, _args2 = _val.args;
    return {
      type: "!func",
      methodName: functionName || methodName,
      isVar: type2 == "function",
      args: _args2
    };
  }
  return {
    type: type2,
    children,
    val
  };
};
var flatizeTernary = function flatizeTernary2(children) {
  var flat = [];
  function _processTernaryChildren(tern) {
    var _tern = _slicedToArray$1(tern, 3), cond = _tern[0], if_val = _tern[1], else_val = _tern[2];
    flat.push([cond, if_val]);
    if ((else_val === null || else_val === void 0 ? void 0 : else_val.type) == "ternary") {
      _processTernaryChildren(else_val.children);
    } else {
      flat.push([void 0, else_val]);
    }
  }
  _processTernaryChildren(children);
  return flat;
};
var buildConv2 = function buildConv3(config2) {
  var operators2 = {};
  var _loop = function _loop4(opKey2) {
    var opConfig = config2.operators[opKey2];
    if (opConfig.spelOps) {
      opConfig.spelOps.forEach(function(spelOp) {
        var opk2 = spelOp;
        if (!operators2[opk2])
          operators2[opk2] = [];
        operators2[opk2].push(opKey2);
      });
    } else if (opConfig.spelOp) {
      var opk = opConfig.spelOp;
      if (!operators2[opk])
        operators2[opk] = [];
      operators2[opk].push(opKey2);
    } else {
      logger$1.log("[spel] No spelOp for operator ".concat(opKey2));
    }
  };
  for (var opKey in config2.operators) {
    _loop(opKey);
  }
  var conjunctions2 = {};
  for (var conjKey in config2.conjunctions) {
    var conjunctionDefinition = config2.conjunctions[conjKey];
    var ck = conjunctionDefinition.spelConj || conjKey.toLowerCase();
    conjunctions2[ck] = conjKey;
  }
  var funcs2 = {};
  for (var funcKey in config2.funcs) {
    var funcConfig = config2.funcs[funcKey];
    var fk = void 0;
    if (typeof funcConfig.spelFunc == "string") {
      fk = funcConfig.spelFunc;
    }
    if (fk) {
      if (!funcs2[fk])
        funcs2[fk] = [];
      funcs2[fk].push(funcKey);
    }
  }
  return {
    operators: operators2,
    conjunctions: conjunctions2,
    funcs: funcs2
  };
};
var convertPath = function convertPath2(parts, meta) {
  var isError = false;
  var res = parts.map(function(c2) {
    if (c2.type == "variable" || c2.type == "property" || c2.type == "indexer" && c2.itype == "string") {
      return c2.val;
    } else {
      isError = true;
      meta.errors.push("Unexpected item in compound: ".concat(JSON.stringify(c2)));
    }
  });
  return !isError ? res : void 0;
};
var convertArg = function convertArg2(spel, conv, config2, meta, parentSpel) {
  if (spel == void 0)
    return void 0;
  var fieldSeparator = config2.settings.fieldSeparator;
  var literalTypes = {
    number: "number",
    string: "text",
    "boolean": "boolean",
    "null": "null"
    // should not be
  };
  var groupFieldParts = parentSpel !== null && parentSpel !== void 0 && parentSpel._groupField ? [parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField] : [];
  if (spel.type == "compound") {
    var _spel$children, _spel$children$;
    var parts = convertPath(spel.children, meta);
    if (!parts) {
      return void 0;
    }
    var fullParts = [].concat(groupFieldParts, _toConsumableArray(parts));
    var isVariable = ((_spel$children = spel.children) === null || _spel$children === void 0 ? void 0 : (_spel$children$ = _spel$children[0]) === null || _spel$children$ === void 0 ? void 0 : _spel$children$.type) == "variable";
    return {
      valueSrc: "field",
      //valueType: todo
      isVariable,
      value: fullParts.join(fieldSeparator)
    };
  } else if (spel.type == "variable" || spel.type == "property") {
    var _fullParts = [].concat(groupFieldParts, [spel.val]);
    var _isVariable = spel.type == "variable";
    return {
      valueSrc: "field",
      //valueType: todo
      isVariable: _isVariable,
      value: _fullParts.join(fieldSeparator)
    };
  } else if (literalTypes[spel.type]) {
    var value = spel.val;
    var valueType = literalTypes[spel.type];
    if (parentSpel !== null && parentSpel !== void 0 && parentSpel.isUnary) {
      value = -value;
    }
    return {
      valueSrc: "value",
      valueType,
      value
    };
  } else if (spel.type == "list") {
    var _values$;
    var values = spel.val.map(function(v2) {
      return convertArg2(v2, conv, config2, meta, spel);
    });
    values.length ? (_values$ = values[0]) === null || _values$ === void 0 ? void 0 : _values$.valueType : null;
    var _value = values.map(function(v2) {
      return v2 === null || v2 === void 0 ? void 0 : v2.value;
    });
    var _valueType = "multiselect";
    return {
      valueSrc: "value",
      valueType: _valueType,
      value: _value
    };
  } else if (spel.type == "!func") {
    var _funcToOpMap;
    var obj = spel.obj, methodName = spel.methodName, args = spel.args;
    spel.isVar;
    var funcToOpMap = (_funcToOpMap = {}, _defineProperty$4(_funcToOpMap, ".contains", "like"), _defineProperty$4(_funcToOpMap, ".startsWith", "starts_with"), _defineProperty$4(_funcToOpMap, ".endsWith", "ends_with"), _defineProperty$4(_funcToOpMap, "$contains", "select_any_in"), _defineProperty$4(_funcToOpMap, ".equals", "multiselect_equals"), _defineProperty$4(_funcToOpMap, "CollectionUtils.containsAny()", "multiselect_contains"), _funcToOpMap);
    var convertedArgs = args.map(function(v2) {
      return convertArg2(v2, conv, config2, meta, _objectSpread$l(_objectSpread$l({}, spel), {}, {
        _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField
      }));
    });
    if (methodName == "contains" && obj && obj[0].type == "list") {
      var convertedObj = obj.map(function(v2) {
        return convertArg2(v2, conv, config2, meta, spel);
      });
      if (!(convertedArgs.length == 1 && convertedArgs[0].valueSrc == "field")) {
        meta.errors.push("Expected arg to method ".concat(methodName, " to be field but got: ").concat(JSON.stringify(convertedArgs)));
        return void 0;
      }
      var field = convertedArgs[0].value;
      if (!(convertedObj.length == 1 && convertedObj[0].valueType == "multiselect")) {
        meta.errors.push("Expected object of method ".concat(methodName, " to be inline list but got: ").concat(JSON.stringify(convertedObj)));
        return void 0;
      }
      var opKey = funcToOpMap["$" + methodName];
      var list2 = convertedObj[0];
      return buildRule(config2, meta, field, opKey, [list2], spel);
    } else if (obj && obj[0].type == "property" && funcToOpMap[obj[0].val + "." + methodName + "()"]) {
      var _opKey = funcToOpMap[obj[0].val + "." + methodName + "()"];
      var _field = convertedArgs[0].value;
      var _args3 = convertedArgs.slice(1);
      return buildRule(config2, meta, _field, _opKey, _args3, spel);
    } else if (funcToOpMap["." + methodName]) {
      var _opKey2 = funcToOpMap["." + methodName];
      var _parts = convertPath(obj, meta);
      if (_parts && convertedArgs.length == 1) {
        var _fullParts2 = [].concat(groupFieldParts, _toConsumableArray(_parts));
        var _field2 = _fullParts2.join(fieldSeparator);
        return buildRule(config2, meta, _field2, _opKey2, convertedArgs, spel);
      }
    } else if (methodName == "parse" && obj && obj[0].type == "!new" && obj[0].cls.at(-1) == "SimpleDateFormat") {
      var _args4 = obj[0].args.map(function(v2) {
        return convertArg2(v2, conv, config2, meta, _objectSpread$l(_objectSpread$l({}, spel), {}, {
          _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField
        }));
      });
      if (!(_args4.length == 1 && _args4[0].valueType == "text")) {
        meta.errors.push("Expected args of ".concat(obj[0].cls.join("."), ".").concat(methodName, " to be 1 string but got: ").concat(JSON.stringify(_args4)));
        return void 0;
      }
      if (!(convertedArgs.length == 1 && convertedArgs[0].valueType == "text")) {
        meta.errors.push("Expected args of ".concat(obj[0].cls.join("."), " to be 1 string but got: ").concat(JSON.stringify(convertedArgs)));
        return void 0;
      }
      var dateFormat = _args4[0].value;
      var dateString = convertedArgs[0].value;
      var _valueType2 = dateFormat.includes(" ") ? "datetime" : "date";
      var _field3 = null;
      var widget = _valueType2;
      var fieldConfig = getFieldConfig$8(config2, _field3);
      var widgetConfig = config2.widgets[widget || (fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.mainWidget)];
      var valueFormat = widgetConfig.valueFormat;
      var dateVal = hooks(dateString, hooks.ISO_8601);
      var _value2 = dateVal.isValid() ? dateVal.format(valueFormat) : void 0;
      return {
        valueSrc: "value",
        valueType: _valueType2,
        value: _value2
      };
    } else if (methodName == "parse" && obj && obj[0].type == "!type" && obj[0].cls.at(-1) == "LocalTime") {
      if (!(convertedArgs.length == 1 && convertedArgs[0].valueType == "text")) {
        meta.errors.push("Expected args of ".concat(obj[0].cls.join("."), " to be 1 string but got: ").concat(JSON.stringify(convertedArgs)));
        return void 0;
      }
      var timeString = convertedArgs[0].value;
      var _valueType3 = "time";
      var _field4 = null;
      var _widget = _valueType3;
      var _fieldConfig = getFieldConfig$8(config2, _field4);
      var _widgetConfig = config2.widgets[_widget || (_fieldConfig === null || _fieldConfig === void 0 ? void 0 : _fieldConfig.mainWidget)];
      var _valueFormat = _widgetConfig.valueFormat;
      var _dateVal = hooks(timeString, "HH:mm:ss");
      var _value3 = _dateVal.isValid() ? _dateVal.format(_valueFormat) : void 0;
      return {
        valueSrc: "value",
        valueType: _valueType3,
        value: _value3
      };
    } else {
      meta.errors.push("Unsupported method ".concat(methodName));
    }
  } else if (spel.type == "op-plus" && (parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel.type) == "ternary") {
    return buildCaseValueConcat(spel, conv, config2, meta);
  } else {
    meta.errors.push("Can't convert arg of type ".concat(spel.type));
  }
  return void 0;
};
var buildRule = function buildRule2(config2, meta, field, opKey, convertedArgs, spel) {
  if (convertedArgs.filter(function(v2) {
    return v2 === void 0;
  }).length) {
    return void 0;
  }
  var fieldConfig = getFieldConfig$8(config2, field);
  if (!fieldConfig) {
    meta.errors.push("No config for field ".concat(field));
    return void 0;
  }
  var canRev = true;
  var needWrapReverse = false;
  if (spel !== null && spel !== void 0 && spel.not && canRev) {
    var opConfig = config2.operators[opKey];
    if (opConfig.reversedOp) {
      opKey = opConfig.reversedOp;
      spel.not = false;
    } else {
      needWrapReverse = true;
    }
  }
  var widget = getWidgetForFieldOp$3(config2, field, opKey);
  var widgetConfig = config2.widgets[widget || fieldConfig.mainWidget];
  var asyncListValuesArr = convertedArgs.map(function(v2) {
    return v2.asyncListValues;
  }).filter(function(v2) {
    return v2 != void 0;
  });
  var asyncListValues = asyncListValuesArr.length ? asyncListValuesArr[0] : void 0;
  var res = {
    type: "rule",
    id: uuid$1(),
    properties: {
      field,
      operator: opKey,
      value: convertedArgs.map(function(v2) {
        return v2.value;
      }),
      valueSrc: convertedArgs.map(function(v2) {
        return v2.valueSrc;
      }),
      valueType: convertedArgs.map(function(v2) {
        if (v2.valueSrc == "value") {
          return (widgetConfig === null || widgetConfig === void 0 ? void 0 : widgetConfig.type) || (fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type) || v2.valueType;
        }
        return v2.valueType;
      }),
      asyncListValues
    }
  };
  if (needWrapReverse) {
    res = wrapInDefaultConj2(res, config2, spel === null || spel === void 0 ? void 0 : spel.not);
    if (spel !== null && spel !== void 0 && spel.not) {
      spel.not = false;
    }
  }
  return res;
};
var buildRuleGroup = function buildRuleGroup2(_ref, opKey, convertedArgs, config2, meta) {
  var groupFilter = _ref.groupFilter, groupFieldValue = _ref.groupFieldValue;
  if (groupFieldValue.valueSrc != "field")
    throw "Bad groupFieldValue: ".concat(JSON.stringify(groupFieldValue));
  var groupField = groupFieldValue.value;
  var groupOpRule = buildRule(config2, meta, groupField, opKey, convertedArgs);
  if (!groupOpRule)
    return void 0;
  var fieldConfig = getFieldConfig$8(config2, groupField);
  var mode = fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.mode;
  var res = _objectSpread$l(_objectSpread$l({}, groupFilter || {}), {}, {
    type: "rule_group",
    properties: _objectSpread$l(_objectSpread$l(_objectSpread$l({}, groupOpRule.properties), (groupFilter === null || groupFilter === void 0 ? void 0 : groupFilter.properties) || {}), {}, {
      mode
    })
  });
  if (!res.id)
    res.id = uuid$1();
  return res;
};
var compareArgs = function compareArgs2(left, right, spel, conv, config2, meta) {
  var parentSpel = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null;
  if (left.type == right.type) {
    if (left.type == "!aggr") {
      var _map = [left.source, right.source].map(function(v2) {
        return convertArg(v2, conv, config2, meta, _objectSpread$l(_objectSpread$l({}, spel), {}, {
          _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField
        }));
      }), _map22 = _slicedToArray$1(_map, 2), leftSource = _map22[0], rightSource = _map22[1];
      return leftSource.value == rightSource.value;
    } else {
      var _map32 = [left, right].map(function(v2) {
        return convertArg(v2, conv, config2, meta, _objectSpread$l(_objectSpread$l({}, spel), {}, {
          _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField
        }));
      }), _map4 = _slicedToArray$1(_map32, 2), leftVal = _map4[0], rightVal = _map4[1];
      return leftVal.value == rightVal.value;
    }
  }
  return false;
};
var convertToTree = function convertToTree2(spel, conv, config2, meta) {
  var parentSpel = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
  if (!spel)
    return void 0;
  var res;
  if (spel.type.indexOf("op-") == 0) {
    var op = spel.type.slice("op-".length);
    var isUnary = (op == "minus" || op == "plus") && spel.children.length == 1;
    if (isUnary) {
      spel.isUnary = true;
      return convertToTree2(spel.children[0], conv, config2, meta, spel);
    }
    var isBetweenNormal = op == "and" && spel.children.length == 2 && spel.children[0].type == "op-ge" && spel.children[1].type == "op-le";
    var isBetweenRev = op == "or" && spel.children.length == 2 && spel.children[0].type == "op-lt" && spel.children[1].type == "op-gt";
    var isBetween2 = isBetweenNormal || isBetweenRev;
    if (isBetween2) {
      var _spel$children$0$chil = _slicedToArray$1(spel.children[0].children, 2), left = _spel$children$0$chil[0], from2 = _spel$children$0$chil[1];
      var _spel$children$1$chil = _slicedToArray$1(spel.children[1].children, 2), right = _spel$children$1$chil[0], to2 = _spel$children$1$chil[1];
      var isNumbers = from2.type == "number" && to2.type == "number";
      var isSameSource = compareArgs(left, right, spel, conv, config2, meta, parentSpel);
      if (isNumbers && isSameSource) {
        from2.val;
        to2.val;
        var oneSpel = {
          type: "op-between",
          children: [left, from2, to2]
        };
        return convertToTree2(oneSpel, conv, config2, meta, parentSpel);
      }
    }
    var opKeys = conv.operators[op];
    if (op == "eq" && spel.children[1].type == "null") {
      opKeys = ["is_null"];
    } else if (op == "ne" && spel.children[1].type == "null") {
      opKeys = ["is_not_null"];
    } else if (op == "le" && spel.children[1].type == "string" && spel.children[1].val == "") {
      opKeys = ["is_empty"];
    } else if (op == "gt" && spel.children[1].type == "string" && spel.children[1].val == "") {
      opKeys = ["is_not_empty"];
    } else if (op == "between") {
      opKeys = ["between"];
    }
    var convertChildren = function convertChildren2() {
      return spel.children.map(function(child) {
        return convertToTree2(child, conv, config2, meta, _objectSpread$l(_objectSpread$l({}, spel), {}, {
          _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField
        }));
      });
    };
    if (op == "and" || op == "or") {
      var children1 = {};
      var vals = convertChildren();
      vals.forEach(function(v2) {
        if (v2) {
          var id = uuid$1();
          v2.id = id;
          if (v2.type != void 0) {
            children1[id] = v2;
          } else {
            meta.errors.push("Bad item in AND/OR: ".concat(JSON.stringify(v2)));
          }
        }
      });
      res = {
        type: "group",
        id: uuid$1(),
        children1,
        properties: {
          conjunction: conv.conjunctions[op],
          not: spel.not
        }
      };
    } else if (opKeys) {
      var _fieldObj$groupFieldV, _convertedArgs;
      var _vals = convertChildren();
      var fieldObj = _vals[0];
      var convertedArgs = _vals.slice(1);
      var groupField = fieldObj === null || fieldObj === void 0 ? void 0 : (_fieldObj$groupFieldV = fieldObj.groupFieldValue) === null || _fieldObj$groupFieldV === void 0 ? void 0 : _fieldObj$groupFieldV.value;
      var opArg = (_convertedArgs = convertedArgs) === null || _convertedArgs === void 0 ? void 0 : _convertedArgs[0];
      var opKey = opKeys[0];
      if (opKeys.length > 1) {
        logger$1.warn("[spel] Spel operator ".concat(op, " can be mapped to ").concat(opKeys));
        var field = fieldObj === null || fieldObj === void 0 ? void 0 : fieldObj.value;
        var widgets2 = opKeys.map(function(op2) {
          return {
            op: op2,
            widget: getWidgetForFieldOp$3(config2, field, op2)
          };
        });
        if (op == "eq" || op == "ne") {
          var ws = widgets2.find(function(_ref2) {
            _ref2.op;
            var widget = _ref2.widget;
            return widget && widget != "field";
          });
          if (ws) {
            opKey = ws.op;
          }
        }
      }
      if (fieldObj !== null && fieldObj !== void 0 && fieldObj.groupFieldValue) {
        if (opArg && opArg.groupFieldValue && opArg.groupFieldValue.valueSrc == "field" && opArg.groupFieldValue.value == groupField) {
          opKey = "all";
          convertedArgs = [];
        } else if (opKey == "equal" && opArg.valueSrc == "value" && opArg.valueType == "number" && opArg.value == 0) {
          opKey = "none";
          convertedArgs = [];
        } else if (opKey == "greater" && opArg.valueSrc == "value" && opArg.valueType == "number" && opArg.value == 0) {
          opKey = "some";
          convertedArgs = [];
        }
      }
      var canRev = true;
      var needWrapReverse = false;
      if (spel.not && canRev) {
        var opConfig = config2.operators[opKey];
        if (opConfig.reversedOp) {
          opKey = opConfig.reversedOp;
          spel.not = false;
        } else {
          needWrapReverse = true;
        }
      }
      if (!fieldObj)
        ;
      else if (fieldObj.groupFieldValue) {
        if (fieldObj.groupFieldValue.valueSrc != "field") {
          meta.errors.push("Expected group field ".concat(JSON.stringify(fieldObj)));
        }
        res = buildRuleGroup(fieldObj, opKey, convertedArgs, config2, meta);
      } else {
        if (fieldObj.valueSrc != "field") {
          meta.errors.push("Expected field ".concat(JSON.stringify(fieldObj)));
        }
        var _field5 = fieldObj.value;
        res = buildRule(config2, meta, _field5, opKey, convertedArgs);
      }
      if (needWrapReverse) {
        if (res.type !== "group") {
          res = wrapInDefaultConj2(res, config2, spel.not);
        } else {
          res.properties.not = !res.properties.not;
        }
      }
    } else {
      if (!parentSpel) {
        res = buildSimpleSwitch(spel, conv, config2, meta);
      }
      if (!res) {
        meta.errors.push("Can't convert op ".concat(op));
      }
    }
  } else if (spel.type == "!aggr") {
    var _groupFilter;
    var groupFieldValue = convertToTree2(spel.source, conv, config2, meta, _objectSpread$l(_objectSpread$l({}, spel), {}, {
      _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField
    }));
    var groupFilter = convertToTree2(spel.filter, conv, config2, meta, _objectSpread$l(_objectSpread$l({}, spel), {}, {
      _groupField: groupFieldValue === null || groupFieldValue === void 0 ? void 0 : groupFieldValue.value
    }));
    if (((_groupFilter = groupFilter) === null || _groupFilter === void 0 ? void 0 : _groupFilter.type) == "rule") {
      groupFilter = wrapInDefaultConj2(groupFilter, config2, spel.filter.not);
    }
    res = {
      groupFilter,
      groupFieldValue
    };
    if (!parentSpel) {
      res = void 0;
      meta.errors.push("Unexpected !aggr in root");
    }
  } else if (spel.type == "ternary") {
    var _children = {};
    spel.val.forEach(function(v2) {
      var _v = _slicedToArray$1(v2, 2), cond = _v[0], val = _v[1];
      var caseI = buildCase(cond, val, conv, config2, meta, spel);
      if (caseI) {
        _children[caseI.id] = caseI;
      }
    });
    res = {
      type: "switch_group",
      id: uuid$1(),
      children1: _children,
      properties: {}
    };
  } else {
    res = convertArg(spel, conv, config2, meta, parentSpel);
    if (res && !res.type && !parentSpel) {
      var sw = buildSimpleSwitch(spel, conv, config2, meta);
      if (sw) {
        res = sw;
      } else {
        res = void 0;
        meta.errors.push("Can't convert rule of type ".concat(spel.type, ", it looks like var/literal"));
      }
    }
  }
  return res;
};
var buildSimpleSwitch = function buildSimpleSwitch2(val, conv, config2, meta) {
  var children1 = {};
  var cond = null;
  var caseI = buildCase(cond, val, conv, config2, meta);
  if (caseI) {
    children1[caseI.id] = caseI;
  }
  var res = {
    type: "switch_group",
    id: uuid$1(),
    children1,
    properties: {}
  };
  return res;
};
var buildCase = function buildCase2(cond, val, conv, config2, meta) {
  var spel = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null;
  var valProperties = buildCaseValProperties(config2, meta, conv, val, spel);
  var caseI;
  if (cond) {
    caseI = convertToTree(cond, conv, config2, meta, spel);
    if (caseI && caseI.type) {
      if (caseI.type != "group") {
        caseI = wrapInDefaultConj2(caseI, config2);
      }
      caseI.type = "case_group";
    } else {
      meta.errors.push("Unexpected case: ".concat(JSON.stringify(caseI)));
      caseI = void 0;
    }
  } else {
    caseI = {
      id: uuid$1(),
      type: "case_group",
      properties: {}
    };
  }
  if (caseI) {
    caseI.properties = _objectSpread$l(_objectSpread$l({}, caseI.properties), valProperties);
  }
  return caseI;
};
var buildCaseValueConcat = function buildCaseValueConcat2(spel, conv, config2, meta) {
  var flat = [];
  function _processConcatChildren(children) {
    children.map(function(child) {
      if (child.type == "op-plus") {
        _processConcatChildren(child.children);
      } else {
        var convertedChild = convertArg(child, conv, config2, meta, spel);
        if (convertedChild) {
          flat.push(convertedChild);
        } else {
          meta.errors.push("Can't convert ".concat(child.type, " in concatenation"));
        }
      }
    });
  }
  _processConcatChildren(spel.children);
  return {
    valueSrc: "value",
    valueType: "case_value",
    value: flat
  };
};
var buildCaseValProperties = function buildCaseValProperties2(config2, meta, conv, val) {
  var spel = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
  var valProperties = {};
  var convVal;
  if ((val === null || val === void 0 ? void 0 : val.type) == "op-plus") {
    convVal = buildCaseValueConcat(val, conv, config2, meta);
  } else {
    convVal = convertArg(val, conv, config2, meta, spel);
  }
  var widgetDef = config2.widgets["case_value"];
  var importCaseValue = widgetDef === null || widgetDef === void 0 ? void 0 : widgetDef.spelImportValue;
  if (importCaseValue) {
    var _importCaseValue = importCaseValue(convVal), _importCaseValue2 = _slicedToArray$1(_importCaseValue, 2), normVal = _importCaseValue2[0], normErrors = _importCaseValue2[1];
    normErrors.map(function(e2) {
      return meta.errors.push(e2);
    });
    if (normVal) {
      valProperties = {
        value: [normVal],
        valueSrc: ["value"],
        valueType: ["case_value"]
      };
    }
  } else {
    meta.errors.push("No fucntion to import case value");
  }
  return valProperties;
};
var wrapInDefaultConj2 = function wrapInDefaultConj3(rule3, config2) {
  var not = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  return {
    type: "group",
    id: uuid$1(),
    children1: _defineProperty$4({}, rule3.id, rule3),
    properties: {
      conjunction: defaultConjunction(config2),
      not: not || false
    }
  };
};
const Import = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _loadFromJsonLogic,
  _loadFromSpel,
  checkTree,
  getTree,
  isImmutableTree,
  isJsonLogic,
  isTree,
  isValidTree,
  loadFromJsonLogic,
  loadFromSpel,
  loadTree
}, Symbol.toStringTag, { value: "Module" }));
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error2) {
    reject(error2);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
var regeneratorRuntime$1 = { exports: {} };
var _typeof = { exports: {} };
(function(module2) {
  function _typeof2(obj) {
    "@babel/helpers - typeof";
    return module2.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _typeof2(obj);
  }
  module2.exports = _typeof2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
})(_typeof);
var _typeofExports = _typeof.exports;
(function(module2) {
  var _typeof2 = _typeofExports["default"];
  function _regeneratorRuntime2() {
    module2.exports = _regeneratorRuntime2 = function _regeneratorRuntime3() {
      return exports2;
    }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    var exports2 = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty2 = Object.defineProperty || function(obj, key, desc) {
      obj[key] = desc.value;
    }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      return Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      }), obj[key];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function define2(obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self2, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context2 = new Context(tryLocsList || []);
      return defineProperty2(generator, "_invoke", {
        value: makeInvokeMethod(innerFn, self2, context2)
      }), generator;
    }
    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }
    exports2.wrap = wrap;
    var ContinueSentinel = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function() {
      return this;
    });
    var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method) {
        define(prototype, method, function(arg) {
          return this._invoke(method, arg);
        });
      });
    }
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if ("throw" !== record.type) {
          var result = record.arg, value = result.value;
          return value && "object" == _typeof2(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
            invoke("next", value2, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          }) : PromiseImpl.resolve(value).then(function(unwrapped) {
            result.value = unwrapped, resolve(result);
          }, function(error2) {
            return invoke("throw", error2, resolve, reject);
          });
        }
        reject(record.arg);
      }
      var previousPromise;
      defineProperty2(this, "_invoke", {
        value: function value(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function(resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(innerFn, self2, context2) {
      var state = "suspendedStart";
      return function(method, arg) {
        if ("executing" === state)
          throw new Error("Generator is already running");
        if ("completed" === state) {
          if ("throw" === method)
            throw arg;
          return doneResult();
        }
        for (context2.method = method, context2.arg = arg; ; ) {
          var delegate = context2.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context2);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel)
                continue;
              return delegateResult;
            }
          }
          if ("next" === context2.method)
            context2.sent = context2._sent = context2.arg;
          else if ("throw" === context2.method) {
            if ("suspendedStart" === state)
              throw state = "completed", context2.arg;
            context2.dispatchException(context2.arg);
          } else
            "return" === context2.method && context2.abrupt("return", context2.arg);
          state = "executing";
          var record = tryCatch(innerFn, self2, context2);
          if ("normal" === record.type) {
            if (state = context2.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
              continue;
            return {
              value: record.arg,
              done: context2.done
            };
          }
          "throw" === record.type && (state = "completed", context2.method = "throw", context2.arg = record.arg);
        }
      };
    }
    function maybeInvokeDelegate(delegate, context2) {
      var methodName = context2.method, method = delegate.iterator[methodName];
      if (void 0 === method)
        return context2.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context2.method = "return", context2.arg = void 0, maybeInvokeDelegate(delegate, context2), "throw" === context2.method) || "return" !== methodName && (context2.method = "throw", context2.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
      var record = tryCatch(method, delegate.iterator, context2.arg);
      if ("throw" === record.type)
        return context2.method = "throw", context2.arg = record.arg, context2.delegate = null, ContinueSentinel;
      var info = record.arg;
      return info ? info.done ? (context2[delegate.resultName] = info.value, context2.next = delegate.nextLoc, "return" !== context2.method && (context2.method = "next", context2.arg = void 0), context2.delegate = null, ContinueSentinel) : info : (context2.method = "throw", context2.arg = new TypeError("iterator result is not an object"), context2.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
    }
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod)
          return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next)
          return iterable;
        if (!isNaN(iterable.length)) {
          var i2 = -1, next = function next2() {
            for (; ++i2 < iterable.length; )
              if (hasOwn.call(iterable, i2))
                return next2.value = iterable[i2], next2.done = false, next2;
            return next2.value = void 0, next2.done = true, next2;
          };
          return next.next = next;
        }
      }
      return {
        next: doneResult
      };
    }
    function doneResult() {
      return {
        value: void 0,
        done: true
      };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty2(Gp, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: true
    }), defineProperty2(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: true
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports2.isGeneratorFunction = function(genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports2.mark = function(genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports2.awrap = function(arg) {
      return {
        __await: arg
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
      return this;
    }), exports2.AsyncIterator = AsyncIterator, exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
      return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
      return this;
    }), define(Gp, "toString", function() {
      return "[object Generator]";
    }), exports2.keys = function(val) {
      var object = Object(val), keys2 = [];
      for (var key in object)
        keys2.push(key);
      return keys2.reverse(), function next() {
        for (; keys2.length; ) {
          var key2 = keys2.pop();
          if (key2 in object)
            return next.value = key2, next.done = false, next;
        }
        return next.done = true, next;
      };
    }, exports2.values = values, Context.prototype = {
      constructor: Context,
      reset: function reset(skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
          for (var name in this)
            "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
      },
      stop: function stop2() {
        this.done = true;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type)
          throw rootRecord.arg;
        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done)
          throw exception;
        var context2 = this;
        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception, context2.next = loc, caught && (context2.method = "next", context2.arg = void 0), !!caught;
        }
        for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
          var entry = this.tryEntries[i2], record = entry.completion;
          if ("root" === entry.tryLoc)
            return handle("end");
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc)
                return handle(entry.catchLoc, true);
              if (this.prev < entry.finallyLoc)
                return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc)
                return handle(entry.catchLoc, true);
            } else {
              if (!hasFinally)
                throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc)
                return handle(entry.finallyLoc);
            }
          }
        }
      },
      abrupt: function abrupt(type2, arg) {
        for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
          var entry = this.tryEntries[i2];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        finallyEntry && ("break" === type2 || "continue" === type2) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type2, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if ("throw" === record.type)
          throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
          var entry = this.tryEntries[i2];
          if (entry.finallyLoc === finallyLoc)
            return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
          var entry = this.tryEntries[i2];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        return this.delegate = {
          iterator: values(iterable),
          resultName,
          nextLoc
        }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
      }
    }, exports2;
  }
  module2.exports = _regeneratorRuntime2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
})(regeneratorRuntime$1);
var regeneratorRuntimeExports = regeneratorRuntime$1.exports;
var runtime = regeneratorRuntimeExports();
var regenerator = runtime;
try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}
const _regeneratorRuntime = /* @__PURE__ */ getDefaultExportFromCjs(regenerator);
var simulateAsyncFetch = function simulateAsyncFetch2(all) {
  var cPageSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var delay = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1e3;
  return /* @__PURE__ */ function() {
    var _ref = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee(search, offset2, meta) {
      var pageSize2, filtered, currentOffset, values, newOffset, hasMore;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              pageSize2 = meta.pageSize != void 0 ? meta.pageSize : cPageSize;
              filtered = listValuesToArray$1(all).filter(function(_ref2) {
                var title2 = _ref2.title;
                return search == null ? true : title2.toUpperCase().indexOf(search.toUpperCase()) != -1;
              });
              pageSize2 ? Math.ceil(filtered.length / pageSize2) : 0;
              currentOffset = offset2 || 0;
              values = pageSize2 ? filtered.slice(currentOffset, currentOffset + pageSize2) : filtered;
              newOffset = pageSize2 ? currentOffset + values.length : null;
              hasMore = pageSize2 ? newOffset < filtered.length : false;
              console.debug("simulateAsyncFetch", {
                search,
                offset: offset2,
                values,
                hasMore,
                filtered
              });
              _context.next = 11;
              return sleep(delay);
            case 11:
              return _context.abrupt("return", {
                values,
                hasMore
              });
            case 12:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function(_x, _x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }();
};
var mergeListValues$1 = function mergeListValues(values, newValues) {
  var toStart = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (!newValues)
    return values;
  var old = values || [];
  var newFiltered = newValues.filter(function(v2) {
    return old.find(function(av) {
      return av.value == v2.value;
    }) == void 0;
  });
  var merged = toStart ? [].concat(_toConsumableArray(newFiltered), _toConsumableArray(old)) : [].concat(_toConsumableArray(old), _toConsumableArray(newFiltered));
  return merged;
};
var listValueToOption$1 = function listValueToOption(lv) {
  if (lv == null)
    return null;
  var title2 = lv.title, value = lv.value, disabled = lv.disabled, groupTitle = lv.groupTitle, renderTitle = lv.renderTitle;
  var option = {
    title: title2,
    value
  };
  if (disabled)
    option.disabled = disabled;
  if (groupTitle)
    option.groupTitle = groupTitle;
  if (renderTitle)
    option.renderTitle = renderTitle;
  return option;
};
var getListValue$1 = function getListValue(selectedValue, listValues2) {
  return mapListValues$5(listValues2, function(lv) {
    return lv.value === selectedValue ? lv : null;
  }).filter(function(v2) {
    return v2 !== null;
  }).shift();
};
const autocomplete = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getListValue: getListValue$1,
  listValueToOption: listValueToOption$1,
  mergeListValues: mergeListValues$1,
  simulateAsyncFetch
}, Symbol.toStringTag, { value: "Module" }));
const BasicUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Autocomplete: autocomplete,
  ConfigUtils: configUtils,
  DefaultUtils: defaultUtils,
  ExportUtils: _export,
  FuncUtils: funcUtils,
  ListUtils: listValues,
  RuleUtils: ruleUtils,
  TreeUtils: treeUtils,
  clone: clone$3,
  getSwitchValues,
  moment: hooks,
  uuid: uuid$1,
  validateAndFixTree: validateAndFixTree$1,
  validateTree
}, Symbol.toStringTag, { value: "Module" }));
function ownKeys$k(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$k(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$k(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$k(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var conjunctions$2 = {
  AND: {
    label: "And",
    mongoConj: "$and",
    jsonLogicConj: "and",
    sqlConj: "AND",
    spelConj: "and",
    spelConjs: ["and", "&&"],
    reversedConj: "OR",
    formatConj: function formatConj(children, conj, not, isForDisplay) {
      return children.size > 1 ? (not ? "NOT " : "") + "(" + children.join(" " + (isForDisplay ? "AND" : "&&") + " ") + ")" : (not ? "NOT (" : "") + children.first() + (not ? ")" : "");
    },
    sqlFormatConj: function sqlFormatConj(children, conj, not) {
      return children.size > 1 ? (not ? "NOT " : "") + "(" + children.join(" AND ") + ")" : (not ? "NOT (" : "") + children.first() + (not ? ")" : "");
    },
    spelFormatConj: function spelFormatConj(children, conj, not, omitBrackets) {
      if (not)
        omitBrackets = false;
      return children.size > 1 ? (not ? "!" : "") + (omitBrackets ? "" : "(") + children.join(" && ") + (omitBrackets ? "" : ")") : (not ? "!(" : "") + children.first() + (not ? ")" : "");
    }
  },
  OR: {
    label: "Or",
    mongoConj: "$or",
    jsonLogicConj: "or",
    sqlConj: "OR",
    spelConj: "or",
    spelConjs: ["or", "||"],
    reversedConj: "AND",
    formatConj: function formatConj2(children, conj, not, isForDisplay) {
      return children.size > 1 ? (not ? "NOT " : "") + "(" + children.join(" " + (isForDisplay ? "OR" : "||") + " ") + ")" : (not ? "NOT (" : "") + children.first() + (not ? ")" : "");
    },
    sqlFormatConj: function sqlFormatConj2(children, conj, not) {
      return children.size > 1 ? (not ? "NOT " : "") + "(" + children.join(" OR ") + ")" : (not ? "NOT (" : "") + children.first() + (not ? ")" : "");
    },
    spelFormatConj: function spelFormatConj2(children, conj, not, omitBrackets) {
      if (not)
        omitBrackets = false;
      return children.size > 1 ? (not ? "!" : "") + (omitBrackets ? "" : "(") + children.join(" || ") + (omitBrackets ? "" : ")") : (not ? "!(" : "") + children.first() + (not ? ")" : "");
    }
  }
};
var mongoFormatOp1 = function mongoFormatOp12(mop, mc, not, field, _op, value, useExpr, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
  var $field = typeof field == "string" && !field.startsWith("$") ? "$" + field : field;
  var mv = mc(value, fieldDef);
  if (mv === void 0)
    return void 0;
  if (not) {
    if (!useExpr && (!mop || mop == "$eq"))
      return _defineProperty$4({}, field, {
        "$ne": mv
      });
    return !useExpr ? _defineProperty$4({}, field, {
      "$not": _defineProperty$4({}, mop, mv)
    }) : {
      "$not": _defineProperty$4({}, mop, [$field, mv])
    };
  } else {
    if (!useExpr && (!mop || mop == "$eq"))
      return _defineProperty$4({}, field, mv);
    return !useExpr ? _defineProperty$4({}, field, _defineProperty$4({}, mop, mv)) : _defineProperty$4({}, mop, [$field, mv]);
  }
};
var mongoFormatOp2 = function mongoFormatOp22(mops, not, field, _op, values, useExpr, valueSrcs, valueTypes, opDef, operatorOptions, fieldDef) {
  var $field = typeof field == "string" && !field.startsWith("$") ? "$" + field : field;
  if (not) {
    var _$not3;
    return !useExpr ? _defineProperty$4({}, field, {
      "$not": (_$not3 = {}, _defineProperty$4(_$not3, mops[0], values[0]), _defineProperty$4(_$not3, mops[1], values[1]), _$not3)
    }) : {
      "$not": {
        "$and": [_defineProperty$4({}, mops[0], [$field, values[0]]), _defineProperty$4({}, mops[1], [$field, values[1]])]
      }
    };
  } else {
    var _field2;
    return !useExpr ? _defineProperty$4({}, field, (_field2 = {}, _defineProperty$4(_field2, mops[0], values[0]), _defineProperty$4(_field2, mops[1], values[1]), _field2)) : {
      "$and": [_defineProperty$4({}, mops[0], [$field, values[0]]), _defineProperty$4({}, mops[1], [$field, values[1]])]
    };
  }
};
var operators$2 = {
  equal: {
    label: "==",
    labelForFormat: "==",
    sqlOp: "=",
    spelOp: "==",
    spelOps: ["==", "eq"],
    reversedOp: "not_equal",
    formatOp: function formatOp(field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) {
      var opStr = isForDisplay ? "=" : opDef.label;
      if (valueTypes == "boolean" && isForDisplay)
        return value == "No" ? "NOT ".concat(field) : "".concat(field);
      else
        return "".concat(field, " ").concat(opStr, " ").concat(value);
    },
    mongoFormatOp: mongoFormatOp1.bind(null, "$eq", function(v2) {
      return v2;
    }, false),
    jsonLogic: "==",
    elasticSearchQueryType: "term"
  },
  not_equal: {
    isNotOp: true,
    label: "!=",
    labelForFormat: "!=",
    sqlOp: "<>",
    spelOp: "!=",
    spelOps: ["!=", "ne"],
    reversedOp: "equal",
    formatOp: function formatOp2(field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) {
      if (valueTypes == "boolean" && isForDisplay)
        return value == "No" ? "".concat(field) : "NOT ".concat(field);
      else
        return "".concat(field, " ").concat(opDef.label, " ").concat(value);
    },
    mongoFormatOp: mongoFormatOp1.bind(null, "$ne", function(v2) {
      return v2;
    }, false),
    jsonLogic: "!="
  },
  less: {
    label: "<",
    labelForFormat: "<",
    sqlOp: "<",
    spelOp: "<",
    spelOps: ["<", "lt"],
    reversedOp: "greater_or_equal",
    mongoFormatOp: mongoFormatOp1.bind(null, "$lt", function(v2) {
      return v2;
    }, false),
    jsonLogic: "<",
    elasticSearchQueryType: "range"
  },
  less_or_equal: {
    label: "<=",
    labelForFormat: "<=",
    sqlOp: "<=",
    spelOp: "<=",
    spelOps: ["<=", "le"],
    reversedOp: "greater",
    mongoFormatOp: mongoFormatOp1.bind(null, "$lte", function(v2) {
      return v2;
    }, false),
    jsonLogic: "<=",
    elasticSearchQueryType: "range"
  },
  greater: {
    label: ">",
    labelForFormat: ">",
    sqlOp: ">",
    spelOp: ">",
    spelOps: [">", "gt"],
    reversedOp: "less_or_equal",
    mongoFormatOp: mongoFormatOp1.bind(null, "$gt", function(v2) {
      return v2;
    }, false),
    jsonLogic: ">",
    elasticSearchQueryType: "range"
  },
  greater_or_equal: {
    label: ">=",
    labelForFormat: ">=",
    sqlOp: ">=",
    spelOp: ">=",
    spelOps: [">=", "ge"],
    reversedOp: "less",
    mongoFormatOp: mongoFormatOp1.bind(null, "$gte", function(v2) {
      return v2;
    }, false),
    jsonLogic: ">=",
    elasticSearchQueryType: "range"
  },
  like: {
    label: "Contains",
    labelForFormat: "Contains",
    reversedOp: "not_like",
    sqlOp: "LIKE",
    spelOp: ".contains",
    spelOps: ["matches", ".contains"],
    mongoFormatOp: mongoFormatOp1.bind(null, "$regex", function(v2) {
      return typeof v2 == "string" ? escapeRegExp(v2) : void 0;
    }, false),
    //jsonLogic: (field, op, val) => ({ "in": [val, field] }),
    jsonLogic: "in",
    _jsonLogicIsRevArgs: true,
    valueSources: ["value"],
    elasticSearchQueryType: "regexp"
  },
  not_like: {
    isNotOp: true,
    label: "Not contains",
    reversedOp: "like",
    labelForFormat: "Not Contains",
    sqlOp: "NOT LIKE",
    mongoFormatOp: mongoFormatOp1.bind(null, "$regex", function(v2) {
      return typeof v2 == "string" ? escapeRegExp(v2) : void 0;
    }, true),
    valueSources: ["value"]
  },
  starts_with: {
    label: "Starts with",
    labelForFormat: "Starts with",
    sqlOp: "LIKE",
    spelOp: ".startsWith",
    spelOps: ["matches", ".startsWith"],
    mongoFormatOp: mongoFormatOp1.bind(null, "$regex", function(v2) {
      return typeof v2 == "string" ? "^" + escapeRegExp(v2) : void 0;
    }, false),
    jsonLogic: void 0,
    // not supported
    valueSources: ["value"]
  },
  ends_with: {
    label: "Ends with",
    labelForFormat: "Ends with",
    sqlOp: "LIKE",
    spelOp: ".endsWith",
    spelOps: ["matches", ".endsWith"],
    mongoFormatOp: mongoFormatOp1.bind(null, "$regex", function(v2) {
      return typeof v2 == "string" ? escapeRegExp(v2) + "$" : void 0;
    }, false),
    jsonLogic: void 0,
    // not supported
    valueSources: ["value"]
  },
  between: {
    label: "Between",
    labelForFormat: "BETWEEN",
    sqlOp: "BETWEEN",
    cardinality: 2,
    formatOp: function formatOp3(field, op, values, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay) {
      var valFrom = values.first();
      var valTo = values.get(1);
      if (isForDisplay)
        return "".concat(field, " BETWEEN ").concat(valFrom, " AND ").concat(valTo);
      else
        return "".concat(field, " >= ").concat(valFrom, " && ").concat(field, " <= ").concat(valTo);
    },
    spelFormatOp: function spelFormatOp(field, op, values, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) {
      var valFrom = values[0];
      var valTo = values[1];
      return "".concat(field, " >= ").concat(valFrom, " && ").concat(field, " <= ").concat(valTo);
    },
    mongoFormatOp: mongoFormatOp2.bind(null, ["$gte", "$lte"], false),
    valueLabels: ["Value from", "Value to"],
    textSeparators: [null, "and"],
    reversedOp: "not_between",
    jsonLogic: "<=",
    validateValues: function validateValues(values) {
      if (values[0] != void 0 && values[1] != void 0) {
        return values[0] <= values[1] ? null : "Invalid range";
      }
      return null;
    },
    elasticSearchQueryType: function elasticSearchQueryType(type2) {
      return type2 === "time" ? "filter" : "range";
    }
  },
  not_between: {
    isNotOp: true,
    label: "Not between",
    labelForFormat: "NOT BETWEEN",
    sqlOp: "NOT BETWEEN",
    cardinality: 2,
    formatOp: function formatOp4(field, op, values, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay) {
      var valFrom = values.first();
      var valTo = values.get(1);
      if (isForDisplay)
        return "".concat(field, " NOT BETWEEN ").concat(valFrom, " AND ").concat(valTo);
      else
        return "(".concat(field, " < ").concat(valFrom, " || ").concat(field, " > ").concat(valTo, ")");
    },
    spelFormatOp: function spelFormatOp2(field, op, values, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) {
      var valFrom = values[0];
      var valTo = values[1];
      return "(".concat(field, " < ").concat(valFrom, " || ").concat(field, " > ").concat(valTo, ")");
    },
    mongoFormatOp: mongoFormatOp2.bind(null, ["$gte", "$lte"], true),
    valueLabels: ["Value from", "Value to"],
    textSeparators: [null, "and"],
    reversedOp: "between",
    validateValues: function validateValues2(values) {
      if (values[0] != void 0 && values[1] != void 0) {
        return values[0] <= values[1] ? null : "Invalid range";
      }
      return null;
    }
  },
  is_empty: {
    label: "Is empty",
    labelForFormat: "IS EMPTY",
    cardinality: 0,
    reversedOp: "is_not_empty",
    formatOp: function formatOp5(field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      return isForDisplay ? "".concat(field, " IS EMPTY") : "!".concat(field);
    },
    sqlFormatOp: function sqlFormatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
      var empty = sqlEmptyValue(fieldDef);
      return "COALESCE(".concat(field, ", ").concat(empty, ") = ").concat(empty);
    },
    spelFormatOp: function spelFormatOp3(field, op, values, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) {
      return "".concat(field, " <= ''");
    },
    mongoFormatOp: mongoFormatOp1.bind(null, "$in", function(v2, fieldDef) {
      return [mongoEmptyValue(fieldDef), null];
    }, false),
    jsonLogic: "!"
  },
  is_not_empty: {
    isNotOp: true,
    label: "Is not empty",
    labelForFormat: "IS NOT EMPTY",
    cardinality: 0,
    reversedOp: "is_empty",
    formatOp: function formatOp6(field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      return isForDisplay ? "".concat(field, " IS NOT EMPTY") : "!!".concat(field);
    },
    sqlFormatOp: function sqlFormatOp2(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
      var empty = sqlEmptyValue(fieldDef);
      return "COALESCE(".concat(field, ", ").concat(empty, ") <> ").concat(empty);
    },
    spelFormatOp: function spelFormatOp4(field, op, values, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) {
      return "".concat(field, " > ''");
    },
    mongoFormatOp: mongoFormatOp1.bind(null, "$nin", function(v2, fieldDef) {
      return [mongoEmptyValue(fieldDef), null];
    }, false),
    jsonLogic: "!!",
    elasticSearchQueryType: "exists"
  },
  is_null: {
    label: "Is null",
    labelForFormat: "IS NULL",
    sqlOp: "IS NULL",
    cardinality: 0,
    reversedOp: "is_not_null",
    formatOp: function formatOp7(field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      return isForDisplay ? "".concat(field, " IS NULL") : "!".concat(field);
    },
    spelFormatOp: function spelFormatOp5(field, op, values, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) {
      return "".concat(field, " == null");
    },
    // check if value is null OR not exists
    mongoFormatOp: mongoFormatOp1.bind(null, "$eq", function(v2) {
      return null;
    }, false),
    jsonLogic: "=="
  },
  is_not_null: {
    label: "Is not null",
    labelForFormat: "IS NOT NULL",
    sqlOp: "IS NOT NULL",
    cardinality: 0,
    reversedOp: "is_null",
    formatOp: function formatOp8(field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      return isForDisplay ? "".concat(field, " IS NOT NULL") : "!!".concat(field);
    },
    spelFormatOp: function spelFormatOp6(field, op, values, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) {
      return "".concat(field, " != null");
    },
    // check if value exists and is not null
    mongoFormatOp: mongoFormatOp1.bind(null, "$ne", function(v2) {
      return null;
    }, false),
    jsonLogic: "!=",
    elasticSearchQueryType: "exists"
  },
  select_equals: {
    label: "==",
    labelForFormat: "==",
    sqlOp: "=",
    // enum/set
    formatOp: function formatOp9(field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      var opStr = isForDisplay ? "=" : "==";
      return "".concat(field, " ").concat(opStr, " ").concat(value);
    },
    spelOp: "==",
    spelOps: ["==", "eq"],
    mongoFormatOp: mongoFormatOp1.bind(null, "$eq", function(v2) {
      return v2;
    }, false),
    reversedOp: "select_not_equals",
    jsonLogic: "==",
    elasticSearchQueryType: "term"
  },
  select_not_equals: {
    isNotOp: true,
    label: "!=",
    labelForFormat: "!=",
    sqlOp: "<>",
    // enum/set
    formatOp: function formatOp10(field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      return "".concat(field, " != ").concat(value);
    },
    spelOp: "!=",
    spelOps: ["!=", "ne"],
    mongoFormatOp: mongoFormatOp1.bind(null, "$ne", function(v2) {
      return v2;
    }, false),
    reversedOp: "select_equals",
    jsonLogic: "!="
  },
  select_any_in: {
    label: "Any in",
    labelForFormat: "IN",
    sqlOp: "IN",
    formatOp: function formatOp11(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      if (valueSrc == "value")
        return "".concat(field, " IN (").concat(values.join(", "), ")");
      else
        return "".concat(field, " IN (").concat(values, ")");
    },
    sqlFormatOp: function sqlFormatOp3(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
      if (valueSrc == "value") {
        return "".concat(field, " IN (").concat(values.join(", "), ")");
      } else
        return void 0;
    },
    spelOp: "$contains",
    // tip: $ means first arg is object
    mongoFormatOp: mongoFormatOp1.bind(null, "$in", function(v2) {
      return v2;
    }, false),
    reversedOp: "select_not_any_in",
    jsonLogic: "in",
    elasticSearchQueryType: "term"
  },
  select_not_any_in: {
    isNotOp: true,
    label: "Not in",
    labelForFormat: "NOT IN",
    sqlOp: "NOT IN",
    formatOp: function formatOp12(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      if (valueSrc == "value")
        return "".concat(field, " NOT IN (").concat(values.join(", "), ")");
      else
        return "".concat(field, " NOT IN (").concat(values, ")");
    },
    sqlFormatOp: function sqlFormatOp4(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
      if (valueSrc == "value") {
        return "".concat(field, " NOT IN (").concat(values.join(", "), ")");
      } else
        return void 0;
    },
    mongoFormatOp: mongoFormatOp1.bind(null, "$nin", function(v2) {
      return v2;
    }, false),
    reversedOp: "select_any_in"
  },
  // it's not "contains all", but "contains any" operator
  multiselect_contains: {
    label: "Contains",
    labelForFormat: "CONTAINS",
    formatOp: function formatOp13(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      if (valueSrc == "value")
        return "".concat(field, " CONTAINS [").concat(values.join(", "), "]");
      else
        return "".concat(field, " CONTAINS ").concat(values);
    },
    reversedOp: "multiselect_not_contains",
    jsonLogic2: "some-in",
    jsonLogic: function jsonLogic(field, op, vals) {
      return {
        "some": [field, {
          "in": [{
            "var": ""
          }, vals]
        }]
      };
    },
    //spelOp: ".containsAll",
    spelOp: "CollectionUtils.containsAny()",
    elasticSearchQueryType: "term",
    mongoFormatOp: mongoFormatOp1.bind(null, "$in", function(v2) {
      return v2;
    }, false)
  },
  multiselect_not_contains: {
    isNotOp: true,
    label: "Not contains",
    labelForFormat: "NOT CONTAINS",
    formatOp: function formatOp14(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      if (valueSrc == "value")
        return "".concat(field, " NOT CONTAINS [").concat(values.join(", "), "]");
      else
        return "".concat(field, " NOT CONTAINS ").concat(values);
    },
    reversedOp: "multiselect_contains"
  },
  multiselect_equals: {
    label: "Equals",
    labelForFormat: "==",
    sqlOp: "=",
    formatOp: function formatOp15(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      var opStr = isForDisplay ? "=" : "==";
      if (valueSrc == "value")
        return "".concat(field, " ").concat(opStr, " [").concat(values.join(", "), "]");
      else
        return "".concat(field, " ").concat(opStr, " ").concat(values);
    },
    sqlFormatOp: function sqlFormatOp5(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
      if (valueSrc == "value")
        return "".concat(field, " = '").concat(values.map(function(v2) {
          return SqlString$1.trim(v2);
        }).join(","), "'");
      else
        return void 0;
    },
    spelOp: ".equals",
    mongoFormatOp: mongoFormatOp1.bind(null, "$eq", function(v2) {
      return v2;
    }, false),
    reversedOp: "multiselect_not_equals",
    jsonLogic2: "all-in",
    jsonLogic: function jsonLogic2(field, op, vals) {
      return {
        // it's not "equals", but "includes" operator - just for example
        "all": [field, {
          "in": [{
            "var": ""
          }, vals]
        }]
      };
    },
    elasticSearchQueryType: "term"
  },
  multiselect_not_equals: {
    isNotOp: true,
    label: "Not equals",
    labelForFormat: "!=",
    sqlOp: "<>",
    formatOp: function formatOp16(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      if (valueSrc == "value")
        return "".concat(field, " != [").concat(values.join(", "), "]");
      else
        return "".concat(field, " != ").concat(values);
    },
    sqlFormatOp: function sqlFormatOp6(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
      if (valueSrc == "value")
        return "".concat(field, " != '").concat(values.map(function(v2) {
          return SqlString$1.trim(v2);
        }).join(","), "'");
      else
        return void 0;
    },
    mongoFormatOp: mongoFormatOp1.bind(null, "$ne", function(v2) {
      return v2;
    }, false),
    reversedOp: "multiselect_equals"
  },
  proximity: {
    label: "Proximity search",
    cardinality: 2,
    valueLabels: [{
      label: "Word 1",
      placeholder: "Enter first word"
    }, {
      label: "Word 2",
      placeholder: "Enter second word"
    }],
    textSeparators: [
      //'Word 1',
      //'Word 2'
    ],
    formatOp: function formatOp17(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      var val1 = values.first();
      var val2 = values.get(1);
      var prox = operatorOptions.get("proximity");
      return "".concat(field, " ").concat(val1, " NEAR/").concat(prox, " ").concat(val2);
    },
    sqlFormatOp: function sqlFormatOp7(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
      var val1 = values.first();
      var val2 = values.get(1);
      var aVal1 = SqlString$1.trim(val1);
      var aVal2 = SqlString$1.trim(val2);
      var prox = operatorOptions.get("proximity");
      return "CONTAINS(".concat(field, ", 'NEAR((").concat(aVal1, ", ").concat(aVal2, "), ").concat(prox, ")')");
    },
    mongoFormatOp: void 0,
    // not supported
    jsonLogic: void 0,
    // not supported
    options: {
      optionLabel: "Near",
      // label on top of "near" selectbox (for config.settings.showLabels==true)
      optionTextBefore: "Near",
      // label before "near" selectbox (for config.settings.showLabels==false)
      optionPlaceholder: "Select words between",
      // placeholder for "near" selectbox
      minProximity: 2,
      maxProximity: 10,
      defaults: {
        proximity: 2
      }
    }
  },
  some: {
    label: "Some",
    labelForFormat: "SOME",
    cardinality: 0,
    jsonLogic: "some",
    spelFormatOp: function spelFormatOp7(filteredSize) {
      return "".concat(filteredSize, " > 0");
    },
    mongoFormatOp: mongoFormatOp1.bind(null, "$gt", function(v2) {
      return 0;
    }, false)
  },
  all: {
    label: "All",
    labelForFormat: "ALL",
    cardinality: 0,
    jsonLogic: "all",
    spelFormatOp: function spelFormatOp8(filteredSize, op, fullSize) {
      return "".concat(filteredSize, " == ").concat(fullSize);
    },
    mongoFormatOp: mongoFormatOp1.bind(null, "$eq", function(v2) {
      return v2;
    }, false)
  },
  none: {
    label: "None",
    labelForFormat: "NONE",
    cardinality: 0,
    jsonLogic: "none",
    spelFormatOp: function spelFormatOp9(filteredSize) {
      return "".concat(filteredSize, " == 0");
    },
    mongoFormatOp: mongoFormatOp1.bind(null, "$eq", function(v2) {
      return 0;
    }, false)
  }
};
var widgets$3 = {
  text: {
    type: "text",
    jsType: "string",
    valueSrc: "value",
    valueLabel: "String",
    valuePlaceholder: "Enter string",
    formatValue: function formatValue7(val, fieldDef, wgtDef, isForDisplay) {
      return isForDisplay ? stringifyForDisplay$1(val) : JSON.stringify(val);
    },
    spelFormatValue: function spelFormatValue(val, fieldDef, wgtDef, op, opDef) {
      if (opDef.spelOp == "matches" && op != "regex") {
        var regex;
        if (op == "starts_with") {
          regex = "(?s)^".concat(escapeRegExp(val), ".*");
        } else if (op == "ends_with") {
          regex = "(?s).*".concat(escapeRegExp(val), "$");
        } else {
          regex = "(?s).*".concat(escapeRegExp(val), ".*");
        }
        return spelEscape(regex);
      } else {
        return spelEscape(val);
      }
    },
    sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
      if (opDef.sqlOp == "LIKE" || opDef.sqlOp == "NOT LIKE") {
        return SqlString$1.escapeLike(val, op != "starts_with", op != "ends_with");
      } else {
        return SqlString$1.escape(val);
      }
    },
    toJS: function toJS(val, fieldSettings) {
      return val;
    },
    mongoFormatValue: function mongoFormatValue(val, fieldDef, wgtDef) {
      return val;
    }
  },
  textarea: {
    type: "text",
    jsType: "string",
    valueSrc: "value",
    valueLabel: "Text",
    valuePlaceholder: "Enter text",
    formatValue: function formatValue8(val, fieldDef, wgtDef, isForDisplay) {
      return isForDisplay ? stringifyForDisplay$1(val) : JSON.stringify(val);
    },
    sqlFormatValue: function sqlFormatValue2(val, fieldDef, wgtDef, op, opDef) {
      if (opDef.sqlOp == "LIKE" || opDef.sqlOp == "NOT LIKE") {
        return SqlString$1.escapeLike(val, op != "starts_with", op != "ends_with");
      } else {
        return SqlString$1.escape(val);
      }
    },
    spelFormatValue: function spelFormatValue2(val) {
      return spelEscape(val);
    },
    toJS: function toJS2(val, fieldSettings) {
      return val;
    },
    mongoFormatValue: function mongoFormatValue2(val, fieldDef, wgtDef) {
      return val;
    },
    fullWidth: true
  },
  number: {
    type: "number",
    jsType: "number",
    valueSrc: "value",
    valueLabel: "Number",
    valuePlaceholder: "Enter number",
    valueLabels: [{
      label: "Number from",
      placeholder: "Enter number from"
    }, {
      label: "Number to",
      placeholder: "Enter number to"
    }],
    formatValue: function formatValue9(val, fieldDef, wgtDef, isForDisplay) {
      return isForDisplay ? stringifyForDisplay$1(val) : JSON.stringify(val);
    },
    sqlFormatValue: function sqlFormatValue3(val, fieldDef, wgtDef, op, opDef) {
      return SqlString$1.escape(val);
    },
    spelFormatValue: function spelFormatValue3(val, fieldDef, wgtDef) {
      var isFloat = wgtDef.step && !Number.isInteger(wgtDef.step);
      return spelEscape(val, isFloat);
    },
    toJS: function toJS3(val, fieldSettings) {
      return val;
    },
    mongoFormatValue: function mongoFormatValue3(val, fieldDef, wgtDef) {
      return val;
    }
  },
  slider: {
    type: "number",
    jsType: "number",
    valueSrc: "value",
    valueLabel: "Number",
    valuePlaceholder: "Enter number or move slider",
    formatValue: function formatValue10(val, fieldDef, wgtDef, isForDisplay) {
      return isForDisplay ? stringifyForDisplay$1(val) : JSON.stringify(val);
    },
    sqlFormatValue: function sqlFormatValue4(val, fieldDef, wgtDef, op, opDef) {
      return SqlString$1.escape(val);
    },
    spelFormatValue: function spelFormatValue4(val) {
      return spelEscape(val);
    },
    toJS: function toJS4(val, fieldSettings) {
      return val;
    },
    mongoFormatValue: function mongoFormatValue4(val, fieldDef, wgtDef) {
      return val;
    }
  },
  select: {
    type: "select",
    jsType: "string",
    valueSrc: "value",
    valueLabel: "Value",
    valuePlaceholder: "Select value",
    formatValue: function formatValue11(val, fieldDef, wgtDef, isForDisplay) {
      var valLabel = getTitleInListValues$1(fieldDef.fieldSettings.treeValues || fieldDef.fieldSettings.listValues || fieldDef.asyncListValues, val);
      return isForDisplay ? stringifyForDisplay$1(valLabel) : JSON.stringify(val);
    },
    sqlFormatValue: function sqlFormatValue5(val, fieldDef, wgtDef, op, opDef) {
      return SqlString$1.escape(val);
    },
    spelFormatValue: function spelFormatValue5(val) {
      return spelEscape(val);
    },
    toJS: function toJS5(val, fieldSettings) {
      return val;
    },
    mongoFormatValue: function mongoFormatValue5(val, fieldDef, wgtDef) {
      return val;
    }
  },
  multiselect: {
    type: "multiselect",
    jsType: "array",
    valueSrc: "value",
    valueLabel: "Values",
    valuePlaceholder: "Select values",
    formatValue: function formatValue12(vals, fieldDef, wgtDef, isForDisplay) {
      var valsLabels = vals.map(function(v2) {
        return getTitleInListValues$1(fieldDef.fieldSettings.treeValues || fieldDef.fieldSettings.listValues || fieldDef.asyncListValues, v2);
      });
      return isForDisplay ? valsLabels.map(stringifyForDisplay$1) : vals.map(JSON.stringify);
    },
    sqlFormatValue: function sqlFormatValue6(vals, fieldDef, wgtDef, op, opDef) {
      return vals.map(function(v2) {
        return SqlString$1.escape(v2);
      });
    },
    spelFormatValue: function spelFormatValue6(vals, fieldDef, wgtDef, op, opDef) {
      var isCallable = opDef.spelOp && opDef.spelOp[0] == "$";
      var res = spelEscape(vals);
      if (isCallable) {
        res = spelFixList(res);
      }
      return res;
    },
    toJS: function toJS6(val, fieldSettings) {
      return val;
    },
    mongoFormatValue: function mongoFormatValue6(val, fieldDef, wgtDef) {
      return val;
    }
  },
  date: {
    type: "date",
    jsType: "string",
    valueSrc: "value",
    dateFormat: "DD.MM.YYYY",
    valueFormat: "YYYY-MM-DD",
    useKeyboard: true,
    valueLabel: "Date",
    valuePlaceholder: "Enter date",
    valueLabels: [{
      label: "Date from",
      placeholder: "Enter date from"
    }, {
      label: "Date to",
      placeholder: "Enter date to"
    }],
    formatValue: function formatValue13(val, fieldDef, wgtDef, isForDisplay) {
      var dateVal = hooks(val, wgtDef.valueFormat);
      return isForDisplay ? dateVal.format(wgtDef.dateFormat) : JSON.stringify(val);
    },
    sqlFormatValue: function sqlFormatValue7(val, fieldDef, wgtDef, op, opDef) {
      var dateVal = hooks(val, wgtDef.valueFormat);
      return SqlString$1.escape(dateVal.format("YYYY-MM-DD"));
    },
    spelFormatValue: function spelFormatValue7(val, fieldDef, wgtDef, op, opDef) {
      var dateVal = hooks(val, wgtDef.valueFormat);
      return "new java.text.SimpleDateFormat('yyyy-MM-dd').parse('".concat(dateVal.format("YYYY-MM-DD"), "')");
    },
    jsonLogic: function jsonLogic3(val, fieldDef, wgtDef) {
      return hooks(val, wgtDef.valueFormat).toDate();
    },
    toJS: function toJS7(val, fieldSettings) {
      var dateVal = hooks(val, fieldSettings.valueFormat);
      return dateVal.isValid() ? dateVal.toDate() : void 0;
    },
    mongoFormatValue: function mongoFormatValue7(val, fieldDef, wgtDef) {
      var dateVal = hooks(val, wgtDef.valueFormat);
      return dateVal.isValid() ? dateVal.toDate() : void 0;
    }
  },
  time: {
    type: "time",
    jsType: "string",
    valueSrc: "value",
    timeFormat: "HH:mm",
    valueFormat: "HH:mm:ss",
    use12Hours: false,
    useKeyboard: true,
    valueLabel: "Time",
    valuePlaceholder: "Enter time",
    valueLabels: [{
      label: "Time from",
      placeholder: "Enter time from"
    }, {
      label: "Time to",
      placeholder: "Enter time to"
    }],
    formatValue: function formatValue14(val, fieldDef, wgtDef, isForDisplay) {
      var dateVal = hooks(val, wgtDef.valueFormat);
      return isForDisplay ? dateVal.format(wgtDef.timeFormat) : JSON.stringify(val);
    },
    sqlFormatValue: function sqlFormatValue8(val, fieldDef, wgtDef, op, opDef) {
      var dateVal = hooks(val, wgtDef.valueFormat);
      return SqlString$1.escape(dateVal.format("HH:mm:ss"));
    },
    spelFormatValue: function spelFormatValue8(val, fieldDef, wgtDef, op, opDef) {
      var dateVal = hooks(val, wgtDef.valueFormat);
      return "T(java.time.LocalTime).parse('".concat(dateVal.format("HH:mm:ss"), "')");
    },
    jsonLogic: function jsonLogic4(val, fieldDef, wgtDef) {
      var dateVal = hooks(val, wgtDef.valueFormat);
      return dateVal.get("hour") * 60 * 60 + dateVal.get("minute") * 60 + dateVal.get("second");
    },
    toJS: function toJS8(val, fieldSettings) {
      var dateVal = hooks(val, fieldSettings.valueFormat);
      return dateVal.isValid() ? dateVal.get("hour") * 60 * 60 + dateVal.get("minute") * 60 + dateVal.get("second") : void 0;
    },
    mongoFormatValue: function mongoFormatValue8(val, fieldDef, wgtDef) {
      var dateVal = hooks(val, wgtDef.valueFormat);
      return dateVal.get("hour") * 60 * 60 + dateVal.get("minute") * 60 + dateVal.get("second");
    },
    elasticSearchFormatValue: function elasticSearchFormatValue(queryType, value, operator, fieldName) {
      return {
        script: {
          script: {
            source: "doc[".concat(fieldName, "][0].getHour() >== params.min && doc[").concat(fieldName, "][0].getHour() <== params.max"),
            params: {
              min: value[0],
              max: value[1]
            }
          }
        }
      };
    }
  },
  datetime: {
    type: "datetime",
    jsType: "string",
    valueSrc: "value",
    timeFormat: "HH:mm",
    dateFormat: "DD.MM.YYYY",
    valueFormat: "YYYY-MM-DD HH:mm:ss",
    use12Hours: false,
    useKeyboard: true,
    valueLabel: "Datetime",
    valuePlaceholder: "Enter datetime",
    valueLabels: [{
      label: "Datetime from",
      placeholder: "Enter datetime from"
    }, {
      label: "Datetime to",
      placeholder: "Enter datetime to"
    }],
    formatValue: function formatValue15(val, fieldDef, wgtDef, isForDisplay) {
      var dateVal = hooks(val, wgtDef.valueFormat);
      return isForDisplay ? dateVal.format(wgtDef.dateFormat + " " + wgtDef.timeFormat) : JSON.stringify(val);
    },
    sqlFormatValue: function sqlFormatValue9(val, fieldDef, wgtDef, op, opDef) {
      var dateVal = hooks(val, wgtDef.valueFormat);
      return SqlString$1.escape(dateVal.toDate());
    },
    spelFormatValue: function spelFormatValue9(val, fieldDef, wgtDef, op, opDef) {
      var dateVal = hooks(val, wgtDef.valueFormat);
      return "new java.text.SimpleDateFormat('yyyy-MM-dd HH:mm:ss').parse('".concat(dateVal.format("YYYY-MM-DD HH:mm:ss"), "')");
    },
    jsonLogic: function jsonLogic5(val, fieldDef, wgtDef) {
      return hooks(val, wgtDef.valueFormat).toDate();
    },
    toJS: function toJS9(val, fieldSettings) {
      var dateVal = hooks(val, fieldSettings.valueFormat);
      return dateVal.isValid() ? dateVal.toDate() : void 0;
    },
    mongoFormatValue: function mongoFormatValue9(val, fieldDef, wgtDef) {
      var dateVal = hooks(val, wgtDef.valueFormat);
      return dateVal.isValid() ? dateVal.toDate() : void 0;
    }
  },
  "boolean": {
    type: "boolean",
    jsType: "boolean",
    valueSrc: "value",
    labelYes: "Yes",
    labelNo: "No",
    formatValue: function formatValue16(val, fieldDef, wgtDef, isForDisplay) {
      return isForDisplay ? val ? "Yes" : "No" : JSON.stringify(!!val);
    },
    sqlFormatValue: function sqlFormatValue10(val, fieldDef, wgtDef, op, opDef) {
      return SqlString$1.escape(val);
    },
    spelFormatValue: function spelFormatValue10(val, fieldDef, wgtDef, op, opDef) {
      return spelEscape(val);
    },
    defaultValue: false,
    toJS: function toJS10(val, fieldSettings) {
      return val;
    },
    mongoFormatValue: function mongoFormatValue10(val, fieldDef, wgtDef) {
      return val;
    }
  },
  field: {
    valueSrc: "field",
    formatValue: function formatValue17(val, fieldDef, wgtDef, isForDisplay, op, opDef, rightFieldDef) {
      return isForDisplay ? rightFieldDef.label || val : val;
    },
    sqlFormatValue: function sqlFormatValue11(val, fieldDef, wgtDef, op, opDef, rightFieldDef) {
      return val;
    },
    spelFormatValue: function spelFormatValue11(val, fieldDef, wgtDef, op, opDef) {
      return val;
    },
    valueLabel: "Field to compare",
    valuePlaceholder: "Select field to compare"
  },
  func: {
    valueSrc: "func",
    valueLabel: "Function",
    valuePlaceholder: "Select function"
  },
  case_value: {
    valueSrc: "value",
    type: "case_value",
    spelFormatValue: function spelFormatValue12(val) {
      return spelEscape(val === "" ? null : val);
    },
    spelImportValue: function spelImportValue(val) {
      return [val.value, []];
    }
  }
};
var types$4 = {
  text: {
    defaultOperator: "equal",
    mainWidget: "text",
    widgets: {
      text: {
        operators: ["equal", "not_equal", "like", "not_like", "starts_with", "ends_with", "proximity", "is_empty", "is_not_empty", "is_null", "is_not_null"],
        widgetProps: {},
        opProps: {}
      },
      textarea: {
        operators: ["equal", "not_equal", "like", "not_like", "starts_with", "ends_with", "is_empty", "is_not_empty", "is_null", "is_not_null"],
        widgetProps: {},
        opProps: {}
      },
      field: {
        operators: [
          //unary ops (like `is_empty`) will be excluded anyway, see getWidgetsForFieldOp()
          "equal",
          "not_equal",
          "proximity"
          //can exclude if you want
        ]
      }
    }
  },
  number: {
    defaultOperator: "equal",
    mainWidget: "number",
    widgets: {
      number: {
        operators: [
          "equal",
          "not_equal",
          "less",
          "less_or_equal",
          "greater",
          "greater_or_equal",
          "between",
          "not_between",
          // "is_empty",
          // "is_not_empty",
          "is_null",
          "is_not_null"
        ]
      },
      slider: {
        operators: [
          "equal",
          "not_equal",
          "less",
          "less_or_equal",
          "greater",
          "greater_or_equal",
          // "is_empty",
          // "is_not_empty",
          "is_null",
          "is_not_null"
        ]
      }
    }
  },
  date: {
    defaultOperator: "equal",
    widgets: {
      date: {
        operators: [
          "equal",
          "not_equal",
          "less",
          "less_or_equal",
          "greater",
          "greater_or_equal",
          "between",
          "not_between",
          // "is_empty",
          // "is_not_empty",
          "is_null",
          "is_not_null"
        ]
      }
    }
  },
  time: {
    defaultOperator: "equal",
    widgets: {
      time: {
        operators: [
          "equal",
          "not_equal",
          "less",
          "less_or_equal",
          "greater",
          "greater_or_equal",
          "between",
          "not_between",
          // "is_empty",
          // "is_not_empty",
          "is_null",
          "is_not_null"
        ]
      }
    }
  },
  datetime: {
    defaultOperator: "equal",
    widgets: {
      datetime: {
        operators: [
          "equal",
          "not_equal",
          "less",
          "less_or_equal",
          "greater",
          "greater_or_equal",
          "between",
          "not_between",
          // "is_empty",
          // "is_not_empty",
          "is_null",
          "is_not_null"
        ]
      }
    }
  },
  select: {
    mainWidget: "select",
    defaultOperator: "select_equals",
    widgets: {
      select: {
        operators: [
          "select_equals",
          "select_not_equals",
          // "is_empty",
          // "is_not_empty",
          "is_null",
          "is_not_null"
        ]
      },
      multiselect: {
        operators: [
          "select_any_in",
          "select_not_any_in",
          // "is_empty",
          // "is_not_empty",
          "is_null",
          "is_not_null"
        ]
      }
    }
  },
  multiselect: {
    defaultOperator: "multiselect_equals",
    widgets: {
      multiselect: {
        operators: [
          "multiselect_contains",
          "multiselect_not_contains",
          "multiselect_equals",
          "multiselect_not_equals",
          // "is_empty",
          // "is_not_empty",
          "is_null",
          "is_not_null"
        ]
      }
    }
  },
  "boolean": {
    defaultOperator: "equal",
    widgets: {
      "boolean": {
        operators: ["equal", "not_equal", "is_null", "is_not_null"],
        widgetProps: {
          //you can enable this if you don't use fields as value sources
          // hideOperator: true,
          // operatorInlineLabel: "is",
        }
      },
      field: {
        operators: ["equal", "not_equal"]
      }
    }
  },
  "!group": {
    defaultOperator: "some",
    mainWidget: "number",
    widgets: {
      number: {
        widgetProps: {
          min: 0
        },
        operators: [
          // w/o operand
          "some",
          "all",
          "none",
          // w/ operand - count
          "equal",
          "not_equal",
          "less",
          "less_or_equal",
          "greater",
          "greater_or_equal",
          "between",
          "not_between"
        ],
        opProps: {
          equal: {
            label: "Count =="
          },
          not_equal: {
            label: "Count !="
          },
          less: {
            label: "Count <"
          },
          less_or_equal: {
            label: "Count <="
          },
          greater: {
            label: "Count >"
          },
          greater_or_equal: {
            label: "Count >="
          },
          between: {
            label: "Count between"
          },
          not_between: {
            label: "Count not between"
          }
        }
      }
    }
  },
  "case_value": {
    mainWidget: "case_value",
    widgets: {
      case_value: {}
    }
  }
};
var settings$3 = _objectSpread$k(_objectSpread$k({}, settings$4), {}, {
  convertableWidgets: {
    "number": ["slider", "rangeslider"],
    "slider": ["number", "rangeslider"],
    "rangeslider": ["number", "slider"],
    "text": ["textarea"],
    "textarea": ["text"]
  },
  formatSpelField: function formatSpelField(field, parentField, parts, partsExt, fieldDefinition, config2) {
    var fieldName = partsExt.map(function(_ref12, ind) {
      var key = _ref12.key, parent2 = _ref12.parent;
      if (ind == 0) {
        if (parent2 == "[map]")
          return "#this[".concat(spelEscape(key), "]");
        else if (parent2 == "[class]")
          return key;
        else
          return key;
      } else {
        if (parent2 == "map" || parent2 == "[map]")
          return "[".concat(spelEscape(key), "]");
        else if (parent2 == "class" || parent2 == "[class]")
          return ".".concat(key);
        else
          return ".".concat(key);
      }
    }).join("");
    if (fieldDefinition.isSpelVariable) {
      fieldName = "#" + fieldName;
    }
    return fieldName;
  },
  sqlFormatReverse: function sqlFormatReverse(q2) {
    if (q2 == void 0)
      return void 0;
    return "NOT(" + q2 + ")";
  },
  spelFormatReverse: function spelFormatReverse(q2) {
    if (q2 == void 0)
      return void 0;
    return "!(" + q2 + ")";
  },
  formatReverse: function formatReverse(q2, operator, reversedOp, operatorDefinition, revOperatorDefinition, isForDisplay) {
    if (q2 == void 0)
      return void 0;
    if (isForDisplay)
      return "NOT (" + q2 + ")";
    else
      return "!(" + q2 + ")";
  },
  formatAggr: function formatAggr(whereStr, aggrField, operator, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay, aggrFieldDef) {
    var labelForFormat = opDef.labelForFormat, cardinality = opDef.cardinality;
    if (cardinality == 0) {
      var cond = whereStr ? " HAVE ".concat(whereStr) : "";
      return "".concat(labelForFormat, " OF ").concat(aggrField).concat(cond);
    } else if (cardinality == void 0 || cardinality == 1) {
      var _cond = whereStr ? " WHERE ".concat(whereStr) : "";
      return "COUNT OF ".concat(aggrField).concat(_cond, " ").concat(labelForFormat, " ").concat(value);
    } else if (cardinality == 2) {
      var _cond2 = whereStr ? " WHERE ".concat(whereStr) : "";
      var valFrom = value.first();
      var valTo = value.get(1);
      return "COUNT OF ".concat(aggrField).concat(_cond2, " ").concat(labelForFormat, " ").concat(valFrom, " AND ").concat(valTo);
    }
  },
  jsonLogic: {
    groupVarKey: "var",
    altVarKey: "var",
    lockedOp: "locked"
  },
  canCompareFieldWithField: function canCompareFieldWithField(leftField, leftFieldConfig, rightField, rightFieldConfig) {
    return true;
  },
  // enable compare fields
  valueSourcesInfo: {
    value: {
      label: "Value"
    },
    field: {
      label: "Field",
      widget: "field"
    },
    func: {
      label: "Function",
      widget: "func"
    }
  }
});
const CoreConfig = {
  conjunctions: conjunctions$2,
  operators: operators$2,
  widgets: widgets$3,
  types: types$4,
  settings: settings$3
};
var ADD_GROUP = "ADD_GROUP";
var ADD_CASE_GROUP = "ADD_CASE_GROUP";
var REMOVE_GROUP = "REMOVE_GROUP";
var SET_CONJUNCTION = "SET_CONJUNCTION";
var SET_NOT = "SET_NOT";
var ADD_RULE = "ADD_RULE";
var REMOVE_RULE = "REMOVE_RULE";
var SET_FIELD = "SET_FIELD";
var SET_OPERATOR = "SET_OPERATOR";
var SET_VALUE = "SET_VALUE";
var SET_VALUE_SRC = "SET_VALUE_SRC";
var SET_OPERATOR_OPTION = "SET_OPERATOR_OPTION";
var SET_LOCK = "SET_LOCK";
var SET_TREE = "SET_TREE";
var MOVE_ITEM = "MOVE_ITEM";
var PLACEMENT_AFTER$1 = "after";
var PLACEMENT_BEFORE$1 = "before";
var PLACEMENT_APPEND$1 = "append";
var PLACEMENT_PREPEND$1 = "prepend";
var SET_DRAG_PROGRESS$1 = "SET_DRAG_PROGRESS";
var SET_DRAG_START$1 = "SET_DRAG_START";
var SET_DRAG_END$1 = "SET_DRAG_END";
var baseAssignValue = _baseAssignValue, baseForOwn = _baseForOwn, baseIteratee$1 = _baseIteratee;
function mapValues(object, iteratee) {
  var result = {};
  iteratee = baseIteratee$1(iteratee);
  baseForOwn(object, function(value, key, object2) {
    baseAssignValue(result, key, iteratee(value, key, object2));
  });
  return result;
}
var mapValues_1 = mapValues;
const mapValues$1 = /* @__PURE__ */ getDefaultExportFromCjs(mapValues_1);
function _createForOfIteratorHelper$2(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i2 = 0;
      var F2 = function F3() {
      };
      return { s: F2, n: function n2() {
        if (i2 >= o.length)
          return { done: true };
        return { done: false, value: o[i2++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F2 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it = it.call(o);
  }, n: function n2() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f2() {
    try {
      if (!normalCompletion && it["return"] != null)
        it["return"]();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray$2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$2(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$2(o, minLen);
}
function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
function ownKeys$j(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$j(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$j(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$j(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var addNewGroup = function addNewGroup2(state, path, type2, groupUuid, properties, config2) {
  var children = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null;
  var meta = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : {};
  var shouldCreateEmptyGroup = config2.settings.shouldCreateEmptyGroup;
  var groupPath = path.push(groupUuid);
  var canAddNewRule = !shouldCreateEmptyGroup;
  var isDefaultCase = !!(meta !== null && meta !== void 0 && meta.isDefaultCase);
  var origState = state;
  state = addItem(state, path, type2, groupUuid, defaultGroupProperties(config2).merge(properties || {}), config2, children);
  if (state !== origState) {
    if (!children && !isDefaultCase) {
      state = state.setIn(expandTreePath(groupPath, "children1"), new Immutable.OrderedMap());
      if (canAddNewRule) {
        state = addItem(state, groupPath, "rule", uuid$1(), defaultRuleProperties(config2), config2);
      }
    }
    state = fixPathsInTree(state);
  }
  return state;
};
var removeGroup$1 = function removeGroup(state, path, config2) {
  state = removeItem(state, path);
  var canLeaveEmptyGroup = config2.settings.canLeaveEmptyGroup;
  var parentPath = path.slice(0, -1);
  var isEmptyParentGroup = !hasChildren(state, parentPath);
  if (isEmptyParentGroup && !canLeaveEmptyGroup) {
    state = fixEmptyGroupsInTree(state);
    if (isEmptyTree(state) && !canLeaveEmptyGroup) {
      state = addItem(state, new Immutable.List(), "rule", uuid$1(), defaultRuleProperties(config2), config2);
    }
  }
  state = fixPathsInTree(state);
  return state;
};
var removeRule$1 = function removeRule(state, path, config2) {
  state = removeItem(state, path);
  var canLeaveEmptyGroup = config2.settings.canLeaveEmptyGroup;
  var parentPath = path.pop();
  var parent2 = state.getIn(expandTreePath(parentPath));
  var parentField = parent2.getIn(["properties", "field"]);
  var parentOperator = parent2.getIn(["properties", "operator"]);
  parent2.getIn(["properties", "value", 0]);
  var parentFieldConfig = parentField ? getFieldConfig$8(config2, parentField) : null;
  var parentOperatorConfig = parentOperator ? getOperatorConfig$4(config2, parentOperator, parentField) : null;
  var hasGroupCountRule = parentField && parentOperator && parentOperatorConfig.cardinality != 0;
  var isParentRuleGroup = parent2.get("type") == "rule_group";
  var isEmptyParentGroup = !hasChildren(state, parentPath);
  var canLeaveEmpty = isParentRuleGroup ? hasGroupCountRule && parentFieldConfig.initialEmptyWhere : canLeaveEmptyGroup;
  if (isEmptyParentGroup && !canLeaveEmpty) {
    if (isParentRuleGroup) {
      state = state.deleteIn(expandTreePath(parentPath));
    }
    state = fixEmptyGroupsInTree(state);
    if (isEmptyTree(state) && !canLeaveEmptyGroup) {
      state = addItem(state, new Immutable.List(), "rule", uuid$1(), defaultRuleProperties(config2), config2);
    }
  }
  state = fixPathsInTree(state);
  return state;
};
var setNot$1 = function setNot(state, path, not) {
  return state.setIn(expandTreePath(path, "properties", "not"), not);
};
var setLock$1 = function setLock(state, path, lock) {
  return removeIsLockedInTree(state.setIn(expandTreePath(path, "properties", "isLocked"), lock));
};
var setConjunction$1 = function setConjunction(state, path, conjunction) {
  return state.setIn(expandTreePath(path, "properties", "conjunction"), conjunction);
};
var _addChildren1 = function _addChildren12(config2, item, children) {
  if (children && Array.isArray(children)) {
    item.children1 = new Immutable.OrderedMap(children.reduce(function(map2, it) {
      var id1 = uuid$1();
      var it1 = _objectSpread$j(_objectSpread$j({}, it), {}, {
        properties: defaultItemProperties(config2, it).merge(it.properties || {}),
        id: id1
      });
      _addChildren12(config2, it1, it1.children1);
      return _objectSpread$j(_objectSpread$j({}, map2), {}, _defineProperty$4({}, id1, new Immutable.Map(it1)));
    }, {}));
  }
};
var addItem = function addItem2(state, path, type2, id, properties, config2) {
  var children = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null;
  if (type2 == "switch_group")
    throw new Error("Can't add switch_group programmatically");
  var _config$settings = config2.settings, maxNumberOfCases = _config$settings.maxNumberOfCases, maxNumberOfRules = _config$settings.maxNumberOfRules, maxNesting = _config$settings.maxNesting;
  var rootType = state.get("type");
  var isTernary = rootType == "switch_group";
  var targetItem = state.getIn(expandTreePath(path));
  var caseGroup = isTernary ? state.getIn(expandTreePath(path.take(2))) : null;
  var childrenPath = expandTreePath(path, "children1");
  var targetChildren = state.getIn(childrenPath);
  var hasChildren3 = !!targetChildren && targetChildren.size;
  var targetChildrenSize = hasChildren3 ? targetChildren.size : null;
  var currentNumber, maxNumber;
  if (type2 == "case_group") {
    currentNumber = targetChildrenSize;
    maxNumber = maxNumberOfCases;
  } else if (type2 == "group") {
    currentNumber = path.size;
    maxNumber = maxNesting;
  } else if ((targetItem === null || targetItem === void 0 ? void 0 : targetItem.get("type")) == "rule_group")
    ;
  else {
    currentNumber = isTernary ? getTotalRulesCountInTree$2(caseGroup) : getTotalRulesCountInTree$2(state);
    maxNumber = maxNumberOfRules;
  }
  var canAdd = maxNumber && currentNumber ? currentNumber < maxNumber : true;
  var item = {
    type: type2,
    id,
    properties
  };
  _addChildren1(config2, item, children);
  var isLastDefaultCase = type2 == "case_group" && hasChildren3 && targetChildren.last().get("children1") == null;
  if (canAdd) {
    var newChildren = new Immutable.OrderedMap(_defineProperty$4({}, id, new Immutable.Map(item)));
    if (!hasChildren3) {
      state = state.setIn(childrenPath, newChildren);
    } else if (isLastDefaultCase) {
      var _Immutable$OrderedMap2;
      var last2 = targetChildren.last();
      var newChildrenWithLast = new Immutable.OrderedMap((_Immutable$OrderedMap2 = {}, _defineProperty$4(_Immutable$OrderedMap2, id, new Immutable.Map(item)), _defineProperty$4(_Immutable$OrderedMap2, last2.get("id"), last2), _Immutable$OrderedMap2));
      state = state.deleteIn(expandTreePath(childrenPath, "children1", last2.get("id")));
      state = state.mergeIn(childrenPath, newChildrenWithLast);
    } else {
      state = state.mergeIn(childrenPath, newChildren);
    }
    state = fixPathsInTree(state);
  }
  return state;
};
var removeItem = function removeItem2(state, path) {
  state = state.deleteIn(expandTreePath(path));
  state = fixPathsInTree(state);
  return state;
};
var moveItem$1 = function moveItem(state, fromPath, toPath, placement, config2) {
  var from2 = getItemByPath(state, fromPath);
  var sourcePath = fromPath.pop();
  var source = fromPath.size > 1 ? getItemByPath(state, sourcePath) : null;
  var sourceChildren = source ? source.get("children1") : null;
  var to2 = getItemByPath(state, toPath);
  var targetPath = placement == PLACEMENT_APPEND$1 || placement == PLACEMENT_PREPEND$1 ? toPath : toPath.pop();
  var target = placement == PLACEMENT_APPEND$1 || placement == PLACEMENT_PREPEND$1 ? to2 : toPath.size > 1 ? getItemByPath(state, targetPath) : null;
  var targetChildren = target ? target.get("children1") : null;
  if (!source || !target || !from2)
    return state;
  var isSameParent = source.get("id") == target.get("id");
  var isSourceInsideTarget = targetPath.size < sourcePath.size && deepEqual(targetPath.toArray(), sourcePath.toArray().slice(0, targetPath.size));
  var isTargetInsideSource = targetPath.size > sourcePath.size && deepEqual(sourcePath.toArray(), targetPath.toArray().slice(0, sourcePath.size));
  var sourceSubpathFromTarget = null;
  var targetSubpathFromSource = null;
  if (isSourceInsideTarget) {
    sourceSubpathFromTarget = Immutable.List(sourcePath.toArray().slice(targetPath.size));
  } else if (isTargetInsideSource) {
    targetSubpathFromSource = Immutable.List(targetPath.toArray().slice(sourcePath.size));
  }
  var newTargetChildren = targetChildren, newSourceChildren = sourceChildren;
  if (!isTargetInsideSource)
    newSourceChildren = newSourceChildren["delete"](from2.get("id"));
  if (isSameParent) {
    newTargetChildren = newSourceChildren;
  } else if (isSourceInsideTarget) {
    newTargetChildren = newTargetChildren.updateIn(expandTreeSubpath(sourceSubpathFromTarget, "children1"), function(_oldChildren) {
      return newSourceChildren;
    });
  }
  if (placement == PLACEMENT_BEFORE$1 || placement == PLACEMENT_AFTER$1) {
    newTargetChildren = Immutable.OrderedMap().withMutations(function(r2) {
      var _iterator = _createForOfIteratorHelper$2(newTargetChildren.entries()), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _step$value = _slicedToArray$1(_step.value, 2), itemId = _step$value[0], item = _step$value[1];
          if (itemId == to2.get("id") && placement == PLACEMENT_BEFORE$1) {
            r2.set(from2.get("id"), from2);
          }
          r2.set(itemId, item);
          if (itemId == to2.get("id") && placement == PLACEMENT_AFTER$1) {
            r2.set(from2.get("id"), from2);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    });
  } else if (placement == PLACEMENT_APPEND$1) {
    newTargetChildren = newTargetChildren.merge(_defineProperty$4({}, from2.get("id"), from2));
  } else if (placement == PLACEMENT_PREPEND$1) {
    newTargetChildren = Immutable.OrderedMap(_defineProperty$4({}, from2.get("id"), from2)).merge(newTargetChildren);
  }
  if (isTargetInsideSource) {
    newSourceChildren = newSourceChildren.updateIn(expandTreeSubpath(targetSubpathFromSource, "children1"), function(_oldChildren) {
      return newTargetChildren;
    });
    newSourceChildren = newSourceChildren["delete"](from2.get("id"));
  }
  if (!isSameParent && !isSourceInsideTarget)
    state = state.updateIn(expandTreePath(sourcePath, "children1"), function(_oldChildren) {
      return newSourceChildren;
    });
  if (!isTargetInsideSource)
    state = state.updateIn(expandTreePath(targetPath, "children1"), function(_oldChildren) {
      return newTargetChildren;
    });
  state = fixPathsInTree(state);
  return state;
};
var setField$1 = function setField(state, path, newField, config2) {
  if (!newField)
    return removeItem(state, path);
  var _config$settings2 = config2.settings, fieldSeparator = _config$settings2.fieldSeparator, setOpOnChangeField = _config$settings2.setOpOnChangeField, showErrorMessage = _config$settings2.showErrorMessage;
  if (Array.isArray(newField))
    newField = newField.join(fieldSeparator);
  var currentType = state.getIn(expandTreePath(path, "type"));
  var currentProperties = state.getIn(expandTreePath(path, "properties"));
  var wasRuleGroup = currentType == "rule_group";
  var newFieldConfig = getFieldConfig$8(config2, newField);
  var isRuleGroup = newFieldConfig.type == "!group";
  var isRuleGroupExt = isRuleGroup && newFieldConfig.mode == "array";
  var isChangeToAnotherType = wasRuleGroup != isRuleGroup;
  var currentOperator = currentProperties.get("operator");
  var currentOperatorOptions = currentProperties.get("operatorOptions");
  currentProperties.get("field");
  currentProperties.get("value");
  currentProperties.get("valueSrc", new Immutable.List());
  currentProperties.get("valueType", new Immutable.List());
  var lastOp = newFieldConfig && newFieldConfig.operators.indexOf(currentOperator) !== -1 ? currentOperator : null;
  var newOperator = null;
  var availOps = getOperatorsForField(config2, newField);
  if (availOps && availOps.length == 1)
    newOperator = availOps[0];
  else if (availOps && availOps.length > 1) {
    var _iterator2 = _createForOfIteratorHelper$2(setOpOnChangeField || []), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var strategy = _step2.value;
        if (strategy == "keep" && !isChangeToAnotherType)
          newOperator = lastOp;
        else if (strategy == "default")
          newOperator = defaultOperator(config2, newField, false);
        else if (strategy == "first")
          newOperator = getFirstOperator(config2, newField);
        if (newOperator)
          break;
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  if (!isRuleGroup && !newFieldConfig.operators) {
    console.warn("Type ".concat(newFieldConfig.type, " is not supported"));
    return state;
  }
  if (wasRuleGroup && !isRuleGroup) {
    state = state.setIn(expandTreePath(path, "type"), "rule");
    state = state.deleteIn(expandTreePath(path, "children1"));
    state = state.setIn(expandTreePath(path, "properties"), new Immutable.OrderedMap());
  }
  if (isRuleGroup) {
    state = state.setIn(expandTreePath(path, "type"), "rule_group");
    var _getNewValueForFieldO = getNewValueForFieldOp(config2, config2, currentProperties, newField, newOperator, "field", true);
    _getNewValueForFieldO.canReuseValue;
    var newValue = _getNewValueForFieldO.newValue, newValueSrc = _getNewValueForFieldO.newValueSrc, newValueType = _getNewValueForFieldO.newValueType, operatorCardinality = _getNewValueForFieldO.operatorCardinality;
    var groupProperties = defaultGroupProperties(config2, newFieldConfig).merge({
      field: newField,
      mode: newFieldConfig.mode
    });
    if (isRuleGroupExt) {
      groupProperties = groupProperties.merge({
        operator: newOperator,
        value: newValue,
        valueSrc: newValueSrc,
        valueType: newValueType
      });
    }
    state = state.setIn(expandTreePath(path, "children1"), new Immutable.OrderedMap());
    state = state.setIn(expandTreePath(path, "properties"), groupProperties);
    if (newFieldConfig.initialEmptyWhere && operatorCardinality == 1)
      ;
    else {
      state = addItem(state, path, "rule", uuid$1(), defaultRuleProperties(config2, newField), config2);
    }
    state = fixPathsInTree(state);
    return state;
  }
  return state.updateIn(expandTreePath(path, "properties"), function(map2) {
    return map2.withMutations(function(current) {
      var _getNewValueForFieldO2 = getNewValueForFieldOp(config2, config2, current, newField, newOperator, "field", true), canReuseValue = _getNewValueForFieldO2.canReuseValue, newValue2 = _getNewValueForFieldO2.newValue, newValueSrc2 = _getNewValueForFieldO2.newValueSrc, newValueType2 = _getNewValueForFieldO2.newValueType, newValueError = _getNewValueForFieldO2.newValueError;
      if (showErrorMessage) {
        current = current.set("valueError", newValueError);
      }
      var newOperatorOptions = canReuseValue ? currentOperatorOptions : defaultOperatorOptions(config2, newOperator, newField);
      return current.set("field", newField).set("operator", newOperator).set("operatorOptions", newOperatorOptions).set("value", newValue2).set("valueSrc", newValueSrc2).set("valueType", newValueType2)["delete"]("asyncListValues");
    });
  });
};
var setOperator$1 = function setOperator(state, path, newOperator, config2) {
  var showErrorMessage = config2.settings.showErrorMessage;
  var properties = state.getIn(expandTreePath(path, "properties"));
  var children = state.getIn(expandTreePath(path, "children1"));
  var currentField = properties.get("field");
  var fieldConfig = getFieldConfig$8(config2, currentField);
  var isRuleGroup = fieldConfig.type == "!group";
  var operatorConfig = getOperatorConfig$4(config2, newOperator, currentField);
  var operatorCardinality = operatorConfig ? defaultValue$1(operatorConfig.cardinality, 1) : null;
  state = state.updateIn(expandTreePath(path, "properties"), function(map2) {
    return map2.withMutations(function(current) {
      var currentField2 = current.get("field");
      var currentOperatorOptions = current.get("operatorOptions");
      current.get("value", new Immutable.List());
      current.get("valueSrc", new Immutable.List());
      current.get("operator");
      var _getNewValueForFieldO3 = getNewValueForFieldOp(config2, config2, current, currentField2, newOperator, "operator", true), canReuseValue = _getNewValueForFieldO3.canReuseValue, newValue = _getNewValueForFieldO3.newValue, newValueSrc = _getNewValueForFieldO3.newValueSrc, newValueType = _getNewValueForFieldO3.newValueType, newValueError = _getNewValueForFieldO3.newValueError;
      if (showErrorMessage) {
        current = current.set("valueError", newValueError);
      }
      var newOperatorOptions = canReuseValue ? currentOperatorOptions : defaultOperatorOptions(config2, newOperator, currentField2);
      if (!canReuseValue) {
        current = current["delete"]("asyncListValues");
      }
      return current.set("operator", newOperator).set("operatorOptions", newOperatorOptions).set("value", newValue).set("valueSrc", newValueSrc).set("valueType", newValueType);
    });
  });
  if (isRuleGroup) {
    if (operatorCardinality == 0 && children.size == 0) {
      state = addItem(state, path, "rule", uuid$1(), defaultRuleProperties(config2, currentField), config2);
    }
  }
  return state;
};
var setValue$1 = function setValue(state, path, delta, value, valueType, config2, asyncListValues, __isInternal) {
  var _config$settings3 = config2.settings, fieldSeparator = _config$settings3.fieldSeparator, showErrorMessage = _config$settings3.showErrorMessage;
  var isInternalValueChange;
  var valueSrc = state.getIn(expandTreePath(path, "properties", "valueSrc", delta + "")) || null;
  if (valueSrc === "field" && Array.isArray(value))
    value = value.join(fieldSeparator);
  var field = state.getIn(expandTreePath(path, "properties", "field")) || null;
  var operator = state.getIn(expandTreePath(path, "properties", "operator")) || null;
  var operatorConfig = getOperatorConfig$4(config2, operator, field);
  var operatorCardinality = operator ? defaultValue$1(operatorConfig.cardinality, 1) : null;
  var isEndValue = false;
  var calculatedValueType = valueType || calculateValueType(value, valueSrc, config2);
  var canFix = false;
  var _validateValue = validateValue(config2, field, field, operator, value, calculatedValueType, valueSrc, asyncListValues, canFix, isEndValue), _validateValue2 = _slicedToArray$1(_validateValue, 2), validateError = _validateValue2[0], fixedValue = _validateValue2[1];
  var isValid3 = !validateError;
  if (fixedValue !== value) {
    value = fixedValue;
  }
  if (showErrorMessage) {
    var w2 = getWidgetForFieldOp$3(config2, field, operator, valueSrc);
    var fieldWidgetDefinition = getFieldWidgetConfig$3(config2, field, operator, w2, valueSrc);
    var valueSrcs = Array.from({
      length: operatorCardinality
    }, function(_, i2) {
      return state.getIn(expandTreePath(path, "properties", "valueSrc", i2 + "")) || null;
    });
    if (operatorConfig && operatorConfig.validateValues && valueSrcs.filter(function(vs) {
      return vs == "value" || vs == null;
    }).length == operatorCardinality) {
      var values = Array.from({
        length: operatorCardinality
      }, function(_, i2) {
        return i2 == delta ? value : state.getIn(expandTreePath(path, "properties", "value", i2 + "")) || null;
      });
      var jsValues = fieldWidgetDefinition && fieldWidgetDefinition.toJS ? values.map(function(v2) {
        return fieldWidgetDefinition.toJS(v2, fieldWidgetDefinition);
      }) : values;
      var rangeValidateError = operatorConfig.validateValues(jsValues);
      state = state.setIn(expandTreePath(path, "properties", "valueError", operatorCardinality), rangeValidateError);
    }
  }
  var lastValueArr = state.getIn(expandTreePath(path, "properties", "value"));
  if (!lastValueArr) {
    state = state.setIn(expandTreePath(path, "properties", "value"), new Immutable.List(new Array(operatorCardinality))).setIn(expandTreePath(path, "properties", "valueType"), new Immutable.List(new Array(operatorCardinality))).setIn(expandTreePath(path, "properties", "valueError"), new Immutable.List(new Array(operatorCardinality)));
  }
  var lastValue = state.getIn(expandTreePath(path, "properties", "value", delta + ""));
  var lastError = state.getIn(expandTreePath(path, "properties", "valueError", delta));
  var isLastEmpty = lastValue == void 0;
  var isLastError = !!lastError;
  if (isValid3 || showErrorMessage) {
    state = state.deleteIn(expandTreePath(path, "properties", "asyncListValues"));
    if (typeof value === "undefined") {
      state = state.setIn(expandTreePath(path, "properties", "value", delta + ""), void 0);
      state = state.setIn(expandTreePath(path, "properties", "valueType", delta + ""), null);
    } else {
      if (asyncListValues) {
        state = state.setIn(expandTreePath(path, "properties", "asyncListValues"), asyncListValues);
      }
      state = state.setIn(expandTreePath(path, "properties", "value", delta + ""), value);
      state = state.setIn(expandTreePath(path, "properties", "valueType", delta + ""), calculatedValueType);
      isInternalValueChange = __isInternal && !isLastEmpty && !isLastError;
    }
  }
  if (showErrorMessage) {
    state = state.setIn(expandTreePath(path, "properties", "valueError", delta), validateError);
  }
  if (__isInternal && (isValid3 && isLastError || !isValid3 && !isLastError)) {
    state = state.setIn(expandTreePath(path, "properties", "valueError", delta), validateError);
    isInternalValueChange = false;
  }
  return {
    tree: state,
    isInternalValueChange
  };
};
var setValueSrc$1 = function setValueSrc(state, path, delta, srcKey, config2) {
  var showErrorMessage = config2.settings.showErrorMessage;
  var field = state.getIn(expandTreePath(path, "properties", "field")) || null;
  var operator = state.getIn(expandTreePath(path, "properties", "operator")) || null;
  state = state.setIn(expandTreePath(path, "properties", "value", delta + ""), void 0);
  state = state.setIn(expandTreePath(path, "properties", "valueType", delta + ""), null);
  state = state.deleteIn(expandTreePath(path, "properties", "asyncListValues"));
  if (showErrorMessage) {
    state = state.setIn(expandTreePath(path, "properties", "valueError", delta), null);
    var operatorConfig = getOperatorConfig$4(config2, operator, field);
    var operatorCardinality = operator ? defaultValue$1(operatorConfig.cardinality, 1) : null;
    if (operatorConfig.validateValues) {
      state = state.setIn(expandTreePath(path, "properties", "valueError", operatorCardinality), null);
    }
  }
  if (typeof srcKey === "undefined") {
    state = state.setIn(expandTreePath(path, "properties", "valueSrc", delta + ""), null);
  } else {
    state = state.setIn(expandTreePath(path, "properties", "valueSrc", delta + ""), srcKey);
  }
  if (srcKey) {
    var properties = state.getIn(expandTreePath(path, "properties"));
    var _getNewValueForFieldO4 = getNewValueForFieldOp(config2, config2, properties, field, operator, "valueSrc", true), canReuseValue = _getNewValueForFieldO4.canReuseValue, newValue = _getNewValueForFieldO4.newValue, newValueSrc = _getNewValueForFieldO4.newValueSrc, newValueType = _getNewValueForFieldO4.newValueType;
    _getNewValueForFieldO4.newValueError;
    if (!canReuseValue && newValueSrc.get(delta) == srcKey) {
      state = state.setIn(expandTreePath(path, "properties", "value", delta + ""), newValue.get(delta));
      state = state.setIn(expandTreePath(path, "properties", "valueType", delta + ""), newValueType.get(delta));
    }
  }
  return state;
};
var setOperatorOption$1 = function setOperatorOption(state, path, name, value) {
  return state.setIn(expandTreePath(path, "properties", "operatorOptions", name), value);
};
var checkEmptyGroups = function checkEmptyGroups2(state, config2) {
  var canLeaveEmptyGroup = config2.settings.canLeaveEmptyGroup;
  if (!canLeaveEmptyGroup) {
    state = fixEmptyGroupsInTree(state);
  }
  return state;
};
var calculateValueType = function calculateValueType2(value, valueSrc, config2) {
  var calculatedValueType = null;
  if (value) {
    if (valueSrc === "field") {
      var fieldConfig = getFieldConfig$8(config2, value);
      if (fieldConfig) {
        calculatedValueType = fieldConfig.type;
      }
    } else if (valueSrc === "func") {
      var funcKey = value.get("func");
      if (funcKey) {
        var funcConfig = getFuncConfig$2(config2, funcKey);
        if (funcConfig) {
          calculatedValueType = funcConfig.returnType;
        }
      }
    }
  }
  return calculatedValueType;
};
var getField = function getField2(state, path) {
  var field = state.getIn(expandTreePath(path, "properties", "field")) || null;
  return field;
};
var emptyDrag = {
  dragging: {
    id: null,
    x: null,
    y: null,
    w: null,
    h: null
  },
  mousePos: {},
  dragStart: {
    id: null
  }
};
var getActionMeta = function getActionMeta2(action2, state) {
  if (!action2 || !action2.type)
    return null;
  var actionKeysToOmit = ["config", "asyncListValues", "__isInternal"];
  var actionTypesToIgnore = [SET_TREE, SET_DRAG_START$1, SET_DRAG_PROGRESS$1, SET_DRAG_END$1];
  var meta = mapValues$1(omit$1(action2, actionKeysToOmit), applyToJS);
  var affectedField = action2.path && getField(state.tree, action2.path) || action2.field;
  if (affectedField)
    meta.affectedField = affectedField;
  if (actionTypesToIgnore.includes(action2.type) || action2.type.indexOf("@@redux") == 0)
    meta = null;
  return meta;
};
const TreeStore = function(config2, tree2, getMemoizedTree, setLastTree) {
  var emptyTree = defaultRoot$1(config2);
  var initTree = tree2 || emptyTree;
  var emptyState = _objectSpread$j({
    tree: initTree
  }, emptyDrag);
  return function() {
    var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : emptyState;
    var action2 = arguments.length > 1 ? arguments[1] : void 0;
    var unset = {
      __isInternalValueChange: void 0,
      __lastAction: void 0
    };
    var set2 = {};
    var actionMeta = getActionMeta(action2, state);
    switch (action2 === null || action2 === void 0 ? void 0 : action2.type) {
      case SET_TREE: {
        var validatedTree = getMemoizedTree(action2.config, action2.tree);
        set2.tree = validatedTree;
        break;
      }
      case ADD_CASE_GROUP: {
        set2.tree = addNewGroup(state.tree, action2.path, "case_group", action2.id, action2.properties, action2.config, action2.children, action2.meta);
        break;
      }
      case ADD_GROUP: {
        set2.tree = addNewGroup(state.tree, action2.path, "group", action2.id, action2.properties, action2.config, action2.children, action2.meta);
        break;
      }
      case REMOVE_GROUP: {
        set2.tree = removeGroup$1(state.tree, action2.path, action2.config);
        break;
      }
      case ADD_RULE: {
        set2.tree = addItem(state.tree, action2.path, action2.ruleType, action2.id, action2.properties, action2.config, action2.children);
        break;
      }
      case REMOVE_RULE: {
        set2.tree = removeRule$1(state.tree, action2.path, action2.config);
        break;
      }
      case SET_CONJUNCTION: {
        set2.tree = setConjunction$1(state.tree, action2.path, action2.conjunction);
        break;
      }
      case SET_NOT: {
        set2.tree = setNot$1(state.tree, action2.path, action2.not);
        break;
      }
      case SET_FIELD: {
        set2.tree = setField$1(state.tree, action2.path, action2.field, action2.config);
        break;
      }
      case SET_LOCK: {
        set2.tree = setLock$1(state.tree, action2.path, action2.lock);
        break;
      }
      case SET_OPERATOR: {
        set2.tree = setOperator$1(state.tree, action2.path, action2.operator, action2.config);
        break;
      }
      case SET_VALUE: {
        var _setValue = setValue$1(state.tree, action2.path, action2.delta, action2.value, action2.valueType, action2.config, action2.asyncListValues, action2.__isInternal), _tree = _setValue.tree, isInternalValueChange = _setValue.isInternalValueChange;
        set2.__isInternalValueChange = isInternalValueChange;
        set2.tree = _tree;
        break;
      }
      case SET_VALUE_SRC: {
        set2.tree = setValueSrc$1(state.tree, action2.path, action2.delta, action2.srcKey, action2.config);
        break;
      }
      case SET_OPERATOR_OPTION: {
        set2.tree = setOperatorOption$1(state.tree, action2.path, action2.name, action2.value);
        break;
      }
      case MOVE_ITEM: {
        set2.tree = moveItem$1(state.tree, action2.fromPath, action2.toPath, action2.placement, action2.config);
        break;
      }
      case SET_DRAG_START$1: {
        set2.dragStart = action2.dragStart;
        set2.dragging = action2.dragging;
        set2.mousePos = action2.mousePos;
        break;
      }
      case SET_DRAG_PROGRESS$1: {
        set2.mousePos = action2.mousePos;
        set2.dragging = action2.dragging;
        break;
      }
      case SET_DRAG_END$1: {
        set2.tree = checkEmptyGroups(state.tree, config2);
        set2 = _objectSpread$j(_objectSpread$j({}, set2), emptyDrag);
        break;
      }
    }
    if (actionMeta) {
      set2.__lastAction = actionMeta;
    }
    if (setLastTree && set2.tree && state.tree) {
      setLastTree(state.tree);
    }
    return _objectSpread$j(_objectSpread$j(_objectSpread$j({}, state), unset), set2);
  };
};
var setTree = function setTree2(config2, tree2) {
  return {
    type: SET_TREE,
    tree: tree2,
    config: config2
  };
};
var addRule = function addRule2(config2, path, properties) {
  var ruleType = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "rule";
  var children = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
  return {
    type: ADD_RULE,
    ruleType,
    children,
    path: toImmutableList(path),
    id: uuid$1(),
    properties: defaultRuleProperties(config2).merge(properties || {}),
    config: config2
  };
};
var removeRule2 = function removeRule3(config2, path) {
  return {
    type: REMOVE_RULE,
    path: toImmutableList(path),
    config: config2
  };
};
var addDefaultCaseGroup = function addDefaultCaseGroup2(config2, path, properties) {
  var children = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    type: ADD_CASE_GROUP,
    path: toImmutableList(path),
    children,
    id: uuid$1(),
    properties: defaultGroupProperties(config2).merge(properties || {}),
    config: config2,
    meta: {
      isDefaultCase: true
    }
  };
};
var addCaseGroup = function addCaseGroup2(config2, path, properties) {
  var children = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    type: ADD_CASE_GROUP,
    path: toImmutableList(path),
    children,
    id: uuid$1(),
    properties: defaultGroupProperties(config2).merge(properties || {}),
    config: config2
  };
};
var addGroup = function addGroup2(config2, path, properties) {
  var children = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    type: ADD_GROUP,
    path: toImmutableList(path),
    children,
    id: uuid$1(),
    properties: defaultGroupProperties(config2).merge(properties || {}),
    config: config2
  };
};
var removeGroup2 = function removeGroup3(config2, path) {
  return {
    type: REMOVE_GROUP,
    path: toImmutableList(path),
    config: config2
  };
};
var moveItem2 = function moveItem3(config2, fromPath, toPath, placement) {
  return {
    type: MOVE_ITEM,
    fromPath: toImmutableList(fromPath),
    toPath: toImmutableList(toPath),
    placement,
    config: config2
  };
};
const tree$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addCaseGroup,
  addDefaultCaseGroup,
  addGroup,
  addRule,
  moveItem: moveItem2,
  removeGroup: removeGroup2,
  removeRule: removeRule2,
  setTree
}, Symbol.toStringTag, { value: "Module" }));
var setConjunction2 = function setConjunction3(config2, path, conjunction) {
  return {
    type: SET_CONJUNCTION,
    path: toImmutableList(path),
    conjunction
  };
};
var setNot2 = function setNot3(config2, path, not) {
  return {
    type: SET_NOT,
    path: toImmutableList(path),
    not
  };
};
var setLock2 = function setLock3(config2, path, lock) {
  return {
    type: SET_LOCK,
    path: toImmutableList(path),
    lock
  };
};
const group$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  setConjunction: setConjunction2,
  setLock: setLock2,
  setNot: setNot2
}, Symbol.toStringTag, { value: "Module" }));
var setField2 = function setField3(config2, path, field) {
  return {
    type: SET_FIELD,
    path: toImmutableList(path),
    field,
    config: config2
  };
};
var setOperator2 = function setOperator3(config2, path, operator) {
  return {
    type: SET_OPERATOR,
    path: toImmutableList(path),
    operator,
    config: config2
  };
};
var setValue2 = function setValue3(config2, path, delta, value, valueType, asyncListValues, __isInternal) {
  return {
    type: SET_VALUE,
    path: toImmutableList(path),
    delta,
    value,
    valueType,
    asyncListValues,
    config: config2,
    __isInternal
  };
};
var setValueSrc2 = function setValueSrc3(config2, path, delta, srcKey) {
  return {
    type: SET_VALUE_SRC,
    path: toImmutableList(path),
    delta,
    srcKey,
    config: config2
  };
};
var setOperatorOption2 = function setOperatorOption3(config2, path, name, value) {
  return {
    type: SET_OPERATOR_OPTION,
    path: toImmutableList(path),
    name,
    value,
    config: config2
  };
};
const rule$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  setField: setField2,
  setOperator: setOperator2,
  setOperatorOption: setOperatorOption2,
  setValue: setValue2,
  setValueSrc: setValueSrc2
}, Symbol.toStringTag, { value: "Module" }));
function ownKeys$i(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$i(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$i(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$i(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var Utils$1 = _objectSpread$i(_objectSpread$i(_objectSpread$i({}, BasicUtils), Export), Import);
const context = /* @__PURE__ */ React.createContext();
var ReactReduxContext = /* @__PURE__ */ React.createContext(null);
function defaultNoopBatch(callback) {
  callback();
}
var batch = defaultNoopBatch;
var setBatch = function setBatch2(newBatch) {
  return batch = newBatch;
};
var getBatch = function getBatch2() {
  return batch;
};
function createListenerCollection() {
  var batch2 = getBatch();
  var first = null;
  var last2 = null;
  return {
    clear: function clear() {
      first = null;
      last2 = null;
    },
    notify: function notify2() {
      batch2(function() {
        var listener = first;
        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get: function get4() {
      var listeners = [];
      var listener = first;
      while (listener) {
        listeners.push(listener);
        listener = listener.next;
      }
      return listeners;
    },
    subscribe: function subscribe(callback) {
      var isSubscribed = true;
      var listener = last2 = {
        callback,
        next: null,
        prev: last2
      };
      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first = listener;
      }
      return function unsubscribe() {
        if (!isSubscribed || first === null)
          return;
        isSubscribed = false;
        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last2 = listener.prev;
        }
        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first = listener.next;
        }
      };
    }
  };
}
var nullListeners = {
  notify: function notify() {
  },
  get: function get3() {
    return [];
  }
};
function createSubscription(store, parentSub) {
  var unsubscribe;
  var listeners = nullListeners;
  function addNestedSub(listener) {
    trySubscribe();
    return listeners.subscribe(listener);
  }
  function notifyNestedSubs() {
    listeners.notify();
  }
  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }
  function isSubscribed() {
    return Boolean(unsubscribe);
  }
  function trySubscribe() {
    if (!unsubscribe) {
      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
      listeners = createListenerCollection();
    }
  }
  function tryUnsubscribe() {
    if (unsubscribe) {
      unsubscribe();
      unsubscribe = void 0;
      listeners.clear();
      listeners = nullListeners;
    }
  }
  var subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe,
    tryUnsubscribe,
    getListeners: function getListeners() {
      return listeners;
    }
  };
  return subscription;
}
var useIsomorphicLayoutEffect = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function Provider(_ref) {
  var store = _ref.store, context2 = _ref.context, children = _ref.children;
  var contextValue = reactExports.useMemo(function() {
    var subscription = createSubscription(store);
    return {
      store,
      subscription
    };
  }, [store]);
  var previousState = reactExports.useMemo(function() {
    return store.getState();
  }, [store]);
  useIsomorphicLayoutEffect(function() {
    var subscription = contextValue.subscription;
    subscription.onStateChange = subscription.notifyNestedSubs;
    subscription.trySubscribe();
    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }
    return function() {
      subscription.tryUnsubscribe();
      subscription.onStateChange = null;
    };
  }, [contextValue, previousState]);
  var Context = context2 || ReactReduxContext;
  return /* @__PURE__ */ React.createElement(Context.Provider, {
    value: contextValue
  }, children);
}
var reactIs = { exports: {} };
var reactIs_production_min = {};
/** @license React v17.0.2
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = 60103, c = 60106, d = 60107, e = 60108, f = 60114, g = 60109, h = 60110, k = 60112, l = 60113, m = 60120, n = 60115, p = 60116, q = 60121, r = 60122, u = 60117, v = 60129, w = 60131;
if ("function" === typeof Symbol && Symbol.for) {
  var x = Symbol.for;
  b = x("react.element");
  c = x("react.portal");
  d = x("react.fragment");
  e = x("react.strict_mode");
  f = x("react.profiler");
  g = x("react.provider");
  h = x("react.context");
  k = x("react.forward_ref");
  l = x("react.suspense");
  m = x("react.suspense_list");
  n = x("react.memo");
  p = x("react.lazy");
  q = x("react.block");
  r = x("react.server.block");
  u = x("react.fundamental");
  v = x("react.debug_trace_mode");
  w = x("react.legacy_hidden");
}
function y(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var t2 = a2.$$typeof;
    switch (t2) {
      case b:
        switch (a2 = a2.type, a2) {
          case d:
          case f:
          case e:
          case l:
          case m:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case h:
              case k:
              case p:
              case n:
              case g:
                return a2;
              default:
                return t2;
            }
        }
      case c:
        return t2;
    }
  }
}
var z = g, A = b, B = k, C = d, D = p, E = n, F = c, G = f, H = e, I = l;
reactIs_production_min.ContextConsumer = h;
reactIs_production_min.ContextProvider = z;
reactIs_production_min.Element = A;
reactIs_production_min.ForwardRef = B;
reactIs_production_min.Fragment = C;
reactIs_production_min.Lazy = D;
reactIs_production_min.Memo = E;
reactIs_production_min.Portal = F;
reactIs_production_min.Profiler = G;
reactIs_production_min.StrictMode = H;
reactIs_production_min.Suspense = I;
reactIs_production_min.isAsyncMode = function() {
  return false;
};
reactIs_production_min.isConcurrentMode = function() {
  return false;
};
reactIs_production_min.isContextConsumer = function(a2) {
  return y(a2) === h;
};
reactIs_production_min.isContextProvider = function(a2) {
  return y(a2) === g;
};
reactIs_production_min.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === b;
};
reactIs_production_min.isForwardRef = function(a2) {
  return y(a2) === k;
};
reactIs_production_min.isFragment = function(a2) {
  return y(a2) === d;
};
reactIs_production_min.isLazy = function(a2) {
  return y(a2) === p;
};
reactIs_production_min.isMemo = function(a2) {
  return y(a2) === n;
};
reactIs_production_min.isPortal = function(a2) {
  return y(a2) === c;
};
reactIs_production_min.isProfiler = function(a2) {
  return y(a2) === f;
};
reactIs_production_min.isStrictMode = function(a2) {
  return y(a2) === e;
};
reactIs_production_min.isSuspense = function(a2) {
  return y(a2) === l;
};
reactIs_production_min.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === d || a2 === f || a2 === v || a2 === e || a2 === l || a2 === m || a2 === w || "object" === typeof a2 && null !== a2 && (a2.$$typeof === p || a2.$$typeof === n || a2.$$typeof === g || a2.$$typeof === h || a2.$$typeof === k || a2.$$typeof === u || a2.$$typeof === q || a2[0] === r) ? true : false;
};
reactIs_production_min.typeOf = y;
{
  reactIs.exports = reactIs_production_min;
}
var reactIsExports = reactIs.exports;
var _excluded$b = ["getDisplayName", "methodName", "renderCountProp", "shouldHandleStateChanges", "storeKey", "withRef", "forwardRef", "context"], _excluded2 = ["reactReduxForwardedRef"];
var EMPTY_ARRAY = [];
var NO_SUBSCRIPTION_ARRAY = [null, null];
function storeStateUpdatesReducer(state, action2) {
  var updateCount = state[1];
  return [action2.payload, updateCount + 1];
}
function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
  useIsomorphicLayoutEffect(function() {
    return effectFunc.apply(void 0, effectArgs);
  }, dependencies);
}
function captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs) {
  lastWrapperProps.current = wrapperProps;
  lastChildProps.current = actualChildProps;
  renderIsScheduled.current = false;
  if (childPropsFromStoreUpdate.current) {
    childPropsFromStoreUpdate.current = null;
    notifyNestedSubs();
  }
}
function subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch) {
  if (!shouldHandleStateChanges)
    return;
  var didUnsubscribe = false;
  var lastThrownError = null;
  var checkForUpdates = function checkForUpdates2() {
    if (didUnsubscribe) {
      return;
    }
    var latestStoreState = store.getState();
    var newChildProps, error2;
    try {
      newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);
    } catch (e2) {
      error2 = e2;
      lastThrownError = e2;
    }
    if (!error2) {
      lastThrownError = null;
    }
    if (newChildProps === lastChildProps.current) {
      if (!renderIsScheduled.current) {
        notifyNestedSubs();
      }
    } else {
      lastChildProps.current = newChildProps;
      childPropsFromStoreUpdate.current = newChildProps;
      renderIsScheduled.current = true;
      forceComponentUpdateDispatch({
        type: "STORE_UPDATED",
        payload: {
          error: error2
        }
      });
    }
  };
  subscription.onStateChange = checkForUpdates;
  subscription.trySubscribe();
  checkForUpdates();
  var unsubscribeWrapper = function unsubscribeWrapper2() {
    didUnsubscribe = true;
    subscription.tryUnsubscribe();
    subscription.onStateChange = null;
    if (lastThrownError) {
      throw lastThrownError;
    }
  };
  return unsubscribeWrapper;
}
var initStateUpdates = function initStateUpdates2() {
  return [null, 0];
};
function connectAdvanced(selectorFactory, _ref) {
  if (_ref === void 0) {
    _ref = {};
  }
  var _ref2 = _ref, _ref2$getDisplayName = _ref2.getDisplayName, getDisplayName = _ref2$getDisplayName === void 0 ? function(name) {
    return "ConnectAdvanced(" + name + ")";
  } : _ref2$getDisplayName, _ref2$methodName = _ref2.methodName, methodName = _ref2$methodName === void 0 ? "connectAdvanced" : _ref2$methodName, _ref2$renderCountProp = _ref2.renderCountProp, renderCountProp = _ref2$renderCountProp === void 0 ? void 0 : _ref2$renderCountProp, _ref2$shouldHandleSta = _ref2.shouldHandleStateChanges, shouldHandleStateChanges = _ref2$shouldHandleSta === void 0 ? true : _ref2$shouldHandleSta, _ref2$storeKey = _ref2.storeKey, storeKey = _ref2$storeKey === void 0 ? "store" : _ref2$storeKey;
  _ref2.withRef;
  var _ref2$forwardRef = _ref2.forwardRef, forwardRef = _ref2$forwardRef === void 0 ? false : _ref2$forwardRef, _ref2$context = _ref2.context, context2 = _ref2$context === void 0 ? ReactReduxContext : _ref2$context, connectOptions = _objectWithoutPropertiesLoose(_ref2, _excluded$b);
  var Context = context2;
  return function wrapWithConnect(WrappedComponent) {
    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
    var displayName = getDisplayName(wrappedComponentName);
    var selectorFactoryOptions = _extends$h({}, connectOptions, {
      getDisplayName,
      methodName,
      renderCountProp,
      shouldHandleStateChanges,
      storeKey,
      displayName,
      wrappedComponentName,
      WrappedComponent
    });
    var pure = connectOptions.pure;
    function createChildSelector(store) {
      return selectorFactory(store.dispatch, selectorFactoryOptions);
    }
    var usePureOnlyMemo = pure ? reactExports.useMemo : function(callback) {
      return callback();
    };
    function ConnectFunction(props) {
      var _useMemo = reactExports.useMemo(function() {
        var reactReduxForwardedRef2 = props.reactReduxForwardedRef, wrapperProps2 = _objectWithoutPropertiesLoose(props, _excluded2);
        return [props.context, reactReduxForwardedRef2, wrapperProps2];
      }, [props]), propsContext = _useMemo[0], reactReduxForwardedRef = _useMemo[1], wrapperProps = _useMemo[2];
      var ContextToUse = reactExports.useMemo(function() {
        return propsContext && propsContext.Consumer && reactIsExports.isContextConsumer(/* @__PURE__ */ React.createElement(propsContext.Consumer, null)) ? propsContext : Context;
      }, [propsContext, Context]);
      var contextValue = reactExports.useContext(ContextToUse);
      var didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);
      Boolean(contextValue) && Boolean(contextValue.store);
      var store = didStoreComeFromProps ? props.store : contextValue.store;
      var childPropsSelector = reactExports.useMemo(function() {
        return createChildSelector(store);
      }, [store]);
      var _useMemo2 = reactExports.useMemo(function() {
        if (!shouldHandleStateChanges)
          return NO_SUBSCRIPTION_ARRAY;
        var subscription2 = createSubscription(store, didStoreComeFromProps ? null : contextValue.subscription);
        var notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);
        return [subscription2, notifyNestedSubs2];
      }, [store, didStoreComeFromProps, contextValue]), subscription = _useMemo2[0], notifyNestedSubs = _useMemo2[1];
      var overriddenContextValue = reactExports.useMemo(function() {
        if (didStoreComeFromProps) {
          return contextValue;
        }
        return _extends$h({}, contextValue, {
          subscription
        });
      }, [didStoreComeFromProps, contextValue, subscription]);
      var _useReducer = reactExports.useReducer(storeStateUpdatesReducer, EMPTY_ARRAY, initStateUpdates), _useReducer$ = _useReducer[0], previousStateUpdateResult = _useReducer$[0], forceComponentUpdateDispatch = _useReducer[1];
      if (previousStateUpdateResult && previousStateUpdateResult.error) {
        throw previousStateUpdateResult.error;
      }
      var lastChildProps = reactExports.useRef();
      var lastWrapperProps = reactExports.useRef(wrapperProps);
      var childPropsFromStoreUpdate = reactExports.useRef();
      var renderIsScheduled = reactExports.useRef(false);
      var actualChildProps = usePureOnlyMemo(function() {
        if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {
          return childPropsFromStoreUpdate.current;
        }
        return childPropsSelector(store.getState(), wrapperProps);
      }, [store, previousStateUpdateResult, wrapperProps]);
      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs]);
      useIsomorphicLayoutEffectWithArgs(subscribeUpdates, [shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch], [store, subscription, childPropsSelector]);
      var renderedWrappedComponent = reactExports.useMemo(function() {
        return /* @__PURE__ */ React.createElement(WrappedComponent, _extends$h({}, actualChildProps, {
          ref: reactReduxForwardedRef
        }));
      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]);
      var renderedChild = reactExports.useMemo(function() {
        if (shouldHandleStateChanges) {
          return /* @__PURE__ */ React.createElement(ContextToUse.Provider, {
            value: overriddenContextValue
          }, renderedWrappedComponent);
        }
        return renderedWrappedComponent;
      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);
      return renderedChild;
    }
    var Connect = pure ? React.memo(ConnectFunction) : ConnectFunction;
    Connect.WrappedComponent = WrappedComponent;
    Connect.displayName = ConnectFunction.displayName = displayName;
    if (forwardRef) {
      var forwarded = React.forwardRef(function forwardConnectRef(props, ref) {
        return /* @__PURE__ */ React.createElement(Connect, _extends$h({}, props, {
          reactReduxForwardedRef: ref
        }));
      });
      forwarded.displayName = displayName;
      forwarded.WrappedComponent = WrappedComponent;
      return hoistStatics(forwarded, WrappedComponent);
    }
    return hoistStatics(Connect, WrappedComponent);
  };
}
function is(x, y2) {
  if (x === y2) {
    return x !== 0 || y2 !== 0 || 1 / x === 1 / y2;
  } else {
    return x !== x && y2 !== y2;
  }
}
function shallowEqual$1(objA, objB) {
  if (is(objA, objB))
    return true;
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length)
    return false;
  for (var i2 = 0; i2 < keysA.length; i2++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i2]) || !is(objA[keysA[i2]], objB[keysA[i2]])) {
      return false;
    }
  }
  return true;
}
function bindActionCreators$1(actionCreators, dispatch) {
  var boundActionCreators = {};
  var _loop = function _loop4(key2) {
    var actionCreator = actionCreators[key2];
    if (typeof actionCreator === "function") {
      boundActionCreators[key2] = function() {
        return dispatch(actionCreator.apply(void 0, arguments));
      };
    }
  };
  for (var key in actionCreators) {
    _loop(key);
  }
  return boundActionCreators;
}
function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch, options) {
    var constant2 = getConstant(dispatch, options);
    function constantSelector() {
      return constant2;
    }
    constantSelector.dependsOnOwnProps = false;
    return constantSelector;
  };
}
function getDependsOnOwnProps(mapToProps) {
  return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== void 0 ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
}
function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch, _ref) {
    _ref.displayName;
    var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
    };
    proxy.dependsOnOwnProps = true;
    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps;
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
      var props = proxy(stateOrDispatch, ownProps);
      if (typeof props === "function") {
        proxy.mapToProps = props;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
        props = proxy(stateOrDispatch, ownProps);
      }
      return props;
    };
    return proxy;
  };
}
function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
  return typeof mapDispatchToProps === "function" ? wrapMapToPropsFunc(mapDispatchToProps) : void 0;
}
function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
  return !mapDispatchToProps ? wrapMapToPropsConstant(function(dispatch) {
    return {
      dispatch
    };
  }) : void 0;
}
function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
  return mapDispatchToProps && typeof mapDispatchToProps === "object" ? wrapMapToPropsConstant(function(dispatch) {
    return bindActionCreators$1(mapDispatchToProps, dispatch);
  }) : void 0;
}
const defaultMapDispatchToPropsFactories = [whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject];
function whenMapStateToPropsIsFunction(mapStateToProps) {
  return typeof mapStateToProps === "function" ? wrapMapToPropsFunc(mapStateToProps) : void 0;
}
function whenMapStateToPropsIsMissing(mapStateToProps) {
  return !mapStateToProps ? wrapMapToPropsConstant(function() {
    return {};
  }) : void 0;
}
const defaultMapStateToPropsFactories = [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing];
function defaultMergeProps(stateProps, dispatchProps, ownProps) {
  return _extends$h({}, ownProps, stateProps, dispatchProps);
}
function wrapMergePropsFunc(mergeProps2) {
  return function initMergePropsProxy(dispatch, _ref) {
    _ref.displayName;
    var pure = _ref.pure, areMergedPropsEqual = _ref.areMergedPropsEqual;
    var hasRunOnce = false;
    var mergedProps;
    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
      var nextMergedProps = mergeProps2(stateProps, dispatchProps, ownProps);
      if (hasRunOnce) {
        if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps))
          mergedProps = nextMergedProps;
      } else {
        hasRunOnce = true;
        mergedProps = nextMergedProps;
      }
      return mergedProps;
    };
  };
}
function whenMergePropsIsFunction(mergeProps2) {
  return typeof mergeProps2 === "function" ? wrapMergePropsFunc(mergeProps2) : void 0;
}
function whenMergePropsIsOmitted(mergeProps2) {
  return !mergeProps2 ? function() {
    return defaultMergeProps;
  } : void 0;
}
const defaultMergePropsFactories = [whenMergePropsIsFunction, whenMergePropsIsOmitted];
var _excluded$a = ["initMapStateToProps", "initMapDispatchToProps", "initMergeProps"];
function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps2, dispatch) {
  return function impureFinalPropsSelector(state, ownProps) {
    return mergeProps2(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);
  };
}
function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps2, dispatch, _ref) {
  var areStatesEqual = _ref.areStatesEqual, areOwnPropsEqual = _ref.areOwnPropsEqual, areStatePropsEqual = _ref.areStatePropsEqual;
  var hasRunAtLeastOnce = false;
  var state;
  var ownProps;
  var stateProps;
  var dispatchProps;
  var mergedProps;
  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState;
    ownProps = firstOwnProps;
    stateProps = mapStateToProps(state, ownProps);
    dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps2(stateProps, dispatchProps, ownProps);
    hasRunAtLeastOnce = true;
    return mergedProps;
  }
  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps2(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps)
      stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps2(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleNewState() {
    var nextStateProps = mapStateToProps(state, ownProps);
    var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
    stateProps = nextStateProps;
    if (statePropsChanged)
      mergedProps = mergeProps2(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleSubsequentCalls(nextState, nextOwnProps) {
    var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
    var stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);
    state = nextState;
    ownProps = nextOwnProps;
    if (propsChanged && stateChanged)
      return handleNewPropsAndNewState();
    if (propsChanged)
      return handleNewProps();
    if (stateChanged)
      return handleNewState();
    return mergedProps;
  }
  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
  };
}
function finalPropsSelectorFactory(dispatch, _ref2) {
  var initMapStateToProps = _ref2.initMapStateToProps, initMapDispatchToProps = _ref2.initMapDispatchToProps, initMergeProps = _ref2.initMergeProps, options = _objectWithoutPropertiesLoose(_ref2, _excluded$a);
  var mapStateToProps = initMapStateToProps(dispatch, options);
  var mapDispatchToProps = initMapDispatchToProps(dispatch, options);
  var mergeProps2 = initMergeProps(dispatch, options);
  var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;
  return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps2, dispatch, options);
}
var _excluded$9 = ["pure", "areStatesEqual", "areOwnPropsEqual", "areStatePropsEqual", "areMergedPropsEqual"];
function match(arg, factories, name) {
  for (var i2 = factories.length - 1; i2 >= 0; i2--) {
    var result = factories[i2](arg);
    if (result)
      return result;
  }
  return function(dispatch, options) {
    throw new Error("Invalid value of type " + typeof arg + " for " + name + " argument when connecting component " + options.wrappedComponentName + ".");
  };
}
function strictEqual(a2, b2) {
  return a2 === b2;
}
function createConnect(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$connectHOC = _ref.connectHOC, connectHOC = _ref$connectHOC === void 0 ? connectAdvanced : _ref$connectHOC, _ref$mapStateToPropsF = _ref.mapStateToPropsFactories, mapStateToPropsFactories = _ref$mapStateToPropsF === void 0 ? defaultMapStateToPropsFactories : _ref$mapStateToPropsF, _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories, mapDispatchToPropsFactories = _ref$mapDispatchToPro === void 0 ? defaultMapDispatchToPropsFactories : _ref$mapDispatchToPro, _ref$mergePropsFactor = _ref.mergePropsFactories, mergePropsFactories = _ref$mergePropsFactor === void 0 ? defaultMergePropsFactories : _ref$mergePropsFactor, _ref$selectorFactory = _ref.selectorFactory, selectorFactory = _ref$selectorFactory === void 0 ? finalPropsSelectorFactory : _ref$selectorFactory;
  return function connect2(mapStateToProps, mapDispatchToProps, mergeProps2, _ref2) {
    if (_ref2 === void 0) {
      _ref2 = {};
    }
    var _ref3 = _ref2, _ref3$pure = _ref3.pure, pure = _ref3$pure === void 0 ? true : _ref3$pure, _ref3$areStatesEqual = _ref3.areStatesEqual, areStatesEqual = _ref3$areStatesEqual === void 0 ? strictEqual : _ref3$areStatesEqual, _ref3$areOwnPropsEqua = _ref3.areOwnPropsEqual, areOwnPropsEqual = _ref3$areOwnPropsEqua === void 0 ? shallowEqual$1 : _ref3$areOwnPropsEqua, _ref3$areStatePropsEq = _ref3.areStatePropsEqual, areStatePropsEqual = _ref3$areStatePropsEq === void 0 ? shallowEqual$1 : _ref3$areStatePropsEq, _ref3$areMergedPropsE = _ref3.areMergedPropsEqual, areMergedPropsEqual = _ref3$areMergedPropsE === void 0 ? shallowEqual$1 : _ref3$areMergedPropsE, extraOptions = _objectWithoutPropertiesLoose(_ref3, _excluded$9);
    var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, "mapStateToProps");
    var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, "mapDispatchToProps");
    var initMergeProps = match(mergeProps2, mergePropsFactories, "mergeProps");
    return connectHOC(selectorFactory, _extends$h({
      // used in error messages
      methodName: "connect",
      // used to compute Connect's displayName from the wrapped component's displayName.
      getDisplayName: function getDisplayName(name) {
        return "Connect(" + name + ")";
      },
      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
      shouldHandleStateChanges: Boolean(mapStateToProps),
      // passed through to selectorFactory
      initMapStateToProps,
      initMapDispatchToProps,
      initMergeProps,
      pure,
      areStatesEqual,
      areOwnPropsEqual,
      areStatePropsEqual,
      areMergedPropsEqual
    }, extraOptions));
  };
}
const connect = /* @__PURE__ */ createConnect();
setBatch(reactDomExports.unstable_batchedUpdates);
var PLACEMENT_AFTER = "after";
var PLACEMENT_BEFORE = "before";
var PLACEMENT_APPEND = "append";
var PLACEMENT_PREPEND = "prepend";
var SET_DRAG_PROGRESS = "SET_DRAG_PROGRESS";
var SET_DRAG_START = "SET_DRAG_START";
var SET_DRAG_END = "SET_DRAG_END";
var setDragProgress = function setDragProgress2(mousePos, dragging) {
  return {
    type: SET_DRAG_PROGRESS,
    mousePos,
    dragging
  };
};
var setDragStart = function setDragStart2(dragStart, dragging, mousePos) {
  return {
    type: SET_DRAG_START,
    dragStart,
    dragging,
    mousePos
  };
};
var setDragEnd = function setDragEnd2() {
  return {
    type: SET_DRAG_END
  };
};
var tree = tree$1, group = group$1, rule = rule$1;
function _createForOfIteratorHelper$1(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i2 = 0;
      var F2 = function F3() {
      };
      return { s: F2, n: function n2() {
        if (i2 >= o.length)
          return { done: true };
        return { done: false, value: o[i2++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F2 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it = it.call(o);
  }, n: function n2() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f2() {
    try {
      if (!normalCompletion && it["return"] != null)
        it["return"]();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
var extendConfig2 = Utils$1.ConfigUtils.extendConfig;
var configKeys = ["conjunctions", "fields", "types", "operators", "widgets", "settings", "funcs"];
var pickConfig = function pickConfig2(props) {
  return pick$1(props, configKeys);
};
var createConfigMemo = function createConfigMemo2() {
  var configStore = /* @__PURE__ */ new Map();
  var maxSize = 2;
  var configId = 0;
  var extendAndStore = function extendAndStore2(config2) {
    var extendedConfig = extendConfig2(config2, ++configId);
    if (configStore.size + 1 > maxSize) {
      configStore["delete"](configStore.keys()[0]);
    }
    configStore.set(config2, extendedConfig);
    return extendedConfig;
  };
  var findExtended = function findExtended2(findConfig) {
    var _iterator = _createForOfIteratorHelper$1(configStore.keys()), _step;
    try {
      var _loop = function _loop4() {
        var savedConfig = _step.value;
        var found = configKeys.map(function(k2) {
          return savedConfig[k2] === findConfig[k2];
        }).filter(function(v2) {
          return !v2;
        }).length === 0;
        if (found) {
          return {
            v: configStore.get(savedConfig)
          };
        }
      };
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _ret = _loop();
        if (_typeof$2(_ret) === "object")
          return _ret.v;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var _iterator2 = _createForOfIteratorHelper$1(configStore.values()), _step2;
    try {
      var _loop22 = function _loop23() {
        var extendedConfig = _step2.value;
        var found = configKeys.map(function(k2) {
          return extendedConfig[k2] === findConfig[k2];
        }).filter(function(v2) {
          return !v2;
        }).length === 0;
        if (found) {
          return {
            v: extendedConfig
          };
        }
      };
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var _ret2 = _loop22();
        if (_typeof$2(_ret2) === "object")
          return _ret2.v;
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return null;
  };
  var findOrExtend = function findOrExtend2(config2) {
    return findExtended(config2) || extendAndStore(config2);
  };
  return function(props) {
    return findOrExtend(pickConfig(props));
  };
};
var defaultValue2 = function defaultValue3(value, _default2) {
  return typeof value === "undefined" ? _default2 : value;
};
var truncateString = function truncateString2(str, n2, useWordBoundary) {
  if (!n2 || str.length <= n2) {
    return str;
  }
  var subString = str.substr(0, n2 - 1);
  return (useWordBoundary ? subString.substr(0, subString.lastIndexOf(" ")) : subString) + "...";
};
var immutableEqual = function immutableEqual2(v1, v2) {
  if (v1 === v2) {
    return true;
  } else {
    return v1.equals(v2);
  }
};
var shallowEqual2 = function shallowEqual3(a2, b2) {
  var deep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (a2 === b2) {
    return true;
  } else if (Array.isArray(a2))
    return shallowEqualArrays(a2, b2, deep);
  else if (a2 && typeof a2.equals === "function")
    return a2.equals(b2);
  else if (_typeof$2(a2) === "object")
    return shallowEqualObjects(a2, b2, deep);
  else
    return a2 === b2;
};
function shallowEqualArrays(arrA, arrB) {
  var deep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (arrA === arrB) {
    return true;
  }
  if (!arrA || !arrB) {
    return false;
  }
  var len = arrA.length;
  if (arrB.length !== len) {
    return false;
  }
  for (var i2 = 0; i2 < len; i2++) {
    var isEqual2 = deep ? shallowEqual2(arrA[i2], arrB[i2], deep) : arrA[i2] === arrB[i2];
    if (!isEqual2) {
      return false;
    }
  }
  return true;
}
function shallowEqualObjects(objA, objB) {
  var deep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (objA === objB) {
    return true;
  }
  if (!objA || !objB) {
    return false;
  }
  var aKeys = Object.keys(objA);
  var bKeys = Object.keys(objB);
  var len = aKeys.length;
  if (bKeys.length !== len) {
    return false;
  }
  for (var i2 = 0; i2 < len; i2++) {
    var key = aKeys[i2];
    var isEqual2 = deep ? shallowEqual2(objA[key], objB[key], deep) : objA[key] === objB[key];
    if (!isEqual2) {
      return false;
    }
  }
  return true;
}
var isDev2 = function isDev3() {
  return typeof process !== "undefined" && {} && false;
};
var getLogger2 = function getLogger3() {
  var devMode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
  var verbose = devMode != void 0 ? devMode : isDev2();
  return verbose ? console : {
    error: function error2() {
    },
    log: function log() {
    },
    warn: function warn2() {
    },
    debug: function debug() {
    },
    info: function info() {
    }
  };
};
var logger = getLogger2();
var validateAndFixTree2 = Utils$1.validateAndFixTree;
var createValidationMemo = function createValidationMemo2() {
  var originalTree;
  var validatedTree;
  var configId;
  return function(config2, tree2) {
    var oldConfig = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
    var sanitizeTree = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
    if (!tree2) {
      return null;
    }
    if (config2.__configId === configId && (immutableEqual(tree2, originalTree) || immutableEqual(tree2, validatedTree))) {
      return validatedTree;
    } else {
      configId = config2.__configId;
      originalTree = tree2;
      if (sanitizeTree === false) {
        validatedTree = validateAndFixTree2(tree2, null, config2, oldConfig || config2, false, false);
      } else {
        validatedTree = validateAndFixTree2(tree2, null, config2, oldConfig || config2);
      }
      return validatedTree;
    }
  };
};
var getReactContainerType = function getReactContainerType2(el) {
  if (el._reactRootContainer) {
    return "root";
  }
  if (Object.getOwnPropertyNames(el).filter(function(k2) {
    return k2.startsWith("__reactContainer");
  }).length > 0) {
    return "container";
  }
  return void 0;
};
var getReactRootNodeType = function getReactRootNodeType2(node) {
  if (!node) {
    return void 0;
  }
  var type2 = getReactContainerType(node);
  if (type2 !== void 0) {
    return type2;
  } else {
    return getReactRootNodeType2(node.parentNode);
  }
};
var isUsingLegacyReactDomRender = function isUsingLegacyReactDomRender2(node) {
  return getReactRootNodeType(node) === "root";
};
var liteShouldComponentUpdate = function liteShouldComponentUpdate2(self2, config2) {
  return function(nextProps, nextState) {
    var prevProps = self2.props;
    var prevState = self2.state;
    var should = nextProps != prevProps || nextState != prevState;
    if (should) {
      if (prevState == nextState && prevProps != nextProps) {
        var chs = [];
        for (var k2 in nextProps) {
          var changed = nextProps[k2] != prevProps[k2];
          if (changed) {
            if (config2[k2] == "ignore")
              changed = false;
            else if (config2[k2] == "shallow_deep")
              changed = !shallowEqual2(nextProps[k2], prevProps[k2], true);
            else if (config2[k2] == "shallow")
              changed = !shallowEqual2(nextProps[k2], prevProps[k2]);
            else if (typeof config2[k2] == "function")
              changed = config2[k2](nextProps[k2], prevProps[k2], nextState);
          }
          if (changed)
            chs.push(k2);
        }
        if (!chs.length)
          should = false;
      }
    }
    return should;
  };
};
var pureShouldComponentUpdate = function pureShouldComponentUpdate2(self2) {
  return function(nextProps, nextState) {
    return !shallowEqual2(self2.props, nextProps) || !shallowEqual2(self2.state, nextState);
  };
};
var canUseOldComponentWillReceiveProps = function canUseOldComponentWillReceiveProps2() {
  var v2 = React.version.split(".").map(parseInt.bind(null, 10));
  return v2[0] == 16 && v2[1] < 3 || v2[0] < 16;
};
var useOnPropsChanged = function useOnPropsChanged2(obj) {
  if (!obj.shouldComponentUpdate) {
    obj.shouldComponentUpdate = pureShouldComponentUpdate(obj);
  }
  if (canUseOldComponentWillReceiveProps()) {
    obj.componentWillReceiveProps = function(nextProps) {
      obj.onPropsChanged(nextProps);
    };
  } else {
    var origShouldComponentUpdate = obj.shouldComponentUpdate;
    var newShouldComponentUpdate = function newShouldComponentUpdate2(nextProps, nextState) {
      var shouldNotify = !shallowEqual2(obj.props, nextProps);
      if (shouldNotify) {
        obj.onPropsChanged(nextProps);
      }
      var shouldUpdate = origShouldComponentUpdate.call(obj, nextProps, nextState);
      return shouldUpdate;
    };
    obj.shouldComponentUpdate = newShouldComponentUpdate.bind(obj);
  }
};
var bindActionCreators = function bindActionCreators2(actionCreators, config2, dispatch) {
  return mapValues$1(actionCreators, function(actionCreator) {
    return function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return dispatch(actionCreator.apply(void 0, [config2].concat(args)));
    };
  });
};
const ReactUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bindActionCreators,
  isUsingLegacyReactDomRender,
  liteShouldComponentUpdate,
  pureShouldComponentUpdate,
  useOnPropsChanged
}, Symbol.toStringTag, { value: "Module" }));
function ownKeys$h(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$h(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$h(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$h(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper$r(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$r();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct$r() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var Query = /* @__PURE__ */ function(_Component) {
  _inherits$b(Query2, _Component);
  var _super = _createSuper$r(Query2);
  function Query2(props) {
    var _this;
    _classCallCheck$b(this, Query2);
    _this = _super.call(this, props);
    _this.shouldComponentUpdate = liteShouldComponentUpdate(_assertThisInitialized$1(_this), {
      tree: function tree2(nextValue) {
        if (nextValue === _this.oldValidatedTree && _this.oldValidatedTree === _this.validatedTree) {
          return false;
        }
        return true;
      }
    });
    useOnPropsChanged(_assertThisInitialized$1(_this));
    _this._updateActions(props);
    _this.validatedTree = props.getMemoizedTree(props.config, props.tree);
    _this.oldValidatedTree = _this.validatedTree;
    return _this;
  }
  _createClass$9(Query2, [{
    key: "_updateActions",
    value: function _updateActions(props) {
      var config2 = props.config, dispatch = props.dispatch;
      this.actions = bindActionCreators(_objectSpread$h(_objectSpread$h(_objectSpread$h({}, tree), group), rule), config2, dispatch);
    }
  }, {
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var onChange = nextProps.onChange;
      var oldConfig = this.props.config;
      var newTree = nextProps.tree;
      this.props.tree;
      var newConfig = nextProps.config;
      this.oldValidatedTree = this.validatedTree;
      this.validatedTree = newTree;
      if (oldConfig !== newConfig) {
        this._updateActions(nextProps);
        this.validatedTree = nextProps.getMemoizedTree(newConfig, newTree, oldConfig);
      }
      var validatedTreeChanged = !immutableEqual(this.validatedTree, this.oldValidatedTree);
      if (validatedTreeChanged) {
        onChange && onChange(this.validatedTree, newConfig, nextProps.__lastAction);
      }
    }
  }, {
    key: "render",
    value: function render3() {
      var _this$props = this.props, config2 = _this$props.config, renderBuilder = _this$props.renderBuilder, dispatch = _this$props.dispatch, __isInternalValueChange = _this$props.__isInternalValueChange;
      var builderProps = {
        tree: this.validatedTree,
        actions: this.actions,
        config: config2,
        dispatch,
        __isInternalValueChange
      };
      return renderBuilder(builderProps);
    }
  }]);
  return Query2;
}(reactExports.Component);
Query.propTypes = {
  config: PropTypes.object.isRequired,
  onChange: PropTypes.func,
  renderBuilder: PropTypes.func,
  tree: PropTypes.any
  //instanceOf(Immutable.Map)
  //dispatch: PropTypes.func.isRequired,
  //__isInternalValueChange
  //__lastAction
  //getMemoizedTree: PropTypes.func.isRequired,
};
var ConnectedQuery = connect(function(state) {
  return {
    tree: state.tree,
    __isInternalValueChange: state.__isInternalValueChange,
    __lastAction: state.__lastAction
  };
}, null, null, {
  context
})(Query);
ConnectedQuery.displayName = "ConnectedQuery";
function _createSuper$q(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$q();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct$q() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var defaultRoot2 = Utils$1.DefaultUtils.defaultRoot;
var QueryContainer = /* @__PURE__ */ function(_Component) {
  _inherits$b(QueryContainer2, _Component);
  var _super = _createSuper$q(QueryContainer2);
  function QueryContainer2(props, context2) {
    var _this;
    _classCallCheck$b(this, QueryContainer2);
    _this = _super.call(this, props, context2);
    _this.setLastTree = function(lastTree) {
      if (_this.prevTree) {
        _this.prevprevTree = _this.prevTree;
      }
      _this.prevTree = lastTree;
    };
    _this.shouldComponentUpdate = liteShouldComponentUpdate(_assertThisInitialized$1(_this), {
      value: function value(nextValue, prevValue, state) {
        return false;
      }
    });
    useOnPropsChanged(_assertThisInitialized$1(_this));
    _this.getMemoizedConfig = createConfigMemo();
    _this.getMemoizedTree = createValidationMemo();
    var config2 = _this.getMemoizedConfig(props);
    var tree2 = props.value;
    var validatedTree = _this.getMemoizedTree(config2, tree2);
    var reducer = TreeStore(config2, validatedTree, _this.getMemoizedTree, _this.setLastTree);
    var store = createStore(reducer);
    _this.config = config2;
    _this.state = {
      store
    };
    return _this;
  }
  _createClass$9(QueryContainer2, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var oldConfig = this.config;
      var nextConfig = this.getMemoizedConfig(nextProps);
      var isConfigChanged = oldConfig !== nextConfig;
      var storeValue = this.state.store.getState().tree;
      var isTreeChanged = !immutableEqual(nextProps.value, this.props.value) && !immutableEqual(nextProps.value, storeValue);
      var currentTree = isTreeChanged ? nextProps.value || defaultRoot2(nextProps) : storeValue;
      var isTreeTrulyChanged = isTreeChanged && !immutableEqual(nextProps.value, this.prevTree) && !immutableEqual(nextProps.value, this.prevprevTree);
      var sanitizeTree = isTreeTrulyChanged || isConfigChanged;
      if (isConfigChanged) {
        this.config = nextConfig;
      }
      if (isTreeChanged || isConfigChanged) {
        var validatedTree = this.getMemoizedTree(nextConfig, currentTree, oldConfig, sanitizeTree);
        this.state.store.dispatch(tree.setTree(nextConfig, validatedTree));
      }
    }
  }, {
    key: "render",
    value: function render3() {
      var _this$props = this.props, renderBuilder = _this$props.renderBuilder, get_children = _this$props.get_children, onChange = _this$props.onChange, settings2 = _this$props.settings;
      var store = this.state.store;
      var config2 = this.config;
      var QueryWrapper = settings2.renderProvider;
      return /* @__PURE__ */ React.createElement(QueryWrapper, {
        config: config2
      }, /* @__PURE__ */ React.createElement(Provider, {
        store,
        context
      }, /* @__PURE__ */ React.createElement(ConnectedQuery, {
        config: config2,
        getMemoizedTree: this.getMemoizedTree,
        onChange,
        renderBuilder: renderBuilder || get_children
      })));
    }
  }]);
  return QueryContainer2;
}(reactExports.Component);
QueryContainer.propTypes = {
  //config
  conjunctions: PropTypes.object.isRequired,
  fields: PropTypes.object.isRequired,
  types: PropTypes.object.isRequired,
  operators: PropTypes.object.isRequired,
  widgets: PropTypes.object.isRequired,
  settings: PropTypes.object.isRequired,
  onChange: PropTypes.func,
  renderBuilder: PropTypes.func,
  value: PropTypes.any
  //instanceOf(Immutable.Map)
};
function _createSuper$p(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$p();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct$p() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var getFieldConfig$7 = Utils$1.ConfigUtils.getFieldConfig;
var createRuleContainer = function createRuleContainer2(Rule2) {
  var _class;
  return _class = /* @__PURE__ */ function(_Component) {
    _inherits$b(RuleContainer2, _Component);
    var _super = _createSuper$p(RuleContainer2);
    function RuleContainer2(props) {
      var _this;
      _classCallCheck$b(this, RuleContainer2);
      _this = _super.call(this, props);
      _this.dummyFn = function() {
      };
      _this.removeSelf = function() {
        _this.props.actions.removeRule(_this.props.path);
      };
      _this.setLock = function() {
        var lock = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        _this.props.actions.setLock(_this.props.path, lock);
      };
      _this.setField = function(field) {
        _this.props.actions.setField(_this.props.path, field);
      };
      _this.setOperator = function(operator) {
        _this.props.actions.setOperator(_this.props.path, operator);
      };
      _this.setOperatorOption = function(name, value) {
        _this.props.actions.setOperatorOption(_this.props.path, name, value);
      };
      _this.setValue = function(delta, value, type2, asyncListValues, __isInternal) {
        _this.props.actions.setValue(_this.props.path, delta, value, type2, asyncListValues, __isInternal);
      };
      _this.setValueSrc = function(delta, srcKey) {
        _this.props.actions.setValueSrc(_this.props.path, delta, srcKey);
      };
      _this.pureShouldComponentUpdate = pureShouldComponentUpdate(_assertThisInitialized$1(_this));
      _this.dummyFn.isDummyFn = true;
      return _this;
    }
    _createClass$9(RuleContainer2, [{
      key: "shouldComponentUpdate",
      value: function shouldComponentUpdate(nextProps, nextState) {
        var prevProps = this.props;
        var prevState = this.state;
        var should = this.pureShouldComponentUpdate(nextProps, nextState);
        if (should) {
          if (prevState == nextState && prevProps != nextProps) {
            var draggingId = nextProps.dragging.id || prevProps.dragging.id;
            var isDraggingMe = draggingId == nextProps.id;
            var chs = [];
            for (var k2 in nextProps) {
              var changed = nextProps[k2] != prevProps[k2];
              if (k2 == "dragging" && !isDraggingMe) {
                changed = false;
              }
              if (changed) {
                chs.push(k2);
              }
            }
            if (!chs.length)
              should = false;
          }
        }
        return should;
      }
    }, {
      key: "render",
      value: function render3() {
        var isDraggingMe = this.props.dragging.id == this.props.id;
        var fieldConfig = getFieldConfig$7(this.props.config, this.props.field);
        var showErrorMessage = this.props.config.settings.showErrorMessage;
        fieldConfig && fieldConfig.type == "!struct";
        var isInDraggingTempo = !isDraggingMe && this.props.isDraggingTempo;
        var valueError = this.props.valueError;
        var oneValueError = valueError && valueError.toArray().filter(function(e2) {
          return !!e2;
        }).shift() || null;
        var hasError = oneValueError != null && showErrorMessage;
        return /* @__PURE__ */ React.createElement("div", {
          className: classNames("group-or-rule-container", "rule-container", hasError ? "rule-with-error" : null),
          "data-id": this.props.id
        }, [isDraggingMe ? /* @__PURE__ */ React.createElement(Rule2, {
          key: "dragging",
          id: this.props.id,
          groupId: this.props.groupId,
          isDraggingMe: true,
          isDraggingTempo: true,
          dragging: this.props.dragging,
          setField: this.dummyFn,
          setOperator: this.dummyFn,
          setOperatorOption: this.dummyFn,
          setLock: this.dummyFn,
          removeSelf: this.dummyFn,
          setValue: this.dummyFn,
          setValueSrc: this.dummyFn,
          selectedField: this.props.field || null,
          parentField: this.props.parentField || null,
          selectedOperator: this.props.operator || null,
          value: this.props.value || null,
          valueSrc: this.props.valueSrc || null,
          valueError: this.props.valueError || null,
          operatorOptions: this.props.operatorOptions,
          config: this.props.config,
          reordableNodesCnt: this.props.reordableNodesCnt,
          totalRulesCnt: this.props.totalRulesCnt,
          asyncListValues: this.props.asyncListValues,
          isLocked: this.props.isLocked,
          isTrueLocked: this.props.isTrueLocked,
          parentReordableNodesCnt: this.props.parentReordableNodesCnt
        }) : null, /* @__PURE__ */ React.createElement(Rule2, {
          key: this.props.id,
          id: this.props.id,
          groupId: this.props.groupId,
          isDraggingMe,
          isDraggingTempo: isInDraggingTempo,
          onDragStart: this.props.onDragStart,
          setLock: isInDraggingTempo ? this.dummyFn : this.setLock,
          removeSelf: isInDraggingTempo ? this.dummyFn : this.removeSelf,
          setField: isInDraggingTempo ? this.dummyFn : this.setField,
          setOperator: isInDraggingTempo ? this.dummyFn : this.setOperator,
          setOperatorOption: isInDraggingTempo ? this.dummyFn : this.setOperatorOption,
          setValue: isInDraggingTempo ? this.dummyFn : this.setValue,
          setValueSrc: isInDraggingTempo ? this.dummyFn : this.setValueSrc,
          selectedField: this.props.field || null,
          parentField: this.props.parentField || null,
          selectedOperator: this.props.operator || null,
          value: this.props.value || null,
          valueSrc: this.props.valueSrc || null,
          valueError: this.props.valueError || null,
          operatorOptions: this.props.operatorOptions,
          config: this.props.config,
          reordableNodesCnt: this.props.reordableNodesCnt,
          totalRulesCnt: this.props.totalRulesCnt,
          asyncListValues: this.props.asyncListValues,
          isLocked: this.props.isLocked,
          isTrueLocked: this.props.isTrueLocked,
          parentReordableNodesCnt: this.props.parentReordableNodesCnt
        })]);
      }
    }]);
    return RuleContainer2;
  }(reactExports.Component), _class.propTypes = {
    id: PropTypes.string.isRequired,
    groupId: PropTypes.string,
    config: PropTypes.object.isRequired,
    path: PropTypes.any.isRequired,
    //instanceOf(Immutable.List)
    operator: PropTypes.string,
    field: PropTypes.string,
    actions: PropTypes.object.isRequired,
    //{removeRule: Funciton, setField, setOperator, setOperatorOption, setValue, setValueSrc, ...}
    onDragStart: PropTypes.func,
    value: PropTypes.any,
    //depends on widget
    valueSrc: PropTypes.any,
    asyncListValues: PropTypes.array,
    valueError: PropTypes.any,
    operatorOptions: PropTypes.object,
    reordableNodesCnt: PropTypes.number,
    parentField: PropTypes.string,
    //from RuleGroup
    isLocked: PropTypes.bool,
    isTrueLocked: PropTypes.bool,
    //connected:
    dragging: PropTypes.object,
    //{id, x, y, w, h}
    isDraggingTempo: PropTypes.bool
  }, _class;
};
const RuleContainer = function(Rule2) {
  var ConnectedRuleContainer = connect(function(state) {
    return {
      dragging: state.dragging
    };
  }, null, null, {
    context
  })(createRuleContainer(Rule2));
  ConnectedRuleContainer.displayName = "ConnectedRuleContainer";
  return ConnectedRuleContainer;
};
function _createSuper$o(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$o();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct$o() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var clone$2 = Utils$1.clone;
var getFlatTree2 = Utils$1.TreeUtils.getFlatTree;
var _isReorderingTree = false;
var createSortableContainer = function createSortableContainer2(Builder2) {
  var _class;
  var CanMoveFn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  return _class = /* @__PURE__ */ function(_Component) {
    _inherits$b(SortableContainer2, _Component);
    var _super = _createSuper$o(SortableContainer2);
    function SortableContainer2(props) {
      var _this;
      _classCallCheck$b(this, SortableContainer2);
      _this = _super.call(this, props);
      _this._getEventTarget = function(e2, dragStart) {
        return e2 && e2.__mocked_window || document.body || window;
      };
      _this.onDragStart = function(id, dom, e2) {
        var treeEl = dom.closest(".query-builder");
        if (_this._isUsingLegacyReactDomRender === void 0) {
          _this._isUsingLegacyReactDomRender = isUsingLegacyReactDomRender(treeEl);
        }
        document.body.classList.add("qb-dragging");
        treeEl.classList.add("qb-dragging");
        var treeElContainer = treeEl.closest(".query-builder-container") || treeEl;
        treeElContainer = _this._getScrollParent(treeElContainer) || document.body;
        var scrollTop = treeElContainer.scrollTop;
        _this._getDraggableNodeEl(treeEl);
        _this._getPlaceholderNodeEl(treeEl);
        var tmpAllGroups = treeEl.querySelectorAll(".group--children");
        var anyGroup = tmpAllGroups.length ? tmpAllGroups[0] : null;
        var groupPadding;
        if (anyGroup) {
          groupPadding = window.getComputedStyle(anyGroup, null).getPropertyValue("padding-left");
          groupPadding = parseInt(groupPadding);
        }
        var dragging = {
          id,
          x: dom.offsetLeft,
          y: dom.offsetTop,
          w: dom.offsetWidth,
          h: dom.offsetHeight,
          itemInfo: _this.tree.items[id],
          paddingLeft: groupPadding
        };
        var dragStart = {
          id,
          x: dom.offsetLeft,
          y: dom.offsetTop,
          scrollTop,
          clientX: e2.clientX,
          clientY: e2.clientY,
          itemInfo: clone$2(_this.tree.items[id]),
          treeEl,
          treeElContainer
        };
        var mousePos = {
          clientX: e2.clientX,
          clientY: e2.clientY
        };
        var target = _this._getEventTarget(e2, dragStart);
        _this.eventTarget = target;
        target.addEventListener("mousemove", _this.onDrag);
        target.addEventListener("mouseup", _this.onDragEnd);
        _this.props.setDragStart(dragStart, dragging, mousePos);
      };
      _this.onDrag = function(e2) {
        var doHandleDrag = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        var dragging = Object.assign({}, _this.props.dragging);
        var startDragging = _this.props.dragStart;
        var paddingLeft = dragging.paddingLeft;
        var treeElContainer = startDragging.treeElContainer;
        var scrollTop = treeElContainer.scrollTop;
        dragging.itemInfo = _this.tree.items[dragging.id];
        if (!dragging.itemInfo) {
          return;
        }
        var mousePos = {
          clientX: e2.clientX,
          clientY: e2.clientY
        };
        var startMousePos = {
          clientX: startDragging.clientX,
          clientY: startDragging.clientY
        };
        if (e2.__mock_dom) {
          var treeEl = startDragging.treeEl;
          var dragEl = _this._getDraggableNodeEl(treeEl);
          var plhEl = _this._getPlaceholderNodeEl(treeEl);
          e2.__mock_dom({
            treeEl,
            dragEl,
            plhEl
          });
        }
        if (!startDragging.plX) {
          var _treeEl = startDragging.treeEl;
          var _plhEl2 = _this._getPlaceholderNodeEl(_treeEl);
          if (_plhEl2) {
            startDragging.plX = _plhEl2.getBoundingClientRect().left + window.scrollX;
            startDragging.plY = _plhEl2.getBoundingClientRect().top + window.scrollY;
          }
        }
        var startX = startDragging.x;
        var startY = startDragging.y;
        var startClientX = startDragging.clientX;
        var startClientY = startDragging.clientY;
        var startScrollTop = startDragging.scrollTop;
        var pos = {
          x: startX + (e2.clientX - startClientX),
          y: startY + (e2.clientY - startClientY) + (scrollTop - startScrollTop)
        };
        dragging.x = pos.x;
        dragging.y = pos.y;
        dragging.paddingLeft = paddingLeft;
        dragging.mousePos = mousePos;
        dragging.startMousePos = startMousePos;
        _this.props.setDragProgress(mousePos, dragging);
        var moved = doHandleDrag ? _this.handleDrag(dragging, e2, CanMoveFn) : false;
        if (!moved) {
          if (e2.preventDefault)
            e2.preventDefault();
        }
      };
      _this.onDragEnd = function() {
        var treeEl = _this.props.dragStart.treeEl;
        _this.props.setDragEnd();
        treeEl.classList.remove("qb-dragging");
        document.body.classList.remove("qb-dragging");
        _this._cacheEls = {};
        var target = _this.eventTarget || _this._getEventTarget();
        target.removeEventListener("mousemove", _this.onDrag);
        target.removeEventListener("mouseup", _this.onDragEnd);
      };
      _this.pureShouldComponentUpdate = pureShouldComponentUpdate(_assertThisInitialized$1(_this));
      useOnPropsChanged(_assertThisInitialized$1(_this));
      _this.onPropsChanged(props);
      return _this;
    }
    _createClass$9(SortableContainer2, [{
      key: "onPropsChanged",
      value: function onPropsChanged(nextProps) {
        this.tree = getFlatTree2(nextProps.tree);
      }
    }, {
      key: "shouldComponentUpdate",
      value: function shouldComponentUpdate(nextProps, nextState) {
        var prevProps = this.props;
        var prevState = this.state;
        var should = this.pureShouldComponentUpdate(nextProps, nextState);
        if (should) {
          if (prevState == nextState && prevProps != nextProps) {
            var chs = [];
            for (var k2 in nextProps) {
              var changed = nextProps[k2] != prevProps[k2];
              if (changed) {
                if (k2 != "dragging" && k2 != "mousePos")
                  chs.push(k2);
              }
            }
            if (!chs.length)
              should = false;
          }
        }
        return should;
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(_prevProps, _prevState) {
        var dragging = this.props.dragging;
        var startDragging = this.props.dragStart;
        _isReorderingTree = false;
        if (startDragging && startDragging.id) {
          dragging.itemInfo = this.tree.items[dragging.id];
          if (dragging.itemInfo) {
            if (dragging.itemInfo.index != startDragging.itemInfo.index || dragging.itemInfo.parent != startDragging.itemInfo.parent) {
              var treeEl = startDragging.treeEl;
              var treeElContainer = startDragging.treeElContainer;
              var plhEl = this._getPlaceholderNodeEl(treeEl, true);
              if (plhEl) {
                var plX = plhEl.getBoundingClientRect().left + window.scrollX;
                var plY = plhEl.getBoundingClientRect().top + window.scrollY;
                var oldPlX = startDragging.plX;
                var oldPlY = startDragging.plY;
                var scrollTop = treeElContainer.scrollTop;
                startDragging.plX = plX;
                startDragging.plY = plY;
                startDragging.itemInfo = clone$2(dragging.itemInfo);
                startDragging.y = plhEl.offsetTop;
                startDragging.x = plhEl.offsetLeft;
                startDragging.clientY += plY - oldPlY;
                startDragging.clientX += plX - oldPlX;
                if (treeElContainer != document.body)
                  startDragging.scrollTop = scrollTop;
                this.onDrag(this.props.mousePos, false);
              }
            }
          }
        }
      }
    }, {
      key: "_getNodeElById",
      value: function _getNodeElById(treeEl, indexId) {
        var ignoreCache = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        if (indexId == null)
          return null;
        if (!this._cacheEls)
          this._cacheEls = {};
        var el = this._cacheEls[indexId];
        if (el && document.contains(el) && !ignoreCache)
          return el;
        el = treeEl.querySelector('.group-or-rule-container[data-id="' + indexId + '"]');
        this._cacheEls[indexId] = el;
        return el;
      }
    }, {
      key: "_getDraggableNodeEl",
      value: function _getDraggableNodeEl(treeEl) {
        var ignoreCache = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (!this._cacheEls)
          this._cacheEls = {};
        var el = this._cacheEls["draggable"];
        if (el && document.contains(el) && !ignoreCache)
          return el;
        var els = treeEl.getElementsByClassName("qb-draggable");
        el = els.length ? els[0] : null;
        this._cacheEls["draggable"] = el;
        return el;
      }
    }, {
      key: "_getPlaceholderNodeEl",
      value: function _getPlaceholderNodeEl(treeEl) {
        var ignoreCache = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (!this._cacheEls)
          this._cacheEls = {};
        var el = this._cacheEls["placeholder"];
        if (el && document.contains(el) && !ignoreCache)
          return el;
        var els = treeEl.getElementsByClassName("qb-placeholder");
        el = els.length ? els[0] : null;
        this._cacheEls["placeholder"] = el;
        return el;
      }
    }, {
      key: "_isScrollable",
      value: function _isScrollable(node) {
        var overflowY = window.getComputedStyle(node)["overflow-y"];
        return (overflowY === "scroll" || overflowY === "auto") && node.scrollHeight > node.offsetHeight;
      }
    }, {
      key: "_getScrollParent",
      value: function _getScrollParent(node) {
        if (node == null)
          return null;
        if (node === document.body || this._isScrollable(node)) {
          return node;
        } else {
          return this._getScrollParent(node.parentNode);
        }
      }
    }, {
      key: "handleDrag",
      value: function handleDrag(dragInfo, e2, canMoveFn) {
        var _this2 = this;
        var canMoveBeforeAfterGroup = true;
        var itemInfo = dragInfo.itemInfo;
        var paddingLeft = dragInfo.paddingLeft;
        var moveInfo = null;
        var treeEl = this.props.dragStart.treeEl;
        var dragId = dragInfo.id;
        var dragEl = this._getDraggableNodeEl(treeEl);
        var plhEl = this._getPlaceholderNodeEl(treeEl);
        var dragRect, plhRect, hovRect, treeRect;
        if (dragEl && plhEl) {
          dragRect = dragEl.getBoundingClientRect();
          plhRect = plhEl.getBoundingClientRect();
          if (!plhRect.width) {
            return;
          }
          var dragDirs = {
            hrz: 0,
            vrt: 0
          };
          if (dragRect.top < plhRect.top)
            dragDirs.vrt = -1;
          else if (dragRect.bottom > plhRect.bottom)
            dragDirs.vrt = 1;
          if (dragRect.left > plhRect.left)
            dragDirs.hrz = 1;
          else if (dragRect.left < plhRect.left)
            dragDirs.hrz = -1;
          treeRect = treeEl.getBoundingClientRect();
          var trgCoord = {
            x: treeRect.left + (treeRect.right - treeRect.left) / 2,
            y: dragDirs.vrt >= 0 ? dragRect.bottom : dragRect.top
          };
          var hovCNodeEl;
          if (e2.__mocked_hov_container) {
            hovCNodeEl = e2.__mocked_hov_container;
          } else {
            var hovNodeEl = document.elementFromPoint(trgCoord.x, trgCoord.y - 1);
            hovCNodeEl = hovNodeEl ? hovNodeEl.closest(".group-or-rule-container") : null;
            if (!hovCNodeEl && hovNodeEl && hovNodeEl.classList.contains("query-builder-container")) {
              var _hovNodeEl$firstChild;
              var rootGroupContainer = hovNodeEl === null || hovNodeEl === void 0 ? void 0 : (_hovNodeEl$firstChild = hovNodeEl.firstChild) === null || _hovNodeEl$firstChild === void 0 ? void 0 : _hovNodeEl$firstChild.firstChild;
              if (rootGroupContainer && rootGroupContainer.classList.contains("group-or-rule-container")) {
                hovCNodeEl = rootGroupContainer;
              }
            }
          }
          if (!hovCNodeEl) {
            logger.log("out of tree bounds!");
          } else {
            var isGroup2 = hovCNodeEl.classList.contains("group-container");
            var hovNodeId = hovCNodeEl.getAttribute("data-id");
            var hovEl = hovCNodeEl;
            var doAppend = false;
            var doPrepend = false;
            if (hovEl) {
              hovRect = hovEl.getBoundingClientRect();
              var hovHeight = hovRect.bottom - hovRect.top;
              var hovII = this.tree.items[hovNodeId];
              var trgRect = null, trgEl = null, trgII = null, altII = null;
              if (dragDirs.vrt == 0) {
                trgII = itemInfo;
                trgEl = plhEl;
                if (trgEl)
                  trgRect = trgEl.getBoundingClientRect();
              } else {
                if (isGroup2) {
                  if (dragDirs.vrt > 0) {
                    var hovInnerEl = hovCNodeEl.getElementsByClassName("group--header");
                    var hovEl2 = hovInnerEl.length ? hovInnerEl[0] : null;
                    if (hovEl2) {
                      var hovRect2 = hovEl2.getBoundingClientRect();
                      var hovHeight2 = hovRect2.bottom - hovRect2.top;
                      var isOverHover = dragRect.bottom - hovRect2.top > hovHeight2 * 3 / 4;
                      if (isOverHover && hovII.top > dragInfo.itemInfo.top) {
                        trgII = hovII;
                        trgRect = hovRect2;
                        trgEl = hovEl2;
                        doPrepend = true;
                      }
                    }
                  } else if (dragDirs.vrt < 0) {
                    if (hovII.lev >= itemInfo.lev) {
                      var isClimbToHover = hovRect.bottom - dragRect.top >= 2;
                      if (isClimbToHover && hovII.top < dragInfo.itemInfo.top) {
                        trgII = hovII;
                        trgRect = hovRect;
                        trgEl = hovEl;
                        doAppend = true;
                      }
                    }
                  }
                  if (!doPrepend && !doAppend || canMoveBeforeAfterGroup) {
                    var _isOverHover = dragDirs.vrt < 0 ? hovRect.bottom - dragRect.top > hovHeight - 5 : dragRect.bottom - hovRect.top > hovHeight - 5;
                    if (_isOverHover) {
                      if (!doPrepend && !doAppend) {
                        trgII = hovII;
                        trgRect = hovRect;
                        trgEl = hovEl;
                      }
                      {
                        altII = hovII;
                      }
                    }
                  }
                } else {
                  var _isOverHover2 = dragDirs.vrt < 0 ? hovRect.bottom - dragRect.top > hovHeight / 2 : dragRect.bottom - hovRect.top > hovHeight / 2;
                  if (_isOverHover2) {
                    trgII = hovII;
                    trgRect = hovRect;
                    trgEl = hovEl;
                  }
                }
              }
              var isSamePos = trgII && trgII.id == dragId;
              if (trgRect) {
                var dragLeftOffset = dragRect.left - treeRect.left;
                trgRect.left - treeRect.left;
                var dragLev = Math.max(0, Math.round(dragLeftOffset / paddingLeft));
                var availMoves = [];
                var altMoves = [];
                if (isSamePos)
                  ;
                else {
                  if (isGroup2) {
                    if (doAppend) {
                      availMoves.push([PLACEMENT_APPEND, trgII, trgII.lev + 1]);
                    } else if (doPrepend) {
                      availMoves.push([PLACEMENT_PREPEND, trgII, trgII.lev + 1]);
                    }
                    if (altII) {
                      var isToRoot = altII.lev == 0;
                      var isToCase = altII.type == "case_group" && itemInfo.type != "case_group";
                      var prevCaseId = altII.prev && this.tree.items[altII.prev].caseId;
                      var nextCaseId = altII.next && this.tree.items[altII.next].caseId;
                      if (itemInfo.caseId == prevCaseId)
                        prevCaseId = null;
                      if (itemInfo.caseId == nextCaseId)
                        nextCaseId = null;
                      var prevCase = prevCaseId && this.tree.items[prevCaseId];
                      var nextCase = nextCaseId && this.tree.items[nextCaseId];
                      if (dragDirs.vrt > 0) {
                        if (isToRoot) {
                          altMoves.push([PLACEMENT_APPEND, altII, altII.lev + 1]);
                        } else if (isToCase && nextCase) {
                          altMoves.push([PLACEMENT_PREPEND, nextCase, nextCase.lev + 1]);
                        } else {
                          altMoves.push([PLACEMENT_AFTER, altII, altII.lev]);
                        }
                      } else if (dragDirs.vrt < 0) {
                        if (isToRoot) {
                          altMoves.push([PLACEMENT_PREPEND, altII, altII.lev + 1]);
                        } else if (isToCase && prevCase) {
                          altMoves.push([PLACEMENT_APPEND, prevCase, prevCase.lev + 1]);
                        } else {
                          altMoves.push([PLACEMENT_BEFORE, altII, altII.lev]);
                        }
                      }
                    }
                  }
                  if (!doAppend && !doPrepend) {
                    if (dragDirs.vrt < 0) {
                      availMoves.push([PLACEMENT_BEFORE, trgII, trgII.lev]);
                    } else if (dragDirs.vrt > 0) {
                      availMoves.push([PLACEMENT_AFTER, trgII, trgII.lev]);
                    }
                  }
                }
                var addCaseII = function addCaseII2(am) {
                  var toII = am[1];
                  var fromCaseII = itemInfo.caseId ? _this2.tree.items[itemInfo.caseId] : null;
                  var toCaseII = toII.caseId ? _this2.tree.items[toII.caseId] : null;
                  return [].concat(_toConsumableArray(am), [fromCaseII, toCaseII]);
                };
                availMoves = availMoves.map(addCaseII);
                altMoves = altMoves.map(addCaseII);
                availMoves = availMoves.filter(function(am) {
                  var placement = am[0];
                  var trg = am[1];
                  if ((placement == PLACEMENT_BEFORE || placement == PLACEMENT_AFTER) && trg.parent == null)
                    return false;
                  if (trg.collapsed && (placement == PLACEMENT_APPEND || placement == PLACEMENT_PREPEND))
                    return false;
                  var isInside = trg.id == itemInfo.id;
                  if (!isInside) {
                    var tmp = trg;
                    while (tmp.parent) {
                      tmp = _this2.tree.items[tmp.parent];
                      if (tmp.id == itemInfo.id) {
                        isInside = true;
                        break;
                      }
                    }
                  }
                  return !isInside;
                }).map(function(am) {
                  var placement = am[0], toII = am[1];
                  am[2];
                  am[3];
                  am[4];
                  var toParentII = null;
                  if (placement == PLACEMENT_APPEND || placement == PLACEMENT_PREPEND)
                    toParentII = toII;
                  else
                    toParentII = _this2.tree.items[toII.parent];
                  if (toParentII && toParentII.parent == null)
                    toParentII = null;
                  am[5] = toParentII;
                  return am;
                });
                var bestMode = null;
                var filteredMoves = availMoves.filter(function(am) {
                  return _this2.canMove(itemInfo, am[1], am[0], am[3], am[4], am[5], canMoveFn);
                });
                if (filteredMoves.length == 0 && altMoves.length > 0) {
                  filteredMoves = altMoves.filter(function(am) {
                    return _this2.canMove(itemInfo, am[1], am[0], am[3], am[4], am[5], canMoveFn);
                  });
                }
                var levs = filteredMoves.map(function(am) {
                  return am[2];
                });
                var curLev = itemInfo.lev;
                var allLevs = levs.concat(curLev);
                var closestDragLev = null;
                if (allLevs.indexOf(dragLev) != -1)
                  closestDragLev = dragLev;
                else if (dragLev > Math.max.apply(Math, _toConsumableArray(allLevs)))
                  closestDragLev = Math.max.apply(Math, _toConsumableArray(allLevs));
                else if (dragLev < Math.min.apply(Math, _toConsumableArray(allLevs)))
                  closestDragLev = Math.min.apply(Math, _toConsumableArray(allLevs));
                bestMode = filteredMoves.find(function(am) {
                  return am[2] == closestDragLev;
                });
                if (!isSamePos && !bestMode && filteredMoves.length)
                  bestMode = filteredMoves[0];
                moveInfo = bestMode;
              }
            }
          }
        }
        if (moveInfo) {
          this.move(itemInfo, moveInfo[1], moveInfo[0], moveInfo[3]);
          return true;
        }
        return false;
      }
    }, {
      key: "canMove",
      value: function canMove(fromII, toII, placement, fromCaseII, toCaseII, toParentII, canMoveFn) {
        if (!fromII || !toII)
          return false;
        if (fromII.id === toII.id)
          return false;
        var _this$props$config$se = this.props.config.settings, canRegroup = _this$props$config$se.canRegroup, canRegroupCases = _this$props$config$se.canRegroupCases, maxNesting = _this$props$config$se.maxNesting, maxNumberOfRules = _this$props$config$se.maxNumberOfRules, canLeaveEmptyCase = _this$props$config$se.canLeaveEmptyCase;
        var newLev = toParentII ? toParentII.lev + 1 : toII.lev;
        var isBeforeAfter = placement == PLACEMENT_BEFORE || placement == PLACEMENT_AFTER;
        var isPend = placement == PLACEMENT_PREPEND || placement == PLACEMENT_APPEND;
        var isLev1 = isBeforeAfter && toII.lev == 1 || isPend && toII.lev == 0;
        var isParentChange = fromII.parent != toII.parent;
        var isStructChange = isPend || isParentChange;
        var isForbiddenStructChange = fromII.type == "case_group" && !isLev1 || fromII.parentType == "rule_group" || toII.type == "rule_group" || toII.parentType == "rule_group" || fromII.type != "case_group" && toII.type == "case_group" && isBeforeAfter || fromII.type != "case_group" && toII.type == "switch_group" || !canRegroupCases && fromII.caseId != toII.caseId;
        var isLockedChange = toII.isLocked || fromII.isLocked || toParentII && toParentII.isLocked;
        if (maxNesting && newLev > maxNesting)
          return false;
        if (isStructChange && (!canRegroup || isForbiddenStructChange || isLockedChange))
          return false;
        if (fromII.type != "case_group" && fromII.caseId != toII.caseId) {
          var isLastFromCase = fromCaseII ? fromCaseII._height == 2 : false;
          var newRulesInTargetCase = toCaseII ? toCaseII.leafsCount + 1 : 0;
          if (maxNumberOfRules && newRulesInTargetCase > maxNumberOfRules)
            return false;
          if (isLastFromCase && !canLeaveEmptyCase)
            return false;
        }
        if (fromII.type == "case_group" && (fromII.isDefaultCase || toII.isDefaultCase || toII.type == "switch_group" && placement == PLACEMENT_APPEND)) {
          return false;
        }
        var res = true;
        if (canMoveFn) {
          res = canMoveFn(fromII.node.toJS(), toII.node.toJS(), placement, toParentII ? toParentII.node.toJS() : null);
        }
        return res;
      }
    }, {
      key: "move",
      value: function move(fromII, toII, placement, toParentII) {
        if (!this._isUsingLegacyReactDomRender) {
          _isReorderingTree = true;
        }
        this.props.actions.moveItem(fromII.path, toII.path, placement);
      }
    }, {
      key: "render",
      value: function render3() {
        return /* @__PURE__ */ React.createElement(Builder2, _extends$h({}, this.props, {
          onDragStart: this.onDragStart
        }));
      }
    }]);
    return SortableContainer2;
  }(reactExports.Component), _class.propTypes = {
    tree: PropTypes.any.isRequired,
    //instanceOf(Immutable.Map)
    actions: PropTypes.object.isRequired
    // {moveItem: Function, ..}
    //... see Builder
  }, _class;
};
const SortableContainer = function(Builder2) {
  var CanMoveFn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  var ConnectedSortableContainer = connect(function(state) {
    return {
      dragging: state.dragging,
      dragStart: state.dragStart,
      mousePos: state.mousePos
    };
  }, {
    setDragStart,
    setDragProgress,
    setDragEnd
  }, null, {
    context
  })(createSortableContainer(Builder2, CanMoveFn));
  ConnectedSortableContainer.displayName = "ConnectedSortableContainer";
  return ConnectedSortableContainer;
};
var _excluded$8 = ["isDraggingTempo", "isDraggingMe", "dragging"];
function _createSuper$n(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$n();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct$n() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
const Draggable = function(className) {
  return function(GroupOrRule) {
    var _class;
    return _class = /* @__PURE__ */ function(_PureComponent) {
      _inherits$b(Draggable2, _PureComponent);
      var _super = _createSuper$n(Draggable2);
      function Draggable2(props) {
        var _this;
        _classCallCheck$b(this, Draggable2);
        _this = _super.call(this, props);
        _this.handleDraggerMouseDown = function(e2) {
          var nodeId = _this.props.id;
          var dom = _this.wrapper.current;
          if (_this.props.onDragStart) {
            _this.props.onDragStart(nodeId, dom, e2);
          }
        };
        _this.wrapper = /* @__PURE__ */ React.createRef();
        return _this;
      }
      _createClass$9(Draggable2, [{
        key: "render",
        value: function render3() {
          var _this$props = this.props, isDraggingTempo = _this$props.isDraggingTempo, isDraggingMe = _this$props.isDraggingMe, dragging = _this$props.dragging, otherProps = _objectWithoutProperties$2(_this$props, _excluded$8);
          var isTrueLocked = otherProps.isTrueLocked;
          var styles2 = {};
          if (isDraggingMe && isDraggingTempo) {
            if (_isReorderingTree)
              ;
            else {
              styles2 = {
                top: dragging.y,
                left: dragging.x,
                width: dragging.w
              };
            }
          }
          var cn = classNames(className, "group-or-rule", isDraggingMe && isDraggingTempo ? "qb-draggable" : null, isDraggingMe && !isDraggingTempo ? "qb-placeholder" : null, isTrueLocked ? "locked" : null);
          return /* @__PURE__ */ React.createElement("div", {
            className: cn,
            style: styles2,
            ref: this.wrapper,
            "data-id": this.props.id
          }, /* @__PURE__ */ React.createElement(GroupOrRule, _extends$h({
            handleDraggerMouseDown: this.handleDraggerMouseDown,
            isDraggingMe,
            isDraggingTempo
          }, otherProps)));
        }
      }]);
      return Draggable2;
    }(reactExports.PureComponent), _class.propTypes = {
      isDraggingTempo: PropTypes.bool,
      isDraggingMe: PropTypes.bool,
      onDragStart: PropTypes.func,
      dragging: PropTypes.object,
      //{id, x, y, w, h}
      isLocked: PropTypes.bool,
      isTrueLocked: PropTypes.bool
    }, _class;
  };
};
var arrayMap = _arrayMap, baseIteratee = _baseIteratee, basePickBy = _basePickBy, getAllKeysIn = _getAllKeysIn;
function pickBy(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = arrayMap(getAllKeysIn(object), function(prop) {
    return [prop];
  });
  predicate = baseIteratee(predicate);
  return basePickBy(object, props, function(value, path) {
    return predicate(value, path[0]);
  });
}
var pickBy_1 = pickBy;
const pickBy$1 = /* @__PURE__ */ getDefaultExportFromCjs(pickBy_1);
function ownKeys$g(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$g(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$g(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$g(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper$m(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$m();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct$m() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var _Utils$ConfigUtils$4 = Utils$1.ConfigUtils, getFieldConfig$6 = _Utils$ConfigUtils$4.getFieldConfig, getOperatorConfig$3 = _Utils$ConfigUtils$4.getOperatorConfig;
var Operator = /* @__PURE__ */ function(_Component) {
  _inherits$b(Operator2, _Component);
  var _super = _createSuper$m(Operator2);
  function Operator2(props) {
    var _this;
    _classCallCheck$b(this, Operator2);
    _this = _super.call(this, props);
    useOnPropsChanged(_assertThisInitialized$1(_this));
    _this.onPropsChanged(props);
    return _this;
  }
  _createClass$9(Operator2, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var prevProps = this.props;
      var keysForMeta = ["config", "selectedField", "selectedOperator"];
      var needUpdateMeta = !this.meta || keysForMeta.map(function(k2) {
        return nextProps[k2] !== prevProps[k2];
      }).filter(function(ch) {
        return ch;
      }).length > 0;
      if (needUpdateMeta) {
        this.meta = this.getMeta(nextProps);
      }
    }
  }, {
    key: "getMeta",
    value: function getMeta(_ref) {
      var config2 = _ref.config, selectedField = _ref.selectedField, selectedOperator = _ref.selectedOperator;
      var fieldConfig = getFieldConfig$6(config2, selectedField);
      var operators2 = fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.operators;
      var operatorOptions = mapValues$1(pickBy$1(config2.operators, function(item, key) {
        return (operators2 === null || operators2 === void 0 ? void 0 : operators2.indexOf(key)) !== -1;
      }), function(_opts, op) {
        return getOperatorConfig$3(config2, op, selectedField);
      });
      var items = this.buildOptions(config2, operatorOptions, operators2);
      var isOpSelected = !!selectedOperator;
      var currOp = isOpSelected ? operatorOptions[selectedOperator] : null;
      var selectedOpts = currOp || {};
      var placeholder2 = this.props.config.settings.operatorPlaceholder;
      var selectedKey = selectedOperator;
      var selectedKeys = isOpSelected ? [selectedKey] : null;
      var selectedPath = selectedKeys;
      var selectedLabel = selectedOpts.label;
      return {
        placeholder: placeholder2,
        items,
        selectedKey,
        selectedKeys,
        selectedPath,
        selectedLabel,
        selectedOpts,
        fieldConfig
      };
    }
  }, {
    key: "buildOptions",
    value: function buildOptions3(config2, fields, ops) {
      if (!fields || !ops)
        return null;
      return keys$8(fields).sort(function(a2, b2) {
        return ops.indexOf(a2) - ops.indexOf(b2);
      }).map(function(fieldKey) {
        var field = fields[fieldKey];
        var label2 = field.label;
        return {
          key: fieldKey,
          path: fieldKey,
          label: label2
        };
      });
    }
  }, {
    key: "render",
    value: function render3() {
      var _this$props = this.props, config2 = _this$props.config, customProps = _this$props.customProps, setOperator4 = _this$props.setOperator, readonly = _this$props.readonly, id = _this$props.id, groupId = _this$props.groupId;
      var renderOperator3 = config2.settings.renderOperator;
      var renderProps = _objectSpread$g({
        id,
        groupId,
        config: config2,
        customProps,
        readonly,
        setField: setOperator4
      }, this.meta);
      if (!renderProps.items)
        return null;
      return renderOperator3(renderProps);
    }
  }]);
  return Operator2;
}(reactExports.Component);
Operator.propTypes = {
  id: PropTypes.string,
  groupId: PropTypes.string,
  config: PropTypes.object.isRequired,
  selectedField: PropTypes.string,
  selectedOperator: PropTypes.string,
  readonly: PropTypes.bool,
  //actions
  setOperator: PropTypes.func.isRequired
};
var _excluded$7 = ["children"];
var Col = function Col2(_ref) {
  var children = _ref.children, props = _objectWithoutProperties$2(_ref, _excluded$7);
  return /* @__PURE__ */ React.createElement("div", props, children);
};
var dummyFn = function dummyFn2() {
};
var DragIcon = function DragIcon2() {
  return /* @__PURE__ */ React.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "gray",
    width: "18px",
    height: "18px"
  }, /* @__PURE__ */ React.createElement("path", {
    d: "M0 0h24v24H0V0z",
    fill: "none"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"
  }));
};
var ConfirmFn = function ConfirmFn2(Cmp) {
  return function(props) {
    var useConfirm3 = props.config.settings.useConfirm;
    var confirmFn = useConfirm3 ? useConfirm3() : null;
    return /* @__PURE__ */ React.createElement(Cmp, _extends$h({}, props, {
      confirmFn
    }));
  };
};
function _createSuper$l(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$l();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct$l() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var OperatorWrapper = /* @__PURE__ */ function(_PureComponent) {
  _inherits$b(OperatorWrapper2, _PureComponent);
  var _super = _createSuper$l(OperatorWrapper2);
  function OperatorWrapper2() {
    _classCallCheck$b(this, OperatorWrapper2);
    return _super.apply(this, arguments);
  }
  _createClass$9(OperatorWrapper2, [{
    key: "render",
    value: function render3() {
      var _this$props = this.props, config2 = _this$props.config, selectedField = _this$props.selectedField, selectedOperator = _this$props.selectedOperator, setOperator4 = _this$props.setOperator, selectedFieldPartsLabels = _this$props.selectedFieldPartsLabels, showOperator = _this$props.showOperator, showOperatorLabel = _this$props.showOperatorLabel, selectedFieldWidgetConfig = _this$props.selectedFieldWidgetConfig, readonly = _this$props.readonly, id = _this$props.id, groupId = _this$props.groupId;
      var operator = showOperator && /* @__PURE__ */ React.createElement(Col, {
        key: "operators-for-" + (selectedFieldPartsLabels || []).join("_"),
        className: "rule--operator"
      }, config2.settings.showLabels && /* @__PURE__ */ React.createElement("label", {
        className: "rule--label"
      }, config2.settings.operatorLabel), /* @__PURE__ */ React.createElement(Operator, {
        key: "operator",
        config: config2,
        selectedField,
        selectedOperator,
        setOperator: setOperator4,
        readonly,
        id,
        groupId
      }));
      var hiddenOperator = showOperatorLabel && /* @__PURE__ */ React.createElement(Col, {
        key: "operators-for-" + (selectedFieldPartsLabels || []).join("_"),
        className: "rule--operator"
      }, /* @__PURE__ */ React.createElement("div", {
        className: "rule--operator-wrapper"
      }, config2.settings.showLabels ? /* @__PURE__ */ React.createElement("label", {
        className: "rule--label"
      }, " ") : null, /* @__PURE__ */ React.createElement("div", {
        className: "rule--operator-text-wrapper"
      }, /* @__PURE__ */ React.createElement("span", {
        className: "rule--operator-text"
      }, selectedFieldWidgetConfig.operatorInlineLabel))));
      return [operator, hiddenOperator];
    }
  }]);
  return OperatorWrapper2;
}(reactExports.PureComponent);
function ownKeys$f(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$f(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$f(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$f(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper$k(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$k();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct$k() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var _Utils$RuleUtils$3 = Utils$1.RuleUtils, getFieldPath$2 = _Utils$RuleUtils$3.getFieldPath, getFieldPathLabels$2 = _Utils$RuleUtils$3.getFieldPathLabels;
var getFieldConfig$5 = Utils$1.ConfigUtils.getFieldConfig;
var Field = /* @__PURE__ */ function(_Component) {
  _inherits$b(Field2, _Component);
  var _super = _createSuper$k(Field2);
  function Field2(props) {
    var _this;
    _classCallCheck$b(this, Field2);
    _this = _super.call(this, props);
    useOnPropsChanged(_assertThisInitialized$1(_this));
    _this.onPropsChanged(props);
    return _this;
  }
  _createClass$9(Field2, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var prevProps = this.props;
      var keysForMeta = ["selectedField", "config", "parentField"];
      var needUpdateMeta = !this.meta || keysForMeta.map(function(k2) {
        return nextProps[k2] !== prevProps[k2];
      }).filter(function(ch) {
        return ch;
      }).length > 0;
      if (needUpdateMeta) {
        this.meta = this.getMeta(nextProps);
      }
    }
  }, {
    key: "getMeta",
    value: function getMeta(_ref) {
      var selectedField = _ref.selectedField, config2 = _ref.config, parentField = _ref.parentField;
      var selectedKey = selectedField;
      var _config$settings = config2.settings, maxLabelsLength = _config$settings.maxLabelsLength, fieldSeparatorDisplay = _config$settings.fieldSeparatorDisplay, fieldPlaceholder = _config$settings.fieldPlaceholder, fieldSeparator = _config$settings.fieldSeparator;
      var isFieldSelected = !!selectedField;
      var placeholder2 = !isFieldSelected ? truncateString(fieldPlaceholder, maxLabelsLength) : null;
      var currField = isFieldSelected ? getFieldConfig$5(config2, selectedKey) : null;
      var selectedOpts = currField || {};
      var selectedKeys = getFieldPath$2(selectedKey, config2);
      var selectedPath = getFieldPath$2(selectedKey, config2, true);
      var selectedLabel = this.getFieldLabel(currField, selectedKey, config2);
      var partsLabels = getFieldPathLabels$2(selectedKey, config2);
      var selectedFullLabel = partsLabels ? partsLabels.join(fieldSeparatorDisplay) : null;
      if (selectedFullLabel == selectedLabel || parentField)
        selectedFullLabel = null;
      var selectedAltLabel = selectedOpts.label2;
      var parentFieldPath = typeof parentField == "string" ? parentField.split(fieldSeparator) : parentField;
      var parentFieldConfig = parentField ? getFieldConfig$5(config2, parentField) : null;
      var sourceFields = parentField ? parentFieldConfig && parentFieldConfig.subfields : config2.fields;
      var items = this.buildOptions(parentFieldPath, config2, sourceFields, parentFieldPath);
      return {
        placeholder: placeholder2,
        items,
        parentField,
        selectedKey,
        selectedKeys,
        selectedPath,
        selectedLabel,
        selectedOpts,
        selectedAltLabel,
        selectedFullLabel
      };
    }
  }, {
    key: "getFieldLabel",
    value: function getFieldLabel(fieldOpts, fieldKey, config2) {
      if (!fieldKey)
        return null;
      var fieldSeparator = config2.settings.fieldSeparator;
      var maxLabelsLength = config2.settings.maxLabelsLength;
      var fieldParts = Array.isArray(fieldKey) ? fieldKey : fieldKey.split(fieldSeparator);
      var label2 = fieldOpts && fieldOpts.label || last$2(fieldParts);
      label2 = truncateString(label2, maxLabelsLength);
      return label2;
    }
  }, {
    key: "buildOptions",
    value: function buildOptions3(parentFieldPath, config2, fields) {
      var _this2 = this;
      var path = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      var optGroupLabel = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
      if (!fields)
        return null;
      var _config$settings2 = config2.settings, fieldSeparator = _config$settings2.fieldSeparator, fieldSeparatorDisplay = _config$settings2.fieldSeparatorDisplay;
      var prefix = path ? path.join(fieldSeparator) + fieldSeparator : "";
      return keys$8(fields).map(function(fieldKey) {
        var field = fields[fieldKey];
        var label2 = _this2.getFieldLabel(field, fieldKey, config2);
        var partsLabels = getFieldPathLabels$2(prefix + fieldKey, config2);
        var fullLabel = partsLabels.join(fieldSeparatorDisplay);
        if (fullLabel == label2 || parentFieldPath)
          fullLabel = null;
        var altLabel = field.label2;
        var tooltip = field.tooltip;
        var subpath = (path ? path : []).concat(fieldKey);
        var disabled = field.disabled;
        if (field.hideForSelect)
          return void 0;
        if (field.type == "!struct") {
          return {
            disabled,
            key: fieldKey,
            path: prefix + fieldKey,
            label: label2,
            fullLabel,
            altLabel,
            tooltip,
            items: _this2.buildOptions(parentFieldPath, config2, field.subfields, subpath, label2)
          };
        } else {
          return {
            disabled,
            key: fieldKey,
            path: prefix + fieldKey,
            label: label2,
            fullLabel,
            altLabel,
            tooltip,
            grouplabel: optGroupLabel
          };
        }
      }).filter(function(o) {
        return !!o;
      });
    }
  }, {
    key: "render",
    value: function render3() {
      var _this$props = this.props, config2 = _this$props.config, customProps = _this$props.customProps, setField4 = _this$props.setField, readonly = _this$props.readonly, id = _this$props.id, groupId = _this$props.groupId;
      var renderField3 = config2.settings.renderField;
      var renderProps = _objectSpread$f({
        id,
        groupId,
        config: config2,
        customProps,
        readonly,
        setField: setField4
      }, this.meta);
      return renderField3(renderProps);
    }
  }]);
  return Field2;
}(reactExports.Component);
Field.propTypes = {
  id: PropTypes.string,
  groupId: PropTypes.string,
  config: PropTypes.object.isRequired,
  selectedField: PropTypes.string,
  parentField: PropTypes.string,
  customProps: PropTypes.object,
  readonly: PropTypes.bool,
  //actions
  setField: PropTypes.func.isRequired
};
function _createSuper$j(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$j();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct$j() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var FieldWrapper = /* @__PURE__ */ function(_PureComponent) {
  _inherits$b(FieldWrapper2, _PureComponent);
  var _super = _createSuper$j(FieldWrapper2);
  function FieldWrapper2() {
    _classCallCheck$b(this, FieldWrapper2);
    return _super.apply(this, arguments);
  }
  _createClass$9(FieldWrapper2, [{
    key: "render",
    value: function render3() {
      var _this$props = this.props, config2 = _this$props.config, selectedField = _this$props.selectedField, setField4 = _this$props.setField, parentField = _this$props.parentField, classname = _this$props.classname, readonly = _this$props.readonly, id = _this$props.id, groupId = _this$props.groupId;
      return /* @__PURE__ */ React.createElement(Col, {
        className: classname
      }, config2.settings.showLabels && /* @__PURE__ */ React.createElement("label", {
        className: "rule--label"
      }, config2.settings.fieldLabel), /* @__PURE__ */ React.createElement(Field, {
        config: config2,
        selectedField,
        parentField,
        setField: setField4,
        customProps: config2.settings.customFieldSelectProps,
        readonly,
        id,
        groupId
      }));
    }
  }]);
  return FieldWrapper2;
}(reactExports.PureComponent);
var nativeCeil = Math.ceil, nativeMax$1 = Math.max;
function baseRange$1(start2, end, step, fromRight) {
  var index2 = -1, length = nativeMax$1(nativeCeil((end - start2) / (step || 1)), 0), result = Array(length);
  while (length--) {
    result[fromRight ? length : ++index2] = start2;
    start2 += step;
  }
  return result;
}
var _baseRange = baseRange$1;
var reWhitespace = /\s/;
function trimmedEndIndex$1(string) {
  var index2 = string.length;
  while (index2-- && reWhitespace.test(string.charAt(index2))) {
  }
  return index2;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$1(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
var _baseTrim = baseTrim$1;
var baseTrim = _baseTrim, isObject$1 = isObject_1, isSymbol = isSymbol_1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$2(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject$1(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$1(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_1 = toNumber$2;
var toNumber$1 = toNumber_1;
var INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292;
function toFinite$2(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber$1(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign2 = value < 0 ? -1 : 1;
    return sign2 * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
var toFinite_1 = toFinite$2;
var baseRange = _baseRange, isIterateeCall = _isIterateeCall, toFinite$1 = toFinite_1;
function createRange$1(fromRight) {
  return function(start2, end, step) {
    if (step && typeof step != "number" && isIterateeCall(start2, end, step)) {
      end = step = void 0;
    }
    start2 = toFinite$1(start2);
    if (end === void 0) {
      end = start2;
      start2 = 0;
    } else {
      end = toFinite$1(end);
    }
    step = step === void 0 ? start2 < end ? 1 : -1 : toFinite$1(step);
    return baseRange(start2, end, step, fromRight);
  };
}
var _createRange = createRange$1;
var createRange = _createRange;
var range = createRange();
var range_1 = range;
const range$1 = /* @__PURE__ */ getDefaultExportFromCjs(range_1);
var _excluded$6 = ["factory"];
var getTitleInListValues2 = Utils$1.ListUtils.getTitleInListValues;
const WidgetFactory = function(_ref) {
  var delta = _ref.delta, isFuncArg = _ref.isFuncArg;
  _ref.valueSrc;
  var immValue = _ref.value, immValueError = _ref.valueError, asyncListValues = _ref.asyncListValues, isSpecialRange = _ref.isSpecialRange, fieldDefinition = _ref.fieldDefinition;
  _ref.widget;
  var widgetDefinition = _ref.widgetDefinition, widgetValueLabel = _ref.widgetValueLabel, valueLabels = _ref.valueLabels, textSeparators = _ref.textSeparators, setValueHandler = _ref.setValueHandler, config2 = _ref.config, field = _ref.field, operator = _ref.operator, readonly = _ref.readonly, parentField = _ref.parentField, parentFuncs = _ref.parentFuncs, id = _ref.id, groupId = _ref.groupId;
  var widgetFactory = widgetDefinition.factory, fieldWidgetProps = _objectWithoutProperties$2(widgetDefinition, _excluded$6);
  var isConst = isFuncArg && fieldDefinition.valueSources && fieldDefinition.valueSources.length == 1 && fieldDefinition.valueSources[0] == "const";
  var defaultValue4 = fieldDefinition.defaultValue;
  if (!widgetFactory) {
    return "?";
  }
  var value = isSpecialRange ? [immValue.get(0), immValue.get(1)] : immValue ? immValue.get(delta) : void 0;
  var valueError = immValueError && (isSpecialRange ? [immValueError.get(0), immValueError.get(1)] : immValueError.get(delta)) || null;
  if (isSpecialRange && value[0] === void 0 && value[1] === void 0)
    value = void 0;
  var _ref2 = fieldDefinition || {}, fieldSettings = _ref2.fieldSettings;
  var widgetProps = Object.assign({}, fieldWidgetProps, fieldSettings, {
    config: config2,
    field,
    parentField,
    parentFuncs,
    fieldDefinition,
    operator,
    delta,
    isSpecialRange,
    isFuncArg,
    value,
    valueError,
    label: widgetValueLabel.label,
    placeholder: widgetValueLabel.placeholder,
    placeholders: valueLabels ? valueLabels.placeholder : null,
    textSeparators,
    setValue: setValueHandler,
    readonly,
    asyncListValues,
    id,
    groupId
  });
  if (isConst && defaultValue4) {
    var listValues2 = fieldSettings.treeValues || fieldSettings.listValues;
    if (typeof defaultValue4 == "boolean") {
      return defaultValue4 ? widgetProps.labelYes || "YES" : widgetProps.labelNo || "NO";
    } else if (listValues2) {
      if (Array.isArray(defaultValue4))
        return defaultValue4.map(function(v2) {
          return getTitleInListValues2(listValues2, v2) || v2;
        }).join(", ");
      else
        return getTitleInListValues2(listValues2, defaultValue4) || defaultValue4;
    }
    return "" + defaultValue4;
  }
  return widgetFactory(widgetProps);
};
function _createSuper$i(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$i();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct$i() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var _Utils$ConfigUtils$3 = Utils$1.ConfigUtils, getFieldConfig$4 = _Utils$ConfigUtils$3.getFieldConfig, getOperatorConfig$2 = _Utils$ConfigUtils$3.getOperatorConfig, getFieldWidgetConfig$2 = _Utils$ConfigUtils$3.getFieldWidgetConfig;
var _Utils$RuleUtils$2 = Utils$1.RuleUtils, getValueSourcesForFieldOp2 = _Utils$RuleUtils$2.getValueSourcesForFieldOp, getWidgetsForFieldOp2 = _Utils$RuleUtils$2.getWidgetsForFieldOp, getWidgetForFieldOp$2 = _Utils$RuleUtils$2.getWidgetForFieldOp, getValueLabel2 = _Utils$RuleUtils$2.getValueLabel;
var createListFromArray$1 = Utils$1.DefaultUtils.createListFromArray;
var funcArgDummyOpDef = {
  cardinality: 1
};
var Widget = /* @__PURE__ */ function(_Component) {
  _inherits$b(Widget2, _Component);
  var _super = _createSuper$i(Widget2);
  function Widget2(_props) {
    var _this;
    _classCallCheck$b(this, Widget2);
    _this = _super.call(this, _props);
    _this._setValue = function(isSpecialRange, delta, widgetType, value, asyncListValues, __isInternal) {
      if (isSpecialRange && Array.isArray(value)) {
        var oldRange = [_this.props.value.get(0), _this.props.value.get(1)];
        if (oldRange[0] != value[0])
          _this.props.setValue(0, value[0], widgetType, asyncListValues, __isInternal);
        if (oldRange[1] != value[1])
          _this.props.setValue(1, value[1], widgetType, asyncListValues, __isInternal);
      } else {
        _this.props.setValue(delta, value, widgetType, asyncListValues, __isInternal);
      }
    };
    _this._onChangeValueSrc = function(delta, srcKey) {
      _this.props.setValueSrc(delta, srcKey);
    };
    _this.renderWidget = function(delta, meta, props) {
      var config2 = props.config, isFuncArg = props.isFuncArg, leftField = props.leftField, operator = props.operator, values = props.value, valueError = props.valueError, readonly = props.readonly, parentField = props.parentField, parentFuncs = props.parentFuncs, id = props.id, groupId = props.groupId;
      var settings2 = config2.settings;
      var widgets2 = meta.widgets, iValues = meta.iValues, aField = meta.aField;
      var value = isFuncArg ? iValues : values;
      var field = isFuncArg ? leftField : aField;
      var _widgets$delta = widgets2[delta], valueSrc = _widgets$delta.valueSrc, valueLabel = _widgets$delta.valueLabel;
      var widgetLabel = settings2.showLabels ? /* @__PURE__ */ React.createElement("label", {
        className: "rule--label"
      }, valueLabel.label) : null;
      return /* @__PURE__ */ React.createElement("div", {
        key: "widget-" + field + "-" + delta,
        className: "widget--widget"
      }, valueSrc == "func" ? null : widgetLabel, /* @__PURE__ */ React.createElement(WidgetFactory, _extends$h({
        id,
        groupId,
        valueSrc,
        delta,
        value,
        valueError,
        isFuncArg
      }, pick$1(meta, ["isSpecialRange", "fieldDefinition", "asyncListValues"]), pick$1(widgets2[delta], ["widget", "widgetDefinition", "widgetValueLabel", "valueLabels", "textSeparators", "setValueHandler"]), {
        config: config2,
        field,
        parentField,
        parentFuncs,
        operator,
        readonly
      })));
    };
    _this.renderValueSources = function(delta, meta, props) {
      var config2 = props.config, isFuncArg = props.isFuncArg, leftField = props.leftField, operator = props.operator, readonly = props.readonly;
      var settings2 = config2.settings;
      var valueSources = meta.valueSources, widgets2 = meta.widgets, aField = meta.aField;
      var field = isFuncArg ? leftField : aField;
      var _widgets$delta2 = widgets2[delta], valueSrc = _widgets$delta2.valueSrc, setValueSrcHandler = _widgets$delta2.setValueSrcHandler;
      var valueSourcesInfo = settings2.valueSourcesInfo, ValueSources = settings2.renderValueSources;
      var valueSourcesOptions = valueSources.map(function(srcKey) {
        return [srcKey, {
          label: valueSourcesInfo[srcKey].label
        }];
      });
      var sourceLabel = settings2.showLabels ? /* @__PURE__ */ React.createElement("label", {
        className: "rule--label"
      }, " ") : null;
      return valueSources.length > 1 && !readonly && /* @__PURE__ */ React.createElement("div", {
        key: "valuesrc-" + field + "-" + delta,
        className: "widget--valuesrc"
      }, sourceLabel, /* @__PURE__ */ React.createElement(ValueSources, {
        key: "valuesrc-" + delta,
        delta,
        valueSources: valueSourcesOptions,
        valueSrc,
        config: config2,
        field,
        operator,
        setValueSrc: setValueSrcHandler,
        readonly,
        title: settings2.valueSourcesPopupTitle
      }));
    };
    _this.renderSep = function(delta, meta, props) {
      var config2 = props.config;
      var widgets2 = meta.widgets;
      var settings2 = config2.settings;
      var sepText = widgets2[delta].sepText;
      var sepLabel = settings2.showLabels ? /* @__PURE__ */ React.createElement("label", {
        className: "rule--label"
      }, " ") : null;
      return sepText && /* @__PURE__ */ React.createElement("div", {
        key: "widget-separators-" + delta,
        className: "widget--sep"
      }, sepLabel, /* @__PURE__ */ React.createElement("span", null, sepText));
    };
    _this.renderWidgetDelta = function(delta) {
      var sep = _this.renderSep(delta, _this.meta, _this.props);
      var sources = _this.renderValueSources(delta, _this.meta, _this.props);
      var widgetCmp = _this.renderWidget(delta, _this.meta, _this.props);
      return [sep, sources, widgetCmp];
    };
    useOnPropsChanged(_assertThisInitialized$1(_this));
    _this.onPropsChanged(_props);
    return _this;
  }
  _createClass$9(Widget2, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var prevProps = this.props;
      var keysForMeta = ["config", "field", "fieldFunc", "fieldArg", "leftField", "operator", "valueSrc", "isFuncArg", "asyncListValues"];
      var needUpdateMeta = !this.meta || keysForMeta.map(function(k2) {
        return nextProps[k2] !== prevProps[k2] || k2 == "isFuncArg" && nextProps["isFuncArg"] && nextProps["value"] !== prevProps["value"];
      }).filter(function(ch) {
        return ch;
      }).length > 0;
      if (needUpdateMeta) {
        this.meta = this.getMeta(nextProps);
      }
    }
  }, {
    key: "getMeta",
    value: function getMeta(_ref) {
      var _this2 = this;
      var config2 = _ref.config, simpleField = _ref.field, fieldFunc = _ref.fieldFunc, fieldArg = _ref.fieldArg, operator = _ref.operator, valueSrcs = _ref.valueSrc, values = _ref.value, isForRuleGruop = _ref.isForRuleGruop, isCaseValue = _ref.isCaseValue, isFuncArg = _ref.isFuncArg, leftField = _ref.leftField, asyncListValues = _ref.asyncListValues;
      var field = isFuncArg ? {
        func: fieldFunc,
        arg: fieldArg
      } : simpleField;
      var iValueSrcs = valueSrcs;
      var iValues = values;
      if (isFuncArg || isForRuleGruop || isCaseValue) {
        iValueSrcs = createListFromArray$1([valueSrcs]);
        iValues = createListFromArray$1([values]);
      }
      var fieldDefinition = getFieldConfig$4(config2, field);
      var defaultWidget = getWidgetForFieldOp$2(config2, field, operator);
      getWidgetsForFieldOp2(config2, field, operator);
      var operatorDefinition = isFuncArg ? funcArgDummyOpDef : getOperatorConfig$2(config2, operator, field);
      if ((fieldDefinition == null || operatorDefinition == null) && !isCaseValue) {
        return null;
      }
      var isSpecialRange = operatorDefinition === null || operatorDefinition === void 0 ? void 0 : operatorDefinition.isSpecialRange;
      var isSpecialRangeForSrcField = isSpecialRange && (iValueSrcs.get(0) == "field" || iValueSrcs.get(1) == "field");
      var isTrueSpecialRange = isSpecialRange && !isSpecialRangeForSrcField;
      var cardinality = isTrueSpecialRange ? 1 : defaultValue2(operatorDefinition === null || operatorDefinition === void 0 ? void 0 : operatorDefinition.cardinality, 1);
      if (cardinality === 0) {
        return null;
      }
      var valueSources = getValueSourcesForFieldOp2(config2, field, operator, fieldDefinition, isFuncArg ? leftField : null);
      var widgets2 = range$1(0, cardinality).map(function(delta) {
        var _widgetDefinition;
        var valueSrc = iValueSrcs.get(delta) || null;
        var widget = getWidgetForFieldOp$2(config2, field, operator, valueSrc);
        var widgetDefinition = getFieldWidgetConfig$2(config2, field, operator, widget, valueSrc);
        if (isSpecialRangeForSrcField) {
          widget = widgetDefinition.singleWidget;
          widgetDefinition = getFieldWidgetConfig$2(config2, field, operator, widget, valueSrc);
        }
        var widgetType = (_widgetDefinition = widgetDefinition) === null || _widgetDefinition === void 0 ? void 0 : _widgetDefinition.type;
        var valueLabel = getValueLabel2(config2, field, operator, delta, valueSrc, isTrueSpecialRange);
        var widgetValueLabel = getValueLabel2(config2, field, operator, delta, null, isTrueSpecialRange);
        var sepText = operatorDefinition !== null && operatorDefinition !== void 0 && operatorDefinition.textSeparators ? operatorDefinition === null || operatorDefinition === void 0 ? void 0 : operatorDefinition.textSeparators[delta] : null;
        var setValueSrcHandler = _this2._onChangeValueSrc.bind(_this2, delta);
        var valueLabels = null;
        var textSeparators = null;
        if (isSpecialRange) {
          valueLabels = [getValueLabel2(config2, field, operator, 0), getValueLabel2(config2, field, operator, 1)];
          valueLabels = {
            placeholder: [valueLabels[0].placeholder, valueLabels[1].placeholder],
            label: [valueLabels[0].label, valueLabels[1].label]
          };
          textSeparators = operatorDefinition === null || operatorDefinition === void 0 ? void 0 : operatorDefinition.textSeparators;
        }
        var setValueHandler = _this2._setValue.bind(_this2, isSpecialRange, delta, widgetType);
        return {
          valueSrc,
          valueLabel,
          widget,
          sepText,
          setValueSrcHandler,
          widgetDefinition,
          widgetValueLabel,
          valueLabels,
          textSeparators,
          setValueHandler
        };
      });
      return {
        defaultWidget,
        fieldDefinition,
        operatorDefinition,
        isSpecialRange: isTrueSpecialRange,
        cardinality,
        valueSources,
        widgets: widgets2,
        iValues,
        //correct for isFuncArg
        aField: field,
        //correct for isFuncArg
        asyncListValues
      };
    }
  }, {
    key: "render",
    value: function render3() {
      if (!this.meta)
        return null;
      var _this$meta = this.meta, defaultWidget = _this$meta.defaultWidget, cardinality = _this$meta.cardinality;
      if (!defaultWidget)
        return null;
      var name = defaultWidget;
      return /* @__PURE__ */ React.createElement(Col, {
        className: "rule--widget rule--widget--".concat(name.toUpperCase()),
        key: "widget-col-" + name
      }, range$1(0, cardinality).map(this.renderWidgetDelta));
    }
  }]);
  return Widget2;
}(reactExports.Component);
Widget.propTypes = {
  config: PropTypes.object.isRequired,
  value: PropTypes.any,
  //instanceOf(Immutable.List)
  valueSrc: PropTypes.any,
  //instanceOf(Immutable.List)
  valueError: PropTypes.any,
  field: PropTypes.string,
  operator: PropTypes.string,
  readonly: PropTypes.bool,
  asyncListValues: PropTypes.array,
  id: PropTypes.string,
  groupId: PropTypes.string,
  //actions
  setValue: PropTypes.func,
  setValueSrc: PropTypes.func,
  // for isFuncArg
  isFuncArg: PropTypes.bool,
  fieldFunc: PropTypes.string,
  fieldArg: PropTypes.string,
  leftField: PropTypes.string,
  // for RuleGroupExt
  isForRuleGruop: PropTypes.bool,
  parentField: PropTypes.string,
  // for func in func
  parentFuncs: PropTypes.array,
  // for case_value
  isCaseValue: PropTypes.bool
};
var _excluded$5 = ["factory"];
function _createSuper$h(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$h();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct$h() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var getOperatorConfig$1 = Utils$1.ConfigUtils.getOperatorConfig;
var OperatorOptions = /* @__PURE__ */ function(_PureComponent) {
  _inherits$b(OperatorOptions2, _PureComponent);
  var _super = _createSuper$h(OperatorOptions2);
  function OperatorOptions2() {
    _classCallCheck$b(this, OperatorOptions2);
    return _super.apply(this, arguments);
  }
  _createClass$9(OperatorOptions2, [{
    key: "render",
    value: function render3() {
      if (!this.props.selectedOperator)
        return null;
      var operatorDefinitions = getOperatorConfig$1(this.props.config, this.props.selectedOperator, this.props.selectedField);
      if (typeof operatorDefinitions.options === "undefined") {
        return null;
      }
      var _operatorDefinitions$ = operatorDefinitions.options, optionsFactory = _operatorDefinitions$.factory, basicOptionsProps = _objectWithoutProperties$2(_operatorDefinitions$, _excluded$5);
      var optionsProps = Object.assign({}, basicOptionsProps, {
        config: this.props.config,
        field: this.props.selectedField,
        operator: this.props.selectedOperator,
        options: this.props.operatorOptions,
        setOption: this.props.setOperatorOption,
        readonly: this.props.readonly
      });
      var optionsCmp = optionsFactory(optionsProps);
      var name = this.props.selectedOperator;
      return /* @__PURE__ */ React.createElement("div", {
        className: "rule--operator rule--operator--".concat(name.toUpperCase())
      }, optionsCmp);
    }
  }]);
  return OperatorOptions2;
}(reactExports.PureComponent);
OperatorOptions.propTypes = {
  config: PropTypes.object.isRequired,
  operatorOptions: PropTypes.any.isRequired,
  //instanceOf(Immutable.Map)
  selectedField: PropTypes.string.isRequired,
  selectedOperator: PropTypes.string.isRequired,
  readonly: PropTypes.bool,
  //actions
  setOperatorOption: PropTypes.func.isRequired
};
function ownKeys$e(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$e(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$e(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$e(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper$g(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$g();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct$g() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var _Utils$ConfigUtils$2 = Utils$1.ConfigUtils, getFieldConfig$3 = _Utils$ConfigUtils$2.getFieldConfig, getOperatorConfig2 = _Utils$ConfigUtils$2.getOperatorConfig, getFieldWidgetConfig$1 = _Utils$ConfigUtils$2.getFieldWidgetConfig;
var getFieldPathLabels$1 = Utils$1.RuleUtils.getFieldPathLabels;
var Rule = /* @__PURE__ */ function(_Component) {
  _inherits$b(Rule2, _Component);
  var _super = _createSuper$g(Rule2);
  function Rule2(props) {
    var _this;
    _classCallCheck$b(this, Rule2);
    _this = _super.call(this, props);
    useOnPropsChanged(_assertThisInitialized$1(_this));
    _this.removeSelf = _this.removeSelf.bind(_assertThisInitialized$1(_this));
    _this.setLock = _this.setLock.bind(_assertThisInitialized$1(_this));
    _this.onPropsChanged(props);
    return _this;
  }
  _createClass$9(Rule2, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var prevProps = this.props;
      var keysForMeta = ["selectedField", "selectedOperator", "config", "reordableNodesCnt", "isLocked"];
      var needUpdateMeta = !this.meta || keysForMeta.map(function(k2) {
        return nextProps[k2] !== prevProps[k2];
      }).filter(function(ch) {
        return ch;
      }).length > 0;
      if (needUpdateMeta) {
        this.meta = this.getMeta(nextProps);
      }
    }
  }, {
    key: "getMeta",
    value: function getMeta(_ref) {
      var selectedField = _ref.selectedField, selectedOperator = _ref.selectedOperator, config2 = _ref.config, reordableNodesCnt = _ref.reordableNodesCnt, isLocked = _ref.isLocked;
      var selectedFieldPartsLabels = getFieldPathLabels$1(selectedField, config2);
      var selectedFieldConfig = getFieldConfig$3(config2, selectedField);
      var isSelectedGroup = selectedFieldConfig && selectedFieldConfig.type == "!struct";
      var isFieldAndOpSelected = selectedField && selectedOperator && !isSelectedGroup;
      var selectedOperatorConfig = getOperatorConfig2(config2, selectedOperator, selectedField);
      var selectedOperatorHasOptions = selectedOperatorConfig && selectedOperatorConfig.options != null;
      var selectedFieldWidgetConfig = getFieldWidgetConfig$1(config2, selectedField, selectedOperator) || {};
      var hideOperator = selectedFieldWidgetConfig.hideOperator;
      var showDragIcon = config2.settings.canReorder && reordableNodesCnt > 1 && !isLocked;
      var showOperator = selectedField && !hideOperator;
      var showOperatorLabel = selectedField && hideOperator && selectedFieldWidgetConfig.operatorInlineLabel;
      var showWidget = isFieldAndOpSelected;
      var showOperatorOptions = isFieldAndOpSelected && selectedOperatorHasOptions;
      return {
        selectedFieldPartsLabels,
        selectedFieldWidgetConfig,
        showDragIcon,
        showOperator,
        showOperatorLabel,
        showWidget,
        showOperatorOptions
      };
    }
  }, {
    key: "setLock",
    value: function setLock4(lock) {
      this.props.setLock(lock);
    }
  }, {
    key: "removeSelf",
    value: function removeSelf() {
      var _this2 = this;
      var confirmFn = this.props.confirmFn;
      var _this$props$config$se = this.props.config.settings, renderConfirm = _this$props$config$se.renderConfirm, confirmOptions = _this$props$config$se.removeRuleConfirmOptions;
      var doRemove = function doRemove2() {
        _this2.props.removeSelf();
      };
      if (confirmOptions && !this.isEmptyCurrentRule()) {
        renderConfirm(_objectSpread$e(_objectSpread$e({}, confirmOptions), {}, {
          onOk: doRemove,
          onCancel: null,
          confirmFn
        }));
      } else {
        doRemove();
      }
    }
  }, {
    key: "isEmptyCurrentRule",
    value: function isEmptyCurrentRule() {
      return !(this.props.selectedField !== null && this.props.selectedOperator !== null && this.props.value.filter(function(val) {
        return val !== void 0;
      }).size > 0);
    }
  }, {
    key: "renderField",
    value: function renderField3() {
      var _this$props = this.props, config2 = _this$props.config, isLocked = _this$props.isLocked;
      var immutableFieldsMode = config2.settings.immutableFieldsMode;
      return /* @__PURE__ */ React.createElement(FieldWrapper, {
        key: "field",
        classname: "rule--field",
        config: config2,
        selectedField: this.props.selectedField,
        setField: !immutableFieldsMode ? this.props.setField : dummyFn,
        parentField: this.props.parentField,
        readonly: immutableFieldsMode || isLocked,
        id: this.props.id,
        groupId: this.props.groupId
      });
    }
  }, {
    key: "renderOperator",
    value: function renderOperator3() {
      var _this$props2 = this.props, config2 = _this$props2.config, isLocked = _this$props2.isLocked;
      var _this$meta = this.meta, selectedFieldPartsLabels = _this$meta.selectedFieldPartsLabels, selectedFieldWidgetConfig = _this$meta.selectedFieldWidgetConfig, showOperator = _this$meta.showOperator, showOperatorLabel = _this$meta.showOperatorLabel;
      var immutableOpsMode = config2.settings.immutableOpsMode;
      return /* @__PURE__ */ React.createElement(OperatorWrapper, {
        key: "operator",
        config: config2,
        selectedField: this.props.selectedField,
        selectedOperator: this.props.selectedOperator,
        setOperator: !immutableOpsMode ? this.props.setOperator : dummyFn,
        selectedFieldPartsLabels,
        showOperator,
        showOperatorLabel,
        selectedFieldWidgetConfig,
        readonly: immutableOpsMode || isLocked,
        id: this.props.id,
        groupId: this.props.groupId
      });
    }
  }, {
    key: "renderWidget",
    value: function renderWidget() {
      var _this$props3 = this.props, config2 = _this$props3.config, valueError = _this$props3.valueError, isLocked = _this$props3.isLocked;
      var showWidget = this.meta.showWidget;
      var immutableValuesMode = config2.settings.immutableValuesMode;
      if (!showWidget)
        return null;
      var widget = /* @__PURE__ */ React.createElement(Widget, {
        key: "values",
        field: this.props.selectedField,
        parentField: this.props.parentField,
        operator: this.props.selectedOperator,
        value: this.props.value,
        valueSrc: this.props.valueSrc,
        asyncListValues: this.props.asyncListValues,
        valueError,
        config: config2,
        setValue: !immutableValuesMode ? this.props.setValue : dummyFn,
        setValueSrc: !immutableValuesMode ? this.props.setValueSrc : dummyFn,
        readonly: immutableValuesMode || isLocked,
        id: this.props.id,
        groupId: this.props.groupId
      });
      return /* @__PURE__ */ React.createElement(Col, {
        key: "widget-for-" + this.props.selectedOperator,
        className: "rule--value"
      }, widget);
    }
  }, {
    key: "renderOperatorOptions",
    value: function renderOperatorOptions() {
      var config2 = this.props.config;
      var showOperatorOptions = this.meta.showOperatorOptions;
      var _config$settings = config2.settings, immutableOpsMode = _config$settings.immutableOpsMode, immutableValuesMode = _config$settings.immutableValuesMode;
      if (!showOperatorOptions)
        return null;
      var opOpts = /* @__PURE__ */ React.createElement(OperatorOptions, {
        key: "operatorOptions",
        selectedField: this.props.selectedField,
        selectedOperator: this.props.selectedOperator,
        operatorOptions: this.props.operatorOptions,
        setOperatorOption: !immutableOpsMode ? this.props.setOperatorOption : dummyFn,
        config: config2,
        readonly: immutableValuesMode
      });
      return /* @__PURE__ */ React.createElement(Col, {
        key: "op-options-for-" + this.props.selectedOperator,
        className: "rule--operator-options"
      }, opOpts);
    }
  }, {
    key: "renderBeforeWidget",
    value: function renderBeforeWidget() {
      var config2 = this.props.config;
      var renderBeforeWidget2 = config2.settings.renderBeforeWidget;
      return renderBeforeWidget2 && /* @__PURE__ */ React.createElement(Col, {
        key: "before-widget-for-" + this.props.selectedOperator,
        className: "rule--before-widget"
      }, typeof renderBeforeWidget2 === "function" ? renderBeforeWidget2(this.props) : renderBeforeWidget2);
    }
  }, {
    key: "renderAfterWidget",
    value: function renderAfterWidget() {
      var config2 = this.props.config;
      var renderAfterWidget2 = config2.settings.renderAfterWidget;
      return renderAfterWidget2 && /* @__PURE__ */ React.createElement(Col, {
        key: "after-widget-for-" + this.props.selectedOperator,
        className: "rule--after-widget"
      }, typeof renderAfterWidget2 === "function" ? renderAfterWidget2(this.props) : renderAfterWidget2);
    }
  }, {
    key: "renderError",
    value: function renderError() {
      var _this$props4 = this.props, config2 = _this$props4.config, valueError = _this$props4.valueError;
      var _config$settings2 = config2.settings, renderRuleError = _config$settings2.renderRuleError, showErrorMessage = _config$settings2.showErrorMessage;
      var oneValueError = valueError && valueError.toArray().filter(function(e2) {
        return !!e2;
      }).shift() || null;
      return showErrorMessage && oneValueError && /* @__PURE__ */ React.createElement("div", {
        className: "rule--error"
      }, renderRuleError ? renderRuleError({
        error: oneValueError
      }) : oneValueError);
    }
  }, {
    key: "renderDrag",
    value: function renderDrag() {
      var showDragIcon = this.meta.showDragIcon;
      return showDragIcon && /* @__PURE__ */ React.createElement("span", {
        key: "rule-drag-icon",
        className: "qb-drag-handler rule--drag-handler",
        onMouseDown: this.props.handleDraggerMouseDown
      }, /* @__PURE__ */ React.createElement(DragIcon, null), " ");
    }
  }, {
    key: "renderDel",
    value: function renderDel() {
      var _this$props5 = this.props, config2 = _this$props5.config, isLocked = _this$props5.isLocked;
      var _config$settings3 = config2.settings, deleteLabel = _config$settings3.deleteLabel, immutableGroupsMode = _config$settings3.immutableGroupsMode, Btn = _config$settings3.renderButton, canDeleteLocked = _config$settings3.canDeleteLocked;
      return !immutableGroupsMode && (!isLocked || isLocked && canDeleteLocked) && /* @__PURE__ */ React.createElement(Btn, {
        type: "delRule",
        onClick: this.removeSelf,
        label: deleteLabel,
        config: config2
      });
    }
  }, {
    key: "renderLock",
    value: function renderLock() {
      var _this$props6 = this.props, config2 = _this$props6.config, isLocked = _this$props6.isLocked, isTrueLocked = _this$props6.isTrueLocked, id = _this$props6.id;
      var _config$settings4 = config2.settings, lockLabel = _config$settings4.lockLabel, lockedLabel = _config$settings4.lockedLabel, showLock = _config$settings4.showLock, Switch2 = _config$settings4.renderSwitch;
      return showLock && !(isLocked && !isTrueLocked) && /* @__PURE__ */ React.createElement(Switch2, {
        type: "lock",
        id,
        value: isLocked,
        setValue: this.setLock,
        label: lockLabel,
        checkedLabel: lockedLabel,
        hideLabel: true,
        config: config2
      });
    }
  }, {
    key: "render",
    value: function render3() {
      var _this$meta2 = this.meta, showOperatorOptions = _this$meta2.showOperatorOptions, selectedFieldWidgetConfig = _this$meta2.selectedFieldWidgetConfig;
      var _this$props7 = this.props, valueSrc = _this$props7.valueSrc, value = _this$props7.value, config2 = _this$props7.config;
      var canShrinkValue = valueSrc.first() == "value" && !showOperatorOptions && value.size == 1 && selectedFieldWidgetConfig.fullWidth;
      var BtnGrp = config2.settings.renderButtonGroup;
      var parts = [this.renderField(), this.renderOperator(), this.renderBeforeWidget(), this.renderWidget(), this.renderAfterWidget(), this.renderOperatorOptions()];
      var body = /* @__PURE__ */ React.createElement("div", {
        key: "rule-body",
        className: classNames("rule--body", canShrinkValue && "can--shrink--value")
      }, parts);
      var error2 = this.renderError();
      var drag = this.renderDrag();
      var lock = this.renderLock();
      var del = this.renderDel();
      return /* @__PURE__ */ React.createElement(React.Fragment, null, drag, /* @__PURE__ */ React.createElement("div", {
        className: "rule--body--wrapper"
      }, body, error2), /* @__PURE__ */ React.createElement("div", {
        className: "rule--header"
      }, /* @__PURE__ */ React.createElement(BtnGrp, {
        config: config2
      }, lock, del)));
    }
  }]);
  return Rule2;
}(reactExports.Component);
Rule.propTypes = {
  id: PropTypes.string.isRequired,
  groupId: PropTypes.string,
  selectedField: PropTypes.string,
  selectedOperator: PropTypes.string,
  operatorOptions: PropTypes.object,
  config: PropTypes.object.isRequired,
  value: PropTypes.any,
  //depends on widget
  valueSrc: PropTypes.any,
  asyncListValues: PropTypes.array,
  isDraggingMe: PropTypes.bool,
  isDraggingTempo: PropTypes.bool,
  parentField: PropTypes.string,
  //from RuleGroup
  valueError: PropTypes.any,
  isLocked: PropTypes.bool,
  isTrueLocked: PropTypes.bool,
  //path: PropTypes.instanceOf(Immutable.List),
  //actions
  handleDraggerMouseDown: PropTypes.func,
  setField: PropTypes.func,
  setOperator: PropTypes.func,
  setOperatorOption: PropTypes.func,
  setLock: PropTypes.func,
  removeSelf: PropTypes.func,
  setValue: PropTypes.func,
  setValueSrc: PropTypes.func,
  reordableNodesCnt: PropTypes.number,
  totalRulesCnt: PropTypes.number,
  parentReordableNodesCnt: PropTypes.number
};
const Rule$1 = RuleContainer(Draggable("rule")(ConfirmFn(Rule)));
function baseClamp$1(number, lower, upper) {
  if (number === number) {
    if (upper !== void 0) {
      number = number <= upper ? number : upper;
    }
    if (lower !== void 0) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}
var _baseClamp = baseClamp$1;
var toFinite = toFinite_1;
function toInteger$1(value) {
  var result = toFinite(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
var toInteger_1 = toInteger$1;
var baseClamp = _baseClamp, baseToString = _baseToString, toInteger = toInteger_1, toString2 = toString_1;
function startsWith(string, target, position) {
  string = toString2(string);
  position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
  target = baseToString(target);
  return string.slice(position, position + target.length) == target;
}
var startsWith_1 = startsWith;
const startsWith$1 = /* @__PURE__ */ getDefaultExportFromCjs(startsWith_1);
function _createSuper$f(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$f();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct$f() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var defaultGroupConjunction2 = Utils$1.DefaultUtils.defaultGroupConjunction;
var createGroupContainer = function createGroupContainer2(Group2) {
  var _class;
  return _class = /* @__PURE__ */ function(_Component) {
    _inherits$b(GroupContainer2, _Component);
    var _super = _createSuper$f(GroupContainer2);
    function GroupContainer2(_props) {
      var _this;
      _classCallCheck$b(this, GroupContainer2);
      _this = _super.call(this, _props);
      _this._selectedConjunction = function(props) {
        props = props || _this.props;
        return props.conjunction || defaultGroupConjunction2(props.config, props.field);
      };
      _this.setConjunction = function() {
        var conj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        _this.props.actions.setConjunction(_this.props.path, conj);
      };
      _this.setNot = function() {
        var not = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        _this.props.actions.setNot(_this.props.path, not);
      };
      _this.setLock = function() {
        var lock = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        _this.props.actions.setLock(_this.props.path, lock);
      };
      _this.dummyFn = function() {
      };
      _this.removeSelf = function() {
        _this.props.actions.removeGroup(_this.props.path);
      };
      _this.addGroup = function() {
        _this.props.actions.addGroup(_this.props.path);
      };
      _this.addCaseGroup = function() {
        _this.props.actions.addCaseGroup(_this.props.path);
      };
      _this.addDefaultCaseGroup = function() {
        _this.props.actions.addDefaultCaseGroup(_this.props.path);
      };
      _this.addRule = function() {
        _this.props.actions.addRule(_this.props.path);
      };
      _this.setField = function(field) {
        _this.props.actions.setField(_this.props.path, field);
      };
      _this.setOperator = function(operator) {
        _this.props.actions.setOperator(_this.props.path, operator);
      };
      _this.setValue = function(delta, value, type2) {
        _this.props.actions.setValue(_this.props.path, delta, value, type2);
      };
      _this.pureShouldComponentUpdate = pureShouldComponentUpdate(_assertThisInitialized$1(_this));
      useOnPropsChanged(_assertThisInitialized$1(_this));
      _this.selectedConjunction = _this._selectedConjunction(_props);
      _this.conjunctionOptions = _this._getConjunctionOptions(_props);
      _this.dummyFn.isDummyFn = true;
      return _this;
    }
    _createClass$9(GroupContainer2, [{
      key: "shouldComponentUpdate",
      value: function shouldComponentUpdate(nextProps, nextState) {
        var prevProps = this.props;
        var prevState = this.state;
        var should = this.pureShouldComponentUpdate(nextProps, nextState);
        if (should) {
          if (prevState == nextState && prevProps != nextProps) {
            var draggingId = nextProps.dragging.id || prevProps.dragging.id;
            var isDraggingMe = draggingId == nextProps.id;
            var chs = [];
            for (var k2 in nextProps) {
              var changed = nextProps[k2] != prevProps[k2];
              if (k2 == "dragging" && !isDraggingMe) {
                changed = false;
              }
              if (changed) {
                chs.push(k2);
              }
            }
            if (!chs.length)
              should = false;
          }
        }
        return should;
      }
    }, {
      key: "onPropsChanged",
      value: function onPropsChanged(nextProps) {
        var config2 = nextProps.config;
        nextProps.id;
        var conjunction = nextProps.conjunction;
        var oldConfig = this.props.config;
        var oldConjunction = this.props.conjunction;
        if (oldConfig != config2 || oldConjunction != conjunction) {
          this.selectedConjunction = this._selectedConjunction(nextProps);
          this.conjunctionOptions = this._getConjunctionOptions(nextProps);
        }
      }
    }, {
      key: "_getConjunctionOptions",
      value: function _getConjunctionOptions(props) {
        var _this2 = this;
        return mapValues$1(props.config.conjunctions, function(item, index2) {
          return {
            id: "conjunction-".concat(props.id, "-").concat(index2),
            name: "conjunction[".concat(props.id, "]"),
            key: index2,
            label: item.label,
            checked: index2 === _this2._selectedConjunction(props)
          };
        });
      }
    }, {
      key: "render",
      value: function render3() {
        var isDraggingMe = this.props.dragging.id == this.props.id;
        var currentNesting = this.props.path.size;
        var maxNesting = this.props.config.settings.maxNesting;
        var isInDraggingTempo = !isDraggingMe && this.props.isDraggingTempo;
        var allowFurtherNesting = typeof maxNesting === "undefined" || currentNesting < maxNesting;
        var isRoot = currentNesting == 1;
        return /* @__PURE__ */ React.createElement("div", {
          className: "group-or-rule-container group-container",
          "data-id": this.props.id
        }, [isDraggingMe ? /* @__PURE__ */ React.createElement(Group2, {
          key: "dragging",
          id: this.props.id,
          groupId: this.props.groupId,
          isDraggingMe: true,
          isDraggingTempo: true,
          dragging: this.props.dragging,
          isRoot,
          allowFurtherNesting,
          conjunctionOptions: this.conjunctionOptions,
          not: this.props.not,
          selectedConjunction: this.selectedConjunction,
          setConjunction: this.dummyFn,
          setNot: this.dummyFn,
          setLock: this.dummyFn,
          removeSelf: this.dummyFn,
          addGroup: this.dummyFn,
          addCaseGroup: this.dummyFn,
          addDefaultCaseGroup: this.dummyFn,
          addRule: this.dummyFn,
          setField: this.dummyFn,
          setOperator: this.dummyFn,
          setValue: this.dummyFn,
          value: this.props.value || null,
          config: this.props.config,
          children1: this.props.children1,
          actions: this.props.actions,
          reordableNodesCnt: this.props.reordableNodesCnt,
          totalRulesCnt: this.props.totalRulesCnt,
          selectedField: this.props.field || null,
          parentField: this.props.parentField || null,
          selectedOperator: this.props.operator || null,
          isLocked: this.props.isLocked,
          isTrueLocked: this.props.isTrueLocked,
          parentReordableNodesCnt: this.props.parentReordableNodesCnt
        }) : null, /* @__PURE__ */ React.createElement(Group2, {
          key: this.props.id,
          id: this.props.id,
          groupId: this.props.groupId,
          isDraggingMe,
          isDraggingTempo: isInDraggingTempo,
          onDragStart: this.props.onDragStart,
          isRoot,
          allowFurtherNesting,
          conjunctionOptions: this.conjunctionOptions,
          not: this.props.not,
          selectedConjunction: this.selectedConjunction,
          setConjunction: isInDraggingTempo ? this.dummyFn : this.setConjunction,
          setNot: isInDraggingTempo ? this.dummyFn : this.setNot,
          setLock: isInDraggingTempo ? this.dummyFn : this.setLock,
          removeSelf: isInDraggingTempo ? this.dummyFn : this.removeSelf,
          addGroup: isInDraggingTempo ? this.dummyFn : this.addGroup,
          addCaseGroup: isInDraggingTempo ? this.dummyFn : this.addCaseGroup,
          addDefaultCaseGroup: isInDraggingTempo ? this.dummyFn : this.addDefaultCaseGroup,
          addRule: isInDraggingTempo ? this.dummyFn : this.addRule,
          setField: isInDraggingTempo ? this.dummyFn : this.setField,
          setOperator: isInDraggingTempo ? this.dummyFn : this.setOperator,
          setValue: isInDraggingTempo ? this.dummyFn : this.setValue,
          value: this.props.value || null,
          config: this.props.config,
          children1: this.props.children1,
          actions: this.props.actions,
          reordableNodesCnt: this.props.reordableNodesCnt,
          totalRulesCnt: this.props.totalRulesCnt,
          selectedField: this.props.field || null,
          parentField: this.props.parentField || null,
          selectedOperator: this.props.operator || null,
          isLocked: this.props.isLocked,
          isTrueLocked: this.props.isTrueLocked,
          parentReordableNodesCnt: this.props.parentReordableNodesCnt
        })]);
      }
    }]);
    return GroupContainer2;
  }(reactExports.Component), _class.propTypes = {
    //tree: PropTypes.instanceOf(Immutable.Map).isRequired,
    config: PropTypes.object.isRequired,
    actions: PropTypes.object.isRequired,
    //{setConjunction: Funciton, removeGroup, addGroup, addRule, ...}
    path: PropTypes.any.isRequired,
    //instanceOf(Immutable.List)
    id: PropTypes.string.isRequired,
    groupId: PropTypes.string,
    not: PropTypes.bool,
    conjunction: PropTypes.string,
    children1: PropTypes.any,
    //instanceOf(Immutable.OrderedMap)
    onDragStart: PropTypes.func,
    reordableNodesCnt: PropTypes.number,
    field: PropTypes.string,
    // for RuleGroup
    parentField: PropTypes.string,
    //from RuleGroup
    isLocked: PropTypes.bool,
    isTrueLocked: PropTypes.bool,
    //connected:
    dragging: PropTypes.object,
    //{id, x, y, w, h}
    isDraggingTempo: PropTypes.bool
  }, _class;
};
const GroupContainer = function(Group2) {
  var ConnectedGroupContainer = connect(function(state) {
    return {
      dragging: state.dragging
    };
  }, null, null, {
    context
  })(createGroupContainer(Group2));
  ConnectedGroupContainer.displayName = "ConnectedGroupContainer";
  return ConnectedGroupContainer;
};
function _createSuper$e(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$e();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct$e() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var groupActionsPositionList$1 = {
  topLeft: "group--actions--tl",
  topCenter: "group--actions--tc",
  topRight: "group--actions--tr",
  bottomLeft: "group--actions--bl",
  bottomCenter: "group--actions--bc",
  bottomRight: "group--actions--br"
};
var defaultPosition$2 = "topRight";
var GroupActions = /* @__PURE__ */ function(_PureComponent) {
  _inherits$b(GroupActions2, _PureComponent);
  var _super = _createSuper$e(GroupActions2);
  function GroupActions2() {
    _classCallCheck$b(this, GroupActions2);
    return _super.apply(this, arguments);
  }
  _createClass$9(GroupActions2, [{
    key: "render",
    value: function render3() {
      var _this$props = this.props, config2 = _this$props.config, addRule3 = _this$props.addRule, addGroup3 = _this$props.addGroup, removeSelf = _this$props.removeSelf, setLock4 = _this$props.setLock, isLocked = _this$props.isLocked, isTrueLocked = _this$props.isTrueLocked, id = _this$props.id, canAddGroup = _this$props.canAddGroup, canAddRule = _this$props.canAddRule, canDeleteGroup = _this$props.canDeleteGroup;
      var _config$settings = config2.settings, immutableGroupsMode = _config$settings.immutableGroupsMode, addRuleLabel = _config$settings.addRuleLabel, addGroupLabel = _config$settings.addGroupLabel, delGroupLabel = _config$settings.delGroupLabel, groupActionsPosition = _config$settings.groupActionsPosition, Btn = _config$settings.renderButton, Switch2 = _config$settings.renderSwitch, BtnGrp = _config$settings.renderButtonGroup, lockLabel = _config$settings.lockLabel, lockedLabel = _config$settings.lockedLabel, showLock = _config$settings.showLock, canDeleteLocked = _config$settings.canDeleteLocked;
      var position = groupActionsPositionList$1[groupActionsPosition || defaultPosition$2];
      var setLockSwitch = showLock && !(isLocked && !isTrueLocked) && /* @__PURE__ */ React.createElement(Switch2, {
        type: "lock",
        id,
        value: isLocked,
        setValue: setLock4,
        label: lockLabel,
        checkedLabel: lockedLabel,
        config: config2
      });
      var addRuleBtn = !immutableGroupsMode && canAddRule && !isLocked && /* @__PURE__ */ React.createElement(Btn, {
        type: "addRule",
        onClick: addRule3,
        label: addRuleLabel,
        readonly: isLocked,
        config: config2
      });
      var addGroupBtn = !immutableGroupsMode && canAddGroup && !isLocked && /* @__PURE__ */ React.createElement(Btn, {
        type: "addGroup",
        onClick: addGroup3,
        label: addGroupLabel,
        readonly: isLocked,
        config: config2
      });
      var delGroupBtn = !immutableGroupsMode && canDeleteGroup && (!isLocked || isLocked && canDeleteLocked) && /* @__PURE__ */ React.createElement(Btn, {
        type: "delGroup",
        onClick: removeSelf,
        label: delGroupLabel,
        config: config2
      });
      return /* @__PURE__ */ React.createElement("div", {
        className: "group--actions ".concat(position)
      }, /* @__PURE__ */ React.createElement(BtnGrp, {
        config: config2
      }, setLockSwitch, addRuleBtn, addGroupBtn, delGroupBtn));
    }
  }]);
  return GroupActions2;
}(reactExports.PureComponent);
function ownKeys$d(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$d(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$d(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$d(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper$d(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$d();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct$d() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var defaultPosition$1 = "topRight";
var BasicGroup = /* @__PURE__ */ function(_Component) {
  _inherits$b(BasicGroup2, _Component);
  var _super = _createSuper$d(BasicGroup2);
  function BasicGroup2(props) {
    var _this;
    _classCallCheck$b(this, BasicGroup2);
    _this = _super.call(this, props);
    _this.childrenClassName = function() {
      return "";
    };
    _this.renderBeforeActions = function() {
      var BeforeActions = _this.props.config.settings.renderBeforeActions;
      if (BeforeActions == void 0)
        return null;
      return typeof BeforeActions === "function" ? /* @__PURE__ */ React.createElement(BeforeActions, _this.props) : BeforeActions;
    };
    _this.renderAfterActions = function() {
      var AfterActions = _this.props.config.settings.renderAfterActions;
      if (AfterActions == void 0)
        return null;
      return typeof AfterActions === "function" ? /* @__PURE__ */ React.createElement(AfterActions, _this.props) : AfterActions;
    };
    _this.removeSelf = _this.removeSelf.bind(_assertThisInitialized$1(_this));
    _this.setLock = _this.setLock.bind(_assertThisInitialized$1(_this));
    _this.renderItem = _this.renderItem.bind(_assertThisInitialized$1(_this));
    return _this;
  }
  _createClass$9(BasicGroup2, [{
    key: "isGroupTopPosition",
    value: function isGroupTopPosition() {
      return startsWith$1(this.props.config.settings.groupActionsPosition || defaultPosition$1, "top");
    }
  }, {
    key: "setLock",
    value: function setLock4(lock) {
      this.props.setLock(lock);
    }
  }, {
    key: "removeSelf",
    value: function removeSelf() {
      var _this2 = this;
      var confirmFn = this.props.confirmFn;
      var _this$props$config$se = this.props.config.settings, renderConfirm = _this$props$config$se.renderConfirm, confirmOptions = _this$props$config$se.removeGroupConfirmOptions;
      var doRemove = function doRemove2() {
        _this2.props.removeSelf();
      };
      if (confirmOptions && !this.isEmptyCurrentGroup()) {
        renderConfirm(_objectSpread$d(_objectSpread$d({}, confirmOptions), {}, {
          onOk: doRemove,
          onCancel: null,
          confirmFn
        }));
      } else {
        doRemove();
      }
    }
  }, {
    key: "isEmptyCurrentGroup",
    value: function isEmptyCurrentGroup() {
      var children = this.props.children1;
      return !children || children.size == 0 || children.size == 1 && this.isEmpty(children.first());
    }
  }, {
    key: "isEmpty",
    value: function isEmpty(item) {
      var isGroup2 = item.get("type") == "group" || item.get("type") == "rule_group";
      return isGroup2 ? this.isEmptyGroup(item) : this.isEmptyRule(item);
    }
  }, {
    key: "isEmptyGroup",
    value: function isEmptyGroup(group3) {
      var children = group3.get("children1");
      return !children || children.size == 0 || children.size == 1 && this.isEmpty(children.first());
    }
  }, {
    key: "isEmptyRule",
    value: function isEmptyRule(rule3) {
      var properties = rule3.get("properties");
      return !(properties.get("field") !== null && properties.get("operator") !== null && properties.get("value").filter(function(val) {
        return val !== void 0;
      }).size > 0);
    }
  }, {
    key: "render",
    value: function render3() {
      return /* @__PURE__ */ React.createElement(React.Fragment, null, this.renderHeaderWrapper(), this.renderChildrenWrapper(), this.renderFooterWrapper());
    }
  }, {
    key: "showNot",
    value: function showNot() {
      var config2 = this.props.config;
      return config2.settings.showNot;
    }
    // show conjs for 2+ children?
  }, {
    key: "showConjs",
    value: function showConjs() {
      var _this$props = this.props, conjunctionOptions = _this$props.conjunctionOptions;
      _this$props.children1;
      _this$props.config;
      var conjunctionCount = Object.keys(conjunctionOptions).length;
      return conjunctionCount > 1 || this.showNot();
    }
  }, {
    key: "isNoChildren",
    value: function isNoChildren() {
      var children1 = this.props.children1;
      return children1 ? children1.size == 0 : true;
    }
  }, {
    key: "isOneChild",
    value: function isOneChild() {
      var children1 = this.props.children1;
      return children1 ? children1.size < 2 : true;
    }
  }, {
    key: "renderChildrenWrapper",
    value: function renderChildrenWrapper() {
      var children1 = this.props.children1;
      return children1 && /* @__PURE__ */ React.createElement("div", {
        key: "group-children",
        className: classNames("group--children", !this.showConjs() ? "hide--conjs" : "", this.isOneChild() ? "hide--line" : "", this.isOneChild() ? "one--child" : "", this.childrenClassName())
      }, this.renderChildren());
    }
  }, {
    key: "renderHeaderWrapper",
    value: function renderHeaderWrapper() {
      var isGroupTopPosition = this.isGroupTopPosition();
      return /* @__PURE__ */ React.createElement("div", {
        key: "group-header",
        className: classNames("group--header", this.isOneChild() ? "one--child" : "", !this.showConjs() ? "hide--conjs" : "", this.isOneChild() ? "hide--line" : "", this.isNoChildren() ? "no--children" : "")
      }, this.renderHeader(), isGroupTopPosition && this.renderBeforeActions(), isGroupTopPosition && this.renderActions(), isGroupTopPosition && this.renderAfterActions());
    }
  }, {
    key: "renderFooterWrapper",
    value: function renderFooterWrapper() {
      var isGroupTopPosition = this.isGroupTopPosition();
      return !isGroupTopPosition && /* @__PURE__ */ React.createElement("div", {
        key: "group-footer",
        className: "group--footer"
      }, this.renderBeforeActions(), this.renderActions(), this.renderAfterActions());
    }
  }, {
    key: "renderActions",
    value: function renderActions() {
      var _this$props2 = this.props, config2 = _this$props2.config, addRule3 = _this$props2.addRule, addGroup3 = _this$props2.addGroup, isLocked = _this$props2.isLocked, isTrueLocked = _this$props2.isTrueLocked, id = _this$props2.id;
      return /* @__PURE__ */ React.createElement(GroupActions, {
        config: config2,
        addRule: addRule3,
        addGroup: addGroup3,
        canAddGroup: this.canAddGroup(),
        canAddRule: this.canAddRule(),
        canDeleteGroup: this.canDeleteGroup(),
        removeSelf: this.removeSelf,
        setLock: this.setLock,
        isLocked,
        isTrueLocked,
        id
      });
    }
  }, {
    key: "canAddGroup",
    value: function canAddGroup() {
      return this.props.allowFurtherNesting;
    }
  }, {
    key: "canAddRule",
    value: function canAddRule() {
      var maxNumberOfRules = this.props.config.settings.maxNumberOfRules;
      var totalRulesCnt = this.props.totalRulesCnt;
      if (maxNumberOfRules) {
        return totalRulesCnt < maxNumberOfRules;
      }
      return true;
    }
  }, {
    key: "canDeleteGroup",
    value: function canDeleteGroup() {
      return !this.props.isRoot;
    }
  }, {
    key: "renderChildren",
    value: function renderChildren() {
      var children1 = this.props.children1;
      return children1 ? children1.map(this.renderItem).toList() : null;
    }
  }, {
    key: "renderItem",
    value: function renderItem(item) {
      var props = this.props;
      var config2 = props.config, actions = props.actions, onDragStart = props.onDragStart, isLocked = props.isLocked;
      var isRuleGroup = item.get("type") == "group" && item.getIn(["properties", "field"]) != null;
      var type2 = isRuleGroup ? "rule_group" : item.get("type");
      return /* @__PURE__ */ React.createElement(Item, _extends$h({}, this.extraPropsForItem(item), {
        key: item.get("id"),
        id: item.get("id"),
        groupId: props.id,
        path: item.get("path"),
        type: type2,
        properties: item.get("properties"),
        config: config2,
        actions,
        children1: item.get("children1"),
        reordableNodesCnt: this.reordableNodesCntForItem(item),
        totalRulesCnt: this.totalRulesCntForItem(item),
        parentReordableNodesCnt: this.reordableNodesCnt(),
        onDragStart,
        isDraggingTempo: this.props.isDraggingTempo,
        isParentLocked: isLocked
      }));
    }
  }, {
    key: "extraPropsForItem",
    value: function extraPropsForItem(_item) {
      return {};
    }
  }, {
    key: "reordableNodesCnt",
    value: function reordableNodesCnt() {
      if (this.props.isLocked)
        return 0;
      return this.props.reordableNodesCnt;
    }
  }, {
    key: "totalRulesCntForItem",
    value: function totalRulesCntForItem(_item) {
      return this.props.totalRulesCnt;
    }
  }, {
    key: "reordableNodesCntForItem",
    value: function reordableNodesCntForItem(_item) {
      if (this.props.isLocked)
        return 0;
      return this.reordableNodesCnt();
    }
  }, {
    key: "showDragIcon",
    value: function showDragIcon() {
      var _this$props3 = this.props, config2 = _this$props3.config, isRoot = _this$props3.isRoot, isLocked = _this$props3.isLocked;
      var reordableNodesCnt = this.reordableNodesCnt();
      return config2.settings.canReorder && !isRoot && reordableNodesCnt > 1 && !isLocked;
    }
  }, {
    key: "renderDrag",
    value: function renderDrag() {
      var handleDraggerMouseDown = this.props.handleDraggerMouseDown;
      var drag = this.showDragIcon() && /* @__PURE__ */ React.createElement("span", {
        key: "group-drag-icon",
        className: "qb-drag-handler group--drag-handler",
        onMouseDown: handleDraggerMouseDown
      }, /* @__PURE__ */ React.createElement(DragIcon, null), " ");
      return drag;
    }
  }, {
    key: "conjunctionOptions",
    value: function conjunctionOptions() {
      var conjunctionOptions2 = this.props.conjunctionOptions;
      return conjunctionOptions2;
    }
  }, {
    key: "renderConjs",
    value: function renderConjs3() {
      var _this$props4 = this.props, config2 = _this$props4.config, children1 = _this$props4.children1, id = _this$props4.id, selectedConjunction = _this$props4.selectedConjunction, setConjunction4 = _this$props4.setConjunction, not = _this$props4.not, setNot4 = _this$props4.setNot, isLocked = _this$props4.isLocked;
      var _config$settings = config2.settings, immutableGroupsMode = _config$settings.immutableGroupsMode, Conjs = _config$settings.renderConjs;
      _config$settings.showNot;
      var notLabel = _config$settings.notLabel;
      var conjunctionOptions = this.conjunctionOptions();
      if (!this.showConjs())
        return null;
      if (!children1 || !children1.size)
        return null;
      var renderProps = {
        disabled: this.isOneChild(),
        readonly: immutableGroupsMode || isLocked,
        selectedConjunction,
        setConjunction: immutableGroupsMode ? dummyFn : setConjunction4,
        conjunctionOptions,
        config: config2,
        not: not || false,
        id,
        setNot: immutableGroupsMode ? dummyFn : setNot4,
        notLabel,
        showNot: this.showNot(),
        isLocked
      };
      return /* @__PURE__ */ React.createElement(Conjs, renderProps);
    }
  }, {
    key: "renderHeader",
    value: function renderHeader() {
      return /* @__PURE__ */ React.createElement("div", {
        className: "group--conjunctions"
      }, this.renderConjs(), this.renderDrag());
    }
  }]);
  return BasicGroup2;
}(reactExports.Component);
BasicGroup.propTypes = {
  //tree: PropTypes.instanceOf(Immutable.Map).isRequired,
  reordableNodesCnt: PropTypes.number,
  conjunctionOptions: PropTypes.object.isRequired,
  allowFurtherNesting: PropTypes.bool.isRequired,
  isRoot: PropTypes.bool.isRequired,
  not: PropTypes.bool,
  selectedConjunction: PropTypes.string,
  config: PropTypes.object.isRequired,
  id: PropTypes.string.isRequired,
  groupId: PropTypes.string,
  path: PropTypes.any,
  //instanceOf(Immutable.List)
  children1: PropTypes.any,
  //instanceOf(Immutable.OrderedMap)
  isDraggingMe: PropTypes.bool,
  isDraggingTempo: PropTypes.bool,
  isLocked: PropTypes.bool,
  isTrueLocked: PropTypes.bool,
  //actions
  handleDraggerMouseDown: PropTypes.func,
  onDragStart: PropTypes.func,
  addRule: PropTypes.func.isRequired,
  addGroup: PropTypes.func.isRequired,
  removeSelf: PropTypes.func.isRequired,
  setConjunction: PropTypes.func.isRequired,
  setNot: PropTypes.func.isRequired,
  setLock: PropTypes.func.isRequired,
  actions: PropTypes.object.isRequired
};
const Group = GroupContainer(Draggable("group")(ConfirmFn(BasicGroup)));
function _superPropBase(object, property2) {
  while (!Object.prototype.hasOwnProperty.call(object, property2)) {
    object = _getPrototypeOf$1(object);
    if (object === null)
      break;
  }
  return object;
}
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get.bind();
  } else {
    _get = function _get2(target, property2, receiver) {
      var base = _superPropBase(target, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get.apply(this, arguments);
}
function _createSuper$c(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$c();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct$c() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var RuleGroupActions = /* @__PURE__ */ function(_PureComponent) {
  _inherits$b(RuleGroupActions2, _PureComponent);
  var _super = _createSuper$c(RuleGroupActions2);
  function RuleGroupActions2() {
    _classCallCheck$b(this, RuleGroupActions2);
    return _super.apply(this, arguments);
  }
  _createClass$9(RuleGroupActions2, [{
    key: "render",
    value: function render3() {
      var _this$props = this.props, config2 = _this$props.config, addRule3 = _this$props.addRule, canAddRule = _this$props.canAddRule, canDeleteGroup = _this$props.canDeleteGroup, removeSelf = _this$props.removeSelf, setLock4 = _this$props.setLock, isLocked = _this$props.isLocked, isTrueLocked = _this$props.isTrueLocked, id = _this$props.id;
      var _config$settings = config2.settings, immutableGroupsMode = _config$settings.immutableGroupsMode, addRuleLabel = _config$settings.addRuleLabel, delGroupLabel = _config$settings.delGroupLabel, Btn = _config$settings.renderButton, Switch2 = _config$settings.renderSwitch, BtnGrp = _config$settings.renderButtonGroup, lockLabel = _config$settings.lockLabel, lockedLabel = _config$settings.lockedLabel, showLock = _config$settings.showLock, canDeleteLocked = _config$settings.canDeleteLocked;
      var setLockSwitch = showLock && !(isLocked && !isTrueLocked) && /* @__PURE__ */ React.createElement(Switch2, {
        type: "lock",
        id,
        value: isLocked,
        setValue: setLock4,
        label: lockLabel,
        checkedLabel: lockedLabel,
        hideLabel: true,
        config: config2
      });
      var addRuleBtn = !immutableGroupsMode && canAddRule && !isLocked && /* @__PURE__ */ React.createElement(Btn, {
        type: "addRuleGroup",
        onClick: addRule3,
        label: addRuleLabel,
        readonly: isLocked,
        config: config2
      });
      var delGroupBtn = !immutableGroupsMode && canDeleteGroup && (!isLocked || isLocked && canDeleteLocked) && /* @__PURE__ */ React.createElement(Btn, {
        type: "delRuleGroup",
        onClick: removeSelf,
        label: delGroupLabel,
        config: config2
      });
      return /* @__PURE__ */ React.createElement("div", {
        className: "group--actions"
      }, /* @__PURE__ */ React.createElement(BtnGrp, {
        config: config2
      }, setLockSwitch, addRuleBtn, delGroupBtn));
    }
  }]);
  return RuleGroupActions2;
}(reactExports.PureComponent);
function ownKeys$c(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$c(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$c(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$c(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper$b(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$b();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct$b() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var RuleGroup = /* @__PURE__ */ function(_BasicGroup) {
  _inherits$b(RuleGroup2, _BasicGroup);
  var _super = _createSuper$b(RuleGroup2);
  function RuleGroup2(props) {
    var _this;
    _classCallCheck$b(this, RuleGroup2);
    _this = _super.call(this, props);
    _this.childrenClassName = function() {
      return "rule_group--children";
    };
    _this.renderHeaderWrapper = function() {
      return null;
    };
    _this.renderFooterWrapper = function() {
      return null;
    };
    _this.renderConjs = function() {
      return null;
    };
    _this.canAddGroup = function() {
      return false;
    };
    _this.canAddRule = function() {
      return true;
    };
    _this.canDeleteGroup = function() {
      return false;
    };
    useOnPropsChanged(_assertThisInitialized$1(_this));
    _this.onPropsChanged(props);
    return _this;
  }
  _createClass$9(RuleGroup2, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
    }
  }, {
    key: "reordableNodesCntForItem",
    value: function reordableNodesCntForItem(_item) {
      if (this.props.isLocked)
        return 0;
      var children1 = this.props.children1;
      return (children1 === null || children1 === void 0 ? void 0 : children1.size) || 0;
    }
  }, {
    key: "renderChildrenWrapper",
    value: function renderChildrenWrapper() {
      return /* @__PURE__ */ React.createElement(React.Fragment, null, this.renderDrag(), this.renderField(), this.renderActions(), _get(_getPrototypeOf$1(RuleGroup2.prototype), "renderChildrenWrapper", this).call(this));
    }
  }, {
    key: "renderField",
    value: function renderField3() {
      var _this$props = this.props, config2 = _this$props.config, selectedField = _this$props.selectedField, setField4 = _this$props.setField, parentField = _this$props.parentField, id = _this$props.id, groupId = _this$props.groupId, isLocked = _this$props.isLocked;
      var immutableFieldsMode = config2.settings.immutableFieldsMode;
      return /* @__PURE__ */ React.createElement(FieldWrapper, {
        key: "field",
        classname: "group--field",
        config: config2,
        selectedField,
        setField: setField4,
        parentField,
        readonly: immutableFieldsMode || isLocked,
        id,
        groupId
      });
    }
  }, {
    key: "renderActions",
    value: function renderActions() {
      var _this$props2 = this.props, config2 = _this$props2.config, addRule3 = _this$props2.addRule, isLocked = _this$props2.isLocked, isTrueLocked = _this$props2.isTrueLocked, id = _this$props2.id;
      return /* @__PURE__ */ React.createElement(RuleGroupActions, {
        config: config2,
        addRule: addRule3,
        canAddRule: this.canAddRule(),
        canDeleteGroup: this.canDeleteGroup(),
        removeSelf: this.removeSelf,
        setLock: this.setLock,
        isLocked,
        isTrueLocked,
        id
      });
    }
  }, {
    key: "extraPropsForItem",
    value: function extraPropsForItem(_item) {
      return {
        parentField: this.props.selectedField
      };
    }
  }]);
  return RuleGroup2;
}(BasicGroup);
RuleGroup.propTypes = _objectSpread$c(_objectSpread$c({}, BasicGroup.propTypes), {}, {
  selectedField: PropTypes.string,
  parentField: PropTypes.string,
  setField: PropTypes.func
});
const RuleGroup$1 = GroupContainer(Draggable("group rule_group")(ConfirmFn(RuleGroup)));
function _createSuper$a(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$a();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct$a() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var RuleGroupExtActions = /* @__PURE__ */ function(_PureComponent) {
  _inherits$b(RuleGroupExtActions2, _PureComponent);
  var _super = _createSuper$a(RuleGroupExtActions2);
  function RuleGroupExtActions2() {
    _classCallCheck$b(this, RuleGroupExtActions2);
    return _super.apply(this, arguments);
  }
  _createClass$9(RuleGroupExtActions2, [{
    key: "render",
    value: function render3() {
      var _this$props = this.props, config2 = _this$props.config, addRule3 = _this$props.addRule, canAddRule = _this$props.canAddRule, canDeleteGroup = _this$props.canDeleteGroup, removeSelf = _this$props.removeSelf, setLock4 = _this$props.setLock, isLocked = _this$props.isLocked, isTrueLocked = _this$props.isTrueLocked, id = _this$props.id;
      var _config$settings = config2.settings, immutableGroupsMode = _config$settings.immutableGroupsMode, addSubRuleLabel = _config$settings.addSubRuleLabel, delGroupLabel = _config$settings.delGroupLabel, Btn = _config$settings.renderButton, Switch2 = _config$settings.renderSwitch, BtnGrp = _config$settings.renderButtonGroup, lockLabel = _config$settings.lockLabel, lockedLabel = _config$settings.lockedLabel, showLock = _config$settings.showLock, canDeleteLocked = _config$settings.canDeleteLocked;
      var setLockSwitch = showLock && !(isLocked && !isTrueLocked) && /* @__PURE__ */ React.createElement(Switch2, {
        type: "lock",
        id,
        value: isLocked,
        setValue: setLock4,
        label: lockLabel,
        checkedLabel: lockedLabel,
        config: config2
      });
      var addRuleBtn = !immutableGroupsMode && canAddRule && !isLocked && /* @__PURE__ */ React.createElement(Btn, {
        type: "addRuleGroupExt",
        onClick: addRule3,
        label: addSubRuleLabel,
        readonly: isLocked,
        config: config2
      });
      var delGroupBtn = !immutableGroupsMode && canDeleteGroup && (!isLocked || isLocked && canDeleteLocked) && /* @__PURE__ */ React.createElement(Btn, {
        type: "delRuleGroup",
        onClick: removeSelf,
        label: delGroupLabel,
        config: config2
      });
      return /* @__PURE__ */ React.createElement("div", {
        className: "group--actions group--actions--tr"
      }, /* @__PURE__ */ React.createElement(BtnGrp, {
        config: config2
      }, setLockSwitch, addRuleBtn, delGroupBtn));
    }
  }]);
  return RuleGroupExtActions2;
}(reactExports.PureComponent);
function ownKeys$b(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$b(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$b(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$b(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i2 = 0;
      var F2 = function F3() {
      };
      return { s: F2, n: function n2() {
        if (i2 >= o.length)
          return { done: true };
        return { done: false, value: o[i2++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F2 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it = it.call(o);
  }, n: function n2() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f2() {
    try {
      if (!normalCompletion && it["return"] != null)
        it["return"]();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
function _createSuper$9(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$9();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct$9() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var _Utils$ConfigUtils$1 = Utils$1.ConfigUtils, getFieldConfig$2 = _Utils$ConfigUtils$1.getFieldConfig, getFieldWidgetConfig2 = _Utils$ConfigUtils$1.getFieldWidgetConfig;
var RuleGroupExt = /* @__PURE__ */ function(_BasicGroup) {
  _inherits$b(RuleGroupExt2, _BasicGroup);
  var _super = _createSuper$9(RuleGroupExt2);
  function RuleGroupExt2(props) {
    var _this;
    _classCallCheck$b(this, RuleGroupExt2);
    _this = _super.call(this, props);
    _this.childrenClassName = function() {
      return "rule_group_ext--children";
    };
    _this.renderFooterWrapper = function() {
      return null;
    };
    _this.canAddGroup = function() {
      return false;
    };
    _this.canAddRule = function() {
      return true;
    };
    _this.canDeleteGroup = function() {
      return true;
    };
    useOnPropsChanged(_assertThisInitialized$1(_this));
    _this.onPropsChanged(props);
    return _this;
  }
  _createClass$9(RuleGroupExt2, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
    }
  }, {
    key: "renderHeaderWrapper",
    value: function renderHeaderWrapper() {
      return /* @__PURE__ */ React.createElement("div", {
        key: "group-header",
        className: classNames("group--header", this.isOneChild() ? "one--child" : "", this.isOneChild() ? "hide--line" : "", this.isNoChildren() ? "no--children" : "", this.showDragIcon() ? "with--drag" : "hide--drag", this.showConjs() && (!this.isOneChild() || this.showNot()) ? "with--conjs" : "hide--conjs")
      }, this.renderHeader(), this.renderGroupField(), this.renderActions());
    }
  }, {
    key: "renderHeader",
    value: function renderHeader() {
      return /* @__PURE__ */ React.createElement("div", {
        className: "group--conjunctions"
      }, this.renderConjs(), this.renderDrag());
    }
  }, {
    key: "renderGroupField",
    value: function renderGroupField() {
      return /* @__PURE__ */ React.createElement("div", {
        className: "group--field--count--rule"
      }, this.renderField(), this.renderOperator(), this.renderWidget());
    }
  }, {
    key: "showNot",
    value: function showNot() {
      var _this$props = this.props, config2 = _this$props.config, selectedField = _this$props.selectedField;
      _this$props.selectedOperator;
      var selectedFieldConfig = getFieldConfig$2(config2, selectedField) || {};
      return selectedFieldConfig.showNot != void 0 ? selectedFieldConfig.showNot : config2.settings.showNot;
    }
  }, {
    key: "conjunctionOptions",
    value: function conjunctionOptions() {
      var _this$props2 = this.props, config2 = _this$props2.config, selectedField = _this$props2.selectedField;
      _this$props2.selectedOperator;
      var selectedFieldConfig = getFieldConfig$2(config2, selectedField) || {};
      var conjunctionOptions2 = _get(_getPrototypeOf$1(RuleGroupExt2.prototype), "conjunctionOptions", this).call(this);
      if (selectedFieldConfig.conjunctions) {
        var filtered = {};
        var _iterator = _createForOfIteratorHelper(selectedFieldConfig.conjunctions), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var k2 = _step.value;
            filtered[k2] = conjunctionOptions2[k2];
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        conjunctionOptions2 = filtered;
      }
      return conjunctionOptions2;
    }
  }, {
    key: "renderField",
    value: function renderField3() {
      var _this$props3 = this.props, config2 = _this$props3.config, selectedField = _this$props3.selectedField, setField4 = _this$props3.setField, parentField = _this$props3.parentField, id = _this$props3.id, groupId = _this$props3.groupId, isLocked = _this$props3.isLocked;
      var immutableFieldsMode = config2.settings.immutableFieldsMode;
      return /* @__PURE__ */ React.createElement(FieldWrapper, {
        key: "field",
        classname: "rule--field",
        config: config2,
        selectedField,
        setField: setField4,
        parentField,
        readonly: immutableFieldsMode || isLocked,
        id,
        groupId
      });
    }
  }, {
    key: "renderOperator",
    value: function renderOperator3() {
      var _this$props4 = this.props, config2 = _this$props4.config, selectedField = _this$props4.selectedField, selectedOperator = _this$props4.selectedOperator, setField4 = _this$props4.setField, setOperator4 = _this$props4.setOperator, isLocked = _this$props4.isLocked;
      var immutableFieldsMode = config2.settings.immutableFieldsMode;
      var selectedFieldWidgetConfig = getFieldWidgetConfig2(config2, selectedField, selectedOperator) || {};
      var hideOperator = selectedFieldWidgetConfig.hideOperator;
      var showOperatorLabel = selectedField && hideOperator && selectedFieldWidgetConfig.operatorInlineLabel;
      var showOperator = selectedField && !hideOperator;
      return /* @__PURE__ */ React.createElement(OperatorWrapper, {
        key: "operator",
        classname: "group--operator",
        config: config2,
        selectedField,
        selectedOperator,
        setField: setField4,
        setOperator: setOperator4,
        selectedFieldPartsLabels: ["group"],
        showOperator,
        showOperatorLabel,
        selectedFieldWidgetConfig,
        readonly: immutableFieldsMode || isLocked,
        id: this.props.id,
        groupId: this.props.groupId
      });
    }
  }, {
    key: "renderWidget",
    value: function renderWidget() {
      var _this$props5 = this.props, config2 = _this$props5.config, selectedField = _this$props5.selectedField, selectedOperator = _this$props5.selectedOperator, isLocked = _this$props5.isLocked;
      var immutableValuesMode = config2.settings.immutableValuesMode;
      var isFieldAndOpSelected = selectedField && selectedOperator;
      var showWidget = isFieldAndOpSelected;
      if (!showWidget)
        return null;
      var widget = /* @__PURE__ */ React.createElement(Widget, {
        key: "values",
        isForRuleGruop: true,
        field: this.props.selectedField,
        operator: this.props.selectedOperator,
        value: this.props.value,
        valueSrc: "value",
        valueError: null,
        config: config2,
        setValue: !immutableValuesMode ? this.props.setValue : dummyFn,
        setValueSrc: dummyFn,
        readonly: immutableValuesMode || isLocked,
        id: this.props.id,
        groupId: this.props.groupId
      });
      return /* @__PURE__ */ React.createElement(Col, {
        key: "widget-for-" + this.props.selectedOperator,
        className: "rule--value"
      }, widget);
    }
  }, {
    key: "renderActions",
    value: function renderActions() {
      var _this$props6 = this.props, config2 = _this$props6.config, addRule3 = _this$props6.addRule, isLocked = _this$props6.isLocked, isTrueLocked = _this$props6.isTrueLocked, id = _this$props6.id;
      return /* @__PURE__ */ React.createElement(RuleGroupExtActions, {
        config: config2,
        addRule: addRule3,
        canAddRule: this.canAddRule(),
        canDeleteGroup: this.canDeleteGroup(),
        removeSelf: this.removeSelf,
        setLock: this.setLock,
        isLocked,
        isTrueLocked,
        id
      });
    }
  }, {
    key: "reordableNodesCntForItem",
    value: function reordableNodesCntForItem(_item) {
      if (this.props.isLocked)
        return 0;
      var children1 = this.props.children1;
      return (children1 === null || children1 === void 0 ? void 0 : children1.size) || 0;
    }
  }, {
    key: "extraPropsForItem",
    value: function extraPropsForItem(_item) {
      return {
        parentField: this.props.selectedField
      };
    }
  }]);
  return RuleGroupExt2;
}(BasicGroup);
RuleGroupExt.propTypes = _objectSpread$b(_objectSpread$b({}, BasicGroup.propTypes), {}, {
  selectedField: PropTypes.string,
  selectedOperator: PropTypes.string,
  value: PropTypes.any,
  parentField: PropTypes.string,
  setField: PropTypes.func,
  setOperator: PropTypes.func,
  setValue: PropTypes.func
});
const RuleGroupExt$1 = GroupContainer(Draggable("group rule_group_ext")(ConfirmFn(RuleGroupExt)));
function _createSuper$8(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$8();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct$8() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var groupActionsPositionList = {
  topLeft: "group--actions--tl",
  topCenter: "group--actions--tc",
  topRight: "group--actions--tr",
  bottomLeft: "group--actions--bl",
  bottomCenter: "group--actions--bc",
  bottomRight: "group--actions--br"
};
var defaultPosition = "topRight";
var SwitchGroupActions = /* @__PURE__ */ function(_PureComponent) {
  _inherits$b(SwitchGroupActions2, _PureComponent);
  var _super = _createSuper$8(SwitchGroupActions2);
  function SwitchGroupActions2() {
    _classCallCheck$b(this, SwitchGroupActions2);
    return _super.apply(this, arguments);
  }
  _createClass$9(SwitchGroupActions2, [{
    key: "render",
    value: function render3() {
      var _this$props = this.props, config2 = _this$props.config, addCaseGroup3 = _this$props.addCaseGroup, addDefaultCaseGroup3 = _this$props.addDefaultCaseGroup, setLock4 = _this$props.setLock, isLocked = _this$props.isLocked, isTrueLocked = _this$props.isTrueLocked, id = _this$props.id, canAddGroup = _this$props.canAddGroup, canAddDefault = _this$props.canAddDefault;
      var _config$settings = config2.settings, immutableGroupsMode = _config$settings.immutableGroupsMode, addCaseLabel = _config$settings.addCaseLabel, addDefaultCaseLabel = _config$settings.addDefaultCaseLabel, groupActionsPosition = _config$settings.groupActionsPosition, Btn = _config$settings.renderButton, Switch2 = _config$settings.renderSwitch, BtnGrp = _config$settings.renderButtonGroup, lockLabel = _config$settings.lockLabel, lockedLabel = _config$settings.lockedLabel, showLock = _config$settings.showLock;
      var position = groupActionsPositionList[groupActionsPosition || defaultPosition];
      var setLockSwitch = showLock && !(isLocked && !isTrueLocked) && /* @__PURE__ */ React.createElement(Switch2, {
        type: "lock",
        id,
        value: isLocked,
        setValue: setLock4,
        label: lockLabel,
        checkedLabel: lockedLabel,
        config: config2
      });
      var addCaseGroupBtn = !immutableGroupsMode && canAddGroup && !isLocked && /* @__PURE__ */ React.createElement(Btn, {
        type: "addCaseGroup",
        onClick: addCaseGroup3,
        label: addCaseLabel,
        readonly: isLocked,
        config: config2
      });
      var addDefaultCaseGroupBtn = !immutableGroupsMode && canAddDefault && !isLocked && /* @__PURE__ */ React.createElement(Btn, {
        type: "addDefaultCaseGroup",
        onClick: addDefaultCaseGroup3,
        label: addDefaultCaseLabel,
        readonly: isLocked,
        config: config2
      });
      return /* @__PURE__ */ React.createElement("div", {
        className: "group--actions ".concat(position)
      }, /* @__PURE__ */ React.createElement(BtnGrp, {
        config: config2
      }, setLockSwitch, addCaseGroupBtn, addDefaultCaseGroupBtn));
    }
  }]);
  return SwitchGroupActions2;
}(reactExports.PureComponent);
function ownKeys$a(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$a(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$a(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$a(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper$7(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$7();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct$7() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var _Utils$TreeUtils$1 = Utils$1.TreeUtils, getTotalReordableNodesCountInTree$1 = _Utils$TreeUtils$1.getTotalReordableNodesCountInTree, getTotalRulesCountInTree$1 = _Utils$TreeUtils$1.getTotalRulesCountInTree;
var SwitchGroup = /* @__PURE__ */ function(_BasicGroup) {
  _inherits$b(SwitchGroup2, _BasicGroup);
  var _super = _createSuper$7(SwitchGroup2);
  function SwitchGroup2(props) {
    var _this;
    _classCallCheck$b(this, SwitchGroup2);
    _this = _super.call(this, props);
    _this.childrenClassName = function() {
      return "switch_group--children";
    };
    _this.renderFooterWrapper = function() {
      return null;
    };
    _this.hasDefaultCase = function() {
      var _this$props$children;
      return ((_this$props$children = _this.props.children1) === null || _this$props$children === void 0 ? void 0 : _this$props$children.size) && _this.props.children1.filter(function(c2) {
        return c2.get("children1") == null;
      }).size > 0;
    };
    useOnPropsChanged(_assertThisInitialized$1(_this));
    _this.onPropsChanged(props);
    return _this;
  }
  _createClass$9(SwitchGroup2, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
    }
  }, {
    key: "canAddGroup",
    value: function canAddGroup() {
      var _this$props$children2;
      var maxNumberOfCases = this.props.config.settings.maxNumberOfCases;
      var totalCasesCnt = ((_this$props$children2 = this.props.children1) === null || _this$props$children2 === void 0 ? void 0 : _this$props$children2.size) || 0;
      if (maxNumberOfCases) {
        return totalCasesCnt < maxNumberOfCases;
      }
      return true;
    }
  }, {
    key: "canAddRule",
    value: function canAddRule() {
      return false;
    }
  }, {
    key: "reordableNodesCnt",
    value: function reordableNodesCnt() {
      var _this$props$children3;
      var totalCasesCnt = ((_this$props$children3 = this.props.children1) === null || _this$props$children3 === void 0 ? void 0 : _this$props$children3.size) || 0;
      var casesToReorder = totalCasesCnt;
      if (this.hasDefaultCase()) {
        casesToReorder--;
      }
      return casesToReorder;
    }
  }, {
    key: "totalRulesCntForItem",
    value: function totalRulesCntForItem(item) {
      return getTotalRulesCountInTree$1(item);
    }
  }, {
    key: "reordableNodesCntForItem",
    value: function reordableNodesCntForItem(item) {
      var _this$props$children4;
      if (this.props.isLocked)
        return 0;
      var _this$props$config$se = this.props.config.settings, canLeaveEmptyCase = _this$props$config$se.canLeaveEmptyCase, canRegroupCases = _this$props$config$se.canRegroupCases;
      var totalCasesCnt = ((_this$props$children4 = this.props.children1) === null || _this$props$children4 === void 0 ? void 0 : _this$props$children4.size) || 0;
      var casesToReorder = totalCasesCnt;
      if (this.hasDefaultCase()) {
        casesToReorder--;
      }
      var nodesInCase = getTotalReordableNodesCountInTree$1(item);
      var cnt = nodesInCase;
      if (cnt == 1 && canRegroupCases && canLeaveEmptyCase && casesToReorder > 1)
        cnt = 111;
      return cnt;
    }
  }, {
    key: "renderHeaderWrapper",
    value: function renderHeaderWrapper() {
      return /* @__PURE__ */ React.createElement("div", {
        key: "group-header",
        className: classNames(
          "group--header",
          this.isOneChild() ? "one--child" : "",
          this.isOneChild() ? "hide--line" : "",
          this.isNoChildren() ? "no--children" : "",
          this.showDragIcon() ? "with--drag" : "hide--drag"
          //this.showConjs() && (!this.isOneChild() || this.showNot()) ? "with--conjs" : "hide--conjs"
        )
      }, this.renderHeader(), this.renderActions());
    }
  }, {
    key: "renderHeader",
    value: function renderHeader() {
      return /* @__PURE__ */ React.createElement("div", {
        className: "group--conjunctions"
      }, this.renderConjs(), this.renderDrag());
    }
  }, {
    key: "renderConjs",
    value: function renderConjs3() {
      var renderSwitchPrefix2 = this.props.config.settings.renderSwitchPrefix;
      return renderSwitchPrefix2 ? renderSwitchPrefix2() : null;
    }
  }, {
    key: "showNot",
    value: function showNot() {
      return false;
    }
  }, {
    key: "renderActions",
    value: function renderActions() {
      var _this$props = this.props, config2 = _this$props.config, addCaseGroup3 = _this$props.addCaseGroup, addDefaultCaseGroup3 = _this$props.addDefaultCaseGroup, isLocked = _this$props.isLocked, isTrueLocked = _this$props.isTrueLocked, id = _this$props.id;
      return /* @__PURE__ */ React.createElement(SwitchGroupActions, {
        config: config2,
        addCaseGroup: addCaseGroup3,
        addDefaultCaseGroup: addDefaultCaseGroup3,
        canAddDefault: !this.hasDefaultCase(),
        canAddGroup: this.canAddGroup(),
        setLock: this.setLock,
        isLocked,
        isTrueLocked,
        id
      });
    }
  }]);
  return SwitchGroup2;
}(BasicGroup);
SwitchGroup.propTypes = _objectSpread$a({}, BasicGroup.propTypes);
const SwitchGroup$1 = GroupContainer(Draggable("group switch_group")(ConfirmFn(SwitchGroup)));
function ownKeys$9(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$9(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$9(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$9(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper$6(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$6();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct$6() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var CaseGroup = /* @__PURE__ */ function(_BasicGroup) {
  _inherits$b(CaseGroup2, _BasicGroup);
  var _super = _createSuper$6(CaseGroup2);
  function CaseGroup2(props) {
    var _this;
    _classCallCheck$b(this, CaseGroup2);
    _this = _super.call(this, props);
    _this.childrenClassName = function() {
      return "case_group--children";
    };
    _this.renderFooterWrapper = function() {
      return null;
    };
    useOnPropsChanged(_assertThisInitialized$1(_this));
    _this.onPropsChanged(props);
    return _this;
  }
  _createClass$9(CaseGroup2, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
    }
  }, {
    key: "isDefaultCase",
    value: function isDefaultCase() {
      return this.props.children1 == void 0;
    }
  }, {
    key: "reordableNodesCnt",
    value: function reordableNodesCnt() {
      return this.props.parentReordableNodesCnt;
    }
  }, {
    key: "reordableNodesCntForItem",
    value: function reordableNodesCntForItem(_item) {
      if (this.props.isLocked)
        return 0;
      return this.props.reordableNodesCnt;
    }
  }, {
    key: "totalRulesCntForItem",
    value: function totalRulesCntForItem(_item) {
      return this.props.totalRulesCnt;
    }
  }, {
    key: "showDragIcon",
    value: function showDragIcon() {
      if (this.isDefaultCase())
        return false;
      return _get(_getPrototypeOf$1(CaseGroup2.prototype), "showDragIcon", this).call(this);
    }
  }, {
    key: "renderHeaderWrapper",
    value: function renderHeaderWrapper() {
      return /* @__PURE__ */ React.createElement("div", {
        key: "group-header",
        className: classNames("group--header", this.isOneChild() ? "one--child" : "", this.isOneChild() ? "hide--line" : "", this.isNoChildren() ? "no--children" : "", this.showDragIcon() ? "with--drag" : "hide--drag", this.showConjs() && (!this.isOneChild() || this.showNot()) ? "with--conjs" : "hide--conjs")
      }, this.renderHeaderLeft(), this.renderHeaderCenter(), this.renderActions());
    }
  }, {
    key: "renderChildrenWrapper",
    value: function renderChildrenWrapper() {
      if (this.isDefaultCase())
        return null;
      return /* @__PURE__ */ React.createElement("div", {
        className: "case_group--body"
      }, this.renderCondition(), this.renderValue());
    }
  }, {
    key: "renderHeaderLeft",
    value: function renderHeaderLeft() {
      if (this.isDefaultCase()) {
        var defaultCaseLabel = this.props.config.settings.defaultCaseLabel;
        return defaultCaseLabel || "";
      }
      return /* @__PURE__ */ React.createElement("div", {
        className: "group--conjunctions"
      }, this.renderConjs(), this.renderDrag());
    }
  }, {
    key: "renderCondition",
    value: function renderCondition() {
      if (this.isDefaultCase())
        return null;
      return _get(_getPrototypeOf$1(CaseGroup2.prototype), "renderChildrenWrapper", this).call(this);
    }
  }, {
    key: "renderHeaderCenter",
    value: function renderHeaderCenter() {
      if (this.isDefaultCase())
        return this.renderValue();
      else
        return null;
    }
  }, {
    key: "canAddGroup",
    value: function canAddGroup() {
      if (this.isDefaultCase())
        return false;
      return _get(_getPrototypeOf$1(CaseGroup2.prototype), "canAddGroup", this).call(this);
    }
  }, {
    key: "canAddRule",
    value: function canAddRule() {
      if (this.isDefaultCase())
        return false;
      return _get(_getPrototypeOf$1(CaseGroup2.prototype), "canAddRule", this).call(this);
    }
  }, {
    key: "renderValue",
    value: function renderValue() {
      var _this$props = this.props, config2 = _this$props.config, isLocked = _this$props.isLocked, value = _this$props.value, setValue4 = _this$props.setValue, id = _this$props.id;
      var immutableValuesMode = config2.settings.immutableValuesMode;
      var widget = /* @__PURE__ */ React.createElement(Widget, {
        key: "values",
        isCaseValue: true,
        field: "!case_value",
        operator: null,
        value,
        valueSrc: "value",
        valueError: null,
        config: config2,
        setValue: !immutableValuesMode ? setValue4 : dummyFn,
        setValueSrc: dummyFn,
        readonly: immutableValuesMode || isLocked,
        id,
        groupId: null
      });
      return /* @__PURE__ */ React.createElement(Col, {
        className: "case_group--value"
      }, widget);
    }
  }, {
    key: "renderActions",
    value: function renderActions() {
      var _this$props2 = this.props, config2 = _this$props2.config, addGroup3 = _this$props2.addGroup, addRule3 = _this$props2.addRule, isLocked = _this$props2.isLocked, isTrueLocked = _this$props2.isTrueLocked, id = _this$props2.id;
      return /* @__PURE__ */ React.createElement(GroupActions, {
        config: config2,
        addGroup: addGroup3,
        addRule: addRule3,
        canAddRule: this.canAddRule(),
        canAddGroup: this.canAddGroup(),
        canDeleteGroup: this.canDeleteGroup(),
        removeSelf: this.removeSelf,
        setLock: this.setLock,
        isLocked,
        isTrueLocked,
        id
      });
    }
  }, {
    key: "isEmptyCurrentGroup",
    value: function isEmptyCurrentGroup() {
      var value = this.props.value;
      var oneValue = value && value.size ? value.get(0) : null;
      var hasValue = oneValue != null && (Array.isArray(oneValue) ? oneValue.length > 0 : true);
      return _get(_getPrototypeOf$1(CaseGroup2.prototype), "isEmptyCurrentGroup", this).call(this) && !hasValue;
    }
  }]);
  return CaseGroup2;
}(BasicGroup);
CaseGroup.propTypes = _objectSpread$9(_objectSpread$9({}, BasicGroup.propTypes), {}, {
  parentReordableNodesCnt: PropTypes.number,
  value: PropTypes.any,
  setValue: PropTypes.func
});
const CaseGroup$1 = GroupContainer(Draggable("group case_group")(ConfirmFn(CaseGroup)));
var _excluded$4 = ["type"];
function _createSuper$5(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct$5() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function ownKeys$8(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$8(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$8(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$8(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var types$3 = ["rule", "group", "rule_group", "switch_group", "case_group"];
var getProperties = function getProperties2(props) {
  var _props$properties;
  var properties = ((_props$properties = props.properties) === null || _props$properties === void 0 ? void 0 : _props$properties.toObject()) || {};
  var result = _objectSpread$8({}, properties);
  if (props.isParentLocked) {
    result.isLocked = true;
  }
  if (properties.isLocked) {
    result.isTrueLocked = true;
  }
  return result;
};
var typeMap = {
  rule: function rule2(props) {
    return /* @__PURE__ */ React.createElement(Rule$1, _extends$h({}, getProperties(props), {
      id: props.id,
      groupId: props.groupId,
      path: props.path,
      actions: props.actions,
      reordableNodesCnt: props.reordableNodesCnt,
      totalRulesCnt: props.totalRulesCnt,
      config: props.config,
      onDragStart: props.onDragStart,
      isDraggingTempo: props.isDraggingTempo,
      parentField: props.parentField,
      parentReordableNodesCnt: props.parentReordableNodesCnt
    }));
  },
  group: function group2(props) {
    return /* @__PURE__ */ React.createElement(Group, _extends$h({}, getProperties(props), {
      id: props.id,
      groupId: props.groupId,
      path: props.path,
      actions: props.actions,
      config: props.config,
      reordableNodesCnt: props.reordableNodesCnt,
      totalRulesCnt: props.totalRulesCnt,
      onDragStart: props.onDragStart,
      isDraggingTempo: props.isDraggingTempo,
      children1: props.children1,
      parentField: null,
      parentReordableNodesCnt: props.parentReordableNodesCnt
    }));
  },
  rule_group: function rule_group(props) {
    return /* @__PURE__ */ React.createElement(RuleGroup$1, _extends$h({}, getProperties(props), {
      id: props.id,
      groupId: props.groupId,
      path: props.path,
      actions: props.actions,
      config: props.config,
      reordableNodesCnt: props.reordableNodesCnt,
      totalRulesCnt: props.totalRulesCnt,
      onDragStart: props.onDragStart,
      isDraggingTempo: props.isDraggingTempo,
      children1: props.children1,
      parentField: props.parentField,
      parentReordableNodesCnt: props.parentReordableNodesCnt
    }));
  },
  rule_group_ext: function rule_group_ext(props) {
    return /* @__PURE__ */ React.createElement(RuleGroupExt$1, _extends$h({}, getProperties(props), {
      id: props.id,
      groupId: props.groupId,
      path: props.path,
      actions: props.actions,
      config: props.config,
      reordableNodesCnt: props.reordableNodesCnt,
      totalRulesCnt: props.totalRulesCnt,
      onDragStart: props.onDragStart,
      isDraggingTempo: props.isDraggingTempo,
      children1: props.children1,
      parentField: props.parentField,
      parentReordableNodesCnt: props.parentReordableNodesCnt
    }));
  },
  switch_group: function switch_group(props) {
    return /* @__PURE__ */ React.createElement(SwitchGroup$1, _extends$h({}, getProperties(props), {
      id: props.id,
      groupId: props.groupId,
      path: props.path,
      actions: props.actions,
      config: props.config,
      reordableNodesCnt: props.reordableNodesCnt,
      totalRulesCnt: props.totalRulesCnt,
      onDragStart: props.onDragStart,
      isDraggingTempo: props.isDraggingTempo,
      children1: props.children1,
      parentField: null,
      parentReordableNodesCnt: props.parentReordableNodesCnt
    }));
  },
  case_group: function case_group(props) {
    return /* @__PURE__ */ React.createElement(CaseGroup$1, _extends$h({}, getProperties(props), {
      id: props.id,
      groupId: props.groupId,
      path: props.path,
      actions: props.actions,
      config: props.config,
      reordableNodesCnt: props.reordableNodesCnt,
      totalRulesCnt: props.totalRulesCnt,
      onDragStart: props.onDragStart,
      isDraggingTempo: props.isDraggingTempo,
      children1: props.children1,
      parentField: null,
      parentReordableNodesCnt: props.parentReordableNodesCnt
    }));
  }
};
var Item = /* @__PURE__ */ function(_PureComponent) {
  _inherits$b(Item2, _PureComponent);
  var _super = _createSuper$5(Item2);
  function Item2() {
    _classCallCheck$b(this, Item2);
    return _super.apply(this, arguments);
  }
  _createClass$9(Item2, [{
    key: "render",
    value: function render3() {
      var _props$properties2;
      var _this$props = this.props, type2 = _this$props.type, props = _objectWithoutProperties$2(_this$props, _excluded$4);
      var mode = (_props$properties2 = props.properties) === null || _props$properties2 === void 0 ? void 0 : _props$properties2.get("mode");
      var postfix = mode == "array" ? "_ext" : "";
      var renderItem = props.config.settings.renderItem;
      var Cmp = typeMap[type2 + postfix];
      if (renderItem) {
        return renderItem(_objectSpread$8(_objectSpread$8({}, props), {}, {
          type: type2,
          itemComponent: Cmp
        }));
      }
      if (!Cmp)
        return null;
      return Cmp(props);
    }
  }]);
  return Item2;
}(reactExports.PureComponent);
Item.propTypes = {
  //tree: PropTypes.instanceOf(Immutable.Map).isRequired,
  config: PropTypes.object.isRequired,
  id: PropTypes.string.isRequired,
  groupId: PropTypes.string,
  type: PropTypes.oneOf(types$3).isRequired,
  path: PropTypes.any.isRequired,
  //instanceOf(Immutable.List)
  properties: PropTypes.any.isRequired,
  //instanceOf(Immutable.Map)
  children1: PropTypes.any,
  //instanceOf(Immutable.OrderedMap)
  actions: PropTypes.object.isRequired,
  reordableNodesCnt: PropTypes.number,
  onDragStart: PropTypes.func,
  parentField: PropTypes.string,
  //from RuleGroup
  isDraggingTempo: PropTypes.bool,
  isParentLocked: PropTypes.bool
};
function _createSuper$4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct$4() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var _Utils$TreeUtils = Utils$1.TreeUtils, getTotalReordableNodesCountInTree2 = _Utils$TreeUtils.getTotalReordableNodesCountInTree, getTotalRulesCountInTree2 = _Utils$TreeUtils.getTotalRulesCountInTree;
var _Utils$DefaultUtils = Utils$1.DefaultUtils, createListFromArray2 = _Utils$DefaultUtils.createListFromArray, emptyProperies2 = _Utils$DefaultUtils.emptyProperies;
var Builder = /* @__PURE__ */ function(_Component) {
  _inherits$b(Builder2, _Component);
  var _super = _createSuper$4(Builder2);
  function Builder2(props) {
    var _this;
    _classCallCheck$b(this, Builder2);
    _this = _super.call(this, props);
    _this.pureShouldComponentUpdate = pureShouldComponentUpdate(_assertThisInitialized$1(_this));
    _this._updPath(props);
    return _this;
  }
  _createClass$9(Builder2, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps, nextState) {
      var prevProps = this.props;
      var should = this.pureShouldComponentUpdate(nextProps, nextState);
      if (should) {
        var chs = [];
        for (var k2 in nextProps) {
          var changed = nextProps[k2] !== prevProps[k2];
          if (changed && k2 != "__isInternalValueChange") {
            chs.push(k2);
          }
        }
        if (!chs.length)
          should = false;
        if (chs.length == 1 && chs[0] == "tree" && nextProps.__isInternalValueChange)
          should = false;
      }
      return should;
    }
  }, {
    key: "_updPath",
    value: function _updPath(props) {
      var id = props.tree.get("id");
      this.path = createListFromArray2([id]);
    }
  }, {
    key: "render",
    value: function render3() {
      var tree2 = this.props.tree;
      var rootType = tree2.get("type");
      var isTernary = rootType == "switch_group";
      var reordableNodesCnt = isTernary ? null : getTotalReordableNodesCountInTree2(tree2);
      var totalRulesCnt = isTernary ? null : getTotalRulesCountInTree2(tree2);
      var id = tree2.get("id");
      return /* @__PURE__ */ React.createElement(Item, {
        key: id,
        id,
        path: this.path,
        type: rootType,
        properties: tree2.get("properties") || emptyProperies2(),
        config: this.props.config,
        actions: this.props.actions,
        children1: tree2.get("children1") || emptyProperies2(),
        reordableNodesCnt,
        totalRulesCnt,
        parentReordableNodesCnt: 0,
        onDragStart: this.props.onDragStart
      });
    }
  }]);
  return Builder2;
}(reactExports.Component);
Builder.propTypes = {
  tree: PropTypes.any.isRequired,
  //instanceOf(Immutable.Map)
  config: PropTypes.object.isRequired,
  actions: PropTypes.object.isRequired,
  onDragStart: PropTypes.func
};
const Builder$1 = SortableContainer(Builder);
function ownKeys$7(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$7(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$7(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$7(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var clone$1 = Utils$1.clone;
var getFieldConfig$1 = Utils$1.ConfigUtils.getFieldConfig;
var _Utils$RuleUtils$1 = Utils$1.RuleUtils, getFieldPath$1 = _Utils$RuleUtils$1.getFieldPath, getFieldPathLabels2 = _Utils$RuleUtils$1.getFieldPathLabels, getWidgetForFieldOp$1 = _Utils$RuleUtils$1.getWidgetForFieldOp;
var ValueField = /* @__PURE__ */ function(_Component) {
  _inherits$b(ValueField2, _Component);
  var _super = _createSuper$3(ValueField2);
  function ValueField2(props) {
    var _this;
    _classCallCheck$b(this, ValueField2);
    _this = _super.call(this, props);
    useOnPropsChanged(_assertThisInitialized$1(_this));
    _this.onPropsChanged(props);
    return _this;
  }
  _createClass$9(ValueField2, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var prevProps = this.props;
      var keysForItems = ["config", "field", "operator", "isFuncArg", "parentField"];
      var keysForMeta = ["config", "field", "operator", "value", "placeholder", "isFuncArg", "parentField"];
      var needUpdateItems = !this.items || keysForItems.map(function(k2) {
        return nextProps[k2] !== prevProps[k2];
      }).filter(function(ch) {
        return ch;
      }).length > 0;
      var needUpdateMeta = !this.meta || keysForMeta.map(function(k2) {
        return nextProps[k2] !== prevProps[k2];
      }).filter(function(ch) {
        return ch;
      }).length > 0;
      if (needUpdateItems) {
        this.items = this.getItems(nextProps);
      }
      if (needUpdateMeta) {
        this.meta = this.getMeta(nextProps);
      }
    }
  }, {
    key: "getItems",
    value: function getItems(_ref) {
      var config2 = _ref.config, field = _ref.field, operator = _ref.operator, parentField = _ref.parentField, isFuncArg = _ref.isFuncArg, fieldDefinition = _ref.fieldDefinition;
      var canCompareFieldWithField2 = config2.settings.canCompareFieldWithField;
      var fieldSeparator = config2.settings.fieldSeparator;
      var parentFieldPath = typeof parentField == "string" ? parentField.split(fieldSeparator) : parentField;
      var parentFieldConfig = parentField ? getFieldConfig$1(config2, parentField) : null;
      var sourceFields = parentField ? parentFieldConfig && parentFieldConfig.subfields : config2.fields;
      var filteredFields = this.filterFields(config2, sourceFields, field, parentField, parentFieldPath, operator, canCompareFieldWithField2, isFuncArg, fieldDefinition);
      var items = this.buildOptions(parentFieldPath, config2, filteredFields, parentFieldPath);
      return items;
    }
  }, {
    key: "getMeta",
    value: function getMeta(_ref2) {
      var config2 = _ref2.config, field = _ref2.field;
      _ref2.operator;
      var value = _ref2.value, customPlaceholder = _ref2.placeholder, isFuncArg = _ref2.isFuncArg, parentField = _ref2.parentField;
      var _config$settings = config2.settings, fieldPlaceholder = _config$settings.fieldPlaceholder, fieldSeparatorDisplay = _config$settings.fieldSeparatorDisplay;
      var selectedKey = value;
      var isFieldSelected = !!value;
      var leftFieldConfig = getFieldConfig$1(config2, field);
      var leftFieldWidgetField = leftFieldConfig.widgets.field;
      var leftFieldWidgetFieldProps = leftFieldWidgetField && leftFieldWidgetField.widgetProps || {};
      var placeholder2 = isFieldSelected ? null : isFuncArg && customPlaceholder || leftFieldWidgetFieldProps.valuePlaceholder || fieldPlaceholder;
      var currField = isFieldSelected ? getFieldConfig$1(config2, selectedKey) : null;
      var selectedOpts = currField || {};
      var selectedKeys = getFieldPath$1(selectedKey, config2);
      var selectedPath = getFieldPath$1(selectedKey, config2, true);
      var selectedLabel = this.getFieldLabel(currField, selectedKey, config2);
      var partsLabels = getFieldPathLabels2(selectedKey, config2);
      var selectedFullLabel = partsLabels ? partsLabels.join(fieldSeparatorDisplay) : null;
      if (selectedFullLabel == selectedLabel || parentField)
        selectedFullLabel = null;
      var selectedAltLabel = selectedOpts.label2;
      return {
        placeholder: placeholder2,
        selectedKey,
        selectedKeys,
        selectedPath,
        selectedLabel,
        selectedOpts,
        selectedAltLabel,
        selectedFullLabel
      };
    }
  }, {
    key: "filterFields",
    value: function filterFields(config2, fields, leftFieldFullkey, parentField, parentFieldPath, operator, canCompareFieldWithField2, isFuncArg, fieldDefinition) {
      fields = clone$1(fields);
      var fieldSeparator = config2.settings.fieldSeparator;
      var leftFieldConfig = getFieldConfig$1(config2, leftFieldFullkey);
      var widget = getWidgetForFieldOp$1(config2, leftFieldFullkey, operator, "value");
      config2.widgets[widget];
      var expectedType;
      if (isFuncArg && fieldDefinition) {
        expectedType = fieldDefinition.type;
      } else {
        expectedType = leftFieldConfig.type;
      }
      function _filter(list2, path) {
        for (var rightFieldKey in list2) {
          var subfields = list2[rightFieldKey].subfields;
          var subpath = (path ? path : []).concat(rightFieldKey);
          var rightFieldFullkey = subpath.join(fieldSeparator);
          var rightFieldConfig = getFieldConfig$1(config2, rightFieldFullkey);
          if (!rightFieldConfig) {
            delete list2[rightFieldKey];
          } else if (rightFieldConfig.type == "!struct" || rightFieldConfig.type == "!group") {
            if (_filter(subfields, subpath) == 0)
              delete list2[rightFieldKey];
          } else {
            var canUse = rightFieldConfig.type == expectedType && (isFuncArg ? true : rightFieldFullkey != leftFieldFullkey);
            var fn = canCompareFieldWithField2 || config2.settings.canCompareFieldWithField;
            if (fn)
              canUse = canUse && fn(leftFieldFullkey, leftFieldConfig, rightFieldFullkey, rightFieldConfig, operator);
            if (!canUse)
              delete list2[rightFieldKey];
          }
        }
        return keys$8(list2).length;
      }
      _filter(fields, parentFieldPath || []);
      return fields;
    }
  }, {
    key: "buildOptions",
    value: function buildOptions3(parentFieldPath, config2, fields) {
      var _this2 = this;
      var path = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      var optGroupLabel = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
      if (!fields)
        return null;
      var _config$settings2 = config2.settings, fieldSeparator = _config$settings2.fieldSeparator, fieldSeparatorDisplay = _config$settings2.fieldSeparatorDisplay;
      var prefix = path ? path.join(fieldSeparator) + fieldSeparator : "";
      return keys$8(fields).map(function(fieldKey) {
        var field = fields[fieldKey];
        var label2 = _this2.getFieldLabel(field, fieldKey, config2);
        var partsLabels = getFieldPathLabels2(fieldKey, config2);
        var fullLabel = partsLabels.join(fieldSeparatorDisplay);
        if (fullLabel == label2 || parentFieldPath)
          fullLabel = null;
        var altLabel = field.label2;
        var tooltip = field.tooltip;
        var subpath = (path ? path : []).concat(fieldKey);
        if (field.hideForCompare)
          return void 0;
        if (field.type == "!struct" || field.type == "!group") {
          return {
            key: fieldKey,
            path: prefix + fieldKey,
            label: label2,
            fullLabel,
            altLabel,
            tooltip,
            items: _this2.buildOptions(parentFieldPath, config2, field.subfields, subpath, label2)
          };
        } else {
          return {
            key: fieldKey,
            path: prefix + fieldKey,
            label: label2,
            fullLabel,
            altLabel,
            tooltip,
            grouplabel: optGroupLabel
          };
        }
      }).filter(function(o) {
        return !!o;
      });
    }
  }, {
    key: "getFieldLabel",
    value: function getFieldLabel(fieldOpts, fieldKey, config2) {
      if (!fieldKey)
        return null;
      var fieldSeparator = config2.settings.fieldSeparator;
      var maxLabelsLength = config2.settings.maxLabelsLength;
      var fieldParts = Array.isArray(fieldKey) ? fieldKey : fieldKey.split(fieldSeparator);
      var label2 = fieldOpts.label || last$2(fieldParts);
      label2 = truncateString(label2, maxLabelsLength);
      return label2;
    }
  }, {
    key: "render",
    value: function render3() {
      var _this$props = this.props, config2 = _this$props.config, customProps = _this$props.customProps, setValue4 = _this$props.setValue, readonly = _this$props.readonly, id = _this$props.id, groupId = _this$props.groupId;
      var renderField3 = config2.settings.renderField;
      var renderProps = _objectSpread$7({
        config: config2,
        customProps,
        setField: setValue4,
        readonly,
        items: this.items,
        id,
        groupId
      }, this.meta);
      return renderField3(renderProps);
    }
  }]);
  return ValueField2;
}(reactExports.Component);
ValueField.propTypes = {
  id: PropTypes.string,
  groupId: PropTypes.string,
  setValue: PropTypes.func.isRequired,
  config: PropTypes.object.isRequired,
  field: PropTypes.string.isRequired,
  value: PropTypes.string,
  operator: PropTypes.string,
  customProps: PropTypes.object,
  readonly: PropTypes.bool,
  parentField: PropTypes.string,
  fieldDefinition: PropTypes.object,
  isFuncArg: PropTypes.bool
};
function ownKeys$6(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$6(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$6(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var clone2 = Utils$1.clone;
var _Utils$ConfigUtils = Utils$1.ConfigUtils, getFieldConfig2 = _Utils$ConfigUtils.getFieldConfig, getFuncConfig$1 = _Utils$ConfigUtils.getFuncConfig;
var _Utils$RuleUtils = Utils$1.RuleUtils, getFieldPath2 = _Utils$RuleUtils.getFieldPath, getFuncPathLabels2 = _Utils$RuleUtils.getFuncPathLabels, getWidgetForFieldOp2 = _Utils$RuleUtils.getWidgetForFieldOp;
var FuncSelect = /* @__PURE__ */ function(_Component) {
  _inherits$b(FuncSelect2, _Component);
  var _super = _createSuper$2(FuncSelect2);
  function FuncSelect2(props) {
    var _this;
    _classCallCheck$b(this, FuncSelect2);
    _this = _super.call(this, props);
    useOnPropsChanged(_assertThisInitialized$1(_this));
    _this.onPropsChanged(props);
    return _this;
  }
  _createClass$9(FuncSelect2, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var prevProps = this.props;
      var keysForItems = ["config", "field", "operator", "isFuncArg"];
      var keysForMeta = ["config", "field", "value"];
      var needUpdateItems = !this.items || keysForItems.map(function(k2) {
        return nextProps[k2] !== prevProps[k2];
      }).filter(function(ch) {
        return ch;
      }).length > 0;
      var needUpdateMeta = !this.meta || keysForMeta.map(function(k2) {
        return nextProps[k2] !== prevProps[k2];
      }).filter(function(ch) {
        return ch;
      }).length > 0;
      if (needUpdateMeta) {
        this.meta = this.getMeta(nextProps);
      }
      if (needUpdateItems) {
        this.items = this.getItems(nextProps);
      }
    }
  }, {
    key: "getItems",
    value: function getItems(_ref) {
      var config2 = _ref.config, field = _ref.field, operator = _ref.operator, parentFuncs = _ref.parentFuncs, fieldDefinition = _ref.fieldDefinition, isFuncArg = _ref.isFuncArg;
      var canUseFuncForField = config2.settings.canUseFuncForField;
      var filteredFuncs = this.filterFuncs(config2, config2.funcs, field, operator, canUseFuncForField, parentFuncs, isFuncArg, fieldDefinition);
      var items = this.buildOptions(config2, filteredFuncs);
      return items;
    }
  }, {
    key: "getMeta",
    value: function getMeta(_ref2) {
      var config2 = _ref2.config, field = _ref2.field, value = _ref2.value;
      var _config$settings = config2.settings, funcPlaceholder = _config$settings.funcPlaceholder, fieldSeparatorDisplay = _config$settings.fieldSeparatorDisplay;
      var selectedFuncKey = value;
      var isFuncSelected = !!value;
      var leftFieldConfig = getFieldConfig2(config2, field);
      var leftFieldWidgetField = leftFieldConfig.widgets.field;
      leftFieldWidgetField && leftFieldWidgetField.widgetProps || {};
      var placeholder2 = !isFuncSelected ? funcPlaceholder : null;
      var currFunc = isFuncSelected ? getFuncConfig$1(config2, selectedFuncKey) : null;
      var selectedOpts = currFunc || {};
      var selectedKeys = getFieldPath2(selectedFuncKey, config2);
      var selectedPath = getFieldPath2(selectedFuncKey, config2, true);
      var selectedLabel = this.getFuncLabel(currFunc, selectedFuncKey, config2);
      var partsLabels = getFuncPathLabels2(selectedFuncKey, config2);
      var selectedFullLabel = partsLabels ? partsLabels.join(fieldSeparatorDisplay) : null;
      if (selectedFullLabel == selectedLabel)
        selectedFullLabel = null;
      return {
        placeholder: placeholder2,
        selectedKey: selectedFuncKey,
        selectedKeys,
        selectedPath,
        selectedLabel,
        selectedOpts,
        selectedFullLabel
      };
    }
  }, {
    key: "filterFuncs",
    value: function filterFuncs(config2, funcs2, leftFieldFullkey, operator, canUseFuncForField, parentFuncs, isFuncArg, fieldDefinition) {
      funcs2 = clone2(funcs2);
      var fieldSeparator = config2.settings.fieldSeparator;
      var leftFieldConfig = getFieldConfig2(config2, leftFieldFullkey);
      var expectedType;
      var targetDefinition = leftFieldConfig;
      var widget = getWidgetForFieldOp2(config2, leftFieldFullkey, operator, "value");
      if (isFuncArg && fieldDefinition) {
        targetDefinition = fieldDefinition;
        expectedType = fieldDefinition.type;
      } else if (widget) {
        var widgetConfig = config2.widgets[widget];
        var widgetType = widgetConfig.type;
        expectedType = widgetType;
      } else {
        expectedType = leftFieldConfig.type;
      }
      function _filter(list2, path) {
        for (var funcKey in list2) {
          var subfields = list2[funcKey].subfields;
          var subpath = (path ? path : []).concat(funcKey);
          var funcFullkey = subpath.join(fieldSeparator);
          var funcConfig = getFuncConfig$1(config2, funcFullkey);
          if (funcConfig.type == "!struct") {
            if (_filter(subfields, subpath) == 0)
              delete list2[funcKey];
          } else {
            var canUse = funcConfig.returnType == expectedType;
            if (targetDefinition.funcs)
              canUse = canUse && targetDefinition.funcs.includes(funcFullkey);
            if (canUseFuncForField)
              canUse = canUse && canUseFuncForField(leftFieldFullkey, leftFieldConfig, funcFullkey, funcConfig, operator);
            if (!funcConfig.allowSelfNesting && parentFuncs && parentFuncs.map(function(_ref3) {
              var _ref4 = _slicedToArray$1(_ref3, 2), func = _ref4[0];
              _ref4[1];
              return func;
            }).includes(funcFullkey))
              canUse = false;
            if (!canUse)
              delete list2[funcKey];
          }
        }
        return keys$8(list2).length;
      }
      _filter(funcs2, []);
      return funcs2;
    }
  }, {
    key: "buildOptions",
    value: function buildOptions3(config2, funcs2) {
      var _this2 = this;
      var path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      var optGroupLabel = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      if (!funcs2)
        return null;
      var _config$settings2 = config2.settings, fieldSeparator = _config$settings2.fieldSeparator, fieldSeparatorDisplay = _config$settings2.fieldSeparatorDisplay;
      var prefix = path ? path.join(fieldSeparator) + fieldSeparator : "";
      return keys$8(funcs2).map(function(funcKey) {
        var func = funcs2[funcKey];
        var label2 = _this2.getFuncLabel(func, funcKey, config2);
        var partsLabels = getFuncPathLabels2(funcKey, config2);
        var fullLabel = partsLabels.join(fieldSeparatorDisplay);
        if (fullLabel == label2)
          fullLabel = null;
        var tooltip = func.tooltip;
        var subpath = (path ? path : []).concat(funcKey);
        if (func.type == "!struct") {
          return {
            key: funcKey,
            path: prefix + funcKey,
            label: label2,
            fullLabel,
            tooltip,
            items: _this2.buildOptions(config2, func.subfields, subpath, label2)
          };
        } else {
          return {
            key: funcKey,
            path: prefix + funcKey,
            label: label2,
            fullLabel,
            tooltip,
            grouplabel: optGroupLabel
          };
        }
      });
    }
  }, {
    key: "getFuncLabel",
    value: function getFuncLabel(funcOpts, funcKey, config2) {
      if (!funcKey)
        return null;
      var fieldSeparator = config2.settings.fieldSeparator;
      var maxLabelsLength = config2.settings.maxLabelsLength;
      var funcParts = Array.isArray(funcKey) ? funcKey : funcKey.split(fieldSeparator);
      var label2 = funcOpts.label || last$2(funcParts);
      label2 = truncateString(label2, maxLabelsLength);
      return label2;
    }
  }, {
    key: "render",
    value: function render3() {
      var _this$props = this.props, config2 = _this$props.config, customProps = _this$props.customProps, setValue4 = _this$props.setValue, readonly = _this$props.readonly, id = _this$props.id, groupId = _this$props.groupId;
      var renderFunc3 = config2.settings.renderFunc;
      var renderProps = _objectSpread$6({
        config: config2,
        customProps,
        readonly,
        setField: setValue4,
        items: this.items,
        id,
        groupId
      }, this.meta);
      return renderFunc3(renderProps);
    }
  }]);
  return FuncSelect2;
}(reactExports.Component);
FuncSelect.propTypes = {
  id: PropTypes.string,
  groupId: PropTypes.string,
  config: PropTypes.object.isRequired,
  field: PropTypes.string.isRequired,
  operator: PropTypes.string,
  customProps: PropTypes.object,
  value: PropTypes.string,
  setValue: PropTypes.func.isRequired,
  readonly: PropTypes.bool,
  parentFuncs: PropTypes.array,
  fieldDefinition: PropTypes.object,
  isFuncArg: PropTypes.bool
};
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var getFuncConfig2 = Utils$1.ConfigUtils.getFuncConfig;
var _Utils$FuncUtils = Utils$1.FuncUtils, setFunc2 = _Utils$FuncUtils.setFunc, setArgValue2 = _Utils$FuncUtils.setArgValue, setArgValueSrc2 = _Utils$FuncUtils.setArgValueSrc;
var FuncWidget$1 = /* @__PURE__ */ function(_Component) {
  _inherits$b(FuncWidget2, _Component);
  var _super = _createSuper$1(FuncWidget2);
  function FuncWidget2(props) {
    var _this;
    _classCallCheck$b(this, FuncWidget2);
    _this = _super.call(this, props);
    _this.setFunc = function(funcKey) {
      _this.props.setValue(setFunc2(_this.props.value, funcKey, _this.props.config));
    };
    _this.setArgValue = function(argKey, argVal) {
      var config2 = _this.props.config;
      var funcDefinition = _this.meta.funcDefinition;
      var args = funcDefinition.args;
      var argDefinition = args[argKey];
      _this.props.setValue(setArgValue2(_this.props.value, argKey, argVal, argDefinition, config2));
    };
    _this.setArgValueSrc = function(argKey, argValSrc) {
      var config2 = _this.props.config;
      var funcDefinition = _this.meta.funcDefinition;
      var args = funcDefinition.args;
      var argDefinition = args[argKey];
      _this.props.setValue(setArgValueSrc2(_this.props.value, argKey, argValSrc, argDefinition, config2));
    };
    _this.renderFuncSelect = function() {
      var _this$props = _this.props, config2 = _this$props.config, field = _this$props.field, operator = _this$props.operator, customProps = _this$props.customProps, value = _this$props.value, readonly = _this$props.readonly, parentFuncs = _this$props.parentFuncs, id = _this$props.id, groupId = _this$props.groupId, isFuncArg = _this$props.isFuncArg, fieldDefinition = _this$props.fieldDefinition;
      var funcKey = value ? value.get("func") : null;
      var selectProps = {
        value: funcKey,
        setValue: _this.setFunc,
        config: config2,
        field,
        operator,
        customProps,
        readonly,
        parentFuncs,
        isFuncArg,
        fieldDefinition,
        id,
        groupId
      };
      var _config$settings = config2.settings, showLabels = _config$settings.showLabels, funcLabel = _config$settings.funcLabel;
      var widgetLabel = showLabels ? /* @__PURE__ */ React.createElement("label", {
        className: "rule--label"
      }, funcLabel) : null;
      return /* @__PURE__ */ React.createElement(Col, {
        key: "func",
        className: "rule--func"
      }, widgetLabel, /* @__PURE__ */ React.createElement(FuncSelect, selectProps));
    };
    _this.renderArgLabel = function(argKey, argDefinition) {
      var valueSources = argDefinition.valueSources, type2 = argDefinition.type, showPrefix = argDefinition.showPrefix, label2 = argDefinition.label;
      var config2 = _this.props.config;
      var isConst = valueSources && valueSources.length == 1 && valueSources[0] == "const";
      var forceShow = !config2.settings.showLabels && (type2 == "boolean" || isConst) && showPrefix;
      if (!forceShow)
        return null;
      return /* @__PURE__ */ React.createElement(Col, {
        className: "rule--func--arg-label"
      }, label2 || argKey);
    };
    _this.renderArgLabelSep = function(argKey, argDefinition) {
      var valueSources = argDefinition.valueSources, type2 = argDefinition.type, showPrefix = argDefinition.showPrefix;
      var config2 = _this.props.config;
      var isConst = valueSources && valueSources.length == 1 && valueSources[0] == "const";
      var forceShow = !config2.settings.showLabels && (type2 == "boolean" || isConst) && showPrefix;
      if (!forceShow)
        return null;
      return /* @__PURE__ */ React.createElement(Col, {
        className: "rule--func--arg-label-sep"
      }, ":");
    };
    _this.renderArgVal = function(funcKey, argKey, argDefinition) {
      var _this$props2 = _this.props, config2 = _this$props2.config, field = _this$props2.field;
      _this$props2.operator;
      var value = _this$props2.value, readonly = _this$props2.readonly, parentFuncs = _this$props2.parentFuncs, id = _this$props2.id, groupId = _this$props2.groupId;
      var arg = value ? value.getIn(["args", argKey]) : null;
      var argVal = arg ? arg.get("value") : void 0;
      var defaultValueSource = argDefinition.valueSources.length == 1 ? argDefinition.valueSources[0] : void 0;
      var argValSrc = arg ? arg.get("valueSrc") || defaultValueSource || "value" : defaultValueSource;
      var widgetProps = {
        config: config2,
        fieldFunc: funcKey,
        fieldArg: argKey,
        leftField: field,
        operator: null,
        value: argVal,
        valueSrc: argValSrc,
        setValue: _this.setArgValue,
        setValueSrc: _this.setArgValueSrc,
        funcKey,
        argKey,
        argDefinition,
        readonly,
        parentFuncs,
        id,
        groupId
      };
      return /* @__PURE__ */ React.createElement(Col, {
        className: "rule--func--arg-value"
      }, /* @__PURE__ */ React.createElement(ArgWidget, widgetProps));
    };
    _this.renderArgSep = function(argKey, argDefinition, argIndex, _ref) {
      var renderSeps = _ref.renderSeps;
      if (!argIndex)
        return null;
      return /* @__PURE__ */ React.createElement(Col, {
        className: "rule--func--arg-sep"
      }, renderSeps ? renderSeps[argIndex - 1] : ", ");
    };
    _this.renderBracketBefore = function(_ref2) {
      var renderBrackets = _ref2.renderBrackets;
      return /* @__PURE__ */ React.createElement(Col, {
        key: "before_args",
        className: "rule--func--bracket-before"
      }, renderBrackets ? renderBrackets[0] : "(");
    };
    _this.renderBracketAfter = function(_ref3) {
      var renderBrackets = _ref3.renderBrackets;
      return /* @__PURE__ */ React.createElement(Col, {
        key: "after_args",
        className: "rule--func--bracket-after"
      }, renderBrackets ? renderBrackets[1] : ")");
    };
    _this.renderFuncArgs = function() {
      var _this$meta = _this.meta, funcDefinition = _this$meta.funcDefinition, funcKey = _this$meta.funcKey;
      if (!funcKey)
        return null;
      var args = funcDefinition.args;
      if (!args)
        return null;
      return /* @__PURE__ */ React.createElement(React.Fragment, null, _this.renderBracketBefore(funcDefinition), /* @__PURE__ */ React.createElement(Col, {
        key: "args",
        className: "rule--func--args"
      }, Object.keys(args).map(function(argKey, argIndex) {
        return /* @__PURE__ */ React.createElement(Col, {
          key: "arg-".concat(argKey, "-").concat(argIndex),
          className: "rule--func--arg"
        }, _this.renderArgSep(argKey, args[argKey], argIndex, funcDefinition), _this.renderArgLabel(argKey, args[argKey]), _this.renderArgLabelSep(argKey, args[argKey]), _this.renderArgVal(funcKey, argKey, args[argKey]));
      })), _this.renderBracketAfter(funcDefinition));
    };
    useOnPropsChanged(_assertThisInitialized$1(_this));
    _this.onPropsChanged(props);
    return _this;
  }
  _createClass$9(FuncWidget2, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var prevProps = this.props;
      var keysForMeta = ["config", "field", "operator", "value"];
      var needUpdateMeta = !this.meta || keysForMeta.map(function(k2) {
        return nextProps[k2] !== prevProps[k2];
      }).filter(function(ch) {
        return ch;
      }).length > 0;
      if (needUpdateMeta) {
        this.meta = this.getMeta(nextProps);
      }
    }
  }, {
    key: "getMeta",
    value: function getMeta(_ref4) {
      var config2 = _ref4.config;
      _ref4.field;
      _ref4.operator;
      var value = _ref4.value;
      var funcKey = value ? value.get("func") : null;
      var funcDefinition = funcKey ? getFuncConfig2(config2, funcKey) : null;
      return {
        funcDefinition,
        funcKey
      };
    }
  }, {
    key: "render",
    value: function render3() {
      return /* @__PURE__ */ React.createElement(Col, {
        className: "rule--func--wrapper"
      }, this.renderFuncSelect(), this.renderFuncArgs());
    }
  }]);
  return FuncWidget2;
}(reactExports.Component);
FuncWidget$1.propTypes = {
  id: PropTypes.string,
  groupId: PropTypes.string,
  config: PropTypes.object.isRequired,
  field: PropTypes.string.isRequired,
  operator: PropTypes.string,
  customProps: PropTypes.object,
  value: PropTypes.object,
  //instanceOf(Immutable.Map) //with keys 'func' and `args`
  setValue: PropTypes.func.isRequired,
  readonly: PropTypes.bool,
  parentFuncs: PropTypes.array,
  fieldDefinition: PropTypes.object,
  isFuncArg: PropTypes.bool
};
var ArgWidget = /* @__PURE__ */ function(_PureComponent) {
  _inherits$b(ArgWidget2, _PureComponent);
  var _super2 = _createSuper$1(ArgWidget2);
  function ArgWidget2() {
    var _this2;
    _classCallCheck$b(this, ArgWidget2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super2.call.apply(_super2, [this].concat(args));
    _this2.setValue = function(_delta, value, _widgetType) {
      var _this2$props = _this2.props, setValue4 = _this2$props.setValue, argKey = _this2$props.argKey;
      setValue4(argKey, value);
    };
    _this2.setValueSrc = function(_delta, valueSrc, _widgetType) {
      var _this2$props2 = _this2.props, setValueSrc4 = _this2$props2.setValueSrc, argKey = _this2$props2.argKey;
      setValueSrc4(argKey, valueSrc);
    };
    return _this2;
  }
  _createClass$9(ArgWidget2, [{
    key: "render",
    value: function render3() {
      var _this$props3 = this.props, funcKey = _this$props3.funcKey, argKey = _this$props3.argKey, parentFuncs = _this$props3.parentFuncs;
      return /* @__PURE__ */ React.createElement(Widget, _extends$h({}, this.props, {
        setValue: this.setValue,
        setValueSrc: this.setValueSrc,
        isFuncArg: true,
        parentFuncs: [].concat(_toConsumableArray(parentFuncs || []), [[funcKey, argKey]])
      }));
    }
  }]);
  return ArgWidget2;
}(reactExports.PureComponent);
ArgWidget.propTypes = {
  funcKey: PropTypes.string.isRequired,
  argKey: PropTypes.string.isRequired,
  setValue: PropTypes.func.isRequired,
  setValueSrc: PropTypes.func.isRequired,
  readonly: PropTypes.bool,
  parentFuncs: PropTypes.array,
  id: PropTypes.string,
  groupId: PropTypes.string
};
var uuid = Utils$1.uuid;
const VanillaBoolean = function(props) {
  var value = props.value, setValue4 = props.setValue;
  props.config;
  var labelYes = props.labelYes, labelNo = props.labelNo, readonly = props.readonly, _props$customProps = props.customProps, customProps = _props$customProps === void 0 ? {} : _props$customProps;
  var customRadioYesProps = customProps.radioYes || {};
  var customRadioNoProps = customProps.radioNo || {};
  var onRadioChange = function onRadioChange2(e2) {
    return setValue4(e2.target.value == "true");
  };
  var id = uuid(), id2 = uuid();
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("input", _extends$h({
    key: id,
    type: "radio",
    id,
    value: true,
    checked: !!value,
    disabled: readonly,
    onChange: onRadioChange
  }, customRadioYesProps)), /* @__PURE__ */ React.createElement("label", {
    style: {
      display: "inline"
    },
    key: id + "label",
    htmlFor: id
  }, labelYes), /* @__PURE__ */ React.createElement("input", _extends$h({
    key: id2,
    type: "radio",
    id: id2,
    value: false,
    checked: !value,
    disabled: readonly,
    onChange: onRadioChange
  }, customRadioNoProps)), /* @__PURE__ */ React.createElement("label", {
    style: {
      display: "inline"
    },
    key: id2 + "label",
    htmlFor: id2
  }, labelNo));
};
const VanillaText = function(props) {
  var value = props.value, setValue4 = props.setValue;
  props.config;
  var readonly = props.readonly, placeholder2 = props.placeholder, maxLength = props.maxLength, customProps = props.customProps;
  var onChange = function onChange2(e2) {
    var val = e2.target.value;
    if (val === "")
      val = void 0;
    setValue4(val);
  };
  var textValue = value || "";
  return /* @__PURE__ */ React.createElement("input", _extends$h({
    type: "text",
    value: textValue,
    placeholder: placeholder2,
    disabled: readonly,
    onChange,
    maxLength
  }, customProps));
};
const VanillaTextArea = function(props) {
  var value = props.value, setValue4 = props.setValue;
  props.config;
  var readonly = props.readonly, placeholder2 = props.placeholder, maxLength = props.maxLength;
  props.maxRows;
  var fullWidth2 = props.fullWidth, customProps = props.customProps;
  var onChange = function onChange2(e2) {
    var val = e2.target.value;
    if (val === "")
      val = void 0;
    setValue4(val);
  };
  var textValue = value || "";
  return /* @__PURE__ */ React.createElement("textarea", _extends$h({
    value: textValue,
    placeholder: placeholder2,
    disabled: readonly,
    onChange,
    maxLength,
    style: {
      width: fullWidth2 ? "100%" : void 0
    }
  }, customProps));
};
Utils$1.moment;
const VanillaDate = function(props) {
  var value = props.value, setValue4 = props.setValue;
  props.config;
  props.valueFormat;
  var readonly = props.readonly, customProps = props.customProps;
  var onChange = function onChange2(e2) {
    var value2 = e2.target.value;
    if (value2 == "")
      value2 = void 0;
    setValue4(value2);
  };
  return /* @__PURE__ */ React.createElement("input", _extends$h({
    type: "date",
    value: value || "",
    disabled: readonly,
    onChange
  }, customProps));
};
const VanillaTime = function(props) {
  var value = props.value, setValue4 = props.setValue;
  props.config;
  props.valueFormat;
  props.use12Hours;
  var readonly = props.readonly, customProps = props.customProps;
  var onChange = function onChange2(e2) {
    var value2 = e2.target.value;
    if (value2 == "")
      value2 = void 0;
    setValue4(value2);
  };
  return /* @__PURE__ */ React.createElement("input", _extends$h({
    type: "time",
    value: value || "",
    disabled: readonly,
    onChange
  }, customProps));
};
var moment$1 = Utils$1.moment;
const VanillaDateTime = function(props) {
  var value = props.value, setValue4 = props.setValue;
  props.config;
  var valueFormat = props.valueFormat;
  props.use12Hours;
  var readonly = props.readonly, customProps = props.customProps;
  var onChange = function onChange2(e2) {
    var value2 = e2.target.value;
    if (value2 == "")
      value2 = void 0;
    else
      value2 = moment$1(new Date(value2)).format(valueFormat);
    setValue4(value2);
  };
  var dtValue = value;
  if (!value)
    dtValue = "";
  else
    dtValue = moment$1(value).format("YYYY-MM-DDTHH:mm");
  return /* @__PURE__ */ React.createElement("input", _extends$h({
    type: "datetime-local",
    value: dtValue,
    disabled: readonly,
    onChange
  }, customProps));
};
var mapListValues$4 = Utils$1.ListUtils.mapListValues;
const VanillaMultiSelect = function(_ref) {
  var listValues2 = _ref.listValues, value = _ref.value, setValue4 = _ref.setValue;
  _ref.allowCustomValues;
  var readonly = _ref.readonly, customProps = _ref.customProps;
  var renderOptions = function renderOptions2() {
    return mapListValues$4(listValues2, function(_ref2) {
      var title2 = _ref2.title, value2 = _ref2.value;
      return /* @__PURE__ */ React.createElement("option", {
        key: value2,
        value: value2
      }, title2);
    });
  };
  var getMultiSelectValues = function getMultiSelectValues2(multiselect) {
    var values = [];
    var options = multiselect.options;
    for (var i2 = 0; i2 < options.length; i2++) {
      var opt = options[i2];
      if (opt.selected) {
        values.push(opt.value);
      }
    }
    if (!values.length)
      values = void 0;
    return values;
  };
  var onChange = function onChange2(e2) {
    return setValue4(getMultiSelectValues(e2.target));
  };
  return /* @__PURE__ */ React.createElement("select", _extends$h({
    multiple: true,
    onChange,
    value,
    disabled: readonly
  }, omit$1(customProps, ["showSearch", "input", "showCheckboxes"])), renderOptions());
};
var mapListValues$3 = Utils$1.ListUtils.mapListValues;
const VanillaSelect = function(_ref) {
  var listValues2 = _ref.listValues, value = _ref.value, setValue4 = _ref.setValue;
  _ref.allowCustomValues;
  var readonly = _ref.readonly, customProps = _ref.customProps;
  var renderOptions = function renderOptions2() {
    return mapListValues$3(listValues2, function(_ref2) {
      var title2 = _ref2.title, value2 = _ref2.value;
      return /* @__PURE__ */ React.createElement("option", {
        key: value2,
        value: value2
      }, title2);
    });
  };
  var onChange = function onChange2(e2) {
    return setValue4(e2.target.value);
  };
  var hasValue = value != null;
  return /* @__PURE__ */ React.createElement("select", _extends$h({
    onChange,
    value: hasValue ? value : "",
    disabled: readonly
  }, omit$1(customProps, ["showSearch", "input"])), !hasValue && /* @__PURE__ */ React.createElement("option", {
    disabled: true,
    value: ""
  }), renderOptions());
};
const VanillaNumber = function(props) {
  var value = props.value, setValue4 = props.setValue;
  props.config;
  var readonly = props.readonly, min2 = props.min, max2 = props.max, step = props.step, placeholder2 = props.placeholder, customProps = props.customProps;
  var onChange = function onChange2(e2) {
    var val = e2.target.value;
    if (val === "" || val === null)
      val = void 0;
    else
      val = Number(val);
    setValue4(val);
  };
  var numberValue = value == void 0 ? "" : value;
  return /* @__PURE__ */ React.createElement("input", _extends$h({
    type: "number",
    value: numberValue,
    placeholder: placeholder2,
    disabled: readonly,
    min: min2,
    max: max2,
    step,
    onChange
  }, customProps));
};
const VanillaSlider = function(props) {
  var value = props.value, setValue4 = props.setValue;
  props.config;
  var readonly = props.readonly, min2 = props.min, max2 = props.max, step = props.step, placeholder2 = props.placeholder, _props$customProps = props.customProps, customProps = _props$customProps === void 0 ? {} : _props$customProps;
  var customInputProps = customProps.input || {};
  var customSliderProps = customProps.slider || customProps;
  var onChange = function onChange2(e2) {
    var val = e2.target.value;
    if (val === "" || val === null)
      val = void 0;
    else
      val = Number(val);
    setValue4(val);
  };
  var numberValue = value == void 0 ? "" : value;
  return /* @__PURE__ */ React.createElement("div", {
    style: {
      display: "inline-flex"
    }
  }, /* @__PURE__ */ React.createElement("input", _extends$h({
    key: "number",
    type: "number",
    value: numberValue,
    placeholder: placeholder2,
    disabled: readonly,
    min: min2,
    max: max2,
    step,
    onChange
  }, customInputProps)), /* @__PURE__ */ React.createElement("input", _extends$h({
    key: "range",
    type: "range",
    value: numberValue,
    disabled: readonly,
    min: min2,
    max: max2,
    step,
    onChange
  }, customSliderProps)));
};
const VanillaFieldSelect$1 = function(_ref) {
  var items = _ref.items, setField4 = _ref.setField, selectedKey = _ref.selectedKey, readonly = _ref.readonly;
  var renderOptions = function renderOptions2(fields) {
    return fields.map(function(field) {
      var items2 = field.items, path = field.path, label2 = field.label, disabled = field.disabled;
      if (items2) {
        return /* @__PURE__ */ React.createElement("optgroup", {
          disabled,
          key: path,
          label: label2
        }, renderOptions2(items2));
      } else {
        return /* @__PURE__ */ React.createElement("option", {
          disabled,
          key: path,
          value: path
        }, label2);
      }
    });
  };
  var onChange = function onChange2(e2) {
    return setField4(e2.target.value);
  };
  var hasValue = selectedKey != null;
  return /* @__PURE__ */ React.createElement("select", {
    onChange,
    value: hasValue ? selectedKey : "",
    disabled: readonly
  }, !hasValue && /* @__PURE__ */ React.createElement("option", {
    disabled: true,
    value: ""
  }), renderOptions(items));
};
const VanillaConjs$1 = function(_ref) {
  var id = _ref.id, not = _ref.not, setNot4 = _ref.setNot, conjunctionOptions = _ref.conjunctionOptions, setConjunction4 = _ref.setConjunction, disabled = _ref.disabled, readonly = _ref.readonly, config2 = _ref.config, showNot = _ref.showNot, notLabel = _ref.notLabel;
  var conjsCount = Object.keys(conjunctionOptions).length;
  var lessThenTwo = disabled;
  var forceShowConj = config2.settings.forceShowConj;
  var showConj = forceShowConj || conjsCount > 1 && !lessThenTwo;
  var renderOptions = function renderOptions2() {
    return Object.keys(conjunctionOptions).map(function(key) {
      var _conjunctionOptions$k = conjunctionOptions[key], id2 = _conjunctionOptions$k.id, name = _conjunctionOptions$k.name, label2 = _conjunctionOptions$k.label, checked = _conjunctionOptions$k.checked;
      var postfix = setConjunction4.isDummyFn ? "__dummy" : "";
      if ((readonly || disabled) && !checked)
        return null;
      return [/* @__PURE__ */ React.createElement("input", {
        key: id2 + postfix,
        type: "radio",
        id: id2 + postfix,
        name: name + postfix,
        checked,
        disabled: readonly || disabled,
        value: key,
        onChange
      }), /* @__PURE__ */ React.createElement("label", {
        key: id2 + postfix + "label",
        htmlFor: id2 + postfix
      }, label2)];
    });
  };
  var renderNot = function renderNot2() {
    var postfix = "not";
    return [/* @__PURE__ */ React.createElement("input", {
      key: id + postfix,
      type: "checkbox",
      id: id + postfix,
      checked: not,
      disabled: readonly,
      onChange: onNotChange
    }), /* @__PURE__ */ React.createElement("label", {
      key: id + postfix + "label",
      htmlFor: id + postfix
    }, notLabel || "NOT")];
  };
  var onChange = function onChange2(e2) {
    return setConjunction4(e2.target.value);
  };
  var onNotChange = function onNotChange2(e2) {
    return setNot4(e2.target.checked);
  };
  return [showNot && renderNot(), showConj && renderOptions()];
};
const VanillaButton$1 = function(_ref) {
  var type2 = _ref.type, label2 = _ref.label, onClick = _ref.onClick, readonly = _ref.readonly;
  _ref.config;
  var typeToLabel = {
    "addRuleGroup": "+",
    "addRuleGroupExt": "+",
    "delGroup": "x",
    "delRuleGroup": "x",
    "delRule": "x"
  };
  var btnLabel = label2 || typeToLabel[type2];
  return /* @__PURE__ */ React.createElement("button", {
    onClick,
    type: "button",
    disabled: readonly
  }, btnLabel);
};
const VanillaButtonGroup$1 = function(_ref) {
  var children = _ref.children;
  _ref.config;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, children);
};
const VanillaValueSources$1 = function(_ref) {
  _ref.config;
  var valueSources = _ref.valueSources, valueSrc = _ref.valueSrc;
  _ref.title;
  var setValueSrc4 = _ref.setValueSrc, readonly = _ref.readonly;
  var renderOptions = function renderOptions2(valueSources2) {
    return valueSources2.map(function(_ref2) {
      var _ref3 = _slicedToArray$1(_ref2, 2), srcKey = _ref3[0], info = _ref3[1];
      return /* @__PURE__ */ React.createElement("option", {
        key: srcKey,
        value: srcKey
      }, info.label);
    });
  };
  var onChange = function onChange2(e2) {
    return setValueSrc4(e2.target.value);
  };
  return /* @__PURE__ */ React.createElement("select", {
    onChange,
    value: valueSrc,
    disabled: readonly
  }, renderOptions(valueSources));
};
const VanillaSwitch$1 = function(_ref) {
  var value = _ref.value, setValue4 = _ref.setValue, label2 = _ref.label, id = _ref.id;
  _ref.config;
  var type2 = _ref.type;
  var onChange = function onChange2(e2) {
    return setValue4(e2.target.checked);
  };
  var postfix = type2;
  return [/* @__PURE__ */ React.createElement("input", {
    key: id + postfix,
    type: "checkbox",
    id: id + postfix,
    checked: !!value,
    onChange
  }), /* @__PURE__ */ React.createElement("label", {
    key: id + postfix + "label",
    htmlFor: id + postfix
  }, label2)];
};
const vanillaConfirm$1 = function(_ref) {
  var onOk = _ref.onOk;
  _ref.okText;
  _ref.cancelText;
  var title2 = _ref.title;
  if (confirm(title2)) {
    onOk();
  }
};
var VanillaProvider$1 = function VanillaProvider(_ref) {
  _ref.config;
  var children = _ref.children;
  return children;
};
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var Proximity = /* @__PURE__ */ function(_PureComponent) {
  _inherits$b(Proximity2, _PureComponent);
  var _super = _createSuper(Proximity2);
  function Proximity2() {
    var _this;
    _classCallCheck$b(this, Proximity2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _this.handleChange = function(value) {
      _this.props.setOption("proximity", parseInt(value));
    };
    return _this;
  }
  _createClass$9(Proximity2, [{
    key: "render",
    value: function render3() {
      var _this$props = this.props, defaults2 = _this$props.defaults, options = _this$props.options, config2 = _this$props.config, optionLabel = _this$props.optionLabel, optionPlaceholder = _this$props.optionPlaceholder, customProps = _this$props.customProps, minProximity = _this$props.minProximity, maxProximity = _this$props.maxProximity, optionTextBefore = _this$props.optionTextBefore, readonly = _this$props.readonly;
      var settings2 = config2.settings, widgets2 = config2.widgets;
      var defaultProximity = defaults2 ? defaults2.proximity : void 0;
      var showLabels = settings2.showLabels;
      var selectedProximity = options.get("proximity", defaultProximity);
      var proxValues = range$1(minProximity, maxProximity + 1).map(function(item) {
        return {
          title: item,
          value: item
        };
      });
      var Select2 = widgets2.select.factory;
      return /* @__PURE__ */ React.createElement("div", {
        className: "operator--PROXIMITY"
      }, /* @__PURE__ */ React.createElement("div", {
        className: "operator--options"
      }, showLabels && /* @__PURE__ */ React.createElement("label", {
        className: "rule--label"
      }, optionLabel), !showLabels && optionTextBefore && /* @__PURE__ */ React.createElement("div", {
        className: "operator--options--sep"
      }, /* @__PURE__ */ React.createElement("span", null, optionTextBefore)), /* @__PURE__ */ React.createElement(Select2, _extends$h({
        config: config2,
        value: selectedProximity,
        listValues: proxValues,
        setValue: this.handleChange,
        readonly,
        placeholder: optionPlaceholder
      }, customProps))), /* @__PURE__ */ React.createElement("div", {
        className: "operator--widgets"
      }, this.props.children));
    }
  }]);
  return Proximity2;
}(reactExports.PureComponent);
Proximity.propTypes = {
  config: PropTypes.object.isRequired,
  setOption: PropTypes.func.isRequired,
  options: PropTypes.any.isRequired,
  //instanceOf(Immutable.Map)
  minProximity: PropTypes.number,
  maxProximity: PropTypes.number,
  optionPlaceholder: PropTypes.string,
  optionTextBefore: PropTypes.string,
  optionLabel: PropTypes.string,
  customProps: PropTypes.object,
  readonly: PropTypes.bool
  //children
};
Proximity.defaultProps = {
  customProps: {},
  minProximity: 2,
  maxProximity: 10,
  optionPlaceholder: "Select words between",
  optionLabel: "Words between",
  optionTextBefore: null
};
function ownKeys$5(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$5(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$5(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var VanillaBooleanWidget = VanillaBoolean, VanillaTextWidget = VanillaText, VanillaTextAreaWidget = VanillaTextArea, VanillaDateWidget = VanillaDate, VanillaTimeWidget = VanillaTime, VanillaDateTimeWidget = VanillaDateTime, VanillaMultiSelectWidget = VanillaMultiSelect, VanillaSelectWidget = VanillaSelect, VanillaNumberWidget = VanillaNumber, VanillaSliderWidget = VanillaSlider, VanillaFieldSelect = VanillaFieldSelect$1, VanillaConjs = VanillaConjs$1, VanillaButton = VanillaButton$1, VanillaButtonGroup = VanillaButtonGroup$1, VanillaProvider2 = VanillaProvider$1, VanillaValueSources = VanillaValueSources$1, vanillaConfirm = vanillaConfirm$1, VanillaSwitch = VanillaSwitch$1, ValueFieldWidget = ValueField, FuncWidget = FuncWidget$1;
var ProximityOperator = Proximity;
var conjunctions$1 = _objectSpread$5({}, CoreConfig.conjunctions);
var operators$1 = _objectSpread$5(_objectSpread$5({}, CoreConfig.operators), {}, {
  proximity: _objectSpread$5(_objectSpread$5({}, CoreConfig.operators.proximity), {}, {
    options: _objectSpread$5(_objectSpread$5({}, CoreConfig.operators.proximity.options), {}, {
      factory: function factory(props) {
        return /* @__PURE__ */ React.createElement(ProximityOperator, props);
      }
    })
  })
});
var widgets$2 = {
  text: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.text), {}, {
    factory: function factory2(props) {
      return /* @__PURE__ */ React.createElement(VanillaTextWidget, props);
    }
  }),
  textarea: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.textarea), {}, {
    factory: function factory3(props) {
      return /* @__PURE__ */ React.createElement(VanillaTextAreaWidget, props);
    }
  }),
  number: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.number), {}, {
    factory: function factory4(props) {
      return /* @__PURE__ */ React.createElement(VanillaNumberWidget, props);
    }
  }),
  slider: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.slider), {}, {
    factory: function factory5(props) {
      return /* @__PURE__ */ React.createElement(VanillaSliderWidget, props);
    }
  }),
  select: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.select), {}, {
    factory: function factory6(props) {
      return /* @__PURE__ */ React.createElement(VanillaSelectWidget, props);
    }
  }),
  multiselect: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.multiselect), {}, {
    factory: function factory7(props) {
      return /* @__PURE__ */ React.createElement(VanillaMultiSelectWidget, props);
    }
  }),
  date: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.date), {}, {
    factory: function factory8(props) {
      return /* @__PURE__ */ React.createElement(VanillaDateWidget, props);
    }
  }),
  time: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.time), {}, {
    factory: function factory9(props) {
      return /* @__PURE__ */ React.createElement(VanillaTimeWidget, props);
    }
  }),
  datetime: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.datetime), {}, {
    factory: function factory10(props) {
      return /* @__PURE__ */ React.createElement(VanillaDateTimeWidget, props);
    }
  }),
  "boolean": _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets["boolean"]), {}, {
    factory: function factory11(props) {
      return /* @__PURE__ */ React.createElement(VanillaBooleanWidget, props);
    }
  }),
  field: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.field), {}, {
    factory: function factory12(props) {
      return /* @__PURE__ */ React.createElement(ValueFieldWidget, props);
    },
    customProps: {
      showSearch: true
    }
  }),
  func: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.func), {}, {
    factory: function factory13(props) {
      return /* @__PURE__ */ React.createElement(FuncWidget, props);
    },
    customProps: {
      //showSearch: true
    }
  }),
  case_value: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.case_value), {}, {
    factory: function factory14(_ref) {
      var value = _ref.value, setValue4 = _ref.setValue;
      return /* @__PURE__ */ React.createElement("input", {
        type: "text",
        value: value || "",
        onChange: function onChange(e2) {
          return setValue4(e2.target.value);
        }
      });
    }
  })
};
var types$2 = _objectSpread$5(_objectSpread$5({}, CoreConfig.types), {}, {
  select: _objectSpread$5(_objectSpread$5({}, CoreConfig.types.select), {}, {
    widgets: _objectSpread$5(_objectSpread$5({}, CoreConfig.types.select.widgets), {}, {
      select: _objectSpread$5(_objectSpread$5({}, CoreConfig.types.select.widgets.select), {}, {
        widgetProps: {
          customProps: {
            showSearch: true
          }
        }
      })
    })
  })
});
var settings$2 = _objectSpread$5(_objectSpread$5({}, CoreConfig.settings), {}, {
  renderField: function renderField(props) {
    return /* @__PURE__ */ React.createElement(VanillaFieldSelect, props);
  },
  renderOperator: function renderOperator(props) {
    return /* @__PURE__ */ React.createElement(VanillaFieldSelect, props);
  },
  renderFunc: function renderFunc(props) {
    return /* @__PURE__ */ React.createElement(VanillaFieldSelect, props);
  },
  renderConjs: function renderConjs(props) {
    return /* @__PURE__ */ React.createElement(VanillaConjs, props);
  },
  renderSwitch: function renderSwitch(props) {
    return /* @__PURE__ */ React.createElement(VanillaSwitch, props);
  },
  renderButton: function renderButton(props) {
    return /* @__PURE__ */ React.createElement(VanillaButton, props);
  },
  renderButtonGroup: function renderButtonGroup(props) {
    return /* @__PURE__ */ React.createElement(VanillaButtonGroup, props);
  },
  renderProvider: function renderProvider(props) {
    return /* @__PURE__ */ React.createElement(VanillaProvider2, props);
  },
  renderValueSources: function renderValueSources(props) {
    return /* @__PURE__ */ React.createElement(VanillaValueSources, props);
  },
  renderConfirm: vanillaConfirm,
  renderSwitchPrefix: function renderSwitchPrefix() {
    return /* @__PURE__ */ React.createElement(React.Fragment, null, "Conditions");
  },
  customFieldSelectProps: {
    showSearch: true
  },
  defaultSliderWidth: "200px",
  defaultSelectWidth: "200px",
  defaultSearchWidth: "100px",
  defaultMaxRows: 5,
  renderSize: "small",
  maxLabelsLength: 100,
  showLock: false,
  showNot: true,
  forceShowConj: false,
  groupActionsPosition: "topRight"
  // oneOf [topLeft, topCenter, topRight, bottomLeft, bottomCenter, bottomRight]
});
const BasicConfig = {
  conjunctions: conjunctions$1,
  operators: operators$1,
  widgets: widgets$2,
  types: types$2,
  settings: settings$2
};
var root = _root;
var now$1 = function() {
  return root.Date.now();
};
var now_1 = now$1;
var isObject4 = isObject_1, now = now_1, toNumber = toNumber_1;
var FUNC_ERROR_TEXT = "Expected a function";
var nativeMax = Math.max, nativeMin = Math.min;
function debounce(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject4(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now());
  }
  function debounced() {
    var time = now(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_1 = debounce;
const debounce$1 = /* @__PURE__ */ getDefaultExportFromCjs(debounce_1);
function ownKeys$4(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$4(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$4(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var _Utils$Autocomplete = Utils$1.Autocomplete, mergeListValues2 = _Utils$Autocomplete.mergeListValues, listValueToOption2 = _Utils$Autocomplete.listValueToOption, getListValue2 = _Utils$Autocomplete.getListValue;
var _Utils$ListUtils = Utils$1.ListUtils, mapListValues$2 = _Utils$ListUtils.mapListValues, listValuesToArray2 = _Utils$ListUtils.listValuesToArray;
var useListValuesAutocomplete$1 = function useListValuesAutocomplete(_ref, _ref2) {
  var asyncFetch = _ref.asyncFetch, useLoadMore = _ref.useLoadMore, useAsyncSearch = _ref.useAsyncSearch, forceAsyncSearch = _ref.forceAsyncSearch, selectedAsyncListValues = _ref.asyncListValues, staticListValues = _ref.listValues, allowCustomValues = _ref.allowCustomValues, selectedValue = _ref.value, setValue4 = _ref.setValue, placeholder2 = _ref.placeholder;
  var debounceTimeout = _ref2.debounceTimeout, multiple = _ref2.multiple;
  var knownSpecialValues = ["LOAD_MORE", "LOADING_MORE"];
  var loadMoreTitle = "Load more...";
  var loadingMoreTitle = "Loading more...";
  var aPlaceholder = forceAsyncSearch ? "Type to search" : placeholder2;
  var _React$useState = React.useState(false), _React$useState2 = _slicedToArray$1(_React$useState, 2), open = _React$useState2[0], setOpen = _React$useState2[1];
  var _React$useState3 = React.useState(void 0), _React$useState4 = _slicedToArray$1(_React$useState3, 2), asyncFetchMeta = _React$useState4[0], setAsyncFetchMeta = _React$useState4[1];
  var _React$useState5 = React.useState(0), _React$useState6 = _slicedToArray$1(_React$useState5, 2), loadingCnt = _React$useState6[0], setLoadingCnt = _React$useState6[1];
  var _React$useState7 = React.useState(false), _React$useState8 = _slicedToArray$1(_React$useState7, 2), isLoadingMore = _React$useState8[0], setIsLoadingMore = _React$useState8[1];
  var _React$useState9 = React.useState(""), _React$useState10 = _slicedToArray$1(_React$useState9, 2), inputValue2 = _React$useState10[0], setInputValue = _React$useState10[1];
  var _React$useState11 = React.useState(void 0), _React$useState12 = _slicedToArray$1(_React$useState11, 2), asyncListValues = _React$useState12[0], setAsyncListValues = _React$useState12[1];
  var asyncFectchCnt = React.useRef(0);
  var componentIsMounted = React.useRef(0);
  var isSelectedLoadMore = React.useRef(false);
  var nSelectedAsyncListValues = listValuesToArray2(selectedAsyncListValues);
  var listValues2 = asyncFetch ? !allowCustomValues ? mergeListValues2(asyncListValues, nSelectedAsyncListValues, true) : asyncListValues : staticListValues;
  var isLoading = loadingCnt > 0;
  var canInitialLoad = open && asyncFetch && asyncListValues === void 0 && (forceAsyncSearch ? inputValue2 : true);
  var isInitialLoading = canInitialLoad && isLoading;
  var canLoadMore = !isInitialLoading && listValues2 && listValues2.length > 0 && asyncFetchMeta && asyncFetchMeta.hasMore && (asyncFetchMeta.filter || "") === inputValue2;
  var canShowLoadMore = !isLoading && canLoadMore;
  var options = mapListValues$2(listValues2, listValueToOption2);
  var hasValue = selectedValue != null;
  var fetchListValues = /* @__PURE__ */ function() {
    var _ref3 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee() {
      var filter, isLoadMore, offset2, meta, newAsyncFetchCnt, res, isFetchCancelled, _ref4, values, hasMore, newMeta, nValues, assumeHasMore, newValues, realNewMeta, _args = arguments;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              filter = _args.length > 0 && _args[0] !== void 0 ? _args[0] : null;
              isLoadMore = _args.length > 1 && _args[1] !== void 0 ? _args[1] : false;
              if (!isLoadMore && asyncFetchMeta) {
                setAsyncFetchMeta(void 0);
              }
              offset2 = isLoadMore && asyncListValues ? asyncListValues.length : 0;
              meta = isLoadMore && asyncFetchMeta || !useLoadMore && {
                pageSize: 0
              };
              newAsyncFetchCnt = ++asyncFectchCnt.current;
              _context.next = 8;
              return asyncFetch(filter, offset2, meta);
            case 8:
              res = _context.sent;
              isFetchCancelled = asyncFectchCnt.current != newAsyncFetchCnt;
              if (!(isFetchCancelled || !componentIsMounted.current)) {
                _context.next = 12;
                break;
              }
              return _context.abrupt("return", null);
            case 12:
              _ref4 = res && res.values ? res : {
                values: res
              }, values = _ref4.values, hasMore = _ref4.hasMore, newMeta = _ref4.meta;
              nValues = listValuesToArray2(values);
              if (isLoadMore) {
                newValues = mergeListValues2(asyncListValues, nValues, false);
                assumeHasMore = newValues.length > asyncListValues.length;
              } else {
                newValues = nValues;
                if (useLoadMore) {
                  assumeHasMore = newValues.length > 0;
                }
              }
              realNewMeta = hasMore != null || newMeta != null || assumeHasMore != null ? _objectSpread$4(_objectSpread$4(_objectSpread$4(_objectSpread$4({}, assumeHasMore != null ? {
                hasMore: assumeHasMore
              } : {}), hasMore != null ? {
                hasMore
              } : {}), newMeta != null ? newMeta : {}), {}, {
                filter
              }) : void 0;
              if (realNewMeta) {
                setAsyncFetchMeta(realNewMeta);
              }
              return _context.abrupt("return", newValues);
            case 18:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function fetchListValues2() {
      return _ref3.apply(this, arguments);
    };
  }();
  var loadListValues = /* @__PURE__ */ function() {
    var _ref5 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee2() {
      var filter, isLoadMore, list2, _args2 = arguments;
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1)
          switch (_context2.prev = _context2.next) {
            case 0:
              filter = _args2.length > 0 && _args2[0] !== void 0 ? _args2[0] : null;
              isLoadMore = _args2.length > 1 && _args2[1] !== void 0 ? _args2[1] : false;
              setLoadingCnt(function(x) {
                return x + 1;
              });
              setIsLoadingMore(isLoadMore);
              _context2.next = 6;
              return fetchListValues(filter, isLoadMore);
            case 6:
              list2 = _context2.sent;
              if (componentIsMounted.current) {
                _context2.next = 9;
                break;
              }
              return _context2.abrupt("return");
            case 9:
              if (list2 != null) {
                setAsyncListValues(list2);
              }
              setLoadingCnt(function(x) {
                return x - 1;
              });
              setIsLoadingMore(false);
            case 12:
            case "end":
              return _context2.stop();
          }
      }, _callee2);
    }));
    return function loadListValues2() {
      return _ref5.apply(this, arguments);
    };
  }();
  var loadListValuesDebounced = React.useCallback(debounce$1(loadListValues, debounceTimeout), []);
  React.useEffect(function() {
    componentIsMounted.current++;
    if (canInitialLoad && loadingCnt == 0 && asyncFectchCnt.current == 0) {
      _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee3() {
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1)
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return loadListValues();
              case 2:
              case "end":
                return _context3.stop();
            }
        }, _callee3);
      }))();
    }
    return function() {
      componentIsMounted.current--;
    };
  }, [canInitialLoad]);
  var onOpen = function onOpen2() {
    setOpen(true);
  };
  var onClose = function onClose2(_e) {
    if (isSelectedLoadMore.current) {
      isSelectedLoadMore.current = false;
      if (multiple) {
        setOpen(false);
      }
    } else {
      setOpen(false);
    }
  };
  var onDropdownVisibleChange = function onDropdownVisibleChange2(open2) {
    if (open2) {
      onOpen();
    } else {
      onClose();
    }
  };
  var isSpecialValue = function isSpecialValue2(option) {
    var specialValue = (option === null || option === void 0 ? void 0 : option.specialValue) || (option === null || option === void 0 ? void 0 : option.value);
    return knownSpecialValues.includes(specialValue);
  };
  var onChange = /* @__PURE__ */ function() {
    var _ref7 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee4(_e, option) {
      var specialValue, _options, newSelectedListValues, newSelectedValues, v2;
      return _regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1)
          switch (_context4.prev = _context4.next) {
            case 0:
              specialValue = (option === null || option === void 0 ? void 0 : option.specialValue) || (option === null || option === void 0 ? void 0 : option.value) || multiple && option.map(function(opt) {
                return (opt === null || opt === void 0 ? void 0 : opt.specialValue) || (opt === null || opt === void 0 ? void 0 : opt.value);
              }).find(function(v3) {
                return !!v3;
              });
              if (!(specialValue == "LOAD_MORE")) {
                _context4.next = 7;
                break;
              }
              isSelectedLoadMore.current = true;
              _context4.next = 5;
              return loadListValues(inputValue2, true);
            case 5:
              _context4.next = 8;
              break;
            case 7:
              if (specialValue == "LOADING_MORE") {
                isSelectedLoadMore.current = true;
              } else {
                if (multiple) {
                  _options = option;
                  newSelectedListValues = _options.map(function(o, i2) {
                    var item = o.value != null ? o : getListValue2(o, listValues2);
                    var customItem = allowCustomValues && !item ? Array.isArray(_e) ? _e[i2] : o : null;
                    return item || customItem;
                  });
                  newSelectedValues = newSelectedListValues.filter(function(o) {
                    return o !== void 0;
                  }).map(function(o) {
                    return o.value !== void 0 ? o.value : o;
                  });
                  if (!newSelectedValues.length)
                    newSelectedValues = void 0;
                  setValue4(newSelectedValues, newSelectedListValues);
                } else {
                  v2 = option == null ? void 0 : option.value;
                  setValue4(v2, [option]);
                }
              }
            case 8:
            case "end":
              return _context4.stop();
          }
      }, _callee4);
    }));
    return function onChange2(_x, _x2) {
      return _ref7.apply(this, arguments);
    };
  }();
  var onInputChange = /* @__PURE__ */ function() {
    var _ref8 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee5(_e, newInputValue) {
      var val, canSearchAsync;
      return _regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1)
          switch (_context5.prev = _context5.next) {
            case 0:
              val = newInputValue;
              if (!(val === loadMoreTitle || val === loadingMoreTitle)) {
                _context5.next = 3;
                break;
              }
              return _context5.abrupt("return");
            case 3:
              setInputValue(val);
              if (allowCustomValues) {
                if (multiple)
                  ;
                else {
                  setValue4(val, [val]);
                }
              }
              canSearchAsync = useAsyncSearch && (forceAsyncSearch ? !!val : true);
              if (!canSearchAsync) {
                _context5.next = 11;
                break;
              }
              _context5.next = 9;
              return loadListValuesDebounced(val);
            case 9:
              _context5.next = 12;
              break;
            case 11:
              if (useAsyncSearch && forceAsyncSearch) {
                setAsyncListValues([]);
              }
            case 12:
            case "end":
              return _context5.stop();
          }
      }, _callee5);
    }));
    return function onInputChange2(_x3, _x4) {
      return _ref8.apply(this, arguments);
    };
  }();
  var onSearch = /* @__PURE__ */ function() {
    var _ref9 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee6(newInputValue) {
      return _regeneratorRuntime.wrap(function _callee6$(_context6) {
        while (1)
          switch (_context6.prev = _context6.next) {
            case 0:
              if (!(newInputValue === "" && !open)) {
                _context6.next = 2;
                break;
              }
              return _context6.abrupt("return");
            case 2:
              _context6.next = 4;
              return onInputChange(null, newInputValue);
            case 4:
            case "end":
              return _context6.stop();
          }
      }, _callee6);
    }));
    return function onSearch2(_x5) {
      return _ref9.apply(this, arguments);
    };
  }();
  var extendOptions = function extendOptions2(options2) {
    var filtered = _toConsumableArray(options2);
    if (useLoadMore) {
      if (canShowLoadMore) {
        filtered.push({
          specialValue: "LOAD_MORE",
          title: loadMoreTitle
        });
      } else if (isLoadingMore) {
        filtered.push({
          specialValue: "LOADING_MORE",
          title: loadingMoreTitle,
          disabled: true
        });
      }
    }
    return filtered;
  };
  var getOptionSelected = function getOptionSelected2(option, valueOrOption) {
    if (valueOrOption == null)
      return null;
    var selectedValue2 = valueOrOption.value != void 0 ? valueOrOption.value : valueOrOption;
    return option.value === selectedValue2;
  };
  var getOptionDisabled = function getOptionDisabled2(valueOrOption) {
    return valueOrOption && valueOrOption.disabled;
  };
  var getOptionLabel = function getOptionLabel2(valueOrOption) {
    if (valueOrOption == null)
      return null;
    var option = valueOrOption.value != void 0 ? valueOrOption : listValueToOption2(getListValue2(valueOrOption, listValues2));
    if (!option && valueOrOption.specialValue) {
      return valueOrOption.title;
    }
    if (!option && allowCustomValues) {
      return valueOrOption;
    }
    if (!option) {
      return valueOrOption;
    }
    return option.title;
  };
  return {
    options,
    listValues: listValues2,
    hasValue,
    open,
    onOpen,
    onClose,
    onDropdownVisibleChange,
    onChange,
    inputValue: inputValue2,
    onInputChange,
    onSearch,
    canShowLoadMore,
    isInitialLoading,
    isLoading,
    isLoadingMore,
    isSpecialValue,
    extendOptions,
    getOptionSelected,
    getOptionDisabled,
    getOptionLabel,
    // unused
    //selectedListValue,
    //selectedOption,
    aPlaceholder
  };
};
function ownKeys$3(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$3(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$3(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
const Utils = _objectSpread$3(_objectSpread$3({}, Utils$1), {}, {
  ReactUtils
});
var moment = Utils.moment;
const MuiTimeWidget$1 = function(props) {
  var value = props.value, setValue4 = props.setValue, use12Hours = props.use12Hours, readonly = props.readonly, placeholder2 = props.placeholder, timeFormat = props.timeFormat, valueFormat = props.valueFormat, customProps = props.customProps;
  var formatSingleValue = function formatSingleValue2(value2) {
    return value2 && value2.isValid() ? value2.format(valueFormat) : void 0;
  };
  var handleChange = function handleChange2(value2) {
    setValue4(formatSingleValue(value2));
  };
  var hasSeconds = timeFormat.indexOf(":ss") != -1;
  var timeValue = value ? moment(value, timeFormat) : null;
  var renderInput = function renderInput2(params) {
    return /* @__PURE__ */ React.createElement(TextField, _extends$h({
      size: "small",
      variant: "standard"
    }, params));
  };
  return /* @__PURE__ */ React.createElement(FormControl, null, /* @__PURE__ */ React.createElement(TimePicker, _extends$h({
    readOnly: readonly,
    disabled: readonly,
    ampm: !!use12Hours,
    toolbarPlaceholder: !readonly ? placeholder2 : "",
    inputFormat: timeFormat,
    value: timeValue || null,
    onChange: handleChange,
    views: hasSeconds ? ["hours", "minutes", "seconds"] : ["hours", "minutes"],
    renderInput
  }, customProps)));
};
var mapListValues$1 = Utils.ListUtils.mapListValues;
const MuiSelectWidget$1 = function(_ref) {
  var listValues2 = _ref.listValues, value = _ref.value, setValue4 = _ref.setValue;
  _ref.allowCustomValues;
  var readonly = _ref.readonly, placeholder2 = _ref.placeholder, customProps = _ref.customProps;
  var renderOptions = function renderOptions2() {
    return mapListValues$1(listValues2, function(_ref2) {
      var title2 = _ref2.title, value2 = _ref2.value;
      return /* @__PURE__ */ React.createElement(MenuItem, {
        key: value2,
        value: value2
      }, title2);
    });
  };
  var onChange = function onChange2(e2) {
    if (e2.target.value === void 0)
      return;
    setValue4(e2.target.value);
  };
  var renderValue = function renderValue2(selectedValue) {
    if (!readonly && selectedValue == null)
      return placeholder2;
    return getListValueTitle(selectedValue);
  };
  var getListValueTitle = function getListValueTitle2(selectedValue) {
    return mapListValues$1(listValues2, function(_ref3) {
      var title2 = _ref3.title, value2 = _ref3.value;
      return value2 === selectedValue ? title2 : null;
    }).filter(function(v2) {
      return v2 !== null;
    }).shift();
  };
  var hasValue = value != null;
  return /* @__PURE__ */ React.createElement(FormControl, null, /* @__PURE__ */ React.createElement(Select, _extends$h({
    variant: "standard",
    autoWidth: true,
    displayEmpty: true,
    placeholder: !readonly ? placeholder2 : "",
    onChange,
    value: hasValue ? value : "",
    disabled: readonly,
    readOnly: readonly,
    renderValue,
    size: "small"
  }, omit$1(customProps, ["showSearch", "input"])), renderOptions()));
};
const MuiNumberWidget$1 = function(props) {
  var value = props.value, setValue4 = props.setValue;
  props.config;
  var readonly = props.readonly, min2 = props.min, max2 = props.max, step = props.step, placeholder2 = props.placeholder, customProps = props.customProps;
  var onChange = function onChange2(e2) {
    var val = e2.target.value;
    if (val === "" || val === null)
      val = void 0;
    else
      val = Number(val);
    setValue4(val);
  };
  var numberValue = value == void 0 ? "" : value;
  return /* @__PURE__ */ React.createElement(FormControl, null, /* @__PURE__ */ React.createElement(TextField, _extends$h({
    variant: "standard",
    type: "number",
    value: numberValue,
    placeholder: !readonly ? placeholder2 : "",
    InputProps: {
      readOnly: readonly
    },
    inputProps: {
      min: min2,
      max: max2,
      step
    },
    disabled: readonly,
    onChange,
    size: "small"
  }, customProps)));
};
var _excluded$3 = ["width"];
const MuiSliderWidget$1 = function(props) {
  var config2 = props.config, placeholder2 = props.placeholder, customProps = props.customProps, value = props.value, setValue4 = props.setValue, min2 = props.min, max2 = props.max, step = props.step, marks = props.marks, readonly = props.readonly;
  var defaultSliderWidth = config2.settings.defaultSliderWidth;
  var handleSliderChange = reactExports.useCallback(function(_e, newValue) {
    setValue4(newValue);
  }, []);
  var handleInputChange = function handleInputChange2(e2) {
    var val = e2.target.value;
    if (val === "" || val === null)
      val = void 0;
    else
      val = Number(val);
    setValue4(val);
  };
  var handleInputBlur = function handleInputBlur2() {
    if (value < min2) {
      setValue4(min2);
    } else if (value > max2) {
      setValue4(max2);
    }
  };
  var _ref = customProps || {}, width = _ref.width, rest = _objectWithoutProperties$2(_ref, _excluded$3);
  var customInputProps = rest.input || {};
  var customSliderProps = rest.slider || rest;
  var inputValue2 = typeof value === "number" ? value : "";
  var sliderValue = typeof value === "number" ? value : null;
  var muiMarks = reactExports.useMemo(function() {
    return marks ? Object.keys(marks).map(function(v2) {
      return {
        value: Number(v2),
        label: _typeof$2(marks[v2]) === "object" || typeof marks[v2] === "undefined" ? marks[v2] : /* @__PURE__ */ React.createElement("p", null, marks[v2])
      };
    }) : false;
  }, [marks]);
  var InputCmp = /* @__PURE__ */ React.createElement(TextField, _extends$h({
    variant: "standard",
    type: "number",
    value: inputValue2,
    placeholder: placeholder2,
    InputProps: {
      readOnly: readonly
    },
    inputProps: {
      min: min2,
      max: max2,
      step
    },
    disabled: readonly,
    onChange: handleInputChange,
    onBlur: handleInputBlur,
    size: "small"
  }, customInputProps));
  var SliderCmp = /* @__PURE__ */ React.createElement(Slider$2, _extends$h({
    value: sliderValue,
    onChange: handleSliderChange,
    disabled: readonly,
    min: min2,
    max: max2,
    step,
    marks: muiMarks,
    valueLabelDisplay: "auto",
    size: "small"
  }, customSliderProps));
  var stylesWrapper = {
    display: "inline-flex",
    alignItems: "center",
    flexWrap: "wrap"
  };
  var stylesInputWrapper = {
    marginLeft: "5px"
  };
  var stylesSliderWrapper = {
    marginLeft: "5px",
    paddingLeft: "12px",
    marginBottom: muiMarks && "-16px",
    width: width || defaultSliderWidth
  };
  return /* @__PURE__ */ React.createElement(FormControl, null, /* @__PURE__ */ React.createElement("div", {
    style: stylesWrapper
  }, /* @__PURE__ */ React.createElement("div", {
    style: stylesInputWrapper
  }, InputCmp), /* @__PURE__ */ React.createElement("div", {
    style: stylesSliderWrapper
  }, SliderCmp)));
};
var _excluded$2 = ["width"];
const MuiRangeWidget$1 = function(props) {
  var config2 = props.config, placeholders = props.placeholders, customProps = props.customProps, value = props.value, setValue4 = props.setValue, min2 = props.min, max2 = props.max, step = props.step, marks = props.marks, readonly = props.readonly, textSeparators = props.textSeparators;
  var defaultSliderWidth = config2.settings.defaultSliderWidth;
  reactExports.useEffect(function() {
    var _ref = props.value || [void 0, void 0], _ref2 = _slicedToArray$1(_ref, 2), valueFrom2 = _ref2[0], valueTo2 = _ref2[1];
    if (props.value && (valueFrom2 == void 0 || valueTo2 == void 0)) {
      setTimeout(function() {
        var oneValue = valueFrom2 || valueTo2;
        var value2 = [oneValue, oneValue];
        setValue4(value2);
      }, 1);
    }
  }, []);
  var handleSliderChange = function handleSliderChange2(_e, newValues) {
    setValue4(newValues);
  };
  var handleInputChangeFrom = function handleInputChangeFrom2(e2) {
    var valueFrom2 = e2.target.value;
    if (valueFrom2 === "" || valueFrom2 == null)
      valueFrom2 = void 0;
    else
      valueFrom2 = Number(valueFrom2);
    var value2 = props.value ? _toConsumableArray(props.value) : [void 0, void 0];
    value2[0] = valueFrom2;
    setValue4(value2);
  };
  var handleInputChangeTo = function handleInputChangeTo2(e2) {
    var valueTo2 = e2.target.value;
    if (valueTo2 === "" || valueTo2 == null)
      valueTo2 = void 0;
    else
      valueTo2 = Number(valueTo2);
    var value2 = props.value ? _toConsumableArray(props.value) : [void 0, void 0];
    value2[1] = valueTo2;
    setValue4(value2);
  };
  var handleInputBlur = function handleInputBlur2() {
    if (!value)
      return;
    if (value[0] < min2) {
      setValue4([min2, value[1]]);
    } else if (value[1] > max2) {
      setValue4([value[0], max2]);
    }
  };
  var _ref3 = customProps || {}, width = _ref3.width, rest = _objectWithoutProperties$2(_ref3, _excluded$2);
  var customInputProps = rest.input || {};
  var customSliderProps = rest.slider || rest;
  var muiMarks = marks ? Object.keys(marks).map(function(v2) {
    return {
      value: Number(v2),
      label: _typeof$2(marks[v2]) === "object" || typeof marks[v2] === "undefined" ? marks[v2] : /* @__PURE__ */ React.createElement("p", null, marks[v2])
    };
  }) : false;
  var sliderValue = value ? _toConsumableArray(value) : [void 0, void 0];
  var _sliderValue = _slicedToArray$1(sliderValue, 2), valueFrom = _sliderValue[0], valueTo = _sliderValue[1];
  if (valueFrom == void 0) {
    valueFrom = "";
    sliderValue[0] = 0;
  }
  if (valueTo == void 0) {
    valueTo = "";
    sliderValue[1] = 0;
  }
  var FromInputCmp = /* @__PURE__ */ React.createElement(TextField, _extends$h({
    variant: "standard",
    type: "number",
    value: valueFrom,
    placeholder: placeholders[0],
    InputProps: {
      readOnly: readonly
    },
    inputProps: {
      min: min2,
      max: max2,
      step
    },
    disabled: readonly,
    onChange: handleInputChangeFrom,
    onBlur: handleInputBlur,
    size: "small"
  }, customInputProps));
  var ToInputCmp = /* @__PURE__ */ React.createElement(TextField, _extends$h({
    variant: "standard",
    type: "number",
    value: valueTo,
    placeholder: placeholders[1],
    InputProps: {
      readOnly: readonly
    },
    inputProps: {
      min: min2,
      max: max2,
      step
    },
    disabled: readonly,
    onChange: handleInputChangeTo,
    onBlur: handleInputBlur,
    size: "small"
  }, customInputProps));
  var SliderCmp = /* @__PURE__ */ React.createElement(Slider$2, _extends$h({
    value: sliderValue,
    onChange: handleSliderChange,
    disabled: readonly,
    min: min2,
    max: max2,
    step,
    marks: muiMarks,
    valueLabelDisplay: "auto",
    size: "small"
  }, customSliderProps));
  var stylesWrapper = {
    display: "inline-flex",
    flexWrap: "wrap"
  };
  var stylesInputWrapper = {
    marginLeft: "5px"
  };
  var stylesSliderWrapper = {
    marginLeft: "5px",
    paddingLeft: "12px",
    marginBottom: muiMarks && "-16px",
    width: width || defaultSliderWidth
  };
  return /* @__PURE__ */ React.createElement(FormControl, null, /* @__PURE__ */ React.createElement("div", {
    style: stylesWrapper
  }, /* @__PURE__ */ React.createElement("div", {
    style: stylesInputWrapper
  }, FromInputCmp), /* @__PURE__ */ React.createElement("div", {
    className: "widget--sep"
  }, /* @__PURE__ */ React.createElement("span", null, textSeparators[1])), /* @__PURE__ */ React.createElement("div", {
    style: stylesInputWrapper
  }, ToInputCmp), /* @__PURE__ */ React.createElement("div", {
    style: stylesSliderWrapper
  }, SliderCmp)));
};
const MuiBooleanWidget$1 = function(props) {
  var customProps = props.customProps, value = props.value, setValue4 = props.setValue, labelYes = props.labelYes, labelNo = props.labelNo, readonly = props.readonly;
  var onChange = function onChange2() {
    setValue4(!value);
  };
  return /* @__PURE__ */ React.createElement(FormControl, null, /* @__PURE__ */ React.createElement(Typography, {
    component: "div"
  }, /* @__PURE__ */ React.createElement(Grid, {
    component: "label",
    container: true,
    alignItems: "center",
    spacing: 0
  }, /* @__PURE__ */ React.createElement(Grid, {
    item: true,
    component: "span"
  }, labelNo), /* @__PURE__ */ React.createElement(Grid, {
    item: true,
    component: "span"
  }, /* @__PURE__ */ React.createElement(Switch, _extends$h({
    checked: !!value,
    onChange,
    disabled: readonly
  }, customProps))), /* @__PURE__ */ React.createElement(Grid, {
    item: true,
    component: "span"
  }, labelYes))));
};
var mapListValues2 = Utils.ListUtils.mapListValues;
const MuiMultiSelectWidget$1 = function(_ref) {
  var listValues2 = _ref.listValues, value = _ref.value, setValue4 = _ref.setValue;
  _ref.allowCustomValues;
  var readonly = _ref.readonly, placeholder2 = _ref.placeholder, customProps = _ref.customProps;
  var renderOptions = function renderOptions2(selectedValues) {
    return mapListValues2(listValues2, function(_ref2) {
      var title2 = _ref2.title, value2 = _ref2.value;
      return /* @__PURE__ */ React.createElement(MenuItem, {
        key: value2,
        value: value2
      }, /* @__PURE__ */ React.createElement(Checkbox, {
        checked: selectedValues.indexOf(value2) > -1
      }), /* @__PURE__ */ React.createElement(ListItemText$1, {
        primary: title2
      }));
    });
  };
  var renderValue = function renderValue2(selectedValues) {
    if (!readonly && !selectedValues.length)
      return placeholder2;
    var selectedTitles = mapListValues2(listValues2, function(_ref3) {
      var title2 = _ref3.title, value2 = _ref3.value;
      return selectedValues.indexOf(value2) > -1 ? title2 : null;
    }).filter(function(v2) {
      return v2 !== null;
    });
    return selectedTitles.join(", ");
  };
  var hasValue = value != null && value.length > 0;
  var onChange = function onChange2(e2) {
    if (e2.target.value === void 0)
      return;
    setValue4(e2.target.value);
  };
  return /* @__PURE__ */ React.createElement(FormControl, null, /* @__PURE__ */ React.createElement(Select, _extends$h({
    multiple: true,
    variant: "standard",
    autoWidth: true,
    displayEmpty: true,
    label: !readonly ? placeholder2 : "",
    onChange,
    value: hasValue ? value : [],
    disabled: readonly,
    readOnly: readonly,
    renderValue,
    size: "small"
  }, omit$1(customProps, ["showSearch", "input", "showCheckboxes"])), renderOptions(hasValue ? value : [])));
};
var _excluded$1 = ["width", "showCheckboxes"];
function ownKeys$2(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$2(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var useListValuesAutocomplete2 = useListValuesAutocomplete$1;
var nonCheckedIcon = /* @__PURE__ */ React.createElement(default_1$m, {
  fontSize: "small"
});
var checkedIcon = /* @__PURE__ */ React.createElement(default_1$t, {
  fontSize: "small"
});
var defaultFilterOptions = createFilterOptions();
var emptyArray = [];
const MuiAutocompleteWidget$1 = function(props) {
  var allowCustomValues = props.allowCustomValues, multiple = props.multiple, selectedValue = props.value, customProps = props.customProps, readonly = props.readonly, config2 = props.config, groupBy = props.groupBy, filterOptionsConfig2 = props.filterOptionsConfig;
  var filterOptionsFn = filterOptionsConfig2 ? createFilterOptions(filterOptionsConfig2) : defaultFilterOptions;
  var _useListValuesAutocom = useListValuesAutocomplete2(props, {
    debounceTimeout: 100,
    multiple
  }), open = _useListValuesAutocom.open, onOpen = _useListValuesAutocom.onOpen, onClose = _useListValuesAutocom.onClose, onChange = _useListValuesAutocom.onChange, onInputChange = _useListValuesAutocom.onInputChange, inputValue2 = _useListValuesAutocom.inputValue, options = _useListValuesAutocom.options, isInitialLoading = _useListValuesAutocom.isInitialLoading, isLoading = _useListValuesAutocom.isLoading, aPlaceholder = _useListValuesAutocom.aPlaceholder, extendOptions = _useListValuesAutocom.extendOptions, getOptionDisabled = _useListValuesAutocom.getOptionDisabled, getOptionLabel = _useListValuesAutocom.getOptionLabel;
  var _config$settings = config2.settings, defaultSelectWidth = _config$settings.defaultSelectWidth, defaultSearchWidth = _config$settings.defaultSearchWidth;
  var _ref = customProps || {}, width = _ref.width, showCheckboxes = _ref.showCheckboxes, rest = _objectWithoutProperties$2(_ref, _excluded$1);
  var customInputProps = rest.input || {};
  customInputProps.width || defaultSearchWidth;
  customInputProps = omit$1(customInputProps, ["width"]);
  var customAutocompleteProps = omit$1(rest, ["showSearch", "showCheckboxes"]);
  var fullWidth2 = true;
  var minWidth = width || defaultSelectWidth;
  var style = {
    width: multiple ? void 0 : minWidth,
    minWidth
  };
  var placeholder2 = !readonly ? aPlaceholder : "";
  var hasValue = selectedValue != null;
  var value = hasValue ? selectedValue : multiple ? emptyArray : null;
  var filterOptions = function filterOptions2(options2, params) {
    var filtered = filterOptionsFn(options2, params);
    var extended = extendOptions(filtered);
    return extended;
  };
  var renderInput = function renderInput2(params) {
    return /* @__PURE__ */ React.createElement(TextField, _extends$h({
      variant: "standard"
    }, params, {
      InputProps: _objectSpread$2(_objectSpread$2({}, params.InputProps), {}, {
        readOnly: readonly,
        endAdornment: /* @__PURE__ */ React.createElement(React.Fragment, null, isLoading ? /* @__PURE__ */ React.createElement(CircularProgress, {
          color: "inherit",
          size: 20
        }) : null, params.InputProps.endAdornment)
      }),
      disabled: readonly,
      placeholder: placeholder2
      //onChange={onInputChange}
    }, customInputProps));
  };
  var isOptionEqualToValue = function isOptionEqualToValue2(option, value2) {
    return (option === null || option === void 0 ? void 0 : option.value) == value2;
  };
  var renderOption = function renderOption2(props2, option) {
    var title2 = option.title, renderTitle = option.renderTitle, value2 = option.value;
    var selected = (selectedValue || []).includes(value2);
    if (option.specialValue) {
      return /* @__PURE__ */ React.createElement("div", props2, renderTitle || title2);
    } else if (multiple && showCheckboxes != false) {
      return /* @__PURE__ */ React.createElement("div", props2, /* @__PURE__ */ React.createElement(Checkbox, {
        icon: nonCheckedIcon,
        checkedIcon,
        style: {
          marginRight: 8
        },
        checked: selected
      }), title2);
    } else {
      return /* @__PURE__ */ React.createElement("div", props2, renderTitle || title2);
    }
  };
  return /* @__PURE__ */ React.createElement(FormControl, {
    fullWidth: fullWidth2
  }, /* @__PURE__ */ React.createElement(Autocomplete$1, _extends$h({
    disableCloseOnSelect: multiple,
    fullWidth: fullWidth2,
    multiple,
    style,
    freeSolo: allowCustomValues,
    loading: isInitialLoading,
    open,
    onOpen,
    onClose,
    inputValue: inputValue2,
    onInputChange,
    label: placeholder2,
    onChange,
    value,
    disabled: readonly,
    readOnly: readonly,
    options,
    groupBy,
    getOptionLabel,
    getOptionDisabled,
    renderInput,
    renderOption,
    filterOptions,
    isOptionEqualToValue,
    size: "small"
  }, customAutocompleteProps)));
};
const MuiFieldSelect$1 = function(_ref) {
  var items = _ref.items, setField4 = _ref.setField, selectedKey = _ref.selectedKey, readonly = _ref.readonly, placeholder2 = _ref.placeholder;
  var renderOptions = function renderOptions2(fields) {
    var level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return Object.keys(fields).map(function(fieldKey) {
      var field = fields[fieldKey];
      var items2 = field.items, path = field.path, label2 = field.label, disabled = field.disabled;
      var prefix = "  ".repeat(level);
      if (items2) {
        return [/* @__PURE__ */ React.createElement(ListSubheader$1, {
          disabled,
          key: path,
          disableSticky: true
        }, prefix && /* @__PURE__ */ React.createElement("span", null, prefix), label2), renderOptions2(items2, level + 1)];
      } else {
        return /* @__PURE__ */ React.createElement(MenuItem, {
          disabled,
          key: path,
          value: path
        }, prefix && /* @__PURE__ */ React.createElement("span", null, prefix), label2);
      }
    });
  };
  var onChange = function onChange2(e2) {
    if (e2.target.value === void 0)
      return;
    setField4(e2.target.value);
  };
  var renderValue = function renderValue2(selectedValue) {
    if (!readonly && !selectedValue)
      return placeholder2;
    var findLabel = function findLabel2(fields) {
      return fields.map(function(field) {
        if (!field.items)
          return field.path === selectedValue ? field.label : null;
        return findLabel2(field.items);
      });
    };
    return findLabel(items).filter(function(v2) {
      if (Array.isArray(v2)) {
        return v2.some(function(value) {
          return value !== null;
        });
      } else {
        return v2 !== null;
      }
    }).pop();
  };
  var hasValue = selectedKey != null;
  return /* @__PURE__ */ React.createElement(FormControl, null, /* @__PURE__ */ React.createElement(Select, {
    variant: "standard",
    autoWidth: true,
    displayEmpty: true,
    placeholder: placeholder2,
    onChange,
    value: hasValue ? selectedKey : "",
    disabled: readonly,
    renderValue,
    size: "small"
  }, renderOptions(items)));
};
var _excluded = ["items", "selectedKey", "setField"];
function ownKeys$1(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var itemsToListValues = function itemsToListValues2(items) {
  var level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return items.map(function(item) {
    var items2 = item.items, path = item.path, label2 = item.label, disabled = item.disabled, grouplabel = item.grouplabel;
    var prefix = "  ".repeat(level);
    if (items2) {
      return itemsToListValues2(items2, level + 1);
    } else {
      return {
        title: label2,
        renderTitle: prefix + label2,
        value: path,
        disabled,
        groupTitle: level > 0 ? prefix + grouplabel : null
      };
    }
  }).flat(Infinity);
};
var filterOptionsConfig = {
  stringify: function stringify(option) {
    var keysForFilter = ["title", "value", "grouplabel", "label"];
    var valueForFilter = keysForFilter.map(function(k2) {
      return typeof option[k2] == "string" ? option[k2] : "";
    }).join("\0");
    return valueForFilter;
  }
};
var fieldAdapter = function fieldAdapter2(_ref) {
  var items = _ref.items, selectedKey = _ref.selectedKey, setField4 = _ref.setField, rest = _objectWithoutProperties$2(_ref, _excluded);
  var listValues2 = itemsToListValues(items);
  var groupBy = function groupBy2(option) {
    return option.groupTitle;
  };
  var value = selectedKey;
  var setValue4 = function setValue5(value2, _asyncValues) {
    if (!value2)
      return void 0;
    return setField4(value2);
  };
  return _objectSpread$1(_objectSpread$1({}, rest), {}, {
    listValues: listValues2,
    setValue: setValue4,
    groupBy,
    filterOptionsConfig,
    allowCustomValues: false,
    multiple: false,
    value
  });
};
const MuiFieldAutocomplete$1 = function(props) {
  return /* @__PURE__ */ React.createElement(MuiAutocompleteWidget$1, fieldAdapter(props));
};
const MuiButton$1 = function(_ref) {
  var type2 = _ref.type, label2 = _ref.label, onClick = _ref.onClick, readonly = _ref.readonly;
  _ref.config;
  var hideLabelsFor = {
    "addRuleGroup": true,
    "addRuleGroupExt": true
  };
  var typeToIcon = {
    "delGroup": /* @__PURE__ */ React.createElement(default_1$u, null),
    "delRuleGroup": /* @__PURE__ */ React.createElement(default_1$u, null),
    "delRule": /* @__PURE__ */ React.createElement(default_1$u, null),
    "addRule": /* @__PURE__ */ React.createElement(default_1$9, null),
    "addGroup": /* @__PURE__ */ React.createElement(default_1$9, null),
    "addRuleGroupExt": /* @__PURE__ */ React.createElement(default_1$9, null),
    "addRuleGroup": /* @__PURE__ */ React.createElement(default_1$9, null)
  };
  var typeToColor = {
    "addRule": "neutral",
    "addGroup": "primary",
    "delGroup": "secondary",
    "delRuleGroup": "secondary",
    "delRule": "secondary"
  };
  if (!label2 || hideLabelsFor[type2]) {
    return /* @__PURE__ */ React.createElement(IconButton, {
      size: "small",
      disabled: readonly,
      onClick,
      color: typeToColor[type2]
    }, typeToIcon[type2]);
  } else {
    return /* @__PURE__ */ React.createElement(Button, {
      size: "small",
      disabled: readonly,
      onClick,
      color: typeToColor[type2],
      startIcon: typeToIcon[type2]
    }, label2);
  }
};
const MuiButtonGroup$1 = function(_ref) {
  var children = _ref.children;
  _ref.config;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, children);
};
const MuiConjs$1 = function(_ref) {
  var id = _ref.id, not = _ref.not, setNot4 = _ref.setNot, conjunctionOptions = _ref.conjunctionOptions, setConjunction4 = _ref.setConjunction, disabled = _ref.disabled, readonly = _ref.readonly, config2 = _ref.config, showNot = _ref.showNot, notLabel = _ref.notLabel;
  var conjsCount = Object.keys(conjunctionOptions).length;
  var lessThenTwo = disabled;
  var forceShowConj = config2.settings.forceShowConj;
  var showConj = forceShowConj || conjsCount > 1 && !lessThenTwo;
  var renderOptions = function renderOptions2() {
    return Object.keys(conjunctionOptions).map(function(key) {
      var _conjunctionOptions$k = conjunctionOptions[key], id2 = _conjunctionOptions$k.id;
      _conjunctionOptions$k.name;
      var label2 = _conjunctionOptions$k.label, checked = _conjunctionOptions$k.checked;
      var postfix = setConjunction4.isDummyFn ? "__dummy" : "";
      if ((readonly || disabled) && !checked)
        return null;
      return /* @__PURE__ */ React.createElement(Button, {
        key: id2 + postfix,
        id: id2 + postfix,
        color: checked ? "primary" : "neutral",
        value: key,
        onClick: onClick.bind(null, key),
        disabled: readonly || disabled
      }, label2);
    });
  };
  var renderNot = function renderNot2() {
    if (readonly && !not)
      return null;
    return /* @__PURE__ */ React.createElement(Button, {
      key: id,
      id: id + "__not",
      color: not ? "secondary" : "neutral",
      onClick: onNotClick.bind(null, !not),
      disabled: readonly
    }, notLabel || "NOT");
  };
  var onClick = function onClick2(value) {
    return setConjunction4(value);
  };
  var onNotClick = function onNotClick2(checked) {
    return setNot4(checked);
  };
  return /* @__PURE__ */ React.createElement(FormControl, null, /* @__PURE__ */ React.createElement(ButtonGroup$1, {
    disableElevation: true,
    variant: "contained",
    size: "small",
    disabled: readonly
  }, showNot && renderNot(), showConj && renderOptions()));
};
var LockOpen = {};
var _interopRequireDefault$6 = interopRequireDefaultExports;
Object.defineProperty(LockOpen, "__esModule", {
  value: true
});
var default_1$6 = LockOpen.default = void 0;
var _createSvgIcon$6 = _interopRequireDefault$6(requireCreateSvgIcon());
var _jsxRuntime$6 = jsxRuntimeExports;
var _default$6 = (0, _createSvgIcon$6.default)(/* @__PURE__ */ (0, _jsxRuntime$6.jsx)("path", {
  d: "M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6h1.9c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm0 12H6V10h12v10z"
}), "LockOpen");
default_1$6 = LockOpen.default = _default$6;
var Lock = {};
var _interopRequireDefault$5 = interopRequireDefaultExports;
Object.defineProperty(Lock, "__esModule", {
  value: true
});
var default_1$5 = Lock.default = void 0;
var _createSvgIcon$5 = _interopRequireDefault$5(requireCreateSvgIcon());
var _jsxRuntime$5 = jsxRuntimeExports;
var _default$5 = (0, _createSvgIcon$5.default)(/* @__PURE__ */ (0, _jsxRuntime$5.jsx)("path", {
  d: "M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"
}), "Lock");
default_1$5 = Lock.default = _default$5;
const MuiSwitch$1 = function(_ref) {
  var value = _ref.value, setValue4 = _ref.setValue, label2 = _ref.label, checkedLabel = _ref.checkedLabel, hideLabel = _ref.hideLabel, id = _ref.id, config2 = _ref.config, type2 = _ref.type;
  config2.settings.renderSize;
  var onChange = function onChange2(e2) {
    return setValue4(e2.target.checked);
  };
  var onClick = function onClick2() {
    return setValue4(!value);
  };
  var postfix = type2;
  var showLabel = value ? checkedLabel || label2 : label2;
  var icon = value ? /* @__PURE__ */ React.createElement(default_1$5, null) : /* @__PURE__ */ React.createElement(default_1$6, null);
  if (type2 == "lock") {
    if (hideLabel) {
      return /* @__PURE__ */ React.createElement(IconButton, {
        key: id + postfix,
        onClick,
        size: "small"
      }, icon);
    } else {
      return /* @__PURE__ */ React.createElement(Button, {
        key: id + postfix,
        onClick,
        size: "small",
        startIcon: icon
      }, showLabel);
    }
  }
  return /* @__PURE__ */ React.createElement(FormControlLabel, {
    control: /* @__PURE__ */ React.createElement(Switch, {
      checked: !!value,
      size: "small",
      onChange
    }),
    label: showLabel
  });
};
var ExpandMoreSharp = {};
var _interopRequireDefault$4 = interopRequireDefaultExports;
Object.defineProperty(ExpandMoreSharp, "__esModule", {
  value: true
});
var default_1$4 = ExpandMoreSharp.default = void 0;
var _createSvgIcon$4 = _interopRequireDefault$4(requireCreateSvgIcon());
var _jsxRuntime$4 = jsxRuntimeExports;
var _default$4 = (0, _createSvgIcon$4.default)(/* @__PURE__ */ (0, _jsxRuntime$4.jsx)("path", {
  d: "M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6-1.41-1.41z"
}), "ExpandMoreSharp");
default_1$4 = ExpandMoreSharp.default = _default$4;
const MuiValueSources$1 = function(_ref) {
  var valueSources = _ref.valueSources, valueSrc = _ref.valueSrc, title2 = _ref.title, setValueSrc4 = _ref.setValueSrc;
  _ref.readonly;
  var _React$useState = React.useState(null), _React$useState2 = _slicedToArray$1(_React$useState, 2), anchorEl = _React$useState2[0], setAnchorEl = _React$useState2[1];
  var handleOpen = function handleOpen2(event) {
    setAnchorEl(event.currentTarget);
  };
  var handleClose = function handleClose2() {
    setAnchorEl(null);
  };
  var toggleOpenClose = function toggleOpenClose2(event) {
    anchorEl ? handleClose() : handleOpen(event);
  };
  var handleChange = function handleChange2(e2) {
    if (e2.target.value === void 0)
      return;
    setValueSrc4(e2.target.value);
    handleClose();
  };
  var renderOptions = function renderOptions2(valueSources2) {
    return valueSources2.map(function(_ref2) {
      var _ref3 = _slicedToArray$1(_ref2, 2), srcKey = _ref3[0], info = _ref3[1];
      return /* @__PURE__ */ React.createElement(FormControlLabel, {
        key: srcKey,
        value: srcKey,
        checked: valueSrc == srcKey || !valueSrc && srcKey == "value",
        control: /* @__PURE__ */ React.createElement(Radio, null),
        label: info.label
      });
    });
  };
  var open = Boolean(anchorEl);
  return /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement(IconButton, {
    size: "small",
    onClick: toggleOpenClose
  }, /* @__PURE__ */ React.createElement(default_1$4, null)), /* @__PURE__ */ React.createElement(Popover, {
    open,
    anchorEl,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: "left"
    },
    transformOrigin: {
      vertical: "top",
      horizontal: "left"
    },
    onClose: handleClose,
    sx: {
      padding: function padding(theme) {
        return theme.spacing(1);
      }
    },
    disablePortal: true
  }, /* @__PURE__ */ React.createElement(FormControl, {
    component: "fieldset",
    sx: {
      p: 2
    }
  }, /* @__PURE__ */ React.createElement(FormLabel, {
    component: "legend"
  }, title2), /* @__PURE__ */ React.createElement(RadioGroup, {
    value: valueSrc || "value",
    onChange: handleChange
  }, renderOptions(valueSources)))));
};
const MuiConfirm$1 = function(_ref) {
  var onOk = _ref.onOk, okText = _ref.okText, cancelText = _ref.cancelText, title2 = _ref.title, confirmFn = _ref.confirmFn;
  confirmFn({
    description: title2 || "Are you sure?",
    title: null,
    confirmationText: okText || "Ok",
    cancellationText: cancelText || "Cancel"
  }).then(onOk)["catch"](function() {
  });
};
var MuiProvider$1 = function MuiProvider(_ref) {
  var config2 = _ref.config, children = _ref.children;
  var settingsTheme = config2.settings.theme || {};
  var settingsLocale = config2.settings.locale || {};
  var themeConfig = settingsTheme.mui;
  var locale2 = settingsLocale.mui;
  var theme = createTheme(themeConfig, locale2, {
    palette: {
      neutral: {
        main: "#64748B",
        contrastText: "#fff"
      }
    }
  });
  var base = /* @__PURE__ */ React.createElement("div", {
    className: "mui"
  }, children);
  var withProviders = /* @__PURE__ */ React.createElement(LocalizationProvider, {
    dateAdapter: MomentUtils
  }, /* @__PURE__ */ React.createElement(ConfirmProvider, null, base));
  var withTheme = theme ? /* @__PURE__ */ React.createElement(ThemeProvider, {
    theme
  }, withProviders) : withProviders;
  return withTheme;
};
const MuiWidgets = {
  MuiTextWidget: MuiTextWidget$1,
  MuiTextAreaWidget: MuiTextAreaWidget$1,
  MuiDateWidget: MuiDateWidget$1,
  MuiDateTimeWidget: MuiDateTimeWidget$1,
  MuiTimeWidget: MuiTimeWidget$1,
  MuiSelectWidget: MuiSelectWidget$1,
  MuiNumberWidget: MuiNumberWidget$1,
  MuiSliderWidget: MuiSliderWidget$1,
  MuiRangeWidget: MuiRangeWidget$1,
  MuiBooleanWidget: MuiBooleanWidget$1,
  MuiMultiSelectWidget: MuiMultiSelectWidget$1,
  MuiAutocompleteWidget: MuiAutocompleteWidget$1,
  MuiFieldSelect: MuiFieldSelect$1,
  MuiFieldAutocomplete: MuiFieldAutocomplete$1,
  MuiButton: MuiButton$1,
  MuiButtonGroup: MuiButtonGroup$1,
  MuiConjs: MuiConjs$1,
  MuiSwitch: MuiSwitch$1,
  MuiValueSources: MuiValueSources$1,
  MuiConfirm: MuiConfirm$1,
  MuiUseConfirm: useConfirm,
  MuiProvider: MuiProvider$1
};
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var _Utils$ExportUtils = Utils.ExportUtils, SqlString = _Utils$ExportUtils.SqlString, stringifyForDisplay2 = _Utils$ExportUtils.stringifyForDisplay;
var MuiBooleanWidget = MuiWidgets.MuiBooleanWidget, MuiTextWidget = MuiWidgets.MuiTextWidget, MuiTextAreaWidget = MuiWidgets.MuiTextAreaWidget, MuiDateWidget = MuiWidgets.MuiDateWidget, MuiTimeWidget = MuiWidgets.MuiTimeWidget, MuiDateTimeWidget = MuiWidgets.MuiDateTimeWidget, MuiMultiSelectWidget = MuiWidgets.MuiMultiSelectWidget, MuiSelectWidget = MuiWidgets.MuiSelectWidget, MuiNumberWidget = MuiWidgets.MuiNumberWidget, MuiSliderWidget = MuiWidgets.MuiSliderWidget, MuiRangeWidget = MuiWidgets.MuiRangeWidget, MuiAutocompleteWidget = MuiWidgets.MuiAutocompleteWidget, MuiFieldSelect = MuiWidgets.MuiFieldSelect, MuiFieldAutocomplete = MuiWidgets.MuiFieldAutocomplete, MuiConjs = MuiWidgets.MuiConjs, MuiSwitch = MuiWidgets.MuiSwitch, MuiButton = MuiWidgets.MuiButton, MuiButtonGroup = MuiWidgets.MuiButtonGroup, MuiValueSources = MuiWidgets.MuiValueSources, MuiProvider2 = MuiWidgets.MuiProvider, MuiConfirm = MuiWidgets.MuiConfirm, MuiUseConfirm = MuiWidgets.MuiUseConfirm;
var settings$1 = _objectSpread(_objectSpread({}, BasicConfig.settings), {}, {
  renderField: function renderField2(props) {
    var _props$customProps;
    return props !== null && props !== void 0 && (_props$customProps = props.customProps) !== null && _props$customProps !== void 0 && _props$customProps.showSearch ? /* @__PURE__ */ React.createElement(MuiFieldAutocomplete, props) : /* @__PURE__ */ React.createElement(MuiFieldSelect, props);
  },
  renderOperator: function renderOperator2(props) {
    return /* @__PURE__ */ React.createElement(MuiFieldSelect, props);
  },
  renderFunc: function renderFunc2(props) {
    return /* @__PURE__ */ React.createElement(MuiFieldSelect, props);
  },
  renderConjs: function renderConjs2(props) {
    return /* @__PURE__ */ React.createElement(MuiConjs, props);
  },
  renderSwitch: function renderSwitch2(props) {
    return /* @__PURE__ */ React.createElement(MuiSwitch, props);
  },
  renderButton: function renderButton2(props) {
    return /* @__PURE__ */ React.createElement(MuiButton, props);
  },
  renderButtonGroup: function renderButtonGroup2(props) {
    return /* @__PURE__ */ React.createElement(MuiButtonGroup, props);
  },
  renderValueSources: function renderValueSources2(props) {
    return /* @__PURE__ */ React.createElement(MuiValueSources, props);
  },
  renderProvider: function renderProvider2(props) {
    return /* @__PURE__ */ React.createElement(MuiProvider2, props);
  },
  renderConfirm: MuiConfirm,
  useConfirm: MuiUseConfirm
});
var widgets$1 = _objectSpread(_objectSpread({}, BasicConfig.widgets), {}, {
  text: _objectSpread(_objectSpread({}, BasicConfig.widgets.text), {}, {
    factory: function factory15(props) {
      return /* @__PURE__ */ React.createElement(MuiTextWidget, props);
    }
  }),
  textarea: _objectSpread(_objectSpread({}, BasicConfig.widgets.textarea), {}, {
    factory: function factory16(props) {
      return /* @__PURE__ */ React.createElement(MuiTextAreaWidget, props);
    }
  }),
  number: _objectSpread(_objectSpread({}, BasicConfig.widgets.number), {}, {
    factory: function factory17(props) {
      return /* @__PURE__ */ React.createElement(MuiNumberWidget, props);
    }
  }),
  multiselect: _objectSpread(_objectSpread({}, BasicConfig.widgets.multiselect), {}, {
    factory: function factory18(props) {
      return props.asyncFetch || props.showSearch ? /* @__PURE__ */ React.createElement(MuiAutocompleteWidget, _extends$h({
        multiple: true
      }, props)) : /* @__PURE__ */ React.createElement(MuiMultiSelectWidget, props);
    }
  }),
  select: _objectSpread(_objectSpread({}, BasicConfig.widgets.select), {}, {
    factory: function factory19(props) {
      return props.asyncFetch || props.showSearch ? /* @__PURE__ */ React.createElement(MuiAutocompleteWidget, props) : /* @__PURE__ */ React.createElement(MuiSelectWidget, props);
    }
  }),
  slider: _objectSpread(_objectSpread({}, BasicConfig.widgets.slider), {}, {
    factory: function factory20(props) {
      return /* @__PURE__ */ React.createElement(MuiSliderWidget, props);
    }
  }),
  "boolean": _objectSpread(_objectSpread({}, BasicConfig.widgets["boolean"]), {}, {
    factory: function factory21(props) {
      return /* @__PURE__ */ React.createElement(MuiBooleanWidget, props);
    }
  }),
  date: _objectSpread(_objectSpread({}, BasicConfig.widgets.date), {}, {
    factory: function factory22(props) {
      return /* @__PURE__ */ React.createElement(MuiDateWidget, props);
    }
  }),
  time: _objectSpread(_objectSpread({}, BasicConfig.widgets.time), {}, {
    factory: function factory23(props) {
      return /* @__PURE__ */ React.createElement(MuiTimeWidget, props);
    }
  }),
  datetime: _objectSpread(_objectSpread({}, BasicConfig.widgets.datetime), {}, {
    factory: function factory24(props) {
      return /* @__PURE__ */ React.createElement(MuiDateTimeWidget, props);
    }
  }),
  rangeslider: {
    type: "number",
    jsType: "number",
    valueSrc: "value",
    factory: function factory25(props) {
      return /* @__PURE__ */ React.createElement(MuiRangeWidget, props);
    },
    valueLabel: "Range",
    valuePlaceholder: "Select range",
    valueLabels: [{
      label: "Number from",
      placeholder: "Enter number from"
    }, {
      label: "Number to",
      placeholder: "Enter number to"
    }],
    formatValue: function formatValue18(val, fieldDef, wgtDef, isForDisplay) {
      return isForDisplay ? stringifyForDisplay2(val) : JSON.stringify(val);
    },
    sqlFormatValue: function sqlFormatValue12(val, fieldDef, wgtDef, op, opDef) {
      return SqlString.escape(val);
    },
    singleWidget: "slider",
    toJS: function toJS11(val, fieldSettings) {
      return val;
    }
  }
});
var types$1 = _objectSpread(_objectSpread({}, BasicConfig.types), {}, {
  number: _objectSpread(_objectSpread({}, BasicConfig.types.number), {}, {
    widgets: _objectSpread(_objectSpread({}, BasicConfig.types.number.widgets), {}, {
      rangeslider: {
        opProps: {
          between: {
            isSpecialRange: true
          },
          not_between: {
            isSpecialRange: true
          }
        },
        operators: ["between", "not_between", "is_empty", "is_not_empty"]
      }
    })
  })
});
const MuiConfig = _objectSpread(_objectSpread({}, BasicConfig), {}, {
  types: types$1,
  widgets: widgets$1,
  settings: settings$1
});
var lodash_merge = { exports: {} };
lodash_merge.exports;
(function(module2, exports2) {
  var LARGE_ARRAY_SIZE2 = 200;
  var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
  var HOT_COUNT2 = 800, HOT_SPAN2 = 16;
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  var argsTag2 = "[object Arguments]", arrayTag2 = "[object Array]", asyncTag2 = "[object AsyncFunction]", boolTag2 = "[object Boolean]", dateTag2 = "[object Date]", errorTag2 = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag2 = "[object Map]", numberTag2 = "[object Number]", nullTag2 = "[object Null]", objectTag2 = "[object Object]", proxyTag2 = "[object Proxy]", regexpTag2 = "[object RegExp]", setTag2 = "[object Set]", stringTag2 = "[object String]", undefinedTag2 = "[object Undefined]", weakMapTag2 = "[object WeakMap]";
  var arrayBufferTag2 = "[object ArrayBuffer]", dataViewTag2 = "[object DataView]", float32Tag2 = "[object Float32Array]", float64Tag2 = "[object Float64Array]", int8Tag2 = "[object Int8Array]", int16Tag2 = "[object Int16Array]", int32Tag2 = "[object Int32Array]", uint8Tag2 = "[object Uint8Array]", uint8ClampedTag2 = "[object Uint8ClampedArray]", uint16Tag2 = "[object Uint16Array]", uint32Tag2 = "[object Uint32Array]";
  var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
  var reIsUint2 = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags2 = {};
  typedArrayTags2[float32Tag2] = typedArrayTags2[float64Tag2] = typedArrayTags2[int8Tag2] = typedArrayTags2[int16Tag2] = typedArrayTags2[int32Tag2] = typedArrayTags2[uint8Tag2] = typedArrayTags2[uint8ClampedTag2] = typedArrayTags2[uint16Tag2] = typedArrayTags2[uint32Tag2] = true;
  typedArrayTags2[argsTag2] = typedArrayTags2[arrayTag2] = typedArrayTags2[arrayBufferTag2] = typedArrayTags2[boolTag2] = typedArrayTags2[dataViewTag2] = typedArrayTags2[dateTag2] = typedArrayTags2[errorTag2] = typedArrayTags2[funcTag2] = typedArrayTags2[mapTag2] = typedArrayTags2[numberTag2] = typedArrayTags2[objectTag2] = typedArrayTags2[regexpTag2] = typedArrayTags2[setTag2] = typedArrayTags2[stringTag2] = typedArrayTags2[weakMapTag2] = false;
  var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
  var freeExports2 = exports2 && !exports2.nodeType && exports2;
  var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var freeProcess2 = moduleExports2 && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types2 = freeModule2 && freeModule2.require && freeModule2.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
    } catch (e2) {
    }
  }();
  var nodeIsTypedArray2 = nodeUtil2 && nodeUtil2.isTypedArray;
  function apply2(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  function baseTimes2(n2, iteratee) {
    var index2 = -1, result = Array(n2);
    while (++index2 < n2) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  function baseUnary2(func) {
    return function(value) {
      return func(value);
    };
  }
  function getValue2(object, key) {
    return object == null ? void 0 : object[key];
  }
  function overArg2(func, transform2) {
    return function(arg) {
      return func(transform2(arg));
    };
  }
  var arrayProto2 = Array.prototype, funcProto2 = Function.prototype, objectProto2 = Object.prototype;
  var coreJsData2 = root2["__core-js_shared__"];
  var funcToString2 = funcProto2.toString;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var maskSrcKey2 = function() {
    var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var nativeObjectToString2 = objectProto2.toString;
  var objectCtorString2 = funcToString2.call(Object);
  var reIsNative2 = RegExp(
    "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var Buffer2 = moduleExports2 ? root2.Buffer : void 0, Symbol2 = root2.Symbol, Uint8Array2 = root2.Uint8Array, allocUnsafe2 = Buffer2 ? Buffer2.allocUnsafe : void 0, getPrototype2 = overArg2(Object.getPrototypeOf, Object), objectCreate2 = Object.create, propertyIsEnumerable2 = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice, symToStringTag2 = Symbol2 ? Symbol2.toStringTag : void 0;
  var defineProperty2 = function() {
    try {
      var func = getNative2(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e2) {
    }
  }();
  var nativeIsBuffer2 = Buffer2 ? Buffer2.isBuffer : void 0, nativeMax2 = Math.max, nativeNow2 = Date.now;
  var Map2 = getNative2(root2, "Map"), nativeCreate2 = getNative2(Object, "create");
  var baseCreate2 = function() {
    function object() {
    }
    return function(proto2) {
      if (!isObject5(proto2)) {
        return {};
      }
      if (objectCreate2) {
        return objectCreate2(proto2);
      }
      object.prototype = proto2;
      var result = new object();
      object.prototype = void 0;
      return result;
    };
  }();
  function Hash2(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear2() {
    this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
    this.size = 0;
  }
  function hashDelete2(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  function hashGet2(key) {
    var data = this.__data__;
    if (nativeCreate2) {
      var result = data[key];
      return result === HASH_UNDEFINED2 ? void 0 : result;
    }
    return hasOwnProperty2.call(data, key) ? data[key] : void 0;
  }
  function hashHas2(key) {
    var data = this.__data__;
    return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
  }
  function hashSet2(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED2 : value;
    return this;
  }
  Hash2.prototype.clear = hashClear2;
  Hash2.prototype["delete"] = hashDelete2;
  Hash2.prototype.get = hashGet2;
  Hash2.prototype.has = hashHas2;
  Hash2.prototype.set = hashSet2;
  function ListCache2(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear2() {
    this.__data__ = [];
    this.size = 0;
  }
  function listCacheDelete2(key) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index2 == lastIndex) {
      data.pop();
    } else {
      splice2.call(data, index2, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet2(key) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    return index2 < 0 ? void 0 : data[index2][1];
  }
  function listCacheHas2(key) {
    return assocIndexOf2(this.__data__, key) > -1;
  }
  function listCacheSet2(key, value) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    if (index2 < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index2][1] = value;
    }
    return this;
  }
  ListCache2.prototype.clear = listCacheClear2;
  ListCache2.prototype["delete"] = listCacheDelete2;
  ListCache2.prototype.get = listCacheGet2;
  ListCache2.prototype.has = listCacheHas2;
  ListCache2.prototype.set = listCacheSet2;
  function MapCache2(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear2() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash2(),
      "map": new (Map2 || ListCache2)(),
      "string": new Hash2()
    };
  }
  function mapCacheDelete2(key) {
    var result = getMapData2(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet2(key) {
    return getMapData2(this, key).get(key);
  }
  function mapCacheHas2(key) {
    return getMapData2(this, key).has(key);
  }
  function mapCacheSet2(key, value) {
    var data = getMapData2(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  MapCache2.prototype.clear = mapCacheClear2;
  MapCache2.prototype["delete"] = mapCacheDelete2;
  MapCache2.prototype.get = mapCacheGet2;
  MapCache2.prototype.has = mapCacheHas2;
  MapCache2.prototype.set = mapCacheSet2;
  function Stack2(entries) {
    var data = this.__data__ = new ListCache2(entries);
    this.size = data.size;
  }
  function stackClear2() {
    this.__data__ = new ListCache2();
    this.size = 0;
  }
  function stackDelete2(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  function stackGet2(key) {
    return this.__data__.get(key);
  }
  function stackHas2(key) {
    return this.__data__.has(key);
  }
  function stackSet2(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache2) {
      var pairs = data.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE2 - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache2(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  Stack2.prototype.clear = stackClear2;
  Stack2.prototype["delete"] = stackDelete2;
  Stack2.prototype.get = stackGet2;
  Stack2.prototype.has = stackHas2;
  Stack2.prototype.set = stackSet2;
  function arrayLikeKeys2(value, inherited) {
    var isArr = isArray2(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes2(value.length, String) : [], length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
      isIndex2(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assignMergeValue2(object, key, value) {
    if (value !== void 0 && !eq2(object[key], value) || value === void 0 && !(key in object)) {
      baseAssignValue2(object, key, value);
    }
  }
  function assignValue2(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty2.call(object, key) && eq2(objValue, value)) || value === void 0 && !(key in object)) {
      baseAssignValue2(object, key, value);
    }
  }
  function assocIndexOf2(array, key) {
    var length = array.length;
    while (length--) {
      if (eq2(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseAssignValue2(object, key, value) {
    if (key == "__proto__" && defineProperty2) {
      defineProperty2(object, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object[key] = value;
    }
  }
  var baseFor2 = createBaseFor2();
  function baseGetTag2(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag2 : nullTag2;
    }
    return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag2(value) : objectToString2(value);
  }
  function baseIsArguments2(value) {
    return isObjectLike2(value) && baseGetTag2(value) == argsTag2;
  }
  function baseIsNative2(value) {
    if (!isObject5(value) || isMasked2(value)) {
      return false;
    }
    var pattern = isFunction2(value) ? reIsNative2 : reIsHostCtor2;
    return pattern.test(toSource2(value));
  }
  function baseIsTypedArray2(value) {
    return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags2[baseGetTag2(value)];
  }
  function baseKeysIn2(object) {
    if (!isObject5(object)) {
      return nativeKeysIn2(object);
    }
    var isProto = isPrototype2(object), result = [];
    for (var key in object) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  function baseMerge2(object, source, srcIndex, customizer, stack) {
    if (object === source) {
      return;
    }
    baseFor2(source, function(srcValue, key) {
      stack || (stack = new Stack2());
      if (isObject5(srcValue)) {
        baseMergeDeep2(object, source, key, srcIndex, baseMerge2, customizer, stack);
      } else {
        var newValue = customizer ? customizer(safeGet2(object, key), srcValue, key + "", object, source, stack) : void 0;
        if (newValue === void 0) {
          newValue = srcValue;
        }
        assignMergeValue2(object, key, newValue);
      }
    }, keysIn2);
  }
  function baseMergeDeep2(object, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet2(object, key), srcValue = safeGet2(source, key), stacked = stack.get(srcValue);
    if (stacked) {
      assignMergeValue2(object, key, stacked);
      return;
    }
    var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
    var isCommon = newValue === void 0;
    if (isCommon) {
      var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray2(objValue)) {
          newValue = objValue;
        } else if (isArrayLikeObject2(objValue)) {
          newValue = copyArray2(objValue);
        } else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer2(srcValue, true);
        } else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray2(srcValue, true);
        } else {
          newValue = [];
        }
      } else if (isPlainObject2(srcValue) || isArguments2(srcValue)) {
        newValue = objValue;
        if (isArguments2(objValue)) {
          newValue = toPlainObject2(objValue);
        } else if (!isObject5(objValue) || isFunction2(objValue)) {
          newValue = initCloneObject2(srcValue);
        }
      } else {
        isCommon = false;
      }
    }
    if (isCommon) {
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack["delete"](srcValue);
    }
    assignMergeValue2(object, key, newValue);
  }
  function baseRest2(func, start2) {
    return setToString2(overRest2(func, start2, identity2), func + "");
  }
  var baseSetToString2 = !defineProperty2 ? identity2 : function(func, string) {
    return defineProperty2(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant2(string),
      "writable": true
    });
  };
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe2 ? allocUnsafe2(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  function cloneArrayBuffer2(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
    return result;
  }
  function cloneTypedArray2(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer2(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  function copyArray2(source, array) {
    var index2 = -1, length = source.length;
    array || (array = Array(length));
    while (++index2 < length) {
      array[index2] = source[index2];
    }
    return array;
  }
  function copyObject2(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index2 = -1, length = props.length;
    while (++index2 < length) {
      var key = props[index2];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
      if (newValue === void 0) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue2(object, key, newValue);
      } else {
        assignValue2(object, key, newValue);
      }
    }
    return object;
  }
  function createAssigner2(assigner) {
    return baseRest2(function(object, sources) {
      var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
      if (guard && isIterateeCall2(sources[0], sources[1], guard)) {
        customizer = length < 3 ? void 0 : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index2 < length) {
        var source = sources[index2];
        if (source) {
          assigner(object, source, index2, customizer);
        }
      }
      return object;
    });
  }
  function createBaseFor2(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
      while (length--) {
        var key = props[fromRight ? length : ++index2];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }
  function getMapData2(map2, key) {
    var data = map2.__data__;
    return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative2(object, key) {
    var value = getValue2(object, key);
    return baseIsNative2(value) ? value : void 0;
  }
  function getRawTag2(value) {
    var isOwn = hasOwnProperty2.call(value, symToStringTag2), tag = value[symToStringTag2];
    try {
      value[symToStringTag2] = void 0;
      var unmasked = true;
    } catch (e2) {
    }
    var result = nativeObjectToString2.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag2] = tag;
      } else {
        delete value[symToStringTag2];
      }
    }
    return result;
  }
  function initCloneObject2(object) {
    return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate2(getPrototype2(object)) : {};
  }
  function isIndex2(value, length) {
    var type2 = typeof value;
    length = length == null ? MAX_SAFE_INTEGER2 : length;
    return !!length && (type2 == "number" || type2 != "symbol" && reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isIterateeCall2(value, index2, object) {
    if (!isObject5(object)) {
      return false;
    }
    var type2 = typeof index2;
    if (type2 == "number" ? isArrayLike2(object) && isIndex2(index2, object.length) : type2 == "string" && index2 in object) {
      return eq2(object[index2], value);
    }
    return false;
  }
  function isKeyable2(value) {
    var type2 = typeof value;
    return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked2(func) {
    return !!maskSrcKey2 && maskSrcKey2 in func;
  }
  function isPrototype2(value) {
    var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto2;
    return value === proto2;
  }
  function nativeKeysIn2(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }
  function objectToString2(value) {
    return nativeObjectToString2.call(value);
  }
  function overRest2(func, start2, transform2) {
    start2 = nativeMax2(start2 === void 0 ? func.length - 1 : start2, 0);
    return function() {
      var args = arguments, index2 = -1, length = nativeMax2(args.length - start2, 0), array = Array(length);
      while (++index2 < length) {
        array[index2] = args[start2 + index2];
      }
      index2 = -1;
      var otherArgs = Array(start2 + 1);
      while (++index2 < start2) {
        otherArgs[index2] = args[index2];
      }
      otherArgs[start2] = transform2(array);
      return apply2(func, this, otherArgs);
    };
  }
  function safeGet2(object, key) {
    if (key === "constructor" && typeof object[key] === "function") {
      return;
    }
    if (key == "__proto__") {
      return;
    }
    return object[key];
  }
  var setToString2 = shortOut2(baseSetToString2);
  function shortOut2(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow2(), remaining = HOT_SPAN2 - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT2) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  function toSource2(func) {
    if (func != null) {
      try {
        return funcToString2.call(func);
      } catch (e2) {
      }
      try {
        return func + "";
      } catch (e2) {
      }
    }
    return "";
  }
  function eq2(value, other) {
    return value === other || value !== value && other !== other;
  }
  var isArguments2 = baseIsArguments2(function() {
    return arguments;
  }()) ? baseIsArguments2 : function(value) {
    return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable2.call(value, "callee");
  };
  var isArray2 = Array.isArray;
  function isArrayLike2(value) {
    return value != null && isLength2(value.length) && !isFunction2(value);
  }
  function isArrayLikeObject2(value) {
    return isObjectLike2(value) && isArrayLike2(value);
  }
  var isBuffer2 = nativeIsBuffer2 || stubFalse2;
  function isFunction2(value) {
    if (!isObject5(value)) {
      return false;
    }
    var tag = baseGetTag2(value);
    return tag == funcTag2 || tag == genTag2 || tag == asyncTag2 || tag == proxyTag2;
  }
  function isLength2(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
  }
  function isObject5(value) {
    var type2 = typeof value;
    return value != null && (type2 == "object" || type2 == "function");
  }
  function isObjectLike2(value) {
    return value != null && typeof value == "object";
  }
  function isPlainObject2(value) {
    if (!isObjectLike2(value) || baseGetTag2(value) != objectTag2) {
      return false;
    }
    var proto2 = getPrototype2(value);
    if (proto2 === null) {
      return true;
    }
    var Ctor = hasOwnProperty2.call(proto2, "constructor") && proto2.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString2.call(Ctor) == objectCtorString2;
  }
  var isTypedArray2 = nodeIsTypedArray2 ? baseUnary2(nodeIsTypedArray2) : baseIsTypedArray2;
  function toPlainObject2(value) {
    return copyObject2(value, keysIn2(value));
  }
  function keysIn2(object) {
    return isArrayLike2(object) ? arrayLikeKeys2(object, true) : baseKeysIn2(object);
  }
  var merge2 = createAssigner2(function(object, source, srcIndex) {
    baseMerge2(object, source, srcIndex);
  });
  function constant2(value) {
    return function() {
      return value;
    };
  }
  function identity2(value) {
    return value;
  }
  function stubFalse2() {
    return false;
  }
  module2.exports = merge2;
})(lodash_merge, lodash_merge.exports);
var lodash_mergeExports = lodash_merge.exports;
const merge = /* @__PURE__ */ getDefaultExportFromCjs(lodash_mergeExports);
const InitialConfig = MuiConfig;
const wrapField = (field) => {
  return '<span class="logicField">' + field + "</span>";
};
const wrapOperator = (op) => {
  return '<span class="logicOp">' + op + "</span>";
};
const wrapValue = (value, valueTypes) => {
  return '<span class="logicValue">' + (valueTypes == "text" ? '"' + value + '"' : value) + "</span>";
};
const conjunctions = {
  AND: InitialConfig.conjunctions.AND,
  OR: InitialConfig.conjunctions.OR
};
const operators = {
  ...InitialConfig.operators,
  less: {
    ...InitialConfig.operators.less,
    formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
      return `${wrapField(field)} ${wrapOperator("<")} ${wrapValue(
        value,
        valueTypes
      )}`;
    }
  },
  less_or_equal: {
    ...InitialConfig.operators.less_or_equal,
    formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
      return `${wrapField(field)} ${wrapOperator("<=")} ${wrapValue(
        value,
        valueTypes
      )}`;
    }
  },
  greater: {
    ...InitialConfig.operators.greater,
    formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
      return `${wrapField(field)} ${wrapOperator(">")} ${wrapValue(
        value,
        valueTypes
      )}`;
    }
  },
  greater_or_equal: {
    ...InitialConfig.operators.greater_or_equal,
    formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
      return `${wrapField(field)} ${wrapOperator(">=")} ${wrapValue(
        value,
        valueTypes
      )}`;
    }
  },
  equal: {
    ...InitialConfig.operators.equal,
    label: "Equals",
    jsonLogic: "==",
    formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
      const opStr = isForDisplay ? "equals" : opDef.label;
      return `${wrapField(field)} ${wrapOperator(opStr)} ${wrapValue(
        value,
        valueTypes
      )}`;
    }
  },
  not_equal: {
    ...InitialConfig.operators.not_equal,
    label: "Not Equals",
    jsonLogic: "!=",
    formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
      const opStr = isForDisplay ? "not equals" : opDef.label;
      return `${wrapField(field)} ${wrapOperator(opStr)} ${wrapValue(
        value,
        valueTypes
      )}`;
    }
  },
  starts_with: {
    ...InitialConfig.operators.starts_with,
    jsonLogic: "startsWith",
    formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
      const opStr = isForDisplay ? "starts with" : opDef.label;
      return `${wrapField(field)} ${wrapOperator(opStr)} ${wrapValue(
        value,
        valueTypes
      )}`;
    }
  },
  ends_with: {
    ...InitialConfig.operators.ends_with,
    jsonLogic: "endsWith",
    formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
      const opStr = isForDisplay ? "ends with" : opDef.label;
      return `${wrapField(field)} ${wrapOperator(opStr)} ${wrapValue(
        value,
        valueTypes
      )}`;
    }
  },
  between: {
    ...InitialConfig.operators.between,
    label: "Between",
    jsonLogic: "between",
    formatOp: (field, op, values, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay) => {
      let valFrom = values.first();
      let valTo = values.get(1);
      if (isForDisplay)
        return `${wrapField(field)} ${wrapOperator("between")} ${wrapValue(
          valFrom,
          valueTypes
        )} ${wrapOperator("and")} ${wrapValue(valTo, valueTypes)}`;
      else
        return `${field} >= ${valFrom} && ${field} <= ${valTo}`;
    }
  },
  not_between: {
    ...InitialConfig.operators.not_between,
    label: "Not Between",
    jsonLogic: "not_between",
    formatOp: (field, op, values, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay) => {
      let valFrom = values.first();
      let valTo = values.get(1);
      if (isForDisplay)
        return `${wrapField(field)} ${wrapOperator("not between")} ${wrapValue(
          valFrom,
          valueTypes
        )} ${wrapOperator("and")} ${wrapValue(valTo, valueTypes)}`;
      else
        return `${field} >= ${valFrom} && ${field} <= ${valTo}`;
    }
  },
  like: {
    ...InitialConfig.operators.like,
    label: "Contains",
    jsonLogic: "contains",
    _jsonLogicIsRevArgs: false,
    formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
      const opStr = isForDisplay ? "contains" : opDef.label;
      return `${wrapField(field)} ${wrapOperator(opStr)} ${wrapValue(
        value,
        valueTypes
      )}`;
    }
  },
  not_like: {
    ...InitialConfig.operators.not_like,
    label: "Not Contains",
    jsonLogic: "not_contains",
    formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
      const opStr = isForDisplay ? "does not containends with" : opDef.label;
      return `${wrapField(field)} ${wrapOperator(opStr)} ${wrapValue(
        value,
        valueTypes
      )}`;
    }
  },
  select_any_in: {
    ...InitialConfig.operators.select_any_in,
    label: "Any In",
    jsonLogic: "in",
    formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
      let formattedValues = values.join(", ");
      return `${wrapField(field)} ${wrapOperator("in")} (${wrapValue(
        formattedValues,
        ""
      )})`;
    }
  },
  select_not_any_in: {
    ...InitialConfig.operators.select_not_any_in,
    label: "None In",
    jsonLogic: "not_in",
    formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
      let formattedValues = values.join(", ");
      return `${wrapField(field)} ${wrapOperator("not in")} (${wrapValue(
        formattedValues,
        ""
      )})`;
    }
  },
  multiselect_equals: {
    ...InitialConfig.operators.multiselect_equals,
    label: "Any In",
    jsonLogic: "any_in",
    formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
      let formattedValues = values.join(", ");
      return `${wrapOperator("Any of")} (${wrapValue(
        formattedValues,
        ""
      )}) in ${wrapField(field)} ${wrapOperator("is selected")}`;
    }
  },
  multiselect_not_equals: {
    ...InitialConfig.operators.multiselect_not_equals,
    label: "None In",
    jsonLogic: "none_in",
    formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
      let formattedValues = values.join(", ");
      return `${wrapOperator("None of")} (${wrapValue(
        formattedValues,
        ""
      )}) in ${wrapField(field)} ${wrapOperator("is selected")}`;
    }
  },
  is_relevant: {
    label: "Is Displayed",
    jsonLogic: "relevance",
    cardinality: 0,
    formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
      return `${wrapField(field)} ${wrapValue("is shown")}`;
    }
  },
  is_not_relevant: {
    label: "Is Hidden",
    jsonLogic: "not_relevance",
    cardinality: 0,
    formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
      return `${wrapField(field)} ${wrapValue("is not shown")}`;
    }
  },
  is_valid: {
    label: "Is Valid",
    jsonLogic: "validity",
    cardinality: 0,
    formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
      return `${wrapField(field)} ${wrapValue("is valid")}`;
    }
  },
  is_not_valid: {
    label: "Is Not Valid",
    jsonLogic: "not_validity",
    cardinality: 0,
    formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
      return `${wrapField(field)} ${wrapValue("is not valid")}`;
    }
  },
  is_void: {
    cardinality: 0,
    label: "Is Empty",
    jsonLogic: "is_void",
    formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
      return `${wrapField(field)} ${wrapValue("is empty")}`;
    }
  },
  is_not_void: {
    cardinality: 0,
    label: "Is not Empty",
    jsonLogic: "is_not_void",
    formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
      return `${wrapField(field)} ${wrapValue("is not empty")}`;
    }
  },
  is_file_void: {
    cardinality: 0,
    label: "Is Empty",
    jsonLogic: "is_file_void",
    formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
      return `${wrapField(field)} ${wrapValue("is empty")}`;
    }
  },
  is_file_not_void: {
    cardinality: 0,
    label: "Is not Empty",
    jsonLogic: "is_file_not_void",
    formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
      return `${wrapField(field)} ${wrapValue("is not empty")}`;
    }
  }
};
const widgets = {
  ...InitialConfig.widgets,
  // examples of  overriding
  text: {
    ...InitialConfig.widgets.text
  },
  slider: {
    ...InitialConfig.widgets.slider,
    customProps: {
      width: "300px"
    }
  },
  rangeslider: {
    ...InitialConfig.widgets.rangeslider,
    customProps: {
      width: "300px"
    }
  },
  date: {
    ...InitialConfig.widgets.date,
    dateFormat: "DD.MM.YYYY",
    valueFormat: "YYYY-MM-DD"
  },
  time: {
    ...InitialConfig.widgets.time,
    timeFormat: "HH:mm",
    valueFormat: "HH:mm:ss"
  },
  datetime: {
    ...InitialConfig.widgets.datetime,
    timeFormat: "HH:mm",
    dateFormat: "DD.MM.YYYY",
    valueFormat: "YYYY-MM-DD HH:mm:ss"
  },
  func: {
    ...InitialConfig.widgets.func,
    customProps: {
      showSearch: true
    }
  },
  treeselect: {
    ...InitialConfig.widgets.treeselect,
    customProps: {
      showSearch: true
    }
  }
};
const types = {
  ...InitialConfig.types,
  boolean: merge(InitialConfig.types.boolean, {
    widgets: {
      boolean: {
        widgetProps: {
          hideOperator: true,
          operatorInlineLabel: "is"
        }
      }
    }
  })
};
const localeSettings = {
  valueLabel: "Value",
  valuePlaceholder: "Value",
  fieldLabel: "Field",
  operatorLabel: "Operator",
  fieldPlaceholder: "Select field",
  operatorPlaceholder: "Select operator",
  deleteLabel: null,
  addGroupLabel: "Add group",
  addRuleLabel: "Add rule",
  addSubRuleLabel: "Add sub rule",
  delGroupLabel: null,
  notLabel: "Not",
  valueSourcesPopupTitle: "Select value source",
  removeRuleConfirmOptions: {
    title: "Are you sure delete this rule?",
    okText: "Yes",
    okType: "danger"
  },
  removeGroupConfirmOptions: {
    title: "Are you sure delete this group?",
    okText: "Yes",
    okType: "danger"
  }
};
const settings = {
  ...InitialConfig.settings,
  ...localeSettings,
  valueSourcesInfo: {
    value: {
      label: "Value"
    },
    field: {
      label: "Field",
      widget: "field"
    },
    func: {
      label: "Function",
      widget: "func"
    }
  },
  canReorder: false,
  showNot: false,
  maxNesting: 1,
  canLeaveEmptyGroup: false
  //after deletion
};
const funcs = {};
const config = {
  conjunctions,
  operators,
  widgets,
  types,
  settings,
  funcs
};
const styles$b = "";
const override = "";
function LogicBuilder(props) {
  const {
    jsonLogicFormat: jsonLogicFormat3,
    queryString: queryString3,
    loadTree: loadTree3,
    uuid: uuid2,
    loadFromJsonLogic: loadFromJsonLogic3,
    checkTree: checkTree3
  } = Utils;
  const config$1 = { ...config, fields: props.fields };
  const initTree = props.logic ? checkTree3(loadFromJsonLogic3(props.logic, config$1), config$1) : loadTree3({ id: uuid2(), type: "group" });
  const [tree2, setTree3] = reactExports.useState(initTree);
  const [html, setHtml] = reactExports.useState(queryString3(tree2, config$1, true));
  const renderBuilder = (props2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { jey: "builder", className: "query-builder-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "query-builder", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Builder$1, { ...props2 }) }) });
  const onChange = (immutableTree) => {
    setTree3(immutableTree);
  };
  const saveState = () => {
    const { logic, errors } = jsonLogicFormat3(tree2, config$1);
    setHtml(queryString3(tree2, config$1, true));
    props.onChange(logic);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "query-builder-result", children: [
      props.logic && html ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        "pre",
        {
          className: "condition-human-text",
          dangerouslySetInnerHTML: { __html: html }
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "condition-human-text", children: props.t("no_condition") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: () => props.onDialogStateChanged(true), children: /* @__PURE__ */ jsxRuntimeExports.jsx(EditOutlined, {}) })
    ] }, "result"),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Dialog,
      {
        fullScreen: true,
        sx: { margin: "200px" },
        open: props.dialogOpen,
        onClose: () => props.onDialogStateChanged(false),
        "aria-labelledby": "alert-dialog-title-logic-builder",
        "aria-describedby": "alert-dialog-description",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { id: "alert-dialog-title-logic-builder", children: props.title }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            QueryContainer,
            {
              ...config$1,
              value: tree2,
              onChange,
              renderBuilder
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActions, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              onClick: () => {
                props.onDialogStateChanged(false);
                saveState();
              },
              autoFocus: true,
              children: "Agree"
            }
          ) })
        ]
      }
    )
  ] });
}
const buildFields = (componentIndices, code, state, mainLang) => {
  let dependencies = accessibleDependencies(componentIndices, code);
  let returnResult = {};
  dependencies.forEach((el) => {
    if (state[el] && (isQuestion(el) || isGroup(el))) {
      returnResult = {
        ...returnResult,
        ...buildField$1(el, state[el], state, mainLang)
      };
    }
  });
  return returnResult;
};
const buildField$1 = (code, component, state, mainLang) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
  const label2 = code + ". " + stripTags((_b = (_a = component.content) == null ? void 0 : _a.label) == null ? void 0 : _b[mainLang]);
  if (isGroup(code)) {
    return {
      [code]: {
        label: label2,
        type: "text",
        valueSources: ["value"],
        operators: [
          "is_relevant",
          "is_not_relevant",
          "is_valid",
          "is_not_valid"
        ]
      }
    };
  }
  switch (component.type) {
    case "text":
    case "barcode":
    case "email":
      return {
        [code]: {
          label: label2,
          type: "text",
          valueSources: ["value"],
          operators: [
            "is_relevant",
            "is_not_relevant",
            "is_valid",
            "is_not_valid",
            "is_void",
            "is_not_void",
            "equal",
            "not_equal",
            "like",
            "not_like",
            "starts_with",
            "ends_with"
          ]
        }
      };
    case "paragraph":
      return {
        [code]: {
          label: label2,
          type: "text",
          valueSources: ["value"],
          operators: [
            "is_relevant",
            "is_not_relevant",
            "is_valid",
            "is_not_valid",
            "is_void",
            "is_not_void",
            "like",
            "not_like",
            "starts_with",
            "ends_with"
          ]
        }
      };
    case "number":
      return {
        [code]: {
          label: label2,
          type: "number",
          valueSources: ["value"],
          operators: [
            "is_relevant",
            "is_not_relevant",
            "is_valid",
            "is_not_valid",
            "is_void",
            "is_not_void",
            "equal",
            "not_equal",
            "less",
            "less_or_equal",
            "greater",
            "greater_or_equal",
            "between",
            "not_between"
          ]
        }
      };
    case "file_upload":
      return {
        [code]: {
          label: label2,
          type: "text",
          valueSources: ["value"],
          operators: [
            "is_relevant",
            "is_not_relevant",
            "is_valid",
            "is_not_valid",
            "is_file_void",
            "is_file_not_void"
          ]
        }
      };
    case "signature":
    case "photo_capture":
    case "video_capture":
      return {
        [code]: {
          label: label2,
          type: "text",
          valueSources: ["value"],
          operators: [
            "is_relevant",
            "is_not_relevant",
            "is_valid",
            "is_not_valid",
            "is_file_void",
            "is_file_not_void"
          ]
        }
      };
    case "date":
      return {
        [code]: {
          label: label2,
          type: "date",
          valueSources: ["value"],
          operators: [
            "is_relevant",
            "is_not_relevant",
            "is_valid",
            "is_not_valid",
            "is_void",
            "is_not_void",
            "greater_or_equal",
            "less_or_equal",
            "between"
          ]
        }
      };
    case "time":
      return {
        [code]: {
          label: label2,
          type: "time",
          valueSources: ["value"],
          operators: [
            "is_relevant",
            "is_not_relevant",
            "is_valid",
            "is_not_valid",
            "is_void",
            "is_not_void",
            "greater_or_equal",
            "less_or_equal",
            "between"
          ]
        }
      };
    case "date_time":
      return {
        [code]: {
          label: label2,
          type: "datetime",
          valueSources: ["value"],
          operators: [
            "is_relevant",
            "is_not_relevant",
            "is_valid",
            "is_not_valid",
            "is_void",
            "is_not_void",
            "greater_or_equal",
            "less_or_equal",
            "between"
          ]
        }
      };
    case "image_scq":
    case "scq":
      let scqReturnList = {};
      let scqListValues = {};
      (_c = component.children) == null ? void 0 : _c.forEach((element) => {
        var _a2, _b2;
        scqListValues[element.code] = stripTags(
          (_b2 = (_a2 = state[element.qualifiedCode].content) == null ? void 0 : _a2.label) == null ? void 0 : _b2[mainLang]
        );
      });
      scqReturnList[code] = {
        label: label2,
        fieldSettings: {
          listValues: scqListValues
        },
        type: "select",
        valueSources: ["value"],
        operators: [
          "is_relevant",
          "is_not_relevant",
          "is_valid",
          "is_not_valid",
          "is_void",
          "is_not_void",
          "select_any_in",
          "select_not_any_in"
        ]
      };
      let scqOther = (_d = component.children) == null ? void 0 : _d.find((el) => el.code === "Aother");
      if (scqOther && ((_e = state[scqOther.qualifiedCode].children) == null ? void 0 : _e.find(
        (el) => el.code === "Atext"
      ))) {
        scqReturnList[code + "AotherAtext"] = {
          label: `${label2} [${(_g = (_f = state[scqOther.qualifiedCode].content) == null ? void 0 : _f.label) == null ? void 0 : _g[mainLang]}]`,
          type: "text",
          valueSources: ["value"],
          operators: [
            "is_relevant",
            "is_not_relevant",
            "is_valid",
            "is_not_valid",
            "is_void",
            "is_not_void",
            "equal",
            "not_equal",
            "like",
            "not_like",
            "starts_with",
            "ends_with"
          ]
        };
      }
      return scqReturnList;
    case "image_mcq":
    case "mcq":
      let mcqReturnList = {};
      let mcqListValues = {};
      (_h = component.children) == null ? void 0 : _h.forEach((element) => {
        var _a2, _b2;
        mcqListValues[element.code] = stripTags(
          (_b2 = (_a2 = state[element.qualifiedCode].content) == null ? void 0 : _a2.label) == null ? void 0 : _b2[mainLang]
        );
      });
      mcqReturnList[code] = {
        label: label2,
        fieldSettings: {
          listValues: mcqListValues
        },
        type: "multiselect",
        valueSources: ["value"],
        operators: [
          "is_relevant",
          "is_not_relevant",
          "is_valid",
          "is_not_valid",
          "multiselect_equals",
          "multiselect_not_equals"
        ]
      };
      let mcqOther = (_i = component.children) == null ? void 0 : _i.find((el) => el.code === "Aother");
      if (mcqOther && ((_j = state[mcqOther.qualifiedCode].children) == null ? void 0 : _j.find(
        (el) => el.code === "Atext"
      ))) {
        mcqReturnList[code + "AotherAtext"] = {
          label: `${label2} [${(_l = (_k = state[mcqOther.qualifiedCode].content) == null ? void 0 : _k.label) == null ? void 0 : _l[mainLang]}]`,
          type: "text",
          valueSources: ["value"],
          operators: [
            "is_relevant",
            "is_not_relevant",
            "is_valid",
            "is_not_valid",
            "is_void",
            "is_not_void",
            "equal",
            "not_equal",
            "like",
            "not_like",
            "starts_with",
            "ends_with"
          ]
        };
      }
      return mcqReturnList;
    case "nps":
      let npsReturnList = {};
      (_m = component.children) == null ? void 0 : _m.forEach((element) => {
        var _a2, _b2;
        mcqListValues[element.code] = stripTags(
          (_b2 = (_a2 = state[element.qualifiedCode].content) == null ? void 0 : _a2.label) == null ? void 0 : _b2[mainLang]
        );
      });
      npsReturnList[code] = {
        label: label2,
        fieldSettings: {
          min: 0,
          max: 10
        },
        type: "number",
        valueSources: ["value"],
        operators: [
          "is_void",
          "is_not_void",
          "equal",
          "not_equal",
          "less",
          "less_or_equal",
          "greater",
          "greater_or_equal",
          "between",
          "not_between"
        ]
      };
      return npsReturnList;
    case "scq_array":
      let scqArrayReturnList = {};
      let scqArrayListValues = {};
      (_n = component.children) == null ? void 0 : _n.filter((el) => el.type == "column").forEach((element) => {
        var _a2, _b2;
        scqArrayListValues[element.code] = stripTags(
          (_b2 = (_a2 = state[element.qualifiedCode].content) == null ? void 0 : _a2.label) == null ? void 0 : _b2[mainLang]
        );
      });
      scqArrayReturnList[code] = {
        label: label2,
        type: "text",
        valueSources: ["value"],
        operators: [
          "is_relevant",
          "is_not_relevant",
          "is_valid",
          "is_not_valid"
        ]
      };
      (_o = component.children) == null ? void 0 : _o.filter((el) => el.type == "row").forEach((element) => {
        var _a2, _b2;
        scqArrayReturnList[code + element.code] = {
          label: label2 + " - " + stripTags(
            (_b2 = (_a2 = state[element.qualifiedCode].content) == null ? void 0 : _a2.label) == null ? void 0 : _b2[mainLang]
          ),
          type: "select",
          valueSources: ["value"],
          fieldSettings: { listValues: scqArrayListValues },
          operators: ["select_any_in", "select_not_any_in"]
        };
      });
      return scqArrayReturnList;
    case "ranking":
    case "image_ranking":
      let rankingReturnList = {};
      (_p = component.children) == null ? void 0 : _p.forEach((element) => {
        var _a2, _b2;
        rankingReturnList[code + element.code] = {
          label: label2 + " - " + stripTags((_b2 = (_a2 = state[element.qualifiedCode].content) == null ? void 0 : _a2.label) == null ? void 0 : _b2[mainLang]),
          type: "number",
          fieldSettings: {
            min: 1,
            max: component.children.length
          },
          valueSources: ["value"],
          operators: [
            "is_void",
            "is_not_void",
            "equal",
            "not_equal",
            "less",
            "less_or_equal",
            "greater",
            "greater_or_equal",
            "between",
            "not_between"
          ]
        };
      });
      return rankingReturnList;
    default:
      return [];
  }
};
const relevance = "_relevance_1j5a5_1";
const relevanceError = "_relevanceError_1j5a5_5";
const errorContainer = "_errorContainer_1j5a5_9";
const styles$a = {
  relevance,
  relevanceError,
  errorContainer
};
function Relevance({ code, t: t2 }) {
  var _a, _b, _c;
  const dispatch = useDispatch();
  const [logicDialogOpen, setLogicDialogOpen] = reactExports.useState(false);
  const langInfo = useSelector((state2) => {
    return state2.designState.langInfo;
  });
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const fields = useSelector((state2) => {
    return buildFields(
      state2.designState.componentIndex,
      code,
      state2.designState,
      langInfo.mainLang
    );
  });
  const instruction = (_a = state.instructionList) == null ? void 0 : _a.find(
    (instruction2) => instruction2.code == "conditional_relevance"
  );
  const errors = (instruction == null ? void 0 : instruction.errors) || [];
  const hasErrors = errors.length > 0;
  const logic = (_b = state.relevance) == null ? void 0 : _b.logic;
  const logicDisabled = !hasErrors && Object.keys(fields).length > 0;
  const [rule3, setRule] = reactExports.useState(((_c = state.relevance) == null ? void 0 : _c.rule) || "show_always");
  const shouldHaveLogic = rule3 == "show_if" || rule3 == "hide_if";
  const onRuleChange = (rule22) => {
    setRule(rule22);
    switch (rule22) {
      case "show_always":
        reset();
        return;
      case "hide_always":
        dispatch(
          changeRelevance({
            code,
            key: "relevance",
            value: { logic: void 0, rule: rule22 }
          })
        );
        return;
      case "show_if":
      case "hide_if":
        if ((logic == null ? void 0 : logic.rule) != "show_if" && (logic == null ? void 0 : logic.rule) != "hide_if") {
          setLogicDialogOpen(true);
        }
        if (logic) {
          dispatch(
            changeRelevance({
              code,
              key: "relevance",
              value: { logic, rule: rule22 }
            })
          );
        }
        return;
    }
  };
  const reset = () => dispatch(
    changeRelevance({
      code,
      key: "relevance",
      value: { logic: void 0, rule: "show_always" }
    })
  );
  const onLogicChange = (logic2) => {
    setLogicDialogOpen(false);
    if (shouldHaveLogic) {
      dispatch(
        changeRelevance({
          code,
          key: "relevance",
          value: { logic: logic2, rule: rule3 }
        })
      );
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${hasErrors ? styles$a.relevanceError : ""}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { variant: "standard", fullWidth: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Select,
      {
        id: "show-hide-select",
        value: rule3,
        label: "Age",
        onChange: (e2) => onRuleChange(e2.target.value),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { disabled: hasErrors, value: "show_always", children: t2("show_always") }, "show_always"),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { disabled: !logicDisabled, value: "show_if", children: t2("show_if") }, "show_if"),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { disabled: !logicDisabled, value: "hide_if", children: t2("hide_if") }, "hide_if"),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { disabled: hasErrors, value: "hide_always", children: t2("hide_always") }, "hide_always")
        ]
      }
    ) }),
    !hasErrors && shouldHaveLogic && /* @__PURE__ */ jsxRuntimeExports.jsx(
      LogicBuilder,
      {
        title: rule3 == "show_if" ? t2("condition_to_show") : t2("condition_to_hide"),
        onChange: onLogicChange,
        onDialogStateChanged: (state2) => setLogicDialogOpen(state2),
        fields,
        t: t2,
        dialogOpen: logicDialogOpen,
        logic
      }
    ),
    hasErrors ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$a.errorContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Trans, { t: t2, i18nKey: "wrong_logic_err" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "contained", onClick: () => reset(), children: "OK" })
    ] }) : "",
    shouldHaveLogic && !logic ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trans, { t: t2, i18nKey: "no_logic_err" }) }) : ""
  ] });
}
const buildField = (code, state, mainLang) => {
  var _a, _b;
  const component = state[code];
  const label2 = code + ". " + stripTags((_b = (_a = component.content) == null ? void 0 : _a.label) == null ? void 0 : _b[mainLang]);
  return { code, label: label2 };
};
const jumpDestinations = (componentIndices, code, state, mainLang) => {
  let dependencies = [];
  if (!componentIndices) {
    return dependencies;
  }
  let componentIndex = componentIndices.find(
    (element) => element.code === code
  );
  if (!componentIndex) {
    return dependencies;
  }
  dependencies = dependencies.concat(
    accessibleSiblings(componentIndices, componentIndex, state, mainLang)
  );
  if (componentIndex.parent) {
    parents(componentIndices, componentIndex).filter((elem) => isQuestion(elem.code) || isGroup(elem.code)).forEach((element) => {
      dependencies = dependencies.concat(
        accessibleSiblings(componentIndices, element, state, mainLang)
      );
    });
  }
  return dependencies;
};
const parents = (componentIndices, componentIndex) => {
  let result = [];
  let parent2 = componentIndices.find(
    (element) => element.code === componentIndex.parent
  );
  if (parent2 && parent2.parent) {
    result.push(parent2);
    result = result.concat(parents(componentIndices, parent2));
  }
  return result;
};
const accessibleSiblings = (componentIndices, componentIndex, state, mainLang) => {
  let result = [];
  if (!isGroup(componentIndex.code) && !isQuestion(componentIndex.code)) {
    return result;
  }
  let accessibleSiblings2 = componentIndices.filter((elem) => {
    return elem.parent == componentIndex.parent && elem.minIndex > componentIndex.maxIndex && (!componentIndex.prioritisedSiblings || componentIndex.prioritisedSiblings.indexOf(elem.code) === -1);
  });
  accessibleSiblings2.forEach((sibling) => {
    result = result.concat(buildField(sibling.code, state, mainLang));
    result = result.concat(
      childrenDependencies(componentIndices, sibling, state, mainLang)
    );
  });
  return result;
};
const childrenDependencies = (componentIndices, componentIndex, state, mainLang) => {
  let result = [];
  if (!isGroup(componentIndex.code)) {
    return result;
  }
  if (componentIndex.children) {
    componentIndex.children.forEach((childCode) => {
      let child = componentIndices.find(
        (element) => element.code === childCode
      );
      result = result.concat(buildField(child.code, state, mainLang));
      result = result.concat(
        childrenDependencies(componentIndices, child, state, mainLang)
      );
    });
  }
  return result;
};
const skipItem = "_skipItem_1n8m2_1";
const toEnd = "_toEnd_1n8m2_6";
const styles$9 = {
  skipItem,
  toEnd
};
function SkipLogic({ code, t: t2 }) {
  const dispatch = useDispatch();
  const skipLogic = useSelector((state) => {
    return state.designState[code].skip_logic || {};
  });
  const destinations = useSelector((state) => {
    const mainLang = state.designState.langInfo.mainLang;
    return jumpDestinations(
      state.designState.componentIndex,
      code,
      state.designState,
      mainLang
    );
  });
  const instructions = useSelector((state) => {
    return state.designState[code].instructionList.filter(
      (el) => el.code.startsWith("skip_to")
    );
  });
  const children = useSelector((state) => {
    var _a, _b;
    const lang2 = state.designState.langInfo.lang;
    return (_b = (_a = state.designState[code]) == null ? void 0 : _a.children) == null ? void 0 : _b.map((child) => {
      var _a2, _b2;
      return {
        code: child.code,
        label: ((_b2 = (_a2 = state.designState[child.qualifiedCode].content) == null ? void 0 : _a2.label) == null ? void 0 : _b2[lang2]) || child.code
      };
    });
  });
  const onChange = (answerCode, targetCode) => {
    if (targetCode == "proceed") {
      dispatch(removeSkipDestination({ code, answerCode }));
    } else {
      dispatch(editSkipDestination({ code, answerCode, skipTo: targetCode }));
    }
  };
  const onToEndChanged = (answerCode, checked) => {
    dispatch(editSkipToEnd({ code, answerCode, toEnd: checked }));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: children == null ? void 0 : children.map((element) => {
    var _a, _b;
    const code2 = element.code;
    const original = skipLogic == null ? void 0 : skipLogic[code2];
    const skipTo = original == null ? void 0 : original.skipTo;
    const skipToCode = skipTo || "proceed";
    const invalidSkipDestination = skipTo && ((_b = (_a = instructions == null ? void 0 : instructions.find((el) => el.code == "skip_to_on_" + code2)) == null ? void 0 : _a.errors) == null ? void 0 : _b.find((el) => el.name == "InvalidSkipReference"));
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$9.skipItem, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Trans,
        {
          t: t2,
          values: { code: element.label },
          i18nKey: "if_answer_is"
        }
      ),
      invalidSkipDestination ? skipValueError(code2, skipTo, onChange, t2) : skipSelectValue(
        code2,
        destinations,
        skipToCode,
        original == null ? void 0 : original.toEnd,
        onChange,
        onToEndChanged,
        t2
      )
    ] }, element.code);
  }) });
}
function skipValueError(answerCode, skipToCode, onChange, t2) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: styles$9.errorDisplay, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorOutlineOutlined, { style: { verticalAlign: "middle" } }),
    " ",
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Trans,
      {
        t: t2,
        values: { code: skipToCode },
        i18nKey: "invalid_skip_destination_err"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        variant: "contained",
        onClick: () => onChange(answerCode, "proceed"),
        children: t2("ok")
      }
    )
  ] });
}
function skipSelectValue(answerCode, destinations, skipToCode, toEnd2, onChange, onToEndChanged, t2) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { variant: "standard", fullWidth: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Select,
      {
        id: "skip-action",
        value: skipToCode,
        label: t2("skip_to"),
        onChange: (e2) => onChange(answerCode, e2.target.value),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "proceed", children: t2("proceed_as_usual") }, "proceed"),
          destinations && (destinations == null ? void 0 : destinations.map((element) => {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: element.code, children: element.label }, element.code);
          }))
        ]
      }
    ) }),
    skipToCode && skipToCode.startsWith("G") && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$9.toEnd, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: t2("to_group_end") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Switch,
        {
          checked: toEnd2 || false,
          onChange: (event) => onToEndChanged(answerCode, event.target.checked)
        }
      )
    ] })
  ] });
}
const sectionTitle = "_sectionTitle_1aw08_1";
const styles$8 = {
  sectionTitle
};
const errorDisplay$2 = "_errorDisplay_1avr2_1";
const CustomPriority_module = {
  errorDisplay: errorDisplay$2
};
const errorDisplay$1 = "_errorDisplay_1avr2_1";
const styles$7 = {
  errorDisplay: errorDisplay$1
};
function RandomError({ errors }) {
  const { t: t2 } = useTranslation("design");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: styles$7.errorDisplay, children: errors.map((error2) => {
    if (error2.name == "PriorityGroupItemNotChild") {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Trans,
        {
          t: t2,
          i18nKey: "err_priority_group_item_not_child",
          values: { items: error2.items.join(", ") }
        },
        error2.name
      );
    } else if (error2.name == "DuplicatePriorityGroupItems") {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Trans,
        {
          t: t2,
          i18nKey: "err_duplicate_priority_group_items",
          values: { items: error2.items.join(", ") }
        },
        error2.name
      );
    } else if (error2.name == "PriorityLimitMismatch") {
      return t2("err_priority_limit_mismatch");
    } else if (error2.name == "RandomGroupItemNotChild") {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Trans,
        {
          t: t2,
          i18nKey: "err_random_group_item_not_child",
          values: { items: error2.items.join(", ") }
        },
        error2.name
      );
    } else if (error2.name == "DuplicateRandomGroupItems") {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Trans,
        {
          t: t2,
          i18nKey: "err_duplicate_random_group_items",
          values: { items: error2.items.join(", ") }
        },
        error2.name
      );
    }
  }) }, "box");
}
const randomHeader$1 = "_randomHeader_1pjix_1";
const title$3 = "_title_1pjix_6";
const action$1 = "_action_1pjix_11";
const settingIcon$1 = "_settingIcon_1pjix_15";
const randomBody$1 = "_randomBody_1pjix_19";
const list$3 = "_list_1pjix_19";
const weight$1 = "_weight_1pjix_30";
const randomAction$3 = "_randomAction_1pjix_47";
const listItem$3 = "_listItem_1pjix_53";
const label$2 = "_label_1pjix_58";
const input$3 = "_input_1pjix_64";
const listItemError$1 = "_listItemError_1pjix_68";
const randomItem$3 = "_randomItem_1pjix_84";
const highlighted$1 = "_highlighted_1pjix_89";
const styles$6 = {
  randomHeader: randomHeader$1,
  title: title$3,
  action: action$1,
  settingIcon: settingIcon$1,
  randomBody: randomBody$1,
  list: list$3,
  weight: weight$1,
  randomAction: randomAction$3,
  listItem: listItem$3,
  label: label$2,
  input: input$3,
  listItemError: listItemError$1,
  randomItem: randomItem$3,
  highlighted: highlighted$1
};
var Mode = {};
var _interopRequireDefault$3 = interopRequireDefaultExports;
Object.defineProperty(Mode, "__esModule", {
  value: true
});
var default_1$3 = Mode.default = void 0;
var _createSvgIcon$3 = _interopRequireDefault$3(requireCreateSvgIcon());
var _jsxRuntime$3 = jsxRuntimeExports;
var _default$3 = (0, _createSvgIcon$3.default)(/* @__PURE__ */ (0, _jsxRuntime$3.jsx)("path", {
  d: "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75zM20.71 5.63l-2.34-2.34a.9959.9959 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83c.39-.39.39-1.02 0-1.41z"
}), "Mode");
default_1$3 = Mode.default = _default$3;
function PriorityItemDisplay(props) {
  var _a;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Card,
    {
      className: `${styles$6.randomItem} ${props.isBeingEdited ? styles$6.highlighted : ""}`,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.randomHeader, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: styles$6.title, children: props.t("prioritise") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.action, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: () => props.onEditClicked(props.index), children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$3, { className: styles$6.settingIcon }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: () => props.onDeleteClicked(props.index), children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$u, { className: styles$6.settingIcon }) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.randomBody, children: [
          props.t("priority_show_limit_from_count", {
            limit: props.data.limit,
            count: (_a = props.data.weights) == null ? void 0 : _a.length
          }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: styles$6.list, children: props.data && props.data.weights && props.data.weights.map((nestedItem, index2) => {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              PrioritisedChildDisplay$1,
              {
                label: props.getChildLabelByCode(nestedItem.code),
                code: nestedItem.code,
                childrenCodes: props.childrenCodes,
                weight: nestedItem.weight
              },
              index2
            );
          }) })
        ] })
      ]
    }
  );
}
function PrioritisedChildDisplay$1({ code, label: label2, weight: weight2, childrenCodes }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "li",
    {
      className: childrenCodes.indexOf(code) !== -1 ? styles$6.listItem : styles$6.listItemError,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${styles$6.content} ${styles$6.label}`, children: [
          code,
          ": ",
          label2
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6.weight, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: weight2 }) })
      ]
    }
  );
}
const title$2 = "_title_5cg20_1";
const randomBody = "_randomBody_5cg20_6";
const list$2 = "_list_5cg20_6";
const weight = "_weight_5cg20_18";
const label$1 = "_label_5cg20_35";
const randomAction$2 = "_randomAction_5cg20_39";
const listItem$2 = "_listItem_5cg20_45";
const input$2 = "_input_5cg20_50";
const randomItem$2 = "_randomItem_5cg20_54";
const styles$5 = {
  title: title$2,
  randomBody,
  list: list$2,
  weight,
  label: label$1,
  randomAction: randomAction$2,
  listItem: listItem$2,
  input: input$2,
  randomItem: randomItem$2
};
var RemoveCircle = {};
var _interopRequireDefault$2 = interopRequireDefaultExports;
Object.defineProperty(RemoveCircle, "__esModule", {
  value: true
});
var default_1$2 = RemoveCircle.default = void 0;
var _createSvgIcon$2 = _interopRequireDefault$2(requireCreateSvgIcon());
var _jsxRuntime$2 = jsxRuntimeExports;
var _default$2 = (0, _createSvgIcon$2.default)(/* @__PURE__ */ (0, _jsxRuntime$2.jsx)("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11H7v-2h10v2z"
}), "RemoveCircle");
default_1$2 = RemoveCircle.default = _default$2;
var AddCircle = {};
var _interopRequireDefault$1 = interopRequireDefaultExports;
Object.defineProperty(AddCircle, "__esModule", {
  value: true
});
var default_1$1 = AddCircle.default = void 0;
var _createSvgIcon$1 = _interopRequireDefault$1(requireCreateSvgIcon());
var _jsxRuntime$1 = jsxRuntimeExports;
var _default$1 = (0, _createSvgIcon$1.default)(/* @__PURE__ */ (0, _jsxRuntime$1.jsx)("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"
}), "AddCircle");
default_1$1 = AddCircle.default = _default$1;
function PriorityItemSetup(props) {
  const t2 = props.t;
  const [checked, setChecked] = reactExports.useState(props.checked);
  const [data, setData] = reactExports.useState(props.data);
  const isSubmitEnabled = () => {
    const checkCount = checked.filter((x) => x).length;
    return checkCount >= 2 && data.limit <= checkCount - 1 && data.limit >= 1;
  };
  const onSubmit = () => {
    const selected = checked.filter((x) => x).length;
    if (selected < 2) {
      return false;
    }
    const submitData = { ...data };
    const weightsData = checked.reduce((sum, el, i2) => {
      if (el) {
        sum.push(submitData.weights[i2]);
      }
      return sum;
    }, []);
    props.onSubmit({
      ...submitData,
      weights: weightsData
    });
  };
  const handleCheckboxChange = (e2, i2) => {
    const cloneChecked = [...checked];
    cloneChecked[i2] = e2;
    setChecked([...cloneChecked]);
  };
  const changeLimit = (limit) => {
    setData({
      ...data,
      limit
    });
  };
  const changeWeight = (e2, i2) => {
    const newData = { ...data };
    newData.weights = [...data.weights];
    newData.weights[i2] = { ...data.weights[i2], weight: e2 };
    setData(newData);
  };
  const decreaseLimit = (limit) => {
    if (limit === 1) {
      return false;
    }
    limit--;
    changeLimit(limit);
  };
  const increaseLimit = (limit) => {
    if (limit === data.weights.length - 1) {
      return false;
    }
    limit++;
    changeLimit(limit);
  };
  const decreaseWeight = (e2, i2) => {
    if (e2 === 1) {
      return false;
    }
    e2--;
    changeWeight(e2, i2);
  };
  const increaseWeight = (e2, i2) => {
    e2++;
    changeWeight(e2, i2);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { className: styles$5.randomItem, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: styles$5.title, children: props.title }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.randomBody, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        PriorityLimitController,
        {
          t: t2,
          increaseLimit,
          decreaseLimit,
          limit: data.limit
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: `${styles$5.list} ${styles$5.active}`, children: data && data.weights && data.weights.map((nestedItem, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        PrioritisedChildDisplay,
        {
          code: nestedItem.code,
          weight: nestedItem.weight,
          handleChange: (checked2) => handleCheckboxChange(checked2, index2),
          decreaseWeight: (weight2) => decreaseWeight(weight2, index2),
          increaseWeight: (weight2) => increaseWeight(weight2, index2),
          checked: (checked == null ? void 0 : checked[index2]) || false,
          label: props.getChildLabelByCode(nestedItem.code)
        },
        index2
      )) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.randomAction, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "text", onClick: (e2) => props.onCancel(), children: t2("cancel") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "contained",
          onClick: (e2) => onSubmit(),
          disabled: !isSubmitEnabled(),
          children: t2("submit")
        }
      )
    ] })
  ] });
}
function PrioritisedChildDisplay({
  code,
  checked,
  label: label2,
  weight: weight2,
  handleChange,
  increaseWeight,
  decreaseWeight
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: styles$5.listItem, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Checkbox,
      {
        checked,
        onChange: (e2) => handleChange(e2.target.checked)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${styles$5.content} ${styles$5.label}`, children: [
      code,
      ": ",
      label2
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.weight, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { size: "small", onClick: (e2) => decreaseWeight(weight2), children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$2, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: weight2 }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { size: "small", onClick: (e2) => increaseWeight(weight2), children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$1, {}) })
    ] })
  ] });
}
function PriorityLimitController({ limit, increaseLimit, decreaseLimit, t: t2 }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    t2("priority_show"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { size: "small", onClick: (e2) => decreaseLimit(limit), children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$2, {}) }),
    limit,
    /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { size: "small", onClick: (e2) => increaseLimit(limit), children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$1, {}) })
  ] });
}
function CustomPriority({ t: t2, type: type2, code, hideErrors }) {
  var _a, _b;
  const dispatch = useDispatch();
  const [action2, setAction] = reactExports.useState({});
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const childrenCodes = useSelector((state2) => {
    var _a2, _b2, _c, _d;
    return ((_d = (_c = (_b2 = (_a2 = state2.designState[code]) == null ? void 0 : _a2.children) == null ? void 0 : _b2.filter((el) => type2 ? el.type == type2 : true)) == null ? void 0 : _c.filter(
      (el) => {
        var _a3, _b3;
        return ((_a3 = el.groupType) == null ? void 0 : _a3.toLowerCase()) != "welcome" && ((_b3 = el.groupType) == null ? void 0 : _b3.toLowerCase()) != "end";
      }
    )) == null ? void 0 : _d.map((el) => el.code)) || [];
  });
  const lang2 = useSelector((state2) => {
    return state2.designState.langInfo.lang;
  });
  const childrenLabels = useSelector((state2) => {
    var _a2, _b2, _c;
    return ((_c = (_b2 = (_a2 = state2.designState[code]) == null ? void 0 : _a2.children) == null ? void 0 : _b2.filter((el) => type2 ? el.type == type2 : true)) == null ? void 0 : _c.map((child) => {
      var _a3, _b3;
      return {
        code: child.code,
        label: (_b3 = (_a3 = state2.designState[child.qualifiedCode].content) == null ? void 0 : _a3.label) == null ? void 0 : _b3[lang2]
      };
    })) || [];
  });
  const priorityInstruction = instructionByCode(state, "priority_groups");
  const priorities2 = ((_a = priorityInstruction == null ? void 0 : priorityInstruction.priorities) == null ? void 0 : _a.filter(
    (priority) => type2 ? priority.weights.some((el) => childrenCodes.includes(el.code)) : true
  )) || [];
  let allCodesinPriority = priorities2.map((priority) => priority.weights).flat().map((weight2) => weight2.code).flat();
  const priorityErrors = ((_b = priorityInstruction == null ? void 0 : priorityInstruction.errors) == null ? void 0 : _b.filter(
    (error2) => error2.items.some((item) => allCodesinPriority.includes(item))
  )) || [];
  const updatePriorities = (priorities22) => {
    dispatch(
      type2 ? updatePriorityByType({ code, priorities: priorities22, type: type2 }) : updatePriority({ code, priorities: priorities22 })
    );
  };
  const getChildLabelByCode = (code2) => {
    var _a2;
    const label2 = (_a2 = childrenLabels.find((el) => el.code == code2)) == null ? void 0 : _a2.label;
    return label2 == null ? void 0 : label2.replace(/<[^>]*>/g, "");
  };
  const getUnPrioritisedChildrenCodes = () => {
    return childrenCodes.filter((el) => !allCodesinPriority.includes(el));
  };
  const onDeleteClicked = (index2) => {
    if (window.confirm(t2("are_you_sure"))) {
      updatePriorities(priorities2.filter((el, i2) => i2 !== index2));
    }
  };
  const isActionEmpty = !action2 || Object.keys(action2).length == 0;
  const onEditClicked = (index2) => {
    let checked = [];
    let data = [];
    data.weights = [];
    const unPrioritised = getUnPrioritisedChildrenCodes();
    childrenCodes.forEach((code2) => {
      if (unPrioritised.includes(code2)) {
        data.weights.push({ code: code2, weight: 1 });
        checked.push(false);
      } else {
        let weightIndex = priorities2[index2].weights.findIndex(
          (weight2) => weight2.code == code2
        );
        if (weightIndex > -1) {
          data.weights.push(priorities2[index2].weights[weightIndex]);
          checked.push(true);
        }
      }
      data.limit = priorities2[index2].limit;
    });
    setAction({
      index: index2,
      checked,
      title: t2("edit_priority_rule"),
      data
    });
  };
  const resetData = () => {
    setAction({});
  };
  const onSubmit = (value, index2) => {
    const newPriorities = priorities2 ? [...priorities2] : [];
    newPriorities[index2] = { ...value };
    updatePriorities(newPriorities);
    resetData();
  };
  const addNewPriority = () => {
    const listQuestionCode = getUnPrioritisedChildrenCodes();
    const weights = listQuestionCode.map((el) => ({
      code: el,
      weight: 1
    }));
    setAction({
      title: t2("add_priority_rule"),
      checked: listQuestionCode.map((el) => false),
      data: {
        limit: 1,
        weights
      },
      index: priorities2 ? priorities2.length : 0,
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$b, {})
    });
  };
  const sortPriorityItem = (item) => {
    let newWeights = [...item.weights].sort(function(a2, b2) {
      return childrenCodes.findIndex((x) => x === a2.code) - childrenCodes.findIndex((x) => x === b2.code);
    });
    return { ...item, weights: newWeights };
  };
  const sanitize = (data, childrenCodes2) => {
    let weights = [...data.weights].filter(
      (el) => childrenCodes2.includes(el.code)
    );
    if (weights.length <= 1) {
      resetData();
    }
    return {
      limit: Math.min(data.limit, weights.length - 1),
      weights
    };
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    priorities2 && priorities2.map((item, i2) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        PriorityItemDisplay,
        {
          t: t2,
          data: sortPriorityItem(item),
          index: i2,
          childrenCodes,
          isBeingEdited: action2.index == i2,
          onDeleteClicked: (index2) => {
            setAction({});
            onDeleteClicked(index2);
          },
          onEditClicked: (index2) => onEditClicked(index2),
          getChildLabelByCode
        },
        i2
      );
    }),
    !hideErrors && priorityErrors.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(RandomError, { errors: priorityErrors }) : "",
    isActionEmpty && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Button,
      {
        variant: "contained",
        disabled: getUnPrioritisedChildrenCodes().length < 2,
        onClick: addNewPriority,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$b, { sx: { paddingRight: "8px" } }),
          " ",
          t2("add_priority_rule")
        ]
      }
    ),
    action2 && action2.data && /* @__PURE__ */ jsxRuntimeExports.jsx(
      PriorityItemSetup,
      {
        t: t2,
        title: action2.title,
        data: sanitize(action2.data, childrenCodes),
        index: action2.index,
        getChildLabelByCode,
        checked: action2.checked,
        onSubmit: (data) => onSubmit(data, action2.index),
        onCancel: resetData
      }
    )
  ] });
}
const selectValue = "_selectValue_14l81_1";
const styles$4 = {
  selectValue
};
const errorDisplay = "_errorDisplay_1vtlj_1";
const addNew = "_addNew_1vtlj_10";
const styles$3 = {
  errorDisplay,
  addNew
};
const title$1 = "_title_1p7e9_1";
const list$1 = "_list_1p7e9_6";
const randomAction$1 = "_randomAction_1p7e9_19";
const listItem$1 = "_listItem_1p7e9_25";
const input$1 = "_input_1p7e9_30";
const randomItem$1 = "_randomItem_1p7e9_34";
const styles$2 = {
  title: title$1,
  list: list$1,
  randomAction: randomAction$1,
  listItem: listItem$1,
  input: input$1,
  randomItem: randomItem$1
};
function RandomItemSetup(props) {
  const t2 = props.t;
  const [checked, setChecked] = reactExports.useState(props.checked);
  const [randomOption, setRandomOption] = reactExports.useState(props.randomOption);
  const isSubmitEnabled = () => {
    return checked.filter((x) => x).length >= 2;
  };
  const labels = [t2("random_order"), t2("flip_order"), t2("sort_by_label")];
  const values = ["RANDOM", "FLIP", "ALPHA"];
  const onSubmit = () => {
    const selected = checked.filter((x) => x).length;
    if (selected < 2) {
      return false;
    }
    const submitList = checked.reduce((sum, el, i2) => {
      if (el) {
        sum.push(props.data[i2]);
      }
      return sum;
    }, []);
    props.onSubmit(submitList, randomOption);
  };
  const handleCheckboxChange = (e2, i2) => {
    const cloneChecked = [...checked];
    cloneChecked[i2] = e2;
    setChecked([...cloneChecked]);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { className: styles$2.randomItem, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: styles$2.title, children: props.title }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { variant: "standard", fullWidth: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Select,
      {
        id: "select-value",
        value: randomOption,
        label: "Select Value",
        onChange: (e2) => {
          setRandomOption(e2.target.value);
        },
        children: labels.map((element, index2) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: values[index2], children: element }, element);
        })
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: styles$2.list, children: props.data && props.data.map((code, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      RandomisedChildDisplay$1,
      {
        code,
        handleChange: (checked2) => handleCheckboxChange(checked2, index2),
        checked: (checked == null ? void 0 : checked[index2]) || false,
        label: props.getChildLabelByCode(code)
      },
      index2
    )) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2.randomAction, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "text", onClick: (e2) => props.onCancel(), children: t2("cancel") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "contained",
          onClick: (e2) => onSubmit(),
          disabled: !isSubmitEnabled(),
          children: t2("submit")
        }
      )
    ] })
  ] });
}
function RandomisedChildDisplay$1({ code, label: label2, checked, handleChange }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: styles$2.listItem, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Checkbox,
      {
        checked,
        onChange: (e2) => handleChange(e2.target.checked)
      }
    ),
    code,
    ": ",
    label2
  ] });
}
const randomHeader = "_randomHeader_10d2m_1";
const title = "_title_10d2m_6";
const action = "_action_10d2m_11";
const settingIcon = "_settingIcon_10d2m_15";
const list = "_list_10d2m_19";
const randomAction = "_randomAction_10d2m_30";
const listItem = "_listItem_10d2m_36";
const label = "_label_10d2m_41";
const input = "_input_10d2m_47";
const listItemError = "_listItemError_10d2m_51";
const randomItem = "_randomItem_10d2m_63";
const highlighted = "_highlighted_10d2m_68";
const styles$1 = {
  randomHeader,
  title,
  action,
  settingIcon,
  list,
  randomAction,
  listItem,
  label,
  input,
  listItemError,
  randomItem,
  highlighted
};
const randomOptionToText = (randomOption, t2) => {
  switch (randomOption) {
    case "ALPHA":
      return t2("sort_by_label");
    case "RANDOM":
      return t2("random_order");
    case "FLIP":
      return t2("flip_order");
  }
  throw "unidentified randomOption: " + randomOption;
};
function RandomItemDisplay(props) {
  const t2 = props.t;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Card,
    {
      className: `${styles$1.randomItem} ${props.isBeingEdited ? styles$1.highlighted : ""}`,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$1.randomHeader, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: styles$1.title, children: randomOptionToText(props.randomOption, t2) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$1.action, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: () => props.onEditClicked(props.index), children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$3, { className: styles$1.settingIcon }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: () => props.onDeleteClicked(props.index), children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$u, { className: styles$1.settingIcon }) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: styles$1.list, children: props.data && props.data.map((code, index2) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            RandomisedChildDisplay,
            {
              label: props.getChildLabelByCode(code),
              code,
              childrenCodes: props.childrenCodes
            },
            index2
          );
        }) })
      ]
    }
  );
}
function RandomisedChildDisplay({ code, label: label2, childrenCodes }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "li",
    {
      className: childrenCodes.indexOf(code) !== -1 ? styles$1.listItem : styles$1.listItemError,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${styles$1.content} ${styles$1.label}`, children: [
        code,
        ": ",
        label2
      ] })
    }
  );
}
function CustomRandom({ t: t2, type: type2, code, hideErrors }) {
  var _a, _b;
  const dispatch = useDispatch();
  const [action2, setAction] = reactExports.useState({});
  const state = useSelector((state2) => {
    return state2.designState[code];
  });
  const childrenCodes = useSelector((state2) => {
    var _a2, _b2, _c, _d;
    return ((_d = (_c = (_b2 = (_a2 = state2.designState[code]) == null ? void 0 : _a2.children) == null ? void 0 : _b2.filter((el) => type2 ? el.type == type2 : true)) == null ? void 0 : _c.filter(
      (el) => {
        var _a3, _b3;
        return ((_a3 = el.groupType) == null ? void 0 : _a3.toLowerCase()) != "welcome" && ((_b3 = el.groupType) == null ? void 0 : _b3.toLowerCase()) != "end";
      }
    )) == null ? void 0 : _d.map((el) => el.code)) || [];
  });
  const lang2 = useSelector((state2) => {
    return state2.designState.langInfo.lang;
  });
  const childrenLabels = useSelector((state2) => {
    var _a2, _b2, _c;
    return ((_c = (_b2 = (_a2 = state2.designState[code]) == null ? void 0 : _a2.children) == null ? void 0 : _b2.filter((el) => type2 ? el.type == type2 : true)) == null ? void 0 : _c.map((child) => {
      var _a3, _b3;
      return {
        code: child.code,
        label: (_b3 = (_a3 = state2.designState[child.qualifiedCode].content) == null ? void 0 : _a3.label) == null ? void 0 : _b3[lang2]
      };
    })) || [];
  });
  const randomInstruction = instructionByCode(state, "random_group");
  const randomOrders = ((_a = randomInstruction == null ? void 0 : randomInstruction.groups) == null ? void 0 : _a.filter(
    (group3) => type2 ? group3.codes.some((code2) => childrenCodes.includes(code2)) : true
  )) || [];
  const allCodesinRandomOrders = randomOrders.map((it) => it.codes).flat();
  const randomErrors = ((_b = randomInstruction == null ? void 0 : randomInstruction.errors) == null ? void 0 : _b.filter(
    (error2) => error2.items.some((item) => allCodesinRandomOrders.includes(item))
  )) || [];
  const updateRandomOrders = (groups) => {
    dispatch(
      type2 ? updateRandomByType({ code, groups, type: type2 }) : updateRandom({ code, groups })
    );
  };
  const getChildLabelByCode = (code2) => {
    var _a2;
    const label2 = (_a2 = childrenLabels.find((el) => el.code == code2)) == null ? void 0 : _a2.label;
    return label2 == null ? void 0 : label2.replace(/<[^>]*>/g, "");
  };
  const getUnrandomisedChildrenCodes = (data) => {
    return childrenCodes.filter((el) => !allCodesinRandomOrders.includes(el));
  };
  const onDeleteClicked = (index2) => {
    if (window.confirm(t2("are_you_sure"))) {
      updateRandomOrders(randomOrders.filter((el, i2) => i2 !== index2));
    }
  };
  const sortRandomItem = (item) => {
    return [...item.codes].sort(function(a2, b2) {
      return childrenCodes.findIndex((x) => x === a2) - childrenCodes.findIndex((x) => x === b2);
    });
  };
  const onEditClicked = (index2) => {
    let checked = [];
    let data = [];
    let unrandomized = getUnrandomisedChildrenCodes();
    data = childrenCodes.filter(
      (el) => unrandomized.includes(el) || randomOrders[index2].codes.includes(el)
    );
    checked = data.map(
      (el) => randomOrders[index2].codes.includes(el) ? true : false
    );
    setAction({
      index: index2,
      checked,
      randomOption: randomOrders[index2].randomOption || "RANDOM",
      title: t2("edit_random_rule"),
      data
    });
  };
  const resetData = () => {
    setAction({});
  };
  const isActionEmpty = !action2 || Object.keys(action2).length == 0;
  const onSubmit = (value, randomOption, index2) => {
    const newRandomOrders = randomOrders ? [...randomOrders] : [];
    newRandomOrders[index2] = { codes: value, randomOption };
    updateRandomOrders(newRandomOrders);
    resetData();
  };
  const addNewRule = () => {
    const data = getUnrandomisedChildrenCodes();
    setAction({
      title: t2("add_new_random_rule"),
      data,
      checked: [],
      randomOption: "RANDOM",
      index: randomOrders ? randomOrders.length : 0
    });
  };
  const sanitize = (data, childrenCodes2) => {
    let groups = [...data].filter((code2) => childrenCodes2.includes(code2));
    if (groups.length <= 1) {
      resetData();
    }
    return groups;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    randomOrders && randomOrders.map((item, i2) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        RandomItemDisplay,
        {
          t: t2,
          data: sortRandomItem(item),
          randomOption: item.randomOption,
          index: i2,
          isBeingEdited: action2.index == i2,
          childrenCodes,
          getChildLabelByCode,
          onDeleteClicked: (index2) => {
            setAction({});
            onDeleteClicked(index2);
          },
          onEditClicked: (index2) => onEditClicked(index2)
        },
        i2
      );
    }),
    !hideErrors && randomErrors.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(RandomError, { errors: randomErrors }) : "",
    isActionEmpty && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Button,
      {
        className: styles$3.addNew,
        variant: "contained",
        disabled: getUnrandomisedChildrenCodes().length < 2,
        onClick: addNewRule,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$c, { sx: { paddingRight: "8px" } }),
          " ",
          t2("add_random_rule")
        ]
      }
    ),
    action2 && action2.data && /* @__PURE__ */ jsxRuntimeExports.jsx(
      RandomItemSetup,
      {
        t: t2,
        title: action2.title,
        data: sanitize(action2.data, childrenCodes),
        randomOption: action2.randomOption,
        getChildLabelByCode,
        checked: action2.checked,
        onSubmit: (data, randomOption) => onSubmit(data, randomOption, action2.index),
        onCancel: resetData
      }
    )
  ] });
}
function OrderPrioritySetup({ t: t2, rule: rule3, code }) {
  const dispatch = useDispatch();
  const value = useSelector((state) => {
    return state.designState[code][rule3] || "NONE";
  });
  let title2 = "";
  let labels = [];
  let values = [];
  switch (rule3) {
    case "randomize_questions":
      title2 = t2("questions_order");
      labels = [
        t2("as_is"),
        t2("random_order"),
        t2("flip_order"),
        t2("custom_random")
      ];
      values = ["NONE", "RANDOM", "FLIP", "custom"];
      break;
    case "prioritize_questions":
      title2 = t2("questions_priority");
      labels = [t2("no_priority"), t2("prioritise_questions")];
      values = ["NONE", "prioritize"];
      break;
    case "randomize_groups":
      title2 = t2("groups_order");
      labels = [
        t2("as_is"),
        t2("random_order"),
        t2("flip_order"),
        t2("custom_random")
      ];
      values = ["NONE", "RANDOM", "FLIP", "custom"];
      break;
    case "prioritize_groups":
      title2 = t2("groups_priority");
      labels = [t2("no_priority"), t2("prioritise_groups")];
      values = ["NONE", "prioritize"];
      break;
    case "randomize_options":
      title2 = t2("options_order");
      labels = [
        t2("as_is"),
        t2("random_order"),
        t2("flip_order"),
        t2("sort_by_label"),
        t2("custom_random")
      ];
      values = ["NONE", "RANDOM", "FLIP", "ALPHA", "custom"];
      break;
    case "prioritize_options":
      title2 = t2("options_priority");
      labels = [t2("no_priority"), t2("prioritise_options")];
      values = ["NONE", "prioritize"];
      break;
    case "randomize_rows":
      title2 = t2("rows_order");
      labels = [
        t2("as_is"),
        t2("random_order"),
        t2("flip_order"),
        t2("sort_by_label"),
        t2("custom_random")
      ];
      values = ["NONE", "RANDOM", "FLIP", "ALPHA", "custom"];
      break;
    case "prioritize_rows":
      title2 = t2("rows_priority");
      labels = [t2("no_priority"), t2("prioritise_rows")];
      values = ["NONE", "prioritize"];
      break;
    case "randomize_columns":
      title2 = t2("columns_order");
      labels = [
        t2("as_is"),
        t2("random_order"),
        t2("flip_order"),
        t2("sort_by_label"),
        t2("custom_random")
      ];
      values = ["NONE", "RANDOM", "FLIP", "ALPHA", "custom"];
      break;
    case "prioritize_columns":
      title2 = t2("columns_priority");
      labels = [t2("no_priority"), t2("prioritise_columns")];
      values = ["NONE", "prioritize"];
      break;
  }
  const onChange = (value2) => {
    const finalValue = value2 == "NONE" ? void 0 : value2;
    dispatch(changeAttribute({ code, key: rule3, value: finalValue }));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: title2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { className: styles$4.selectValue, variant: "standard", fullWidth: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Select,
      {
        id: "select-value",
        value,
        label: "Select Value",
        onChange: (e2) => {
          onChange(e2.target.value);
        },
        children: labels.map((element, index2) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: values[index2], children: element }, element);
        })
      }
    ) }),
    value == "custom" && [
      "randomize_questions",
      "randomize_options",
      "randomize_groups"
    ].indexOf(rule3) !== -1 && /* @__PURE__ */ jsxRuntimeExports.jsx(CustomRandom, { label: "", code, t: t2 }),
    value == "custom" && "randomize_rows" == rule3 && /* @__PURE__ */ jsxRuntimeExports.jsx(CustomRandom, { label: "", type: "row", code, t: t2 }),
    value == "prioritize" && "prioritize_rows" == rule3 && /* @__PURE__ */ jsxRuntimeExports.jsx(CustomPriority, { label: "", type: "row", code, t: t2 }),
    value == "custom" && "randomize_columns" == rule3 && /* @__PURE__ */ jsxRuntimeExports.jsx(CustomRandom, { label: "", type: "column", code, t: t2 }),
    value == "prioritize" && "prioritize_columns" == rule3 && /* @__PURE__ */ jsxRuntimeExports.jsx(CustomPriority, { label: "", type: "column", code, t: t2 }),
    value == "prioritize" && [
      "prioritize_questions",
      "prioritize_options",
      "prioritize_groups"
    ].indexOf(rule3) !== -1 && /* @__PURE__ */ jsxRuntimeExports.jsx(CustomPriority, { label: "", code, t: t2 })
  ] });
}
function SetupPanel({ setupInfo, t: t2 }) {
  var _a;
  const dispatch = useDispatch();
  const toggleExpand = (key) => {
    dispatch(setupToggleExpand(key));
  };
  const isSingleRule = ((_a = setupInfo.rules) == null ? void 0 : _a.length) === 1;
  const generateSetupSection = (rule3) => {
    var _a2;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Accordion,
      {
        expanded: ((_a2 = setupInfo.expanded) == null ? void 0 : _a2.includes(rule3.key)) || isSingleRule || false,
        TransitionProps: { unmountOnExit: true },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            AccordionSummary,
            {
              sx: { backgroundColor: "#ECECEC", margin: 0 },
              onClick: () => toggleExpand(rule3.key),
              className: styles$8.setupHeader,
              expandIcon: isSingleRule ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$v, {}),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$8.sectionTitle, children: t2(rule3.title) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            AccordionDetails,
            {
              sx: {
                backgroundColor: rule3.key == setupInfo.highlighted ? "beige" : "background.paper"
              },
              children: rule3.rules.map((rule22) => generateSetupcomponent(rule22))
            }
          )
        ]
      },
      setupInfo.code + rule3.title
    );
  };
  const generateSetupcomponent = (rule3) => {
    if (rule3.startsWith("validation_")) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        ValidationSetupItem$1,
        {
          t: t2,
          rule: rule3,
          code: setupInfo.code
        },
        setupInfo.code + rule3
      );
    }
    switch (rule3) {
      case "theme":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Theming, { t: t2 }, setupInfo.code + rule3);
      case "maxChars":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          FieldSize,
          {
            label: t2("text_field_size"),
            rule: rule3,
            lowerBound: 1,
            upperBound: 500,
            defaultValue: 20,
            code: setupInfo.code
          },
          setupInfo.code + rule3
        );
      case "minRows":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          FieldSize,
          {
            label: t2("textarea_lines"),
            lowerBound: 1,
            upperBound: 500,
            code: setupInfo.code,
            defaultValue: 20
          },
          setupInfo.code + rule3
        );
      case "hideText":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          ToggleValue,
          {
            label: t2("hide_text"),
            rule: rule3,
            code: setupInfo.code
          },
          setupInfo.code + rule3
        );
      case "showWordCount":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          ToggleValue,
          {
            label: t2("show_word_count"),
            rule: rule3,
            code: setupInfo.code
          },
          setupInfo.code + rule3
        );
      case "hint":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(ShowHint, { t: t2, code: setupInfo.code }, setupInfo.code + rule3);
      case "lower_bound_hint":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          ContentEditor,
          {
            title: t2("lower_bound_hint"),
            objectName: "lower_bound_hint",
            code: setupInfo.code
          },
          setupInfo.code + rule3
        );
      case "higher_bound_hint":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          ContentEditor,
          {
            title: t2("upper_bound_hint"),
            objectName: "higher_bound_hint",
            code: setupInfo.code
          },
          setupInfo.code + rule3
        );
      case "loop":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          ToggleValue,
          {
            rule: rule3,
            code: setupInfo.code,
            label: t2("loop_video")
          },
          setupInfo.code + rule3
        );
      case "audio_only":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          ToggleValue,
          {
            rule: rule3,
            code: setupInfo.code,
            label: t2("audio_only")
          },
          setupInfo.code + rule3
        );
      case "fullDayFormat":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          ToggleValue,
          {
            rule: rule3,
            code: setupInfo.code,
            label: t2("fullday_format")
          },
          setupInfo.code + rule3
        );
      case "randomize_questions":
      case "prioritize_questions":
      case "randomize_options":
      case "prioritize_options":
      case "randomize_groups":
      case "prioritize_groups":
      case "randomize_rows":
      case "prioritize_rows":
      case "randomize_columns":
      case "prioritize_columns":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          OrderPrioritySetup,
          {
            t: t2,
            rule: rule3,
            code: setupInfo.code
          },
          setupInfo.code + rule3
        );
      case "maxDate":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectDate,
          {
            lowerBound: 1,
            code: setupInfo.code,
            label: t2("max_date"),
            rule: rule3
          },
          setupInfo.code + rule3
        );
      case "minDate":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectDate,
          {
            label: t2("min_date"),
            rule: rule3,
            code: setupInfo.code
          },
          setupInfo.code + rule3
        );
      case "dateFormat":
        const listDateFormat = [
          "DD.MM.YYYY",
          "MM.DD.YYYY",
          "YYYY.MM.DD",
          "DD/MM/YYYY",
          "MM/DD/YYYY",
          "YYYY/MM/DD"
        ];
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectValue,
          {
            values: listDateFormat,
            defaultValue: "DD.MM.YYYY",
            label: t2("date_format"),
            rule: rule3,
            code: setupInfo.code
          },
          setupInfo.code + rule3
        );
      case "imageAspectRatio":
        const aspectLabels = [
          "1:1",
          "16:9",
          "4:3",
          "3:2",
          "9:16",
          "3:4",
          "2:3"
        ];
        const aspectValues = [1, 1.7778, 1.3333, 1.5, 0.562, 0.75, 0.6667];
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectValue,
          {
            values: aspectValues,
            labels: aspectLabels,
            defaultValue: "1:1",
            label: t2("image_aspect_ratio"),
            rule: rule3,
            code: setupInfo.code
          },
          setupInfo.code + rule3
        );
      case "columns":
        const columnsOptions = ["1", "2", "3", "4", "6"];
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectValue,
          {
            values: columnsOptions,
            defaultValue: "2",
            label: t2("columns_number"),
            rule: rule3,
            code: setupInfo.code
          },
          setupInfo.code + rule3
        );
      case "imageHeight":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          FieldSize,
          {
            label: t2("image_height"),
            lowerBound: 50,
            upperBound: 500,
            code: setupInfo.code,
            defaultValue: 250,
            rule: rule3
          },
          setupInfo.code + rule3
        );
      case "spacing":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          FieldSize,
          {
            label: t2("spacing"),
            lowerBound: 2,
            upperBound: 32,
            code: setupInfo.code,
            defaultValue: 8,
            rule: rule3
          },
          setupInfo.code + rule3
        );
      case "skip_logic":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(SkipLogic, { t: t2, code: setupInfo.code }, setupInfo.code + rule3);
      case "relevance":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Relevance, { t: t2, code: setupInfo.code }, setupInfo.code + rule3);
      default:
        return "";
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: setupInfo.rules.map((rule3, index2) => generateSetupSection(rule3)) });
}
var PlayCircleFilledWhite = {};
var _interopRequireDefault = interopRequireDefaultExports;
Object.defineProperty(PlayCircleFilledWhite, "__esModule", {
  value: true
});
var default_1 = PlayCircleFilledWhite.default = void 0;
_interopRequireWildcard(reactExports);
var _createSvgIcon = _interopRequireDefault(requireCreateSvgIcon());
var _jsxRuntime = jsxRuntimeExports;
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function")
    return null;
  var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
  var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
  return (_getRequireWildcardCache = function(nodeInterop2) {
    return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return { default: obj };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
var _default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
  transform: "scale(0.5, 0.5)",
  d: "M24 4C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm-4 29V15l12 9-12 9z"
}), "PlayCircleFilledWhite");
default_1 = PlayCircleFilledWhite.default = _default;
function LeftPanel({ t: t2 }) {
  const dispatch = useDispatch();
  const setupInfo = useSelector((state) => {
    return state.designState.setup;
  });
  const nav = useNavigate();
  const surveyId = sessionStorage.getItem("surveyId");
  const hasFatalErrors = useSelector((state) => {
    return state.designState.Survey.errors && state.designState.Survey.errors.length > 0;
  });
  const isPushingStateToServer = useSelector((state) => {
    return state.designState.isSaving;
  });
  const published = useSelector((state) => {
    return state.designState.versionDto.published;
  });
  const langInfo = useSelector((state) => {
    return state.designState.langInfo;
  });
  const preview = (lang22) => {
    nav(`/preview-survey/${surveyId}`);
  };
  const params = useSelector((state) => {
    return new URLSearchParams([
      ["version", state.designState.versionDto.version],
      ["sub_version", state.designState.versionDto.subVersion]
    ]);
  });
  const back = () => {
    nav(`/`);
  };
  const logout = () => {
    AuthService.logout();
    nav("/login");
  };
  const publish = () => {
    dispatch(setFetching(true));
    DesignService.publish(params).then((data) => {
      dispatch(setFetching(false));
      dispatch(newVersionReceived(data));
    }).catch((error2) => {
      dispatch(setFetching(false));
    });
  };
  const lang2 = langInfo == null ? void 0 : langInfo.lang;
  const languagesList = langInfo == null ? void 0 : langInfo.languagesList;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: { backgroundColor: "background.paper" },
      className: styles$m.leftContent,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Select,
          {
            id: "ChangeLang",
            value: lang2,
            onChange: (event) => {
              dispatch(changeLang(event.target.value));
            },
            children: languagesList ? languagesList.map((lang22, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: lang22.code, children: lang22.langName }, index2)) : ""
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$m.leftPanelGroupItem, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: () => back(), children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$w, { className: styles$m.settingIcon }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: () => preview(), children: /* @__PURE__ */ jsxRuntimeExports.jsx(PreviewOutlined, { className: styles$m.settingIcon }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: () => logout(), children: /* @__PURE__ */ jsxRuntimeExports.jsx(LogoutOutlined, { className: styles$m.settingIcon }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconButton,
            {
              disabled: hasFatalErrors || isPushingStateToServer || published,
              onClick: () => publish(),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1, { className: styles$m.settingIcon })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconButton,
            {
              onClick: () => dispatch(
                setup({
                  code: "Survey",
                  rules: [{ title: t2("theme"), rules: ["theme"] }]
                })
              ),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$8, { className: styles$m.settingIcon })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: () => dispatch(setup(serveyRandomSetup)), children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$j, { className: styles$m.settingIcon }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: setupInfo ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$m.close, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: () => dispatch(resetSetup()), children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$k, {}) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SetupPanel, { t: t2, setupInfo })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(NewComponentsPanel, { t: t2 }) })
      ]
    }
  );
}
const savingProgress = "_savingProgress_zztu3_1";
const styles = {
  savingProgress
};
function SavingSurvey() {
  const isSaving = useSelector((state) => {
    return state.designState.isSaving;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Snackbar, { open: isSaving, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Alert, { severity: "warning", children: [
    "Saving Survey...",
    " ",
    /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { className: styles.savingProgress, color: "warning" })
  ] }) });
}
function ErrorWrapper() {
  const dispatch = useDispatch();
  const error2 = useSelector((state) => {
    const error22 = state.designState.error || false;
    return error22;
  });
  const setErrorSeen = () => {
    dispatch(onErrorSeen(false));
  };
  return error2 && !error2.seen && /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Dialog,
    {
      open: true,
      onClose: () => setErrorSeen(),
      "aria-labelledby": "alert-dialog-title-error",
      "aria-describedby": "alert-dialog-description",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { id: "alert-dialog-title-error", children: "Error" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent, { children: error2.message || "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActions, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => setErrorSeen(), children: "OK" }) })
      ]
    }
  );
}
function DesignSurvey() {
  const { t: t2, i18n } = useTranslation(["design", "run"]);
  const dispatch = useDispatch();
  const [render3, setRender] = reactExports.useState(false);
  const headerImage2 = useSelector((state) => {
    var _a, _b;
    return (_b = (_a = state.designState["Survey"]) == null ? void 0 : _a.resources) == null ? void 0 : _b.headerImage;
  });
  const groups = useSelector((state) => {
    var _a;
    return (_a = state.designState["Survey"]) == null ? void 0 : _a.children;
  });
  const langInfo = useSelector((state) => {
    return state.designState.langInfo;
  });
  const lang2 = langInfo == null ? void 0 : langInfo.lang;
  const theme = useSelector((state) => {
    var _a;
    return (_a = state.designState["Survey"]) == null ? void 0 : _a.theme;
  });
  const setState = (state) => {
    dispatch(designStateReceived(state));
  };
  const setError = (error2) => {
    dispatch(onError(error2));
  };
  reactExports.useEffect(() => {
    document.body.style.overflow = "hidden";
    dispatch(setFetching(true));
    GetData(setState, setError).then((data) => {
      if (data) {
        setRender(true);
        i18n.loadLanguages(data.languages);
        dispatch(setFetching(false));
      }
    }).catch((err) => {
      dispatch(setFetching(false));
    });
  }, []);
  function changeLanguage(lang22) {
    return new Promise((resolve, reject) => {
      const dir = rtlLanguage.includes(lang22) ? "rtl" : "ltr";
      if (document.dir != dir) {
        document.dir = dir;
      }
      if (lang22) {
        i18n.changeLanguage(lang22);
      }
      resolve();
    });
  }
  reactExports.useEffect(() => {
    changeLanguage(lang2);
  }, [lang2]);
  const cacheRtl = createCache({
    key: rtlLanguage.includes(lang2) ? "muirtl" : "muiltr",
    stylisPlugins: rtlLanguage.includes(lang2) ? [prefixer, stylisRTLPlugin] : null
  });
  const surveyTheme = React.useCallback(
    createTheme({
      ...defualtTheme(theme),
      direction: rtlLanguage.includes(lang2) ? "rtl" : "ltr"
    }),
    [theme]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CacheProvider, { value: cacheRtl, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider, { theme: surveyTheme, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Layout, { children: [
    render3 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$M.mainContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        DragDropContext,
        {
          onDragEnd: (event) => {
            onDragEnd(event, (payload) => {
              dispatch(onDrag(payload));
            });
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(LeftPanel, { t: t2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ContentPanel,
              {
                className: styles$M.contentPanel,
                t: t2,
                headerImage: headerImage2,
                groups
              }
            )
          ]
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SavingSurvey, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorWrapper, {})
  ] }) }) });
}
export {
  DesignSurvey as default
};
