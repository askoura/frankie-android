;
(function () {
  System.register([], function (exports, module) {
    'use strict';

    var __vite_style__ = document.createElement('style');
    __vite_style__.textContent = "._leftPanelGroupItem_ckjs5_1 {\n  width: 100%;\n  margin-bottom: 20px;\n}\n\n._groupTitle_ckjs5_6 {\n  margin-bottom: 10px;\n  font-size: 24px;\n  font-weight: bold;\n}\n\n._iconMenu_ckjs5_12 {\n  min-width: 35px;\n}\n\n._tabHeader_ckjs5_16 {\n  position: relative;\n}\n\n._tabHeader_ckjs5_16::after {\n  content: \"\";\n  position: absolute;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  display: block;\n  border-bottom: 1px solid;\n}\n._leftPannelItem_1kak4_1 {\n  display: inline-flex;\n  width: 100%;\n  margin-bottom: 10px;\n  border: 1px solid;\n  border-radius: 4px;\n  font-size: 16px;\n  line-height: 23px;\n}\n\n._icon_1kak4_11 {\n  margin: 8px;\n}\n\n._title_1kak4_15 {\n  margin: 8px;\n}\n._loading_c5al4_1 {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  display: block;\n  width: 100vw;\n  height: 100vh;\n  z-index: 1000;\n  background: rgba(0, 0, 0, .2);\n}\n\n._loadingWrapper_c5al4_14 {\n  position: relative;\n  top: 50%;\n  left: 50%;\n  display: inline-block;\n  margin: auto;\n  transform: translate(-50%, -50%);\n}\nbody {\n  margin: 0;\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", \"Roboto\", \"Oxygen\",\n    \"Ubuntu\", \"Cantarell\", \"Fira Sans\", \"Droid Sans\", \"Helvetica Neue\",\n    sans-serif;\n  -moz-osx-font-smoothing: grayscale;\n}\n\ncode {\n  font-family: source-code-pro, Menlo, Monaco, Consolas, \"Courier New\",\n    monospace;\n}\n.MuiFormControl-root {\n  width: 100%;\n}\n\n.text-left {\n  text-align: left !important;\n}\n\n.mt-20 {\n  margin-top: 20px !important;\n}\n\n.mt-40 {\n  margin-top: 40px !important;\n}\n\n.mr-10 {\n  margin-right: 10px !important;\n}\n\n.mr-14 {\n  margin-right: 14px !important;\n}\n\n.ml-14 {\n  margin-left: 14px !important;\n}\n\n.ml-5 {\n  margin-left: 5px !important;\n}\n\n.mb-0 {\n  margin-bottom: 0 !important;\n}\n\n.mb-10 {\n  margin-bottom: 10px !important;\n}\n\n.pb-10 {\n  padding-bottom: 10px !important;\n}\n\n.ta-center {\n  text-align: center;\n}\n\n.d-flex {\n  display: flex;\n}\n\n.w-100 {\n  width: 100%;\n}\n\n.card-custom {\n  position: relative;\n  margin-top: 12px;\n  margin-bottom: 12px;\n  border: 1px solid;\n  border-radius: 8px;\n  cursor: default;\n}\n\n.required {\n  font-size: 16px;\n  line-height: 24px;\n  letter-spacing: 0.1px;\n}\n\n.inputSurvey {\n  max-width: 400px;\n  width: 100%;\n  margin-bottom: 15px;\n}\n\n.MuiSelect-select {\n  display: flex !important;\n  align-items: center;\n}\n\n.MuiSwitch-root {\n  margin-right: -4px;\n}\n\n.jsx-parser {\n  p {\n    margin: 0;\n  }\n}\n";
    document.head.appendChild(__vite_style__);
    return {
      execute: function () {
        function _mergeNamespaces(n, m) {
          for (var i = 0; i < m.length; i++) {
            const e = m[i];
            if (typeof e !== 'string' && !Array.isArray(e)) {
              for (const k in e) {
                if (k !== 'default' && !(k in n)) {
                  const d = Object.getOwnPropertyDescriptor(e, k);
                  if (d) {
                    Object.defineProperty(n, k, d.get ? d : {
                      enumerable: true,
                      get: () => e[k]
                    });
                  }
                }
              }
            }
          }
          return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, {
            value: 'Module'
          }));
        }
        exports({
          A: getDefaultExportFromCjs,
          D: useLocation,
          H: createStyled,
          I: createTheme$1,
          J: useThemeProps$1,
          K: handleBreakpoints,
          M: resolveBreakpointValues,
          N: createUnarySpacing,
          O: deepmerge,
          Q: mergeBreakpointsInOrder,
          U: getValue,
          W: capitalize,
          X: useForkRef,
          Y: debounce,
          Z: ownerWindow,
          _: _objectWithoutPropertiesLoose$1,
          a: useParams,
          a9: useTheme,
          aA: _defineProperty,
          aB: _typeof,
          aC: getI18n,
          aD: useControlled,
          aF: useEventCallback,
          aG: ownerDocument,
          aH: setRef,
          aa: DragDropContext,
          ac: PublicDraggable,
          ae: getAugmentedNamespace,
          am: createTheme,
          ap: prefixer$1,
          aq: stylisRTLPlugin,
          at: getPath,
          au: alpha,
          av: useIsFocusVisible,
          aw: lighten,
          ax: darken,
          az: getDefaults,
          bC: GetData,
          bH: useTheme$1,
          bK: createChainedFunction,
          bN: useReduxContext,
          bP: _inheritsLoose,
          bQ: getThemeProps,
          bS: isMuiElement,
          bT: _arrayWithHoles,
          bU: _nonIterableRest,
          bY: isPlainObject$1,
          bZ: styled$2,
          ba: _arrayLikeToArray,
          bb: _iterableToArray,
          bc: _unsupportedIterableToArray,
          bd: _toArray,
          bf: _inherits,
          bg: _classCallCheck,
          bh: _assertThisInitialized,
          bi: _createClass,
          bj: _getPrototypeOf,
          bk: _possibleConstructorReturn,
          bl: createStore$1,
          bz: NewComponentsPanel,
          c: createSvgIcon,
          c2: formatMuiErrorMessage,
          c4: resolveProps,
          c5: emphasize,
          d: LoadingIndicator,
          g: requireCreateSvgIcon,
          m: _extends,
          n: generateUtilityClasses,
          q: generateUtilityClass,
          u: useNavigate,
          v: useThemeProps,
          w: useId,
          x: clsx,
          y: composeClasses
        });
        false && function polyfill() {
          const relList = document.createElement('link').relList;
          if (relList && relList.supports && relList.supports('modulepreload')) {
            return;
          }
          for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
            processPreload(link);
          }
          new MutationObserver(mutations => {
            for (const mutation of mutations) {
              if (mutation.type !== 'childList') {
                continue;
              }
              for (const node of mutation.addedNodes) {
                if (node.tagName === 'LINK' && node.rel === 'modulepreload') processPreload(node);
              }
            }
          }).observe(document, {
            childList: true,
            subtree: true
          });
          function getFetchOpts(link) {
            const fetchOpts = {};
            if (link.integrity) fetchOpts.integrity = link.integrity;
            if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
            if (link.crossOrigin === 'use-credentials') fetchOpts.credentials = 'include';else if (link.crossOrigin === 'anonymous') fetchOpts.credentials = 'omit';else fetchOpts.credentials = 'same-origin';
            return fetchOpts;
          }
          function processPreload(link) {
            if (link.ep)
              // ep marker = processed
              return;
            link.ep = true;
            // prepopulate the load record
            const fetchOpts = getFetchOpts(link);
            fetch(link.href, fetchOpts);
          }
        }();
        var commonjsGlobal = exports('z', typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {});
        function getDefaultExportFromCjs(x) {
          return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
        }
        function getAugmentedNamespace(n) {
          if (n.__esModule) return n;
          var f = n.default;
          if (typeof f == "function") {
            var a = function a() {
              if (this instanceof a) {
                var args = [null];
                args.push.apply(args, arguments);
                var Ctor = Function.bind.apply(f, args);
                return new Ctor();
              }
              return f.apply(this, arguments);
            };
            a.prototype = f.prototype;
          } else a = {};
          Object.defineProperty(a, '__esModule', {
            value: true
          });
          Object.keys(n).forEach(function (k) {
            var d = Object.getOwnPropertyDescriptor(n, k);
            Object.defineProperty(a, k, d.get ? d : {
              enumerable: true,
              get: function () {
                return n[k];
              }
            });
          });
          return a;
        }
        var jsxRuntime = {
          exports: {}
        };
        var reactJsxRuntime_production_min = {};
        var react = {
          exports: {}
        };
        var react_production_min = {};

        /**
         * @license React
         * react.production.min.js
         *
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */
        var l$6 = Symbol.for("react.element"),
          n$7 = Symbol.for("react.portal"),
          p$8 = Symbol.for("react.fragment"),
          q$7 = Symbol.for("react.strict_mode"),
          r$6 = Symbol.for("react.profiler"),
          t$5 = Symbol.for("react.provider"),
          u$5 = Symbol.for("react.context"),
          v$6 = Symbol.for("react.forward_ref"),
          w$4 = Symbol.for("react.suspense"),
          x$3 = Symbol.for("react.memo"),
          y$3 = Symbol.for("react.lazy"),
          z$4 = Symbol.iterator;
        function A$4(a) {
          if (null === a || "object" !== typeof a) return null;
          a = z$4 && a[z$4] || a["@@iterator"];
          return "function" === typeof a ? a : null;
        }
        var B$3 = {
            isMounted: function () {
              return !1;
            },
            enqueueForceUpdate: function () {},
            enqueueReplaceState: function () {},
            enqueueSetState: function () {}
          },
          C$2 = Object.assign,
          D$3 = {};
        function E$3(a, b, e) {
          this.props = a;
          this.context = b;
          this.refs = D$3;
          this.updater = e || B$3;
        }
        E$3.prototype.isReactComponent = {};
        E$3.prototype.setState = function (a, b) {
          if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
          this.updater.enqueueSetState(this, a, b, "setState");
        };
        E$3.prototype.forceUpdate = function (a) {
          this.updater.enqueueForceUpdate(this, a, "forceUpdate");
        };
        function F$2() {}
        F$2.prototype = E$3.prototype;
        function G$3(a, b, e) {
          this.props = a;
          this.context = b;
          this.refs = D$3;
          this.updater = e || B$3;
        }
        var H$3 = G$3.prototype = new F$2();
        H$3.constructor = G$3;
        C$2(H$3, E$3.prototype);
        H$3.isPureReactComponent = !0;
        var I$3 = Array.isArray,
          J = Object.prototype.hasOwnProperty,
          K$1 = {
            current: null
          },
          L$2 = {
            key: !0,
            ref: !0,
            __self: !0,
            __source: !0
          };
        function M$2(a, b, e) {
          var d,
            c = {},
            k = null,
            h = null;
          if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d) && !L$2.hasOwnProperty(d) && (c[d] = b[d]);
          var g = arguments.length - 2;
          if (1 === g) c.children = e;else if (1 < g) {
            for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
            c.children = f;
          }
          if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
          return {
            $$typeof: l$6,
            type: a,
            key: k,
            ref: h,
            props: c,
            _owner: K$1.current
          };
        }
        function N$2(a, b) {
          return {
            $$typeof: l$6,
            type: a.type,
            key: b,
            ref: a.ref,
            props: a.props,
            _owner: a._owner
          };
        }
        function O$2(a) {
          return "object" === typeof a && null !== a && a.$$typeof === l$6;
        }
        function escape$3(a) {
          var b = {
            "=": "=0",
            ":": "=2"
          };
          return "$" + a.replace(/[=:]/g, function (a) {
            return b[a];
          });
        }
        var P$2 = /\/+/g;
        function Q$2(a, b) {
          return "object" === typeof a && null !== a && null != a.key ? escape$3("" + a.key) : b.toString(36);
        }
        function R$2(a, b, e, d, c) {
          var k = typeof a;
          if ("undefined" === k || "boolean" === k) a = null;
          var h = !1;
          if (null === a) h = !0;else switch (k) {
            case "string":
            case "number":
              h = !0;
              break;
            case "object":
              switch (a.$$typeof) {
                case l$6:
                case n$7:
                  h = !0;
              }
          }
          if (h) return h = a, c = c(h), a = "" === d ? "." + Q$2(h, 0) : d, I$3(c) ? (e = "", null != a && (e = a.replace(P$2, "$&/") + "/"), R$2(c, b, e, "", function (a) {
            return a;
          })) : null != c && (O$2(c) && (c = N$2(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P$2, "$&/") + "/") + a)), b.push(c)), 1;
          h = 0;
          d = "" === d ? "." : d + ":";
          if (I$3(a)) for (var g = 0; g < a.length; g++) {
            k = a[g];
            var f = d + Q$2(k, g);
            h += R$2(k, b, e, f, c);
          } else if (f = A$4(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done;) k = k.value, f = d + Q$2(k, g++), h += R$2(k, b, e, f, c);else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
          return h;
        }
        function S$2(a, b, e) {
          if (null == a) return a;
          var d = [],
            c = 0;
          R$2(a, d, "", "", function (a) {
            return b.call(e, a, c++);
          });
          return d;
        }
        function T$1(a) {
          if (-1 === a._status) {
            var b = a._result;
            b = b();
            b.then(function (b) {
              if (0 === a._status || -1 === a._status) a._status = 1, a._result = b;
            }, function (b) {
              if (0 === a._status || -1 === a._status) a._status = 2, a._result = b;
            });
            -1 === a._status && (a._status = 0, a._result = b);
          }
          if (1 === a._status) return a._result.default;
          throw a._result;
        }
        var U$2 = {
            current: null
          },
          V$1 = {
            transition: null
          },
          W$2 = {
            ReactCurrentDispatcher: U$2,
            ReactCurrentBatchConfig: V$1,
            ReactCurrentOwner: K$1
          };
        react_production_min.Children = {
          map: S$2,
          forEach: function (a, b, e) {
            S$2(a, function () {
              b.apply(this, arguments);
            }, e);
          },
          count: function (a) {
            var b = 0;
            S$2(a, function () {
              b++;
            });
            return b;
          },
          toArray: function (a) {
            return S$2(a, function (a) {
              return a;
            }) || [];
          },
          only: function (a) {
            if (!O$2(a)) throw Error("React.Children.only expected to receive a single React element child.");
            return a;
          }
        };
        react_production_min.Component = E$3;
        react_production_min.Fragment = p$8;
        react_production_min.Profiler = r$6;
        react_production_min.PureComponent = G$3;
        react_production_min.StrictMode = q$7;
        react_production_min.Suspense = w$4;
        react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$2;
        react_production_min.cloneElement = function (a, b, e) {
          if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
          var d = C$2({}, a.props),
            c = a.key,
            k = a.ref,
            h = a._owner;
          if (null != b) {
            void 0 !== b.ref && (k = b.ref, h = K$1.current);
            void 0 !== b.key && (c = "" + b.key);
            if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
            for (f in b) J.call(b, f) && !L$2.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
          }
          var f = arguments.length - 2;
          if (1 === f) d.children = e;else if (1 < f) {
            g = Array(f);
            for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
            d.children = g;
          }
          return {
            $$typeof: l$6,
            type: a.type,
            key: c,
            ref: k,
            props: d,
            _owner: h
          };
        };
        react_production_min.createContext = function (a) {
          a = {
            $$typeof: u$5,
            _currentValue: a,
            _currentValue2: a,
            _threadCount: 0,
            Provider: null,
            Consumer: null,
            _defaultValue: null,
            _globalName: null
          };
          a.Provider = {
            $$typeof: t$5,
            _context: a
          };
          return a.Consumer = a;
        };
        react_production_min.createElement = M$2;
        react_production_min.createFactory = function (a) {
          var b = M$2.bind(null, a);
          b.type = a;
          return b;
        };
        react_production_min.createRef = function () {
          return {
            current: null
          };
        };
        react_production_min.forwardRef = function (a) {
          return {
            $$typeof: v$6,
            render: a
          };
        };
        react_production_min.isValidElement = O$2;
        react_production_min.lazy = function (a) {
          return {
            $$typeof: y$3,
            _payload: {
              _status: -1,
              _result: a
            },
            _init: T$1
          };
        };
        react_production_min.memo = function (a, b) {
          return {
            $$typeof: x$3,
            type: a,
            compare: void 0 === b ? null : b
          };
        };
        react_production_min.startTransition = function (a) {
          var b = V$1.transition;
          V$1.transition = {};
          try {
            a();
          } finally {
            V$1.transition = b;
          }
        };
        react_production_min.unstable_act = function () {
          throw Error("act(...) is not supported in production builds of React.");
        };
        react_production_min.useCallback = function (a, b) {
          return U$2.current.useCallback(a, b);
        };
        react_production_min.useContext = function (a) {
          return U$2.current.useContext(a);
        };
        react_production_min.useDebugValue = function () {};
        react_production_min.useDeferredValue = function (a) {
          return U$2.current.useDeferredValue(a);
        };
        react_production_min.useEffect = function (a, b) {
          return U$2.current.useEffect(a, b);
        };
        react_production_min.useId = function () {
          return U$2.current.useId();
        };
        react_production_min.useImperativeHandle = function (a, b, e) {
          return U$2.current.useImperativeHandle(a, b, e);
        };
        react_production_min.useInsertionEffect = function (a, b) {
          return U$2.current.useInsertionEffect(a, b);
        };
        react_production_min.useLayoutEffect = function (a, b) {
          return U$2.current.useLayoutEffect(a, b);
        };
        react_production_min.useMemo = function (a, b) {
          return U$2.current.useMemo(a, b);
        };
        react_production_min.useReducer = function (a, b, e) {
          return U$2.current.useReducer(a, b, e);
        };
        react_production_min.useRef = function (a) {
          return U$2.current.useRef(a);
        };
        react_production_min.useState = function (a) {
          return U$2.current.useState(a);
        };
        react_production_min.useSyncExternalStore = function (a, b, e) {
          return U$2.current.useSyncExternalStore(a, b, e);
        };
        react_production_min.useTransition = function () {
          return U$2.current.useTransition();
        };
        react_production_min.version = "18.2.0";
        {
          react.exports = react_production_min;
        }
        var reactExports = exports('r', react.exports);
        const React = exports('R', /*@__PURE__*/getDefaultExportFromCjs(reactExports));
        const React$1 = /*#__PURE__*/_mergeNamespaces({
          __proto__: null,
          default: React
        }, [reactExports]);
        exports('bR', React$1);

        /**
         * @license React
         * react-jsx-runtime.production.min.js
         *
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */
        var f$4 = reactExports,
          k$5 = Symbol.for("react.element"),
          l$5 = Symbol.for("react.fragment"),
          m$6 = Object.prototype.hasOwnProperty,
          n$6 = f$4.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
          p$7 = {
            key: !0,
            ref: !0,
            __self: !0,
            __source: !0
          };
        function q$6(c, a, g) {
          var b,
            d = {},
            e = null,
            h = null;
          void 0 !== g && (e = "" + g);
          void 0 !== a.key && (e = "" + a.key);
          void 0 !== a.ref && (h = a.ref);
          for (b in a) m$6.call(a, b) && !p$7.hasOwnProperty(b) && (d[b] = a[b]);
          if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
          return {
            $$typeof: k$5,
            type: c,
            key: e,
            ref: h,
            props: d,
            _owner: n$6.current
          };
        }
        reactJsxRuntime_production_min.Fragment = l$5;
        reactJsxRuntime_production_min.jsx = q$6;
        reactJsxRuntime_production_min.jsxs = q$6;
        {
          jsxRuntime.exports = reactJsxRuntime_production_min;
        }
        var jsxRuntimeExports = exports('j', jsxRuntime.exports);
        function _typeof(obj) {
          "@babel/helpers - typeof";

          return exports('aB', _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          }), _typeof(obj);
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _toPrimitive(input, hint) {
          if (_typeof(input) !== "object" || input === null) return input;
          var prim = input[Symbol.toPrimitive];
          if (prim !== undefined) {
            var res = prim.call(input, hint || "default");
            if (_typeof(res) !== "object") return res;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return (hint === "string" ? String : Number)(input);
        }
        function _toPropertyKey(arg) {
          var key = _toPrimitive(arg, "string");
          return _typeof(key) === "symbol" ? key : String(key);
        }
        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties(Constructor.prototype, protoProps);
          if (staticProps) _defineProperties(Constructor, staticProps);
          Object.defineProperty(Constructor, "prototype", {
            writable: false
          });
          return Constructor;
        }
        function _assertThisInitialized(self) {
          if (self === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return self;
        }
        function _setPrototypeOf(o, p) {
          _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
            o.__proto__ = p;
            return o;
          };
          return _setPrototypeOf(o, p);
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function");
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              writable: true,
              configurable: true
            }
          });
          Object.defineProperty(subClass, "prototype", {
            writable: false
          });
          if (superClass) _setPrototypeOf(subClass, superClass);
        }
        function _possibleConstructorReturn(self, call) {
          if (call && (_typeof(call) === "object" || typeof call === "function")) {
            return call;
          } else if (call !== void 0) {
            throw new TypeError("Derived constructors may only return object or undefined");
          }
          return _assertThisInitialized(self);
        }
        function _getPrototypeOf(o) {
          exports('bj', _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
            return o.__proto__ || Object.getPrototypeOf(o);
          });
          return _getPrototypeOf(o);
        }
        function _defineProperty(obj, key, value) {
          key = _toPropertyKey(key);
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function _arrayWithHoles(arr) {
          if (Array.isArray(arr)) return arr;
        }
        function _iterableToArray(iter) {
          if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
        }
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }
        function _unsupportedIterableToArray(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }
        function _nonIterableRest() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _toArray(arr) {
          return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
        }
        function ownKeys$1(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly) {
              symbols = symbols.filter(function (sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
            }
            keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            if (i % 2) {
              ownKeys$1(Object(source), true).forEach(function (key) {
                _defineProperty(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              ownKeys$1(Object(source)).forEach(function (key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target;
        }
        var consoleLogger = {
          type: 'logger',
          log: function log(args) {
            this.output('log', args);
          },
          warn: function warn(args) {
            this.output('warn', args);
          },
          error: function error(args) {
            this.output('error', args);
          },
          output: function output(type, args) {
            if (console && console[type]) console[type].apply(console, args);
          }
        };
        var Logger = function () {
          function Logger(concreteLogger) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            _classCallCheck(this, Logger);
            this.init(concreteLogger, options);
          }
          _createClass(Logger, [{
            key: "init",
            value: function init(concreteLogger) {
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              this.prefix = options.prefix || 'i18next:';
              this.logger = concreteLogger || consoleLogger;
              this.options = options;
              this.debug = options.debug;
            }
          }, {
            key: "setDebug",
            value: function setDebug(bool) {
              this.debug = bool;
            }
          }, {
            key: "log",
            value: function log() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return this.forward(args, 'log', '', true);
            }
          }, {
            key: "warn",
            value: function warn() {
              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
              }
              return this.forward(args, 'warn', '', true);
            }
          }, {
            key: "error",
            value: function error() {
              for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                args[_key3] = arguments[_key3];
              }
              return this.forward(args, 'error', '');
            }
          }, {
            key: "deprecate",
            value: function deprecate() {
              for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                args[_key4] = arguments[_key4];
              }
              return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);
            }
          }, {
            key: "forward",
            value: function forward(args, lvl, prefix, debugOnly) {
              if (debugOnly && !this.debug) return null;
              if (typeof args[0] === 'string') args[0] = "".concat(prefix).concat(this.prefix, " ").concat(args[0]);
              return this.logger[lvl](args);
            }
          }, {
            key: "create",
            value: function create(moduleName) {
              return new Logger(this.logger, _objectSpread(_objectSpread({}, {
                prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
              }), this.options));
            }
          }, {
            key: "clone",
            value: function clone(options) {
              options = options || this.options;
              options.prefix = options.prefix || this.prefix;
              return new Logger(this.logger, options);
            }
          }]);
          return Logger;
        }();
        var baseLogger = new Logger();
        var EventEmitter = function () {
          function EventEmitter() {
            _classCallCheck(this, EventEmitter);
            this.observers = {};
          }
          _createClass(EventEmitter, [{
            key: "on",
            value: function on(events, listener) {
              var _this = this;
              events.split(' ').forEach(function (event) {
                _this.observers[event] = _this.observers[event] || [];
                _this.observers[event].push(listener);
              });
              return this;
            }
          }, {
            key: "off",
            value: function off(event, listener) {
              if (!this.observers[event]) return;
              if (!listener) {
                delete this.observers[event];
                return;
              }
              this.observers[event] = this.observers[event].filter(function (l) {
                return l !== listener;
              });
            }
          }, {
            key: "emit",
            value: function emit(event) {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              if (this.observers[event]) {
                var cloned = [].concat(this.observers[event]);
                cloned.forEach(function (observer) {
                  observer.apply(void 0, args);
                });
              }
              if (this.observers['*']) {
                var _cloned = [].concat(this.observers['*']);
                _cloned.forEach(function (observer) {
                  observer.apply(observer, [event].concat(args));
                });
              }
            }
          }]);
          return EventEmitter;
        }();
        function defer() {
          var res;
          var rej;
          var promise = new Promise(function (resolve, reject) {
            res = resolve;
            rej = reject;
          });
          promise.resolve = res;
          promise.reject = rej;
          return promise;
        }
        function makeString(object) {
          if (object == null) return '';
          return '' + object;
        }
        function copy$1(a, s, t) {
          a.forEach(function (m) {
            if (s[m]) t[m] = s[m];
          });
        }
        function getLastOfPath(object, path, Empty) {
          function cleanKey(key) {
            return key && key.indexOf('###') > -1 ? key.replace(/###/g, '.') : key;
          }
          function canNotTraverseDeeper() {
            return !object || typeof object === 'string';
          }
          var stack = typeof path !== 'string' ? [].concat(path) : path.split('.');
          while (stack.length > 1) {
            if (canNotTraverseDeeper()) return {};
            var key = cleanKey(stack.shift());
            if (!object[key] && Empty) object[key] = new Empty();
            if (Object.prototype.hasOwnProperty.call(object, key)) {
              object = object[key];
            } else {
              object = {};
            }
          }
          if (canNotTraverseDeeper()) return {};
          return {
            obj: object,
            k: cleanKey(stack.shift())
          };
        }
        function setPath(object, path, newValue) {
          var _getLastOfPath = getLastOfPath(object, path, Object),
            obj = _getLastOfPath.obj,
            k = _getLastOfPath.k;
          obj[k] = newValue;
        }
        function pushPath(object, path, newValue, concat) {
          var _getLastOfPath2 = getLastOfPath(object, path, Object),
            obj = _getLastOfPath2.obj,
            k = _getLastOfPath2.k;
          obj[k] = obj[k] || [];
          if (concat) obj[k] = obj[k].concat(newValue);
          if (!concat) obj[k].push(newValue);
        }
        function getPath$1(object, path) {
          var _getLastOfPath3 = getLastOfPath(object, path),
            obj = _getLastOfPath3.obj,
            k = _getLastOfPath3.k;
          if (!obj) return undefined;
          return obj[k];
        }
        function getPathWithDefaults(data, defaultData, key) {
          var value = getPath$1(data, key);
          if (value !== undefined) {
            return value;
          }
          return getPath$1(defaultData, key);
        }
        function deepExtend(target, source, overwrite) {
          for (var prop in source) {
            if (prop !== '__proto__' && prop !== 'constructor') {
              if (prop in target) {
                if (typeof target[prop] === 'string' || target[prop] instanceof String || typeof source[prop] === 'string' || source[prop] instanceof String) {
                  if (overwrite) target[prop] = source[prop];
                } else {
                  deepExtend(target[prop], source[prop], overwrite);
                }
              } else {
                target[prop] = source[prop];
              }
            }
          }
          return target;
        }
        function regexEscape(str) {
          return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
        }
        var _entityMap = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;',
          '/': '&#x2F;'
        };
        function escape$2(data) {
          if (typeof data === 'string') {
            return data.replace(/[&<>"'\/]/g, function (s) {
              return _entityMap[s];
            });
          }
          return data;
        }
        var isIE10 = typeof window !== 'undefined' && window.navigator && typeof window.navigator.userAgentData === 'undefined' && window.navigator.userAgent && window.navigator.userAgent.indexOf('MSIE') > -1;
        var chars = [' ', ',', '?', '!', ';'];
        function looksLikeObjectPath(key, nsSeparator, keySeparator) {
          nsSeparator = nsSeparator || '';
          keySeparator = keySeparator || '';
          var possibleChars = chars.filter(function (c) {
            return nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0;
          });
          if (possibleChars.length === 0) return true;
          var r = new RegExp("(".concat(possibleChars.map(function (c) {
            return c === '?' ? '\\?' : c;
          }).join('|'), ")"));
          var matched = !r.test(key);
          if (!matched) {
            var ki = key.indexOf(keySeparator);
            if (ki > 0 && !r.test(key.substring(0, ki))) {
              matched = true;
            }
          }
          return matched;
        }
        function ownKeys$1$1(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly) {
              symbols = symbols.filter(function (sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
            }
            keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$1(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            if (i % 2) {
              ownKeys$1$1(Object(source), true).forEach(function (key) {
                _defineProperty(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              ownKeys$1$1(Object(source)).forEach(function (key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target;
        }
        function _createSuper(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function _isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        function deepFind(obj, path) {
          var keySeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';
          if (!obj) return undefined;
          if (obj[path]) return obj[path];
          var paths = path.split(keySeparator);
          var current = obj;
          for (var i = 0; i < paths.length; ++i) {
            if (!current) return undefined;
            if (typeof current[paths[i]] === 'string' && i + 1 < paths.length) {
              return undefined;
            }
            if (current[paths[i]] === undefined) {
              var j = 2;
              var p = paths.slice(i, i + j).join(keySeparator);
              var mix = current[p];
              while (mix === undefined && paths.length > i + j) {
                j++;
                p = paths.slice(i, i + j).join(keySeparator);
                mix = current[p];
              }
              if (mix === undefined) return undefined;
              if (mix === null) return null;
              if (path.endsWith(p)) {
                if (typeof mix === 'string') return mix;
                if (p && typeof mix[p] === 'string') return mix[p];
              }
              var joinedPath = paths.slice(i + j).join(keySeparator);
              if (joinedPath) return deepFind(mix, joinedPath, keySeparator);
              return undefined;
            }
            current = current[paths[i]];
          }
          return current;
        }
        var ResourceStore = function (_EventEmitter) {
          _inherits(ResourceStore, _EventEmitter);
          var _super = _createSuper(ResourceStore);
          function ResourceStore(data) {
            var _this;
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
              ns: ['translation'],
              defaultNS: 'translation'
            };
            _classCallCheck(this, ResourceStore);
            _this = _super.call(this);
            if (isIE10) {
              EventEmitter.call(_assertThisInitialized(_this));
            }
            _this.data = data || {};
            _this.options = options;
            if (_this.options.keySeparator === undefined) {
              _this.options.keySeparator = '.';
            }
            if (_this.options.ignoreJSONStructure === undefined) {
              _this.options.ignoreJSONStructure = true;
            }
            return _this;
          }
          _createClass(ResourceStore, [{
            key: "addNamespaces",
            value: function addNamespaces(ns) {
              if (this.options.ns.indexOf(ns) < 0) {
                this.options.ns.push(ns);
              }
            }
          }, {
            key: "removeNamespaces",
            value: function removeNamespaces(ns) {
              var index = this.options.ns.indexOf(ns);
              if (index > -1) {
                this.options.ns.splice(index, 1);
              }
            }
          }, {
            key: "getResource",
            value: function getResource(lng, ns, key) {
              var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
              var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
              var ignoreJSONStructure = options.ignoreJSONStructure !== undefined ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
              var path = [lng, ns];
              if (key && typeof key !== 'string') path = path.concat(key);
              if (key && typeof key === 'string') path = path.concat(keySeparator ? key.split(keySeparator) : key);
              if (lng.indexOf('.') > -1) {
                path = lng.split('.');
              }
              var result = getPath$1(this.data, path);
              if (result || !ignoreJSONStructure || typeof key !== 'string') return result;
              return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
            }
          }, {
            key: "addResource",
            value: function addResource(lng, ns, key, value) {
              var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
                silent: false
              };
              var keySeparator = this.options.keySeparator;
              if (keySeparator === undefined) keySeparator = '.';
              var path = [lng, ns];
              if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);
              if (lng.indexOf('.') > -1) {
                path = lng.split('.');
                value = ns;
                ns = path[1];
              }
              this.addNamespaces(ns);
              setPath(this.data, path, value);
              if (!options.silent) this.emit('added', lng, ns, key, value);
            }
          }, {
            key: "addResources",
            value: function addResources(lng, ns, resources) {
              var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
                silent: false
              };
              for (var m in resources) {
                if (typeof resources[m] === 'string' || Object.prototype.toString.apply(resources[m]) === '[object Array]') this.addResource(lng, ns, m, resources[m], {
                  silent: true
                });
              }
              if (!options.silent) this.emit('added', lng, ns, resources);
            }
          }, {
            key: "addResourceBundle",
            value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
              var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {
                silent: false
              };
              var path = [lng, ns];
              if (lng.indexOf('.') > -1) {
                path = lng.split('.');
                deep = resources;
                resources = ns;
                ns = path[1];
              }
              this.addNamespaces(ns);
              var pack = getPath$1(this.data, path) || {};
              if (deep) {
                deepExtend(pack, resources, overwrite);
              } else {
                pack = _objectSpread$1(_objectSpread$1({}, pack), resources);
              }
              setPath(this.data, path, pack);
              if (!options.silent) this.emit('added', lng, ns, resources);
            }
          }, {
            key: "removeResourceBundle",
            value: function removeResourceBundle(lng, ns) {
              if (this.hasResourceBundle(lng, ns)) {
                delete this.data[lng][ns];
              }
              this.removeNamespaces(ns);
              this.emit('removed', lng, ns);
            }
          }, {
            key: "hasResourceBundle",
            value: function hasResourceBundle(lng, ns) {
              return this.getResource(lng, ns) !== undefined;
            }
          }, {
            key: "getResourceBundle",
            value: function getResourceBundle(lng, ns) {
              if (!ns) ns = this.options.defaultNS;
              if (this.options.compatibilityAPI === 'v1') return _objectSpread$1(_objectSpread$1({}, {}), this.getResource(lng, ns));
              return this.getResource(lng, ns);
            }
          }, {
            key: "getDataByLanguage",
            value: function getDataByLanguage(lng) {
              return this.data[lng];
            }
          }, {
            key: "hasLanguageSomeTranslations",
            value: function hasLanguageSomeTranslations(lng) {
              var data = this.getDataByLanguage(lng);
              var n = data && Object.keys(data) || [];
              return !!n.find(function (v) {
                return data[v] && Object.keys(data[v]).length > 0;
              });
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              return this.data;
            }
          }]);
          return ResourceStore;
        }(EventEmitter);
        var postProcessor = {
          processors: {},
          addPostProcessor: function addPostProcessor(module) {
            this.processors[module.name] = module;
          },
          handle: function handle(processors, value, key, options, translator) {
            var _this = this;
            processors.forEach(function (processor) {
              if (_this.processors[processor]) value = _this.processors[processor].process(value, key, options, translator);
            });
            return value;
          }
        };
        function ownKeys$2(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly) {
              symbols = symbols.filter(function (sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
            }
            keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$2(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            if (i % 2) {
              ownKeys$2(Object(source), true).forEach(function (key) {
                _defineProperty(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              ownKeys$2(Object(source)).forEach(function (key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target;
        }
        function _createSuper$1(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function _isNativeReflectConstruct$1() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var checkedLoadedFor = {};
        var Translator = function (_EventEmitter) {
          _inherits(Translator, _EventEmitter);
          var _super = _createSuper$1(Translator);
          function Translator(services) {
            var _this;
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            _classCallCheck(this, Translator);
            _this = _super.call(this);
            if (isIE10) {
              EventEmitter.call(_assertThisInitialized(_this));
            }
            copy$1(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector', 'i18nFormat', 'utils'], services, _assertThisInitialized(_this));
            _this.options = options;
            if (_this.options.keySeparator === undefined) {
              _this.options.keySeparator = '.';
            }
            _this.logger = baseLogger.create('translator');
            return _this;
          }
          _createClass(Translator, [{
            key: "changeLanguage",
            value: function changeLanguage(lng) {
              if (lng) this.language = lng;
            }
          }, {
            key: "exists",
            value: function exists(key) {
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
                interpolation: {}
              };
              if (key === undefined || key === null) {
                return false;
              }
              var resolved = this.resolve(key, options);
              return resolved && resolved.res !== undefined;
            }
          }, {
            key: "extractFromKey",
            value: function extractFromKey(key, options) {
              var nsSeparator = options.nsSeparator !== undefined ? options.nsSeparator : this.options.nsSeparator;
              if (nsSeparator === undefined) nsSeparator = ':';
              var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
              var namespaces = options.ns || this.options.defaultNS || [];
              var wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
              var seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
              if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
                var m = key.match(this.interpolator.nestingRegexp);
                if (m && m.length > 0) {
                  return {
                    key: key,
                    namespaces: namespaces
                  };
                }
                var parts = key.split(nsSeparator);
                if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
                key = parts.join(keySeparator);
              }
              if (typeof namespaces === 'string') namespaces = [namespaces];
              return {
                key: key,
                namespaces: namespaces
              };
            }
          }, {
            key: "translate",
            value: function translate(keys, options, lastKey) {
              var _this2 = this;
              if (_typeof(options) !== 'object' && this.options.overloadTranslationOptionHandler) {
                options = this.options.overloadTranslationOptionHandler(arguments);
              }
              if (!options) options = {};
              if (keys === undefined || keys === null) return '';
              if (!Array.isArray(keys)) keys = [String(keys)];
              var returnDetails = options.returnDetails !== undefined ? options.returnDetails : this.options.returnDetails;
              var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
              var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options),
                key = _this$extractFromKey.key,
                namespaces = _this$extractFromKey.namespaces;
              var namespace = namespaces[namespaces.length - 1];
              var lng = options.lng || this.language;
              var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
              if (lng && lng.toLowerCase() === 'cimode') {
                if (appendNamespaceToCIMode) {
                  var nsSeparator = options.nsSeparator || this.options.nsSeparator;
                  if (returnDetails) {
                    resolved.res = "".concat(namespace).concat(nsSeparator).concat(key);
                    return resolved;
                  }
                  return "".concat(namespace).concat(nsSeparator).concat(key);
                }
                if (returnDetails) {
                  resolved.res = key;
                  return resolved;
                }
                return key;
              }
              var resolved = this.resolve(keys, options);
              var res = resolved && resolved.res;
              var resUsedKey = resolved && resolved.usedKey || key;
              var resExactUsedKey = resolved && resolved.exactUsedKey || key;
              var resType = Object.prototype.toString.apply(res);
              var noObject = ['[object Number]', '[object Function]', '[object RegExp]'];
              var joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;
              var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
              var handleAsObject = typeof res !== 'string' && typeof res !== 'boolean' && typeof res !== 'number';
              if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === 'string' && resType === '[object Array]')) {
                if (!options.returnObjects && !this.options.returnObjects) {
                  if (!this.options.returnedObjectHandler) {
                    this.logger.warn('accessing an object - but returnObjects options is not enabled!');
                  }
                  var r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, _objectSpread$2(_objectSpread$2({}, options), {}, {
                    ns: namespaces
                  })) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
                  if (returnDetails) {
                    resolved.res = r;
                    return resolved;
                  }
                  return r;
                }
                if (keySeparator) {
                  var resTypeIsArray = resType === '[object Array]';
                  var copy = resTypeIsArray ? [] : {};
                  var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
                  for (var m in res) {
                    if (Object.prototype.hasOwnProperty.call(res, m)) {
                      var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m);
                      copy[m] = this.translate(deepKey, _objectSpread$2(_objectSpread$2({}, options), {
                        joinArrays: false,
                        ns: namespaces
                      }));
                      if (copy[m] === deepKey) copy[m] = res[m];
                    }
                  }
                  res = copy;
                }
              } else if (handleAsObjectInI18nFormat && typeof joinArrays === 'string' && resType === '[object Array]') {
                res = res.join(joinArrays);
                if (res) res = this.extendTranslation(res, keys, options, lastKey);
              } else {
                var usedDefault = false;
                var usedKey = false;
                var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';
                var hasDefaultValue = Translator.hasDefaultValue(options);
                var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : '';
                var defaultValue = options["defaultValue".concat(defaultValueSuffix)] || options.defaultValue;
                if (!this.isValidLookup(res) && hasDefaultValue) {
                  usedDefault = true;
                  res = defaultValue;
                }
                if (!this.isValidLookup(res)) {
                  usedKey = true;
                  res = key;
                }
                var missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
                var resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;
                var updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
                if (usedKey || usedDefault || updateMissing) {
                  this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? defaultValue : res);
                  if (keySeparator) {
                    var fk = this.resolve(key, _objectSpread$2(_objectSpread$2({}, options), {}, {
                      keySeparator: false
                    }));
                    if (fk && fk.res) this.logger.warn('Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.');
                  }
                  var lngs = [];
                  var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
                  if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {
                    for (var i = 0; i < fallbackLngs.length; i++) {
                      lngs.push(fallbackLngs[i]);
                    }
                  } else if (this.options.saveMissingTo === 'all') {
                    lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
                  } else {
                    lngs.push(options.lng || this.language);
                  }
                  var send = function send(l, k, specificDefaultValue) {
                    var defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
                    if (_this2.options.missingKeyHandler) {
                      _this2.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);
                    } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
                      _this2.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);
                    }
                    _this2.emit('missingKey', l, namespace, k, res);
                  };
                  if (this.options.saveMissing) {
                    if (this.options.saveMissingPlurals && needsPluralHandling) {
                      lngs.forEach(function (language) {
                        _this2.pluralResolver.getSuffixes(language, options).forEach(function (suffix) {
                          send([language], key + suffix, options["defaultValue".concat(suffix)] || defaultValue);
                        });
                      });
                    } else {
                      send(lngs, key, defaultValue);
                    }
                  }
                }
                res = this.extendTranslation(res, keys, options, resolved, lastKey);
                if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = "".concat(namespace, ":").concat(key);
                if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
                  if (this.options.compatibilityAPI !== 'v1') {
                    res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? "".concat(namespace, ":").concat(key) : key, usedDefault ? res : undefined);
                  } else {
                    res = this.options.parseMissingKeyHandler(res);
                  }
                }
              }
              if (returnDetails) {
                resolved.res = res;
                return resolved;
              }
              return res;
            }
          }, {
            key: "extendTranslation",
            value: function extendTranslation(res, key, options, resolved, lastKey) {
              var _this3 = this;
              if (this.i18nFormat && this.i18nFormat.parse) {
                res = this.i18nFormat.parse(res, _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), options), resolved.usedLng, resolved.usedNS, resolved.usedKey, {
                  resolved: resolved
                });
              } else if (!options.skipInterpolation) {
                if (options.interpolation) this.interpolator.init(_objectSpread$2(_objectSpread$2({}, options), {
                  interpolation: _objectSpread$2(_objectSpread$2({}, this.options.interpolation), options.interpolation)
                }));
                var skipOnVariables = typeof res === 'string' && (options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
                var nestBef;
                if (skipOnVariables) {
                  var nb = res.match(this.interpolator.nestingRegexp);
                  nestBef = nb && nb.length;
                }
                var data = options.replace && typeof options.replace !== 'string' ? options.replace : options;
                if (this.options.interpolation.defaultVariables) data = _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), data);
                res = this.interpolator.interpolate(res, data, options.lng || this.language, options);
                if (skipOnVariables) {
                  var na = res.match(this.interpolator.nestingRegexp);
                  var nestAft = na && na.length;
                  if (nestBef < nestAft) options.nest = false;
                }
                if (options.nest !== false) res = this.interpolator.nest(res, function () {
                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                  }
                  if (lastKey && lastKey[0] === args[0] && !options.context) {
                    _this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key[0]));
                    return null;
                  }
                  return _this3.translate.apply(_this3, args.concat([key]));
                }, options);
                if (options.interpolation) this.interpolator.reset();
              }
              var postProcess = options.postProcess || this.options.postProcess;
              var postProcessorNames = typeof postProcess === 'string' ? [postProcess] : postProcess;
              if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
                res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread$2({
                  i18nResolved: resolved
                }, options) : options, this);
              }
              return res;
            }
          }, {
            key: "resolve",
            value: function resolve(keys) {
              var _this4 = this;
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              var found;
              var usedKey;
              var exactUsedKey;
              var usedLng;
              var usedNS;
              if (typeof keys === 'string') keys = [keys];
              keys.forEach(function (k) {
                if (_this4.isValidLookup(found)) return;
                var extracted = _this4.extractFromKey(k, options);
                var key = extracted.key;
                usedKey = key;
                var namespaces = extracted.namespaces;
                if (_this4.options.fallbackNS) namespaces = namespaces.concat(_this4.options.fallbackNS);
                var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';
                var needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && _this4.pluralResolver.shouldUseIntlApi();
                var needsContextHandling = options.context !== undefined && (typeof options.context === 'string' || typeof options.context === 'number') && options.context !== '';
                var codes = options.lngs ? options.lngs : _this4.languageUtils.toResolveHierarchy(options.lng || _this4.language, options.fallbackLng);
                namespaces.forEach(function (ns) {
                  if (_this4.isValidLookup(found)) return;
                  usedNS = ns;
                  if (!checkedLoadedFor["".concat(codes[0], "-").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
                    checkedLoadedFor["".concat(codes[0], "-").concat(ns)] = true;
                    _this4.logger.warn("key \"".concat(usedKey, "\" for languages \"").concat(codes.join(', '), "\" won't get resolved as namespace \"").concat(usedNS, "\" was not yet loaded"), 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
                  }
                  codes.forEach(function (code) {
                    if (_this4.isValidLookup(found)) return;
                    usedLng = code;
                    var finalKeys = [key];
                    if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
                      _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
                    } else {
                      var pluralSuffix;
                      if (needsPluralHandling) pluralSuffix = _this4.pluralResolver.getSuffix(code, options.count, options);
                      var zeroSuffix = "".concat(_this4.options.pluralSeparator, "zero");
                      if (needsPluralHandling) {
                        finalKeys.push(key + pluralSuffix);
                        if (needsZeroSuffixLookup) {
                          finalKeys.push(key + zeroSuffix);
                        }
                      }
                      if (needsContextHandling) {
                        var contextKey = "".concat(key).concat(_this4.options.contextSeparator).concat(options.context);
                        finalKeys.push(contextKey);
                        if (needsPluralHandling) {
                          finalKeys.push(contextKey + pluralSuffix);
                          if (needsZeroSuffixLookup) {
                            finalKeys.push(contextKey + zeroSuffix);
                          }
                        }
                      }
                    }
                    var possibleKey;
                    while (possibleKey = finalKeys.pop()) {
                      if (!_this4.isValidLookup(found)) {
                        exactUsedKey = possibleKey;
                        found = _this4.getResource(code, ns, possibleKey, options);
                      }
                    }
                  });
                });
              });
              return {
                res: found,
                usedKey: usedKey,
                exactUsedKey: exactUsedKey,
                usedLng: usedLng,
                usedNS: usedNS
              };
            }
          }, {
            key: "isValidLookup",
            value: function isValidLookup(res) {
              return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');
            }
          }, {
            key: "getResource",
            value: function getResource(code, ns, key) {
              var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
              if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);
              return this.resourceStore.getResource(code, ns, key, options);
            }
          }], [{
            key: "hasDefaultValue",
            value: function hasDefaultValue(options) {
              var prefix = 'defaultValue';
              for (var option in options) {
                if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && undefined !== options[option]) {
                  return true;
                }
              }
              return false;
            }
          }]);
          return Translator;
        }(EventEmitter);
        function capitalize$1(string) {
          return string.charAt(0).toUpperCase() + string.slice(1);
        }
        var LanguageUtil = function () {
          function LanguageUtil(options) {
            _classCallCheck(this, LanguageUtil);
            this.options = options;
            this.supportedLngs = this.options.supportedLngs || false;
            this.logger = baseLogger.create('languageUtils');
          }
          _createClass(LanguageUtil, [{
            key: "getScriptPartFromCode",
            value: function getScriptPartFromCode(code) {
              if (!code || code.indexOf('-') < 0) return null;
              var p = code.split('-');
              if (p.length === 2) return null;
              p.pop();
              if (p[p.length - 1].toLowerCase() === 'x') return null;
              return this.formatLanguageCode(p.join('-'));
            }
          }, {
            key: "getLanguagePartFromCode",
            value: function getLanguagePartFromCode(code) {
              if (!code || code.indexOf('-') < 0) return code;
              var p = code.split('-');
              return this.formatLanguageCode(p[0]);
            }
          }, {
            key: "formatLanguageCode",
            value: function formatLanguageCode(code) {
              if (typeof code === 'string' && code.indexOf('-') > -1) {
                var specialCases = ['hans', 'hant', 'latn', 'cyrl', 'cans', 'mong', 'arab'];
                var p = code.split('-');
                if (this.options.lowerCaseLng) {
                  p = p.map(function (part) {
                    return part.toLowerCase();
                  });
                } else if (p.length === 2) {
                  p[0] = p[0].toLowerCase();
                  p[1] = p[1].toUpperCase();
                  if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize$1(p[1].toLowerCase());
                } else if (p.length === 3) {
                  p[0] = p[0].toLowerCase();
                  if (p[1].length === 2) p[1] = p[1].toUpperCase();
                  if (p[0] !== 'sgn' && p[2].length === 2) p[2] = p[2].toUpperCase();
                  if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize$1(p[1].toLowerCase());
                  if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize$1(p[2].toLowerCase());
                }
                return p.join('-');
              }
              return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
            }
          }, {
            key: "isSupportedCode",
            value: function isSupportedCode(code) {
              if (this.options.load === 'languageOnly' || this.options.nonExplicitSupportedLngs) {
                code = this.getLanguagePartFromCode(code);
              }
              return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
            }
          }, {
            key: "getBestMatchFromCodes",
            value: function getBestMatchFromCodes(codes) {
              var _this = this;
              if (!codes) return null;
              var found;
              codes.forEach(function (code) {
                if (found) return;
                var cleanedLng = _this.formatLanguageCode(code);
                if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng)) found = cleanedLng;
              });
              if (!found && this.options.supportedLngs) {
                codes.forEach(function (code) {
                  if (found) return;
                  var lngOnly = _this.getLanguagePartFromCode(code);
                  if (_this.isSupportedCode(lngOnly)) return found = lngOnly;
                  found = _this.options.supportedLngs.find(function (supportedLng) {
                    if (supportedLng.indexOf(lngOnly) === 0) return supportedLng;
                  });
                });
              }
              if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
              return found;
            }
          }, {
            key: "getFallbackCodes",
            value: function getFallbackCodes(fallbacks, code) {
              if (!fallbacks) return [];
              if (typeof fallbacks === 'function') fallbacks = fallbacks(code);
              if (typeof fallbacks === 'string') fallbacks = [fallbacks];
              if (Object.prototype.toString.apply(fallbacks) === '[object Array]') return fallbacks;
              if (!code) return fallbacks["default"] || [];
              var found = fallbacks[code];
              if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
              if (!found) found = fallbacks[this.formatLanguageCode(code)];
              if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
              if (!found) found = fallbacks["default"];
              return found || [];
            }
          }, {
            key: "toResolveHierarchy",
            value: function toResolveHierarchy(code, fallbackCode) {
              var _this2 = this;
              var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
              var codes = [];
              var addCode = function addCode(c) {
                if (!c) return;
                if (_this2.isSupportedCode(c)) {
                  codes.push(c);
                } else {
                  _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c));
                }
              };
              if (typeof code === 'string' && code.indexOf('-') > -1) {
                if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code));
                if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code));
                if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));
              } else if (typeof code === 'string') {
                addCode(this.formatLanguageCode(code));
              }
              fallbackCodes.forEach(function (fc) {
                if (codes.indexOf(fc) < 0) addCode(_this2.formatLanguageCode(fc));
              });
              return codes;
            }
          }]);
          return LanguageUtil;
        }();
        var sets = [{
          lngs: ['ach', 'ak', 'am', 'arn', 'br', 'fil', 'gun', 'ln', 'mfe', 'mg', 'mi', 'oc', 'pt', 'pt-BR', 'tg', 'tl', 'ti', 'tr', 'uz', 'wa'],
          nr: [1, 2],
          fc: 1
        }, {
          lngs: ['af', 'an', 'ast', 'az', 'bg', 'bn', 'ca', 'da', 'de', 'dev', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fi', 'fo', 'fur', 'fy', 'gl', 'gu', 'ha', 'hi', 'hu', 'hy', 'ia', 'it', 'kk', 'kn', 'ku', 'lb', 'mai', 'ml', 'mn', 'mr', 'nah', 'nap', 'nb', 'ne', 'nl', 'nn', 'no', 'nso', 'pa', 'pap', 'pms', 'ps', 'pt-PT', 'rm', 'sco', 'se', 'si', 'so', 'son', 'sq', 'sv', 'sw', 'ta', 'te', 'tk', 'ur', 'yo'],
          nr: [1, 2],
          fc: 2
        }, {
          lngs: ['ay', 'bo', 'cgg', 'fa', 'ht', 'id', 'ja', 'jbo', 'ka', 'km', 'ko', 'ky', 'lo', 'ms', 'sah', 'su', 'th', 'tt', 'ug', 'vi', 'wo', 'zh'],
          nr: [1],
          fc: 3
        }, {
          lngs: ['be', 'bs', 'cnr', 'dz', 'hr', 'ru', 'sr', 'uk'],
          nr: [1, 2, 5],
          fc: 4
        }, {
          lngs: ['ar'],
          nr: [0, 1, 2, 3, 11, 100],
          fc: 5
        }, {
          lngs: ['cs', 'sk'],
          nr: [1, 2, 5],
          fc: 6
        }, {
          lngs: ['csb', 'pl'],
          nr: [1, 2, 5],
          fc: 7
        }, {
          lngs: ['cy'],
          nr: [1, 2, 3, 8],
          fc: 8
        }, {
          lngs: ['fr'],
          nr: [1, 2],
          fc: 9
        }, {
          lngs: ['ga'],
          nr: [1, 2, 3, 7, 11],
          fc: 10
        }, {
          lngs: ['gd'],
          nr: [1, 2, 3, 20],
          fc: 11
        }, {
          lngs: ['is'],
          nr: [1, 2],
          fc: 12
        }, {
          lngs: ['jv'],
          nr: [0, 1],
          fc: 13
        }, {
          lngs: ['kw'],
          nr: [1, 2, 3, 4],
          fc: 14
        }, {
          lngs: ['lt'],
          nr: [1, 2, 10],
          fc: 15
        }, {
          lngs: ['lv'],
          nr: [1, 2, 0],
          fc: 16
        }, {
          lngs: ['mk'],
          nr: [1, 2],
          fc: 17
        }, {
          lngs: ['mnk'],
          nr: [0, 1, 2],
          fc: 18
        }, {
          lngs: ['mt'],
          nr: [1, 2, 11, 20],
          fc: 19
        }, {
          lngs: ['or'],
          nr: [2, 1],
          fc: 2
        }, {
          lngs: ['ro'],
          nr: [1, 2, 20],
          fc: 20
        }, {
          lngs: ['sl'],
          nr: [5, 1, 2, 3],
          fc: 21
        }, {
          lngs: ['he', 'iw'],
          nr: [1, 2, 20, 21],
          fc: 22
        }];
        var _rulesPluralsTypes = {
          1: function _(n) {
            return Number(n > 1);
          },
          2: function _(n) {
            return Number(n != 1);
          },
          3: function _(n) {
            return 0;
          },
          4: function _(n) {
            return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
          },
          5: function _(n) {
            return Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
          },
          6: function _(n) {
            return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);
          },
          7: function _(n) {
            return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
          },
          8: function _(n) {
            return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);
          },
          9: function _(n) {
            return Number(n >= 2);
          },
          10: function _(n) {
            return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
          },
          11: function _(n) {
            return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);
          },
          12: function _(n) {
            return Number(n % 10 != 1 || n % 100 == 11);
          },
          13: function _(n) {
            return Number(n !== 0);
          },
          14: function _(n) {
            return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);
          },
          15: function _(n) {
            return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
          },
          16: function _(n) {
            return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);
          },
          17: function _(n) {
            return Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1);
          },
          18: function _(n) {
            return Number(n == 0 ? 0 : n == 1 ? 1 : 2);
          },
          19: function _(n) {
            return Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);
          },
          20: function _(n) {
            return Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);
          },
          21: function _(n) {
            return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
          },
          22: function _(n) {
            return Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);
          }
        };
        var deprecatedJsonVersions = ['v1', 'v2', 'v3'];
        var suffixesOrder = {
          zero: 0,
          one: 1,
          two: 2,
          few: 3,
          many: 4,
          other: 5
        };
        function createRules() {
          var rules = {};
          sets.forEach(function (set) {
            set.lngs.forEach(function (l) {
              rules[l] = {
                numbers: set.nr,
                plurals: _rulesPluralsTypes[set.fc]
              };
            });
          });
          return rules;
        }
        var PluralResolver = function () {
          function PluralResolver(languageUtils) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            _classCallCheck(this, PluralResolver);
            this.languageUtils = languageUtils;
            this.options = options;
            this.logger = baseLogger.create('pluralResolver');
            if ((!this.options.compatibilityJSON || this.options.compatibilityJSON === 'v4') && (typeof Intl === 'undefined' || !Intl.PluralRules)) {
              this.options.compatibilityJSON = 'v3';
              this.logger.error('Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.');
            }
            this.rules = createRules();
          }
          _createClass(PluralResolver, [{
            key: "addRule",
            value: function addRule(lng, obj) {
              this.rules[lng] = obj;
            }
          }, {
            key: "getRule",
            value: function getRule(code) {
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              if (this.shouldUseIntlApi()) {
                try {
                  return new Intl.PluralRules(code, {
                    type: options.ordinal ? 'ordinal' : 'cardinal'
                  });
                } catch (_unused) {
                  return;
                }
              }
              return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
            }
          }, {
            key: "needsPlural",
            value: function needsPlural(code) {
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              var rule = this.getRule(code, options);
              if (this.shouldUseIntlApi()) {
                return rule && rule.resolvedOptions().pluralCategories.length > 1;
              }
              return rule && rule.numbers.length > 1;
            }
          }, {
            key: "getPluralFormsOfKey",
            value: function getPluralFormsOfKey(code, key) {
              var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
              return this.getSuffixes(code, options).map(function (suffix) {
                return "".concat(key).concat(suffix);
              });
            }
          }, {
            key: "getSuffixes",
            value: function getSuffixes(code) {
              var _this = this;
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              var rule = this.getRule(code, options);
              if (!rule) {
                return [];
              }
              if (this.shouldUseIntlApi()) {
                return rule.resolvedOptions().pluralCategories.sort(function (pluralCategory1, pluralCategory2) {
                  return suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2];
                }).map(function (pluralCategory) {
                  return "".concat(_this.options.prepend).concat(pluralCategory);
                });
              }
              return rule.numbers.map(function (number) {
                return _this.getSuffix(code, number, options);
              });
            }
          }, {
            key: "getSuffix",
            value: function getSuffix(code, count) {
              var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
              var rule = this.getRule(code, options);
              if (rule) {
                if (this.shouldUseIntlApi()) {
                  return "".concat(this.options.prepend).concat(rule.select(count));
                }
                return this.getSuffixRetroCompatible(rule, count);
              }
              this.logger.warn("no plural rule found for: ".concat(code));
              return '';
            }
          }, {
            key: "getSuffixRetroCompatible",
            value: function getSuffixRetroCompatible(rule, count) {
              var _this2 = this;
              var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
              var suffix = rule.numbers[idx];
              if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
                if (suffix === 2) {
                  suffix = 'plural';
                } else if (suffix === 1) {
                  suffix = '';
                }
              }
              var returnSuffix = function returnSuffix() {
                return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
              };
              if (this.options.compatibilityJSON === 'v1') {
                if (suffix === 1) return '';
                if (typeof suffix === 'number') return "_plural_".concat(suffix.toString());
                return returnSuffix();
              } else if (this.options.compatibilityJSON === 'v2') {
                return returnSuffix();
              } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
                return returnSuffix();
              }
              return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
            }
          }, {
            key: "shouldUseIntlApi",
            value: function shouldUseIntlApi() {
              return !deprecatedJsonVersions.includes(this.options.compatibilityJSON);
            }
          }]);
          return PluralResolver;
        }();
        function ownKeys$3(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly) {
              symbols = symbols.filter(function (sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
            }
            keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$3(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            if (i % 2) {
              ownKeys$3(Object(source), true).forEach(function (key) {
                _defineProperty(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              ownKeys$3(Object(source)).forEach(function (key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target;
        }
        var Interpolator = function () {
          function Interpolator() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            _classCallCheck(this, Interpolator);
            this.logger = baseLogger.create('interpolator');
            this.options = options;
            this.format = options.interpolation && options.interpolation.format || function (value) {
              return value;
            };
            this.init(options);
          }
          _createClass(Interpolator, [{
            key: "init",
            value: function init() {
              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              if (!options.interpolation) options.interpolation = {
                escapeValue: true
              };
              var iOpts = options.interpolation;
              this.escape = iOpts.escape !== undefined ? iOpts.escape : escape$2;
              this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;
              this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;
              this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';
              this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';
              this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';
              this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';
              this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';
              this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape('$t(');
              this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(')');
              this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ',';
              this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000;
              this.alwaysFormat = iOpts.alwaysFormat !== undefined ? iOpts.alwaysFormat : false;
              this.resetRegExp();
            }
          }, {
            key: "reset",
            value: function reset() {
              if (this.options) this.init(this.options);
            }
          }, {
            key: "resetRegExp",
            value: function resetRegExp() {
              var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
              this.regexp = new RegExp(regexpStr, 'g');
              var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
              this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');
              var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
              this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');
            }
          }, {
            key: "interpolate",
            value: function interpolate(str, data, lng, options) {
              var _this = this;
              var match;
              var value;
              var replaces;
              var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
              function regexSafe(val) {
                return val.replace(/\$/g, '$$$$');
              }
              var handleFormat = function handleFormat(key) {
                if (key.indexOf(_this.formatSeparator) < 0) {
                  var path = getPathWithDefaults(data, defaultData, key);
                  return _this.alwaysFormat ? _this.format(path, undefined, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options), data), {}, {
                    interpolationkey: key
                  })) : path;
                }
                var p = key.split(_this.formatSeparator);
                var k = p.shift().trim();
                var f = p.join(_this.formatSeparator).trim();
                return _this.format(getPathWithDefaults(data, defaultData, k), f, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options), data), {}, {
                  interpolationkey: k
                }));
              };
              this.resetRegExp();
              var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
              var skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
              var todos = [{
                regex: this.regexpUnescape,
                safeValue: function safeValue(val) {
                  return regexSafe(val);
                }
              }, {
                regex: this.regexp,
                safeValue: function safeValue(val) {
                  return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);
                }
              }];
              todos.forEach(function (todo) {
                replaces = 0;
                while (match = todo.regex.exec(str)) {
                  var matchedVar = match[1].trim();
                  value = handleFormat(matchedVar);
                  if (value === undefined) {
                    if (typeof missingInterpolationHandler === 'function') {
                      var temp = missingInterpolationHandler(str, match, options);
                      value = typeof temp === 'string' ? temp : '';
                    } else if (options && options.hasOwnProperty(matchedVar)) {
                      value = '';
                    } else if (skipOnVariables) {
                      value = match[0];
                      continue;
                    } else {
                      _this.logger.warn("missed to pass in variable ".concat(matchedVar, " for interpolating ").concat(str));
                      value = '';
                    }
                  } else if (typeof value !== 'string' && !_this.useRawValueToEscape) {
                    value = makeString(value);
                  }
                  var safeValue = todo.safeValue(value);
                  str = str.replace(match[0], safeValue);
                  if (skipOnVariables) {
                    todo.regex.lastIndex += value.length;
                    todo.regex.lastIndex -= match[0].length;
                  } else {
                    todo.regex.lastIndex = 0;
                  }
                  replaces++;
                  if (replaces >= _this.maxReplaces) {
                    break;
                  }
                }
              });
              return str;
            }
          }, {
            key: "nest",
            value: function nest(str, fc) {
              var _this2 = this;
              var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
              var match;
              var value;
              var clonedOptions = _objectSpread$3({}, options);
              clonedOptions.applyPostProcessor = false;
              delete clonedOptions.defaultValue;
              function handleHasOptions(key, inheritedOptions) {
                var sep = this.nestingOptionsSeparator;
                if (key.indexOf(sep) < 0) return key;
                var c = key.split(new RegExp("".concat(sep, "[ ]*{")));
                var optionsString = "{".concat(c[1]);
                key = c[0];
                optionsString = this.interpolate(optionsString, clonedOptions);
                var matchedSingleQuotes = optionsString.match(/'/g);
                var matchedDoubleQuotes = optionsString.match(/"/g);
                if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
                  optionsString = optionsString.replace(/'/g, '"');
                }
                try {
                  clonedOptions = JSON.parse(optionsString);
                  if (inheritedOptions) clonedOptions = _objectSpread$3(_objectSpread$3({}, inheritedOptions), clonedOptions);
                } catch (e) {
                  this.logger.warn("failed parsing options string in nesting for key ".concat(key), e);
                  return "".concat(key).concat(sep).concat(optionsString);
                }
                delete clonedOptions.defaultValue;
                return key;
              }
              while (match = this.nestingRegexp.exec(str)) {
                var formatters = [];
                var doReduce = false;
                if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
                  var r = match[1].split(this.formatSeparator).map(function (elem) {
                    return elem.trim();
                  });
                  match[1] = r.shift();
                  formatters = r;
                  doReduce = true;
                }
                value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
                if (value && match[0] === str && typeof value !== 'string') return value;
                if (typeof value !== 'string') value = makeString(value);
                if (!value) {
                  this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str));
                  value = '';
                }
                if (doReduce) {
                  value = formatters.reduce(function (v, f) {
                    return _this2.format(v, f, options.lng, _objectSpread$3(_objectSpread$3({}, options), {}, {
                      interpolationkey: match[1].trim()
                    }));
                  }, value.trim());
                }
                str = str.replace(match[0], value);
                this.regexp.lastIndex = 0;
              }
              return str;
            }
          }]);
          return Interpolator;
        }();
        function ownKeys$4(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly) {
              symbols = symbols.filter(function (sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
            }
            keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$4(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            if (i % 2) {
              ownKeys$4(Object(source), true).forEach(function (key) {
                _defineProperty(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              ownKeys$4(Object(source)).forEach(function (key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target;
        }
        function parseFormatStr(formatStr) {
          var formatName = formatStr.toLowerCase().trim();
          var formatOptions = {};
          if (formatStr.indexOf('(') > -1) {
            var p = formatStr.split('(');
            formatName = p[0].toLowerCase().trim();
            var optStr = p[1].substring(0, p[1].length - 1);
            if (formatName === 'currency' && optStr.indexOf(':') < 0) {
              if (!formatOptions.currency) formatOptions.currency = optStr.trim();
            } else if (formatName === 'relativetime' && optStr.indexOf(':') < 0) {
              if (!formatOptions.range) formatOptions.range = optStr.trim();
            } else {
              var opts = optStr.split(';');
              opts.forEach(function (opt) {
                if (!opt) return;
                var _opt$split = opt.split(':'),
                  _opt$split2 = _toArray(_opt$split),
                  key = _opt$split2[0],
                  rest = _opt$split2.slice(1);
                var val = rest.join(':').trim().replace(/^'+|'+$/g, '');
                if (!formatOptions[key.trim()]) formatOptions[key.trim()] = val;
                if (val === 'false') formatOptions[key.trim()] = false;
                if (val === 'true') formatOptions[key.trim()] = true;
                if (!isNaN(val)) formatOptions[key.trim()] = parseInt(val, 10);
              });
            }
          }
          return {
            formatName: formatName,
            formatOptions: formatOptions
          };
        }
        function createCachedFormatter(fn) {
          var cache = {};
          return function invokeFormatter(val, lng, options) {
            var key = lng + JSON.stringify(options);
            var formatter = cache[key];
            if (!formatter) {
              formatter = fn(lng, options);
              cache[key] = formatter;
            }
            return formatter(val);
          };
        }
        var Formatter = function () {
          function Formatter() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            _classCallCheck(this, Formatter);
            this.logger = baseLogger.create('formatter');
            this.options = options;
            this.formats = {
              number: createCachedFormatter(function (lng, options) {
                var formatter = new Intl.NumberFormat(lng, options);
                return function (val) {
                  return formatter.format(val);
                };
              }),
              currency: createCachedFormatter(function (lng, options) {
                var formatter = new Intl.NumberFormat(lng, _objectSpread$4(_objectSpread$4({}, options), {}, {
                  style: 'currency'
                }));
                return function (val) {
                  return formatter.format(val);
                };
              }),
              datetime: createCachedFormatter(function (lng, options) {
                var formatter = new Intl.DateTimeFormat(lng, _objectSpread$4({}, options));
                return function (val) {
                  return formatter.format(val);
                };
              }),
              relativetime: createCachedFormatter(function (lng, options) {
                var formatter = new Intl.RelativeTimeFormat(lng, _objectSpread$4({}, options));
                return function (val) {
                  return formatter.format(val, options.range || 'day');
                };
              }),
              list: createCachedFormatter(function (lng, options) {
                var formatter = new Intl.ListFormat(lng, _objectSpread$4({}, options));
                return function (val) {
                  return formatter.format(val);
                };
              })
            };
            this.init(options);
          }
          _createClass(Formatter, [{
            key: "init",
            value: function init(services) {
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
                interpolation: {}
              };
              var iOpts = options.interpolation;
              this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';
            }
          }, {
            key: "add",
            value: function add(name, fc) {
              this.formats[name.toLowerCase().trim()] = fc;
            }
          }, {
            key: "addCached",
            value: function addCached(name, fc) {
              this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
            }
          }, {
            key: "format",
            value: function format(value, _format, lng, options) {
              var _this = this;
              var formats = _format.split(this.formatSeparator);
              var result = formats.reduce(function (mem, f) {
                var _parseFormatStr = parseFormatStr(f),
                  formatName = _parseFormatStr.formatName,
                  formatOptions = _parseFormatStr.formatOptions;
                if (_this.formats[formatName]) {
                  var formatted = mem;
                  try {
                    var valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
                    var l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
                    formatted = _this.formats[formatName](mem, l, _objectSpread$4(_objectSpread$4(_objectSpread$4({}, formatOptions), options), valOptions));
                  } catch (error) {
                    _this.logger.warn(error);
                  }
                  return formatted;
                } else {
                  _this.logger.warn("there was no format function for ".concat(formatName));
                }
                return mem;
              }, value);
              return result;
            }
          }]);
          return Formatter;
        }();
        function ownKeys$5(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly) {
              symbols = symbols.filter(function (sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
            }
            keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$5(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            if (i % 2) {
              ownKeys$5(Object(source), true).forEach(function (key) {
                _defineProperty(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              ownKeys$5(Object(source)).forEach(function (key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target;
        }
        function _createSuper$2(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function _isNativeReflectConstruct$2() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        function removePending(q, name) {
          if (q.pending[name] !== undefined) {
            delete q.pending[name];
            q.pendingCount--;
          }
        }
        var Connector = function (_EventEmitter) {
          _inherits(Connector, _EventEmitter);
          var _super = _createSuper$2(Connector);
          function Connector(backend, store, services) {
            var _this;
            var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
            _classCallCheck(this, Connector);
            _this = _super.call(this);
            if (isIE10) {
              EventEmitter.call(_assertThisInitialized(_this));
            }
            _this.backend = backend;
            _this.store = store;
            _this.services = services;
            _this.languageUtils = services.languageUtils;
            _this.options = options;
            _this.logger = baseLogger.create('backendConnector');
            _this.waitingReads = [];
            _this.maxParallelReads = options.maxParallelReads || 10;
            _this.readingCalls = 0;
            _this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
            _this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
            _this.state = {};
            _this.queue = [];
            if (_this.backend && _this.backend.init) {
              _this.backend.init(services, options.backend, options);
            }
            return _this;
          }
          _createClass(Connector, [{
            key: "queueLoad",
            value: function queueLoad(languages, namespaces, options, callback) {
              var _this2 = this;
              var toLoad = {};
              var pending = {};
              var toLoadLanguages = {};
              var toLoadNamespaces = {};
              languages.forEach(function (lng) {
                var hasAllNamespaces = true;
                namespaces.forEach(function (ns) {
                  var name = "".concat(lng, "|").concat(ns);
                  if (!options.reload && _this2.store.hasResourceBundle(lng, ns)) {
                    _this2.state[name] = 2;
                  } else if (_this2.state[name] < 0) ;else if (_this2.state[name] === 1) {
                    if (pending[name] === undefined) pending[name] = true;
                  } else {
                    _this2.state[name] = 1;
                    hasAllNamespaces = false;
                    if (pending[name] === undefined) pending[name] = true;
                    if (toLoad[name] === undefined) toLoad[name] = true;
                    if (toLoadNamespaces[ns] === undefined) toLoadNamespaces[ns] = true;
                  }
                });
                if (!hasAllNamespaces) toLoadLanguages[lng] = true;
              });
              if (Object.keys(toLoad).length || Object.keys(pending).length) {
                this.queue.push({
                  pending: pending,
                  pendingCount: Object.keys(pending).length,
                  loaded: {},
                  errors: [],
                  callback: callback
                });
              }
              return {
                toLoad: Object.keys(toLoad),
                pending: Object.keys(pending),
                toLoadLanguages: Object.keys(toLoadLanguages),
                toLoadNamespaces: Object.keys(toLoadNamespaces)
              };
            }
          }, {
            key: "loaded",
            value: function loaded(name, err, data) {
              var s = name.split('|');
              var lng = s[0];
              var ns = s[1];
              if (err) this.emit('failedLoading', lng, ns, err);
              if (data) {
                this.store.addResourceBundle(lng, ns, data);
              }
              this.state[name] = err ? -1 : 2;
              var loaded = {};
              this.queue.forEach(function (q) {
                pushPath(q.loaded, [lng], ns);
                removePending(q, name);
                if (err) q.errors.push(err);
                if (q.pendingCount === 0 && !q.done) {
                  Object.keys(q.loaded).forEach(function (l) {
                    if (!loaded[l]) loaded[l] = {};
                    var loadedKeys = q.loaded[l];
                    if (loadedKeys.length) {
                      loadedKeys.forEach(function (ns) {
                        if (loaded[l][ns] === undefined) loaded[l][ns] = true;
                      });
                    }
                  });
                  q.done = true;
                  if (q.errors.length) {
                    q.callback(q.errors);
                  } else {
                    q.callback();
                  }
                }
              });
              this.emit('loaded', loaded);
              this.queue = this.queue.filter(function (q) {
                return !q.done;
              });
            }
          }, {
            key: "read",
            value: function read(lng, ns, fcName) {
              var _this3 = this;
              var tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
              var wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.retryTimeout;
              var callback = arguments.length > 5 ? arguments[5] : undefined;
              if (!lng.length) return callback(null, {});
              if (this.readingCalls >= this.maxParallelReads) {
                this.waitingReads.push({
                  lng: lng,
                  ns: ns,
                  fcName: fcName,
                  tried: tried,
                  wait: wait,
                  callback: callback
                });
                return;
              }
              this.readingCalls++;
              return this.backend[fcName](lng, ns, function (err, data) {
                _this3.readingCalls--;
                if (_this3.waitingReads.length > 0) {
                  var next = _this3.waitingReads.shift();
                  _this3.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
                }
                if (err && data && tried < _this3.maxRetries) {
                  setTimeout(function () {
                    _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);
                  }, wait);
                  return;
                }
                callback(err, data);
              });
            }
          }, {
            key: "prepareLoading",
            value: function prepareLoading(languages, namespaces) {
              var _this4 = this;
              var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
              var callback = arguments.length > 3 ? arguments[3] : undefined;
              if (!this.backend) {
                this.logger.warn('No backend was added via i18next.use. Will not load resources.');
                return callback && callback();
              }
              if (typeof languages === 'string') languages = this.languageUtils.toResolveHierarchy(languages);
              if (typeof namespaces === 'string') namespaces = [namespaces];
              var toLoad = this.queueLoad(languages, namespaces, options, callback);
              if (!toLoad.toLoad.length) {
                if (!toLoad.pending.length) callback();
                return null;
              }
              toLoad.toLoad.forEach(function (name) {
                _this4.loadOne(name);
              });
            }
          }, {
            key: "load",
            value: function load(languages, namespaces, callback) {
              this.prepareLoading(languages, namespaces, {}, callback);
            }
          }, {
            key: "reload",
            value: function reload(languages, namespaces, callback) {
              this.prepareLoading(languages, namespaces, {
                reload: true
              }, callback);
            }
          }, {
            key: "loadOne",
            value: function loadOne(name) {
              var _this5 = this;
              var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
              var s = name.split('|');
              var lng = s[0];
              var ns = s[1];
              this.read(lng, ns, 'read', undefined, undefined, function (err, data) {
                if (err) _this5.logger.warn("".concat(prefix, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err);
                if (!err && data) _this5.logger.log("".concat(prefix, "loaded namespace ").concat(ns, " for language ").concat(lng), data);
                _this5.loaded(name, err, data);
              });
            }
          }, {
            key: "saveMissing",
            value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
              var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
              if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
                this.logger.warn("did not save key \"".concat(key, "\" as the namespace \"").concat(namespace, "\" was not yet loaded"), 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
                return;
              }
              if (key === undefined || key === null || key === '') return;
              if (this.backend && this.backend.create) {
                this.backend.create(languages, namespace, key, fallbackValue, null, _objectSpread$5(_objectSpread$5({}, options), {}, {
                  isUpdate: isUpdate
                }));
              }
              if (!languages || !languages[0]) return;
              this.store.addResource(languages[0], namespace, key, fallbackValue);
            }
          }]);
          return Connector;
        }(EventEmitter);
        function get() {
          return {
            debug: false,
            initImmediate: true,
            ns: ['translation'],
            defaultNS: ['translation'],
            fallbackLng: ['dev'],
            fallbackNS: false,
            supportedLngs: false,
            nonExplicitSupportedLngs: false,
            load: 'all',
            preload: false,
            simplifyPluralSuffix: true,
            keySeparator: '.',
            nsSeparator: ':',
            pluralSeparator: '_',
            contextSeparator: '_',
            partialBundledLanguages: false,
            saveMissing: false,
            updateMissing: false,
            saveMissingTo: 'fallback',
            saveMissingPlurals: true,
            missingKeyHandler: false,
            missingInterpolationHandler: false,
            postProcess: false,
            postProcessPassResolved: false,
            returnNull: true,
            returnEmptyString: true,
            returnObjects: false,
            joinArrays: false,
            returnedObjectHandler: false,
            parseMissingKeyHandler: false,
            appendNamespaceToMissingKey: false,
            appendNamespaceToCIMode: false,
            overloadTranslationOptionHandler: function handle(args) {
              var ret = {};
              if (_typeof(args[1]) === 'object') ret = args[1];
              if (typeof args[1] === 'string') ret.defaultValue = args[1];
              if (typeof args[2] === 'string') ret.tDescription = args[2];
              if (_typeof(args[2]) === 'object' || _typeof(args[3]) === 'object') {
                var options = args[3] || args[2];
                Object.keys(options).forEach(function (key) {
                  ret[key] = options[key];
                });
              }
              return ret;
            },
            interpolation: {
              escapeValue: true,
              format: function format(value, _format, lng, options) {
                return value;
              },
              prefix: '{{',
              suffix: '}}',
              formatSeparator: ',',
              unescapePrefix: '-',
              nestingPrefix: '$t(',
              nestingSuffix: ')',
              nestingOptionsSeparator: ',',
              maxReplaces: 1000,
              skipOnVariables: true
            }
          };
        }
        function transformOptions(options) {
          if (typeof options.ns === 'string') options.ns = [options.ns];
          if (typeof options.fallbackLng === 'string') options.fallbackLng = [options.fallbackLng];
          if (typeof options.fallbackNS === 'string') options.fallbackNS = [options.fallbackNS];
          if (options.supportedLngs && options.supportedLngs.indexOf('cimode') < 0) {
            options.supportedLngs = options.supportedLngs.concat(['cimode']);
          }
          return options;
        }
        function ownKeys$6(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly) {
              symbols = symbols.filter(function (sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
            }
            keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$6(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            if (i % 2) {
              ownKeys$6(Object(source), true).forEach(function (key) {
                _defineProperty(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              ownKeys$6(Object(source)).forEach(function (key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target;
        }
        function _createSuper$3(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function _isNativeReflectConstruct$3() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        function noop$3() {}
        function bindMemberFunctions(inst) {
          var mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
          mems.forEach(function (mem) {
            if (typeof inst[mem] === 'function') {
              inst[mem] = inst[mem].bind(inst);
            }
          });
        }
        var I18n = function (_EventEmitter) {
          _inherits(I18n, _EventEmitter);
          var _super = _createSuper$3(I18n);
          function I18n() {
            var _this;
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var callback = arguments.length > 1 ? arguments[1] : undefined;
            _classCallCheck(this, I18n);
            _this = _super.call(this);
            if (isIE10) {
              EventEmitter.call(_assertThisInitialized(_this));
            }
            _this.options = transformOptions(options);
            _this.services = {};
            _this.logger = baseLogger;
            _this.modules = {
              external: []
            };
            bindMemberFunctions(_assertThisInitialized(_this));
            if (callback && !_this.isInitialized && !options.isClone) {
              if (!_this.options.initImmediate) {
                _this.init(options, callback);
                return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
              }
              setTimeout(function () {
                _this.init(options, callback);
              }, 0);
            }
            return _this;
          }
          _createClass(I18n, [{
            key: "init",
            value: function init() {
              var _this2 = this;
              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              var callback = arguments.length > 1 ? arguments[1] : undefined;
              if (typeof options === 'function') {
                callback = options;
                options = {};
              }
              if (!options.defaultNS && options.defaultNS !== false && options.ns) {
                if (typeof options.ns === 'string') {
                  options.defaultNS = options.ns;
                } else if (options.ns.indexOf('translation') < 0) {
                  options.defaultNS = options.ns[0];
                }
              }
              var defOpts = get();
              this.options = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, defOpts), this.options), transformOptions(options));
              if (this.options.compatibilityAPI !== 'v1') {
                this.options.interpolation = _objectSpread$6(_objectSpread$6({}, defOpts.interpolation), this.options.interpolation);
              }
              if (options.keySeparator !== undefined) {
                this.options.userDefinedKeySeparator = options.keySeparator;
              }
              if (options.nsSeparator !== undefined) {
                this.options.userDefinedNsSeparator = options.nsSeparator;
              }
              function createClassOnDemand(ClassOrObject) {
                if (!ClassOrObject) return null;
                if (typeof ClassOrObject === 'function') return new ClassOrObject();
                return ClassOrObject;
              }
              if (!this.options.isClone) {
                if (this.modules.logger) {
                  baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
                } else {
                  baseLogger.init(null, this.options);
                }
                var formatter;
                if (this.modules.formatter) {
                  formatter = this.modules.formatter;
                } else if (typeof Intl !== 'undefined') {
                  formatter = Formatter;
                }
                var lu = new LanguageUtil(this.options);
                this.store = new ResourceStore(this.options.resources, this.options);
                var s = this.services;
                s.logger = baseLogger;
                s.resourceStore = this.store;
                s.languageUtils = lu;
                s.pluralResolver = new PluralResolver(lu, {
                  prepend: this.options.pluralSeparator,
                  compatibilityJSON: this.options.compatibilityJSON,
                  simplifyPluralSuffix: this.options.simplifyPluralSuffix
                });
                if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
                  s.formatter = createClassOnDemand(formatter);
                  s.formatter.init(s, this.options);
                  this.options.interpolation.format = s.formatter.format.bind(s.formatter);
                }
                s.interpolator = new Interpolator(this.options);
                s.utils = {
                  hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
                };
                s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
                s.backendConnector.on('*', function (event) {
                  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                  }
                  _this2.emit.apply(_this2, [event].concat(args));
                });
                if (this.modules.languageDetector) {
                  s.languageDetector = createClassOnDemand(this.modules.languageDetector);
                  s.languageDetector.init(s, this.options.detection, this.options);
                }
                if (this.modules.i18nFormat) {
                  s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
                  if (s.i18nFormat.init) s.i18nFormat.init(this);
                }
                this.translator = new Translator(this.services, this.options);
                this.translator.on('*', function (event) {
                  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                    args[_key2 - 1] = arguments[_key2];
                  }
                  _this2.emit.apply(_this2, [event].concat(args));
                });
                this.modules.external.forEach(function (m) {
                  if (m.init) m.init(_this2);
                });
              }
              this.format = this.options.interpolation.format;
              if (!callback) callback = noop$3;
              if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
                var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
                if (codes.length > 0 && codes[0] !== 'dev') this.options.lng = codes[0];
              }
              if (!this.services.languageDetector && !this.options.lng) {
                this.logger.warn('init: no languageDetector is used and no lng is defined');
              }
              var storeApi = ['getResource', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'];
              storeApi.forEach(function (fcName) {
                _this2[fcName] = function () {
                  var _this2$store;
                  return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
                };
              });
              var storeApiChained = ['addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle'];
              storeApiChained.forEach(function (fcName) {
                _this2[fcName] = function () {
                  var _this2$store2;
                  (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);
                  return _this2;
                };
              });
              var deferred = defer();
              var load = function load() {
                var finish = function finish(err, t) {
                  if (_this2.isInitialized && !_this2.initializedStoreOnce) _this2.logger.warn('init: i18next is already initialized. You should call init just once!');
                  _this2.isInitialized = true;
                  if (!_this2.options.isClone) _this2.logger.log('initialized', _this2.options);
                  _this2.emit('initialized', _this2.options);
                  deferred.resolve(t);
                  callback(err, t);
                };
                if (_this2.languages && _this2.options.compatibilityAPI !== 'v1' && !_this2.isInitialized) return finish(null, _this2.t.bind(_this2));
                _this2.changeLanguage(_this2.options.lng, finish);
              };
              if (this.options.resources || !this.options.initImmediate) {
                load();
              } else {
                setTimeout(load, 0);
              }
              return deferred;
            }
          }, {
            key: "loadResources",
            value: function loadResources(language) {
              var _this3 = this;
              var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop$3;
              var usedCallback = callback;
              var usedLng = typeof language === 'string' ? language : this.language;
              if (typeof language === 'function') usedCallback = language;
              if (!this.options.resources || this.options.partialBundledLanguages) {
                if (usedLng && usedLng.toLowerCase() === 'cimode') return usedCallback();
                var toLoad = [];
                var append = function append(lng) {
                  if (!lng) return;
                  var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);
                  lngs.forEach(function (l) {
                    if (toLoad.indexOf(l) < 0) toLoad.push(l);
                  });
                };
                if (!usedLng) {
                  var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
                  fallbacks.forEach(function (l) {
                    return append(l);
                  });
                } else {
                  append(usedLng);
                }
                if (this.options.preload) {
                  this.options.preload.forEach(function (l) {
                    return append(l);
                  });
                }
                this.services.backendConnector.load(toLoad, this.options.ns, function (e) {
                  if (!e && !_this3.resolvedLanguage && _this3.language) _this3.setResolvedLanguage(_this3.language);
                  usedCallback(e);
                });
              } else {
                usedCallback(null);
              }
            }
          }, {
            key: "reloadResources",
            value: function reloadResources(lngs, ns, callback) {
              var deferred = defer();
              if (!lngs) lngs = this.languages;
              if (!ns) ns = this.options.ns;
              if (!callback) callback = noop$3;
              this.services.backendConnector.reload(lngs, ns, function (err) {
                deferred.resolve();
                callback(err);
              });
              return deferred;
            }
          }, {
            key: "use",
            value: function use(module) {
              if (!module) throw new Error('You are passing an undefined module! Please check the object you are passing to i18next.use()');
              if (!module.type) throw new Error('You are passing a wrong module! Please check the object you are passing to i18next.use()');
              if (module.type === 'backend') {
                this.modules.backend = module;
              }
              if (module.type === 'logger' || module.log && module.warn && module.error) {
                this.modules.logger = module;
              }
              if (module.type === 'languageDetector') {
                this.modules.languageDetector = module;
              }
              if (module.type === 'i18nFormat') {
                this.modules.i18nFormat = module;
              }
              if (module.type === 'postProcessor') {
                postProcessor.addPostProcessor(module);
              }
              if (module.type === 'formatter') {
                this.modules.formatter = module;
              }
              if (module.type === '3rdParty') {
                this.modules.external.push(module);
              }
              return this;
            }
          }, {
            key: "setResolvedLanguage",
            value: function setResolvedLanguage(l) {
              if (!l || !this.languages) return;
              if (['cimode', 'dev'].indexOf(l) > -1) return;
              for (var li = 0; li < this.languages.length; li++) {
                var lngInLngs = this.languages[li];
                if (['cimode', 'dev'].indexOf(lngInLngs) > -1) continue;
                if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
                  this.resolvedLanguage = lngInLngs;
                  break;
                }
              }
            }
          }, {
            key: "changeLanguage",
            value: function changeLanguage(lng, callback) {
              var _this4 = this;
              this.isLanguageChangingTo = lng;
              var deferred = defer();
              this.emit('languageChanging', lng);
              var setLngProps = function setLngProps(l) {
                _this4.language = l;
                _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
                _this4.resolvedLanguage = undefined;
                _this4.setResolvedLanguage(l);
              };
              var done = function done(err, l) {
                if (l) {
                  setLngProps(l);
                  _this4.translator.changeLanguage(l);
                  _this4.isLanguageChangingTo = undefined;
                  _this4.emit('languageChanged', l);
                  _this4.logger.log('languageChanged', l);
                } else {
                  _this4.isLanguageChangingTo = undefined;
                }
                deferred.resolve(function () {
                  return _this4.t.apply(_this4, arguments);
                });
                if (callback) callback(err, function () {
                  return _this4.t.apply(_this4, arguments);
                });
              };
              var setLng = function setLng(lngs) {
                if (!lng && !lngs && _this4.services.languageDetector) lngs = [];
                var l = typeof lngs === 'string' ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);
                if (l) {
                  if (!_this4.language) {
                    setLngProps(l);
                  }
                  if (!_this4.translator.language) _this4.translator.changeLanguage(l);
                  if (_this4.services.languageDetector) _this4.services.languageDetector.cacheUserLanguage(l);
                }
                _this4.loadResources(l, function (err) {
                  done(err, l);
                });
              };
              if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
                setLng(this.services.languageDetector.detect());
              } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
                this.services.languageDetector.detect(setLng);
              } else {
                setLng(lng);
              }
              return deferred;
            }
          }, {
            key: "getFixedT",
            value: function getFixedT(lng, ns, keyPrefix) {
              var _this5 = this;
              var fixedT = function fixedT(key, opts) {
                var options;
                if (_typeof(opts) !== 'object') {
                  for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
                    rest[_key3 - 2] = arguments[_key3];
                  }
                  options = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
                } else {
                  options = _objectSpread$6({}, opts);
                }
                options.lng = options.lng || fixedT.lng;
                options.lngs = options.lngs || fixedT.lngs;
                options.ns = options.ns || fixedT.ns;
                options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
                var keySeparator = _this5.options.keySeparator || '.';
                var resultKey = options.keyPrefix ? "".concat(options.keyPrefix).concat(keySeparator).concat(key) : key;
                return _this5.t(resultKey, options);
              };
              if (typeof lng === 'string') {
                fixedT.lng = lng;
              } else {
                fixedT.lngs = lng;
              }
              fixedT.ns = ns;
              fixedT.keyPrefix = keyPrefix;
              return fixedT;
            }
          }, {
            key: "t",
            value: function t() {
              var _this$translator;
              return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
            }
          }, {
            key: "exists",
            value: function exists() {
              var _this$translator2;
              return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
            }
          }, {
            key: "setDefaultNamespace",
            value: function setDefaultNamespace(ns) {
              this.options.defaultNS = ns;
            }
          }, {
            key: "hasLoadedNamespace",
            value: function hasLoadedNamespace(ns) {
              var _this6 = this;
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              if (!this.isInitialized) {
                this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages);
                return false;
              }
              if (!this.languages || !this.languages.length) {
                this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages);
                return false;
              }
              var lng = this.resolvedLanguage || this.languages[0];
              var fallbackLng = this.options ? this.options.fallbackLng : false;
              var lastLng = this.languages[this.languages.length - 1];
              if (lng.toLowerCase() === 'cimode') return true;
              var loadNotPending = function loadNotPending(l, n) {
                var loadState = _this6.services.backendConnector.state["".concat(l, "|").concat(n)];
                return loadState === -1 || loadState === 2;
              };
              if (options.precheck) {
                var preResult = options.precheck(this, loadNotPending);
                if (preResult !== undefined) return preResult;
              }
              if (this.hasResourceBundle(lng, ns)) return true;
              if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
              if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
              return false;
            }
          }, {
            key: "loadNamespaces",
            value: function loadNamespaces(ns, callback) {
              var _this7 = this;
              var deferred = defer();
              if (!this.options.ns) {
                callback && callback();
                return Promise.resolve();
              }
              if (typeof ns === 'string') ns = [ns];
              ns.forEach(function (n) {
                if (_this7.options.ns.indexOf(n) < 0) _this7.options.ns.push(n);
              });
              this.loadResources(function (err) {
                deferred.resolve();
                if (callback) callback(err);
              });
              return deferred;
            }
          }, {
            key: "loadLanguages",
            value: function loadLanguages(lngs, callback) {
              var deferred = defer();
              if (typeof lngs === 'string') lngs = [lngs];
              var preloaded = this.options.preload || [];
              var newLngs = lngs.filter(function (lng) {
                return preloaded.indexOf(lng) < 0;
              });
              if (!newLngs.length) {
                if (callback) callback();
                return Promise.resolve();
              }
              this.options.preload = preloaded.concat(newLngs);
              this.loadResources(function (err) {
                deferred.resolve();
                if (callback) callback(err);
              });
              return deferred;
            }
          }, {
            key: "dir",
            value: function dir(lng) {
              if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
              if (!lng) return 'rtl';
              var rtlLngs = ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ug', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam', 'ckb'];
              return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf('-arab') > 1 ? 'rtl' : 'ltr';
            }
          }, {
            key: "cloneInstance",
            value: function cloneInstance() {
              var _this8 = this;
              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop$3;
              var mergedOptions = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, this.options), options), {
                isClone: true
              });
              var clone = new I18n(mergedOptions);
              if (options.debug !== undefined || options.prefix !== undefined) {
                clone.logger = clone.logger.clone(options);
              }
              var membersToCopy = ['store', 'services', 'language'];
              membersToCopy.forEach(function (m) {
                clone[m] = _this8[m];
              });
              clone.services = _objectSpread$6({}, this.services);
              clone.services.utils = {
                hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
              };
              clone.translator = new Translator(clone.services, clone.options);
              clone.translator.on('*', function (event) {
                for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
                  args[_key4 - 1] = arguments[_key4];
                }
                clone.emit.apply(clone, [event].concat(args));
              });
              clone.init(mergedOptions, callback);
              clone.translator.options = clone.options;
              clone.translator.backendConnector.services.utils = {
                hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
              };
              return clone;
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              return {
                options: this.options,
                store: this.store,
                language: this.language,
                languages: this.languages,
                resolvedLanguage: this.resolvedLanguage
              };
            }
          }]);
          return I18n;
        }(EventEmitter);
        _defineProperty(I18n, "createInstance", function () {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var callback = arguments.length > 1 ? arguments[1] : undefined;
          return new I18n(options, callback);
        });
        var instance$2 = I18n.createInstance();
        instance$2.createInstance = I18n.createInstance;
        instance$2.createInstance;
        instance$2.init;
        instance$2.loadResources;
        instance$2.reloadResources;
        instance$2.use;
        instance$2.changeLanguage;
        instance$2.getFixedT;
        instance$2.t;
        instance$2.exists;
        instance$2.setDefaultNamespace;
        instance$2.hasLoadedNamespace;
        instance$2.loadNamespaces;
        instance$2.loadLanguages;
        function _objectWithoutPropertiesLoose$1(source, excluded) {
          if (source == null) return {};
          var target = {};
          var sourceKeys = Object.keys(source);
          var key, i;
          for (i = 0; i < sourceKeys.length; i++) {
            key = sourceKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            target[key] = source[key];
          }
          return target;
        }
        var matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
        var htmlEntities = {
          '&amp;': '&',
          '&#38;': '&',
          '&lt;': '<',
          '&#60;': '<',
          '&gt;': '>',
          '&#62;': '>',
          '&apos;': "'",
          '&#39;': "'",
          '&quot;': '"',
          '&#34;': '"',
          '&nbsp;': ' ',
          '&#160;': ' ',
          '&copy;': '',
          '&#169;': '',
          '&reg;': '',
          '&#174;': '',
          '&hellip;': '',
          '&#8230;': '',
          '&#x2F;': '/',
          '&#47;': '/'
        };
        var unescapeHtmlEntity = function unescapeHtmlEntity(m) {
          return htmlEntities[m];
        };
        var unescape$1 = function unescape(text) {
          return text.replace(matchHtmlEntity, unescapeHtmlEntity);
        };
        var defaultOptions = {
          bindI18n: 'languageChanged',
          bindI18nStore: '',
          transEmptyNodeValue: '',
          transSupportBasicHtmlNodes: true,
          transWrapTextNodes: '',
          transKeepBasicHtmlNodesFor: ['br', 'strong', 'i', 'p'],
          useSuspense: true,
          unescape: unescape$1
        };
        var i18nInstance;
        var I18nContext = exports('ay', reactExports.createContext());
        function getDefaults() {
          return defaultOptions;
        }
        var ReportNamespaces = exports('bV', function () {
          function ReportNamespaces() {
            _classCallCheck(this, ReportNamespaces);
            this.usedNamespaces = {};
          }
          _createClass(ReportNamespaces, [{
            key: "addUsedNamespaces",
            value: function addUsedNamespaces(namespaces) {
              var _this = this;
              namespaces.forEach(function (ns) {
                if (!_this.usedNamespaces[ns]) _this.usedNamespaces[ns] = true;
              });
            }
          }, {
            key: "getUsedNamespaces",
            value: function getUsedNamespaces() {
              return Object.keys(this.usedNamespaces);
            }
          }]);
          return ReportNamespaces;
        }());
        function getI18n() {
          return i18nInstance;
        }
        function I18nextProvider(_ref) {
          var i18n = _ref.i18n,
            defaultNS = _ref.defaultNS,
            children = _ref.children;
          var value = reactExports.useMemo(function () {
            return {
              i18n: i18n,
              defaultNS: defaultNS
            };
          }, [i18n, defaultNS]);
          return reactExports.createElement(I18nContext.Provider, {
            value: value
          }, children);
        }
        var reactDom = {
          exports: {}
        };
        var reactDom_production_min = {};
        var scheduler = {
          exports: {}
        };
        var scheduler_production_min = {};

        /**
         * @license React
         * scheduler.production.min.js
         *
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        (function (exports) {
          function f(a, b) {
            var c = a.length;
            a.push(b);
            a: for (; 0 < c;) {
              var d = c - 1 >>> 1,
                e = a[d];
              if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;else break a;
            }
          }
          function h(a) {
            return 0 === a.length ? null : a[0];
          }
          function k(a) {
            if (0 === a.length) return null;
            var b = a[0],
              c = a.pop();
            if (c !== b) {
              a[0] = c;
              a: for (var d = 0, e = a.length, w = e >>> 1; d < w;) {
                var m = 2 * (d + 1) - 1,
                  C = a[m],
                  n = m + 1,
                  x = a[n];
                if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);else if (n < e && 0 > g(x, c)) a[d] = x, a[n] = c, d = n;else break a;
              }
            }
            return b;
          }
          function g(a, b) {
            var c = a.sortIndex - b.sortIndex;
            return 0 !== c ? c : a.id - b.id;
          }
          if ("object" === typeof performance && "function" === typeof performance.now) {
            var l = performance;
            exports.unstable_now = function () {
              return l.now();
            };
          } else {
            var p = Date,
              q = p.now();
            exports.unstable_now = function () {
              return p.now() - q;
            };
          }
          var r = [],
            t = [],
            u = 1,
            v = null,
            y = 3,
            z = !1,
            A = !1,
            B = !1,
            D = "function" === typeof setTimeout ? setTimeout : null,
            E = "function" === typeof clearTimeout ? clearTimeout : null,
            F = "undefined" !== typeof setImmediate ? setImmediate : null;
          "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
          function G(a) {
            for (var b = h(t); null !== b;) {
              if (null === b.callback) k(t);else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r, b);else break;
              b = h(t);
            }
          }
          function H(a) {
            B = !1;
            G(a);
            if (!A) if (null !== h(r)) A = !0, I(J);else {
              var b = h(t);
              null !== b && K(H, b.startTime - a);
            }
          }
          function J(a, b) {
            A = !1;
            B && (B = !1, E(L), L = -1);
            z = !0;
            var c = y;
            try {
              G(b);
              for (v = h(r); null !== v && (!(v.expirationTime > b) || a && !M());) {
                var d = v.callback;
                if ("function" === typeof d) {
                  v.callback = null;
                  y = v.priorityLevel;
                  var e = d(v.expirationTime <= b);
                  b = exports.unstable_now();
                  "function" === typeof e ? v.callback = e : v === h(r) && k(r);
                  G(b);
                } else k(r);
                v = h(r);
              }
              if (null !== v) var w = !0;else {
                var m = h(t);
                null !== m && K(H, m.startTime - b);
                w = !1;
              }
              return w;
            } finally {
              v = null, y = c, z = !1;
            }
          }
          var N = !1,
            O = null,
            L = -1,
            P = 5,
            Q = -1;
          function M() {
            return exports.unstable_now() - Q < P ? !1 : !0;
          }
          function R() {
            if (null !== O) {
              var a = exports.unstable_now();
              Q = a;
              var b = !0;
              try {
                b = O(!0, a);
              } finally {
                b ? S() : (N = !1, O = null);
              }
            } else N = !1;
          }
          var S;
          if ("function" === typeof F) S = function () {
            F(R);
          };else if ("undefined" !== typeof MessageChannel) {
            var T = new MessageChannel(),
              U = T.port2;
            T.port1.onmessage = R;
            S = function () {
              U.postMessage(null);
            };
          } else S = function () {
            D(R, 0);
          };
          function I(a) {
            O = a;
            N || (N = !0, S());
          }
          function K(a, b) {
            L = D(function () {
              a(exports.unstable_now());
            }, b);
          }
          exports.unstable_IdlePriority = 5;
          exports.unstable_ImmediatePriority = 1;
          exports.unstable_LowPriority = 4;
          exports.unstable_NormalPriority = 3;
          exports.unstable_Profiling = null;
          exports.unstable_UserBlockingPriority = 2;
          exports.unstable_cancelCallback = function (a) {
            a.callback = null;
          };
          exports.unstable_continueExecution = function () {
            A || z || (A = !0, I(J));
          };
          exports.unstable_forceFrameRate = function (a) {
            0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1E3 / a) : 5;
          };
          exports.unstable_getCurrentPriorityLevel = function () {
            return y;
          };
          exports.unstable_getFirstCallbackNode = function () {
            return h(r);
          };
          exports.unstable_next = function (a) {
            switch (y) {
              case 1:
              case 2:
              case 3:
                var b = 3;
                break;
              default:
                b = y;
            }
            var c = y;
            y = b;
            try {
              return a();
            } finally {
              y = c;
            }
          };
          exports.unstable_pauseExecution = function () {};
          exports.unstable_requestPaint = function () {};
          exports.unstable_runWithPriority = function (a, b) {
            switch (a) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                a = 3;
            }
            var c = y;
            y = a;
            try {
              return b();
            } finally {
              y = c;
            }
          };
          exports.unstable_scheduleCallback = function (a, b, c) {
            var d = exports.unstable_now();
            "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
            switch (a) {
              case 1:
                var e = -1;
                break;
              case 2:
                e = 250;
                break;
              case 5:
                e = 1073741823;
                break;
              case 4:
                e = 1E4;
                break;
              default:
                e = 5E3;
            }
            e = c + e;
            a = {
              id: u++,
              callback: b,
              priorityLevel: a,
              startTime: c,
              expirationTime: e,
              sortIndex: -1
            };
            c > d ? (a.sortIndex = c, f(t, a), null === h(r) && a === h(t) && (B ? (E(L), L = -1) : B = !0, K(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = !0, I(J)));
            return a;
          };
          exports.unstable_shouldYield = M;
          exports.unstable_wrapCallback = function (a) {
            var b = y;
            return function () {
              var c = y;
              y = b;
              try {
                return a.apply(this, arguments);
              } finally {
                y = c;
              }
            };
          };
        })(scheduler_production_min);
        {
          scheduler.exports = scheduler_production_min;
        }
        var schedulerExports = scheduler.exports;

        /**
         * @license React
         * react-dom.production.min.js
         *
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */
        var aa = reactExports,
          ca = schedulerExports;
        function p$6(a) {
          for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
          return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
        }
        var da = new Set(),
          ea = {};
        function fa(a, b) {
          ha(a, b);
          ha(a + "Capture", b);
        }
        function ha(a, b) {
          ea[a] = b;
          for (a = 0; a < b.length; a++) da.add(b[a]);
        }
        var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement),
          ja = Object.prototype.hasOwnProperty,
          ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
          la = {},
          ma = {};
        function oa(a) {
          if (ja.call(ma, a)) return !0;
          if (ja.call(la, a)) return !1;
          if (ka.test(a)) return ma[a] = !0;
          la[a] = !0;
          return !1;
        }
        function pa(a, b, c, d) {
          if (null !== c && 0 === c.type) return !1;
          switch (typeof b) {
            case "function":
            case "symbol":
              return !0;
            case "boolean":
              if (d) return !1;
              if (null !== c) return !c.acceptsBooleans;
              a = a.toLowerCase().slice(0, 5);
              return "data-" !== a && "aria-" !== a;
            default:
              return !1;
          }
        }
        function qa(a, b, c, d) {
          if (null === b || "undefined" === typeof b || pa(a, b, c, d)) return !0;
          if (d) return !1;
          if (null !== c) switch (c.type) {
            case 3:
              return !b;
            case 4:
              return !1 === b;
            case 5:
              return isNaN(b);
            case 6:
              return isNaN(b) || 1 > b;
          }
          return !1;
        }
        function v$5(a, b, c, d, e, f, g) {
          this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
          this.attributeName = d;
          this.attributeNamespace = e;
          this.mustUseProperty = c;
          this.propertyName = a;
          this.type = b;
          this.sanitizeURL = f;
          this.removeEmptyString = g;
        }
        var z$3 = {};
        "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (a) {
          z$3[a] = new v$5(a, 0, !1, a, null, !1, !1);
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (a) {
          var b = a[0];
          z$3[b] = new v$5(b, 1, !1, a[1], null, !1, !1);
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (a) {
          z$3[a] = new v$5(a, 2, !1, a.toLowerCase(), null, !1, !1);
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (a) {
          z$3[a] = new v$5(a, 2, !1, a, null, !1, !1);
        });
        "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (a) {
          z$3[a] = new v$5(a, 3, !1, a.toLowerCase(), null, !1, !1);
        });
        ["checked", "multiple", "muted", "selected"].forEach(function (a) {
          z$3[a] = new v$5(a, 3, !0, a, null, !1, !1);
        });
        ["capture", "download"].forEach(function (a) {
          z$3[a] = new v$5(a, 4, !1, a, null, !1, !1);
        });
        ["cols", "rows", "size", "span"].forEach(function (a) {
          z$3[a] = new v$5(a, 6, !1, a, null, !1, !1);
        });
        ["rowSpan", "start"].forEach(function (a) {
          z$3[a] = new v$5(a, 5, !1, a.toLowerCase(), null, !1, !1);
        });
        var ra = /[\-:]([a-z])/g;
        function sa(a) {
          return a[1].toUpperCase();
        }
        "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (a) {
          var b = a.replace(ra, sa);
          z$3[b] = new v$5(b, 1, !1, a, null, !1, !1);
        });
        "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (a) {
          var b = a.replace(ra, sa);
          z$3[b] = new v$5(b, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
        });
        ["xml:base", "xml:lang", "xml:space"].forEach(function (a) {
          var b = a.replace(ra, sa);
          z$3[b] = new v$5(b, 1, !1, a, "http://www.w3.org/XML/1998/namespace", !1, !1);
        });
        ["tabIndex", "crossOrigin"].forEach(function (a) {
          z$3[a] = new v$5(a, 1, !1, a.toLowerCase(), null, !1, !1);
        });
        z$3.xlinkHref = new v$5("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
        ["src", "href", "action", "formAction"].forEach(function (a) {
          z$3[a] = new v$5(a, 1, !1, a.toLowerCase(), null, !0, !0);
        });
        function ta(a, b, c, d) {
          var e = z$3.hasOwnProperty(b) ? z$3[b] : null;
          if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d) && (c = null), d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? !1 : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && !0 === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
        }
        var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
          va = Symbol.for("react.element"),
          wa = Symbol.for("react.portal"),
          ya = Symbol.for("react.fragment"),
          za = Symbol.for("react.strict_mode"),
          Aa = Symbol.for("react.profiler"),
          Ba = Symbol.for("react.provider"),
          Ca = Symbol.for("react.context"),
          Da = Symbol.for("react.forward_ref"),
          Ea = Symbol.for("react.suspense"),
          Fa = Symbol.for("react.suspense_list"),
          Ga = Symbol.for("react.memo"),
          Ha = Symbol.for("react.lazy");
        var Ia = Symbol.for("react.offscreen");
        var Ja = Symbol.iterator;
        function Ka(a) {
          if (null === a || "object" !== typeof a) return null;
          a = Ja && a[Ja] || a["@@iterator"];
          return "function" === typeof a ? a : null;
        }
        var A$3 = Object.assign,
          La;
        function Ma(a) {
          if (void 0 === La) try {
            throw Error();
          } catch (c) {
            var b = c.stack.trim().match(/\n( *(at )?)/);
            La = b && b[1] || "";
          }
          return "\n" + La + a;
        }
        var Na = !1;
        function Oa(a, b) {
          if (!a || Na) return "";
          Na = !0;
          var c = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          try {
            if (b) {
              if (b = function () {
                throw Error();
              }, Object.defineProperty(b.prototype, "props", {
                set: function () {
                  throw Error();
                }
              }), "object" === typeof Reflect && Reflect.construct) {
                try {
                  Reflect.construct(b, []);
                } catch (l) {
                  var d = l;
                }
                Reflect.construct(a, [], b);
              } else {
                try {
                  b.call();
                } catch (l) {
                  d = l;
                }
                a.call(b.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (l) {
                d = l;
              }
              a();
            }
          } catch (l) {
            if (l && d && "string" === typeof l.stack) {
              for (var e = l.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h];) h--;
              for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
                if (1 !== g || 1 !== h) {
                  do if (g--, h--, 0 > h || e[g] !== f[h]) {
                    var k = "\n" + e[g].replace(" at new ", " at ");
                    a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
                    return k;
                  } while (1 <= g && 0 <= h);
                }
                break;
              }
            }
          } finally {
            Na = !1, Error.prepareStackTrace = c;
          }
          return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
        }
        function Pa(a) {
          switch (a.tag) {
            case 5:
              return Ma(a.type);
            case 16:
              return Ma("Lazy");
            case 13:
              return Ma("Suspense");
            case 19:
              return Ma("SuspenseList");
            case 0:
            case 2:
            case 15:
              return a = Oa(a.type, !1), a;
            case 11:
              return a = Oa(a.type.render, !1), a;
            case 1:
              return a = Oa(a.type, !0), a;
            default:
              return "";
          }
        }
        function Qa(a) {
          if (null == a) return null;
          if ("function" === typeof a) return a.displayName || a.name || null;
          if ("string" === typeof a) return a;
          switch (a) {
            case ya:
              return "Fragment";
            case wa:
              return "Portal";
            case Aa:
              return "Profiler";
            case za:
              return "StrictMode";
            case Ea:
              return "Suspense";
            case Fa:
              return "SuspenseList";
          }
          if ("object" === typeof a) switch (a.$$typeof) {
            case Ca:
              return (a.displayName || "Context") + ".Consumer";
            case Ba:
              return (a._context.displayName || "Context") + ".Provider";
            case Da:
              var b = a.render;
              a = a.displayName;
              a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
              return a;
            case Ga:
              return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
            case Ha:
              b = a._payload;
              a = a._init;
              try {
                return Qa(a(b));
              } catch (c) {}
          }
          return null;
        }
        function Ra(a) {
          var b = a.type;
          switch (a.tag) {
            case 24:
              return "Cache";
            case 9:
              return (b.displayName || "Context") + ".Consumer";
            case 10:
              return (b._context.displayName || "Context") + ".Provider";
            case 18:
              return "DehydratedFragment";
            case 11:
              return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
            case 7:
              return "Fragment";
            case 5:
              return b;
            case 4:
              return "Portal";
            case 3:
              return "Root";
            case 6:
              return "Text";
            case 16:
              return Qa(b);
            case 8:
              return b === za ? "StrictMode" : "Mode";
            case 22:
              return "Offscreen";
            case 12:
              return "Profiler";
            case 21:
              return "Scope";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 25:
              return "TracingMarker";
            case 1:
            case 0:
            case 17:
            case 2:
            case 14:
            case 15:
              if ("function" === typeof b) return b.displayName || b.name || null;
              if ("string" === typeof b) return b;
          }
          return null;
        }
        function Sa(a) {
          switch (typeof a) {
            case "boolean":
            case "number":
            case "string":
            case "undefined":
              return a;
            case "object":
              return a;
            default:
              return "";
          }
        }
        function Ta(a) {
          var b = a.type;
          return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
        }
        function Ua(a) {
          var b = Ta(a) ? "checked" : "value",
            c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b),
            d = "" + a[b];
          if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
            var e = c.get,
              f = c.set;
            Object.defineProperty(a, b, {
              configurable: !0,
              get: function () {
                return e.call(this);
              },
              set: function (a) {
                d = "" + a;
                f.call(this, a);
              }
            });
            Object.defineProperty(a, b, {
              enumerable: c.enumerable
            });
            return {
              getValue: function () {
                return d;
              },
              setValue: function (a) {
                d = "" + a;
              },
              stopTracking: function () {
                a._valueTracker = null;
                delete a[b];
              }
            };
          }
        }
        function Va(a) {
          a._valueTracker || (a._valueTracker = Ua(a));
        }
        function Wa(a) {
          if (!a) return !1;
          var b = a._valueTracker;
          if (!b) return !0;
          var c = b.getValue();
          var d = "";
          a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
          a = d;
          return a !== c ? (b.setValue(a), !0) : !1;
        }
        function Xa(a) {
          a = a || ("undefined" !== typeof document ? document : void 0);
          if ("undefined" === typeof a) return null;
          try {
            return a.activeElement || a.body;
          } catch (b) {
            return a.body;
          }
        }
        function Ya(a, b) {
          var c = b.checked;
          return A$3({}, b, {
            defaultChecked: void 0,
            defaultValue: void 0,
            value: void 0,
            checked: null != c ? c : a._wrapperState.initialChecked
          });
        }
        function Za(a, b) {
          var c = null == b.defaultValue ? "" : b.defaultValue,
            d = null != b.checked ? b.checked : b.defaultChecked;
          c = Sa(null != b.value ? b.value : c);
          a._wrapperState = {
            initialChecked: d,
            initialValue: c,
            controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value
          };
        }
        function ab(a, b) {
          b = b.checked;
          null != b && ta(a, "checked", b, !1);
        }
        function bb(a, b) {
          ab(a, b);
          var c = Sa(b.value),
            d = b.type;
          if (null != c) {
            if ("number" === d) {
              if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
            } else a.value !== "" + c && (a.value = "" + c);
          } else if ("submit" === d || "reset" === d) {
            a.removeAttribute("value");
            return;
          }
          b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
          null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
        }
        function db(a, b, c) {
          if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
            var d = b.type;
            if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
            b = "" + a._wrapperState.initialValue;
            c || b === a.value || (a.value = b);
            a.defaultValue = b;
          }
          c = a.name;
          "" !== c && (a.name = "");
          a.defaultChecked = !!a._wrapperState.initialChecked;
          "" !== c && (a.name = c);
        }
        function cb(a, b, c) {
          if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
        }
        var eb = Array.isArray;
        function fb(a, b, c, d) {
          a = a.options;
          if (b) {
            b = {};
            for (var e = 0; e < c.length; e++) b["$" + c[e]] = !0;
            for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = !0);
          } else {
            c = "" + Sa(c);
            b = null;
            for (e = 0; e < a.length; e++) {
              if (a[e].value === c) {
                a[e].selected = !0;
                d && (a[e].defaultSelected = !0);
                return;
              }
              null !== b || a[e].disabled || (b = a[e]);
            }
            null !== b && (b.selected = !0);
          }
        }
        function gb(a, b) {
          if (null != b.dangerouslySetInnerHTML) throw Error(p$6(91));
          return A$3({}, b, {
            value: void 0,
            defaultValue: void 0,
            children: "" + a._wrapperState.initialValue
          });
        }
        function hb(a, b) {
          var c = b.value;
          if (null == c) {
            c = b.children;
            b = b.defaultValue;
            if (null != c) {
              if (null != b) throw Error(p$6(92));
              if (eb(c)) {
                if (1 < c.length) throw Error(p$6(93));
                c = c[0];
              }
              b = c;
            }
            null == b && (b = "");
            c = b;
          }
          a._wrapperState = {
            initialValue: Sa(c)
          };
        }
        function ib(a, b) {
          var c = Sa(b.value),
            d = Sa(b.defaultValue);
          null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
          null != d && (a.defaultValue = "" + d);
        }
        function jb(a) {
          var b = a.textContent;
          b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
        }
        function kb(a) {
          switch (a) {
            case "svg":
              return "http://www.w3.org/2000/svg";
            case "math":
              return "http://www.w3.org/1998/Math/MathML";
            default:
              return "http://www.w3.org/1999/xhtml";
          }
        }
        function lb(a, b) {
          return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
        }
        var mb,
          nb = function (a) {
            return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function (b, c, d, e) {
              MSApp.execUnsafeLocalFunction(function () {
                return a(b, c, d, e);
              });
            } : a;
          }(function (a, b) {
            if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;else {
              mb = mb || document.createElement("div");
              mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
              for (b = mb.firstChild; a.firstChild;) a.removeChild(a.firstChild);
              for (; b.firstChild;) a.appendChild(b.firstChild);
            }
          });
        function ob(a, b) {
          if (b) {
            var c = a.firstChild;
            if (c && c === a.lastChild && 3 === c.nodeType) {
              c.nodeValue = b;
              return;
            }
          }
          a.textContent = b;
        }
        var pb = {
            animationIterationCount: !0,
            aspectRatio: !0,
            borderImageOutset: !0,
            borderImageSlice: !0,
            borderImageWidth: !0,
            boxFlex: !0,
            boxFlexGroup: !0,
            boxOrdinalGroup: !0,
            columnCount: !0,
            columns: !0,
            flex: !0,
            flexGrow: !0,
            flexPositive: !0,
            flexShrink: !0,
            flexNegative: !0,
            flexOrder: !0,
            gridArea: !0,
            gridRow: !0,
            gridRowEnd: !0,
            gridRowSpan: !0,
            gridRowStart: !0,
            gridColumn: !0,
            gridColumnEnd: !0,
            gridColumnSpan: !0,
            gridColumnStart: !0,
            fontWeight: !0,
            lineClamp: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            tabSize: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0,
            fillOpacity: !0,
            floodOpacity: !0,
            stopOpacity: !0,
            strokeDasharray: !0,
            strokeDashoffset: !0,
            strokeMiterlimit: !0,
            strokeOpacity: !0,
            strokeWidth: !0
          },
          qb = ["Webkit", "ms", "Moz", "O"];
        Object.keys(pb).forEach(function (a) {
          qb.forEach(function (b) {
            b = b + a.charAt(0).toUpperCase() + a.substring(1);
            pb[b] = pb[a];
          });
        });
        function rb(a, b, c) {
          return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
        }
        function sb(a, b) {
          a = a.style;
          for (var c in b) if (b.hasOwnProperty(c)) {
            var d = 0 === c.indexOf("--"),
              e = rb(c, b[c], d);
            "float" === c && (c = "cssFloat");
            d ? a.setProperty(c, e) : a[c] = e;
          }
        }
        var tb = A$3({
          menuitem: !0
        }, {
          area: !0,
          base: !0,
          br: !0,
          col: !0,
          embed: !0,
          hr: !0,
          img: !0,
          input: !0,
          keygen: !0,
          link: !0,
          meta: !0,
          param: !0,
          source: !0,
          track: !0,
          wbr: !0
        });
        function ub(a, b) {
          if (b) {
            if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p$6(137, a));
            if (null != b.dangerouslySetInnerHTML) {
              if (null != b.children) throw Error(p$6(60));
              if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p$6(61));
            }
            if (null != b.style && "object" !== typeof b.style) throw Error(p$6(62));
          }
        }
        function vb(a, b) {
          if (-1 === a.indexOf("-")) return "string" === typeof b.is;
          switch (a) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return !1;
            default:
              return !0;
          }
        }
        var wb = null;
        function xb(a) {
          a = a.target || a.srcElement || window;
          a.correspondingUseElement && (a = a.correspondingUseElement);
          return 3 === a.nodeType ? a.parentNode : a;
        }
        var yb = null,
          zb = null,
          Ab = null;
        function Bb(a) {
          if (a = Cb(a)) {
            if ("function" !== typeof yb) throw Error(p$6(280));
            var b = a.stateNode;
            b && (b = Db(b), yb(a.stateNode, a.type, b));
          }
        }
        function Eb(a) {
          zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
        }
        function Fb() {
          if (zb) {
            var a = zb,
              b = Ab;
            Ab = zb = null;
            Bb(a);
            if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
          }
        }
        function Gb(a, b) {
          return a(b);
        }
        function Hb() {}
        var Ib = !1;
        function Jb(a, b, c) {
          if (Ib) return a(b, c);
          Ib = !0;
          try {
            return Gb(a, b, c);
          } finally {
            if (Ib = !1, null !== zb || null !== Ab) Hb(), Fb();
          }
        }
        function Kb(a, b) {
          var c = a.stateNode;
          if (null === c) return null;
          var d = Db(c);
          if (null === d) return null;
          c = d[b];
          a: switch (b) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
              a = !d;
              break a;
            default:
              a = !1;
          }
          if (a) return null;
          if (c && "function" !== typeof c) throw Error(p$6(231, b, typeof c));
          return c;
        }
        var Lb = !1;
        if (ia) try {
          var Mb = {};
          Object.defineProperty(Mb, "passive", {
            get: function () {
              Lb = !0;
            }
          });
          window.addEventListener("test", Mb, Mb);
          window.removeEventListener("test", Mb, Mb);
        } catch (a) {
          Lb = !1;
        }
        function Nb(a, b, c, d, e, f, g, h, k) {
          var l = Array.prototype.slice.call(arguments, 3);
          try {
            b.apply(c, l);
          } catch (m) {
            this.onError(m);
          }
        }
        var Ob = !1,
          Pb = null,
          Qb = !1,
          Rb = null,
          Sb = {
            onError: function (a) {
              Ob = !0;
              Pb = a;
            }
          };
        function Tb(a, b, c, d, e, f, g, h, k) {
          Ob = !1;
          Pb = null;
          Nb.apply(Sb, arguments);
        }
        function Ub(a, b, c, d, e, f, g, h, k) {
          Tb.apply(this, arguments);
          if (Ob) {
            if (Ob) {
              var l = Pb;
              Ob = !1;
              Pb = null;
            } else throw Error(p$6(198));
            Qb || (Qb = !0, Rb = l);
          }
        }
        function Vb(a) {
          var b = a,
            c = a;
          if (a.alternate) for (; b.return;) b = b.return;else {
            a = b;
            do b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return; while (a);
          }
          return 3 === b.tag ? c : null;
        }
        function Wb(a) {
          if (13 === a.tag) {
            var b = a.memoizedState;
            null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
            if (null !== b) return b.dehydrated;
          }
          return null;
        }
        function Xb(a) {
          if (Vb(a) !== a) throw Error(p$6(188));
        }
        function Yb(a) {
          var b = a.alternate;
          if (!b) {
            b = Vb(a);
            if (null === b) throw Error(p$6(188));
            return b !== a ? null : a;
          }
          for (var c = a, d = b;;) {
            var e = c.return;
            if (null === e) break;
            var f = e.alternate;
            if (null === f) {
              d = e.return;
              if (null !== d) {
                c = d;
                continue;
              }
              break;
            }
            if (e.child === f.child) {
              for (f = e.child; f;) {
                if (f === c) return Xb(e), a;
                if (f === d) return Xb(e), b;
                f = f.sibling;
              }
              throw Error(p$6(188));
            }
            if (c.return !== d.return) c = e, d = f;else {
              for (var g = !1, h = e.child; h;) {
                if (h === c) {
                  g = !0;
                  c = e;
                  d = f;
                  break;
                }
                if (h === d) {
                  g = !0;
                  d = e;
                  c = f;
                  break;
                }
                h = h.sibling;
              }
              if (!g) {
                for (h = f.child; h;) {
                  if (h === c) {
                    g = !0;
                    c = f;
                    d = e;
                    break;
                  }
                  if (h === d) {
                    g = !0;
                    d = f;
                    c = e;
                    break;
                  }
                  h = h.sibling;
                }
                if (!g) throw Error(p$6(189));
              }
            }
            if (c.alternate !== d) throw Error(p$6(190));
          }
          if (3 !== c.tag) throw Error(p$6(188));
          return c.stateNode.current === c ? a : b;
        }
        function Zb(a) {
          a = Yb(a);
          return null !== a ? $b(a) : null;
        }
        function $b(a) {
          if (5 === a.tag || 6 === a.tag) return a;
          for (a = a.child; null !== a;) {
            var b = $b(a);
            if (null !== b) return b;
            a = a.sibling;
          }
          return null;
        }
        var ac = ca.unstable_scheduleCallback,
          bc = ca.unstable_cancelCallback,
          cc = ca.unstable_shouldYield,
          dc = ca.unstable_requestPaint,
          B$2 = ca.unstable_now,
          ec = ca.unstable_getCurrentPriorityLevel,
          fc = ca.unstable_ImmediatePriority,
          gc = ca.unstable_UserBlockingPriority,
          hc = ca.unstable_NormalPriority,
          ic = ca.unstable_LowPriority,
          jc = ca.unstable_IdlePriority,
          kc = null,
          lc = null;
        function mc(a) {
          if (lc && "function" === typeof lc.onCommitFiberRoot) try {
            lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
          } catch (b) {}
        }
        var oc = Math.clz32 ? Math.clz32 : nc,
          pc = Math.log,
          qc = Math.LN2;
        function nc(a) {
          a >>>= 0;
          return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
        }
        var rc = 64,
          sc = 4194304;
        function tc(a) {
          switch (a & -a) {
            case 1:
              return 1;
            case 2:
              return 2;
            case 4:
              return 4;
            case 8:
              return 8;
            case 16:
              return 16;
            case 32:
              return 32;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return a & 4194240;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              return a & 130023424;
            case 134217728:
              return 134217728;
            case 268435456:
              return 268435456;
            case 536870912:
              return 536870912;
            case 1073741824:
              return 1073741824;
            default:
              return a;
          }
        }
        function uc(a, b) {
          var c = a.pendingLanes;
          if (0 === c) return 0;
          var d = 0,
            e = a.suspendedLanes,
            f = a.pingedLanes,
            g = c & 268435455;
          if (0 !== g) {
            var h = g & ~e;
            0 !== h ? d = tc(h) : (f &= g, 0 !== f && (d = tc(f)));
          } else g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f && (d = tc(f));
          if (0 === d) return 0;
          if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
          0 !== (d & 4) && (d |= c & 16);
          b = a.entangledLanes;
          if (0 !== b) for (a = a.entanglements, b &= d; 0 < b;) c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
          return d;
        }
        function vc(a, b) {
          switch (a) {
            case 1:
            case 2:
            case 4:
              return b + 250;
            case 8:
            case 16:
            case 32:
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return b + 5E3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              return -1;
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
              return -1;
            default:
              return -1;
          }
        }
        function wc(a, b) {
          for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f;) {
            var g = 31 - oc(f),
              h = 1 << g,
              k = e[g];
            if (-1 === k) {
              if (0 === (h & c) || 0 !== (h & d)) e[g] = vc(h, b);
            } else k <= b && (a.expiredLanes |= h);
            f &= ~h;
          }
        }
        function xc(a) {
          a = a.pendingLanes & -1073741825;
          return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
        }
        function yc() {
          var a = rc;
          rc <<= 1;
          0 === (rc & 4194240) && (rc = 64);
          return a;
        }
        function zc(a) {
          for (var b = [], c = 0; 31 > c; c++) b.push(a);
          return b;
        }
        function Ac(a, b, c) {
          a.pendingLanes |= b;
          536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
          a = a.eventTimes;
          b = 31 - oc(b);
          a[b] = c;
        }
        function Bc(a, b) {
          var c = a.pendingLanes & ~b;
          a.pendingLanes = b;
          a.suspendedLanes = 0;
          a.pingedLanes = 0;
          a.expiredLanes &= b;
          a.mutableReadLanes &= b;
          a.entangledLanes &= b;
          b = a.entanglements;
          var d = a.eventTimes;
          for (a = a.expirationTimes; 0 < c;) {
            var e = 31 - oc(c),
              f = 1 << e;
            b[e] = 0;
            d[e] = -1;
            a[e] = -1;
            c &= ~f;
          }
        }
        function Cc(a, b) {
          var c = a.entangledLanes |= b;
          for (a = a.entanglements; c;) {
            var d = 31 - oc(c),
              e = 1 << d;
            e & b | a[d] & b && (a[d] |= b);
            c &= ~e;
          }
        }
        var C$1 = 0;
        function Dc(a) {
          a &= -a;
          return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
        }
        var Ec,
          Fc,
          Gc,
          Hc,
          Ic,
          Jc = !1,
          Kc = [],
          Lc = null,
          Mc = null,
          Nc = null,
          Oc = new Map(),
          Pc = new Map(),
          Qc = [],
          Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
        function Sc(a, b) {
          switch (a) {
            case "focusin":
            case "focusout":
              Lc = null;
              break;
            case "dragenter":
            case "dragleave":
              Mc = null;
              break;
            case "mouseover":
            case "mouseout":
              Nc = null;
              break;
            case "pointerover":
            case "pointerout":
              Oc.delete(b.pointerId);
              break;
            case "gotpointercapture":
            case "lostpointercapture":
              Pc.delete(b.pointerId);
          }
        }
        function Tc(a, b, c, d, e, f) {
          if (null === a || a.nativeEvent !== f) return a = {
            blockedOn: b,
            domEventName: c,
            eventSystemFlags: d,
            nativeEvent: f,
            targetContainers: [e]
          }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
          a.eventSystemFlags |= d;
          b = a.targetContainers;
          null !== e && -1 === b.indexOf(e) && b.push(e);
          return a;
        }
        function Uc(a, b, c, d, e) {
          switch (b) {
            case "focusin":
              return Lc = Tc(Lc, a, b, c, d, e), !0;
            case "dragenter":
              return Mc = Tc(Mc, a, b, c, d, e), !0;
            case "mouseover":
              return Nc = Tc(Nc, a, b, c, d, e), !0;
            case "pointerover":
              var f = e.pointerId;
              Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e));
              return !0;
            case "gotpointercapture":
              return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)), !0;
          }
          return !1;
        }
        function Vc(a) {
          var b = Wc(a.target);
          if (null !== b) {
            var c = Vb(b);
            if (null !== c) if (b = c.tag, 13 === b) {
              if (b = Wb(c), null !== b) {
                a.blockedOn = b;
                Ic(a.priority, function () {
                  Gc(c);
                });
                return;
              }
            } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
              a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
              return;
            }
          }
          a.blockedOn = null;
        }
        function Xc(a) {
          if (null !== a.blockedOn) return !1;
          for (var b = a.targetContainers; 0 < b.length;) {
            var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
            if (null === c) {
              c = a.nativeEvent;
              var d = new c.constructor(c.type, c);
              wb = d;
              c.target.dispatchEvent(d);
              wb = null;
            } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, !1;
            b.shift();
          }
          return !0;
        }
        function Zc(a, b, c) {
          Xc(a) && c.delete(b);
        }
        function $c() {
          Jc = !1;
          null !== Lc && Xc(Lc) && (Lc = null);
          null !== Mc && Xc(Mc) && (Mc = null);
          null !== Nc && Xc(Nc) && (Nc = null);
          Oc.forEach(Zc);
          Pc.forEach(Zc);
        }
        function ad(a, b) {
          a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = !0, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
        }
        function bd(a) {
          function b(b) {
            return ad(b, a);
          }
          if (0 < Kc.length) {
            ad(Kc[0], a);
            for (var c = 1; c < Kc.length; c++) {
              var d = Kc[c];
              d.blockedOn === a && (d.blockedOn = null);
            }
          }
          null !== Lc && ad(Lc, a);
          null !== Mc && ad(Mc, a);
          null !== Nc && ad(Nc, a);
          Oc.forEach(b);
          Pc.forEach(b);
          for (c = 0; c < Qc.length; c++) d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
          for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn);) Vc(c), null === c.blockedOn && Qc.shift();
        }
        var cd = ua.ReactCurrentBatchConfig,
          dd = !0;
        function ed(a, b, c, d) {
          var e = C$1,
            f = cd.transition;
          cd.transition = null;
          try {
            C$1 = 1, fd(a, b, c, d);
          } finally {
            C$1 = e, cd.transition = f;
          }
        }
        function gd(a, b, c, d) {
          var e = C$1,
            f = cd.transition;
          cd.transition = null;
          try {
            C$1 = 4, fd(a, b, c, d);
          } finally {
            C$1 = e, cd.transition = f;
          }
        }
        function fd(a, b, c, d) {
          if (dd) {
            var e = Yc(a, b, c, d);
            if (null === e) hd(a, b, d, id, c), Sc(a, d);else if (Uc(e, a, b, c, d)) d.stopPropagation();else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
              for (; null !== e;) {
                var f = Cb(e);
                null !== f && Ec(f);
                f = Yc(a, b, c, d);
                null === f && hd(a, b, d, id, c);
                if (f === e) break;
                e = f;
              }
              null !== e && d.stopPropagation();
            } else hd(a, b, d, null, c);
          }
        }
        var id = null;
        function Yc(a, b, c, d) {
          id = null;
          a = xb(d);
          a = Wc(a);
          if (null !== a) if (b = Vb(a), null === b) a = null;else if (c = b.tag, 13 === c) {
            a = Wb(b);
            if (null !== a) return a;
            a = null;
          } else if (3 === c) {
            if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
            a = null;
          } else b !== a && (a = null);
          id = a;
          return null;
        }
        function jd(a) {
          switch (a) {
            case "cancel":
            case "click":
            case "close":
            case "contextmenu":
            case "copy":
            case "cut":
            case "auxclick":
            case "dblclick":
            case "dragend":
            case "dragstart":
            case "drop":
            case "focusin":
            case "focusout":
            case "input":
            case "invalid":
            case "keydown":
            case "keypress":
            case "keyup":
            case "mousedown":
            case "mouseup":
            case "paste":
            case "pause":
            case "play":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
            case "ratechange":
            case "reset":
            case "resize":
            case "seeked":
            case "submit":
            case "touchcancel":
            case "touchend":
            case "touchstart":
            case "volumechange":
            case "change":
            case "selectionchange":
            case "textInput":
            case "compositionstart":
            case "compositionend":
            case "compositionupdate":
            case "beforeblur":
            case "afterblur":
            case "beforeinput":
            case "blur":
            case "fullscreenchange":
            case "focus":
            case "hashchange":
            case "popstate":
            case "select":
            case "selectstart":
              return 1;
            case "drag":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "mousemove":
            case "mouseout":
            case "mouseover":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "scroll":
            case "toggle":
            case "touchmove":
            case "wheel":
            case "mouseenter":
            case "mouseleave":
            case "pointerenter":
            case "pointerleave":
              return 4;
            case "message":
              switch (ec()) {
                case fc:
                  return 1;
                case gc:
                  return 4;
                case hc:
                case ic:
                  return 16;
                case jc:
                  return 536870912;
                default:
                  return 16;
              }
            default:
              return 16;
          }
        }
        var kd = null,
          ld = null,
          md = null;
        function nd() {
          if (md) return md;
          var a,
            b = ld,
            c = b.length,
            d,
            e = "value" in kd ? kd.value : kd.textContent,
            f = e.length;
          for (a = 0; a < c && b[a] === e[a]; a++);
          var g = c - a;
          for (d = 1; d <= g && b[c - d] === e[f - d]; d++);
          return md = e.slice(a, 1 < d ? 1 - d : void 0);
        }
        function od(a) {
          var b = a.keyCode;
          "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
          10 === a && (a = 13);
          return 32 <= a || 13 === a ? a : 0;
        }
        function pd() {
          return !0;
        }
        function qd() {
          return !1;
        }
        function rd(a) {
          function b(b, d, e, f, g) {
            this._reactName = b;
            this._targetInst = e;
            this.type = d;
            this.nativeEvent = f;
            this.target = g;
            this.currentTarget = null;
            for (var c in a) a.hasOwnProperty(c) && (b = a[c], this[c] = b ? b(f) : f[c]);
            this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : !1 === f.returnValue) ? pd : qd;
            this.isPropagationStopped = qd;
            return this;
          }
          A$3(b.prototype, {
            preventDefault: function () {
              this.defaultPrevented = !0;
              var a = this.nativeEvent;
              a && (a.preventDefault ? a.preventDefault() : "unknown" !== typeof a.returnValue && (a.returnValue = !1), this.isDefaultPrevented = pd);
            },
            stopPropagation: function () {
              var a = this.nativeEvent;
              a && (a.stopPropagation ? a.stopPropagation() : "unknown" !== typeof a.cancelBubble && (a.cancelBubble = !0), this.isPropagationStopped = pd);
            },
            persist: function () {},
            isPersistent: pd
          });
          return b;
        }
        var sd = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function (a) {
              return a.timeStamp || Date.now();
            },
            defaultPrevented: 0,
            isTrusted: 0
          },
          td = rd(sd),
          ud = A$3({}, sd, {
            view: 0,
            detail: 0
          }),
          vd = rd(ud),
          wd,
          xd,
          yd,
          Ad = A$3({}, ud, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: zd,
            button: 0,
            buttons: 0,
            relatedTarget: function (a) {
              return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
            },
            movementX: function (a) {
              if ("movementX" in a) return a.movementX;
              a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
              return wd;
            },
            movementY: function (a) {
              return "movementY" in a ? a.movementY : xd;
            }
          }),
          Bd = rd(Ad),
          Cd = A$3({}, Ad, {
            dataTransfer: 0
          }),
          Dd = rd(Cd),
          Ed = A$3({}, ud, {
            relatedTarget: 0
          }),
          Fd = rd(Ed),
          Gd = A$3({}, sd, {
            animationName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          }),
          Hd = rd(Gd),
          Id = A$3({}, sd, {
            clipboardData: function (a) {
              return "clipboardData" in a ? a.clipboardData : window.clipboardData;
            }
          }),
          Jd = rd(Id),
          Kd = A$3({}, sd, {
            data: 0
          }),
          Ld = rd(Kd),
          Md = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified"
          },
          Nd = {
            8: "Backspace",
            9: "Tab",
            12: "Clear",
            13: "Enter",
            16: "Shift",
            17: "Control",
            18: "Alt",
            19: "Pause",
            20: "CapsLock",
            27: "Escape",
            32: " ",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "ArrowLeft",
            38: "ArrowUp",
            39: "ArrowRight",
            40: "ArrowDown",
            45: "Insert",
            46: "Delete",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "NumLock",
            145: "ScrollLock",
            224: "Meta"
          },
          Od = {
            Alt: "altKey",
            Control: "ctrlKey",
            Meta: "metaKey",
            Shift: "shiftKey"
          };
        function Pd(a) {
          var b = this.nativeEvent;
          return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : !1;
        }
        function zd() {
          return Pd;
        }
        var Qd = A$3({}, ud, {
            key: function (a) {
              if (a.key) {
                var b = Md[a.key] || a.key;
                if ("Unidentified" !== b) return b;
              }
              return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
            },
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: zd,
            charCode: function (a) {
              return "keypress" === a.type ? od(a) : 0;
            },
            keyCode: function (a) {
              return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
            },
            which: function (a) {
              return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
            }
          }),
          Rd = rd(Qd),
          Sd = A$3({}, Ad, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0
          }),
          Td = rd(Sd),
          Ud = A$3({}, ud, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: zd
          }),
          Vd = rd(Ud),
          Wd = A$3({}, sd, {
            propertyName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          }),
          Xd = rd(Wd),
          Yd = A$3({}, Ad, {
            deltaX: function (a) {
              return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
            },
            deltaY: function (a) {
              return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
            },
            deltaZ: 0,
            deltaMode: 0
          }),
          Zd = rd(Yd),
          $d = [9, 13, 27, 32],
          ae = ia && "CompositionEvent" in window,
          be = null;
        ia && "documentMode" in document && (be = document.documentMode);
        var ce = ia && "TextEvent" in window && !be,
          de = ia && (!ae || be && 8 < be && 11 >= be),
          ee = String.fromCharCode(32),
          fe = !1;
        function ge(a, b) {
          switch (a) {
            case "keyup":
              return -1 !== $d.indexOf(b.keyCode);
            case "keydown":
              return 229 !== b.keyCode;
            case "keypress":
            case "mousedown":
            case "focusout":
              return !0;
            default:
              return !1;
          }
        }
        function he(a) {
          a = a.detail;
          return "object" === typeof a && "data" in a ? a.data : null;
        }
        var ie = !1;
        function je(a, b) {
          switch (a) {
            case "compositionend":
              return he(b);
            case "keypress":
              if (32 !== b.which) return null;
              fe = !0;
              return ee;
            case "textInput":
              return a = b.data, a === ee && fe ? null : a;
            default:
              return null;
          }
        }
        function ke(a, b) {
          if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = !1, a) : null;
          switch (a) {
            case "paste":
              return null;
            case "keypress":
              if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
                if (b.char && 1 < b.char.length) return b.char;
                if (b.which) return String.fromCharCode(b.which);
              }
              return null;
            case "compositionend":
              return de && "ko" !== b.locale ? null : b.data;
            default:
              return null;
          }
        }
        var le = {
          color: !0,
          date: !0,
          datetime: !0,
          "datetime-local": !0,
          email: !0,
          month: !0,
          number: !0,
          password: !0,
          range: !0,
          search: !0,
          tel: !0,
          text: !0,
          time: !0,
          url: !0,
          week: !0
        };
        function me(a) {
          var b = a && a.nodeName && a.nodeName.toLowerCase();
          return "input" === b ? !!le[a.type] : "textarea" === b ? !0 : !1;
        }
        function ne(a, b, c, d) {
          Eb(d);
          b = oe(b, "onChange");
          0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({
            event: c,
            listeners: b
          }));
        }
        var pe = null,
          qe = null;
        function re(a) {
          se(a, 0);
        }
        function te(a) {
          var b = ue(a);
          if (Wa(b)) return a;
        }
        function ve(a, b) {
          if ("change" === a) return b;
        }
        var we = !1;
        if (ia) {
          var xe;
          if (ia) {
            var ye = ("oninput" in document);
            if (!ye) {
              var ze = document.createElement("div");
              ze.setAttribute("oninput", "return;");
              ye = "function" === typeof ze.oninput;
            }
            xe = ye;
          } else xe = !1;
          we = xe && (!document.documentMode || 9 < document.documentMode);
        }
        function Ae() {
          pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
        }
        function Be(a) {
          if ("value" === a.propertyName && te(qe)) {
            var b = [];
            ne(b, qe, a, xb(a));
            Jb(re, b);
          }
        }
        function Ce(a, b, c) {
          "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
        }
        function De(a) {
          if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
        }
        function Ee(a, b) {
          if ("click" === a) return te(b);
        }
        function Fe(a, b) {
          if ("input" === a || "change" === a) return te(b);
        }
        function Ge(a, b) {
          return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
        }
        var He = "function" === typeof Object.is ? Object.is : Ge;
        function Ie(a, b) {
          if (He(a, b)) return !0;
          if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return !1;
          var c = Object.keys(a),
            d = Object.keys(b);
          if (c.length !== d.length) return !1;
          for (d = 0; d < c.length; d++) {
            var e = c[d];
            if (!ja.call(b, e) || !He(a[e], b[e])) return !1;
          }
          return !0;
        }
        function Je(a) {
          for (; a && a.firstChild;) a = a.firstChild;
          return a;
        }
        function Ke(a, b) {
          var c = Je(a);
          a = 0;
          for (var d; c;) {
            if (3 === c.nodeType) {
              d = a + c.textContent.length;
              if (a <= b && d >= b) return {
                node: c,
                offset: b - a
              };
              a = d;
            }
            a: {
              for (; c;) {
                if (c.nextSibling) {
                  c = c.nextSibling;
                  break a;
                }
                c = c.parentNode;
              }
              c = void 0;
            }
            c = Je(c);
          }
        }
        function Le(a, b) {
          return a && b ? a === b ? !0 : a && 3 === a.nodeType ? !1 : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : !1 : !1;
        }
        function Me() {
          for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement;) {
            try {
              var c = "string" === typeof b.contentWindow.location.href;
            } catch (d) {
              c = !1;
            }
            if (c) a = b.contentWindow;else break;
            b = Xa(a.document);
          }
          return b;
        }
        function Ne(a) {
          var b = a && a.nodeName && a.nodeName.toLowerCase();
          return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
        }
        function Oe(a) {
          var b = Me(),
            c = a.focusedElem,
            d = a.selectionRange;
          if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
            if (null !== d && Ne(c)) if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
              a = a.getSelection();
              var e = c.textContent.length,
                f = Math.min(d.start, e);
              d = void 0 === d.end ? f : Math.min(d.end, e);
              !a.extend && f > d && (e = d, d = f, f = e);
              e = Ke(c, f);
              var g = Ke(c, d);
              e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
            }
            b = [];
            for (a = c; a = a.parentNode;) 1 === a.nodeType && b.push({
              element: a,
              left: a.scrollLeft,
              top: a.scrollTop
            });
            "function" === typeof c.focus && c.focus();
            for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
          }
        }
        var Pe = ia && "documentMode" in document && 11 >= document.documentMode,
          Qe = null,
          Re = null,
          Se = null,
          Te = !1;
        function Ue(a, b, c) {
          var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
          Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = {
            start: d.selectionStart,
            end: d.selectionEnd
          } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = {
            anchorNode: d.anchorNode,
            anchorOffset: d.anchorOffset,
            focusNode: d.focusNode,
            focusOffset: d.focusOffset
          }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({
            event: b,
            listeners: d
          }), b.target = Qe)));
        }
        function Ve(a, b) {
          var c = {};
          c[a.toLowerCase()] = b.toLowerCase();
          c["Webkit" + a] = "webkit" + b;
          c["Moz" + a] = "moz" + b;
          return c;
        }
        var We = {
            animationend: Ve("Animation", "AnimationEnd"),
            animationiteration: Ve("Animation", "AnimationIteration"),
            animationstart: Ve("Animation", "AnimationStart"),
            transitionend: Ve("Transition", "TransitionEnd")
          },
          Xe = {},
          Ye = {};
        ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
        function Ze(a) {
          if (Xe[a]) return Xe[a];
          if (!We[a]) return a;
          var b = We[a],
            c;
          for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
          return a;
        }
        var $e = Ze("animationend"),
          af = Ze("animationiteration"),
          bf = Ze("animationstart"),
          cf = Ze("transitionend"),
          df = new Map(),
          ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
        function ff(a, b) {
          df.set(a, b);
          fa(b, [a]);
        }
        for (var gf = 0; gf < ef.length; gf++) {
          var hf = ef[gf],
            jf = hf.toLowerCase(),
            kf = hf[0].toUpperCase() + hf.slice(1);
          ff(jf, "on" + kf);
        }
        ff($e, "onAnimationEnd");
        ff(af, "onAnimationIteration");
        ff(bf, "onAnimationStart");
        ff("dblclick", "onDoubleClick");
        ff("focusin", "onFocus");
        ff("focusout", "onBlur");
        ff(cf, "onTransitionEnd");
        ha("onMouseEnter", ["mouseout", "mouseover"]);
        ha("onMouseLeave", ["mouseout", "mouseover"]);
        ha("onPointerEnter", ["pointerout", "pointerover"]);
        ha("onPointerLeave", ["pointerout", "pointerover"]);
        fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
        fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
        fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
        fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
        fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
        fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
        var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
          mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
        function nf(a, b, c) {
          var d = a.type || "unknown-event";
          a.currentTarget = c;
          Ub(d, b, void 0, a);
          a.currentTarget = null;
        }
        function se(a, b) {
          b = 0 !== (b & 4);
          for (var c = 0; c < a.length; c++) {
            var d = a[c],
              e = d.event;
            d = d.listeners;
            a: {
              var f = void 0;
              if (b) for (var g = d.length - 1; 0 <= g; g--) {
                var h = d[g],
                  k = h.instance,
                  l = h.currentTarget;
                h = h.listener;
                if (k !== f && e.isPropagationStopped()) break a;
                nf(e, h, l);
                f = k;
              } else for (g = 0; g < d.length; g++) {
                h = d[g];
                k = h.instance;
                l = h.currentTarget;
                h = h.listener;
                if (k !== f && e.isPropagationStopped()) break a;
                nf(e, h, l);
                f = k;
              }
            }
          }
          if (Qb) throw a = Rb, Qb = !1, Rb = null, a;
        }
        function D$2(a, b) {
          var c = b[of];
          void 0 === c && (c = b[of] = new Set());
          var d = a + "__bubble";
          c.has(d) || (pf(b, a, 2, !1), c.add(d));
        }
        function qf(a, b, c) {
          var d = 0;
          b && (d |= 4);
          pf(c, a, d, b);
        }
        var rf = "_reactListening" + Math.random().toString(36).slice(2);
        function sf(a) {
          if (!a[rf]) {
            a[rf] = !0;
            da.forEach(function (b) {
              "selectionchange" !== b && (mf.has(b) || qf(b, !1, a), qf(b, !0, a));
            });
            var b = 9 === a.nodeType ? a : a.ownerDocument;
            null === b || b[rf] || (b[rf] = !0, qf("selectionchange", !1, b));
          }
        }
        function pf(a, b, c, d) {
          switch (jd(b)) {
            case 1:
              var e = ed;
              break;
            case 4:
              e = gd;
              break;
            default:
              e = fd;
          }
          c = e.bind(null, b, c, a);
          e = void 0;
          !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = !0);
          d ? void 0 !== e ? a.addEventListener(b, c, {
            capture: !0,
            passive: e
          }) : a.addEventListener(b, c, !0) : void 0 !== e ? a.addEventListener(b, c, {
            passive: e
          }) : a.addEventListener(b, c, !1);
        }
        function hd(a, b, c, d, e) {
          var f = d;
          if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (;;) {
            if (null === d) return;
            var g = d.tag;
            if (3 === g || 4 === g) {
              var h = d.stateNode.containerInfo;
              if (h === e || 8 === h.nodeType && h.parentNode === e) break;
              if (4 === g) for (g = d.return; null !== g;) {
                var k = g.tag;
                if (3 === k || 4 === k) if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
                g = g.return;
              }
              for (; null !== h;) {
                g = Wc(h);
                if (null === g) return;
                k = g.tag;
                if (5 === k || 6 === k) {
                  d = f = g;
                  continue a;
                }
                h = h.parentNode;
              }
            }
            d = d.return;
          }
          Jb(function () {
            var d = f,
              e = xb(c),
              g = [];
            a: {
              var h = df.get(a);
              if (void 0 !== h) {
                var k = td,
                  n = a;
                switch (a) {
                  case "keypress":
                    if (0 === od(c)) break a;
                  case "keydown":
                  case "keyup":
                    k = Rd;
                    break;
                  case "focusin":
                    n = "focus";
                    k = Fd;
                    break;
                  case "focusout":
                    n = "blur";
                    k = Fd;
                    break;
                  case "beforeblur":
                  case "afterblur":
                    k = Fd;
                    break;
                  case "click":
                    if (2 === c.button) break a;
                  case "auxclick":
                  case "dblclick":
                  case "mousedown":
                  case "mousemove":
                  case "mouseup":
                  case "mouseout":
                  case "mouseover":
                  case "contextmenu":
                    k = Bd;
                    break;
                  case "drag":
                  case "dragend":
                  case "dragenter":
                  case "dragexit":
                  case "dragleave":
                  case "dragover":
                  case "dragstart":
                  case "drop":
                    k = Dd;
                    break;
                  case "touchcancel":
                  case "touchend":
                  case "touchmove":
                  case "touchstart":
                    k = Vd;
                    break;
                  case $e:
                  case af:
                  case bf:
                    k = Hd;
                    break;
                  case cf:
                    k = Xd;
                    break;
                  case "scroll":
                    k = vd;
                    break;
                  case "wheel":
                    k = Zd;
                    break;
                  case "copy":
                  case "cut":
                  case "paste":
                    k = Jd;
                    break;
                  case "gotpointercapture":
                  case "lostpointercapture":
                  case "pointercancel":
                  case "pointerdown":
                  case "pointermove":
                  case "pointerout":
                  case "pointerover":
                  case "pointerup":
                    k = Td;
                }
                var t = 0 !== (b & 4),
                  J = !t && "scroll" === a,
                  x = t ? null !== h ? h + "Capture" : null : h;
                t = [];
                for (var w = d, u; null !== w;) {
                  u = w;
                  var F = u.stateNode;
                  5 === u.tag && null !== F && (u = F, null !== x && (F = Kb(w, x), null != F && t.push(tf(w, F, u))));
                  if (J) break;
                  w = w.return;
                }
                0 < t.length && (h = new k(h, n, null, c, e), g.push({
                  event: h,
                  listeners: t
                }));
              }
            }
            if (0 === (b & 7)) {
              a: {
                h = "mouseover" === a || "pointerover" === a;
                k = "mouseout" === a || "pointerout" === a;
                if (h && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf])) break a;
                if (k || h) {
                  h = e.window === e ? e : (h = e.ownerDocument) ? h.defaultView || h.parentWindow : window;
                  if (k) {
                    if (n = c.relatedTarget || c.toElement, k = d, n = n ? Wc(n) : null, null !== n && (J = Vb(n), n !== J || 5 !== n.tag && 6 !== n.tag)) n = null;
                  } else k = null, n = d;
                  if (k !== n) {
                    t = Bd;
                    F = "onMouseLeave";
                    x = "onMouseEnter";
                    w = "mouse";
                    if ("pointerout" === a || "pointerover" === a) t = Td, F = "onPointerLeave", x = "onPointerEnter", w = "pointer";
                    J = null == k ? h : ue(k);
                    u = null == n ? h : ue(n);
                    h = new t(F, w + "leave", k, c, e);
                    h.target = J;
                    h.relatedTarget = u;
                    F = null;
                    Wc(e) === d && (t = new t(x, w + "enter", n, c, e), t.target = u, t.relatedTarget = J, F = t);
                    J = F;
                    if (k && n) b: {
                      t = k;
                      x = n;
                      w = 0;
                      for (u = t; u; u = vf(u)) w++;
                      u = 0;
                      for (F = x; F; F = vf(F)) u++;
                      for (; 0 < w - u;) t = vf(t), w--;
                      for (; 0 < u - w;) x = vf(x), u--;
                      for (; w--;) {
                        if (t === x || null !== x && t === x.alternate) break b;
                        t = vf(t);
                        x = vf(x);
                      }
                      t = null;
                    } else t = null;
                    null !== k && wf(g, h, k, t, !1);
                    null !== n && null !== J && wf(g, J, n, t, !0);
                  }
                }
              }
              a: {
                h = d ? ue(d) : window;
                k = h.nodeName && h.nodeName.toLowerCase();
                if ("select" === k || "input" === k && "file" === h.type) var na = ve;else if (me(h)) {
                  if (we) na = Fe;else {
                    na = De;
                    var xa = Ce;
                  }
                } else (k = h.nodeName) && "input" === k.toLowerCase() && ("checkbox" === h.type || "radio" === h.type) && (na = Ee);
                if (na && (na = na(a, d))) {
                  ne(g, na, c, e);
                  break a;
                }
                xa && xa(a, h, d);
                "focusout" === a && (xa = h._wrapperState) && xa.controlled && "number" === h.type && cb(h, "number", h.value);
              }
              xa = d ? ue(d) : window;
              switch (a) {
                case "focusin":
                  if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d, Se = null;
                  break;
                case "focusout":
                  Se = Re = Qe = null;
                  break;
                case "mousedown":
                  Te = !0;
                  break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                  Te = !1;
                  Ue(g, c, e);
                  break;
                case "selectionchange":
                  if (Pe) break;
                case "keydown":
                case "keyup":
                  Ue(g, c, e);
              }
              var $a;
              if (ae) b: {
                switch (a) {
                  case "compositionstart":
                    var ba = "onCompositionStart";
                    break b;
                  case "compositionend":
                    ba = "onCompositionEnd";
                    break b;
                  case "compositionupdate":
                    ba = "onCompositionUpdate";
                    break b;
                }
                ba = void 0;
              } else ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
              ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e, ld = "value" in kd ? kd.value : kd.textContent, ie = !0)), xa = oe(d, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e), g.push({
                event: ba,
                listeners: xa
              }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
              if ($a = ce ? je(a, c) : ke(a, c)) d = oe(d, "onBeforeInput"), 0 < d.length && (e = new Ld("onBeforeInput", "beforeinput", null, c, e), g.push({
                event: e,
                listeners: d
              }), e.data = $a);
            }
            se(g, b);
          });
        }
        function tf(a, b, c) {
          return {
            instance: a,
            listener: b,
            currentTarget: c
          };
        }
        function oe(a, b) {
          for (var c = b + "Capture", d = []; null !== a;) {
            var e = a,
              f = e.stateNode;
            5 === e.tag && null !== f && (e = f, f = Kb(a, c), null != f && d.unshift(tf(a, f, e)), f = Kb(a, b), null != f && d.push(tf(a, f, e)));
            a = a.return;
          }
          return d;
        }
        function vf(a) {
          if (null === a) return null;
          do a = a.return; while (a && 5 !== a.tag);
          return a ? a : null;
        }
        function wf(a, b, c, d, e) {
          for (var f = b._reactName, g = []; null !== c && c !== d;) {
            var h = c,
              k = h.alternate,
              l = h.stateNode;
            if (null !== k && k === d) break;
            5 === h.tag && null !== l && (h = l, e ? (k = Kb(c, f), null != k && g.unshift(tf(c, k, h))) : e || (k = Kb(c, f), null != k && g.push(tf(c, k, h))));
            c = c.return;
          }
          0 !== g.length && a.push({
            event: b,
            listeners: g
          });
        }
        var xf = /\r\n?/g,
          yf = /\u0000|\uFFFD/g;
        function zf(a) {
          return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
        }
        function Af(a, b, c) {
          b = zf(b);
          if (zf(a) !== b && c) throw Error(p$6(425));
        }
        function Bf() {}
        var Cf = null,
          Df = null;
        function Ef(a, b) {
          return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
        }
        var Ff = "function" === typeof setTimeout ? setTimeout : void 0,
          Gf = "function" === typeof clearTimeout ? clearTimeout : void 0,
          Hf = "function" === typeof Promise ? Promise : void 0,
          Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function (a) {
            return Hf.resolve(null).then(a).catch(If);
          } : Ff;
        function If(a) {
          setTimeout(function () {
            throw a;
          });
        }
        function Kf(a, b) {
          var c = b,
            d = 0;
          do {
            var e = c.nextSibling;
            a.removeChild(c);
            if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
              if (0 === d) {
                a.removeChild(e);
                bd(b);
                return;
              }
              d--;
            } else "$" !== c && "$?" !== c && "$!" !== c || d++;
            c = e;
          } while (c);
          bd(b);
        }
        function Lf(a) {
          for (; null != a; a = a.nextSibling) {
            var b = a.nodeType;
            if (1 === b || 3 === b) break;
            if (8 === b) {
              b = a.data;
              if ("$" === b || "$!" === b || "$?" === b) break;
              if ("/$" === b) return null;
            }
          }
          return a;
        }
        function Mf(a) {
          a = a.previousSibling;
          for (var b = 0; a;) {
            if (8 === a.nodeType) {
              var c = a.data;
              if ("$" === c || "$!" === c || "$?" === c) {
                if (0 === b) return a;
                b--;
              } else "/$" === c && b++;
            }
            a = a.previousSibling;
          }
          return null;
        }
        var Nf = Math.random().toString(36).slice(2),
          Of = "__reactFiber$" + Nf,
          Pf = "__reactProps$" + Nf,
          uf = "__reactContainer$" + Nf,
          of = "__reactEvents$" + Nf,
          Qf = "__reactListeners$" + Nf,
          Rf = "__reactHandles$" + Nf;
        function Wc(a) {
          var b = a[Of];
          if (b) return b;
          for (var c = a.parentNode; c;) {
            if (b = c[uf] || c[Of]) {
              c = b.alternate;
              if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a;) {
                if (c = a[Of]) return c;
                a = Mf(a);
              }
              return b;
            }
            a = c;
            c = a.parentNode;
          }
          return null;
        }
        function Cb(a) {
          a = a[Of] || a[uf];
          return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
        }
        function ue(a) {
          if (5 === a.tag || 6 === a.tag) return a.stateNode;
          throw Error(p$6(33));
        }
        function Db(a) {
          return a[Pf] || null;
        }
        var Sf = [],
          Tf = -1;
        function Uf(a) {
          return {
            current: a
          };
        }
        function E$2(a) {
          0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
        }
        function G$2(a, b) {
          Tf++;
          Sf[Tf] = a.current;
          a.current = b;
        }
        var Vf = {},
          H$2 = Uf(Vf),
          Wf = Uf(!1),
          Xf = Vf;
        function Yf(a, b) {
          var c = a.type.contextTypes;
          if (!c) return Vf;
          var d = a.stateNode;
          if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
          var e = {},
            f;
          for (f in c) e[f] = b[f];
          d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
          return e;
        }
        function Zf(a) {
          a = a.childContextTypes;
          return null !== a && void 0 !== a;
        }
        function $f() {
          E$2(Wf);
          E$2(H$2);
        }
        function ag(a, b, c) {
          if (H$2.current !== Vf) throw Error(p$6(168));
          G$2(H$2, b);
          G$2(Wf, c);
        }
        function bg(a, b, c) {
          var d = a.stateNode;
          b = b.childContextTypes;
          if ("function" !== typeof d.getChildContext) return c;
          d = d.getChildContext();
          for (var e in d) if (!(e in b)) throw Error(p$6(108, Ra(a) || "Unknown", e));
          return A$3({}, c, d);
        }
        function cg(a) {
          a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
          Xf = H$2.current;
          G$2(H$2, a);
          G$2(Wf, Wf.current);
          return !0;
        }
        function dg(a, b, c) {
          var d = a.stateNode;
          if (!d) throw Error(p$6(169));
          c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E$2(Wf), E$2(H$2), G$2(H$2, a)) : E$2(Wf);
          G$2(Wf, c);
        }
        var eg = null,
          fg = !1,
          gg = !1;
        function hg(a) {
          null === eg ? eg = [a] : eg.push(a);
        }
        function ig(a) {
          fg = !0;
          hg(a);
        }
        function jg() {
          if (!gg && null !== eg) {
            gg = !0;
            var a = 0,
              b = C$1;
            try {
              var c = eg;
              for (C$1 = 1; a < c.length; a++) {
                var d = c[a];
                do d = d(!0); while (null !== d);
              }
              eg = null;
              fg = !1;
            } catch (e) {
              throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
            } finally {
              C$1 = b, gg = !1;
            }
          }
          return null;
        }
        var kg = [],
          lg = 0,
          mg = null,
          ng = 0,
          og = [],
          pg = 0,
          qg = null,
          rg = 1,
          sg = "";
        function tg(a, b) {
          kg[lg++] = ng;
          kg[lg++] = mg;
          mg = a;
          ng = b;
        }
        function ug(a, b, c) {
          og[pg++] = rg;
          og[pg++] = sg;
          og[pg++] = qg;
          qg = a;
          var d = rg;
          a = sg;
          var e = 32 - oc(d) - 1;
          d &= ~(1 << e);
          c += 1;
          var f = 32 - oc(b) + e;
          if (30 < f) {
            var g = e - e % 5;
            f = (d & (1 << g) - 1).toString(32);
            d >>= g;
            e -= g;
            rg = 1 << 32 - oc(b) + e | c << e | d;
            sg = f + a;
          } else rg = 1 << f | c << e | d, sg = a;
        }
        function vg(a) {
          null !== a.return && (tg(a, 1), ug(a, 1, 0));
        }
        function wg(a) {
          for (; a === mg;) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
          for (; a === qg;) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
        }
        var xg = null,
          yg = null,
          I$2 = !1,
          zg = null;
        function Ag(a, b) {
          var c = Bg(5, null, null, 0);
          c.elementType = "DELETED";
          c.stateNode = b;
          c.return = a;
          b = a.deletions;
          null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
        }
        function Cg(a, b) {
          switch (a.tag) {
            case 5:
              var c = a.type;
              b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
              return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), !0) : !1;
            case 6:
              return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, !0) : !1;
            case 13:
              return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? {
                id: rg,
                overflow: sg
              } : null, a.memoizedState = {
                dehydrated: b,
                treeContext: c,
                retryLane: 1073741824
              }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, !0) : !1;
            default:
              return !1;
          }
        }
        function Dg(a) {
          return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
        }
        function Eg(a) {
          if (I$2) {
            var b = yg;
            if (b) {
              var c = b;
              if (!Cg(a, b)) {
                if (Dg(a)) throw Error(p$6(418));
                b = Lf(c.nextSibling);
                var d = xg;
                b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I$2 = !1, xg = a);
              }
            } else {
              if (Dg(a)) throw Error(p$6(418));
              a.flags = a.flags & -4097 | 2;
              I$2 = !1;
              xg = a;
            }
          }
        }
        function Fg(a) {
          for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag;) a = a.return;
          xg = a;
        }
        function Gg(a) {
          if (a !== xg) return !1;
          if (!I$2) return Fg(a), I$2 = !0, !1;
          var b;
          (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
          if (b && (b = yg)) {
            if (Dg(a)) throw Hg(), Error(p$6(418));
            for (; b;) Ag(a, b), b = Lf(b.nextSibling);
          }
          Fg(a);
          if (13 === a.tag) {
            a = a.memoizedState;
            a = null !== a ? a.dehydrated : null;
            if (!a) throw Error(p$6(317));
            a: {
              a = a.nextSibling;
              for (b = 0; a;) {
                if (8 === a.nodeType) {
                  var c = a.data;
                  if ("/$" === c) {
                    if (0 === b) {
                      yg = Lf(a.nextSibling);
                      break a;
                    }
                    b--;
                  } else "$" !== c && "$!" !== c && "$?" !== c || b++;
                }
                a = a.nextSibling;
              }
              yg = null;
            }
          } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
          return !0;
        }
        function Hg() {
          for (var a = yg; a;) a = Lf(a.nextSibling);
        }
        function Ig() {
          yg = xg = null;
          I$2 = !1;
        }
        function Jg(a) {
          null === zg ? zg = [a] : zg.push(a);
        }
        var Kg = ua.ReactCurrentBatchConfig;
        function Lg(a, b) {
          if (a && a.defaultProps) {
            b = A$3({}, b);
            a = a.defaultProps;
            for (var c in a) void 0 === b[c] && (b[c] = a[c]);
            return b;
          }
          return b;
        }
        var Mg = Uf(null),
          Ng = null,
          Og = null,
          Pg = null;
        function Qg() {
          Pg = Og = Ng = null;
        }
        function Rg(a) {
          var b = Mg.current;
          E$2(Mg);
          a._currentValue = b;
        }
        function Sg(a, b, c) {
          for (; null !== a;) {
            var d = a.alternate;
            (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
            if (a === c) break;
            a = a.return;
          }
        }
        function Tg(a, b) {
          Ng = a;
          Pg = Og = null;
          a = a.dependencies;
          null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (Ug = !0), a.firstContext = null);
        }
        function Vg(a) {
          var b = a._currentValue;
          if (Pg !== a) if (a = {
            context: a,
            memoizedValue: b,
            next: null
          }, null === Og) {
            if (null === Ng) throw Error(p$6(308));
            Og = a;
            Ng.dependencies = {
              lanes: 0,
              firstContext: a
            };
          } else Og = Og.next = a;
          return b;
        }
        var Wg = null;
        function Xg(a) {
          null === Wg ? Wg = [a] : Wg.push(a);
        }
        function Yg(a, b, c, d) {
          var e = b.interleaved;
          null === e ? (c.next = c, Xg(b)) : (c.next = e.next, e.next = c);
          b.interleaved = c;
          return Zg(a, d);
        }
        function Zg(a, b) {
          a.lanes |= b;
          var c = a.alternate;
          null !== c && (c.lanes |= b);
          c = a;
          for (a = a.return; null !== a;) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
          return 3 === c.tag ? c.stateNode : null;
        }
        var $g = !1;
        function ah(a) {
          a.updateQueue = {
            baseState: a.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
              pending: null,
              interleaved: null,
              lanes: 0
            },
            effects: null
          };
        }
        function bh(a, b) {
          a = a.updateQueue;
          b.updateQueue === a && (b.updateQueue = {
            baseState: a.baseState,
            firstBaseUpdate: a.firstBaseUpdate,
            lastBaseUpdate: a.lastBaseUpdate,
            shared: a.shared,
            effects: a.effects
          });
        }
        function ch(a, b) {
          return {
            eventTime: a,
            lane: b,
            tag: 0,
            payload: null,
            callback: null,
            next: null
          };
        }
        function dh(a, b, c) {
          var d = a.updateQueue;
          if (null === d) return null;
          d = d.shared;
          if (0 !== (K & 2)) {
            var e = d.pending;
            null === e ? b.next = b : (b.next = e.next, e.next = b);
            d.pending = b;
            return Zg(a, c);
          }
          e = d.interleaved;
          null === e ? (b.next = b, Xg(d)) : (b.next = e.next, e.next = b);
          d.interleaved = b;
          return Zg(a, c);
        }
        function eh(a, b, c) {
          b = b.updateQueue;
          if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
            var d = b.lanes;
            d &= a.pendingLanes;
            c |= d;
            b.lanes = c;
            Cc(a, c);
          }
        }
        function fh(a, b) {
          var c = a.updateQueue,
            d = a.alternate;
          if (null !== d && (d = d.updateQueue, c === d)) {
            var e = null,
              f = null;
            c = c.firstBaseUpdate;
            if (null !== c) {
              do {
                var g = {
                  eventTime: c.eventTime,
                  lane: c.lane,
                  tag: c.tag,
                  payload: c.payload,
                  callback: c.callback,
                  next: null
                };
                null === f ? e = f = g : f = f.next = g;
                c = c.next;
              } while (null !== c);
              null === f ? e = f = b : f = f.next = b;
            } else e = f = b;
            c = {
              baseState: d.baseState,
              firstBaseUpdate: e,
              lastBaseUpdate: f,
              shared: d.shared,
              effects: d.effects
            };
            a.updateQueue = c;
            return;
          }
          a = c.lastBaseUpdate;
          null === a ? c.firstBaseUpdate = b : a.next = b;
          c.lastBaseUpdate = b;
        }
        function gh(a, b, c, d) {
          var e = a.updateQueue;
          $g = !1;
          var f = e.firstBaseUpdate,
            g = e.lastBaseUpdate,
            h = e.shared.pending;
          if (null !== h) {
            e.shared.pending = null;
            var k = h,
              l = k.next;
            k.next = null;
            null === g ? f = l : g.next = l;
            g = k;
            var m = a.alternate;
            null !== m && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (null === h ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
          }
          if (null !== f) {
            var q = e.baseState;
            g = 0;
            m = l = k = null;
            h = f;
            do {
              var r = h.lane,
                y = h.eventTime;
              if ((d & r) === r) {
                null !== m && (m = m.next = {
                  eventTime: y,
                  lane: 0,
                  tag: h.tag,
                  payload: h.payload,
                  callback: h.callback,
                  next: null
                });
                a: {
                  var n = a,
                    t = h;
                  r = b;
                  y = c;
                  switch (t.tag) {
                    case 1:
                      n = t.payload;
                      if ("function" === typeof n) {
                        q = n.call(y, q, r);
                        break a;
                      }
                      q = n;
                      break a;
                    case 3:
                      n.flags = n.flags & -65537 | 128;
                    case 0:
                      n = t.payload;
                      r = "function" === typeof n ? n.call(y, q, r) : n;
                      if (null === r || void 0 === r) break a;
                      q = A$3({}, q, r);
                      break a;
                    case 2:
                      $g = !0;
                  }
                }
                null !== h.callback && 0 !== h.lane && (a.flags |= 64, r = e.effects, null === r ? e.effects = [h] : r.push(h));
              } else y = {
                eventTime: y,
                lane: r,
                tag: h.tag,
                payload: h.payload,
                callback: h.callback,
                next: null
              }, null === m ? (l = m = y, k = q) : m = m.next = y, g |= r;
              h = h.next;
              if (null === h) if (h = e.shared.pending, null === h) break;else r = h, h = r.next, r.next = null, e.lastBaseUpdate = r, e.shared.pending = null;
            } while (1);
            null === m && (k = q);
            e.baseState = k;
            e.firstBaseUpdate = l;
            e.lastBaseUpdate = m;
            b = e.shared.interleaved;
            if (null !== b) {
              e = b;
              do g |= e.lane, e = e.next; while (e !== b);
            } else null === f && (e.shared.lanes = 0);
            hh |= g;
            a.lanes = g;
            a.memoizedState = q;
          }
        }
        function ih(a, b, c) {
          a = b.effects;
          b.effects = null;
          if (null !== a) for (b = 0; b < a.length; b++) {
            var d = a[b],
              e = d.callback;
            if (null !== e) {
              d.callback = null;
              d = c;
              if ("function" !== typeof e) throw Error(p$6(191, e));
              e.call(d);
            }
          }
        }
        var jh = new aa.Component().refs;
        function kh(a, b, c, d) {
          b = a.memoizedState;
          c = c(d, b);
          c = null === c || void 0 === c ? b : A$3({}, b, c);
          a.memoizedState = c;
          0 === a.lanes && (a.updateQueue.baseState = c);
        }
        var nh = {
          isMounted: function (a) {
            return (a = a._reactInternals) ? Vb(a) === a : !1;
          },
          enqueueSetState: function (a, b, c) {
            a = a._reactInternals;
            var d = L$1(),
              e = lh(a),
              f = ch(d, e);
            f.payload = b;
            void 0 !== c && null !== c && (f.callback = c);
            b = dh(a, f, e);
            null !== b && (mh(b, a, e, d), eh(b, a, e));
          },
          enqueueReplaceState: function (a, b, c) {
            a = a._reactInternals;
            var d = L$1(),
              e = lh(a),
              f = ch(d, e);
            f.tag = 1;
            f.payload = b;
            void 0 !== c && null !== c && (f.callback = c);
            b = dh(a, f, e);
            null !== b && (mh(b, a, e, d), eh(b, a, e));
          },
          enqueueForceUpdate: function (a, b) {
            a = a._reactInternals;
            var c = L$1(),
              d = lh(a),
              e = ch(c, d);
            e.tag = 2;
            void 0 !== b && null !== b && (e.callback = b);
            b = dh(a, e, d);
            null !== b && (mh(b, a, d, c), eh(b, a, d));
          }
        };
        function oh(a, b, c, d, e, f, g) {
          a = a.stateNode;
          return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f) : !0;
        }
        function ph(a, b, c) {
          var d = !1,
            e = Vf;
          var f = b.contextType;
          "object" === typeof f && null !== f ? f = Vg(f) : (e = Zf(b) ? Xf : H$2.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
          b = new b(c, f);
          a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
          b.updater = nh;
          a.stateNode = b;
          b._reactInternals = a;
          d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
          return b;
        }
        function qh(a, b, c, d) {
          a = b.state;
          "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
          "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
          b.state !== a && nh.enqueueReplaceState(b, b.state, null);
        }
        function rh(a, b, c, d) {
          var e = a.stateNode;
          e.props = c;
          e.state = a.memoizedState;
          e.refs = jh;
          ah(a);
          var f = b.contextType;
          "object" === typeof f && null !== f ? e.context = Vg(f) : (f = Zf(b) ? Xf : H$2.current, e.context = Yf(a, f));
          e.state = a.memoizedState;
          f = b.getDerivedStateFromProps;
          "function" === typeof f && (kh(a, b, f, c), e.state = a.memoizedState);
          "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && nh.enqueueReplaceState(e, e.state, null), gh(a, c, e, d), e.state = a.memoizedState);
          "function" === typeof e.componentDidMount && (a.flags |= 4194308);
        }
        function sh(a, b, c) {
          a = c.ref;
          if (null !== a && "function" !== typeof a && "object" !== typeof a) {
            if (c._owner) {
              c = c._owner;
              if (c) {
                if (1 !== c.tag) throw Error(p$6(309));
                var d = c.stateNode;
              }
              if (!d) throw Error(p$6(147, a));
              var e = d,
                f = "" + a;
              if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
              b = function (a) {
                var b = e.refs;
                b === jh && (b = e.refs = {});
                null === a ? delete b[f] : b[f] = a;
              };
              b._stringRef = f;
              return b;
            }
            if ("string" !== typeof a) throw Error(p$6(284));
            if (!c._owner) throw Error(p$6(290, a));
          }
          return a;
        }
        function th(a, b) {
          a = Object.prototype.toString.call(b);
          throw Error(p$6(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
        }
        function uh(a) {
          var b = a._init;
          return b(a._payload);
        }
        function vh(a) {
          function b(b, c) {
            if (a) {
              var d = b.deletions;
              null === d ? (b.deletions = [c], b.flags |= 16) : d.push(c);
            }
          }
          function c(c, d) {
            if (!a) return null;
            for (; null !== d;) b(c, d), d = d.sibling;
            return null;
          }
          function d(a, b) {
            for (a = new Map(); null !== b;) null !== b.key ? a.set(b.key, b) : a.set(b.index, b), b = b.sibling;
            return a;
          }
          function e(a, b) {
            a = wh(a, b);
            a.index = 0;
            a.sibling = null;
            return a;
          }
          function f(b, c, d) {
            b.index = d;
            if (!a) return b.flags |= 1048576, c;
            d = b.alternate;
            if (null !== d) return d = d.index, d < c ? (b.flags |= 2, c) : d;
            b.flags |= 2;
            return c;
          }
          function g(b) {
            a && null === b.alternate && (b.flags |= 2);
            return b;
          }
          function h(a, b, c, d) {
            if (null === b || 6 !== b.tag) return b = xh(c, a.mode, d), b.return = a, b;
            b = e(b, c);
            b.return = a;
            return b;
          }
          function k(a, b, c, d) {
            var f = c.type;
            if (f === ya) return m(a, b, c.props.children, d, c.key);
            if (null !== b && (b.elementType === f || "object" === typeof f && null !== f && f.$$typeof === Ha && uh(f) === b.type)) return d = e(b, c.props), d.ref = sh(a, b, c), d.return = a, d;
            d = yh(c.type, c.key, c.props, null, a.mode, d);
            d.ref = sh(a, b, c);
            d.return = a;
            return d;
          }
          function l(a, b, c, d) {
            if (null === b || 4 !== b.tag || b.stateNode.containerInfo !== c.containerInfo || b.stateNode.implementation !== c.implementation) return b = zh(c, a.mode, d), b.return = a, b;
            b = e(b, c.children || []);
            b.return = a;
            return b;
          }
          function m(a, b, c, d, f) {
            if (null === b || 7 !== b.tag) return b = Ah(c, a.mode, d, f), b.return = a, b;
            b = e(b, c);
            b.return = a;
            return b;
          }
          function q(a, b, c) {
            if ("string" === typeof b && "" !== b || "number" === typeof b) return b = xh("" + b, a.mode, c), b.return = a, b;
            if ("object" === typeof b && null !== b) {
              switch (b.$$typeof) {
                case va:
                  return c = yh(b.type, b.key, b.props, null, a.mode, c), c.ref = sh(a, null, b), c.return = a, c;
                case wa:
                  return b = zh(b, a.mode, c), b.return = a, b;
                case Ha:
                  var d = b._init;
                  return q(a, d(b._payload), c);
              }
              if (eb(b) || Ka(b)) return b = Ah(b, a.mode, c, null), b.return = a, b;
              th(a, b);
            }
            return null;
          }
          function r(a, b, c, d) {
            var e = null !== b ? b.key : null;
            if ("string" === typeof c && "" !== c || "number" === typeof c) return null !== e ? null : h(a, b, "" + c, d);
            if ("object" === typeof c && null !== c) {
              switch (c.$$typeof) {
                case va:
                  return c.key === e ? k(a, b, c, d) : null;
                case wa:
                  return c.key === e ? l(a, b, c, d) : null;
                case Ha:
                  return e = c._init, r(a, b, e(c._payload), d);
              }
              if (eb(c) || Ka(c)) return null !== e ? null : m(a, b, c, d, null);
              th(a, c);
            }
            return null;
          }
          function y(a, b, c, d, e) {
            if ("string" === typeof d && "" !== d || "number" === typeof d) return a = a.get(c) || null, h(b, a, "" + d, e);
            if ("object" === typeof d && null !== d) {
              switch (d.$$typeof) {
                case va:
                  return a = a.get(null === d.key ? c : d.key) || null, k(b, a, d, e);
                case wa:
                  return a = a.get(null === d.key ? c : d.key) || null, l(b, a, d, e);
                case Ha:
                  var f = d._init;
                  return y(a, b, c, f(d._payload), e);
              }
              if (eb(d) || Ka(d)) return a = a.get(c) || null, m(b, a, d, e, null);
              th(b, d);
            }
            return null;
          }
          function n(e, g, h, k) {
            for (var l = null, m = null, u = g, w = g = 0, x = null; null !== u && w < h.length; w++) {
              u.index > w ? (x = u, u = null) : x = u.sibling;
              var n = r(e, u, h[w], k);
              if (null === n) {
                null === u && (u = x);
                break;
              }
              a && u && null === n.alternate && b(e, u);
              g = f(n, g, w);
              null === m ? l = n : m.sibling = n;
              m = n;
              u = x;
            }
            if (w === h.length) return c(e, u), I$2 && tg(e, w), l;
            if (null === u) {
              for (; w < h.length; w++) u = q(e, h[w], k), null !== u && (g = f(u, g, w), null === m ? l = u : m.sibling = u, m = u);
              I$2 && tg(e, w);
              return l;
            }
            for (u = d(e, u); w < h.length; w++) x = y(u, e, w, h[w], k), null !== x && (a && null !== x.alternate && u.delete(null === x.key ? w : x.key), g = f(x, g, w), null === m ? l = x : m.sibling = x, m = x);
            a && u.forEach(function (a) {
              return b(e, a);
            });
            I$2 && tg(e, w);
            return l;
          }
          function t(e, g, h, k) {
            var l = Ka(h);
            if ("function" !== typeof l) throw Error(p$6(150));
            h = l.call(h);
            if (null == h) throw Error(p$6(151));
            for (var u = l = null, m = g, w = g = 0, x = null, n = h.next(); null !== m && !n.done; w++, n = h.next()) {
              m.index > w ? (x = m, m = null) : x = m.sibling;
              var t = r(e, m, n.value, k);
              if (null === t) {
                null === m && (m = x);
                break;
              }
              a && m && null === t.alternate && b(e, m);
              g = f(t, g, w);
              null === u ? l = t : u.sibling = t;
              u = t;
              m = x;
            }
            if (n.done) return c(e, m), I$2 && tg(e, w), l;
            if (null === m) {
              for (; !n.done; w++, n = h.next()) n = q(e, n.value, k), null !== n && (g = f(n, g, w), null === u ? l = n : u.sibling = n, u = n);
              I$2 && tg(e, w);
              return l;
            }
            for (m = d(e, m); !n.done; w++, n = h.next()) n = y(m, e, w, n.value, k), null !== n && (a && null !== n.alternate && m.delete(null === n.key ? w : n.key), g = f(n, g, w), null === u ? l = n : u.sibling = n, u = n);
            a && m.forEach(function (a) {
              return b(e, a);
            });
            I$2 && tg(e, w);
            return l;
          }
          function J(a, d, f, h) {
            "object" === typeof f && null !== f && f.type === ya && null === f.key && (f = f.props.children);
            if ("object" === typeof f && null !== f) {
              switch (f.$$typeof) {
                case va:
                  a: {
                    for (var k = f.key, l = d; null !== l;) {
                      if (l.key === k) {
                        k = f.type;
                        if (k === ya) {
                          if (7 === l.tag) {
                            c(a, l.sibling);
                            d = e(l, f.props.children);
                            d.return = a;
                            a = d;
                            break a;
                          }
                        } else if (l.elementType === k || "object" === typeof k && null !== k && k.$$typeof === Ha && uh(k) === l.type) {
                          c(a, l.sibling);
                          d = e(l, f.props);
                          d.ref = sh(a, l, f);
                          d.return = a;
                          a = d;
                          break a;
                        }
                        c(a, l);
                        break;
                      } else b(a, l);
                      l = l.sibling;
                    }
                    f.type === ya ? (d = Ah(f.props.children, a.mode, h, f.key), d.return = a, a = d) : (h = yh(f.type, f.key, f.props, null, a.mode, h), h.ref = sh(a, d, f), h.return = a, a = h);
                  }
                  return g(a);
                case wa:
                  a: {
                    for (l = f.key; null !== d;) {
                      if (d.key === l) {
                        if (4 === d.tag && d.stateNode.containerInfo === f.containerInfo && d.stateNode.implementation === f.implementation) {
                          c(a, d.sibling);
                          d = e(d, f.children || []);
                          d.return = a;
                          a = d;
                          break a;
                        } else {
                          c(a, d);
                          break;
                        }
                      } else b(a, d);
                      d = d.sibling;
                    }
                    d = zh(f, a.mode, h);
                    d.return = a;
                    a = d;
                  }
                  return g(a);
                case Ha:
                  return l = f._init, J(a, d, l(f._payload), h);
              }
              if (eb(f)) return n(a, d, f, h);
              if (Ka(f)) return t(a, d, f, h);
              th(a, f);
            }
            return "string" === typeof f && "" !== f || "number" === typeof f ? (f = "" + f, null !== d && 6 === d.tag ? (c(a, d.sibling), d = e(d, f), d.return = a, a = d) : (c(a, d), d = xh(f, a.mode, h), d.return = a, a = d), g(a)) : c(a, d);
          }
          return J;
        }
        var Bh = vh(!0),
          Ch = vh(!1),
          Dh = {},
          Eh = Uf(Dh),
          Fh = Uf(Dh),
          Gh = Uf(Dh);
        function Hh(a) {
          if (a === Dh) throw Error(p$6(174));
          return a;
        }
        function Ih(a, b) {
          G$2(Gh, b);
          G$2(Fh, a);
          G$2(Eh, Dh);
          a = b.nodeType;
          switch (a) {
            case 9:
            case 11:
              b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
              break;
            default:
              a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
          }
          E$2(Eh);
          G$2(Eh, b);
        }
        function Jh() {
          E$2(Eh);
          E$2(Fh);
          E$2(Gh);
        }
        function Kh(a) {
          Hh(Gh.current);
          var b = Hh(Eh.current);
          var c = lb(b, a.type);
          b !== c && (G$2(Fh, a), G$2(Eh, c));
        }
        function Lh(a) {
          Fh.current === a && (E$2(Eh), E$2(Fh));
        }
        var M$1 = Uf(0);
        function Mh(a) {
          for (var b = a; null !== b;) {
            if (13 === b.tag) {
              var c = b.memoizedState;
              if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
            } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
              if (0 !== (b.flags & 128)) return b;
            } else if (null !== b.child) {
              b.child.return = b;
              b = b.child;
              continue;
            }
            if (b === a) break;
            for (; null === b.sibling;) {
              if (null === b.return || b.return === a) return null;
              b = b.return;
            }
            b.sibling.return = b.return;
            b = b.sibling;
          }
          return null;
        }
        var Nh = [];
        function Oh() {
          for (var a = 0; a < Nh.length; a++) Nh[a]._workInProgressVersionPrimary = null;
          Nh.length = 0;
        }
        var Ph = ua.ReactCurrentDispatcher,
          Qh = ua.ReactCurrentBatchConfig,
          Rh = 0,
          N$1 = null,
          O$1 = null,
          P$1 = null,
          Sh = !1,
          Th = !1,
          Uh = 0,
          Vh = 0;
        function Q$1() {
          throw Error(p$6(321));
        }
        function Wh(a, b) {
          if (null === b) return !1;
          for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return !1;
          return !0;
        }
        function Xh(a, b, c, d, e, f) {
          Rh = f;
          N$1 = b;
          b.memoizedState = null;
          b.updateQueue = null;
          b.lanes = 0;
          Ph.current = null === a || null === a.memoizedState ? Yh : Zh;
          a = c(d, e);
          if (Th) {
            f = 0;
            do {
              Th = !1;
              Uh = 0;
              if (25 <= f) throw Error(p$6(301));
              f += 1;
              P$1 = O$1 = null;
              b.updateQueue = null;
              Ph.current = $h;
              a = c(d, e);
            } while (Th);
          }
          Ph.current = ai;
          b = null !== O$1 && null !== O$1.next;
          Rh = 0;
          P$1 = O$1 = N$1 = null;
          Sh = !1;
          if (b) throw Error(p$6(300));
          return a;
        }
        function bi() {
          var a = 0 !== Uh;
          Uh = 0;
          return a;
        }
        function ci() {
          var a = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
          };
          null === P$1 ? N$1.memoizedState = P$1 = a : P$1 = P$1.next = a;
          return P$1;
        }
        function di() {
          if (null === O$1) {
            var a = N$1.alternate;
            a = null !== a ? a.memoizedState : null;
          } else a = O$1.next;
          var b = null === P$1 ? N$1.memoizedState : P$1.next;
          if (null !== b) P$1 = b, O$1 = a;else {
            if (null === a) throw Error(p$6(310));
            O$1 = a;
            a = {
              memoizedState: O$1.memoizedState,
              baseState: O$1.baseState,
              baseQueue: O$1.baseQueue,
              queue: O$1.queue,
              next: null
            };
            null === P$1 ? N$1.memoizedState = P$1 = a : P$1 = P$1.next = a;
          }
          return P$1;
        }
        function ei(a, b) {
          return "function" === typeof b ? b(a) : b;
        }
        function fi(a) {
          var b = di(),
            c = b.queue;
          if (null === c) throw Error(p$6(311));
          c.lastRenderedReducer = a;
          var d = O$1,
            e = d.baseQueue,
            f = c.pending;
          if (null !== f) {
            if (null !== e) {
              var g = e.next;
              e.next = f.next;
              f.next = g;
            }
            d.baseQueue = e = f;
            c.pending = null;
          }
          if (null !== e) {
            f = e.next;
            d = d.baseState;
            var h = g = null,
              k = null,
              l = f;
            do {
              var m = l.lane;
              if ((Rh & m) === m) null !== k && (k = k.next = {
                lane: 0,
                action: l.action,
                hasEagerState: l.hasEagerState,
                eagerState: l.eagerState,
                next: null
              }), d = l.hasEagerState ? l.eagerState : a(d, l.action);else {
                var q = {
                  lane: m,
                  action: l.action,
                  hasEagerState: l.hasEagerState,
                  eagerState: l.eagerState,
                  next: null
                };
                null === k ? (h = k = q, g = d) : k = k.next = q;
                N$1.lanes |= m;
                hh |= m;
              }
              l = l.next;
            } while (null !== l && l !== f);
            null === k ? g = d : k.next = h;
            He(d, b.memoizedState) || (Ug = !0);
            b.memoizedState = d;
            b.baseState = g;
            b.baseQueue = k;
            c.lastRenderedState = d;
          }
          a = c.interleaved;
          if (null !== a) {
            e = a;
            do f = e.lane, N$1.lanes |= f, hh |= f, e = e.next; while (e !== a);
          } else null === e && (c.lanes = 0);
          return [b.memoizedState, c.dispatch];
        }
        function gi(a) {
          var b = di(),
            c = b.queue;
          if (null === c) throw Error(p$6(311));
          c.lastRenderedReducer = a;
          var d = c.dispatch,
            e = c.pending,
            f = b.memoizedState;
          if (null !== e) {
            c.pending = null;
            var g = e = e.next;
            do f = a(f, g.action), g = g.next; while (g !== e);
            He(f, b.memoizedState) || (Ug = !0);
            b.memoizedState = f;
            null === b.baseQueue && (b.baseState = f);
            c.lastRenderedState = f;
          }
          return [f, d];
        }
        function hi() {}
        function ii(a, b) {
          var c = N$1,
            d = di(),
            e = b(),
            f = !He(d.memoizedState, e);
          f && (d.memoizedState = e, Ug = !0);
          d = d.queue;
          ji(ki.bind(null, c, d, a), [a]);
          if (d.getSnapshot !== b || f || null !== P$1 && P$1.memoizedState.tag & 1) {
            c.flags |= 2048;
            li(9, mi.bind(null, c, d, e, b), void 0, null);
            if (null === R$1) throw Error(p$6(349));
            0 !== (Rh & 30) || ni(c, b, e);
          }
          return e;
        }
        function ni(a, b, c) {
          a.flags |= 16384;
          a = {
            getSnapshot: b,
            value: c
          };
          b = N$1.updateQueue;
          null === b ? (b = {
            lastEffect: null,
            stores: null
          }, N$1.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
        }
        function mi(a, b, c, d) {
          b.value = c;
          b.getSnapshot = d;
          oi(b) && pi(a);
        }
        function ki(a, b, c) {
          return c(function () {
            oi(b) && pi(a);
          });
        }
        function oi(a) {
          var b = a.getSnapshot;
          a = a.value;
          try {
            var c = b();
            return !He(a, c);
          } catch (d) {
            return !0;
          }
        }
        function pi(a) {
          var b = Zg(a, 1);
          null !== b && mh(b, a, 1, -1);
        }
        function qi(a) {
          var b = ci();
          "function" === typeof a && (a = a());
          b.memoizedState = b.baseState = a;
          a = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: ei,
            lastRenderedState: a
          };
          b.queue = a;
          a = a.dispatch = ri.bind(null, N$1, a);
          return [b.memoizedState, a];
        }
        function li(a, b, c, d) {
          a = {
            tag: a,
            create: b,
            destroy: c,
            deps: d,
            next: null
          };
          b = N$1.updateQueue;
          null === b ? (b = {
            lastEffect: null,
            stores: null
          }, N$1.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
          return a;
        }
        function si() {
          return di().memoizedState;
        }
        function ti(a, b, c, d) {
          var e = ci();
          N$1.flags |= a;
          e.memoizedState = li(1 | b, c, void 0, void 0 === d ? null : d);
        }
        function ui(a, b, c, d) {
          var e = di();
          d = void 0 === d ? null : d;
          var f = void 0;
          if (null !== O$1) {
            var g = O$1.memoizedState;
            f = g.destroy;
            if (null !== d && Wh(d, g.deps)) {
              e.memoizedState = li(b, c, f, d);
              return;
            }
          }
          N$1.flags |= a;
          e.memoizedState = li(1 | b, c, f, d);
        }
        function vi(a, b) {
          return ti(8390656, 8, a, b);
        }
        function ji(a, b) {
          return ui(2048, 8, a, b);
        }
        function wi(a, b) {
          return ui(4, 2, a, b);
        }
        function xi(a, b) {
          return ui(4, 4, a, b);
        }
        function yi(a, b) {
          if ("function" === typeof b) return a = a(), b(a), function () {
            b(null);
          };
          if (null !== b && void 0 !== b) return a = a(), b.current = a, function () {
            b.current = null;
          };
        }
        function zi(a, b, c) {
          c = null !== c && void 0 !== c ? c.concat([a]) : null;
          return ui(4, 4, yi.bind(null, b, a), c);
        }
        function Ai() {}
        function Bi(a, b) {
          var c = di();
          b = void 0 === b ? null : b;
          var d = c.memoizedState;
          if (null !== d && null !== b && Wh(b, d[1])) return d[0];
          c.memoizedState = [a, b];
          return a;
        }
        function Ci(a, b) {
          var c = di();
          b = void 0 === b ? null : b;
          var d = c.memoizedState;
          if (null !== d && null !== b && Wh(b, d[1])) return d[0];
          a = a();
          c.memoizedState = [a, b];
          return a;
        }
        function Di(a, b, c) {
          if (0 === (Rh & 21)) return a.baseState && (a.baseState = !1, Ug = !0), a.memoizedState = c;
          He(c, b) || (c = yc(), N$1.lanes |= c, hh |= c, a.baseState = !0);
          return b;
        }
        function Ei(a, b) {
          var c = C$1;
          C$1 = 0 !== c && 4 > c ? c : 4;
          a(!0);
          var d = Qh.transition;
          Qh.transition = {};
          try {
            a(!1), b();
          } finally {
            C$1 = c, Qh.transition = d;
          }
        }
        function Fi() {
          return di().memoizedState;
        }
        function Gi(a, b, c) {
          var d = lh(a);
          c = {
            lane: d,
            action: c,
            hasEagerState: !1,
            eagerState: null,
            next: null
          };
          if (Hi(a)) Ii(b, c);else if (c = Yg(a, b, c, d), null !== c) {
            var e = L$1();
            mh(c, a, d, e);
            Ji(c, b, d);
          }
        }
        function ri(a, b, c) {
          var d = lh(a),
            e = {
              lane: d,
              action: c,
              hasEagerState: !1,
              eagerState: null,
              next: null
            };
          if (Hi(a)) Ii(b, e);else {
            var f = a.alternate;
            if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
              var g = b.lastRenderedState,
                h = f(g, c);
              e.hasEagerState = !0;
              e.eagerState = h;
              if (He(h, g)) {
                var k = b.interleaved;
                null === k ? (e.next = e, Xg(b)) : (e.next = k.next, k.next = e);
                b.interleaved = e;
                return;
              }
            } catch (l) {} finally {}
            c = Yg(a, b, e, d);
            null !== c && (e = L$1(), mh(c, a, d, e), Ji(c, b, d));
          }
        }
        function Hi(a) {
          var b = a.alternate;
          return a === N$1 || null !== b && b === N$1;
        }
        function Ii(a, b) {
          Th = Sh = !0;
          var c = a.pending;
          null === c ? b.next = b : (b.next = c.next, c.next = b);
          a.pending = b;
        }
        function Ji(a, b, c) {
          if (0 !== (c & 4194240)) {
            var d = b.lanes;
            d &= a.pendingLanes;
            c |= d;
            b.lanes = c;
            Cc(a, c);
          }
        }
        var ai = {
            readContext: Vg,
            useCallback: Q$1,
            useContext: Q$1,
            useEffect: Q$1,
            useImperativeHandle: Q$1,
            useInsertionEffect: Q$1,
            useLayoutEffect: Q$1,
            useMemo: Q$1,
            useReducer: Q$1,
            useRef: Q$1,
            useState: Q$1,
            useDebugValue: Q$1,
            useDeferredValue: Q$1,
            useTransition: Q$1,
            useMutableSource: Q$1,
            useSyncExternalStore: Q$1,
            useId: Q$1,
            unstable_isNewReconciler: !1
          },
          Yh = {
            readContext: Vg,
            useCallback: function (a, b) {
              ci().memoizedState = [a, void 0 === b ? null : b];
              return a;
            },
            useContext: Vg,
            useEffect: vi,
            useImperativeHandle: function (a, b, c) {
              c = null !== c && void 0 !== c ? c.concat([a]) : null;
              return ti(4194308, 4, yi.bind(null, b, a), c);
            },
            useLayoutEffect: function (a, b) {
              return ti(4194308, 4, a, b);
            },
            useInsertionEffect: function (a, b) {
              return ti(4, 2, a, b);
            },
            useMemo: function (a, b) {
              var c = ci();
              b = void 0 === b ? null : b;
              a = a();
              c.memoizedState = [a, b];
              return a;
            },
            useReducer: function (a, b, c) {
              var d = ci();
              b = void 0 !== c ? c(b) : b;
              d.memoizedState = d.baseState = b;
              a = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: a,
                lastRenderedState: b
              };
              d.queue = a;
              a = a.dispatch = Gi.bind(null, N$1, a);
              return [d.memoizedState, a];
            },
            useRef: function (a) {
              var b = ci();
              a = {
                current: a
              };
              return b.memoizedState = a;
            },
            useState: qi,
            useDebugValue: Ai,
            useDeferredValue: function (a) {
              return ci().memoizedState = a;
            },
            useTransition: function () {
              var a = qi(!1),
                b = a[0];
              a = Ei.bind(null, a[1]);
              ci().memoizedState = a;
              return [b, a];
            },
            useMutableSource: function () {},
            useSyncExternalStore: function (a, b, c) {
              var d = N$1,
                e = ci();
              if (I$2) {
                if (void 0 === c) throw Error(p$6(407));
                c = c();
              } else {
                c = b();
                if (null === R$1) throw Error(p$6(349));
                0 !== (Rh & 30) || ni(d, b, c);
              }
              e.memoizedState = c;
              var f = {
                value: c,
                getSnapshot: b
              };
              e.queue = f;
              vi(ki.bind(null, d, f, a), [a]);
              d.flags |= 2048;
              li(9, mi.bind(null, d, f, c, b), void 0, null);
              return c;
            },
            useId: function () {
              var a = ci(),
                b = R$1.identifierPrefix;
              if (I$2) {
                var c = sg;
                var d = rg;
                c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
                b = ":" + b + "R" + c;
                c = Uh++;
                0 < c && (b += "H" + c.toString(32));
                b += ":";
              } else c = Vh++, b = ":" + b + "r" + c.toString(32) + ":";
              return a.memoizedState = b;
            },
            unstable_isNewReconciler: !1
          },
          Zh = {
            readContext: Vg,
            useCallback: Bi,
            useContext: Vg,
            useEffect: ji,
            useImperativeHandle: zi,
            useInsertionEffect: wi,
            useLayoutEffect: xi,
            useMemo: Ci,
            useReducer: fi,
            useRef: si,
            useState: function () {
              return fi(ei);
            },
            useDebugValue: Ai,
            useDeferredValue: function (a) {
              var b = di();
              return Di(b, O$1.memoizedState, a);
            },
            useTransition: function () {
              var a = fi(ei)[0],
                b = di().memoizedState;
              return [a, b];
            },
            useMutableSource: hi,
            useSyncExternalStore: ii,
            useId: Fi,
            unstable_isNewReconciler: !1
          },
          $h = {
            readContext: Vg,
            useCallback: Bi,
            useContext: Vg,
            useEffect: ji,
            useImperativeHandle: zi,
            useInsertionEffect: wi,
            useLayoutEffect: xi,
            useMemo: Ci,
            useReducer: gi,
            useRef: si,
            useState: function () {
              return gi(ei);
            },
            useDebugValue: Ai,
            useDeferredValue: function (a) {
              var b = di();
              return null === O$1 ? b.memoizedState = a : Di(b, O$1.memoizedState, a);
            },
            useTransition: function () {
              var a = gi(ei)[0],
                b = di().memoizedState;
              return [a, b];
            },
            useMutableSource: hi,
            useSyncExternalStore: ii,
            useId: Fi,
            unstable_isNewReconciler: !1
          };
        function Ki(a, b) {
          try {
            var c = "",
              d = b;
            do c += Pa(d), d = d.return; while (d);
            var e = c;
          } catch (f) {
            e = "\nError generating stack: " + f.message + "\n" + f.stack;
          }
          return {
            value: a,
            source: b,
            stack: e,
            digest: null
          };
        }
        function Li(a, b, c) {
          return {
            value: a,
            source: null,
            stack: null != c ? c : null,
            digest: null != b ? b : null
          };
        }
        function Mi(a, b) {
          try {
            console.error(b.value);
          } catch (c) {
            setTimeout(function () {
              throw c;
            });
          }
        }
        var Ni = "function" === typeof WeakMap ? WeakMap : Map;
        function Oi(a, b, c) {
          c = ch(-1, c);
          c.tag = 3;
          c.payload = {
            element: null
          };
          var d = b.value;
          c.callback = function () {
            Pi || (Pi = !0, Qi = d);
            Mi(a, b);
          };
          return c;
        }
        function Ri(a, b, c) {
          c = ch(-1, c);
          c.tag = 3;
          var d = a.type.getDerivedStateFromError;
          if ("function" === typeof d) {
            var e = b.value;
            c.payload = function () {
              return d(e);
            };
            c.callback = function () {
              Mi(a, b);
            };
          }
          var f = a.stateNode;
          null !== f && "function" === typeof f.componentDidCatch && (c.callback = function () {
            Mi(a, b);
            "function" !== typeof d && (null === Si ? Si = new Set([this]) : Si.add(this));
            var c = b.stack;
            this.componentDidCatch(b.value, {
              componentStack: null !== c ? c : ""
            });
          });
          return c;
        }
        function Ti(a, b, c) {
          var d = a.pingCache;
          if (null === d) {
            d = a.pingCache = new Ni();
            var e = new Set();
            d.set(b, e);
          } else e = d.get(b), void 0 === e && (e = new Set(), d.set(b, e));
          e.has(c) || (e.add(c), a = Ui.bind(null, a, b, c), b.then(a, a));
        }
        function Vi(a) {
          do {
            var b;
            if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? !0 : !1 : !0;
            if (b) return a;
            a = a.return;
          } while (null !== a);
          return null;
        }
        function Wi(a, b, c, d, e) {
          if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = ch(-1, 1), b.tag = 2, dh(c, b, 1))), c.lanes |= 1), a;
          a.flags |= 65536;
          a.lanes = e;
          return a;
        }
        var Xi = ua.ReactCurrentOwner,
          Ug = !1;
        function Yi(a, b, c, d) {
          b.child = null === a ? Ch(b, null, c, d) : Bh(b, a.child, c, d);
        }
        function Zi(a, b, c, d, e) {
          c = c.render;
          var f = b.ref;
          Tg(b, e);
          d = Xh(a, b, c, d, f, e);
          c = bi();
          if (null !== a && !Ug) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, $i(a, b, e);
          I$2 && c && vg(b);
          b.flags |= 1;
          Yi(a, b, d, e);
          return b.child;
        }
        function aj(a, b, c, d, e) {
          if (null === a) {
            var f = c.type;
            if ("function" === typeof f && !bj(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f, cj(a, b, f, d, e);
            a = yh(c.type, null, d, b, b.mode, e);
            a.ref = b.ref;
            a.return = b;
            return b.child = a;
          }
          f = a.child;
          if (0 === (a.lanes & e)) {
            var g = f.memoizedProps;
            c = c.compare;
            c = null !== c ? c : Ie;
            if (c(g, d) && a.ref === b.ref) return $i(a, b, e);
          }
          b.flags |= 1;
          a = wh(f, d);
          a.ref = b.ref;
          a.return = b;
          return b.child = a;
        }
        function cj(a, b, c, d, e) {
          if (null !== a) {
            var f = a.memoizedProps;
            if (Ie(f, d) && a.ref === b.ref) if (Ug = !1, b.pendingProps = d = f, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (Ug = !0);else return b.lanes = a.lanes, $i(a, b, e);
          }
          return dj(a, b, c, d, e);
        }
        function ej(a, b, c) {
          var d = b.pendingProps,
            e = d.children,
            f = null !== a ? a.memoizedState : null;
          if ("hidden" === d.mode) {
            if (0 === (b.mode & 1)) b.memoizedState = {
              baseLanes: 0,
              cachePool: null,
              transitions: null
            }, G$2(fj, gj), gj |= c;else {
              if (0 === (c & 1073741824)) return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = {
                baseLanes: a,
                cachePool: null,
                transitions: null
              }, b.updateQueue = null, G$2(fj, gj), gj |= a, null;
              b.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
              };
              d = null !== f ? f.baseLanes : c;
              G$2(fj, gj);
              gj |= d;
            }
          } else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, G$2(fj, gj), gj |= d;
          Yi(a, b, e, c);
          return b.child;
        }
        function hj(a, b) {
          var c = b.ref;
          if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
        }
        function dj(a, b, c, d, e) {
          var f = Zf(c) ? Xf : H$2.current;
          f = Yf(b, f);
          Tg(b, e);
          c = Xh(a, b, c, d, f, e);
          d = bi();
          if (null !== a && !Ug) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, $i(a, b, e);
          I$2 && d && vg(b);
          b.flags |= 1;
          Yi(a, b, c, e);
          return b.child;
        }
        function ij(a, b, c, d, e) {
          if (Zf(c)) {
            var f = !0;
            cg(b);
          } else f = !1;
          Tg(b, e);
          if (null === b.stateNode) jj(a, b), ph(b, c, d), rh(b, c, d, e), d = !0;else if (null === a) {
            var g = b.stateNode,
              h = b.memoizedProps;
            g.props = h;
            var k = g.context,
              l = c.contextType;
            "object" === typeof l && null !== l ? l = Vg(l) : (l = Zf(c) ? Xf : H$2.current, l = Yf(b, l));
            var m = c.getDerivedStateFromProps,
              q = "function" === typeof m || "function" === typeof g.getSnapshotBeforeUpdate;
            q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && qh(b, g, d, l);
            $g = !1;
            var r = b.memoizedState;
            g.state = r;
            gh(b, d, g, e);
            k = b.memoizedState;
            h !== d || r !== k || Wf.current || $g ? ("function" === typeof m && (kh(b, c, m, d), k = b.memoizedState), (h = $g || oh(b, c, h, d, r, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = !1);
          } else {
            g = b.stateNode;
            bh(a, b);
            h = b.memoizedProps;
            l = b.type === b.elementType ? h : Lg(b.type, h);
            g.props = l;
            q = b.pendingProps;
            r = g.context;
            k = c.contextType;
            "object" === typeof k && null !== k ? k = Vg(k) : (k = Zf(c) ? Xf : H$2.current, k = Yf(b, k));
            var y = c.getDerivedStateFromProps;
            (m = "function" === typeof y || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q || r !== k) && qh(b, g, d, k);
            $g = !1;
            r = b.memoizedState;
            g.state = r;
            gh(b, d, g, e);
            var n = b.memoizedState;
            h !== q || r !== n || Wf.current || $g ? ("function" === typeof y && (kh(b, c, y, d), n = b.memoizedState), (l = $g || oh(b, c, l, d, r, n, k) || !1) ? (m || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n), g.props = d, g.state = n, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), d = !1);
          }
          return kj(a, b, c, d, f, e);
        }
        function kj(a, b, c, d, e, f) {
          hj(a, b);
          var g = 0 !== (b.flags & 128);
          if (!d && !g) return e && dg(b, c, !1), $i(a, b, f);
          d = b.stateNode;
          Xi.current = b;
          var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
          b.flags |= 1;
          null !== a && g ? (b.child = Bh(b, a.child, null, f), b.child = Bh(b, null, h, f)) : Yi(a, b, h, f);
          b.memoizedState = d.state;
          e && dg(b, c, !0);
          return b.child;
        }
        function lj(a) {
          var b = a.stateNode;
          b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, !1);
          Ih(a, b.containerInfo);
        }
        function mj(a, b, c, d, e) {
          Ig();
          Jg(e);
          b.flags |= 256;
          Yi(a, b, c, d);
          return b.child;
        }
        var nj = {
          dehydrated: null,
          treeContext: null,
          retryLane: 0
        };
        function oj(a) {
          return {
            baseLanes: a,
            cachePool: null,
            transitions: null
          };
        }
        function pj(a, b, c) {
          var d = b.pendingProps,
            e = M$1.current,
            f = !1,
            g = 0 !== (b.flags & 128),
            h;
          (h = g) || (h = null !== a && null === a.memoizedState ? !1 : 0 !== (e & 2));
          if (h) f = !0, b.flags &= -129;else if (null === a || null !== a.memoizedState) e |= 1;
          G$2(M$1, e & 1);
          if (null === a) {
            Eg(b);
            a = b.memoizedState;
            if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
            g = d.children;
            a = d.fallback;
            return f ? (d = b.mode, f = b.child, g = {
              mode: "hidden",
              children: g
            }, 0 === (d & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = qj(g, d, 0, null), a = Ah(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = oj(c), b.memoizedState = nj, a) : rj(b, g);
          }
          e = a.memoizedState;
          if (null !== e && (h = e.dehydrated, null !== h)) return sj(a, b, g, d, h, e, c);
          if (f) {
            f = d.fallback;
            g = b.mode;
            e = a.child;
            h = e.sibling;
            var k = {
              mode: "hidden",
              children: d.children
            };
            0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = wh(e, k), d.subtreeFlags = e.subtreeFlags & 14680064);
            null !== h ? f = wh(h, f) : (f = Ah(f, g, c, null), f.flags |= 2);
            f.return = b;
            d.return = b;
            d.sibling = f;
            b.child = d;
            d = f;
            f = b.child;
            g = a.child.memoizedState;
            g = null === g ? oj(c) : {
              baseLanes: g.baseLanes | c,
              cachePool: null,
              transitions: g.transitions
            };
            f.memoizedState = g;
            f.childLanes = a.childLanes & ~c;
            b.memoizedState = nj;
            return d;
          }
          f = a.child;
          a = f.sibling;
          d = wh(f, {
            mode: "visible",
            children: d.children
          });
          0 === (b.mode & 1) && (d.lanes = c);
          d.return = b;
          d.sibling = null;
          null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
          b.child = d;
          b.memoizedState = null;
          return d;
        }
        function rj(a, b) {
          b = qj({
            mode: "visible",
            children: b
          }, a.mode, 0, null);
          b.return = a;
          return a.child = b;
        }
        function tj(a, b, c, d) {
          null !== d && Jg(d);
          Bh(b, a.child, null, c);
          a = rj(b, b.pendingProps.children);
          a.flags |= 2;
          b.memoizedState = null;
          return a;
        }
        function sj(a, b, c, d, e, f, g) {
          if (c) {
            if (b.flags & 256) return b.flags &= -257, d = Li(Error(p$6(422))), tj(a, b, g, d);
            if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
            f = d.fallback;
            e = b.mode;
            d = qj({
              mode: "visible",
              children: d.children
            }, e, 0, null);
            f = Ah(f, e, g, null);
            f.flags |= 2;
            d.return = b;
            f.return = b;
            d.sibling = f;
            b.child = d;
            0 !== (b.mode & 1) && Bh(b, a.child, null, g);
            b.child.memoizedState = oj(g);
            b.memoizedState = nj;
            return f;
          }
          if (0 === (b.mode & 1)) return tj(a, b, g, null);
          if ("$!" === e.data) {
            d = e.nextSibling && e.nextSibling.dataset;
            if (d) var h = d.dgst;
            d = h;
            f = Error(p$6(419));
            d = Li(f, d, void 0);
            return tj(a, b, g, d);
          }
          h = 0 !== (g & a.childLanes);
          if (Ug || h) {
            d = R$1;
            if (null !== d) {
              switch (g & -g) {
                case 4:
                  e = 2;
                  break;
                case 16:
                  e = 8;
                  break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                  e = 32;
                  break;
                case 536870912:
                  e = 268435456;
                  break;
                default:
                  e = 0;
              }
              e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
              0 !== e && e !== f.retryLane && (f.retryLane = e, Zg(a, e), mh(d, a, e, -1));
            }
            uj();
            d = Li(Error(p$6(421)));
            return tj(a, b, g, d);
          }
          if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = vj.bind(null, a), e._reactRetry = b, null;
          a = f.treeContext;
          yg = Lf(e.nextSibling);
          xg = b;
          I$2 = !0;
          zg = null;
          null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
          b = rj(b, d.children);
          b.flags |= 4096;
          return b;
        }
        function wj(a, b, c) {
          a.lanes |= b;
          var d = a.alternate;
          null !== d && (d.lanes |= b);
          Sg(a.return, b, c);
        }
        function xj(a, b, c, d, e) {
          var f = a.memoizedState;
          null === f ? a.memoizedState = {
            isBackwards: b,
            rendering: null,
            renderingStartTime: 0,
            last: d,
            tail: c,
            tailMode: e
          } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
        }
        function yj(a, b, c) {
          var d = b.pendingProps,
            e = d.revealOrder,
            f = d.tail;
          Yi(a, b, d.children, c);
          d = M$1.current;
          if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;else {
            if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a;) {
              if (13 === a.tag) null !== a.memoizedState && wj(a, c, b);else if (19 === a.tag) wj(a, c, b);else if (null !== a.child) {
                a.child.return = a;
                a = a.child;
                continue;
              }
              if (a === b) break a;
              for (; null === a.sibling;) {
                if (null === a.return || a.return === b) break a;
                a = a.return;
              }
              a.sibling.return = a.return;
              a = a.sibling;
            }
            d &= 1;
          }
          G$2(M$1, d);
          if (0 === (b.mode & 1)) b.memoizedState = null;else switch (e) {
            case "forwards":
              c = b.child;
              for (e = null; null !== c;) a = c.alternate, null !== a && null === Mh(a) && (e = c), c = c.sibling;
              c = e;
              null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
              xj(b, !1, e, c, f);
              break;
            case "backwards":
              c = null;
              e = b.child;
              for (b.child = null; null !== e;) {
                a = e.alternate;
                if (null !== a && null === Mh(a)) {
                  b.child = e;
                  break;
                }
                a = e.sibling;
                e.sibling = c;
                c = e;
                e = a;
              }
              xj(b, !0, c, null, f);
              break;
            case "together":
              xj(b, !1, null, null, void 0);
              break;
            default:
              b.memoizedState = null;
          }
          return b.child;
        }
        function jj(a, b) {
          0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
        }
        function $i(a, b, c) {
          null !== a && (b.dependencies = a.dependencies);
          hh |= b.lanes;
          if (0 === (c & b.childLanes)) return null;
          if (null !== a && b.child !== a.child) throw Error(p$6(153));
          if (null !== b.child) {
            a = b.child;
            c = wh(a, a.pendingProps);
            b.child = c;
            for (c.return = b; null !== a.sibling;) a = a.sibling, c = c.sibling = wh(a, a.pendingProps), c.return = b;
            c.sibling = null;
          }
          return b.child;
        }
        function zj(a, b, c) {
          switch (b.tag) {
            case 3:
              lj(b);
              Ig();
              break;
            case 5:
              Kh(b);
              break;
            case 1:
              Zf(b.type) && cg(b);
              break;
            case 4:
              Ih(b, b.stateNode.containerInfo);
              break;
            case 10:
              var d = b.type._context,
                e = b.memoizedProps.value;
              G$2(Mg, d._currentValue);
              d._currentValue = e;
              break;
            case 13:
              d = b.memoizedState;
              if (null !== d) {
                if (null !== d.dehydrated) return G$2(M$1, M$1.current & 1), b.flags |= 128, null;
                if (0 !== (c & b.child.childLanes)) return pj(a, b, c);
                G$2(M$1, M$1.current & 1);
                a = $i(a, b, c);
                return null !== a ? a.sibling : null;
              }
              G$2(M$1, M$1.current & 1);
              break;
            case 19:
              d = 0 !== (c & b.childLanes);
              if (0 !== (a.flags & 128)) {
                if (d) return yj(a, b, c);
                b.flags |= 128;
              }
              e = b.memoizedState;
              null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
              G$2(M$1, M$1.current);
              if (d) break;else return null;
            case 22:
            case 23:
              return b.lanes = 0, ej(a, b, c);
          }
          return $i(a, b, c);
        }
        var Aj, Bj, Cj, Dj;
        Aj = function (a, b) {
          for (var c = b.child; null !== c;) {
            if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);else if (4 !== c.tag && null !== c.child) {
              c.child.return = c;
              c = c.child;
              continue;
            }
            if (c === b) break;
            for (; null === c.sibling;) {
              if (null === c.return || c.return === b) return;
              c = c.return;
            }
            c.sibling.return = c.return;
            c = c.sibling;
          }
        };
        Bj = function () {};
        Cj = function (a, b, c, d) {
          var e = a.memoizedProps;
          if (e !== d) {
            a = b.stateNode;
            Hh(Eh.current);
            var f = null;
            switch (c) {
              case "input":
                e = Ya(a, e);
                d = Ya(a, d);
                f = [];
                break;
              case "select":
                e = A$3({}, e, {
                  value: void 0
                });
                d = A$3({}, d, {
                  value: void 0
                });
                f = [];
                break;
              case "textarea":
                e = gb(a, e);
                d = gb(a, d);
                f = [];
                break;
              default:
                "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
            }
            ub(c, d);
            var g;
            c = null;
            for (l in e) if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
              var h = e[l];
              for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
            } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
            for (l in d) {
              var k = d[l];
              h = null != e ? e[l] : void 0;
              if (d.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) {
                if (h) {
                  for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
                  for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
                } else c || (f || (f = []), f.push(l, c)), c = k;
              } else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D$2("scroll", a), f || h === k || (f = [])) : (f = f || []).push(l, k));
            }
            c && (f = f || []).push("style", c);
            var l = f;
            if (b.updateQueue = l) b.flags |= 4;
          }
        };
        Dj = function (a, b, c, d) {
          c !== d && (b.flags |= 4);
        };
        function Ej(a, b) {
          if (!I$2) switch (a.tailMode) {
            case "hidden":
              b = a.tail;
              for (var c = null; null !== b;) null !== b.alternate && (c = b), b = b.sibling;
              null === c ? a.tail = null : c.sibling = null;
              break;
            case "collapsed":
              c = a.tail;
              for (var d = null; null !== c;) null !== c.alternate && (d = c), c = c.sibling;
              null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
          }
        }
        function S$1(a) {
          var b = null !== a.alternate && a.alternate.child === a.child,
            c = 0,
            d = 0;
          if (b) for (var e = a.child; null !== e;) c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;else for (e = a.child; null !== e;) c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
          a.subtreeFlags |= d;
          a.childLanes = c;
          return b;
        }
        function Fj(a, b, c) {
          var d = b.pendingProps;
          wg(b);
          switch (b.tag) {
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
              return S$1(b), null;
            case 1:
              return Zf(b.type) && $f(), S$1(b), null;
            case 3:
              d = b.stateNode;
              Jh();
              E$2(Wf);
              E$2(H$2);
              Oh();
              d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
              if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Gj(zg), zg = null));
              Bj(a, b);
              S$1(b);
              return null;
            case 5:
              Lh(b);
              var e = Hh(Gh.current);
              c = b.type;
              if (null !== a && null != b.stateNode) Cj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);else {
                if (!d) {
                  if (null === b.stateNode) throw Error(p$6(166));
                  S$1(b);
                  return null;
                }
                a = Hh(Eh.current);
                if (Gg(b)) {
                  d = b.stateNode;
                  c = b.type;
                  var f = b.memoizedProps;
                  d[Of] = b;
                  d[Pf] = f;
                  a = 0 !== (b.mode & 1);
                  switch (c) {
                    case "dialog":
                      D$2("cancel", d);
                      D$2("close", d);
                      break;
                    case "iframe":
                    case "object":
                    case "embed":
                      D$2("load", d);
                      break;
                    case "video":
                    case "audio":
                      for (e = 0; e < lf.length; e++) D$2(lf[e], d);
                      break;
                    case "source":
                      D$2("error", d);
                      break;
                    case "img":
                    case "image":
                    case "link":
                      D$2("error", d);
                      D$2("load", d);
                      break;
                    case "details":
                      D$2("toggle", d);
                      break;
                    case "input":
                      Za(d, f);
                      D$2("invalid", d);
                      break;
                    case "select":
                      d._wrapperState = {
                        wasMultiple: !!f.multiple
                      };
                      D$2("invalid", d);
                      break;
                    case "textarea":
                      hb(d, f), D$2("invalid", d);
                  }
                  ub(c, f);
                  e = null;
                  for (var g in f) if (f.hasOwnProperty(g)) {
                    var h = f[g];
                    "children" === g ? "string" === typeof h ? d.textContent !== h && (!0 !== f.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", h]) : "number" === typeof h && d.textContent !== "" + h && (!0 !== f.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D$2("scroll", d);
                  }
                  switch (c) {
                    case "input":
                      Va(d);
                      db(d, f, !0);
                      break;
                    case "textarea":
                      Va(d);
                      jb(d);
                      break;
                    case "select":
                    case "option":
                      break;
                    default:
                      "function" === typeof f.onClick && (d.onclick = Bf);
                  }
                  d = e;
                  b.updateQueue = d;
                  null !== d && (b.flags |= 4);
                } else {
                  g = 9 === e.nodeType ? e : e.ownerDocument;
                  "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
                  "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script>\x3c/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, {
                    is: d.is
                  }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = !0 : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
                  a[Of] = b;
                  a[Pf] = d;
                  Aj(a, b, !1, !1);
                  b.stateNode = a;
                  a: {
                    g = vb(c, d);
                    switch (c) {
                      case "dialog":
                        D$2("cancel", a);
                        D$2("close", a);
                        e = d;
                        break;
                      case "iframe":
                      case "object":
                      case "embed":
                        D$2("load", a);
                        e = d;
                        break;
                      case "video":
                      case "audio":
                        for (e = 0; e < lf.length; e++) D$2(lf[e], a);
                        e = d;
                        break;
                      case "source":
                        D$2("error", a);
                        e = d;
                        break;
                      case "img":
                      case "image":
                      case "link":
                        D$2("error", a);
                        D$2("load", a);
                        e = d;
                        break;
                      case "details":
                        D$2("toggle", a);
                        e = d;
                        break;
                      case "input":
                        Za(a, d);
                        e = Ya(a, d);
                        D$2("invalid", a);
                        break;
                      case "option":
                        e = d;
                        break;
                      case "select":
                        a._wrapperState = {
                          wasMultiple: !!d.multiple
                        };
                        e = A$3({}, d, {
                          value: void 0
                        });
                        D$2("invalid", a);
                        break;
                      case "textarea":
                        hb(a, d);
                        e = gb(a, d);
                        D$2("invalid", a);
                        break;
                      default:
                        e = d;
                    }
                    ub(c, e);
                    h = e;
                    for (f in h) if (h.hasOwnProperty(f)) {
                      var k = h[f];
                      "style" === f ? sb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && ob(a, k) : "number" === typeof k && ob(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D$2("scroll", a) : null != k && ta(a, f, k, g));
                    }
                    switch (c) {
                      case "input":
                        Va(a);
                        db(a, d, !1);
                        break;
                      case "textarea":
                        Va(a);
                        jb(a);
                        break;
                      case "option":
                        null != d.value && a.setAttribute("value", "" + Sa(d.value));
                        break;
                      case "select":
                        a.multiple = !!d.multiple;
                        f = d.value;
                        null != f ? fb(a, !!d.multiple, f, !1) : null != d.defaultValue && fb(a, !!d.multiple, d.defaultValue, !0);
                        break;
                      default:
                        "function" === typeof e.onClick && (a.onclick = Bf);
                    }
                    switch (c) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        d = !!d.autoFocus;
                        break a;
                      case "img":
                        d = !0;
                        break a;
                      default:
                        d = !1;
                    }
                  }
                  d && (b.flags |= 4);
                }
                null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
              }
              S$1(b);
              return null;
            case 6:
              if (a && null != b.stateNode) Dj(a, b, a.memoizedProps, d);else {
                if ("string" !== typeof d && null === b.stateNode) throw Error(p$6(166));
                c = Hh(Gh.current);
                Hh(Eh.current);
                if (Gg(b)) {
                  d = b.stateNode;
                  c = b.memoizedProps;
                  d[Of] = b;
                  if (f = d.nodeValue !== c) if (a = xg, null !== a) switch (a.tag) {
                    case 3:
                      Af(d.nodeValue, c, 0 !== (a.mode & 1));
                      break;
                    case 5:
                      !0 !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
                  }
                  f && (b.flags |= 4);
                } else d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
              }
              S$1(b);
              return null;
            case 13:
              E$2(M$1);
              d = b.memoizedState;
              if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
                if (I$2 && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f = !1;else if (f = Gg(b), null !== d && null !== d.dehydrated) {
                  if (null === a) {
                    if (!f) throw Error(p$6(318));
                    f = b.memoizedState;
                    f = null !== f ? f.dehydrated : null;
                    if (!f) throw Error(p$6(317));
                    f[Of] = b;
                  } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
                  S$1(b);
                  f = !1;
                } else null !== zg && (Gj(zg), zg = null), f = !0;
                if (!f) return b.flags & 65536 ? b : null;
              }
              if (0 !== (b.flags & 128)) return b.lanes = c, b;
              d = null !== d;
              d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (M$1.current & 1) ? 0 === T && (T = 3) : uj()));
              null !== b.updateQueue && (b.flags |= 4);
              S$1(b);
              return null;
            case 4:
              return Jh(), Bj(a, b), null === a && sf(b.stateNode.containerInfo), S$1(b), null;
            case 10:
              return Rg(b.type._context), S$1(b), null;
            case 17:
              return Zf(b.type) && $f(), S$1(b), null;
            case 19:
              E$2(M$1);
              f = b.memoizedState;
              if (null === f) return S$1(b), null;
              d = 0 !== (b.flags & 128);
              g = f.rendering;
              if (null === g) {
                if (d) Ej(f, !1);else {
                  if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a;) {
                    g = Mh(a);
                    if (null !== g) {
                      b.flags |= 128;
                      Ej(f, !1);
                      d = g.updateQueue;
                      null !== d && (b.updateQueue = d, b.flags |= 4);
                      b.subtreeFlags = 0;
                      d = c;
                      for (c = b.child; null !== c;) f = c, a = d, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : {
                        lanes: a.lanes,
                        firstContext: a.firstContext
                      }), c = c.sibling;
                      G$2(M$1, M$1.current & 1 | 2);
                      return b.child;
                    }
                    a = a.sibling;
                  }
                  null !== f.tail && B$2() > Hj && (b.flags |= 128, d = !0, Ej(f, !1), b.lanes = 4194304);
                }
              } else {
                if (!d) if (a = Mh(g), null !== a) {
                  if (b.flags |= 128, d = !0, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Ej(f, !0), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I$2) return S$1(b), null;
                } else 2 * B$2() - f.renderingStartTime > Hj && 1073741824 !== c && (b.flags |= 128, d = !0, Ej(f, !1), b.lanes = 4194304);
                f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, null !== c ? c.sibling = g : b.child = g, f.last = g);
              }
              if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B$2(), b.sibling = null, c = M$1.current, G$2(M$1, d ? c & 1 | 2 : c & 1), b;
              S$1(b);
              return null;
            case 22:
            case 23:
              return Ij(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (gj & 1073741824) && (S$1(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S$1(b), null;
            case 24:
              return null;
            case 25:
              return null;
          }
          throw Error(p$6(156, b.tag));
        }
        function Jj(a, b) {
          wg(b);
          switch (b.tag) {
            case 1:
              return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
            case 3:
              return Jh(), E$2(Wf), E$2(H$2), Oh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
            case 5:
              return Lh(b), null;
            case 13:
              E$2(M$1);
              a = b.memoizedState;
              if (null !== a && null !== a.dehydrated) {
                if (null === b.alternate) throw Error(p$6(340));
                Ig();
              }
              a = b.flags;
              return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
            case 19:
              return E$2(M$1), null;
            case 4:
              return Jh(), null;
            case 10:
              return Rg(b.type._context), null;
            case 22:
            case 23:
              return Ij(), null;
            case 24:
              return null;
            default:
              return null;
          }
        }
        var Kj = !1,
          U$1 = !1,
          Lj = "function" === typeof WeakSet ? WeakSet : Set,
          V = null;
        function Mj(a, b) {
          var c = a.ref;
          if (null !== c) if ("function" === typeof c) try {
            c(null);
          } catch (d) {
            W$1(a, b, d);
          } else c.current = null;
        }
        function Nj(a, b, c) {
          try {
            c();
          } catch (d) {
            W$1(a, b, d);
          }
        }
        var Oj = !1;
        function Pj(a, b) {
          Cf = dd;
          a = Me();
          if (Ne(a)) {
            if ("selectionStart" in a) var c = {
              start: a.selectionStart,
              end: a.selectionEnd
            };else a: {
              c = (c = a.ownerDocument) && c.defaultView || window;
              var d = c.getSelection && c.getSelection();
              if (d && 0 !== d.rangeCount) {
                c = d.anchorNode;
                var e = d.anchorOffset,
                  f = d.focusNode;
                d = d.focusOffset;
                try {
                  c.nodeType, f.nodeType;
                } catch (F) {
                  c = null;
                  break a;
                }
                var g = 0,
                  h = -1,
                  k = -1,
                  l = 0,
                  m = 0,
                  q = a,
                  r = null;
                b: for (;;) {
                  for (var y;;) {
                    q !== c || 0 !== e && 3 !== q.nodeType || (h = g + e);
                    q !== f || 0 !== d && 3 !== q.nodeType || (k = g + d);
                    3 === q.nodeType && (g += q.nodeValue.length);
                    if (null === (y = q.firstChild)) break;
                    r = q;
                    q = y;
                  }
                  for (;;) {
                    if (q === a) break b;
                    r === c && ++l === e && (h = g);
                    r === f && ++m === d && (k = g);
                    if (null !== (y = q.nextSibling)) break;
                    q = r;
                    r = q.parentNode;
                  }
                  q = y;
                }
                c = -1 === h || -1 === k ? null : {
                  start: h,
                  end: k
                };
              } else c = null;
            }
            c = c || {
              start: 0,
              end: 0
            };
          } else c = null;
          Df = {
            focusedElem: a,
            selectionRange: c
          };
          dd = !1;
          for (V = b; null !== V;) if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V = a;else for (; null !== V;) {
            b = V;
            try {
              var n = b.alternate;
              if (0 !== (b.flags & 1024)) switch (b.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (null !== n) {
                    var t = n.memoizedProps,
                      J = n.memoizedState,
                      x = b.stateNode,
                      w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Lg(b.type, t), J);
                    x.__reactInternalSnapshotBeforeUpdate = w;
                  }
                  break;
                case 3:
                  var u = b.stateNode.containerInfo;
                  1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(p$6(163));
              }
            } catch (F) {
              W$1(b, b.return, F);
            }
            a = b.sibling;
            if (null !== a) {
              a.return = b.return;
              V = a;
              break;
            }
            V = b.return;
          }
          n = Oj;
          Oj = !1;
          return n;
        }
        function Qj(a, b, c) {
          var d = b.updateQueue;
          d = null !== d ? d.lastEffect : null;
          if (null !== d) {
            var e = d = d.next;
            do {
              if ((e.tag & a) === a) {
                var f = e.destroy;
                e.destroy = void 0;
                void 0 !== f && Nj(b, c, f);
              }
              e = e.next;
            } while (e !== d);
          }
        }
        function Rj(a, b) {
          b = b.updateQueue;
          b = null !== b ? b.lastEffect : null;
          if (null !== b) {
            var c = b = b.next;
            do {
              if ((c.tag & a) === a) {
                var d = c.create;
                c.destroy = d();
              }
              c = c.next;
            } while (c !== b);
          }
        }
        function Sj(a) {
          var b = a.ref;
          if (null !== b) {
            var c = a.stateNode;
            switch (a.tag) {
              case 5:
                a = c;
                break;
              default:
                a = c;
            }
            "function" === typeof b ? b(a) : b.current = a;
          }
        }
        function Tj(a) {
          var b = a.alternate;
          null !== b && (a.alternate = null, Tj(b));
          a.child = null;
          a.deletions = null;
          a.sibling = null;
          5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
          a.stateNode = null;
          a.return = null;
          a.dependencies = null;
          a.memoizedProps = null;
          a.memoizedState = null;
          a.pendingProps = null;
          a.stateNode = null;
          a.updateQueue = null;
        }
        function Uj(a) {
          return 5 === a.tag || 3 === a.tag || 4 === a.tag;
        }
        function Vj(a) {
          a: for (;;) {
            for (; null === a.sibling;) {
              if (null === a.return || Uj(a.return)) return null;
              a = a.return;
            }
            a.sibling.return = a.return;
            for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag;) {
              if (a.flags & 2) continue a;
              if (null === a.child || 4 === a.tag) continue a;else a.child.return = a, a = a.child;
            }
            if (!(a.flags & 2)) return a.stateNode;
          }
        }
        function Wj(a, b, c) {
          var d = a.tag;
          if (5 === d || 6 === d) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));else if (4 !== d && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a;) Wj(a, b, c), a = a.sibling;
        }
        function Xj(a, b, c) {
          var d = a.tag;
          if (5 === d || 6 === d) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);else if (4 !== d && (a = a.child, null !== a)) for (Xj(a, b, c), a = a.sibling; null !== a;) Xj(a, b, c), a = a.sibling;
        }
        var X$1 = null,
          Yj = !1;
        function Zj(a, b, c) {
          for (c = c.child; null !== c;) ak(a, b, c), c = c.sibling;
        }
        function ak(a, b, c) {
          if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
            lc.onCommitFiberUnmount(kc, c);
          } catch (h) {}
          switch (c.tag) {
            case 5:
              U$1 || Mj(c, b);
            case 6:
              var d = X$1,
                e = Yj;
              X$1 = null;
              Zj(a, b, c);
              X$1 = d;
              Yj = e;
              null !== X$1 && (Yj ? (a = X$1, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X$1.removeChild(c.stateNode));
              break;
            case 18:
              null !== X$1 && (Yj ? (a = X$1, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X$1, c.stateNode));
              break;
            case 4:
              d = X$1;
              e = Yj;
              X$1 = c.stateNode.containerInfo;
              Yj = !0;
              Zj(a, b, c);
              X$1 = d;
              Yj = e;
              break;
            case 0:
            case 11:
            case 14:
            case 15:
              if (!U$1 && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
                e = d = d.next;
                do {
                  var f = e,
                    g = f.destroy;
                  f = f.tag;
                  void 0 !== g && (0 !== (f & 2) ? Nj(c, b, g) : 0 !== (f & 4) && Nj(c, b, g));
                  e = e.next;
                } while (e !== d);
              }
              Zj(a, b, c);
              break;
            case 1:
              if (!U$1 && (Mj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
                d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
              } catch (h) {
                W$1(c, b, h);
              }
              Zj(a, b, c);
              break;
            case 21:
              Zj(a, b, c);
              break;
            case 22:
              c.mode & 1 ? (U$1 = (d = U$1) || null !== c.memoizedState, Zj(a, b, c), U$1 = d) : Zj(a, b, c);
              break;
            default:
              Zj(a, b, c);
          }
        }
        function bk(a) {
          var b = a.updateQueue;
          if (null !== b) {
            a.updateQueue = null;
            var c = a.stateNode;
            null === c && (c = a.stateNode = new Lj());
            b.forEach(function (b) {
              var d = ck.bind(null, a, b);
              c.has(b) || (c.add(b), b.then(d, d));
            });
          }
        }
        function dk(a, b) {
          var c = b.deletions;
          if (null !== c) for (var d = 0; d < c.length; d++) {
            var e = c[d];
            try {
              var f = a,
                g = b,
                h = g;
              a: for (; null !== h;) {
                switch (h.tag) {
                  case 5:
                    X$1 = h.stateNode;
                    Yj = !1;
                    break a;
                  case 3:
                    X$1 = h.stateNode.containerInfo;
                    Yj = !0;
                    break a;
                  case 4:
                    X$1 = h.stateNode.containerInfo;
                    Yj = !0;
                    break a;
                }
                h = h.return;
              }
              if (null === X$1) throw Error(p$6(160));
              ak(f, g, e);
              X$1 = null;
              Yj = !1;
              var k = e.alternate;
              null !== k && (k.return = null);
              e.return = null;
            } catch (l) {
              W$1(e, b, l);
            }
          }
          if (b.subtreeFlags & 12854) for (b = b.child; null !== b;) ek(b, a), b = b.sibling;
        }
        function ek(a, b) {
          var c = a.alternate,
            d = a.flags;
          switch (a.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              dk(b, a);
              fk(a);
              if (d & 4) {
                try {
                  Qj(3, a, a.return), Rj(3, a);
                } catch (t) {
                  W$1(a, a.return, t);
                }
                try {
                  Qj(5, a, a.return);
                } catch (t) {
                  W$1(a, a.return, t);
                }
              }
              break;
            case 1:
              dk(b, a);
              fk(a);
              d & 512 && null !== c && Mj(c, c.return);
              break;
            case 5:
              dk(b, a);
              fk(a);
              d & 512 && null !== c && Mj(c, c.return);
              if (a.flags & 32) {
                var e = a.stateNode;
                try {
                  ob(e, "");
                } catch (t) {
                  W$1(a, a.return, t);
                }
              }
              if (d & 4 && (e = a.stateNode, null != e)) {
                var f = a.memoizedProps,
                  g = null !== c ? c.memoizedProps : f,
                  h = a.type,
                  k = a.updateQueue;
                a.updateQueue = null;
                if (null !== k) try {
                  "input" === h && "radio" === f.type && null != f.name && ab(e, f);
                  vb(h, g);
                  var l = vb(h, f);
                  for (g = 0; g < k.length; g += 2) {
                    var m = k[g],
                      q = k[g + 1];
                    "style" === m ? sb(e, q) : "dangerouslySetInnerHTML" === m ? nb(e, q) : "children" === m ? ob(e, q) : ta(e, m, q, l);
                  }
                  switch (h) {
                    case "input":
                      bb(e, f);
                      break;
                    case "textarea":
                      ib(e, f);
                      break;
                    case "select":
                      var r = e._wrapperState.wasMultiple;
                      e._wrapperState.wasMultiple = !!f.multiple;
                      var y = f.value;
                      null != y ? fb(e, !!f.multiple, y, !1) : r !== !!f.multiple && (null != f.defaultValue ? fb(e, !!f.multiple, f.defaultValue, !0) : fb(e, !!f.multiple, f.multiple ? [] : "", !1));
                  }
                  e[Pf] = f;
                } catch (t) {
                  W$1(a, a.return, t);
                }
              }
              break;
            case 6:
              dk(b, a);
              fk(a);
              if (d & 4) {
                if (null === a.stateNode) throw Error(p$6(162));
                e = a.stateNode;
                f = a.memoizedProps;
                try {
                  e.nodeValue = f;
                } catch (t) {
                  W$1(a, a.return, t);
                }
              }
              break;
            case 3:
              dk(b, a);
              fk(a);
              if (d & 4 && null !== c && c.memoizedState.isDehydrated) try {
                bd(b.containerInfo);
              } catch (t) {
                W$1(a, a.return, t);
              }
              break;
            case 4:
              dk(b, a);
              fk(a);
              break;
            case 13:
              dk(b, a);
              fk(a);
              e = a.child;
              e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (gk = B$2()));
              d & 4 && bk(a);
              break;
            case 22:
              m = null !== c && null !== c.memoizedState;
              a.mode & 1 ? (U$1 = (l = U$1) || m, dk(b, a), U$1 = l) : dk(b, a);
              fk(a);
              if (d & 8192) {
                l = null !== a.memoizedState;
                if ((a.stateNode.isHidden = l) && !m && 0 !== (a.mode & 1)) for (V = a, m = a.child; null !== m;) {
                  for (q = V = m; null !== V;) {
                    r = V;
                    y = r.child;
                    switch (r.tag) {
                      case 0:
                      case 11:
                      case 14:
                      case 15:
                        Qj(4, r, r.return);
                        break;
                      case 1:
                        Mj(r, r.return);
                        var n = r.stateNode;
                        if ("function" === typeof n.componentWillUnmount) {
                          d = r;
                          c = r.return;
                          try {
                            b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                          } catch (t) {
                            W$1(d, c, t);
                          }
                        }
                        break;
                      case 5:
                        Mj(r, r.return);
                        break;
                      case 22:
                        if (null !== r.memoizedState) {
                          hk(q);
                          continue;
                        }
                    }
                    null !== y ? (y.return = r, V = y) : hk(q);
                  }
                  m = m.sibling;
                }
                a: for (m = null, q = a;;) {
                  if (5 === q.tag) {
                    if (null === m) {
                      m = q;
                      try {
                        e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
                      } catch (t) {
                        W$1(a, a.return, t);
                      }
                    }
                  } else if (6 === q.tag) {
                    if (null === m) try {
                      q.stateNode.nodeValue = l ? "" : q.memoizedProps;
                    } catch (t) {
                      W$1(a, a.return, t);
                    }
                  } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a) && null !== q.child) {
                    q.child.return = q;
                    q = q.child;
                    continue;
                  }
                  if (q === a) break a;
                  for (; null === q.sibling;) {
                    if (null === q.return || q.return === a) break a;
                    m === q && (m = null);
                    q = q.return;
                  }
                  m === q && (m = null);
                  q.sibling.return = q.return;
                  q = q.sibling;
                }
              }
              break;
            case 19:
              dk(b, a);
              fk(a);
              d & 4 && bk(a);
              break;
            case 21:
              break;
            default:
              dk(b, a), fk(a);
          }
        }
        function fk(a) {
          var b = a.flags;
          if (b & 2) {
            try {
              a: {
                for (var c = a.return; null !== c;) {
                  if (Uj(c)) {
                    var d = c;
                    break a;
                  }
                  c = c.return;
                }
                throw Error(p$6(160));
              }
              switch (d.tag) {
                case 5:
                  var e = d.stateNode;
                  d.flags & 32 && (ob(e, ""), d.flags &= -33);
                  var f = Vj(a);
                  Xj(a, f, e);
                  break;
                case 3:
                case 4:
                  var g = d.stateNode.containerInfo,
                    h = Vj(a);
                  Wj(a, h, g);
                  break;
                default:
                  throw Error(p$6(161));
              }
            } catch (k) {
              W$1(a, a.return, k);
            }
            a.flags &= -3;
          }
          b & 4096 && (a.flags &= -4097);
        }
        function ik(a, b, c) {
          V = a;
          jk(a);
        }
        function jk(a, b, c) {
          for (var d = 0 !== (a.mode & 1); null !== V;) {
            var e = V,
              f = e.child;
            if (22 === e.tag && d) {
              var g = null !== e.memoizedState || Kj;
              if (!g) {
                var h = e.alternate,
                  k = null !== h && null !== h.memoizedState || U$1;
                h = Kj;
                var l = U$1;
                Kj = g;
                if ((U$1 = k) && !l) for (V = e; null !== V;) g = V, k = g.child, 22 === g.tag && null !== g.memoizedState ? kk(e) : null !== k ? (k.return = g, V = k) : kk(e);
                for (; null !== f;) V = f, jk(f), f = f.sibling;
                V = e;
                Kj = h;
                U$1 = l;
              }
              lk(a);
            } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V = f) : lk(a);
          }
        }
        function lk(a) {
          for (; null !== V;) {
            var b = V;
            if (0 !== (b.flags & 8772)) {
              var c = b.alternate;
              try {
                if (0 !== (b.flags & 8772)) switch (b.tag) {
                  case 0:
                  case 11:
                  case 15:
                    U$1 || Rj(5, b);
                    break;
                  case 1:
                    var d = b.stateNode;
                    if (b.flags & 4 && !U$1) if (null === c) d.componentDidMount();else {
                      var e = b.elementType === b.type ? c.memoizedProps : Lg(b.type, c.memoizedProps);
                      d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                    }
                    var f = b.updateQueue;
                    null !== f && ih(b, f, d);
                    break;
                  case 3:
                    var g = b.updateQueue;
                    if (null !== g) {
                      c = null;
                      if (null !== b.child) switch (b.child.tag) {
                        case 5:
                          c = b.child.stateNode;
                          break;
                        case 1:
                          c = b.child.stateNode;
                      }
                      ih(b, g, c);
                    }
                    break;
                  case 5:
                    var h = b.stateNode;
                    if (null === c && b.flags & 4) {
                      c = h;
                      var k = b.memoizedProps;
                      switch (b.type) {
                        case "button":
                        case "input":
                        case "select":
                        case "textarea":
                          k.autoFocus && c.focus();
                          break;
                        case "img":
                          k.src && (c.src = k.src);
                      }
                    }
                    break;
                  case 6:
                    break;
                  case 4:
                    break;
                  case 12:
                    break;
                  case 13:
                    if (null === b.memoizedState) {
                      var l = b.alternate;
                      if (null !== l) {
                        var m = l.memoizedState;
                        if (null !== m) {
                          var q = m.dehydrated;
                          null !== q && bd(q);
                        }
                      }
                    }
                    break;
                  case 19:
                  case 17:
                  case 21:
                  case 22:
                  case 23:
                  case 25:
                    break;
                  default:
                    throw Error(p$6(163));
                }
                U$1 || b.flags & 512 && Sj(b);
              } catch (r) {
                W$1(b, b.return, r);
              }
            }
            if (b === a) {
              V = null;
              break;
            }
            c = b.sibling;
            if (null !== c) {
              c.return = b.return;
              V = c;
              break;
            }
            V = b.return;
          }
        }
        function hk(a) {
          for (; null !== V;) {
            var b = V;
            if (b === a) {
              V = null;
              break;
            }
            var c = b.sibling;
            if (null !== c) {
              c.return = b.return;
              V = c;
              break;
            }
            V = b.return;
          }
        }
        function kk(a) {
          for (; null !== V;) {
            var b = V;
            try {
              switch (b.tag) {
                case 0:
                case 11:
                case 15:
                  var c = b.return;
                  try {
                    Rj(4, b);
                  } catch (k) {
                    W$1(b, c, k);
                  }
                  break;
                case 1:
                  var d = b.stateNode;
                  if ("function" === typeof d.componentDidMount) {
                    var e = b.return;
                    try {
                      d.componentDidMount();
                    } catch (k) {
                      W$1(b, e, k);
                    }
                  }
                  var f = b.return;
                  try {
                    Sj(b);
                  } catch (k) {
                    W$1(b, f, k);
                  }
                  break;
                case 5:
                  var g = b.return;
                  try {
                    Sj(b);
                  } catch (k) {
                    W$1(b, g, k);
                  }
              }
            } catch (k) {
              W$1(b, b.return, k);
            }
            if (b === a) {
              V = null;
              break;
            }
            var h = b.sibling;
            if (null !== h) {
              h.return = b.return;
              V = h;
              break;
            }
            V = b.return;
          }
        }
        var mk = Math.ceil,
          nk = ua.ReactCurrentDispatcher,
          ok$1 = ua.ReactCurrentOwner,
          pk = ua.ReactCurrentBatchConfig,
          K = 0,
          R$1 = null,
          Y = null,
          Z$1 = 0,
          gj = 0,
          fj = Uf(0),
          T = 0,
          qk = null,
          hh = 0,
          rk = 0,
          sk = 0,
          tk = null,
          uk = null,
          gk = 0,
          Hj = Infinity,
          vk = null,
          Pi = !1,
          Qi = null,
          Si = null,
          wk = !1,
          xk = null,
          yk = 0,
          zk = 0,
          Ak = null,
          Bk = -1,
          Ck = 0;
        function L$1() {
          return 0 !== (K & 6) ? B$2() : -1 !== Bk ? Bk : Bk = B$2();
        }
        function lh(a) {
          if (0 === (a.mode & 1)) return 1;
          if (0 !== (K & 2) && 0 !== Z$1) return Z$1 & -Z$1;
          if (null !== Kg.transition) return 0 === Ck && (Ck = yc()), Ck;
          a = C$1;
          if (0 !== a) return a;
          a = window.event;
          a = void 0 === a ? 16 : jd(a.type);
          return a;
        }
        function mh(a, b, c, d) {
          if (50 < zk) throw zk = 0, Ak = null, Error(p$6(185));
          Ac(a, c, d);
          if (0 === (K & 2) || a !== R$1) a === R$1 && (0 === (K & 2) && (rk |= c), 4 === T && Dk(a, Z$1)), Ek(a, d), 1 === c && 0 === K && 0 === (b.mode & 1) && (Hj = B$2() + 500, fg && jg());
        }
        function Ek(a, b) {
          var c = a.callbackNode;
          wc(a, b);
          var d = uc(a, a === R$1 ? Z$1 : 0);
          if (0 === d) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;else if (b = d & -d, a.callbackPriority !== b) {
            null != c && bc(c);
            if (1 === b) 0 === a.tag ? ig(Fk.bind(null, a)) : hg(Fk.bind(null, a)), Jf(function () {
              0 === (K & 6) && jg();
            }), c = null;else {
              switch (Dc(d)) {
                case 1:
                  c = fc;
                  break;
                case 4:
                  c = gc;
                  break;
                case 16:
                  c = hc;
                  break;
                case 536870912:
                  c = jc;
                  break;
                default:
                  c = hc;
              }
              c = Gk(c, Hk.bind(null, a));
            }
            a.callbackPriority = b;
            a.callbackNode = c;
          }
        }
        function Hk(a, b) {
          Bk = -1;
          Ck = 0;
          if (0 !== (K & 6)) throw Error(p$6(327));
          var c = a.callbackNode;
          if (Ik() && a.callbackNode !== c) return null;
          var d = uc(a, a === R$1 ? Z$1 : 0);
          if (0 === d) return null;
          if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Jk(a, d);else {
            b = d;
            var e = K;
            K |= 2;
            var f = Kk();
            if (R$1 !== a || Z$1 !== b) vk = null, Hj = B$2() + 500, Lk(a, b);
            do try {
              Mk();
              break;
            } catch (h) {
              Nk(a, h);
            } while (1);
            Qg();
            nk.current = f;
            K = e;
            null !== Y ? b = 0 : (R$1 = null, Z$1 = 0, b = T);
          }
          if (0 !== b) {
            2 === b && (e = xc(a), 0 !== e && (d = e, b = Ok(a, e)));
            if (1 === b) throw c = qk, Lk(a, 0), Dk(a, d), Ek(a, B$2()), c;
            if (6 === b) Dk(a, d);else {
              e = a.current.alternate;
              if (0 === (d & 30) && !Pk(e) && (b = Jk(a, d), 2 === b && (f = xc(a), 0 !== f && (d = f, b = Ok(a, f))), 1 === b)) throw c = qk, Lk(a, 0), Dk(a, d), Ek(a, B$2()), c;
              a.finishedWork = e;
              a.finishedLanes = d;
              switch (b) {
                case 0:
                case 1:
                  throw Error(p$6(345));
                case 2:
                  Qk(a, uk, vk);
                  break;
                case 3:
                  Dk(a, d);
                  if ((d & 130023424) === d && (b = gk + 500 - B$2(), 10 < b)) {
                    if (0 !== uc(a, 0)) break;
                    e = a.suspendedLanes;
                    if ((e & d) !== d) {
                      L$1();
                      a.pingedLanes |= a.suspendedLanes & e;
                      break;
                    }
                    a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), b);
                    break;
                  }
                  Qk(a, uk, vk);
                  break;
                case 4:
                  Dk(a, d);
                  if ((d & 4194240) === d) break;
                  b = a.eventTimes;
                  for (e = -1; 0 < d;) {
                    var g = 31 - oc(d);
                    f = 1 << g;
                    g = b[g];
                    g > e && (e = g);
                    d &= ~f;
                  }
                  d = e;
                  d = B$2() - d;
                  d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3E3 > d ? 3E3 : 4320 > d ? 4320 : 1960 * mk(d / 1960)) - d;
                  if (10 < d) {
                    a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), d);
                    break;
                  }
                  Qk(a, uk, vk);
                  break;
                case 5:
                  Qk(a, uk, vk);
                  break;
                default:
                  throw Error(p$6(329));
              }
            }
          }
          Ek(a, B$2());
          return a.callbackNode === c ? Hk.bind(null, a) : null;
        }
        function Ok(a, b) {
          var c = tk;
          a.current.memoizedState.isDehydrated && (Lk(a, b).flags |= 256);
          a = Jk(a, b);
          2 !== a && (b = uk, uk = c, null !== b && Gj(b));
          return a;
        }
        function Gj(a) {
          null === uk ? uk = a : uk.push.apply(uk, a);
        }
        function Pk(a) {
          for (var b = a;;) {
            if (b.flags & 16384) {
              var c = b.updateQueue;
              if (null !== c && (c = c.stores, null !== c)) for (var d = 0; d < c.length; d++) {
                var e = c[d],
                  f = e.getSnapshot;
                e = e.value;
                try {
                  if (!He(f(), e)) return !1;
                } catch (g) {
                  return !1;
                }
              }
            }
            c = b.child;
            if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;else {
              if (b === a) break;
              for (; null === b.sibling;) {
                if (null === b.return || b.return === a) return !0;
                b = b.return;
              }
              b.sibling.return = b.return;
              b = b.sibling;
            }
          }
          return !0;
        }
        function Dk(a, b) {
          b &= ~sk;
          b &= ~rk;
          a.suspendedLanes |= b;
          a.pingedLanes &= ~b;
          for (a = a.expirationTimes; 0 < b;) {
            var c = 31 - oc(b),
              d = 1 << c;
            a[c] = -1;
            b &= ~d;
          }
        }
        function Fk(a) {
          if (0 !== (K & 6)) throw Error(p$6(327));
          Ik();
          var b = uc(a, 0);
          if (0 === (b & 1)) return Ek(a, B$2()), null;
          var c = Jk(a, b);
          if (0 !== a.tag && 2 === c) {
            var d = xc(a);
            0 !== d && (b = d, c = Ok(a, d));
          }
          if (1 === c) throw c = qk, Lk(a, 0), Dk(a, b), Ek(a, B$2()), c;
          if (6 === c) throw Error(p$6(345));
          a.finishedWork = a.current.alternate;
          a.finishedLanes = b;
          Qk(a, uk, vk);
          Ek(a, B$2());
          return null;
        }
        function Rk(a, b) {
          var c = K;
          K |= 1;
          try {
            return a(b);
          } finally {
            K = c, 0 === K && (Hj = B$2() + 500, fg && jg());
          }
        }
        function Sk(a) {
          null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik();
          var b = K;
          K |= 1;
          var c = pk.transition,
            d = C$1;
          try {
            if (pk.transition = null, C$1 = 1, a) return a();
          } finally {
            C$1 = d, pk.transition = c, K = b, 0 === (K & 6) && jg();
          }
        }
        function Ij() {
          gj = fj.current;
          E$2(fj);
        }
        function Lk(a, b) {
          a.finishedWork = null;
          a.finishedLanes = 0;
          var c = a.timeoutHandle;
          -1 !== c && (a.timeoutHandle = -1, Gf(c));
          if (null !== Y) for (c = Y.return; null !== c;) {
            var d = c;
            wg(d);
            switch (d.tag) {
              case 1:
                d = d.type.childContextTypes;
                null !== d && void 0 !== d && $f();
                break;
              case 3:
                Jh();
                E$2(Wf);
                E$2(H$2);
                Oh();
                break;
              case 5:
                Lh(d);
                break;
              case 4:
                Jh();
                break;
              case 13:
                E$2(M$1);
                break;
              case 19:
                E$2(M$1);
                break;
              case 10:
                Rg(d.type._context);
                break;
              case 22:
              case 23:
                Ij();
            }
            c = c.return;
          }
          R$1 = a;
          Y = a = wh(a.current, null);
          Z$1 = gj = b;
          T = 0;
          qk = null;
          sk = rk = hh = 0;
          uk = tk = null;
          if (null !== Wg) {
            for (b = 0; b < Wg.length; b++) if (c = Wg[b], d = c.interleaved, null !== d) {
              c.interleaved = null;
              var e = d.next,
                f = c.pending;
              if (null !== f) {
                var g = f.next;
                f.next = e;
                d.next = g;
              }
              c.pending = d;
            }
            Wg = null;
          }
          return a;
        }
        function Nk(a, b) {
          do {
            var c = Y;
            try {
              Qg();
              Ph.current = ai;
              if (Sh) {
                for (var d = N$1.memoizedState; null !== d;) {
                  var e = d.queue;
                  null !== e && (e.pending = null);
                  d = d.next;
                }
                Sh = !1;
              }
              Rh = 0;
              P$1 = O$1 = N$1 = null;
              Th = !1;
              Uh = 0;
              ok$1.current = null;
              if (null === c || null === c.return) {
                T = 1;
                qk = b;
                Y = null;
                break;
              }
              a: {
                var f = a,
                  g = c.return,
                  h = c,
                  k = b;
                b = Z$1;
                h.flags |= 32768;
                if (null !== k && "object" === typeof k && "function" === typeof k.then) {
                  var l = k,
                    m = h,
                    q = m.tag;
                  if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
                    var r = m.alternate;
                    r ? (m.updateQueue = r.updateQueue, m.memoizedState = r.memoizedState, m.lanes = r.lanes) : (m.updateQueue = null, m.memoizedState = null);
                  }
                  var y = Vi(g);
                  if (null !== y) {
                    y.flags &= -257;
                    Wi(y, g, h, f, b);
                    y.mode & 1 && Ti(f, l, b);
                    b = y;
                    k = l;
                    var n = b.updateQueue;
                    if (null === n) {
                      var t = new Set();
                      t.add(k);
                      b.updateQueue = t;
                    } else n.add(k);
                    break a;
                  } else {
                    if (0 === (b & 1)) {
                      Ti(f, l, b);
                      uj();
                      break a;
                    }
                    k = Error(p$6(426));
                  }
                } else if (I$2 && h.mode & 1) {
                  var J = Vi(g);
                  if (null !== J) {
                    0 === (J.flags & 65536) && (J.flags |= 256);
                    Wi(J, g, h, f, b);
                    Jg(Ki(k, h));
                    break a;
                  }
                }
                f = k = Ki(k, h);
                4 !== T && (T = 2);
                null === tk ? tk = [f] : tk.push(f);
                f = g;
                do {
                  switch (f.tag) {
                    case 3:
                      f.flags |= 65536;
                      b &= -b;
                      f.lanes |= b;
                      var x = Oi(f, k, b);
                      fh(f, x);
                      break a;
                    case 1:
                      h = k;
                      var w = f.type,
                        u = f.stateNode;
                      if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Si || !Si.has(u)))) {
                        f.flags |= 65536;
                        b &= -b;
                        f.lanes |= b;
                        var F = Ri(f, h, b);
                        fh(f, F);
                        break a;
                      }
                  }
                  f = f.return;
                } while (null !== f);
              }
              Tk(c);
            } catch (na) {
              b = na;
              Y === c && null !== c && (Y = c = c.return);
              continue;
            }
            break;
          } while (1);
        }
        function Kk() {
          var a = nk.current;
          nk.current = ai;
          return null === a ? ai : a;
        }
        function uj() {
          if (0 === T || 3 === T || 2 === T) T = 4;
          null === R$1 || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R$1, Z$1);
        }
        function Jk(a, b) {
          var c = K;
          K |= 2;
          var d = Kk();
          if (R$1 !== a || Z$1 !== b) vk = null, Lk(a, b);
          do try {
            Uk();
            break;
          } catch (e) {
            Nk(a, e);
          } while (1);
          Qg();
          K = c;
          nk.current = d;
          if (null !== Y) throw Error(p$6(261));
          R$1 = null;
          Z$1 = 0;
          return T;
        }
        function Uk() {
          for (; null !== Y;) Vk(Y);
        }
        function Mk() {
          for (; null !== Y && !cc();) Vk(Y);
        }
        function Vk(a) {
          var b = Wk(a.alternate, a, gj);
          a.memoizedProps = a.pendingProps;
          null === b ? Tk(a) : Y = b;
          ok$1.current = null;
        }
        function Tk(a) {
          var b = a;
          do {
            var c = b.alternate;
            a = b.return;
            if (0 === (b.flags & 32768)) {
              if (c = Fj(c, b, gj), null !== c) {
                Y = c;
                return;
              }
            } else {
              c = Jj(c, b);
              if (null !== c) {
                c.flags &= 32767;
                Y = c;
                return;
              }
              if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;else {
                T = 6;
                Y = null;
                return;
              }
            }
            b = b.sibling;
            if (null !== b) {
              Y = b;
              return;
            }
            Y = b = a;
          } while (null !== b);
          0 === T && (T = 5);
        }
        function Qk(a, b, c) {
          var d = C$1,
            e = pk.transition;
          try {
            pk.transition = null, C$1 = 1, Xk(a, b, c, d);
          } finally {
            pk.transition = e, C$1 = d;
          }
          return null;
        }
        function Xk(a, b, c, d) {
          do Ik(); while (null !== xk);
          if (0 !== (K & 6)) throw Error(p$6(327));
          c = a.finishedWork;
          var e = a.finishedLanes;
          if (null === c) return null;
          a.finishedWork = null;
          a.finishedLanes = 0;
          if (c === a.current) throw Error(p$6(177));
          a.callbackNode = null;
          a.callbackPriority = 0;
          var f = c.lanes | c.childLanes;
          Bc(a, f);
          a === R$1 && (Y = R$1 = null, Z$1 = 0);
          0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || wk || (wk = !0, Gk(hc, function () {
            Ik();
            return null;
          }));
          f = 0 !== (c.flags & 15990);
          if (0 !== (c.subtreeFlags & 15990) || f) {
            f = pk.transition;
            pk.transition = null;
            var g = C$1;
            C$1 = 1;
            var h = K;
            K |= 4;
            ok$1.current = null;
            Pj(a, c);
            ek(c, a);
            Oe(Df);
            dd = !!Cf;
            Df = Cf = null;
            a.current = c;
            ik(c);
            dc();
            K = h;
            C$1 = g;
            pk.transition = f;
          } else a.current = c;
          wk && (wk = !1, xk = a, yk = e);
          f = a.pendingLanes;
          0 === f && (Si = null);
          mc(c.stateNode);
          Ek(a, B$2());
          if (null !== b) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d(e.value, {
            componentStack: e.stack,
            digest: e.digest
          });
          if (Pi) throw Pi = !1, a = Qi, Qi = null, a;
          0 !== (yk & 1) && 0 !== a.tag && Ik();
          f = a.pendingLanes;
          0 !== (f & 1) ? a === Ak ? zk++ : (zk = 0, Ak = a) : zk = 0;
          jg();
          return null;
        }
        function Ik() {
          if (null !== xk) {
            var a = Dc(yk),
              b = pk.transition,
              c = C$1;
            try {
              pk.transition = null;
              C$1 = 16 > a ? 16 : a;
              if (null === xk) var d = !1;else {
                a = xk;
                xk = null;
                yk = 0;
                if (0 !== (K & 6)) throw Error(p$6(331));
                var e = K;
                K |= 4;
                for (V = a.current; null !== V;) {
                  var f = V,
                    g = f.child;
                  if (0 !== (V.flags & 16)) {
                    var h = f.deletions;
                    if (null !== h) {
                      for (var k = 0; k < h.length; k++) {
                        var l = h[k];
                        for (V = l; null !== V;) {
                          var m = V;
                          switch (m.tag) {
                            case 0:
                            case 11:
                            case 15:
                              Qj(8, m, f);
                          }
                          var q = m.child;
                          if (null !== q) q.return = m, V = q;else for (; null !== V;) {
                            m = V;
                            var r = m.sibling,
                              y = m.return;
                            Tj(m);
                            if (m === l) {
                              V = null;
                              break;
                            }
                            if (null !== r) {
                              r.return = y;
                              V = r;
                              break;
                            }
                            V = y;
                          }
                        }
                      }
                      var n = f.alternate;
                      if (null !== n) {
                        var t = n.child;
                        if (null !== t) {
                          n.child = null;
                          do {
                            var J = t.sibling;
                            t.sibling = null;
                            t = J;
                          } while (null !== t);
                        }
                      }
                      V = f;
                    }
                  }
                  if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V = g;else b: for (; null !== V;) {
                    f = V;
                    if (0 !== (f.flags & 2048)) switch (f.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Qj(9, f, f.return);
                    }
                    var x = f.sibling;
                    if (null !== x) {
                      x.return = f.return;
                      V = x;
                      break b;
                    }
                    V = f.return;
                  }
                }
                var w = a.current;
                for (V = w; null !== V;) {
                  g = V;
                  var u = g.child;
                  if (0 !== (g.subtreeFlags & 2064) && null !== u) u.return = g, V = u;else b: for (g = w; null !== V;) {
                    h = V;
                    if (0 !== (h.flags & 2048)) try {
                      switch (h.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Rj(9, h);
                      }
                    } catch (na) {
                      W$1(h, h.return, na);
                    }
                    if (h === g) {
                      V = null;
                      break b;
                    }
                    var F = h.sibling;
                    if (null !== F) {
                      F.return = h.return;
                      V = F;
                      break b;
                    }
                    V = h.return;
                  }
                }
                K = e;
                jg();
                if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
                  lc.onPostCommitFiberRoot(kc, a);
                } catch (na) {}
                d = !0;
              }
              return d;
            } finally {
              C$1 = c, pk.transition = b;
            }
          }
          return !1;
        }
        function Yk(a, b, c) {
          b = Ki(c, b);
          b = Oi(a, b, 1);
          a = dh(a, b, 1);
          b = L$1();
          null !== a && (Ac(a, 1, b), Ek(a, b));
        }
        function W$1(a, b, c) {
          if (3 === a.tag) Yk(a, a, c);else for (; null !== b;) {
            if (3 === b.tag) {
              Yk(b, a, c);
              break;
            } else if (1 === b.tag) {
              var d = b.stateNode;
              if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Si || !Si.has(d))) {
                a = Ki(c, a);
                a = Ri(b, a, 1);
                b = dh(b, a, 1);
                a = L$1();
                null !== b && (Ac(b, 1, a), Ek(b, a));
                break;
              }
            }
            b = b.return;
          }
        }
        function Ui(a, b, c) {
          var d = a.pingCache;
          null !== d && d.delete(b);
          b = L$1();
          a.pingedLanes |= a.suspendedLanes & c;
          R$1 === a && (Z$1 & c) === c && (4 === T || 3 === T && (Z$1 & 130023424) === Z$1 && 500 > B$2() - gk ? Lk(a, 0) : sk |= c);
          Ek(a, b);
        }
        function Zk(a, b) {
          0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
          var c = L$1();
          a = Zg(a, b);
          null !== a && (Ac(a, b, c), Ek(a, c));
        }
        function vj(a) {
          var b = a.memoizedState,
            c = 0;
          null !== b && (c = b.retryLane);
          Zk(a, c);
        }
        function ck(a, b) {
          var c = 0;
          switch (a.tag) {
            case 13:
              var d = a.stateNode;
              var e = a.memoizedState;
              null !== e && (c = e.retryLane);
              break;
            case 19:
              d = a.stateNode;
              break;
            default:
              throw Error(p$6(314));
          }
          null !== d && d.delete(b);
          Zk(a, c);
        }
        var Wk;
        Wk = function (a, b, c) {
          if (null !== a) {
            if (a.memoizedProps !== b.pendingProps || Wf.current) Ug = !0;else {
              if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return Ug = !1, zj(a, b, c);
              Ug = 0 !== (a.flags & 131072) ? !0 : !1;
            }
          } else Ug = !1, I$2 && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
          b.lanes = 0;
          switch (b.tag) {
            case 2:
              var d = b.type;
              jj(a, b);
              a = b.pendingProps;
              var e = Yf(b, H$2.current);
              Tg(b, c);
              e = Xh(null, b, d, a, e, c);
              var f = bi();
              b.flags |= 1;
              "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = !0, cg(b)) : f = !1, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, ah(b), e.updater = nh, b.stateNode = e, e._reactInternals = b, rh(b, d, a, c), b = kj(null, b, d, !0, f, c)) : (b.tag = 0, I$2 && f && vg(b), Yi(null, b, e, c), b = b.child);
              return b;
            case 16:
              d = b.elementType;
              a: {
                jj(a, b);
                a = b.pendingProps;
                e = d._init;
                d = e(d._payload);
                b.type = d;
                e = b.tag = $k(d);
                a = Lg(d, a);
                switch (e) {
                  case 0:
                    b = dj(null, b, d, a, c);
                    break a;
                  case 1:
                    b = ij(null, b, d, a, c);
                    break a;
                  case 11:
                    b = Zi(null, b, d, a, c);
                    break a;
                  case 14:
                    b = aj(null, b, d, Lg(d.type, a), c);
                    break a;
                }
                throw Error(p$6(306, d, ""));
              }
              return b;
            case 0:
              return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), dj(a, b, d, e, c);
            case 1:
              return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), ij(a, b, d, e, c);
            case 3:
              a: {
                lj(b);
                if (null === a) throw Error(p$6(387));
                d = b.pendingProps;
                f = b.memoizedState;
                e = f.element;
                bh(a, b);
                gh(b, d, null, c);
                var g = b.memoizedState;
                d = g.element;
                if (f.isDehydrated) {
                  if (f = {
                    element: d,
                    isDehydrated: !1,
                    cache: g.cache,
                    pendingSuspenseBoundaries: g.pendingSuspenseBoundaries,
                    transitions: g.transitions
                  }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
                    e = Ki(Error(p$6(423)), b);
                    b = mj(a, b, d, c, e);
                    break a;
                  } else if (d !== e) {
                    e = Ki(Error(p$6(424)), b);
                    b = mj(a, b, d, c, e);
                    break a;
                  } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I$2 = !0, zg = null, c = Ch(b, null, d, c), b.child = c; c;) c.flags = c.flags & -3 | 4096, c = c.sibling;
                } else {
                  Ig();
                  if (d === e) {
                    b = $i(a, b, c);
                    break a;
                  }
                  Yi(a, b, d, c);
                }
                b = b.child;
              }
              return b;
            case 5:
              return Kh(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f && Ef(d, f) && (b.flags |= 32), hj(a, b), Yi(a, b, g, c), b.child;
            case 6:
              return null === a && Eg(b), null;
            case 13:
              return pj(a, b, c);
            case 4:
              return Ih(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Bh(b, null, d, c) : Yi(a, b, d, c), b.child;
            case 11:
              return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), Zi(a, b, d, e, c);
            case 7:
              return Yi(a, b, b.pendingProps, c), b.child;
            case 8:
              return Yi(a, b, b.pendingProps.children, c), b.child;
            case 12:
              return Yi(a, b, b.pendingProps.children, c), b.child;
            case 10:
              a: {
                d = b.type._context;
                e = b.pendingProps;
                f = b.memoizedProps;
                g = e.value;
                G$2(Mg, d._currentValue);
                d._currentValue = g;
                if (null !== f) if (He(f.value, g)) {
                  if (f.children === e.children && !Wf.current) {
                    b = $i(a, b, c);
                    break a;
                  }
                } else for (f = b.child, null !== f && (f.return = b); null !== f;) {
                  var h = f.dependencies;
                  if (null !== h) {
                    g = f.child;
                    for (var k = h.firstContext; null !== k;) {
                      if (k.context === d) {
                        if (1 === f.tag) {
                          k = ch(-1, c & -c);
                          k.tag = 2;
                          var l = f.updateQueue;
                          if (null !== l) {
                            l = l.shared;
                            var m = l.pending;
                            null === m ? k.next = k : (k.next = m.next, m.next = k);
                            l.pending = k;
                          }
                        }
                        f.lanes |= c;
                        k = f.alternate;
                        null !== k && (k.lanes |= c);
                        Sg(f.return, c, b);
                        h.lanes |= c;
                        break;
                      }
                      k = k.next;
                    }
                  } else if (10 === f.tag) g = f.type === b.type ? null : f.child;else if (18 === f.tag) {
                    g = f.return;
                    if (null === g) throw Error(p$6(341));
                    g.lanes |= c;
                    h = g.alternate;
                    null !== h && (h.lanes |= c);
                    Sg(g, c, b);
                    g = f.sibling;
                  } else g = f.child;
                  if (null !== g) g.return = f;else for (g = f; null !== g;) {
                    if (g === b) {
                      g = null;
                      break;
                    }
                    f = g.sibling;
                    if (null !== f) {
                      f.return = g.return;
                      g = f;
                      break;
                    }
                    g = g.return;
                  }
                  f = g;
                }
                Yi(a, b, e.children, c);
                b = b.child;
              }
              return b;
            case 9:
              return e = b.type, d = b.pendingProps.children, Tg(b, c), e = Vg(e), d = d(e), b.flags |= 1, Yi(a, b, d, c), b.child;
            case 14:
              return d = b.type, e = Lg(d, b.pendingProps), e = Lg(d.type, e), aj(a, b, d, e, c);
            case 15:
              return cj(a, b, b.type, b.pendingProps, c);
            case 17:
              return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), jj(a, b), b.tag = 1, Zf(d) ? (a = !0, cg(b)) : a = !1, Tg(b, c), ph(b, d, e), rh(b, d, e, c), kj(null, b, d, !0, a, c);
            case 19:
              return yj(a, b, c);
            case 22:
              return ej(a, b, c);
          }
          throw Error(p$6(156, b.tag));
        };
        function Gk(a, b) {
          return ac(a, b);
        }
        function al(a, b, c, d) {
          this.tag = a;
          this.key = c;
          this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
          this.index = 0;
          this.ref = null;
          this.pendingProps = b;
          this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
          this.mode = d;
          this.subtreeFlags = this.flags = 0;
          this.deletions = null;
          this.childLanes = this.lanes = 0;
          this.alternate = null;
        }
        function Bg(a, b, c, d) {
          return new al(a, b, c, d);
        }
        function bj(a) {
          a = a.prototype;
          return !(!a || !a.isReactComponent);
        }
        function $k(a) {
          if ("function" === typeof a) return bj(a) ? 1 : 0;
          if (void 0 !== a && null !== a) {
            a = a.$$typeof;
            if (a === Da) return 11;
            if (a === Ga) return 14;
          }
          return 2;
        }
        function wh(a, b) {
          var c = a.alternate;
          null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
          c.flags = a.flags & 14680064;
          c.childLanes = a.childLanes;
          c.lanes = a.lanes;
          c.child = a.child;
          c.memoizedProps = a.memoizedProps;
          c.memoizedState = a.memoizedState;
          c.updateQueue = a.updateQueue;
          b = a.dependencies;
          c.dependencies = null === b ? null : {
            lanes: b.lanes,
            firstContext: b.firstContext
          };
          c.sibling = a.sibling;
          c.index = a.index;
          c.ref = a.ref;
          return c;
        }
        function yh(a, b, c, d, e, f) {
          var g = 2;
          d = a;
          if ("function" === typeof a) bj(a) && (g = 1);else if ("string" === typeof a) g = 5;else a: switch (a) {
            case ya:
              return Ah(c.children, e, f, b);
            case za:
              g = 8;
              e |= 8;
              break;
            case Aa:
              return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;
            case Ea:
              return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;
            case Fa:
              return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f, a;
            case Ia:
              return qj(c, e, f, b);
            default:
              if ("object" === typeof a && null !== a) switch (a.$$typeof) {
                case Ba:
                  g = 10;
                  break a;
                case Ca:
                  g = 9;
                  break a;
                case Da:
                  g = 11;
                  break a;
                case Ga:
                  g = 14;
                  break a;
                case Ha:
                  g = 16;
                  d = null;
                  break a;
              }
              throw Error(p$6(130, null == a ? a : typeof a, ""));
          }
          b = Bg(g, c, b, e);
          b.elementType = a;
          b.type = d;
          b.lanes = f;
          return b;
        }
        function Ah(a, b, c, d) {
          a = Bg(7, a, d, b);
          a.lanes = c;
          return a;
        }
        function qj(a, b, c, d) {
          a = Bg(22, a, d, b);
          a.elementType = Ia;
          a.lanes = c;
          a.stateNode = {
            isHidden: !1
          };
          return a;
        }
        function xh(a, b, c) {
          a = Bg(6, a, null, b);
          a.lanes = c;
          return a;
        }
        function zh(a, b, c) {
          b = Bg(4, null !== a.children ? a.children : [], a.key, b);
          b.lanes = c;
          b.stateNode = {
            containerInfo: a.containerInfo,
            pendingChildren: null,
            implementation: a.implementation
          };
          return b;
        }
        function bl(a, b, c, d, e) {
          this.tag = b;
          this.containerInfo = a;
          this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
          this.timeoutHandle = -1;
          this.callbackNode = this.pendingContext = this.context = null;
          this.callbackPriority = 0;
          this.eventTimes = zc(0);
          this.expirationTimes = zc(-1);
          this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
          this.entanglements = zc(0);
          this.identifierPrefix = d;
          this.onRecoverableError = e;
          this.mutableSourceEagerHydrationData = null;
        }
        function cl(a, b, c, d, e, f, g, h, k) {
          a = new bl(a, b, c, h, k);
          1 === b ? (b = 1, !0 === f && (b |= 8)) : b = 0;
          f = Bg(3, null, null, b);
          a.current = f;
          f.stateNode = a;
          f.memoizedState = {
            element: d,
            isDehydrated: c,
            cache: null,
            transitions: null,
            pendingSuspenseBoundaries: null
          };
          ah(f);
          return a;
        }
        function dl(a, b, c) {
          var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
          return {
            $$typeof: wa,
            key: null == d ? null : "" + d,
            children: a,
            containerInfo: b,
            implementation: c
          };
        }
        function el(a) {
          if (!a) return Vf;
          a = a._reactInternals;
          a: {
            if (Vb(a) !== a || 1 !== a.tag) throw Error(p$6(170));
            var b = a;
            do {
              switch (b.tag) {
                case 3:
                  b = b.stateNode.context;
                  break a;
                case 1:
                  if (Zf(b.type)) {
                    b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                    break a;
                  }
              }
              b = b.return;
            } while (null !== b);
            throw Error(p$6(171));
          }
          if (1 === a.tag) {
            var c = a.type;
            if (Zf(c)) return bg(a, c, b);
          }
          return b;
        }
        function fl(a, b, c, d, e, f, g, h, k) {
          a = cl(c, d, !0, a, e, f, g, h, k);
          a.context = el(null);
          c = a.current;
          d = L$1();
          e = lh(c);
          f = ch(d, e);
          f.callback = void 0 !== b && null !== b ? b : null;
          dh(c, f, e);
          a.current.lanes = e;
          Ac(a, e, d);
          Ek(a, d);
          return a;
        }
        function gl(a, b, c, d) {
          var e = b.current,
            f = L$1(),
            g = lh(e);
          c = el(c);
          null === b.context ? b.context = c : b.pendingContext = c;
          b = ch(f, g);
          b.payload = {
            element: a
          };
          d = void 0 === d ? null : d;
          null !== d && (b.callback = d);
          a = dh(e, b, g);
          null !== a && (mh(a, e, g, f), eh(a, e, g));
          return g;
        }
        function hl(a) {
          a = a.current;
          if (!a.child) return null;
          switch (a.child.tag) {
            case 5:
              return a.child.stateNode;
            default:
              return a.child.stateNode;
          }
        }
        function il(a, b) {
          a = a.memoizedState;
          if (null !== a && null !== a.dehydrated) {
            var c = a.retryLane;
            a.retryLane = 0 !== c && c < b ? c : b;
          }
        }
        function jl(a, b) {
          il(a, b);
          (a = a.alternate) && il(a, b);
        }
        function kl() {
          return null;
        }
        var ll = "function" === typeof reportError ? reportError : function (a) {
          console.error(a);
        };
        function ml(a) {
          this._internalRoot = a;
        }
        nl.prototype.render = ml.prototype.render = function (a) {
          var b = this._internalRoot;
          if (null === b) throw Error(p$6(409));
          gl(a, b, null, null);
        };
        nl.prototype.unmount = ml.prototype.unmount = function () {
          var a = this._internalRoot;
          if (null !== a) {
            this._internalRoot = null;
            var b = a.containerInfo;
            Sk(function () {
              gl(null, a, null, null);
            });
            b[uf] = null;
          }
        };
        function nl(a) {
          this._internalRoot = a;
        }
        nl.prototype.unstable_scheduleHydration = function (a) {
          if (a) {
            var b = Hc();
            a = {
              blockedOn: null,
              target: a,
              priority: b
            };
            for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++);
            Qc.splice(c, 0, a);
            0 === c && Vc(a);
          }
        };
        function ol(a) {
          return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
        }
        function pl(a) {
          return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
        }
        function ql() {}
        function rl(a, b, c, d, e) {
          if (e) {
            if ("function" === typeof d) {
              var f = d;
              d = function () {
                var a = hl(g);
                f.call(a);
              };
            }
            var g = fl(b, d, a, 0, null, !1, !1, "", ql);
            a._reactRootContainer = g;
            a[uf] = g.current;
            sf(8 === a.nodeType ? a.parentNode : a);
            Sk();
            return g;
          }
          for (; e = a.lastChild;) a.removeChild(e);
          if ("function" === typeof d) {
            var h = d;
            d = function () {
              var a = hl(k);
              h.call(a);
            };
          }
          var k = cl(a, 0, !1, null, null, !1, !1, "", ql);
          a._reactRootContainer = k;
          a[uf] = k.current;
          sf(8 === a.nodeType ? a.parentNode : a);
          Sk(function () {
            gl(b, k, c, d);
          });
          return k;
        }
        function sl(a, b, c, d, e) {
          var f = c._reactRootContainer;
          if (f) {
            var g = f;
            if ("function" === typeof e) {
              var h = e;
              e = function () {
                var a = hl(g);
                h.call(a);
              };
            }
            gl(b, g, a, e);
          } else g = rl(c, b, a, e, d);
          return hl(g);
        }
        Ec = function (a) {
          switch (a.tag) {
            case 3:
              var b = a.stateNode;
              if (b.current.memoizedState.isDehydrated) {
                var c = tc(b.pendingLanes);
                0 !== c && (Cc(b, c | 1), Ek(b, B$2()), 0 === (K & 6) && (Hj = B$2() + 500, jg()));
              }
              break;
            case 13:
              Sk(function () {
                var b = Zg(a, 1);
                if (null !== b) {
                  var c = L$1();
                  mh(b, a, 1, c);
                }
              }), jl(a, 1);
          }
        };
        Fc = function (a) {
          if (13 === a.tag) {
            var b = Zg(a, 134217728);
            if (null !== b) {
              var c = L$1();
              mh(b, a, 134217728, c);
            }
            jl(a, 134217728);
          }
        };
        Gc = function (a) {
          if (13 === a.tag) {
            var b = lh(a),
              c = Zg(a, b);
            if (null !== c) {
              var d = L$1();
              mh(c, a, b, d);
            }
            jl(a, b);
          }
        };
        Hc = function () {
          return C$1;
        };
        Ic = function (a, b) {
          var c = C$1;
          try {
            return C$1 = a, b();
          } finally {
            C$1 = c;
          }
        };
        yb = function (a, b, c) {
          switch (b) {
            case "input":
              bb(a, c);
              b = c.name;
              if ("radio" === c.type && null != b) {
                for (c = a; c.parentNode;) c = c.parentNode;
                c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
                for (b = 0; b < c.length; b++) {
                  var d = c[b];
                  if (d !== a && d.form === a.form) {
                    var e = Db(d);
                    if (!e) throw Error(p$6(90));
                    Wa(d);
                    bb(d, e);
                  }
                }
              }
              break;
            case "textarea":
              ib(a, c);
              break;
            case "select":
              b = c.value, null != b && fb(a, !!c.multiple, b, !1);
          }
        };
        Gb = Rk;
        Hb = Sk;
        var tl = {
            usingClientEntryPoint: !1,
            Events: [Cb, ue, Db, Eb, Fb, Rk]
          },
          ul = {
            findFiberByHostInstance: Wc,
            bundleType: 0,
            version: "18.2.0",
            rendererPackageName: "react-dom"
          };
        var vl = {
          bundleType: ul.bundleType,
          version: ul.version,
          rendererPackageName: ul.rendererPackageName,
          rendererConfig: ul.rendererConfig,
          overrideHookState: null,
          overrideHookStateDeletePath: null,
          overrideHookStateRenamePath: null,
          overrideProps: null,
          overridePropsDeletePath: null,
          overridePropsRenamePath: null,
          setErrorHandler: null,
          setSuspenseHandler: null,
          scheduleUpdate: null,
          currentDispatcherRef: ua.ReactCurrentDispatcher,
          findHostInstanceByFiber: function (a) {
            a = Zb(a);
            return null === a ? null : a.stateNode;
          },
          findFiberByHostInstance: ul.findFiberByHostInstance || kl,
          findHostInstancesForRefresh: null,
          scheduleRefresh: null,
          scheduleRoot: null,
          setRefreshHandler: null,
          getCurrentFiber: null,
          reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
        };
        if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
          var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (!wl.isDisabled && wl.supportsFiber) try {
            kc = wl.inject(vl), lc = wl;
          } catch (a) {}
        }
        reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
        reactDom_production_min.createPortal = function (a, b) {
          var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
          if (!ol(b)) throw Error(p$6(200));
          return dl(a, b, null, c);
        };
        reactDom_production_min.createRoot = function (a, b) {
          if (!ol(a)) throw Error(p$6(299));
          var c = !1,
            d = "",
            e = ll;
          null !== b && void 0 !== b && (!0 === b.unstable_strictMode && (c = !0), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
          b = cl(a, 1, !1, null, null, c, !1, d, e);
          a[uf] = b.current;
          sf(8 === a.nodeType ? a.parentNode : a);
          return new ml(b);
        };
        reactDom_production_min.findDOMNode = function (a) {
          if (null == a) return null;
          if (1 === a.nodeType) return a;
          var b = a._reactInternals;
          if (void 0 === b) {
            if ("function" === typeof a.render) throw Error(p$6(188));
            a = Object.keys(a).join(",");
            throw Error(p$6(268, a));
          }
          a = Zb(b);
          a = null === a ? null : a.stateNode;
          return a;
        };
        reactDom_production_min.flushSync = function (a) {
          return Sk(a);
        };
        reactDom_production_min.hydrate = function (a, b, c) {
          if (!pl(b)) throw Error(p$6(200));
          return sl(null, a, b, !0, c);
        };
        reactDom_production_min.hydrateRoot = function (a, b, c) {
          if (!ol(a)) throw Error(p$6(405));
          var d = null != c && c.hydratedSources || null,
            e = !1,
            f = "",
            g = ll;
          null !== c && void 0 !== c && (!0 === c.unstable_strictMode && (e = !0), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
          b = fl(b, null, a, 1, null != c ? c : null, e, !1, f, g);
          a[uf] = b.current;
          sf(a);
          if (d) for (a = 0; a < d.length; a++) c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(c, e);
          return new nl(b);
        };
        reactDom_production_min.render = function (a, b, c) {
          if (!pl(b)) throw Error(p$6(200));
          return sl(null, a, b, !1, c);
        };
        reactDom_production_min.unmountComponentAtNode = function (a) {
          if (!pl(a)) throw Error(p$6(40));
          return a._reactRootContainer ? (Sk(function () {
            sl(null, null, a, !1, function () {
              a._reactRootContainer = null;
              a[uf] = null;
            });
          }), !0) : !1;
        };
        reactDom_production_min.unstable_batchedUpdates = Rk;
        reactDom_production_min.unstable_renderSubtreeIntoContainer = function (a, b, c, d) {
          if (!pl(c)) throw Error(p$6(200));
          if (null == a || void 0 === a._reactInternals) throw Error(p$6(38));
          return sl(a, b, c, !1, d);
        };
        reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
        function checkDCE() {
          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
            return;
          }
          try {
            // Verify that the code above has been dead code eliminated (DCE'd).
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
          } catch (err) {
            // DevTools shouldn't crash React, no matter what.
            // We should still report in case we break this code.
            console.error(err);
          }
        }
        {
          // DCE check should happen before ReactDOM bundle executes so that
          // DevTools can report bad minification during injection.
          checkDCE();
          reactDom.exports = reactDom_production_min;
        }
        var reactDomExports = exports('aJ', reactDom.exports);
        const ReactDOM = exports('c0', /*@__PURE__*/getDefaultExportFromCjs(reactDomExports));
        var createRoot;
        var m$5 = reactDomExports;
        {
          createRoot = m$5.createRoot;
          m$5.hydrateRoot;
        }

        /**
         * @remix-run/router v1.5.0
         *
         * Copyright (c) Remix Software Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE.md file in the root directory of this source tree.
         *
         * @license MIT
         */
        function _extends$2() {
          _extends$2 = Object.assign ? Object.assign.bind() : function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          return _extends$2.apply(this, arguments);
        }

        ////////////////////////////////////////////////////////////////////////////////
        //#region Types and Constants
        ////////////////////////////////////////////////////////////////////////////////

        /**
         * Actions represent the type of change to a location value.
         */
        var Action;
        (function (Action) {
          /**
           * A POP indicates a change to an arbitrary index in the history stack, such
           * as a back or forward navigation. It does not describe the direction of the
           * navigation, only that the current index changed.
           *
           * Note: This is the default action for newly created history objects.
           */
          Action["Pop"] = "POP";
          /**
           * A PUSH indicates a new entry being added to the history stack, such as when
           * a link is clicked and a new page loads. When this happens, all subsequent
           * entries in the stack are lost.
           */

          Action["Push"] = "PUSH";
          /**
           * A REPLACE indicates the entry at the current index in the history stack
           * being replaced by a new one.
           */

          Action["Replace"] = "REPLACE";
        })(Action || (Action = {}));
        const PopStateEventType = "popstate";
        /**
         * Browser history stores the location in regular URLs. This is the standard for
         * most web apps, but it requires some configuration on the server to ensure you
         * serve the same app at multiple URLs.
         *
         * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory
         */

        function createBrowserHistory(options) {
          if (options === void 0) {
            options = {};
          }
          function createBrowserLocation(window, globalHistory) {
            let {
              pathname,
              search,
              hash
            } = window.location;
            return createLocation("", {
              pathname,
              search,
              hash
            },
            // state defaults to `null` because `window.history.state` does
            globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
          }
          function createBrowserHref(window, to) {
            return typeof to === "string" ? to : createPath(to);
          }
          return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
        }
        function invariant$2(value, message) {
          if (value === false || value === null || typeof value === "undefined") {
            throw new Error(message);
          }
        }
        function createKey() {
          return Math.random().toString(36).substr(2, 8);
        }
        /**
         * For browser-based histories, we combine the state and key into an object
         */

        function getHistoryState(location, index) {
          return {
            usr: location.state,
            key: location.key,
            idx: index
          };
        }
        /**
         * Creates a Location object with a unique key from the given Path
         */

        function createLocation(current, to, state, key) {
          if (state === void 0) {
            state = null;
          }
          let location = _extends$2({
            pathname: typeof current === "string" ? current : current.pathname,
            search: "",
            hash: ""
          }, typeof to === "string" ? parsePath(to) : to, {
            state,
            // TODO: This could be cleaned up.  push/replace should probably just take
            // full Locations now and avoid the need to run through this flow at all
            // But that's a pretty big refactor to the current test suite so going to
            // keep as is for the time being and just let any incoming keys take precedence
            key: to && to.key || key || createKey()
          });
          return location;
        }
        /**
         * Creates a string URL path from the given pathname, search, and hash components.
         */

        function createPath(_ref) {
          let {
            pathname = "/",
            search = "",
            hash = ""
          } = _ref;
          if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
          if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
          return pathname;
        }
        /**
         * Parses a string URL path into its separate pathname, search, and hash components.
         */

        function parsePath(path) {
          let parsedPath = {};
          if (path) {
            let hashIndex = path.indexOf("#");
            if (hashIndex >= 0) {
              parsedPath.hash = path.substr(hashIndex);
              path = path.substr(0, hashIndex);
            }
            let searchIndex = path.indexOf("?");
            if (searchIndex >= 0) {
              parsedPath.search = path.substr(searchIndex);
              path = path.substr(0, searchIndex);
            }
            if (path) {
              parsedPath.pathname = path;
            }
          }
          return parsedPath;
        }
        function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
          if (options === void 0) {
            options = {};
          }
          let {
            window = document.defaultView,
            v5Compat = false
          } = options;
          let globalHistory = window.history;
          let action = Action.Pop;
          let listener = null;
          let index = getIndex(); // Index should only be null when we initialize. If not, it's because the
          // user called history.pushState or history.replaceState directly, in which
          // case we should log a warning as it will result in bugs.

          if (index == null) {
            index = 0;
            globalHistory.replaceState(_extends$2({}, globalHistory.state, {
              idx: index
            }), "");
          }
          function getIndex() {
            let state = globalHistory.state || {
              idx: null
            };
            return state.idx;
          }
          function handlePop() {
            action = Action.Pop;
            let nextIndex = getIndex();
            let delta = nextIndex == null ? null : nextIndex - index;
            index = nextIndex;
            if (listener) {
              listener({
                action,
                location: history.location,
                delta
              });
            }
          }
          function push(to, state) {
            action = Action.Push;
            let location = createLocation(history.location, to, state);
            if (validateLocation) validateLocation(location, to);
            index = getIndex() + 1;
            let historyState = getHistoryState(location, index);
            let url = history.createHref(location); // try...catch because iOS limits us to 100 pushState calls :/

            try {
              globalHistory.pushState(historyState, "", url);
            } catch (error) {
              // They are going to lose state here, but there is no real
              // way to warn them about it since the page will refresh...
              window.location.assign(url);
            }
            if (v5Compat && listener) {
              listener({
                action,
                location: history.location,
                delta: 1
              });
            }
          }
          function replace(to, state) {
            action = Action.Replace;
            let location = createLocation(history.location, to, state);
            if (validateLocation) validateLocation(location, to);
            index = getIndex();
            let historyState = getHistoryState(location, index);
            let url = history.createHref(location);
            globalHistory.replaceState(historyState, "", url);
            if (v5Compat && listener) {
              listener({
                action,
                location: history.location,
                delta: 0
              });
            }
          }
          function createURL(to) {
            // window.location.origin is "null" (the literal string value) in Firefox
            // under certain conditions, notably when serving from a local HTML file
            // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297
            let base = window.location.origin !== "null" ? window.location.origin : window.location.href;
            let href = typeof to === "string" ? to : createPath(to);
            invariant$2(base, "No window.location.(origin|href) available to create URL for href: " + href);
            return new URL(href, base);
          }
          let history = {
            get action() {
              return action;
            },
            get location() {
              return getLocation(window, globalHistory);
            },
            listen(fn) {
              if (listener) {
                throw new Error("A history only accepts one active listener");
              }
              window.addEventListener(PopStateEventType, handlePop);
              listener = fn;
              return () => {
                window.removeEventListener(PopStateEventType, handlePop);
                listener = null;
              };
            },
            createHref(to) {
              return createHref(window, to);
            },
            createURL,
            encodeLocation(to) {
              // Encode a Location the same way window.location would
              let url = createURL(to);
              return {
                pathname: url.pathname,
                search: url.search,
                hash: url.hash
              };
            },
            push,
            replace,
            go(n) {
              return globalHistory.go(n);
            }
          };
          return history;
        } //#endregion

        var ResultType;
        (function (ResultType) {
          ResultType["data"] = "data";
          ResultType["deferred"] = "deferred";
          ResultType["redirect"] = "redirect";
          ResultType["error"] = "error";
        })(ResultType || (ResultType = {}));
        new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
        /**
         * @private
         */

        function stripBasename(pathname, basename) {
          if (basename === "/") return pathname;
          if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
            return null;
          } // We want to leave trailing slash behavior in the user's control, so if they
          // specify a basename with a trailing slash, we should support it

          let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
          let nextChar = pathname.charAt(startIndex);
          if (nextChar && nextChar !== "/") {
            // pathname does not start with basename/
            return null;
          }
          return pathname.slice(startIndex) || "/";
        }
        /**
         * Returns a resolved path object relative to the given pathname.
         *
         * @see https://reactrouter.com/utils/resolve-path
         */

        function resolvePath(to, fromPathname) {
          if (fromPathname === void 0) {
            fromPathname = "/";
          }
          let {
            pathname: toPathname,
            search = "",
            hash = ""
          } = typeof to === "string" ? parsePath(to) : to;
          let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
          return {
            pathname,
            search: normalizeSearch(search),
            hash: normalizeHash(hash)
          };
        }
        function resolvePathname(relativePath, fromPathname) {
          let segments = fromPathname.replace(/\/+$/, "").split("/");
          let relativeSegments = relativePath.split("/");
          relativeSegments.forEach(segment => {
            if (segment === "..") {
              // Keep the root "" segment so the pathname starts at /
              if (segments.length > 1) segments.pop();
            } else if (segment !== ".") {
              segments.push(segment);
            }
          });
          return segments.length > 1 ? segments.join("/") : "/";
        }
        function getInvalidPathError(char, field, dest, path) {
          return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + "a string in <Link to=\"...\"> and the router will parse it for you.";
        }
        /**
         * @private
         *
         * When processing relative navigation we want to ignore ancestor routes that
         * do not contribute to the path, such that index/pathless layout routes don't
         * interfere.
         *
         * For example, when moving a route element into an index route and/or a
         * pathless layout route, relative link behavior contained within should stay
         * the same.  Both of the following examples should link back to the root:
         *
         *   <Route path="/">
         *     <Route path="accounts" element={<Link to=".."}>
         *   </Route>
         *
         *   <Route path="/">
         *     <Route path="accounts">
         *       <Route element={<AccountsLayout />}>       // <-- Does not contribute
         *         <Route index element={<Link to=".."} />  // <-- Does not contribute
         *       </Route
         *     </Route>
         *   </Route>
         */

        function getPathContributingMatches(matches) {
          return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);
        }
        /**
         * @private
         */

        function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
          if (isPathRelative === void 0) {
            isPathRelative = false;
          }
          let to;
          if (typeof toArg === "string") {
            to = parsePath(toArg);
          } else {
            to = _extends$2({}, toArg);
            invariant$2(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
            invariant$2(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
            invariant$2(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
          }
          let isEmptyPath = toArg === "" || to.pathname === "";
          let toPathname = isEmptyPath ? "/" : to.pathname;
          let from; // Routing is relative to the current pathname if explicitly requested.
          //
          // If a pathname is explicitly provided in `to`, it should be relative to the
          // route context. This is explained in `Note on `<Link to>` values` in our
          // migration guide from v5 as a means of disambiguation between `to` values
          // that begin with `/` and those that do not. However, this is problematic for
          // `to` values that do not provide a pathname. `to` can simply be a search or
          // hash string, in which case we should assume that the navigation is relative
          // to the current location's pathname and *not* the route pathname.

          if (isPathRelative || toPathname == null) {
            from = locationPathname;
          } else {
            let routePathnameIndex = routePathnames.length - 1;
            if (toPathname.startsWith("..")) {
              let toSegments = toPathname.split("/"); // Each leading .. segment means "go up one route" instead of "go up one
              // URL segment".  This is a key difference from how <a href> works and a
              // major reason we call this a "to" value instead of a "href".

              while (toSegments[0] === "..") {
                toSegments.shift();
                routePathnameIndex -= 1;
              }
              to.pathname = toSegments.join("/");
            } // If there are more ".." segments than parent routes, resolve relative to
            // the root / URL.

            from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
          }
          let path = resolvePath(to, from); // Ensure the pathname has a trailing slash if the original "to" had one

          let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/"); // Or if this was a link to the current path which has a trailing slash

          let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
          if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
            path.pathname += "/";
          }
          return path;
        }
        /**
         * @private
         */

        const joinPaths = paths => paths.join("/").replace(/\/\/+/g, "/");
        /**
         * @private
         */

        const normalizeSearch = search => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
        /**
         * @private
         */

        const normalizeHash = hash => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
        const validMutationMethodsArr = ["post", "put", "patch", "delete"];
        new Set(validMutationMethodsArr);
        const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
        new Set(validRequestMethodsArr);
        new Set([301, 302, 303, 307, 308]);
        new Set([307, 308]);

        /**
         * React Router v6.10.0
         *
         * Copyright (c) Remix Software Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE.md file in the root directory of this source tree.
         *
         * @license MIT
         */

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */
        /**
         * inlined Object.is polyfill to avoid requiring consumers ship their own
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
         */

        function isPolyfill(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
          ;
        }

        const is$1 = typeof Object.is === "function" ? Object.is : isPolyfill; // Intentionally not using named imports because Rollup uses dynamic
        // dispatch for CommonJS interop named imports.

        const {
          useState,
          useEffect,
          useLayoutEffect,
          useDebugValue
        } = React$1;
        // because of a very particular set of implementation details and assumptions
        // -- change any one of them and it will break. The most important assumption
        // is that updates are always synchronous, because concurrent rendering is
        // only available in versions of React that also have a built-in
        // useSyncExternalStore API. And we only use this shim when the built-in API
        // does not exist.
        //
        // Do not assume that the clever hacks used by this hook also work in general.
        // The point of this shim is to replace the need for hacks by other libraries.

        function useSyncExternalStore$2(subscribe, getSnapshot,
        // Note: The shim does not use getServerSnapshot, because pre-18 versions of
        // React do not expose a way to check if we're hydrating. So users of the shim
        // will need to track that themselves and return the correct value
        // from `getSnapshot`.
        getServerSnapshot) {
          // breaks the rules of React, and only works here because of specific
          // implementation details, most importantly that updates are
          // always synchronous.

          const value = getSnapshot();
          // re-render whenever the subscribed state changes by updating an some
          // arbitrary useState hook. Then, during render, we call getSnapshot to read
          // the current value.
          //
          // Because we don't actually use the state returned by the useState hook, we
          // can save a bit of memory by storing other stuff in that slot.
          //
          // To implement the early bailout, we need to track some things on a mutable
          // object. Usually, we would put that in a useRef hook, but we can stash it in
          // our useState hook instead.
          //
          // To force a re-render, we call forceUpdate({inst}). That works because the
          // new object always fails an equality check.

          const [{
            inst
          }, forceUpdate] = useState({
            inst: {
              value,
              getSnapshot
            }
          }); // Track the latest getSnapshot function with a ref. This needs to be updated
          // in the layout phase so we can access it during the tearing check that
          // happens on subscribe.

          useLayoutEffect(() => {
            inst.value = value;
            inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the
            // commit phase if there was an interleaved mutation. In concurrent mode
            // this can happen all the time, but even in synchronous mode, an earlier
            // effect may have mutated the store.

            if (checkIfSnapshotChanged(inst)) {
              // Force a re-render.
              forceUpdate({
                inst
              });
            } // eslint-disable-next-line react-hooks/exhaustive-deps
          }, [subscribe, value, getSnapshot]);
          useEffect(() => {
            // Check for changes right before subscribing. Subsequent changes will be
            // detected in the subscription handler.
            if (checkIfSnapshotChanged(inst)) {
              // Force a re-render.
              forceUpdate({
                inst
              });
            }
            const handleStoreChange = () => {
              // TODO: Because there is no cross-renderer API for batching updates, it's
              // up to the consumer of this library to wrap their subscription event
              // with unstable_batchedUpdates. Should we try to detect when this isn't
              // the case and print a warning in development?
              // The store changed. Check if the snapshot changed since the last time we
              // read from the store.
              if (checkIfSnapshotChanged(inst)) {
                // Force a re-render.
                forceUpdate({
                  inst
                });
              }
            }; // Subscribe to the store and return a clean-up function.

            return subscribe(handleStoreChange); // eslint-disable-next-line react-hooks/exhaustive-deps
          }, [subscribe]);
          useDebugValue(value);
          return value;
        }
        function checkIfSnapshotChanged(inst) {
          const latestGetSnapshot = inst.getSnapshot;
          const prevValue = inst.value;
          try {
            const nextValue = latestGetSnapshot();
            return !is$1(prevValue, nextValue);
          } catch (error) {
            return true;
          }
        }

        /**
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @flow
         */
        function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
          // Note: The shim does not use getServerSnapshot, because pre-18 versions of
          // React do not expose a way to check if we're hydrating. So users of the shim
          // will need to track that themselves and return the correct value
          // from `getSnapshot`.
          return getSnapshot();
        }

        /**
         * Inlined into the react-router repo since use-sync-external-store does not
         * provide a UMD-compatible package, so we need this to be able to distribute
         * UMD react-router bundles
         */
        const canUseDOM$1 = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        const isServerEnvironment = !canUseDOM$1;
        const shim$1 = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore$2;
        "useSyncExternalStore" in React$1 ? (module => module.useSyncExternalStore)(React$1) : shim$1;
        const NavigationContext = /*#__PURE__*/reactExports.createContext(null);
        const LocationContext = /*#__PURE__*/reactExports.createContext(null);
        const RouteContext = /*#__PURE__*/reactExports.createContext({
          outlet: null,
          matches: []
        });

        /**
         * Returns the full href for the given "to" value. This is useful for building
         * custom links that are also accessible and preserve right-click behavior.
         *
         * @see https://reactrouter.com/hooks/use-href
         */

        function useHref(to, _temp) {
          let {
            relative
          } = _temp === void 0 ? {} : _temp;
          !useInRouterContext() ? invariant$2(false) : void 0;
          let {
            basename,
            navigator
          } = reactExports.useContext(NavigationContext);
          let {
            hash,
            pathname,
            search
          } = useResolvedPath(to, {
            relative
          });
          let joinedPathname = pathname; // If we're operating within a basename, prepend it to the pathname prior
          // to creating the href.  If this is a root navigation, then just use the raw
          // basename which allows the basename to have full control over the presence
          // of a trailing slash on root links

          if (basename !== "/") {
            joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
          }
          return navigator.createHref({
            pathname: joinedPathname,
            search,
            hash
          });
        }
        /**
         * Returns true if this component is a descendant of a <Router>.
         *
         * @see https://reactrouter.com/hooks/use-in-router-context
         */

        function useInRouterContext() {
          return reactExports.useContext(LocationContext) != null;
        }
        /**
         * Returns the current location object, which represents the current URL in web
         * browsers.
         *
         * Note: If you're using this it may mean you're doing some of your own
         * "routing" in your app, and we'd like to know what your use case is. We may
         * be able to provide something higher-level to better suit your needs.
         *
         * @see https://reactrouter.com/hooks/use-location
         */

        function useLocation() {
          !useInRouterContext() ? invariant$2(false) : void 0;
          return reactExports.useContext(LocationContext).location;
        }
        /**
         * The interface for the navigate() function returned from useNavigate().
         */

        /**
         * Returns an imperative method for changing the location. Used by <Link>s, but
         * may also be used by other elements to change the location.
         *
         * @see https://reactrouter.com/hooks/use-navigate
         */
        function useNavigate() {
          !useInRouterContext() ? invariant$2(false) : void 0;
          let {
            basename,
            navigator
          } = reactExports.useContext(NavigationContext);
          let {
            matches
          } = reactExports.useContext(RouteContext);
          let {
            pathname: locationPathname
          } = useLocation();
          let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map(match => match.pathnameBase));
          let activeRef = reactExports.useRef(false);
          reactExports.useEffect(() => {
            activeRef.current = true;
          });
          let navigate = reactExports.useCallback(function (to, options) {
            if (options === void 0) {
              options = {};
            }
            if (!activeRef.current) return;
            if (typeof to === "number") {
              navigator.go(to);
              return;
            }
            let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path"); // If we're operating within a basename, prepend it to the pathname prior
            // to handing off to history.  If this is a root navigation, then we
            // navigate to the raw basename which allows the basename to have full
            // control over the presence of a trailing slash on root links

            if (basename !== "/") {
              path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
            }
            (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);
          }, [basename, navigator, routePathnamesJson, locationPathname]);
          return navigate;
        }
        /**
         * Returns an object of key/value pairs of the dynamic params from the current
         * URL that were matched by the route path.
         *
         * @see https://reactrouter.com/hooks/use-params
         */

        function useParams() {
          let {
            matches
          } = reactExports.useContext(RouteContext);
          let routeMatch = matches[matches.length - 1];
          return routeMatch ? routeMatch.params : {};
        }
        /**
         * Resolves the pathname of the given `to` value against the current location.
         *
         * @see https://reactrouter.com/hooks/use-resolved-path
         */

        function useResolvedPath(to, _temp2) {
          let {
            relative
          } = _temp2 === void 0 ? {} : _temp2;
          let {
            matches
          } = reactExports.useContext(RouteContext);
          let {
            pathname: locationPathname
          } = useLocation();
          let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map(match => match.pathnameBase));
          return reactExports.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
        }
        var DataRouterHook$1;
        (function (DataRouterHook) {
          DataRouterHook["UseBlocker"] = "useBlocker";
          DataRouterHook["UseRevalidator"] = "useRevalidator";
        })(DataRouterHook$1 || (DataRouterHook$1 = {}));
        var DataRouterStateHook$1;
        (function (DataRouterStateHook) {
          DataRouterStateHook["UseBlocker"] = "useBlocker";
          DataRouterStateHook["UseLoaderData"] = "useLoaderData";
          DataRouterStateHook["UseActionData"] = "useActionData";
          DataRouterStateHook["UseRouteError"] = "useRouteError";
          DataRouterStateHook["UseNavigation"] = "useNavigation";
          DataRouterStateHook["UseRouteLoaderData"] = "useRouteLoaderData";
          DataRouterStateHook["UseMatches"] = "useMatches";
          DataRouterStateHook["UseRevalidator"] = "useRevalidator";
        })(DataRouterStateHook$1 || (DataRouterStateHook$1 = {}));

        /**
         * Provides location context for the rest of the app.
         *
         * Note: You usually won't render a <Router> directly. Instead, you'll render a
         * router that is more specific to your environment such as a <BrowserRouter>
         * in web browsers or a <StaticRouter> for server rendering.
         *
         * @see https://reactrouter.com/router-components/router
         */
        function Router(_ref4) {
          let {
            basename: basenameProp = "/",
            children = null,
            location: locationProp,
            navigationType = Action.Pop,
            navigator,
            static: staticProp = false
          } = _ref4;
          !!useInRouterContext() ? invariant$2(false) : void 0; // Preserve trailing slashes on basename, so we can let the user control
          // the enforcement of trailing slashes throughout the app

          let basename = basenameProp.replace(/^\/*/, "/");
          let navigationContext = reactExports.useMemo(() => ({
            basename,
            navigator,
            static: staticProp
          }), [basename, navigator, staticProp]);
          if (typeof locationProp === "string") {
            locationProp = parsePath(locationProp);
          }
          let {
            pathname = "/",
            search = "",
            hash = "",
            state = null,
            key = "default"
          } = locationProp;
          let locationContext = reactExports.useMemo(() => {
            let trailingPathname = stripBasename(pathname, basename);
            if (trailingPathname == null) {
              return null;
            }
            return {
              location: {
                pathname: trailingPathname,
                search,
                hash,
                state,
                key
              },
              navigationType
            };
          }, [basename, pathname, search, hash, state, key, navigationType]);
          if (locationContext == null) {
            return null;
          }
          return /*#__PURE__*/reactExports.createElement(NavigationContext.Provider, {
            value: navigationContext
          }, /*#__PURE__*/reactExports.createElement(LocationContext.Provider, {
            children: children,
            value: locationContext
          }));
        }
        var AwaitRenderStatus;
        (function (AwaitRenderStatus) {
          AwaitRenderStatus[AwaitRenderStatus["pending"] = 0] = "pending";
          AwaitRenderStatus[AwaitRenderStatus["success"] = 1] = "success";
          AwaitRenderStatus[AwaitRenderStatus["error"] = 2] = "error";
        })(AwaitRenderStatus || (AwaitRenderStatus = {}));
        new Promise(() => {});

        /**
         * React Router DOM v6.10.0
         *
         * Copyright (c) Remix Software Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE.md file in the root directory of this source tree.
         *
         * @license MIT
         */

        function _extends$1() {
          _extends$1 = Object.assign ? Object.assign.bind() : function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          return _extends$1.apply(this, arguments);
        }
        function _objectWithoutPropertiesLoose(source, excluded) {
          if (source == null) return {};
          var target = {};
          var sourceKeys = Object.keys(source);
          var key, i;
          for (i = 0; i < sourceKeys.length; i++) {
            key = sourceKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            target[key] = source[key];
          }
          return target;
        }
        function isModifiedEvent(event) {
          return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
        }
        function shouldProcessLinkClick(event, target) {
          return event.button === 0 && (
          // Ignore everything but left clicks
          !target || target === "_self") &&
          // Let browser handle "target=_blank" etc.
          !isModifiedEvent(event) // Ignore clicks with modifier keys
          ;
        }

        const _excluded$d = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"];
        /**
         * A `<Router>` for use in web browsers. Provides the cleanest URLs.
         */

        function BrowserRouter(_ref) {
          let {
            basename,
            children,
            window
          } = _ref;
          let historyRef = reactExports.useRef();
          if (historyRef.current == null) {
            historyRef.current = createBrowserHistory({
              window,
              v5Compat: true
            });
          }
          let history = historyRef.current;
          let [state, setState] = reactExports.useState({
            action: history.action,
            location: history.location
          });
          reactExports.useLayoutEffect(() => history.listen(setState), [history]);
          return /*#__PURE__*/reactExports.createElement(Router, {
            basename: basename,
            children: children,
            location: state.location,
            navigationType: state.action,
            navigator: history
          });
        }
        const isBrowser$1 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
        const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
        /**
         * The public API for rendering a history-aware <a>.
         */

        const Link = exports('L', /*#__PURE__*/reactExports.forwardRef(function LinkWithRef(_ref4, ref) {
          let {
              onClick,
              relative,
              reloadDocument,
              replace,
              state,
              target,
              to,
              preventScrollReset
            } = _ref4,
            rest = _objectWithoutPropertiesLoose(_ref4, _excluded$d);
          let {
            basename
          } = reactExports.useContext(NavigationContext); // Rendered into <a href> for absolute URLs

          let absoluteHref;
          let isExternal = false;
          if (typeof to === "string" && ABSOLUTE_URL_REGEX.test(to)) {
            // Render the absolute href server- and client-side
            absoluteHref = to; // Only check for external origins client-side

            if (isBrowser$1) {
              let currentUrl = new URL(window.location.href);
              let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
              let path = stripBasename(targetUrl.pathname, basename);
              if (targetUrl.origin === currentUrl.origin && path != null) {
                // Strip the protocol/origin/basename for same-origin absolute URLs
                to = path + targetUrl.search + targetUrl.hash;
              } else {
                isExternal = true;
              }
            }
          } // Rendered into <a href> for relative URLs

          let href = useHref(to, {
            relative
          });
          let internalOnClick = useLinkClickHandler(to, {
            replace,
            state,
            target,
            preventScrollReset,
            relative
          });
          function handleClick(event) {
            if (onClick) onClick(event);
            if (!event.defaultPrevented) {
              internalOnClick(event);
            }
          }
          return /*#__PURE__*/(
            // eslint-disable-next-line jsx-a11y/anchor-has-content
            reactExports.createElement("a", _extends$1({}, rest, {
              href: absoluteHref || href,
              onClick: isExternal || reloadDocument ? onClick : handleClick,
              ref: ref,
              target: target
            }))
          );
        }));
        ////////////////////////////////////////////////////////////////////////////////
        //#region Hooks
        ////////////////////////////////////////////////////////////////////////////////

        var DataRouterHook;
        (function (DataRouterHook) {
          DataRouterHook["UseScrollRestoration"] = "useScrollRestoration";
          DataRouterHook["UseSubmitImpl"] = "useSubmitImpl";
          DataRouterHook["UseFetcher"] = "useFetcher";
        })(DataRouterHook || (DataRouterHook = {}));
        var DataRouterStateHook;
        (function (DataRouterStateHook) {
          DataRouterStateHook["UseFetchers"] = "useFetchers";
          DataRouterStateHook["UseScrollRestoration"] = "useScrollRestoration";
        })(DataRouterStateHook || (DataRouterStateHook = {}));
        /**
         * Handles the click behavior for router `<Link>` components. This is useful if
         * you need to create custom `<Link>` components with the same click behavior we
         * use in our exported `<Link>`.
         */

        function useLinkClickHandler(to, _temp) {
          let {
            target,
            replace: replaceProp,
            state,
            preventScrollReset,
            relative
          } = _temp === void 0 ? {} : _temp;
          let navigate = useNavigate();
          let location = useLocation();
          let path = useResolvedPath(to, {
            relative
          });
          return reactExports.useCallback(event => {
            if (shouldProcessLinkClick(event, target)) {
              event.preventDefault(); // If the URL hasn't changed, a regular <a> will do a replace instead of
              // a push, so do the same here unless the replace prop is explicitly set

              let replace = replaceProp !== undefined ? replaceProp : createPath(location) === createPath(path);
              navigate(to, {
                replace,
                state,
                preventScrollReset,
                relative
              });
            }
          }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative]);
        }

        // This optional code is used to register a service worker.
        // register() is not called by default.

        // This lets the app load faster on subsequent visits in production, and gives
        // it offline capabilities. However, it also means that developers (and users)
        // will only see deployed updates on subsequent visits to a page, after all the
        // existing tabs open on the page have been closed, since previously cached
        // resources are updated in the background.

        // To learn more about the benefits of this model and instructions on how to
        // opt-in, read https://bit.ly/CRA-PWA

        Boolean(window.location.hostname === 'localhost' ||
        // [::1] is the IPv6 localhost address.
        window.location.hostname === '[::1]' ||
        // 127.0.0.0/8 are considered localhost for IPv4.
        window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));
        function unregister() {
          if ('serviceWorker' in navigator) {
            navigator.serviceWorker.ready.then(registration => {
              registration.unregister();
            }).catch(error => {
              console.error(error.message);
            });
          }
        }
        const show_hide$2 = "Anzeigen/Ausblenden";
        const order_priority$2 = "Reihenfolge und Prioritt";
        const video_options$2 = "Videooptionen";
        const setup$3 = "Setup";
        const validation$2 = "Validierung";
        const display$2 = "Anzeigen";
        const skip_logic$2 = "berspringen Logik";
        const show_always$2 = "Immer anzeigen";
        const show_if$2 = "Zeige wenn";
        const hide_always$2 = "Immer ausblenden";
        const hide_if$2 = "Ausblenden, wenn";
        const condition_to_show$2 = "Zu zeigende Bedingung";
        const condition_to_hide$2 = "Zu verbergende Bedingung";
        const no_logic_err$2 = " Ohne Logik wird dies auf <strong>Immer anzeigen</strong> zurckgesetzt";
        const wrong_logic_err$2 = " Es gab einen Fehler in Logic, daher wurde dies auf <strong>Immer anzeigen</strong> zurckgesetzt";
        const no_condition$2 = "KEINE BEDINGUNG";
        const text_field_size$2 = "Textfeldgre";
        const textarea_lines$2 = "TextArea-Zeilen";
        const hide_text$2 = "Text verbergen";
        const show_word_count$2 = "Wortanzahl anzeigen";
        const lower_bound_hint$1 = "Hinweis zur Untergrenze";
        const upper_bound_hint$2 = "Hinweis zur oberen Grenze";
        const loop_video$2 = "Videoschleife";
        const audio_only$2 = "Nur Audio";
        const fullday_format$2 = "Ganztgiges Format";
        const max_date$2 = "Maximaldatum";
        const min_date$2 = "Min. Datum";
        const date_format$2 = "Datumsformat";
        const image_aspect_ratio$2 = "Bildseitenverhltnis";
        const columns_number$1 = "Spaltennummer";
        const image_height$2 = "Bildhhe";
        const spacing$2 = "Abstand";
        const show_question_hint$2 = "Fragehinweis anzeigen";
        const to_group_end$2 = "Zum Gruppenende";
        const skip_to$2 = "berspringen zu";
        const OK = "OK";
        const proceed_as_usual$2 = "Wie gewohnt fortfahren";
        const if_answer_is$2 = "Wenn die Antwort <strong>{{code}}</strong> ist";
        const invalid_skip_destination_err$1 = "<strong>{{code}}</strong> ist kein gltiges Skip-Ziel...";
        const Thema = "Thema";
        const text_style$2 = "Textstil";
        const group_title$2 = "Gruppentitel";
        const question_title$2 = "Titel der Frage";
        const choose_image$2 = "Bild auswhlen";
        const theme_text$2 = "Text";
        const theme_header$2 = "Kopfzeile";
        const foreground_color$2 = "Vordergrundfarbe";
        const background_color$2 = "Hintergrundfarbe";
        const highlight_color$2 = "Farbe hervorheben";
        const questions_order$2 = "Reihenfolge der Fragen";
        const questions_priority$2 = "Prioritt der Fragen";
        const groups_order$2 = "Gruppenreihenfolge";
        const groups_priority$2 = "Gruppenprioritt";
        const options_order$2 = "Optionsreihenfolge";
        const options_priority$2 = "Prioritt der Optionen";
        const rows_order$2 = "Reihenfolge";
        const rows_priority$2 = "Zeilenprioritt";
        const columns_order$2 = "Reihenfolge der Spalten";
        const columns_priority$1 = "Spaltenprioritt";
        const as_is$2 = "Wie es ist";
        const random_order$2 = "Zufllige Reihenfolge";
        const flip_order$2 = "Flip-Order";
        const custom_random$2 = "Benutzerdefiniert";
        const sort_by_label$2 = "Nach Etikett sortieren";
        const no_priority$2 = "Keine";
        const prioritise_questions$1 = "Fragen priorisieren";
        const prioritise_groups$1 = "Gruppen priorisieren";
        const prioritise_options$1 = "Optionen priorisieren";
        const prioritise_rows$1 = "Zeilen priorisieren";
        const prioritise_columns$1 = "Spalten priorisieren";
        const add_new_random_rule$2 = "Neue Zufallsregel hinzufgen";
        const edit_random_rule$2 = "Zufallsregel bearbeiten";
        const edit_priority_rule$2 = "Priorittsregel bearbeiten";
        const cancel$2 = "stornieren";
        const submit$2 = "Absenden";
        const add_random_rule$2 = "Zufallsregel hinzufgen";
        const add_priority_rule$2 = "Priorittsregel hinzufgen";
        const prioritise$2 = "Priorisieren";
        const priority_show$2 = "Anzeigen";
        const priority_show_limit_from_count$2 = "Zeige {{limit}} von {{count}}";
        const validation_required_title$2 = "Erforderlich";
        const validation_min_char_length_title$2 = "Mindestzeichenlnge";
        const validation_max_char_length_title$2 = "Maximale Zeichenlnge";
        const validation_contains_title$2 = "Enthlt";
        const validation_not_contains_title$2 = "Enthlt nicht";
        const validation_pattern_title$2 = "Entspricht Regex-Muster";
        const validation_max_word_count_title$2 = "Maximale Wortzahl";
        const validation_min_word_count_title$2 = "Mindestwortzahl";
        const validation_pattern_email_title$2 = "Muster-E-Mail";
        const validation_between_title$2 = "Wert zwischen";
        const validation_not_between_title$2 = "Wert nicht zwischen";
        const validation_lt_title$2 = "Wert kleiner als";
        const validation_lte_title$2 = "Wert kleiner oder gleich";
        const validation_gt_title$2 = "Wert grer als";
        const validation_gte_title$2 = "Wert grer oder gleich";
        const validation_equals_title$2 = "Wert gleich";
        const validation_not_equal_title$2 = "Wert ungleich";
        const validation_min_option_count_title$2 = "Mindestzahl der Optionen";
        const validation_max_option_count_title$2 = "Maximale Optionsanzahl";
        const validation_option_count_title$2 = "Genaue Optionsanzahl";
        const validation_min_ranking_count_title$2 = "Mindestplatzierte Anzahl";
        const validation_max_ranking_count_title$2 = "Maximale Anzahl in der Rangliste";
        const validation_ranking_count_title$2 = "Genaue Rangliste";
        const validation_min_char_length_subtitle$2 = "Mindestlnge:";
        const validation_max_char_length_subtitle$2 = "Maximale Lnge:";
        const validation_contains_subtitle$2 = "Enthlt:";
        const validation_not_contains_subtitle$2 = "Enthlt nicht:";
        const validation_pattern_subtitle$2 = "Muster:";
        const validation_max_word_count_subtitle$2 = "Maximale Anzahl:";
        const validation_min_word_count_subtitle$2 = "Mindestanzahl:";
        const validation_between_subtitle$2 = "Zwischen:";
        const validation_not_between_subtitle$2 = "Nicht zwischen:";
        const validation_lt_subtitle$2 = "Kleiner als:";
        const validation_lte_subtitle$2 = "Kleiner als oder gleich:";
        const validation_gt_subtitle$2 = "Grer als:";
        const validation_gte_subtitle$2 = "Grer als oder gleich:";
        const validation_equals_subtitle$2 = "Gleich:";
        const validation_not_equal_subtitle$2 = "Ungleich:";
        const validation_min_option_count_subtitle$2 = "Mindestanzahl:";
        const validation_max_option_count_subtitle$2 = "Maximale Anzahl:";
        const validation_option_count_subtitle$2 = "Anzahl:";
        const validation_min_ranking_count_subtitle$2 = "Mindestanzahl";
        const validation_max_ranking_count_subtitle$2 = "Maximale Anzahl";
        const validation_ranking_count_subtitle$2 = "Anzahl:";
        const standard_error$2 = "Standardfehler";
        const custom_error$2 = "Benutzerdefinierter Fehler";
        const component_text_title$2 = "Kurztext";
        const component_paragraph_title$2 = "Langer Text";
        const component_barcode_title$2 = "Barcode/QrCode Scanner";
        const component_number_title$2 = "Nummer";
        const component_email_title$2 = "E-Mail";
        const component_scq_title$2 = "Einzelauswahl";
        const component_image_scq_title$2 = "Einzelbildauswahl";
        const component_scq_array_title$2 = "Einzelauswahl-Array";
        const component_mcq_title$2 = "Mehrfachauswahl";
        const component_image_mcq_title$2 = "Mehrere Bildauswahl";
        const component_nps_title$2 = "NPS";
        const component_date_title$2 = "Datum";
        const component_date_time_title$2 = "Datum und Uhrzeit";
        const component_time_title$2 = "Zeit";
        const component_file_upload_title$2 = "Datei-Upload";
        const component_signature_title$2 = "Signatur";
        const component_photo_capture_title$2 = "Foto aufnehmen";
        const component_video_capture_title$2 = "Video aufnehmen";
        const component_ranking_title$2 = "Ranking";
        const component_image_ranking_title$2 = "Bildranking";
        const component_text_display_title$2 = "Textanzeige";
        const component_image_display_title$2 = "Bildanzeige";
        const component_video_display_title$2 = "Videoanzeige";
        const component_group_title$2 = "Gruppe";
        const component_welcome_title$2 = "Willkommensgruppe";
        const component_end_title$2 = "Endgruppe";
        const section_text_based$2 = "Textbasiert";
        const section_choice_based$2 = "Auswahl basiert";
        const section_date_time$2 = "Datum / Uhrzeit";
        const section_file_based$2 = "Dateibasiert";
        const section_other$2 = "Andere";
        const section_info$2 = "Info";
        const section_sections$2 = "Abschnitte";
        const add_option$2 = "Option hinzufgen";
        const add_row$2 = "Zeile hinzufgen";
        const add_column$2 = "Spalte hinzufgen";
        const add_other$2 = "\"Andere\" hinzufgen";
        const or$2 = "oder";
        const err_priority$2 = "Priorittsgruppenbefehlsfehler";
        const err_random$2 = "Zuflliger Gruppenbefehlsfehler";
        const err_relevance$1 = "Problem mit Logik zum Ein-/Ausblenden";
        const err_value_in_end_group$2 = "Kann keine Fragen haben, die Benutzereingaben in der Endgruppe erfassen";
        const err_skip$1 = "Problem mit einer der Skip-Anweisungen";
        const err_reference$2 = "Fehler: Weiterleitung eines fehlenden Werts oder einer nachgestellten Frage: <strong>{{codes}}</strong>, in Sprache: <strong>{{lang}}</strong>";
        const err_empty_parent$2 = "Dieses {{component_name}} darf nicht leer sein, bitte fgen Sie mindestens ein {{child_name}} hinzu";
        const err_duplicate_code$2 = "Diese {{component_name}} hat einen doppelten Code";
        const err_no_end_group$2 = "Es muss eine gltige Endgruppe geben";
        const err_misplaced_end_group$2 = "Endgruppe muss immer die letzte Gruppe sein";
        const err_misplaced_welcome_group$2 = "Willkommensgruppe muss immer die erste Gruppe sein";
        const survey$2 = "Umfrage";
        const group$2 = "Gruppe";
        const question$2 = "Frage";
        const option$2 = "Option";
        const err_priority_group_item_not_child$2 = "Diese Elemente sind entweder gelscht oder haben Fehler und knnen daher nicht in der Priorittsgruppe sein: <strong>{{items}}</strong>";
        const err_random_group_item_not_child$2 = "Diese Elemente wurden entweder gelscht oder sind fehlerhaft und knnen daher nicht in der Zufallsgruppe enthalten sein: <strong>{{items}}</strong>";
        const err_duplicate_priority_group_items$2 = "Diese Elemente sind in mehr als einer Priorittsgruppe vorhanden: <strong>{{iterms}}</strong>";
        const err_priority_limit_mismatch$2 = "In einer der Priorittsgruppen ist das Limit grer oder gleich der Anzahl der Artikel";
        const err_duplicate_random_group_items$2 = "Diese Artikel sind in mehr als einer Zufallsgruppe vorhanden: <strong>{{items}}</strong>";
        const are_you_sure$2 = "Bist du sicher?";
        const empty_group_hint$1 = "Stellen Sie hier eine Frage";
        const empty_survey_hint$1 = "Gruppe hier ablegen";
        const upload_image$2 = "Bild hochladen";
        const replace_image$2 = "Bild ersetzen";
        const uploading_image$2 = "Bild wird hochgeladen";
        const upload_video$2 = "Video hochladen";
        const replace_video$2 = "Video ersetzen";
        const uploading_video$2 = "Video hochladen";
        const validation_file_types_title$2 = "Dateitypen";
        const validation_max_file_size_title$2 = "Maximale Dateigre";
        const validation_max_file_size_subtitle$2 = "Maximale Dateigre (KB)";
        const file_type$2 = "Dateityp";
        const file_types$2 = {
          presentation: "Prsentation",
          document: "Dokument",
          spreadsheet: "Spreadsheet",
          pdf: "PDF",
          image: "Bild",
          video: "Video",
          audio: "Audio"
        };
        const design_de = {
          show_hide: show_hide$2,
          order_priority: order_priority$2,
          video_options: video_options$2,
          setup: setup$3,
          validation: validation$2,
          display: display$2,
          skip_logic: skip_logic$2,
          show_always: show_always$2,
          show_if: show_if$2,
          hide_always: hide_always$2,
          hide_if: hide_if$2,
          condition_to_show: condition_to_show$2,
          condition_to_hide: condition_to_hide$2,
          no_logic_err: no_logic_err$2,
          wrong_logic_err: wrong_logic_err$2,
          no_condition: no_condition$2,
          text_field_size: text_field_size$2,
          textarea_lines: textarea_lines$2,
          hide_text: hide_text$2,
          show_word_count: show_word_count$2,
          lower_bound_hint: lower_bound_hint$1,
          upper_bound_hint: upper_bound_hint$2,
          loop_video: loop_video$2,
          audio_only: audio_only$2,
          fullday_format: fullday_format$2,
          max_date: max_date$2,
          min_date: min_date$2,
          date_format: date_format$2,
          image_aspect_ratio: image_aspect_ratio$2,
          columns_number: columns_number$1,
          image_height: image_height$2,
          spacing: spacing$2,
          show_question_hint: show_question_hint$2,
          to_group_end: to_group_end$2,
          skip_to: skip_to$2,
          OK: OK,
          proceed_as_usual: proceed_as_usual$2,
          if_answer_is: if_answer_is$2,
          invalid_skip_destination_err: invalid_skip_destination_err$1,
          Thema: Thema,
          text_style: text_style$2,
          group_title: group_title$2,
          question_title: question_title$2,
          choose_image: choose_image$2,
          theme_text: theme_text$2,
          theme_header: theme_header$2,
          foreground_color: foreground_color$2,
          background_color: background_color$2,
          highlight_color: highlight_color$2,
          questions_order: questions_order$2,
          questions_priority: questions_priority$2,
          groups_order: groups_order$2,
          groups_priority: groups_priority$2,
          options_order: options_order$2,
          options_priority: options_priority$2,
          rows_order: rows_order$2,
          rows_priority: rows_priority$2,
          columns_order: columns_order$2,
          columns_priority: columns_priority$1,
          as_is: as_is$2,
          random_order: random_order$2,
          flip_order: flip_order$2,
          custom_random: custom_random$2,
          sort_by_label: sort_by_label$2,
          no_priority: no_priority$2,
          prioritise_questions: prioritise_questions$1,
          prioritise_groups: prioritise_groups$1,
          prioritise_options: prioritise_options$1,
          prioritise_rows: prioritise_rows$1,
          prioritise_columns: prioritise_columns$1,
          add_new_random_rule: add_new_random_rule$2,
          edit_random_rule: edit_random_rule$2,
          edit_priority_rule: edit_priority_rule$2,
          cancel: cancel$2,
          submit: submit$2,
          add_random_rule: add_random_rule$2,
          add_priority_rule: add_priority_rule$2,
          prioritise: prioritise$2,
          priority_show: priority_show$2,
          priority_show_limit_from_count: priority_show_limit_from_count$2,
          validation_required_title: validation_required_title$2,
          validation_min_char_length_title: validation_min_char_length_title$2,
          validation_max_char_length_title: validation_max_char_length_title$2,
          validation_contains_title: validation_contains_title$2,
          validation_not_contains_title: validation_not_contains_title$2,
          validation_pattern_title: validation_pattern_title$2,
          validation_max_word_count_title: validation_max_word_count_title$2,
          validation_min_word_count_title: validation_min_word_count_title$2,
          validation_pattern_email_title: validation_pattern_email_title$2,
          validation_between_title: validation_between_title$2,
          validation_not_between_title: validation_not_between_title$2,
          validation_lt_title: validation_lt_title$2,
          validation_lte_title: validation_lte_title$2,
          validation_gt_title: validation_gt_title$2,
          validation_gte_title: validation_gte_title$2,
          validation_equals_title: validation_equals_title$2,
          validation_not_equal_title: validation_not_equal_title$2,
          validation_min_option_count_title: validation_min_option_count_title$2,
          validation_max_option_count_title: validation_max_option_count_title$2,
          validation_option_count_title: validation_option_count_title$2,
          validation_min_ranking_count_title: validation_min_ranking_count_title$2,
          validation_max_ranking_count_title: validation_max_ranking_count_title$2,
          validation_ranking_count_title: validation_ranking_count_title$2,
          validation_min_char_length_subtitle: validation_min_char_length_subtitle$2,
          validation_max_char_length_subtitle: validation_max_char_length_subtitle$2,
          validation_contains_subtitle: validation_contains_subtitle$2,
          validation_not_contains_subtitle: validation_not_contains_subtitle$2,
          validation_pattern_subtitle: validation_pattern_subtitle$2,
          validation_max_word_count_subtitle: validation_max_word_count_subtitle$2,
          validation_min_word_count_subtitle: validation_min_word_count_subtitle$2,
          validation_between_subtitle: validation_between_subtitle$2,
          validation_not_between_subtitle: validation_not_between_subtitle$2,
          validation_lt_subtitle: validation_lt_subtitle$2,
          validation_lte_subtitle: validation_lte_subtitle$2,
          validation_gt_subtitle: validation_gt_subtitle$2,
          validation_gte_subtitle: validation_gte_subtitle$2,
          validation_equals_subtitle: validation_equals_subtitle$2,
          validation_not_equal_subtitle: validation_not_equal_subtitle$2,
          validation_min_option_count_subtitle: validation_min_option_count_subtitle$2,
          validation_max_option_count_subtitle: validation_max_option_count_subtitle$2,
          validation_option_count_subtitle: validation_option_count_subtitle$2,
          validation_min_ranking_count_subtitle: validation_min_ranking_count_subtitle$2,
          validation_max_ranking_count_subtitle: validation_max_ranking_count_subtitle$2,
          validation_ranking_count_subtitle: validation_ranking_count_subtitle$2,
          standard_error: standard_error$2,
          custom_error: custom_error$2,
          component_text_title: component_text_title$2,
          component_paragraph_title: component_paragraph_title$2,
          component_barcode_title: component_barcode_title$2,
          component_number_title: component_number_title$2,
          component_email_title: component_email_title$2,
          component_scq_title: component_scq_title$2,
          component_image_scq_title: component_image_scq_title$2,
          component_scq_array_title: component_scq_array_title$2,
          component_mcq_title: component_mcq_title$2,
          component_image_mcq_title: component_image_mcq_title$2,
          component_nps_title: component_nps_title$2,
          component_date_title: component_date_title$2,
          component_date_time_title: component_date_time_title$2,
          component_time_title: component_time_title$2,
          component_file_upload_title: component_file_upload_title$2,
          component_signature_title: component_signature_title$2,
          component_photo_capture_title: component_photo_capture_title$2,
          component_video_capture_title: component_video_capture_title$2,
          component_ranking_title: component_ranking_title$2,
          component_image_ranking_title: component_image_ranking_title$2,
          component_text_display_title: component_text_display_title$2,
          component_image_display_title: component_image_display_title$2,
          component_video_display_title: component_video_display_title$2,
          component_group_title: component_group_title$2,
          component_welcome_title: component_welcome_title$2,
          component_end_title: component_end_title$2,
          section_text_based: section_text_based$2,
          section_choice_based: section_choice_based$2,
          section_date_time: section_date_time$2,
          section_file_based: section_file_based$2,
          section_other: section_other$2,
          section_info: section_info$2,
          section_sections: section_sections$2,
          add_option: add_option$2,
          add_row: add_row$2,
          add_column: add_column$2,
          add_other: add_other$2,
          or: or$2,
          err_priority: err_priority$2,
          err_random: err_random$2,
          err_relevance: err_relevance$1,
          err_value_in_end_group: err_value_in_end_group$2,
          err_skip: err_skip$1,
          err_reference: err_reference$2,
          err_empty_parent: err_empty_parent$2,
          err_duplicate_code: err_duplicate_code$2,
          err_no_end_group: err_no_end_group$2,
          err_misplaced_end_group: err_misplaced_end_group$2,
          err_misplaced_welcome_group: err_misplaced_welcome_group$2,
          survey: survey$2,
          group: group$2,
          question: question$2,
          option: option$2,
          err_priority_group_item_not_child: err_priority_group_item_not_child$2,
          err_random_group_item_not_child: err_random_group_item_not_child$2,
          err_duplicate_priority_group_items: err_duplicate_priority_group_items$2,
          err_priority_limit_mismatch: err_priority_limit_mismatch$2,
          err_duplicate_random_group_items: err_duplicate_random_group_items$2,
          are_you_sure: are_you_sure$2,
          empty_group_hint: empty_group_hint$1,
          empty_survey_hint: empty_survey_hint$1,
          upload_image: upload_image$2,
          replace_image: replace_image$2,
          uploading_image: uploading_image$2,
          upload_video: upload_video$2,
          replace_video: replace_video$2,
          uploading_video: uploading_video$2,
          validation_file_types_title: validation_file_types_title$2,
          validation_max_file_size_title: validation_max_file_size_title$2,
          validation_max_file_size_subtitle: validation_max_file_size_subtitle$2,
          file_type: file_type$2,
          file_types: file_types$2
        };
        const show_hide$1 = "Show/Hide";
        const order_priority$1 = "Order and Priority";
        const video_options$1 = "Video Options";
        const setup$2 = "Setup";
        const validation$1 = "Validation";
        const display$1 = "Display";
        const skip_logic$1 = "Skip Logic";
        const show_always$1 = "Show Always";
        const show_if$1 = "Show If";
        const hide_always$1 = "Hide Always";
        const hide_if$1 = "Hide If";
        const condition_to_show$1 = "Condition to Show";
        const condition_to_hide$1 = "Condition to Hide";
        const no_logic_err$1 = " Without Logic, this will be reset to <strong>Always Show</strong>";
        const wrong_logic_err$1 = " There was an error in Logic therefore this was reset to <strong>Always Show</strong>";
        const no_condition$1 = "NO CONDITION";
        const text_field_size$1 = "Text Field Size";
        const textarea_lines$1 = "TextArea Lines";
        const hide_text$1 = "Hide Text";
        const show_word_count$1 = "Show Word Count";
        const lower_bound_hint = "Lower Bound hint";
        const upper_bound_hint$1 = "Upper Bound hint";
        const loop_video$1 = "Loop Video";
        const audio_only$1 = "Audio Only";
        const fullday_format$1 = "FullDay Format";
        const max_date$1 = "Max Date";
        const min_date$1 = "Min Date";
        const date_format$1 = "Date Format";
        const image_aspect_ratio$1 = "Image Aspect Ratio";
        const columns_number = "Columns Number";
        const image_height$1 = "Image Height";
        const spacing$1 = "Spacing";
        const show_question_hint$1 = "Show Question Hint";
        const to_group_end$1 = "To Group End";
        const skip_to$1 = "Skip To";
        const ok = "OK";
        const proceed_as_usual$1 = "Proceed as usual";
        const if_answer_is$1 = "If answer is <strong>{{code}}</strong>";
        const invalid_skip_destination_err = "<strong>{{code}}</strong> is not a valid Skip Destination...";
        const theme$1 = "Theme";
        const text_style$1 = "Text Style";
        const group_title$1 = "Group Title";
        const question_title$1 = "Question Title";
        const choose_image$1 = "Choose Image";
        const theme_text$1 = "Text";
        const theme_header$1 = "Header";
        const foreground_color$1 = "Foreground Color";
        const background_color$1 = "Background Color";
        const highlight_color$1 = "Highlight Color";
        const questions_order$1 = "Questions Order";
        const questions_priority$1 = "Questions Priority";
        const groups_order$1 = "Groups Order";
        const groups_priority$1 = "Groups Priority";
        const options_order$1 = "Options Order";
        const options_priority$1 = "Options Priority";
        const rows_order$1 = "Rows Order";
        const rows_priority$1 = "Rows Priority";
        const columns_order$1 = "Columns Order";
        const columns_priority = "Columns Priority";
        const as_is$1 = "As is";
        const random_order$1 = "Random Order";
        const flip_order$1 = "Flip Order";
        const custom_random$1 = "Custom";
        const sort_by_label$1 = "Sort By Label";
        const no_priority$1 = "None";
        const prioritise_questions = "Prioritise Questions";
        const prioritise_groups = "Prioritise Groups";
        const prioritise_options = "Prioritise Options";
        const prioritise_rows = "Prioritise Rows";
        const prioritise_columns = "Prioritise Columns";
        const add_new_random_rule$1 = "Add New Random Rule";
        const edit_random_rule$1 = "Edit Random Rule";
        const edit_priority_rule$1 = "Edit Priority Rule";
        const cancel$1 = "Cancel";
        const submit$1 = "Submit";
        const add_random_rule$1 = "Add Random Rule";
        const add_priority_rule$1 = "Add Priority Rule";
        const prioritise$1 = "Prioritise";
        const priority_show$1 = "Show";
        const priority_show_limit_from_count$1 = "Show {{limit}} from {{count}}";
        const validation_required_title$1 = "Required";
        const validation_file_types_title$1 = "File Types";
        const validation_max_file_size_title$1 = "Max File Size";
        const validation_max_file_size_subtitle$1 = "Max File Size (KB)";
        const validation_min_char_length_title$1 = "Min Character Length";
        const validation_max_char_length_title$1 = "Max Character Length";
        const validation_contains_title$1 = "Contains";
        const validation_not_contains_title$1 = "Does not contain";
        const validation_pattern_title$1 = "Matches Regex Pattern";
        const validation_max_word_count_title$1 = "Max Word Count";
        const validation_min_word_count_title$1 = "Min Word Count";
        const validation_pattern_email_title$1 = "Pattern Email";
        const validation_between_title$1 = "Value Between";
        const validation_not_between_title$1 = "Value not between";
        const validation_lt_title$1 = "Value less than";
        const validation_lte_title$1 = "Value less than or equals";
        const validation_gt_title$1 = "Value greater than";
        const validation_gte_title$1 = "Value greater than or equals";
        const validation_equals_title$1 = "Value equals";
        const validation_not_equal_title$1 = "Value not equals";
        const validation_min_option_count_title$1 = "Minimum Option Count";
        const validation_max_option_count_title$1 = "Maximum Option Count";
        const validation_option_count_title$1 = "Exact Option Count";
        const validation_min_ranking_count_title$1 = "Minimum Ranked Count";
        const validation_max_ranking_count_title$1 = "Maximum Ranked Count";
        const validation_ranking_count_title$1 = "Exact Ranked Count";
        const validation_min_char_length_subtitle$1 = "Min Length:";
        const validation_max_char_length_subtitle$1 = "Max Length:";
        const validation_contains_subtitle$1 = "Contains:";
        const validation_not_contains_subtitle$1 = "Does not contain:";
        const validation_pattern_subtitle$1 = "Pattern:";
        const validation_max_word_count_subtitle$1 = "Max Count:";
        const validation_min_word_count_subtitle$1 = "Min Count:";
        const validation_between_subtitle$1 = "Between:";
        const validation_not_between_subtitle$1 = "Not between:";
        const validation_lt_subtitle$1 = "Less than:";
        const validation_lte_subtitle$1 = "Less than or equals:";
        const validation_gt_subtitle$1 = "Greater than:";
        const validation_gte_subtitle$1 = "Greater than or equals:";
        const validation_equals_subtitle$1 = "Equals:";
        const validation_not_equal_subtitle$1 = "Not equals:";
        const validation_min_option_count_subtitle$1 = "Min Count:";
        const validation_max_option_count_subtitle$1 = "Max Count:";
        const validation_option_count_subtitle$1 = "Count:";
        const validation_min_ranking_count_subtitle$1 = "Min Count";
        const validation_max_ranking_count_subtitle$1 = "Max Count";
        const validation_ranking_count_subtitle$1 = "Count:";
        const standard_error$1 = "Standard Error";
        const custom_error$1 = "Custom Error";
        const component_text_title$1 = "Short Text";
        const component_paragraph_title$1 = "Long Text";
        const component_barcode_title$1 = "Barcode/QrCode Scanner";
        const component_number_title$1 = "Number";
        const component_email_title$1 = "Email";
        const component_scq_title$1 = "Single Choice";
        const component_image_scq_title$1 = "Single Image Choice";
        const component_scq_array_title$1 = "Single Choice Array";
        const component_mcq_title$1 = "Multiple Choice";
        const component_image_mcq_title$1 = "Multiple Image Choice";
        const component_nps_title$1 = "NPS";
        const component_date_title$1 = "Date";
        const component_date_time_title$1 = "Date and Time";
        const component_time_title$1 = "Time";
        const component_file_upload_title$1 = "File Upload";
        const component_signature_title$1 = "Signature";
        const component_photo_capture_title$1 = "Capture Photo";
        const component_video_capture_title$1 = "Capture Video";
        const component_ranking_title$1 = "Ranking";
        const component_image_ranking_title$1 = "Image Ranking";
        const component_text_display_title$1 = "Text Display";
        const component_image_display_title$1 = "Image Display";
        const component_video_display_title$1 = "Video Display";
        const component_group_title$1 = "Group";
        const component_welcome_title$1 = "Welcome Group";
        const component_end_title$1 = "End Group";
        const section_text_based$1 = "Text based";
        const section_choice_based$1 = "Choice based";
        const section_date_time$1 = "Date / Time";
        const section_file_based$1 = "File based";
        const section_other$1 = "Other";
        const section_info$1 = "Info";
        const section_sections$1 = "Sections";
        const add_option$1 = "Add Option";
        const add_row$1 = "Add Row";
        const add_column$1 = "Add Column";
        const add_other$1 = "Add \"Other\"";
        const or$1 = "Or";
        const err_priority$1 = "Priority Group instruction Error";
        const err_random$1 = "Random Group instruction Error";
        const err_relevance = "Problem with Show/Hide Logic";
        const err_value_in_end_group$1 = "Cannot have questions that capture user input in End Group";
        const err_skip = "Problem with one of the skip instructions";
        const err_reference$1 = "Error: piping a value of missing or a trailing question: <strong>{{codes}}</strong>, in Language: <strong>{{lang}}</strong>";
        const err_empty_parent$1 = "This {{component_name}} cannot be empty, Please add at least one {{child_name}}";
        const err_duplicate_code$1 = "This {{component_name}} has a duplicate code";
        const err_no_end_group$1 = "There must be an valid end Group";
        const err_misplaced_end_group$1 = "End Group must always be the last group";
        const err_misplaced_welcome_group$1 = "Welcome Group must always be the first group";
        const survey$1 = "Survey";
        const group$1 = "Group";
        const question$1 = "Question";
        const option$1 = "Option";
        const err_priority_group_item_not_child$1 = "Those items are either deleted or have errors and therefore cannot be in Priority Group: <strong>{{items}}</strong>";
        const err_random_group_item_not_child$1 = "Those items are either deleted or have errors and therefore cannot be in Random Group: <strong>{{items}}</strong>";
        const err_duplicate_priority_group_items$1 = "Those items are present in more than one priority Group: <strong>{{iterms}}</strong>";
        const err_priority_limit_mismatch$1 = "In one of the priority groups, the limit is more than or equal to number of items";
        const err_duplicate_random_group_items$1 = "Those items are present in more than one random group: <strong>{{items}}</strong>";
        const are_you_sure$1 = "Are you sure?";
        const empty_group_hint = "Drop a question here";
        const empty_survey_hint = "Drop a group here";
        const upload_image$1 = "Upload Image";
        const replace_image$1 = "Replace Image";
        const uploading_image$1 = "Uploading Image";
        const upload_video$1 = "Upload Video";
        const replace_video$1 = "Replace Video";
        const uploading_video$1 = "Uploading Video";
        const file_type$1 = "File Type";
        const file_types$1 = {
          presentation: "Presentation",
          document: "Document",
          spreadsheet: "Spreadsheet",
          pdf: "Pdf",
          image: "Image",
          video: "Video",
          audio: "Audio"
        };
        const design_en = {
          show_hide: show_hide$1,
          order_priority: order_priority$1,
          video_options: video_options$1,
          setup: setup$2,
          validation: validation$1,
          display: display$1,
          skip_logic: skip_logic$1,
          show_always: show_always$1,
          show_if: show_if$1,
          hide_always: hide_always$1,
          hide_if: hide_if$1,
          condition_to_show: condition_to_show$1,
          condition_to_hide: condition_to_hide$1,
          no_logic_err: no_logic_err$1,
          wrong_logic_err: wrong_logic_err$1,
          no_condition: no_condition$1,
          text_field_size: text_field_size$1,
          textarea_lines: textarea_lines$1,
          hide_text: hide_text$1,
          show_word_count: show_word_count$1,
          lower_bound_hint: lower_bound_hint,
          upper_bound_hint: upper_bound_hint$1,
          loop_video: loop_video$1,
          audio_only: audio_only$1,
          fullday_format: fullday_format$1,
          max_date: max_date$1,
          min_date: min_date$1,
          date_format: date_format$1,
          image_aspect_ratio: image_aspect_ratio$1,
          columns_number: columns_number,
          image_height: image_height$1,
          spacing: spacing$1,
          show_question_hint: show_question_hint$1,
          to_group_end: to_group_end$1,
          skip_to: skip_to$1,
          ok: ok,
          proceed_as_usual: proceed_as_usual$1,
          if_answer_is: if_answer_is$1,
          invalid_skip_destination_err: invalid_skip_destination_err,
          theme: theme$1,
          text_style: text_style$1,
          group_title: group_title$1,
          question_title: question_title$1,
          choose_image: choose_image$1,
          theme_text: theme_text$1,
          theme_header: theme_header$1,
          foreground_color: foreground_color$1,
          background_color: background_color$1,
          highlight_color: highlight_color$1,
          questions_order: questions_order$1,
          questions_priority: questions_priority$1,
          groups_order: groups_order$1,
          groups_priority: groups_priority$1,
          options_order: options_order$1,
          options_priority: options_priority$1,
          rows_order: rows_order$1,
          rows_priority: rows_priority$1,
          columns_order: columns_order$1,
          columns_priority: columns_priority,
          as_is: as_is$1,
          random_order: random_order$1,
          flip_order: flip_order$1,
          custom_random: custom_random$1,
          sort_by_label: sort_by_label$1,
          no_priority: no_priority$1,
          prioritise_questions: prioritise_questions,
          prioritise_groups: prioritise_groups,
          prioritise_options: prioritise_options,
          prioritise_rows: prioritise_rows,
          prioritise_columns: prioritise_columns,
          add_new_random_rule: add_new_random_rule$1,
          edit_random_rule: edit_random_rule$1,
          edit_priority_rule: edit_priority_rule$1,
          cancel: cancel$1,
          submit: submit$1,
          add_random_rule: add_random_rule$1,
          add_priority_rule: add_priority_rule$1,
          prioritise: prioritise$1,
          priority_show: priority_show$1,
          priority_show_limit_from_count: priority_show_limit_from_count$1,
          validation_required_title: validation_required_title$1,
          validation_file_types_title: validation_file_types_title$1,
          validation_max_file_size_title: validation_max_file_size_title$1,
          validation_max_file_size_subtitle: validation_max_file_size_subtitle$1,
          validation_min_char_length_title: validation_min_char_length_title$1,
          validation_max_char_length_title: validation_max_char_length_title$1,
          validation_contains_title: validation_contains_title$1,
          validation_not_contains_title: validation_not_contains_title$1,
          validation_pattern_title: validation_pattern_title$1,
          validation_max_word_count_title: validation_max_word_count_title$1,
          validation_min_word_count_title: validation_min_word_count_title$1,
          validation_pattern_email_title: validation_pattern_email_title$1,
          validation_between_title: validation_between_title$1,
          validation_not_between_title: validation_not_between_title$1,
          validation_lt_title: validation_lt_title$1,
          validation_lte_title: validation_lte_title$1,
          validation_gt_title: validation_gt_title$1,
          validation_gte_title: validation_gte_title$1,
          validation_equals_title: validation_equals_title$1,
          validation_not_equal_title: validation_not_equal_title$1,
          validation_min_option_count_title: validation_min_option_count_title$1,
          validation_max_option_count_title: validation_max_option_count_title$1,
          validation_option_count_title: validation_option_count_title$1,
          validation_min_ranking_count_title: validation_min_ranking_count_title$1,
          validation_max_ranking_count_title: validation_max_ranking_count_title$1,
          validation_ranking_count_title: validation_ranking_count_title$1,
          validation_min_char_length_subtitle: validation_min_char_length_subtitle$1,
          validation_max_char_length_subtitle: validation_max_char_length_subtitle$1,
          validation_contains_subtitle: validation_contains_subtitle$1,
          validation_not_contains_subtitle: validation_not_contains_subtitle$1,
          validation_pattern_subtitle: validation_pattern_subtitle$1,
          validation_max_word_count_subtitle: validation_max_word_count_subtitle$1,
          validation_min_word_count_subtitle: validation_min_word_count_subtitle$1,
          validation_between_subtitle: validation_between_subtitle$1,
          validation_not_between_subtitle: validation_not_between_subtitle$1,
          validation_lt_subtitle: validation_lt_subtitle$1,
          validation_lte_subtitle: validation_lte_subtitle$1,
          validation_gt_subtitle: validation_gt_subtitle$1,
          validation_gte_subtitle: validation_gte_subtitle$1,
          validation_equals_subtitle: validation_equals_subtitle$1,
          validation_not_equal_subtitle: validation_not_equal_subtitle$1,
          validation_min_option_count_subtitle: validation_min_option_count_subtitle$1,
          validation_max_option_count_subtitle: validation_max_option_count_subtitle$1,
          validation_option_count_subtitle: validation_option_count_subtitle$1,
          validation_min_ranking_count_subtitle: validation_min_ranking_count_subtitle$1,
          validation_max_ranking_count_subtitle: validation_max_ranking_count_subtitle$1,
          validation_ranking_count_subtitle: validation_ranking_count_subtitle$1,
          standard_error: standard_error$1,
          custom_error: custom_error$1,
          component_text_title: component_text_title$1,
          component_paragraph_title: component_paragraph_title$1,
          component_barcode_title: component_barcode_title$1,
          component_number_title: component_number_title$1,
          component_email_title: component_email_title$1,
          component_scq_title: component_scq_title$1,
          component_image_scq_title: component_image_scq_title$1,
          component_scq_array_title: component_scq_array_title$1,
          component_mcq_title: component_mcq_title$1,
          component_image_mcq_title: component_image_mcq_title$1,
          component_nps_title: component_nps_title$1,
          component_date_title: component_date_title$1,
          component_date_time_title: component_date_time_title$1,
          component_time_title: component_time_title$1,
          component_file_upload_title: component_file_upload_title$1,
          component_signature_title: component_signature_title$1,
          component_photo_capture_title: component_photo_capture_title$1,
          component_video_capture_title: component_video_capture_title$1,
          component_ranking_title: component_ranking_title$1,
          component_image_ranking_title: component_image_ranking_title$1,
          component_text_display_title: component_text_display_title$1,
          component_image_display_title: component_image_display_title$1,
          component_video_display_title: component_video_display_title$1,
          component_group_title: component_group_title$1,
          component_welcome_title: component_welcome_title$1,
          component_end_title: component_end_title$1,
          section_text_based: section_text_based$1,
          section_choice_based: section_choice_based$1,
          section_date_time: section_date_time$1,
          section_file_based: section_file_based$1,
          section_other: section_other$1,
          section_info: section_info$1,
          section_sections: section_sections$1,
          add_option: add_option$1,
          add_row: add_row$1,
          add_column: add_column$1,
          add_other: add_other$1,
          or: or$1,
          err_priority: err_priority$1,
          err_random: err_random$1,
          err_relevance: err_relevance,
          err_value_in_end_group: err_value_in_end_group$1,
          err_skip: err_skip,
          err_reference: err_reference$1,
          err_empty_parent: err_empty_parent$1,
          err_duplicate_code: err_duplicate_code$1,
          err_no_end_group: err_no_end_group$1,
          err_misplaced_end_group: err_misplaced_end_group$1,
          err_misplaced_welcome_group: err_misplaced_welcome_group$1,
          survey: survey$1,
          group: group$1,
          question: question$1,
          option: option$1,
          err_priority_group_item_not_child: err_priority_group_item_not_child$1,
          err_random_group_item_not_child: err_random_group_item_not_child$1,
          err_duplicate_priority_group_items: err_duplicate_priority_group_items$1,
          err_priority_limit_mismatch: err_priority_limit_mismatch$1,
          err_duplicate_random_group_items: err_duplicate_random_group_items$1,
          are_you_sure: are_you_sure$1,
          empty_group_hint: empty_group_hint,
          empty_survey_hint: empty_survey_hint,
          upload_image: upload_image$1,
          replace_image: replace_image$1,
          uploading_image: uploading_image$1,
          upload_video: upload_video$1,
          replace_video: replace_video$1,
          uploading_video: uploading_video$1,
          file_type: file_type$1,
          file_types: file_types$1
        };
        const show_hide = " / ";
        const order_priority = " ";
        const video_options = " ";
        const setup$1 = "";
        const validation = "  ";
        const display = "";
        const skip_logic = " ";
        const show_always = " ";
        const show_if = " ";
        const hide_always = " ";
        const hide_if = " ";
        const condition_to_show = "  ";
        const condition_to_hide = " ";
        const no_logic_err = "   ,      <strong>   </ strong>";
        const wrong_logic_err = "           <strong>   </ strong>";
        const no_condition = " ";
        const text_field_size = "  ";
        const textarea_lines = "TextArea Lines";
        const hide_text = "Hide Text";
        const show_word_count = "  ";
        const Lower_bound_hint = "  ";
        const upper_bound_hint = "   ";
        const loop_video = "Loop Video";
        const audio_only = " ";
        const fullday_format = " FullDay";
        const max_date = " ";
        const min_date = "Min Date";
        const date_format = " ";
        const image_aspect_ratio = "    ";
        const column_number = " ";
        const image_height = " ";
        const spacing = "";
        const show_question_hint = "  ";
        const to_group_end = "To Group End";
        const skip_to = " ";
        const proceed_as_usual = " ";
        const if_answer_is = "    <strong> {{code} </strong>";
        const unknown_skip_destination_err = "<strong> {{code}} </strong>     ...";
        const theme = "";
        const text_style = " ";
        const group_title = " ";
        const question_title = " ";
        const choose_image = " ";
        const theme_text = "Text";
        const theme_header = "Header";
        const foreground_color = " ";
        const background_color = " ";
        const highlight_color = " ";
        const questions_order = " ";
        const questions_priority = " ";
        const groups_order = " ";
        const groups_priority = " ";
        const options_order = " ";
        const options_priority = " ";
        const rows_order = " ";
        const rows_priority = " ";
        const columns_order = " ";
        const column_priority = " ";
        const as_is = " ";
        const random_order = " ";
        const flip_order = " ";
        const custom_random = "";
        const sort_by_label = "  ";
        const no_priority = "";
        const Prioritise_questions = "   ";
        const Prioritise_groups = "  ";
        const Prioritise_options = " ";
        const Prioritise_rows = " ";
        const Prioritise_columns = "  ";
        const add_new_random_rule = "   ";
        const edit_random_rule = "Edit Random Rule";
        const edit_priority_rule = "  ";
        const cancel = "";
        const submit = "";
        const add_random_rule = "Add Random Rule";
        const add_priority_rule = "  ";
        const prioritise = " ";
        const priority_show = "";
        const priority_show_limit_from_count = " {{limit}}  {{count}}";
        const validation_required_title = "";
        const validation_min_char_length_title = "   ";
        const validation_max_char_length_title = "  ";
        const validation_contains_title = " ";
        const validation_not_contains_title = "  ";
        const validation_pattern_title = " ";
        const validation_max_word_count_title = "   ";
        const validation_min_word_count_title = "   ";
        const validation_pattern_email_title = "  ";
        const validation_between_title = " ";
        const validation_not_between_title = "  ";
        const validation_lt_title = "  ";
        const validation_lte_title = "    ";
        const validation_gt_title = "  ";
        const validation_gte_title = "    ";
        const validation_equals_title = " ";
        const validation_not_equal_title = "  ";
        const validation_min_option_count_title = "   ";
        const validation_max_option_count_title = "   ";
        const validation_option_count_title = "  ";
        const validation_min_ranking_count_title = "    ";
        const validation_max_ranking_count_title = "  ";
        const validation_ranking_count_title = "  ";
        const validation_min_char_length_subtitle = "  :";
        const validation_max_char_length_subtitle = " :";
        const validation_contains_subtitle = " :";
        const validation_not_contains_subtitle = "  :";
        const validation_pattern_subtitle = ":";
        const validation_max_word_count_subtitle = " :";
        const validation_min_word_count_subtitle = "Min Count:";
        const validation_between_subtitle = ":";
        const validation_not_between_subtitle = " :";
        const validation_lt_subtitle = " :";
        const validation_lte_subtitle = "   :";
        const validation_gt_subtitle = " :";
        const validation_gte_subtitle = "   :";
        const validation_equals_subtitle = ":";
        const validation_not_equal_subtitle = " :";
        const validation_min_option_count_subtitle = " :";
        const validation_max_option_count_subtitle = "  :";
        const validation_option_count_subtitle = ":";
        const validation_min_ranking_count_subtitle = " :";
        const validation_max_ranking_count_subtitle = " :";
        const validation_ranking_count_subtitle = ":";
        const standard_error = " ";
        const custom_error = " ";
        const component_text_title = " ";
        const component_paragraph_title = " ";
        const component_barcode_title = "Barcode/QrCode Scanner";
        const component_number_title = "Number";
        const component_email_title = "Email";
        const component_scq_title = " ";
        const component_image_scq_title = "  ";
        const component_scq_array_title = "  ";
        const component_mcq_title = "  ";
        const component_image_mcq_title = "  ";
        const component_nps_title = "NPS";
        const component_date_title = "";
        const component_date_time_title = " ";
        const component_time_title = "";
        const component_file_upload_title = " ";
        const component_signature_title = "";
        const component_photo_capture_title = " ";
        const component_video_capture_title = " ";
        const component_ranking_title = "";
        const component_image_ranking_title = " ";
        const component_text_display_title = " ";
        const component_image_display_title = " ";
        const component_video_display_title = " ";
        const component_group_title = "";
        const component_welcome_title = " ";
        const component_end_title = "";
        const section_text_based = "  ";
        const section_choice_based = "  ";
        const section_date_time = " / ";
        const section_file_based = "  ";
        const section_other = "";
        const section_info = "";
        const section_sections = "";
        const add_option = " ";
        const add_row = " ";
        const add_column = " ";
        const add_other = " \"\"";
        const or = "";
        const err_priority = "     ";
        const err_random = "    ";
        const err_relibility = "   / ";
        const err_value_in_end_group = "          End Group";
        const Err_skip = "    ";
        const err_reference = ":      : <strong> {{codes}} </strong> ,  : <strong> {{lang}} </strong>";
        const err_empty_parent = "    {{component_name}}  ,   {{child_name}}   ";
        const err_duplicate_code = " {{component_name}}   ";
        const err_no_end_group = "      ";
        const err_misplaced_end_group = "        ";
        const err_misplaced_welcome_group = "        ";
        const survey = "";
        const group = "";
        const question = "";
        const option = "";
        const err_priority_group_item_not_child = "              : <strong> {{items}} </strong>";
        const err_random_group_item_not_child = "              : <strong> {{items}} </strong>";
        const err_duplicate_priority_group_items = "        : <strong> {{iterms}} </strong>";
        const err_priority_limit_mismatch = "    ,        ";
        const err_duplicate_random_group_items = "        : <strong> {{items}} </strong>";
        const are_you_sure = "  ";
        const blank_group_hint = "  ";
        const blank_survey_hint = "  ";
        const validation_file_types_title = " ";
        const validation_max_file_size_title = "   ";
        const validation_max_file_size_subtitle = "   ( )";
        const file_type = " ";
        const file_types = {
          presentation: "",
          document: "",
          spreadsheet: " ",
          pdf: "Pdf",
          image: "",
          video: "",
          audio: ""
        };
        const design_ar = {
          show_hide: show_hide,
          order_priority: order_priority,
          video_options: video_options,
          setup: setup$1,
          validation: validation,
          display: display,
          skip_logic: skip_logic,
          show_always: show_always,
          show_if: show_if,
          hide_always: hide_always,
          hide_if: hide_if,
          condition_to_show: condition_to_show,
          condition_to_hide: condition_to_hide,
          no_logic_err: no_logic_err,
          wrong_logic_err: wrong_logic_err,
          no_condition: no_condition,
          text_field_size: text_field_size,
          textarea_lines: textarea_lines,
          hide_text: hide_text,
          show_word_count: show_word_count,
          Lower_bound_hint: Lower_bound_hint,
          upper_bound_hint: upper_bound_hint,
          loop_video: loop_video,
          audio_only: audio_only,
          fullday_format: fullday_format,
          max_date: max_date,
          min_date: min_date,
          date_format: date_format,
          image_aspect_ratio: image_aspect_ratio,
          column_number: column_number,
          image_height: image_height,
          spacing: spacing,
          show_question_hint: show_question_hint,
          to_group_end: to_group_end,
          skip_to: skip_to,
          "ok ": "",
          proceed_as_usual: proceed_as_usual,
          if_answer_is: if_answer_is,
          unknown_skip_destination_err: unknown_skip_destination_err,
          theme: theme,
          text_style: text_style,
          group_title: group_title,
          question_title: question_title,
          choose_image: choose_image,
          theme_text: theme_text,
          theme_header: theme_header,
          foreground_color: foreground_color,
          background_color: background_color,
          highlight_color: highlight_color,
          questions_order: questions_order,
          questions_priority: questions_priority,
          groups_order: groups_order,
          groups_priority: groups_priority,
          options_order: options_order,
          options_priority: options_priority,
          rows_order: rows_order,
          rows_priority: rows_priority,
          columns_order: columns_order,
          column_priority: column_priority,
          as_is: as_is,
          random_order: random_order,
          flip_order: flip_order,
          custom_random: custom_random,
          sort_by_label: sort_by_label,
          no_priority: no_priority,
          Prioritise_questions: Prioritise_questions,
          Prioritise_groups: Prioritise_groups,
          Prioritise_options: Prioritise_options,
          Prioritise_rows: Prioritise_rows,
          Prioritise_columns: Prioritise_columns,
          add_new_random_rule: add_new_random_rule,
          edit_random_rule: edit_random_rule,
          edit_priority_rule: edit_priority_rule,
          cancel: cancel,
          submit: submit,
          add_random_rule: add_random_rule,
          add_priority_rule: add_priority_rule,
          prioritise: prioritise,
          priority_show: priority_show,
          priority_show_limit_from_count: priority_show_limit_from_count,
          validation_required_title: validation_required_title,
          validation_min_char_length_title: validation_min_char_length_title,
          validation_max_char_length_title: validation_max_char_length_title,
          validation_contains_title: validation_contains_title,
          validation_not_contains_title: validation_not_contains_title,
          validation_pattern_title: validation_pattern_title,
          validation_max_word_count_title: validation_max_word_count_title,
          validation_min_word_count_title: validation_min_word_count_title,
          validation_pattern_email_title: validation_pattern_email_title,
          validation_between_title: validation_between_title,
          validation_not_between_title: validation_not_between_title,
          validation_lt_title: validation_lt_title,
          validation_lte_title: validation_lte_title,
          validation_gt_title: validation_gt_title,
          validation_gte_title: validation_gte_title,
          validation_equals_title: validation_equals_title,
          validation_not_equal_title: validation_not_equal_title,
          validation_min_option_count_title: validation_min_option_count_title,
          validation_max_option_count_title: validation_max_option_count_title,
          validation_option_count_title: validation_option_count_title,
          validation_min_ranking_count_title: validation_min_ranking_count_title,
          validation_max_ranking_count_title: validation_max_ranking_count_title,
          validation_ranking_count_title: validation_ranking_count_title,
          validation_min_char_length_subtitle: validation_min_char_length_subtitle,
          validation_max_char_length_subtitle: validation_max_char_length_subtitle,
          validation_contains_subtitle: validation_contains_subtitle,
          validation_not_contains_subtitle: validation_not_contains_subtitle,
          validation_pattern_subtitle: validation_pattern_subtitle,
          validation_max_word_count_subtitle: validation_max_word_count_subtitle,
          validation_min_word_count_subtitle: validation_min_word_count_subtitle,
          validation_between_subtitle: validation_between_subtitle,
          validation_not_between_subtitle: validation_not_between_subtitle,
          validation_lt_subtitle: validation_lt_subtitle,
          validation_lte_subtitle: validation_lte_subtitle,
          validation_gt_subtitle: validation_gt_subtitle,
          validation_gte_subtitle: validation_gte_subtitle,
          validation_equals_subtitle: validation_equals_subtitle,
          validation_not_equal_subtitle: validation_not_equal_subtitle,
          validation_min_option_count_subtitle: validation_min_option_count_subtitle,
          validation_max_option_count_subtitle: validation_max_option_count_subtitle,
          validation_option_count_subtitle: validation_option_count_subtitle,
          validation_min_ranking_count_subtitle: validation_min_ranking_count_subtitle,
          validation_max_ranking_count_subtitle: validation_max_ranking_count_subtitle,
          validation_ranking_count_subtitle: validation_ranking_count_subtitle,
          standard_error: standard_error,
          custom_error: custom_error,
          component_text_title: component_text_title,
          component_paragraph_title: component_paragraph_title,
          component_barcode_title: component_barcode_title,
          component_number_title: component_number_title,
          component_email_title: component_email_title,
          component_scq_title: component_scq_title,
          component_image_scq_title: component_image_scq_title,
          component_scq_array_title: component_scq_array_title,
          component_mcq_title: component_mcq_title,
          component_image_mcq_title: component_image_mcq_title,
          component_nps_title: component_nps_title,
          component_date_title: component_date_title,
          component_date_time_title: component_date_time_title,
          component_time_title: component_time_title,
          component_file_upload_title: component_file_upload_title,
          component_signature_title: component_signature_title,
          component_photo_capture_title: component_photo_capture_title,
          component_video_capture_title: component_video_capture_title,
          component_ranking_title: component_ranking_title,
          component_image_ranking_title: component_image_ranking_title,
          component_text_display_title: component_text_display_title,
          component_image_display_title: component_image_display_title,
          component_video_display_title: component_video_display_title,
          component_group_title: component_group_title,
          component_welcome_title: component_welcome_title,
          component_end_title: component_end_title,
          section_text_based: section_text_based,
          section_choice_based: section_choice_based,
          section_date_time: section_date_time,
          section_file_based: section_file_based,
          section_other: section_other,
          section_info: section_info,
          section_sections: section_sections,
          add_option: add_option,
          add_row: add_row,
          add_column: add_column,
          add_other: add_other,
          or: or,
          err_priority: err_priority,
          err_random: err_random,
          err_relibility: err_relibility,
          err_value_in_end_group: err_value_in_end_group,
          Err_skip: Err_skip,
          err_reference: err_reference,
          err_empty_parent: err_empty_parent,
          err_duplicate_code: err_duplicate_code,
          err_no_end_group: err_no_end_group,
          err_misplaced_end_group: err_misplaced_end_group,
          err_misplaced_welcome_group: err_misplaced_welcome_group,
          survey: survey,
          group: group,
          question: question,
          option: option,
          err_priority_group_item_not_child: err_priority_group_item_not_child,
          err_random_group_item_not_child: err_random_group_item_not_child,
          err_duplicate_priority_group_items: err_duplicate_priority_group_items,
          err_priority_limit_mismatch: err_priority_limit_mismatch,
          err_duplicate_random_group_items: err_duplicate_random_group_items,
          are_you_sure: are_you_sure,
          blank_group_hint: blank_group_hint,
          blank_survey_hint: blank_survey_hint,
          validation_file_types_title: validation_file_types_title,
          validation_max_file_size_title: validation_max_file_size_title,
          validation_max_file_size_subtitle: validation_max_file_size_subtitle,
          file_type: file_type,
          file_types: file_types
        };
        const finish$2 = "Fertig";
        const next$4 = "Weiter";
        const previous$2 = "Zuruck";
        const lang$2 = "Sprache";
        const validation_file_types$2 = "Unbekannter Dateityp";
        const validation_min_char_length$2 = "Muss grer als {{min_length}} Zeichen sein";
        const validation_max_char_length$2 = "Muss kleiner als {{max_length}} Zeichen sein";
        const validation_between$2 = "Muss zwischen {{lower_limit}} und {{upper_limit}} liegen";
        const validation_not_between$2 = "muss kleiner als {{lower_limit}} oder grer als {{upper_limit}} sein";
        const validation_required$2 = "Dies ist erforderlich";
        const validation_pattern_email$2 = "Sollte wie eine E-Mail aussehen";
        const validation_max_word_count$2 = "Muss kleiner als {{max_count}} Wrter sein";
        const validation_min_word_count$2 = "Muss grer als {{min_count}} Wrter sein";
        const word_count$2 = "Wortzahl: {{count}}";
        const validation_max_file_size$2 = "Die Dateigre muss kleiner als {{max_size}} KB sein";
        const validation_pattern$2 = "Muster muss bereinstimmen";
        const validation_option_count$2 = "Bitte whlen Sie hchstens {{count}} Optionen aus";
        const validation_max_option_count$2 = "Bitte hchstens {{max_count}} Optionen auswhlen";
        const validation_min_option_count$2 = "Bitte mindestens {{min_count}} Optionen auswhlen";
        const validation_ranking_count$2 = "Bitte whlen Sie hchstens {{count}} Optionen aus";
        const validation_max_ranking_count$2 = "Bitte hchstens {{max_count}} Optionen auswhlen";
        const validation_min_ranking_count$2 = "Bitte mindestens {{min_count}} Optionen auswhlen";
        const validation_contains$2 = "Muss \"{{contains}}\" enthalten";
        const validation_not_contains$2 = "Darf nicht \"{{not_contains}}\" enthalten";
        const validation_gt$2 = "Muss grer als {{number}} sein";
        const validation_gte$2 = "Muss grer oder gleich {{number}} sein";
        const validation_lt$2 = "Muss kleiner als {{number}} sein";
        const validation_lte$2 = "Muss kleiner oder gleich {{number}} sein";
        const validation_equals$2 = "Muss {{number}} sein";
        const validation_not_equal$2 = "Darf nicht {{number}} sein";
        const processed_errors$5 = {
          survey_design_error: "Fehler im Umfragedesign... berprfen Sie das Umfragedesign",
          survey_not_active: "Diese Umfrage ist nicht aktiv",
          survey_closed: "Diese Umfrage ist nicht aktiv",
          survey_expired: "Diese Umfrage ist abgelaufen",
          survey_scheduled: "Diese Umfrage soll in der Zukunft beginnen"
        };
        const run_de = {
          finish: finish$2,
          next: next$4,
          previous: previous$2,
          lang: lang$2,
          validation_file_types: validation_file_types$2,
          validation_min_char_length: validation_min_char_length$2,
          validation_max_char_length: validation_max_char_length$2,
          validation_between: validation_between$2,
          validation_not_between: validation_not_between$2,
          validation_required: validation_required$2,
          validation_pattern_email: validation_pattern_email$2,
          validation_max_word_count: validation_max_word_count$2,
          validation_min_word_count: validation_min_word_count$2,
          word_count: word_count$2,
          validation_max_file_size: validation_max_file_size$2,
          validation_pattern: validation_pattern$2,
          validation_option_count: validation_option_count$2,
          validation_max_option_count: validation_max_option_count$2,
          validation_min_option_count: validation_min_option_count$2,
          validation_ranking_count: validation_ranking_count$2,
          validation_max_ranking_count: validation_max_ranking_count$2,
          validation_min_ranking_count: validation_min_ranking_count$2,
          validation_contains: validation_contains$2,
          validation_not_contains: validation_not_contains$2,
          validation_gt: validation_gt$2,
          validation_gte: validation_gte$2,
          validation_lt: validation_lt$2,
          validation_lte: validation_lte$2,
          validation_equals: validation_equals$2,
          validation_not_equal: validation_not_equal$2,
          processed_errors: processed_errors$5
        };
        const finish$1 = "Submit";
        const next$3 = "Next";
        const previous$1 = "Previous";
        const lang$1 = "Language";
        const validation_file_types$1 = "Unrecognized file type";
        const validation_min_char_length$1 = "Must be larger than {{min_length}} chars";
        const validation_max_char_length$1 = "Must be smaller than {{max_length}} chars";
        const validation_between$1 = "Must be between {{lower_limit}} and {{upper_limit}}";
        const validation_not_between$1 = "Must be less than {{lower_limit}} or higher than {{upper_limit}}";
        const validation_required$1 = "This is required";
        const validation_pattern_email$1 = "Should look like an email";
        const validation_max_word_count$1 = "Must be less than {{max_count}} words";
        const validation_min_word_count$1 = "Must be more than {{min_count}} words";
        const word_count$1 = "Word count: {{count}}";
        const validation_max_file_size$1 = "File size must be smaller than {{max_size}} KB";
        const validation_pattern$1 = "Must match pattern";
        const validation_option_count$1 = "Please choose at most {{count}} options";
        const validation_max_option_count$1 = "Please choose at most {{max_count}} options";
        const validation_min_option_count$1 = "Please choose at least {{min_count}} options";
        const validation_ranking_count$1 = "Please rank at most {{count}} options";
        const validation_max_ranking_count$1 = "Please rank at most {{max_count}} options";
        const validation_min_ranking_count$1 = "Please rank at least {{min_count}} options";
        const validation_contains$1 = "Must contain \"{{contains}}\"";
        const validation_not_contains$1 = "Must not contain \"{{not_contains}}\"";
        const validation_gt$1 = "Must be greater than {{number}}";
        const validation_gte$1 = "Must be greater than or equals {{number}}";
        const validation_lt$1 = "Must be less than {{number}}";
        const validation_lte$1 = "Must be less than or equals {{number}}";
        const validation_equals$1 = "Must be {{number}}";
        const validation_not_equal$1 = "Must not be {{number}}";
        const processed_errors$4 = {
          survey_design_error: "Survey Design Error... Check Survey Design",
          survey_not_active: "This survey is not active",
          survey_closed: "This survey is not active",
          survey_expired: "This survey is expired",
          survey_scheduled: "This survey is scheduled to start in the future"
        };
        const run_en = {
          finish: finish$1,
          next: next$3,
          previous: previous$1,
          lang: lang$1,
          validation_file_types: validation_file_types$1,
          validation_min_char_length: validation_min_char_length$1,
          validation_max_char_length: validation_max_char_length$1,
          validation_between: validation_between$1,
          validation_not_between: validation_not_between$1,
          validation_required: validation_required$1,
          validation_pattern_email: validation_pattern_email$1,
          validation_max_word_count: validation_max_word_count$1,
          validation_min_word_count: validation_min_word_count$1,
          word_count: word_count$1,
          validation_max_file_size: validation_max_file_size$1,
          validation_pattern: validation_pattern$1,
          validation_option_count: validation_option_count$1,
          validation_max_option_count: validation_max_option_count$1,
          validation_min_option_count: validation_min_option_count$1,
          validation_ranking_count: validation_ranking_count$1,
          validation_max_ranking_count: validation_max_ranking_count$1,
          validation_min_ranking_count: validation_min_ranking_count$1,
          validation_contains: validation_contains$1,
          validation_not_contains: validation_not_contains$1,
          validation_gt: validation_gt$1,
          validation_gte: validation_gte$1,
          validation_lt: validation_lt$1,
          validation_lte: validation_lte$1,
          validation_equals: validation_equals$1,
          validation_not_equal: validation_not_equal$1,
          processed_errors: processed_errors$4
        };
        const finish = "";
        const next$2 = "";
        const previous = "";
        const lang = "";
        const validation_min_char_length = "     {{min_length}} ";
        const validation_max_char_length = "     {{max_length}} ";
        const validation_between = "    {{lower_limit}}  {{upper_limit}}";
        const validation_not_between = "     {{lower_limit}}    {{upper_limit}}";
        const validation_required = " ";
        const validation_pattern_email = "     ";
        const validation_max_word_count = "     {{max_count}} ";
        const validation_min_word_count = "     {{min_count}} ";
        const word_count = " : {{count}}";
        const validation_max_file_size = "       {{max_size}} ";
        const validation_file_types = "   ";
        const validation_pattern = "    ";
        const validation_option_count = "  {{count}}    ";
        const validation_max_option_count = "  {{max_count}}    ";
        const validation_min_option_count = "  {{min_count}}   ";
        const validation_ranking_count = "  {{count}}    ";
        const validation_max_ranking_count = "  {{max_count}}    ";
        const validation_min_ranking_count = "  {{min_count}}   ";
        const validation_contains = "     \"{{contains}}\"";
        const validation_not_contains = "     \"{{not_contains}}\"";
        const validation_gt = "     {{number}}";
        const validation_gte = "       {{number}}";
        const validation_lt = "     {{number}}";
        const validation_lte = "       {{number}}";
        const validation_equals = "   {{number}}";
        const validation_not_equal = "   {{number}}";
        const processed_errors$3 = {
          survey_design_error: "    ...    ",
          survey_not_active: "   ",
          survey_closed: "   ",
          survey_expired: "   ",
          survey_scheduled: "       "
        };
        const run_ar = {
          finish: finish,
          next: next$2,
          previous: previous,
          lang: lang,
          validation_min_char_length: validation_min_char_length,
          validation_max_char_length: validation_max_char_length,
          validation_between: validation_between,
          validation_not_between: validation_not_between,
          validation_required: validation_required,
          validation_pattern_email: validation_pattern_email,
          validation_max_word_count: validation_max_word_count,
          validation_min_word_count: validation_min_word_count,
          word_count: word_count,
          validation_max_file_size: validation_max_file_size,
          validation_file_types: validation_file_types,
          validation_pattern: validation_pattern,
          validation_option_count: validation_option_count,
          validation_max_option_count: validation_max_option_count,
          validation_min_option_count: validation_min_option_count,
          validation_ranking_count: validation_ranking_count,
          validation_max_ranking_count: validation_max_ranking_count,
          validation_min_ranking_count: validation_min_ranking_count,
          validation_contains: validation_contains,
          validation_not_contains: validation_not_contains,
          validation_gt: validation_gt,
          validation_gte: validation_gte,
          validation_lt: validation_lt,
          validation_lte: validation_lte,
          validation_equals: validation_equals,
          validation_not_equal: validation_not_equal,
          processed_errors: processed_errors$3
        };
        const processed_errors$2 = {
          backend_down: "Backend ist nicht erreichbar... Bitte versuchen Sie es spter erneut",
          network_err: "Dieser Browser ist offline",
          wrong_credentials: "Falsche E-Mail oder Passwort",
          wrong_password: "Falsches Passwort",
          duplicate_email: "Doppelte E-Mail",
          duplicate_domain: "Doppelte Domne",
          expired_reset_token: "Abgelaufenes Besttigungstoken, bitte klicken Sie noch einmal auf Passwort vergessen",
          wrong_resettoken: "Dieses Reset-Token, klicken Sie noch einmal auf Passwort vergessen",
          used_confirmation_token: "Diese Besttigung war bereits ein Benutzer. Versuchen Sie, sich mit dem Benutzer anzumelden, den Sie gerade registriert haben",
          expired_confirmation_token: "Abgelaufenes Besttigungstoken, bitte erneut registrieren",
          duplicate_survey_name: "Doppelter Umfragename",
          unidentified_error: "Unerwarteter Fehler aufgetreten, bitte melden Sie sich an support@frankiesurveys.com",
          invalid_domain: "Ungltige Domain, darf nur Kleinbuchstaben, Ziffern oder Bindestriche \"-\" enthalten. Die Lnge sollte zwischen 3 und 12 Zeichen liegen."
        };
        const processed_successes$2 = {
          copied: "Kopiert"
        };
        const label$2 = {
          email: "Email",
          password: "Passwort",
          new_password: "Neues Kennwort",
          current_password: "Aktuelles Passwort",
          confirm_new_password: "Besttige neues Passwort",
          first_name: "Vorname",
          last_name: "Familienname, Nachname",
          server_name: "Server Name",
          super_admin: "Hchster Vorgesetzter",
          survey_admin: "Umfrage Admin",
          analyst: "Analytikerin",
          surveyor: "Landvermesser",
          surveyor_admin: "Surveyor-Administrator",
          survey_name: "Umfragename",
          new_survey_name: "Neuer Umfragename",
          base_language: "Basissprache",
          survey_mode: "Umfragemodus",
          additional_languages: "Weitere Sprachen",
          survey_active: "Umfrage aktiv",
          from: "Aus",
          to: "Zu",
          navigation_mode: "Navigationsmodus",
          public_within_org: "Die Umfrage steht allen Mitgliedern innerhalb der Organisation zur Verfgung",
          apply_quota: "Keine Quote",
          total_responses_limit: "Beantwortungslimit insgesamt: "
        };
        const language$2 = {
          en: "Englisch",
          de: "Deutsch",
          ar: "Arabisch"
        };
        const mode$2 = {
          web: "Web",
          offline: "Offline",
          mixed: "Web und Offline",
          GROUP_BY_GROUP: "Gruppieren nach Gruppe",
          QUESTION_BY_QUESTION: "Frage fr Frage",
          ALL_IN_ONE: "Alles in einem"
        };
        const status$2 = {
          draft: "Entwurf",
          active: "Aktiv",
          closed: "Geschlossen"
        };
        const error$2 = {
          invalid_email: "Ungltige E-Mail",
          password_should_match: "Password should match",
          required: "Is required"
        };
        const login$2 = {
          title: "Login",
          forgot_password: "Passwort vergessen",
          sign_up: "Anmeldung",
          submit: "Anmeldung"
        };
        const confirm_signup$1 = {
          error: "Ein Fehler ist aufgetreten",
          success: "Ihre Anmeldung wurde erfolgreich besttigt... Sie werden in 10 Sekunden auf die Startseite weitergeleitet"
        };
        const forgot_password$2 = {
          title: "Forgot Password",
          success: "Ein Link zum Zurcksetzen des Passworts wurde an Ihre E-Mail-Adresse gesendet. Er ist nur eine Stunde lang gltig",
          helper_text: "Wir senden einen Link zum Zurcksetzen des Passworts an diese E-Mail (falls vorhanden).",
          send: "Schicken"
        };
        const reset_password$2 = {
          title: "Passwort Zurcksetzen",
          reset: "Zurcksetzen"
        };
        const sign_up$2 = {
          title: "Sign Up",
          success: "Anmeldung erfolgreich besttigt... Bitte berprfen Sie Ihren Posteingang auf eine Besttigungs-E-Mail",
          sign_up: "Anmeldung",
          helper_text: "Whlen Sie einen Namen, um Ihren Server zu identifizieren und darauf zuzugreifen. Die meisten Benutzer entscheiden sich dafr, den Namen ihres Projekts, ihrer Umfrage oder Organisation zu verwenden."
        };
        const users_manage$2 = {
          name: "Name",
          email: "Email",
          roles: "Rollen",
          add_user: "Benutzer hinzufgen",
          title_delete: "Lschen",
          title_edit: "Bearbeiten",
          delete_title: "Mchten Sie {{name}} wirklich lschen?"
        };
        const action_btn$2 = {
          "delete": "Lschen",
          cancel: "Stornieren",
          save: "Speichern",
          close: "Schlieen",
          clone: "Klon",
          add_permission: "Berechtigung hinzufgen",
          add: "Hinzufgen"
        };
        const add_user$2 = {
          title: "Neuen Benutzer hinzufgen",
          roles: "Rollen",
          cancel: "Stornieren",
          save: "Speichern"
        };
        const edit_user$2 = {
          title: "Benutzer bearbeiten"
        };
        const profile$2 = {
          title: "Profil",
          cancel: "Stornieren",
          save: "Speichern",
          hint: "Wenn Sie Ihre E-Mail-Adresse oder Ihr Passwort ndern, werden Sie abgemeldet",
          password_required: "Aktuelles Passwort ist erforderlich, um Ihre E-Mail oder Ihr Passwort bearbeiten zu knnen"
        };
        const create_survey$2 = {
          title: "Umfrage erstellen"
        };
        const edit_survey$2 = {
          title: "Umfrage bearbeiten",
          general: "Allgemein",
          sharing: "Teilen",
          navigation: "Navigation",
          offline: "Offline",
          quotas: "Quoten",
          survey_users: "Benutzer befragen",
          privacy: "Privatsphre",
          status: "Status",
          delete_survey: "Mchten Sie {{survey_name}} wirklich lschen?",
          clone_survey: "Klon-Umfrage",
          default_survey_url: "Standard-Umfrage-URL",
          social_sharing: "Soziales Teilen",
          allow_previous: "Zurck zulassen",
          allow_incomplete: "Unvollstndig/Fortsetzen zulassen",
          allow_jump: "Jump/Show Survey Index zulassen",
          skip_invalid: "Validierung nur beim Absenden erzwingen",
          background_audio: "Audioaufnahme im Hintergrund",
          record_gps: "Verfolgen Sie den GPS-Standort",
          can_lock_survey: "Erlauben Sie Vermessern, die Vermessung zu sperren",
          save_ip: "IP-Adressen aufzeichnen",
          save_timings: "Zeiten aufzeichnen",
          limit_responses: "Begrenzen Sie die Antworten von Vermessern",
          surveyor: "Landvermesserin",
          count: "Zhlen",
          limit: "Grenze",
          to: "zu",
          responses: "antworten"
        };
        const responses$2 = {
          title: "Antworten",
          start_date: "Startdatum",
          submit_date: "Sendedatum",
          lang: "Sprache",
          raw_values: "Rohwerte anzeigen",
          raw_complete: "Roh vollstndig anzeigen",
          raw_preview: "Raw-Vorschau anzeigen",
          version: "Version",
          preview: "Vorschau",
          filter_completed: "Erledigte Antworten filtern",
          filter_completed_show_all: "Alle Antworten",
          filter_completed_show_completed: "Nur vollstndige Antworten",
          filter_completed_show_incomplete: "Nur unvollstndige Antworten",
          filter_preview: "Erledigte Antworten filtern",
          filter_preview_show_all: "Alle Antworten",
          filter_preview_show_preview: "Nur Vorschau der Antworten",
          filter_preview_show_actual: "Nur tatschliche Antworten",
          label_displayed_rows: "{{from}}-{{to}} von {{count}}",
          label_rows_per_page: "Zeilen pro Seite:",
          ip_addr: "IP-Adresse",
          title_delete_response: "Sind Sie sicher, dass Sie lschen mchten?"
        };
        const event_response$2 = {
          title: "Antwortereignisse",
          name: "Name",
          time: "Zeit",
          details: "Einzelheiten",
          direction: "Richtung"
        };
        const responses_count$2 = "Antwortanzahl:";
        const super_admins$2 = "super admins";
        const admins$2 = "admins";
        const analysts$2 = "analysten";
        const surveyors$2 = "vermesser";
        const surveyor_auditor$1 = "vermessungsprfer";
        const registered$2 = "eingetragen";
        const manage_users$2 = "Manage-Benutzer";
        const my_surveys$2 = "Meine Umfragen";
        const new_survey$2 = "Neue Umfrage";
        const added$2 = "Hinzugefgt:";
        const last_modified$2 = "Zuletzt bearbeitet:";
        const email_required$2 = "E-Mail ist erforderlich";
        const password_required$2 = "Passwort ist erforderlich";
        const confirm_password_required$1 = "Sie mssen das Passwort wiederholen";
        const domain_required$2 = "Domain ist erforderlich";
        const firstname_required$2 = "Vorname ist erforderlich";
        const lastname_required$1 = "Nachname ist erforderlich";
        const roles_required$2 = "Roles ist erforderlich";
        const survey_required$2 = "Name der Umfrage ist erforderlich";
        const base_language_required$2 = "Basissprache ist erforderlich";
        const survey_mode$2 = "Der Umfragemodus ist erforderlich";
        const manage_de = {
          processed_errors: processed_errors$2,
          processed_successes: processed_successes$2,
          label: label$2,
          language: language$2,
          mode: mode$2,
          status: status$2,
          error: error$2,
          login: login$2,
          confirm_signup: confirm_signup$1,
          forgot_password: forgot_password$2,
          reset_password: reset_password$2,
          sign_up: sign_up$2,
          users_manage: users_manage$2,
          action_btn: action_btn$2,
          add_user: add_user$2,
          edit_user: edit_user$2,
          profile: profile$2,
          create_survey: create_survey$2,
          edit_survey: edit_survey$2,
          responses: responses$2,
          event_response: event_response$2,
          responses_count: responses_count$2,
          super_admins: super_admins$2,
          admins: admins$2,
          analysts: analysts$2,
          surveyors: surveyors$2,
          surveyor_auditor: surveyor_auditor$1,
          registered: registered$2,
          manage_users: manage_users$2,
          my_surveys: my_surveys$2,
          new_survey: new_survey$2,
          added: added$2,
          last_modified: last_modified$2,
          email_required: email_required$2,
          password_required: password_required$2,
          confirm_password_required: confirm_password_required$1,
          domain_required: domain_required$2,
          firstname_required: firstname_required$2,
          lastname_required: lastname_required$1,
          roles_required: roles_required$2,
          survey_required: survey_required$2,
          base_language_required: base_language_required$2,
          survey_mode: survey_mode$2
        };
        const processed_errors$1 = {
          backend_down: "Backend is Unreachable... Please Try again later",
          network_err: "This broweser is offline",
          wrong_credentials: "Wrong email or password",
          wrong_password: "Wrong password",
          duplicate_email: "Duplicate Email",
          duplicate_domain: "Duplicate Domain",
          expired_reset_token: "Expired Confirmation Token, Please Click on Forgot password once more",
          wrong_reset_token: "This Reset Token is incorrect, Click on Forgot password once more",
          used_confirmation_token: "This confirmation was already user. Try to login with the user you just registered",
          expired_confirmation_token: "Expired Confirmation Token, Please Register Once more",
          duplicate_survey_name: "Duplicate Survey Name",
          unidentified_error: "Unexpected Error occurred, please report to support@frankiesurveys.com",
          invalid_domain: "Invalid Domain, must contain only lower case characters, digits or dash \"-\". Length should be between 3 and 12 characters"
        };
        const processed_successes$1 = {
          copied: "Copied"
        };
        const label$1 = {
          email: "Email",
          password: "Password",
          new_password: "New Password",
          current_password: "Current Password",
          confirm_new_password: "Confirm New Password",
          first_name: "First Name",
          last_name: "Last Name",
          server_name: "Server Name",
          super_admin: "Super Admin",
          survey_admin: "Survey Admin",
          analyst: "Analyst",
          surveyor: "Surveyor",
          surveyor_admin: "Surveyor admin",
          survey_name: "Survey Name",
          new_survey_name: "New Survey Name",
          base_language: "Base Language",
          survey_mode: "Survey Mode",
          additional_languages: "Additional Languages",
          survey_active: "Survey Active",
          from: "From",
          to: "To",
          navigation_mode: "Navigation Mode",
          public_within_org: "Survey is available to all members within the org",
          apply_quota: "Apply Quota",
          total_responses_limit: "Total Responses Limit: ",
          responses_limit: "Responses Limit: ",
          code: "Code"
        };
        const language$1 = {
          en: "English",
          de: "German",
          ar: "Arabic"
        };
        const mode$1 = {
          web: "Web",
          offline: "Offline",
          mixed: "Web and Offline",
          GROUP_BY_GROUP: "Group By Group",
          QUESTION_BY_QUESTION: "Question By Question",
          ALL_IN_ONE: "All In One"
        };
        const status$1 = {
          draft: "Draft",
          active: "Active",
          closed: "Closed"
        };
        const error$1 = {
          invalid_email: "Invalid Email",
          password_should_match: "Password should match",
          required: "Is required"
        };
        const login$1 = {
          title: "Login",
          forgot_password: "Forgot password",
          sign_up: "Sign Up",
          submit: "Submit"
        };
        const confirm_signup = {
          error: "An error occurred",
          success: "Your signup was confirmend successfully... you will be redirected to the home page in 10 seconds"
        };
        const forgot_password$1 = {
          title: "Forgot Password",
          success: "A reset password link was sent to your email.. It is valid for only one hour",
          helper_text: " We will send a reset password link to this email (if exist)",
          send: "Send"
        };
        const reset_password$1 = {
          title: "Reset Password",
          reset: "Reset"
        };
        const sign_up$1 = {
          title: "Sign Up",
          success: "Signup confirmed successfully... Please check your inbox for a confirmation email",
          sign_up: "Sign Up",
          helper_text: "Choose a name to identify and access your server. Most users choose to use the name of their project, survey,or organization."
        };
        const users_manage$1 = {
          name: "Name",
          email: "Email",
          roles: "Roles",
          add_user: "Add User",
          title_delete: "Delete",
          title_edit: "Edit",
          delete_title: "Are you sure you want to delete {{name}}?"
        };
        const action_btn$1 = {
          "delete": "Delete",
          cancel: "Cancel",
          save: "Save",
          close: "Close",
          clone: "Clone",
          add_permission: "Add Permission",
          add: "Add"
        };
        const add_user$1 = {
          title: "Add New User",
          roles: "Roles",
          cancel: "Cancel",
          save: "Save"
        };
        const edit_user$1 = {
          title: "Edit User"
        };
        const profile$1 = {
          title: "Profile",
          cancel: "Cancel",
          save: "Save",
          hint: "When you change your email or password, you will be logged out",
          password_required: "Current Password is Required to be able to edit your email or password"
        };
        const create_survey$1 = {
          title: "Create Survey"
        };
        const edit_survey$1 = {
          title: "Edit Survey",
          general: "General",
          sharing: "Sharing",
          navigation: "Navigation",
          offline: "Offline",
          quotas: "Quotas",
          survey_users: "Survey Users",
          privacy: "Privacy",
          status: "Status",
          delete_survey: "Are you sure you want to delete {{survey_name}}?",
          clone_survey: "Clone Survey",
          default_survey_url: "Default survey URL",
          social_sharing: "Social Sharing",
          allow_previous: "Allow Previous",
          allow_incomplete: "Allow Incomplete/Resume",
          allow_jump: "Allow Jump/Show survey Index",
          skip_invalid: "Enforce validation only on submit",
          background_audio: "Background Audio Recording",
          record_gps: "Track GPS Location",
          can_lock_survey: "Allow surveyors to lock survey",
          save_ip: "Record IP addresses",
          save_timings: "Record Timings",
          limit_responses: "Limit Responses by Surveyors",
          surveyor: "Surveyor",
          count: "Count",
          limit: "Limit",
          to: "to",
          responses: "responses"
        };
        const responses$1 = {
          title: "Responses",
          start_date: "Start Date",
          submit_date: "Submit Date",
          lang: "Language",
          raw_values: "Show Raw Values",
          version: "Version",
          preview: "Preview",
          filter_completed: "Filter Completed Responses",
          filter_completed_show_all: "All Responses",
          filter_completed_show_completed: "Complete Responses only",
          filter_completed_show_incomplete: "Incomplete Responses only",
          filter_preview: "Filter Preview Responses",
          filter_preview_show_all: "All Responses",
          filter_preview_show_preview: "Preview Responses only",
          filter_preview_show_actual: "Actual Responses only",
          label_displayed_rows: "{{from}}-{{to}} of {{count}}",
          label_rows_per_page: "Rows per page:",
          ip_addr: "IP Address",
          title_delete_response: "Are you sure you want to delete?"
        };
        const event_response$1 = {
          title: "Response Events",
          name: "Name",
          time: "Time",
          details: "Details",
          direction: "Direction"
        };
        const responses_count$1 = "Responses Count:";
        const super_admins$1 = "super admins";
        const admins$1 = "admins";
        const analysts$1 = "analysts";
        const surveyors$1 = "surveyors";
        const surveyor_auditor = "surveyor auditor";
        const registered$1 = "registered";
        const manage_users$1 = "Manage Users";
        const my_surveys$1 = "My Surveys";
        const new_survey$1 = "New Survey";
        const added$1 = "Added:";
        const last_modified$1 = "Last Modified:";
        const email_required$1 = "Email is Required";
        const password_required$1 = "Password is Required";
        const confirm_password_required = "You must repease password";
        const domain_required$1 = "Domain is Required";
        const firstname_required$1 = "First Name is Required";
        const lastname_required = "Last Name is Required";
        const roles_required$1 = "Roles is Required";
        const survey_required$1 = "Survey Name is Required";
        const base_language_required$1 = "Base Language is Required";
        const survey_mode$1 = "Survey Mode is Required";
        const manage_en = {
          processed_errors: processed_errors$1,
          processed_successes: processed_successes$1,
          label: label$1,
          language: language$1,
          mode: mode$1,
          status: status$1,
          error: error$1,
          login: login$1,
          confirm_signup: confirm_signup,
          forgot_password: forgot_password$1,
          reset_password: reset_password$1,
          sign_up: sign_up$1,
          users_manage: users_manage$1,
          action_btn: action_btn$1,
          add_user: add_user$1,
          edit_user: edit_user$1,
          profile: profile$1,
          create_survey: create_survey$1,
          edit_survey: edit_survey$1,
          responses: responses$1,
          event_response: event_response$1,
          responses_count: responses_count$1,
          super_admins: super_admins$1,
          admins: admins$1,
          analysts: analysts$1,
          surveyors: surveyors$1,
          surveyor_auditor: surveyor_auditor,
          registered: registered$1,
          manage_users: manage_users$1,
          my_surveys: my_surveys$1,
          new_survey: new_survey$1,
          added: added$1,
          last_modified: last_modified$1,
          email_required: email_required$1,
          password_required: password_required$1,
          confirm_password_required: confirm_password_required,
          domain_required: domain_required$1,
          firstname_required: firstname_required$1,
          lastname_required: lastname_required,
          roles_required: roles_required$1,
          survey_required: survey_required$1,
          base_language_required: base_language_required$1,
          survey_mode: survey_mode$1
        };
        const processed_errors = {
          backend_down: "     ...     ",
          network_err: "   ",
          false_credentials: "     ",
          wrong_password: "   ",
          duplicate_email: "  ",
          duplicate_domain: " ",
          expired_reset_token: "    ,        ",
          wrong_reset_token: "      ,       ",
          used_confirmation_token: "    .         ",
          expired_confirmation_token: "    ,    ",
          duplicate_survey_name: "  ",
          unidentified_error: "    ,   support@frankiesurveys.com",
          Invalid_domain: "   ,           \" - \".      3  12 "
        };
        const processed_successes = {
          copied: ""
        };
        const label = {
          email: " ",
          password: " ",
          new_password: "  ",
          confirm_new_password: "   ",
          first_name: " ",
          last_name: " ",
          server_name: " ",
          super_admin: " ",
          survey_admin: " ",
          analyst: "",
          surveyor: "",
          surveyor_admin: " ",
          survey_name: " ",
          new_survey_name: "  ",
          base_language: " ",
          survey_mode: " ",
          additional_languages: " ",
          survey_active: " ",
          from: "",
          to: "",
          navigation_mode: " ",
          public_within_org: "     ",
          application_quota: " ",
          total_responses_limit: "  :",
          code: ""
        };
        const language = {
          en: "",
          de: "",
          ar: ""
        };
        const mode = {
          web: "",
          offline: "",
          mixed: "  ",
          GROUP_BY_GROUP: "  ",
          QUESTION_BY_QUESTION: " ",
          ALL_IN_ONE: "  "
        };
        const status = {
          draft: "",
          active: "",
          closed: ""
        };
        const error = {
          invalid_email: "   ",
          password_should_match: "    ",
          required: ""
        };
        const login = {
          title: " ",
          forgot_password: "  ",
          sign_up: "",
          submit: " "
        };
        const Confirm_signup = {
          error: " ",
          success: "    ...         10 "
        };
        const forgot_password = {
          title: "  ",
          success: "          ..      ",
          helper_text: "          ( )",
          send: ""
        };
        const reset_password = {
          title: "   ",
          reset: " "
        };
        const sign_up = {
          title: "",
          success: "    ...           ",
          sign_up: "",
          helper_text: "       .          ."
        };
        const users_manage = {
          name: "",
          email: " ",
          roles: "",
          add_user: " ",
          title_delete: "",
          title_edit: "",
          delete_title: "      {{name}}"
        };
        const action_btn = {
          "delete": "",
          cancel: "",
          save: "",
          close: "",
          clone: "",
          add_permission: " ",
          add: ""
        };
        const add_user = {
          title: "  ",
          roles: "",
          cancel: "",
          save: ""
        };
        const edit_user = {
          title: " "
        };
        const profile = {
          title: " ",
          cancel: "",
          save: "",
          hint: "          ,   ",
          password_required: "           "
        };
        const create_survey = {
          title: " "
        };
        const edit_survey = {
          title: " ",
          general: "",
          sharing: "",
          navigation: "",
          offline: "   ",
          quotas: "",
          survey_users: " ",
          privacy: "",
          status: "",
          delete_survey: "      {{survey_name}}",
          clone_survey: " ",
          default_survey_url: " URL  ",
          social_sharing: " ",
          allow_previous: " ",
          allow_incomplete: "   / ",
          allow_jump: "  /   ",
          skip_invalid: "    ",
          background_audio: "   ",
          record_gps: "  GPS",
          can_lock_survey: "   ",
          save_ip: "  IP",
          save_timings: " ",
          limit_responses: "     ",
          surveyor: "",
          count: "",
          limit: "",
          to: "",
          responses: ""
        };
        const responses = {
          title: "",
          start_date: " ",
          submit_date: " ",
          lang: "",
          raw_values: "  ",
          raw_complete: "  ",
          raw_preview: "  ",
          version: "",
          preview: "",
          filter_completed: "  ",
          filter_completed_show_all: " ",
          filter_completed_show_completed: "  ",
          filter_completed_show_incomplete: "   ",
          filter_preview: "  ",
          filter_preview_show_all: " ",
          filter_preview_show_preview: "  ",
          filter_preview_show_actual: "  ",
          label_displayed_rows: "{{from}} - {{to}}  {{count}}",
          label_rows_per_page: "    :",
          ip_addr: " IP",
          title_delete_response: "     "
        };
        const event_response = {
          title: " ",
          name: "",
          time: "",
          details: "",
          direction: ""
        };
        const responses_count = " :";
        const super_admins = " ";
        const admins = "";
        const analysts = "";
        const surveyors = "";
        const Surveyor_auditor = " ";
        const registered = "";
        const manage_users = "Manage Users";
        const my_surveys = "My Surveys";
        const new_survey = " ";
        const added = " :";
        const last_modified = " :";
        const email_required = "  ";
        const password_required = "  ";
        const Confirm_password_required = "   ";
        const domain_required = " ";
        const firstname_required = "  ";
        const Lastname_required = "  ";
        const roles_required = " ";
        const survey_required = "  ";
        const base_language_required = "  ";
        const survey_mode = "  ";
        const upload_image = " ";
        const replace_image = " ";
        const uploading_image = " ";
        const upload_video = " ";
        const replace_video = " ";
        const uploading_video = " ";
        const manage_ar = {
          processed_errors: processed_errors,
          processed_successes: processed_successes,
          label: label,
          language: language,
          mode: mode,
          status: status,
          error: error,
          login: login,
          Confirm_signup: Confirm_signup,
          forgot_password: forgot_password,
          reset_password: reset_password,
          sign_up: sign_up,
          users_manage: users_manage,
          action_btn: action_btn,
          add_user: add_user,
          edit_user: edit_user,
          profile: profile,
          create_survey: create_survey,
          edit_survey: edit_survey,
          responses: responses,
          event_response: event_response,
          responses_count: responses_count,
          super_admins: super_admins,
          admins: admins,
          analysts: analysts,
          surveyors: surveyors,
          Surveyor_auditor: Surveyor_auditor,
          registered: registered,
          manage_users: manage_users,
          my_surveys: my_surveys,
          new_survey: new_survey,
          added: added,
          last_modified: last_modified,
          email_required: email_required,
          password_required: password_required,
          Confirm_password_required: Confirm_password_required,
          domain_required: domain_required,
          firstname_required: firstname_required,
          Lastname_required: Lastname_required,
          roles_required: roles_required,
          survey_required: survey_required,
          base_language_required: base_language_required,
          survey_mode: survey_mode,
          upload_image: upload_image,
          replace_image: replace_image,
          uploading_image: uploading_image,
          upload_video: upload_video,
          replace_video: replace_video,
          uploading_video: uploading_video
        };
        const scriptRel = 'modulepreload';
        const assetsURL = function (dep) {
          return "/" + dep;
        };
        const seen = {};
        const __vitePreload = function preload(baseModule, deps, importerUrl) {
          // @ts-expect-error false will be replaced with boolean later
          if (!false || !deps || deps.length === 0) {
            return baseModule();
          }
          const links = document.getElementsByTagName('link');
          return Promise.all(deps.map(dep => {
            // @ts-expect-error assetsURL is declared before preload.toString()
            dep = assetsURL(dep);
            if (dep in seen) return;
            seen[dep] = true;
            const isCss = dep.endsWith('.css');
            const cssSelector = isCss ? '[rel="stylesheet"]' : '';
            const isBaseRelative = !!importerUrl;
            // check if the file is already preloaded by SSR markup
            if (isBaseRelative) {
              // When isBaseRelative is true then we have `importerUrl` and `dep` is
              // already converted to an absolute URL by the `assetsURL` function
              for (let i = links.length - 1; i >= 0; i--) {
                const link = links[i];
                // The `links[i].href` is an absolute URL thanks to browser doing the work
                // for us. See https://html.spec.whatwg.org/multipage/common-dom-interfaces.html#reflecting-content-attributes-in-idl-attributes:idl-domstring-5
                if (link.href === dep && (!isCss || link.rel === 'stylesheet')) {
                  return;
                }
              }
            } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
              return;
            }
            const link = document.createElement('link');
            link.rel = isCss ? 'stylesheet' : scriptRel;
            if (!isCss) {
              link.as = 'script';
              link.crossOrigin = '';
            }
            link.href = dep;
            document.head.appendChild(link);
            if (isCss) {
              return new Promise((res, rej) => {
                link.addEventListener('load', res);
                link.addEventListener('error', () => rej(new Error(`Unable to preload CSS for ${dep}`)));
              });
            }
          })).then(() => baseModule());
        };
        function n$5(n) {
          for (var r = arguments.length, t = Array(r > 1 ? r - 1 : 0), e = 1; e < r; e++) t[e - 1] = arguments[e];
          throw Error("[Immer] minified error nr: " + n + (t.length ? " " + t.map(function (n) {
            return "'" + n + "'";
          }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
        }
        function r$5(n) {
          return !!n && !!n[Q];
        }
        function t$4(n) {
          var r;
          return !!n && (function (n) {
            if (!n || "object" != typeof n) return !1;
            var r = Object.getPrototypeOf(n);
            if (null === r) return !0;
            var t = Object.hasOwnProperty.call(r, "constructor") && r.constructor;
            return t === Object || "function" == typeof t && Function.toString.call(t) === Z;
          }(n) || Array.isArray(n) || !!n[L] || !!(null === (r = n.constructor) || void 0 === r ? void 0 : r[L]) || s(n) || v$4(n));
        }
        function i(n, r, t) {
          void 0 === t && (t = !1), 0 === o(n) ? (t ? Object.keys : nn)(n).forEach(function (e) {
            t && "symbol" == typeof e || r(e, n[e], n);
          }) : n.forEach(function (t, e) {
            return r(e, t, n);
          });
        }
        function o(n) {
          var r = n[Q];
          return r ? r.i > 3 ? r.i - 4 : r.i : Array.isArray(n) ? 1 : s(n) ? 2 : v$4(n) ? 3 : 0;
        }
        function u$4(n, r) {
          return 2 === o(n) ? n.has(r) : Object.prototype.hasOwnProperty.call(n, r);
        }
        function a(n, r) {
          return 2 === o(n) ? n.get(r) : n[r];
        }
        function f$3(n, r, t) {
          var e = o(n);
          2 === e ? n.set(r, t) : 3 === e ? n.add(t) : n[r] = t;
        }
        function c$3(n, r) {
          return n === r ? 0 !== n || 1 / n == 1 / r : n != n && r != r;
        }
        function s(n) {
          return X && n instanceof Map;
        }
        function v$4(n) {
          return q$5 && n instanceof Set;
        }
        function p$5(n) {
          return n.o || n.t;
        }
        function l$4(n) {
          if (Array.isArray(n)) return Array.prototype.slice.call(n);
          var r = rn(n);
          delete r[Q];
          for (var t = nn(r), e = 0; e < t.length; e++) {
            var i = t[e],
              o = r[i];
            !1 === o.writable && (o.writable = !0, o.configurable = !0), (o.get || o.set) && (r[i] = {
              configurable: !0,
              writable: !0,
              enumerable: o.enumerable,
              value: n[i]
            });
          }
          return Object.create(Object.getPrototypeOf(n), r);
        }
        function d$3(n, e) {
          return void 0 === e && (e = !1), y$2(n) || r$5(n) || !t$4(n) || (o(n) > 1 && (n.set = n.add = n.clear = n.delete = h$5), Object.freeze(n), e && i(n, function (n, r) {
            return d$3(r, !0);
          }, !0)), n;
        }
        function h$5() {
          n$5(2);
        }
        function y$2(n) {
          return null == n || "object" != typeof n || Object.isFrozen(n);
        }
        function b$3(r) {
          var t = tn[r];
          return t || n$5(18, r), t;
        }
        function m$4(n, r) {
          tn[n] || (tn[n] = r);
        }
        function _$1() {
          return U;
        }
        function j(n, r) {
          r && (b$3("Patches"), n.u = [], n.s = [], n.v = r);
        }
        function g$3(n) {
          O(n), n.p.forEach(S), n.p = null;
        }
        function O(n) {
          n === U && (U = n.l);
        }
        function w$3(n) {
          return U = {
            p: [],
            l: U,
            h: n,
            m: !0,
            _: 0
          };
        }
        function S(n) {
          var r = n[Q];
          0 === r.i || 1 === r.i ? r.j() : r.g = !0;
        }
        function P(r, e) {
          e._ = e.p.length;
          var i = e.p[0],
            o = void 0 !== r && r !== i;
          return e.h.O || b$3("ES5").S(e, r, o), o ? (i[Q].P && (g$3(e), n$5(4)), t$4(r) && (r = M(e, r), e.l || x$2(e, r)), e.u && b$3("Patches").M(i[Q].t, r, e.u, e.s)) : r = M(e, i, []), g$3(e), e.u && e.v(e.u, e.s), r !== H$1 ? r : void 0;
        }
        function M(n, r, t) {
          if (y$2(r)) return r;
          var e = r[Q];
          if (!e) return i(r, function (i, o) {
            return A$2(n, e, r, i, o, t);
          }, !0), r;
          if (e.A !== n) return r;
          if (!e.P) return x$2(n, e.t, !0), e.t;
          if (!e.I) {
            e.I = !0, e.A._--;
            var o = 4 === e.i || 5 === e.i ? e.o = l$4(e.k) : e.o,
              u = o,
              a = !1;
            3 === e.i && (u = new Set(o), o.clear(), a = !0), i(u, function (r, i) {
              return A$2(n, e, o, r, i, t, a);
            }), x$2(n, o, !1), t && n.u && b$3("Patches").N(e, t, n.u, n.s);
          }
          return e.o;
        }
        function A$2(e, i, o, a, c, s, v) {
          if (r$5(c)) {
            var p = M(e, c, s && i && 3 !== i.i && !u$4(i.R, a) ? s.concat(a) : void 0);
            if (f$3(o, a, p), !r$5(p)) return;
            e.m = !1;
          } else v && o.add(c);
          if (t$4(c) && !y$2(c)) {
            if (!e.h.D && e._ < 1) return;
            M(e, c), i && i.A.l || x$2(e, c);
          }
        }
        function x$2(n, r, t) {
          void 0 === t && (t = !1), !n.l && n.h.D && n.m && d$3(r, t);
        }
        function z$2(n, r) {
          var t = n[Q];
          return (t ? p$5(t) : n)[r];
        }
        function I$1(n, r) {
          if (r in n) for (var t = Object.getPrototypeOf(n); t;) {
            var e = Object.getOwnPropertyDescriptor(t, r);
            if (e) return e;
            t = Object.getPrototypeOf(t);
          }
        }
        function k$4(n) {
          n.P || (n.P = !0, n.l && k$4(n.l));
        }
        function E$1(n) {
          n.o || (n.o = l$4(n.t));
        }
        function N(n, r, t) {
          var e = s(r) ? b$3("MapSet").F(r, t) : v$4(r) ? b$3("MapSet").T(r, t) : n.O ? function (n, r) {
            var t = Array.isArray(n),
              e = {
                i: t ? 1 : 0,
                A: r ? r.A : _$1(),
                P: !1,
                I: !1,
                R: {},
                l: r,
                t: n,
                k: null,
                o: null,
                j: null,
                C: !1
              },
              i = e,
              o = en;
            t && (i = [e], o = on);
            var u = Proxy.revocable(i, o),
              a = u.revoke,
              f = u.proxy;
            return e.k = f, e.j = a, f;
          }(r, t) : b$3("ES5").J(r, t);
          return (t ? t.A : _$1()).p.push(e), e;
        }
        function R(e) {
          return r$5(e) || n$5(22, e), function n(r) {
            if (!t$4(r)) return r;
            var e,
              u = r[Q],
              c = o(r);
            if (u) {
              if (!u.P && (u.i < 4 || !b$3("ES5").K(u))) return u.t;
              u.I = !0, e = D$1(r, c), u.I = !1;
            } else e = D$1(r, c);
            return i(e, function (r, t) {
              u && a(u.t, r) === t || f$3(e, r, n(t));
            }), 3 === c ? new Set(e) : e;
          }(e);
        }
        function D$1(n, r) {
          switch (r) {
            case 2:
              return new Map(n);
            case 3:
              return Array.from(n);
          }
          return l$4(n);
        }
        function F$1() {
          function t(n, r) {
            var t = s[n];
            return t ? t.enumerable = r : s[n] = t = {
              configurable: !0,
              enumerable: r,
              get: function () {
                var r = this[Q];
                return en.get(r, n);
              },
              set: function (r) {
                var t = this[Q];
                en.set(t, n, r);
              }
            }, t;
          }
          function e(n) {
            for (var r = n.length - 1; r >= 0; r--) {
              var t = n[r][Q];
              if (!t.P) switch (t.i) {
                case 5:
                  a(t) && k$4(t);
                  break;
                case 4:
                  o(t) && k$4(t);
              }
            }
          }
          function o(n) {
            for (var r = n.t, t = n.k, e = nn(t), i = e.length - 1; i >= 0; i--) {
              var o = e[i];
              if (o !== Q) {
                var a = r[o];
                if (void 0 === a && !u$4(r, o)) return !0;
                var f = t[o],
                  s = f && f[Q];
                if (s ? s.t !== a : !c$3(f, a)) return !0;
              }
            }
            var v = !!r[Q];
            return e.length !== nn(r).length + (v ? 0 : 1);
          }
          function a(n) {
            var r = n.k;
            if (r.length !== n.t.length) return !0;
            var t = Object.getOwnPropertyDescriptor(r, r.length - 1);
            if (t && !t.get) return !0;
            for (var e = 0; e < r.length; e++) if (!r.hasOwnProperty(e)) return !0;
            return !1;
          }
          var s = {};
          m$4("ES5", {
            J: function (n, r) {
              var e = Array.isArray(n),
                i = function (n, r) {
                  if (n) {
                    for (var e = Array(r.length), i = 0; i < r.length; i++) Object.defineProperty(e, "" + i, t(i, !0));
                    return e;
                  }
                  var o = rn(r);
                  delete o[Q];
                  for (var u = nn(o), a = 0; a < u.length; a++) {
                    var f = u[a];
                    o[f] = t(f, n || !!o[f].enumerable);
                  }
                  return Object.create(Object.getPrototypeOf(r), o);
                }(e, n),
                o = {
                  i: e ? 5 : 4,
                  A: r ? r.A : _$1(),
                  P: !1,
                  I: !1,
                  R: {},
                  l: r,
                  t: n,
                  k: i,
                  o: null,
                  g: !1,
                  C: !1
                };
              return Object.defineProperty(i, Q, {
                value: o,
                writable: !0
              }), i;
            },
            S: function (n, t, o) {
              o ? r$5(t) && t[Q].A === n && e(n.p) : (n.u && function n(r) {
                if (r && "object" == typeof r) {
                  var t = r[Q];
                  if (t) {
                    var e = t.t,
                      o = t.k,
                      f = t.R,
                      c = t.i;
                    if (4 === c) i(o, function (r) {
                      r !== Q && (void 0 !== e[r] || u$4(e, r) ? f[r] || n(o[r]) : (f[r] = !0, k$4(t)));
                    }), i(e, function (n) {
                      void 0 !== o[n] || u$4(o, n) || (f[n] = !1, k$4(t));
                    });else if (5 === c) {
                      if (a(t) && (k$4(t), f.length = !0), o.length < e.length) for (var s = o.length; s < e.length; s++) f[s] = !1;else for (var v = e.length; v < o.length; v++) f[v] = !0;
                      for (var p = Math.min(o.length, e.length), l = 0; l < p; l++) o.hasOwnProperty(l) || (f[l] = !0), void 0 === f[l] && n(o[l]);
                    }
                  }
                }
              }(n.p[0]), e(n.p));
            },
            K: function (n) {
              return 4 === n.i ? o(n) : a(n);
            }
          });
        }
        var G$1,
          U,
          W = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x"),
          X = "undefined" != typeof Map,
          q$5 = "undefined" != typeof Set,
          B$1 = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect,
          H$1 = W ? Symbol.for("immer-nothing") : ((G$1 = {})["immer-nothing"] = !0, G$1),
          L = W ? Symbol.for("immer-draftable") : "__$immer_draftable",
          Q = W ? Symbol.for("immer-state") : "__$immer_state",
          Z = "" + Object.prototype.constructor,
          nn = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function (n) {
            return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n));
          } : Object.getOwnPropertyNames,
          rn = Object.getOwnPropertyDescriptors || function (n) {
            var r = {};
            return nn(n).forEach(function (t) {
              r[t] = Object.getOwnPropertyDescriptor(n, t);
            }), r;
          },
          tn = {},
          en = {
            get: function (n, r) {
              if (r === Q) return n;
              var e = p$5(n);
              if (!u$4(e, r)) return function (n, r, t) {
                var e,
                  i = I$1(r, t);
                return i ? "value" in i ? i.value : null === (e = i.get) || void 0 === e ? void 0 : e.call(n.k) : void 0;
              }(n, e, r);
              var i = e[r];
              return n.I || !t$4(i) ? i : i === z$2(n.t, r) ? (E$1(n), n.o[r] = N(n.A.h, i, n)) : i;
            },
            has: function (n, r) {
              return r in p$5(n);
            },
            ownKeys: function (n) {
              return Reflect.ownKeys(p$5(n));
            },
            set: function (n, r, t) {
              var e = I$1(p$5(n), r);
              if (null == e ? void 0 : e.set) return e.set.call(n.k, t), !0;
              if (!n.P) {
                var i = z$2(p$5(n), r),
                  o = null == i ? void 0 : i[Q];
                if (o && o.t === t) return n.o[r] = t, n.R[r] = !1, !0;
                if (c$3(t, i) && (void 0 !== t || u$4(n.t, r))) return !0;
                E$1(n), k$4(n);
              }
              return n.o[r] === t && (void 0 !== t || r in n.o) || Number.isNaN(t) && Number.isNaN(n.o[r]) || (n.o[r] = t, n.R[r] = !0), !0;
            },
            deleteProperty: function (n, r) {
              return void 0 !== z$2(n.t, r) || r in n.t ? (n.R[r] = !1, E$1(n), k$4(n)) : delete n.R[r], n.o && delete n.o[r], !0;
            },
            getOwnPropertyDescriptor: function (n, r) {
              var t = p$5(n),
                e = Reflect.getOwnPropertyDescriptor(t, r);
              return e ? {
                writable: !0,
                configurable: 1 !== n.i || "length" !== r,
                enumerable: e.enumerable,
                value: t[r]
              } : e;
            },
            defineProperty: function () {
              n$5(11);
            },
            getPrototypeOf: function (n) {
              return Object.getPrototypeOf(n.t);
            },
            setPrototypeOf: function () {
              n$5(12);
            }
          },
          on = {};
        i(en, function (n, r) {
          on[n] = function () {
            return arguments[0] = arguments[0][0], r.apply(this, arguments);
          };
        }), on.deleteProperty = function (r, t) {
          return on.set.call(this, r, t, void 0);
        }, on.set = function (r, t, e) {
          return en.set.call(this, r[0], t, e, r[0]);
        };
        var un = function () {
            function e(r) {
              var e = this;
              this.O = B$1, this.D = !0, this.produce = function (r, i, o) {
                if ("function" == typeof r && "function" != typeof i) {
                  var u = i;
                  i = r;
                  var a = e;
                  return function (n) {
                    var r = this;
                    void 0 === n && (n = u);
                    for (var t = arguments.length, e = Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++) e[o - 1] = arguments[o];
                    return a.produce(n, function (n) {
                      var t;
                      return (t = i).call.apply(t, [r, n].concat(e));
                    });
                  };
                }
                var f;
                if ("function" != typeof i && n$5(6), void 0 !== o && "function" != typeof o && n$5(7), t$4(r)) {
                  var c = w$3(e),
                    s = N(e, r, void 0),
                    v = !0;
                  try {
                    f = i(s), v = !1;
                  } finally {
                    v ? g$3(c) : O(c);
                  }
                  return "undefined" != typeof Promise && f instanceof Promise ? f.then(function (n) {
                    return j(c, o), P(n, c);
                  }, function (n) {
                    throw g$3(c), n;
                  }) : (j(c, o), P(f, c));
                }
                if (!r || "object" != typeof r) {
                  if (void 0 === (f = i(r)) && (f = r), f === H$1 && (f = void 0), e.D && d$3(f, !0), o) {
                    var p = [],
                      l = [];
                    b$3("Patches").M(r, f, p, l), o(p, l);
                  }
                  return f;
                }
                n$5(21, r);
              }, this.produceWithPatches = function (n, r) {
                if ("function" == typeof n) return function (r) {
                  for (var t = arguments.length, i = Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++) i[o - 1] = arguments[o];
                  return e.produceWithPatches(r, function (r) {
                    return n.apply(void 0, [r].concat(i));
                  });
                };
                var t,
                  i,
                  o = e.produce(n, r, function (n, r) {
                    t = n, i = r;
                  });
                return "undefined" != typeof Promise && o instanceof Promise ? o.then(function (n) {
                  return [n, t, i];
                }) : [o, t, i];
              }, "boolean" == typeof (null == r ? void 0 : r.useProxies) && this.setUseProxies(r.useProxies), "boolean" == typeof (null == r ? void 0 : r.autoFreeze) && this.setAutoFreeze(r.autoFreeze);
            }
            var i = e.prototype;
            return i.createDraft = function (e) {
              t$4(e) || n$5(8), r$5(e) && (e = R(e));
              var i = w$3(this),
                o = N(this, e, void 0);
              return o[Q].C = !0, O(i), o;
            }, i.finishDraft = function (r, t) {
              var e = r && r[Q];
              var i = e.A;
              return j(i, t), P(void 0, i);
            }, i.setAutoFreeze = function (n) {
              this.D = n;
            }, i.setUseProxies = function (r) {
              r && !B$1 && n$5(20), this.O = r;
            }, i.applyPatches = function (n, t) {
              var e;
              for (e = t.length - 1; e >= 0; e--) {
                var i = t[e];
                if (0 === i.path.length && "replace" === i.op) {
                  n = i.value;
                  break;
                }
              }
              e > -1 && (t = t.slice(e + 1));
              var o = b$3("Patches").$;
              return r$5(n) ? o(n, t) : this.produce(n, function (n) {
                return o(n, t);
              });
            }, e;
          }(),
          an = new un(),
          fn = an.produce;
        an.produceWithPatches.bind(an);
        an.setAutoFreeze.bind(an);
        an.setUseProxies.bind(an);
        an.applyPatches.bind(an);
        an.createDraft.bind(an);
        an.finishDraft.bind(an);
        function ownKeys(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread2(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
              _defineProperty(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }

        /**
         * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js
         *
         * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes
         * during build.
         * @param {number} code
         */
        function formatProdErrorMessage(code) {
          return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or " + 'use the non-minified dev environment for full errors. ';
        }

        // Inlined version of the `symbol-observable` polyfill
        var $$observable = function () {
          return typeof Symbol === 'function' && Symbol.observable || '@@observable';
        }();

        /**
         * These are private action types reserved by Redux.
         * For any unknown actions, you must return the current state.
         * If the current state is undefined, you must return the initial state.
         * Do not reference these action types directly in your code.
         */
        var randomString = function randomString() {
          return Math.random().toString(36).substring(7).split('').join('.');
        };
        var ActionTypes = {
          INIT: "@@redux/INIT" + randomString(),
          REPLACE: "@@redux/REPLACE" + randomString(),
          PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
            return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
          }
        };

        /**
         * @param {any} obj The object to inspect.
         * @returns {boolean} True if the argument appears to be a plain object.
         */
        function isPlainObject$3(obj) {
          if (typeof obj !== 'object' || obj === null) return false;
          var proto = obj;
          while (Object.getPrototypeOf(proto) !== null) {
            proto = Object.getPrototypeOf(proto);
          }
          return Object.getPrototypeOf(obj) === proto;
        }

        /**
         * @deprecated
         *
         * **We recommend using the `configureStore` method
         * of the `@reduxjs/toolkit` package**, which replaces `createStore`.
         *
         * Redux Toolkit is our recommended approach for writing Redux logic today,
         * including store setup, reducers, data fetching, and more.
         *
         * **For more details, please read this Redux docs page:**
         * **https://redux.js.org/introduction/why-rtk-is-redux-today**
         *
         * `configureStore` from Redux Toolkit is an improved version of `createStore` that
         * simplifies setup and helps avoid common bugs.
         *
         * You should not be using the `redux` core package by itself today, except for learning purposes.
         * The `createStore` method from the core `redux` package will not be removed, but we encourage
         * all users to migrate to using Redux Toolkit for all Redux code.
         *
         * If you want to use `createStore` without this visual deprecation warning, use
         * the `legacy_createStore` import instead:
         *
         * `import { legacy_createStore as createStore} from 'redux'`
         *
         */

        function createStore$1(reducer, preloadedState, enhancer) {
          var _ref2;
          if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
            throw new Error(formatProdErrorMessage(0));
          }
          if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
            enhancer = preloadedState;
            preloadedState = undefined;
          }
          if (typeof enhancer !== 'undefined') {
            if (typeof enhancer !== 'function') {
              throw new Error(formatProdErrorMessage(1));
            }
            return enhancer(createStore$1)(reducer, preloadedState);
          }
          if (typeof reducer !== 'function') {
            throw new Error(formatProdErrorMessage(2));
          }
          var currentReducer = reducer;
          var currentState = preloadedState;
          var currentListeners = [];
          var nextListeners = currentListeners;
          var isDispatching = false;
          /**
           * This makes a shallow copy of currentListeners so we can use
           * nextListeners as a temporary list while dispatching.
           *
           * This prevents any bugs around consumers calling
           * subscribe/unsubscribe in the middle of a dispatch.
           */

          function ensureCanMutateNextListeners() {
            if (nextListeners === currentListeners) {
              nextListeners = currentListeners.slice();
            }
          }
          /**
           * Reads the state tree managed by the store.
           *
           * @returns {any} The current state tree of your application.
           */

          function getState() {
            if (isDispatching) {
              throw new Error(formatProdErrorMessage(3));
            }
            return currentState;
          }
          /**
           * Adds a change listener. It will be called any time an action is dispatched,
           * and some part of the state tree may potentially have changed. You may then
           * call `getState()` to read the current state tree inside the callback.
           *
           * You may call `dispatch()` from a change listener, with the following
           * caveats:
           *
           * 1. The subscriptions are snapshotted just before every `dispatch()` call.
           * If you subscribe or unsubscribe while the listeners are being invoked, this
           * will not have any effect on the `dispatch()` that is currently in progress.
           * However, the next `dispatch()` call, whether nested or not, will use a more
           * recent snapshot of the subscription list.
           *
           * 2. The listener should not expect to see all state changes, as the state
           * might have been updated multiple times during a nested `dispatch()` before
           * the listener is called. It is, however, guaranteed that all subscribers
           * registered before the `dispatch()` started will be called with the latest
           * state by the time it exits.
           *
           * @param {Function} listener A callback to be invoked on every dispatch.
           * @returns {Function} A function to remove this change listener.
           */

          function subscribe(listener) {
            if (typeof listener !== 'function') {
              throw new Error(formatProdErrorMessage(4));
            }
            if (isDispatching) {
              throw new Error(formatProdErrorMessage(5));
            }
            var isSubscribed = true;
            ensureCanMutateNextListeners();
            nextListeners.push(listener);
            return function unsubscribe() {
              if (!isSubscribed) {
                return;
              }
              if (isDispatching) {
                throw new Error(formatProdErrorMessage(6));
              }
              isSubscribed = false;
              ensureCanMutateNextListeners();
              var index = nextListeners.indexOf(listener);
              nextListeners.splice(index, 1);
              currentListeners = null;
            };
          }
          /**
           * Dispatches an action. It is the only way to trigger a state change.
           *
           * The `reducer` function, used to create the store, will be called with the
           * current state tree and the given `action`. Its return value will
           * be considered the **next** state of the tree, and the change listeners
           * will be notified.
           *
           * The base implementation only supports plain object actions. If you want to
           * dispatch a Promise, an Observable, a thunk, or something else, you need to
           * wrap your store creating function into the corresponding middleware. For
           * example, see the documentation for the `redux-thunk` package. Even the
           * middleware will eventually dispatch plain object actions using this method.
           *
           * @param {Object} action A plain object representing what changed. It is
           * a good idea to keep actions serializable so you can record and replay user
           * sessions, or use the time travelling `redux-devtools`. An action must have
           * a `type` property which may not be `undefined`. It is a good idea to use
           * string constants for action types.
           *
           * @returns {Object} For convenience, the same action object you dispatched.
           *
           * Note that, if you use a custom middleware, it may wrap `dispatch()` to
           * return something else (for example, a Promise you can await).
           */

          function dispatch(action) {
            if (!isPlainObject$3(action)) {
              throw new Error(formatProdErrorMessage(7));
            }
            if (typeof action.type === 'undefined') {
              throw new Error(formatProdErrorMessage(8));
            }
            if (isDispatching) {
              throw new Error(formatProdErrorMessage(9));
            }
            try {
              isDispatching = true;
              currentState = currentReducer(currentState, action);
            } finally {
              isDispatching = false;
            }
            var listeners = currentListeners = nextListeners;
            for (var i = 0; i < listeners.length; i++) {
              var listener = listeners[i];
              listener();
            }
            return action;
          }
          /**
           * Replaces the reducer currently used by the store to calculate the state.
           *
           * You might need this if your app implements code splitting and you want to
           * load some of the reducers dynamically. You might also need this if you
           * implement a hot reloading mechanism for Redux.
           *
           * @param {Function} nextReducer The reducer for the store to use instead.
           * @returns {void}
           */

          function replaceReducer(nextReducer) {
            if (typeof nextReducer !== 'function') {
              throw new Error(formatProdErrorMessage(10));
            }
            currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.
            // Any reducers that existed in both the new and old rootReducer
            // will receive the previous state. This effectively populates
            // the new state tree with any relevant data from the old one.

            dispatch({
              type: ActionTypes.REPLACE
            });
          }
          /**
           * Interoperability point for observable/reactive libraries.
           * @returns {observable} A minimal observable of state changes.
           * For more information, see the observable proposal:
           * https://github.com/tc39/proposal-observable
           */

          function observable() {
            var _ref;
            var outerSubscribe = subscribe;
            return _ref = {
              /**
               * The minimal observable subscription method.
               * @param {Object} observer Any object that can be used as an observer.
               * The observer object should have a `next` method.
               * @returns {subscription} An object with an `unsubscribe` method that can
               * be used to unsubscribe the observable from the store, and prevent further
               * emission of values from the observable.
               */
              subscribe: function subscribe(observer) {
                if (typeof observer !== 'object' || observer === null) {
                  throw new Error(formatProdErrorMessage(11));
                }
                function observeState() {
                  if (observer.next) {
                    observer.next(getState());
                  }
                }
                observeState();
                var unsubscribe = outerSubscribe(observeState);
                return {
                  unsubscribe: unsubscribe
                };
              }
            }, _ref[$$observable] = function () {
              return this;
            }, _ref;
          } // When a store is created, an "INIT" action is dispatched so that every
          // reducer returns their initial state. This effectively populates
          // the initial state tree.

          dispatch({
            type: ActionTypes.INIT
          });
          return _ref2 = {
            dispatch: dispatch,
            subscribe: subscribe,
            getState: getState,
            replaceReducer: replaceReducer
          }, _ref2[$$observable] = observable, _ref2;
        }
        function assertReducerShape(reducers) {
          Object.keys(reducers).forEach(function (key) {
            var reducer = reducers[key];
            var initialState = reducer(undefined, {
              type: ActionTypes.INIT
            });
            if (typeof initialState === 'undefined') {
              throw new Error(formatProdErrorMessage(12));
            }
            if (typeof reducer(undefined, {
              type: ActionTypes.PROBE_UNKNOWN_ACTION()
            }) === 'undefined') {
              throw new Error(formatProdErrorMessage(13));
            }
          });
        }
        /**
         * Turns an object whose values are different reducer functions, into a single
         * reducer function. It will call every child reducer, and gather their results
         * into a single state object, whose keys correspond to the keys of the passed
         * reducer functions.
         *
         * @param {Object} reducers An object whose values correspond to different
         * reducer functions that need to be combined into one. One handy way to obtain
         * it is to use ES6 `import * as reducers` syntax. The reducers may never return
         * undefined for any action. Instead, they should return their initial state
         * if the state passed to them was undefined, and the current state for any
         * unrecognized action.
         *
         * @returns {Function} A reducer function that invokes every reducer inside the
         * passed object, and builds a state object with the same shape.
         */

        function combineReducers(reducers) {
          var reducerKeys = Object.keys(reducers);
          var finalReducers = {};
          for (var i = 0; i < reducerKeys.length; i++) {
            var key = reducerKeys[i];
            if (typeof reducers[key] === 'function') {
              finalReducers[key] = reducers[key];
            }
          }
          var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same

          var shapeAssertionError;
          try {
            assertReducerShape(finalReducers);
          } catch (e) {
            shapeAssertionError = e;
          }
          return function combination(state, action) {
            if (state === void 0) {
              state = {};
            }
            if (shapeAssertionError) {
              throw shapeAssertionError;
            }
            var hasChanged = false;
            var nextState = {};
            for (var _i = 0; _i < finalReducerKeys.length; _i++) {
              var _key = finalReducerKeys[_i];
              var reducer = finalReducers[_key];
              var previousStateForKey = state[_key];
              var nextStateForKey = reducer(previousStateForKey, action);
              if (typeof nextStateForKey === 'undefined') {
                action && action.type;
                throw new Error(formatProdErrorMessage(14));
              }
              nextState[_key] = nextStateForKey;
              hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
            }
            hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
            return hasChanged ? nextState : state;
          };
        }
        function bindActionCreator(actionCreator, dispatch) {
          return function () {
            return dispatch(actionCreator.apply(this, arguments));
          };
        }
        /**
         * Turns an object whose values are action creators, into an object with the
         * same keys, but with every function wrapped into a `dispatch` call so they
         * may be invoked directly. This is just a convenience method, as you can call
         * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
         *
         * For convenience, you can also pass an action creator as the first argument,
         * and get a dispatch wrapped function in return.
         *
         * @param {Function|Object} actionCreators An object whose values are action
         * creator functions. One handy way to obtain it is to use ES6 `import * as`
         * syntax. You may also pass a single function.
         *
         * @param {Function} dispatch The `dispatch` function available on your Redux
         * store.
         *
         * @returns {Function|Object} The object mimicking the original object, but with
         * every action creator wrapped into the `dispatch` call. If you passed a
         * function as `actionCreators`, the return value will also be a single
         * function.
         */

        function bindActionCreators$1(actionCreators, dispatch) {
          if (typeof actionCreators === 'function') {
            return bindActionCreator(actionCreators, dispatch);
          }
          if (typeof actionCreators !== 'object' || actionCreators === null) {
            throw new Error(formatProdErrorMessage(16));
          }
          var boundActionCreators = {};
          for (var key in actionCreators) {
            var actionCreator = actionCreators[key];
            if (typeof actionCreator === 'function') {
              boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
            }
          }
          return boundActionCreators;
        }

        /**
         * Composes single-argument functions from right to left. The rightmost
         * function can take multiple arguments as it provides the signature for
         * the resulting composite function.
         *
         * @param {...Function} funcs The functions to compose.
         * @returns {Function} A function obtained by composing the argument functions
         * from right to left. For example, compose(f, g, h) is identical to doing
         * (...args) => f(g(h(...args))).
         */
        function compose$1() {
          for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
            funcs[_key] = arguments[_key];
          }
          if (funcs.length === 0) {
            return function (arg) {
              return arg;
            };
          }
          if (funcs.length === 1) {
            return funcs[0];
          }
          return funcs.reduce(function (a, b) {
            return function () {
              return a(b.apply(void 0, arguments));
            };
          });
        }

        /**
         * Creates a store enhancer that applies middleware to the dispatch method
         * of the Redux store. This is handy for a variety of tasks, such as expressing
         * asynchronous actions in a concise manner, or logging every action payload.
         *
         * See `redux-thunk` package as an example of the Redux middleware.
         *
         * Because middleware is potentially asynchronous, this should be the first
         * store enhancer in the composition chain.
         *
         * Note that each middleware will be given the `dispatch` and `getState` functions
         * as named arguments.
         *
         * @param {...Function} middlewares The middleware chain to be applied.
         * @returns {Function} A store enhancer applying the middleware.
         */

        function applyMiddleware() {
          for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
            middlewares[_key] = arguments[_key];
          }
          return function (createStore) {
            return function () {
              var store = createStore.apply(void 0, arguments);
              var _dispatch = function dispatch() {
                throw new Error(formatProdErrorMessage(15));
              };
              var middlewareAPI = {
                getState: store.getState,
                dispatch: function dispatch() {
                  return _dispatch.apply(void 0, arguments);
                }
              };
              var chain = middlewares.map(function (middleware) {
                return middleware(middlewareAPI);
              });
              _dispatch = compose$1.apply(void 0, chain)(store.dispatch);
              return _objectSpread2(_objectSpread2({}, store), {}, {
                dispatch: _dispatch
              });
            };
          };
        }

        /** A function that accepts a potential "extra argument" value to be injected later,
         * and returns an instance of the thunk middleware that uses that value
         */
        function createThunkMiddleware(extraArgument) {
          // Standard Redux middleware definition pattern:
          // See: https://redux.js.org/tutorials/fundamentals/part-4-store#writing-custom-middleware
          var middleware = function middleware(_ref) {
            var dispatch = _ref.dispatch,
              getState = _ref.getState;
            return function (next) {
              return function (action) {
                // The thunk middleware looks for any functions that were passed to `store.dispatch`.
                // If this "action" is really a function, call it and return the result.
                if (typeof action === 'function') {
                  // Inject the store's `dispatch` and `getState` methods, as well as any "extra arg"
                  return action(dispatch, getState, extraArgument);
                } // Otherwise, pass the action down the middleware chain as usual

                return next(action);
              };
            };
          };
          return middleware;
        }
        var thunk = createThunkMiddleware(); // Attach the factory function so users can create a customized version
        // with whatever "extra arg" they want to inject into their thunks

        thunk.withExtraArgument = createThunkMiddleware;
        const thunkMiddleware = thunk;
        var __extends = globalThis && globalThis.__extends || function () {
          var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf || {
              __proto__: []
            } instanceof Array && function (d, b) {
              d.__proto__ = b;
            } || function (d, b) {
              for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
            };
            return extendStatics(d, b);
          };
          return function (d, b) {
            if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var __generator = globalThis && globalThis.__generator || function (thisArg, body) {
          var _ = {
              label: 0,
              sent: function () {
                if (t[0] & 1) throw t[1];
                return t[1];
              },
              trys: [],
              ops: []
            },
            f,
            y,
            t,
            g;
          return g = {
            next: verb(0),
            "throw": verb(1),
            "return": verb(2)
          }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
            return this;
          }), g;
          function verb(n) {
            return function (v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
              if (y = 0, t) op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return {
                    value: op[1],
                    done: false
                  };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2]) _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
            if (op[0] & 5) throw op[1];
            return {
              value: op[0] ? op[1] : void 0,
              done: true
            };
          }
        };
        var __spreadArray = globalThis && globalThis.__spreadArray || function (to, from) {
          for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
          return to;
        };
        var __defProp = Object.defineProperty;
        var __defProps = Object.defineProperties;
        var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
        var __getOwnPropSymbols = Object.getOwnPropertySymbols;
        var __hasOwnProp = Object.prototype.hasOwnProperty;
        var __propIsEnum = Object.prototype.propertyIsEnumerable;
        var __defNormalProp = function (obj, key, value) {
          return key in obj ? __defProp(obj, key, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: value
          }) : obj[key] = value;
        };
        var __spreadValues = function (a, b) {
          for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
          if (__getOwnPropSymbols) for (var _i = 0, _c = __getOwnPropSymbols(b); _i < _c.length; _i++) {
            var prop = _c[_i];
            if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
          }
          return a;
        };
        var __spreadProps = function (a, b) {
          return __defProps(a, __getOwnPropDescs(b));
        };
        var __async = function (__this, __arguments, generator) {
          return new Promise(function (resolve, reject) {
            var fulfilled = function (value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            };
            var rejected = function (value) {
              try {
                step(generator.throw(value));
              } catch (e) {
                reject(e);
              }
            };
            var step = function (x) {
              return x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
            };
            step((generator = generator.apply(__this, __arguments)).next());
          });
        };
        var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function () {
          if (arguments.length === 0) return void 0;
          if (typeof arguments[0] === "object") return compose$1;
          return compose$1.apply(null, arguments);
        };
        // src/isPlainObject.ts
        function isPlainObject$2(value) {
          if (typeof value !== "object" || value === null) return false;
          var proto = Object.getPrototypeOf(value);
          if (proto === null) return true;
          var baseProto = proto;
          while (Object.getPrototypeOf(baseProto) !== null) {
            baseProto = Object.getPrototypeOf(baseProto);
          }
          return proto === baseProto;
        }
        var MiddlewareArray = /** @class */function (_super) {
          __extends(MiddlewareArray, _super);
          function MiddlewareArray() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, args) || this;
            Object.setPrototypeOf(_this, MiddlewareArray.prototype);
            return _this;
          }
          Object.defineProperty(MiddlewareArray, Symbol.species, {
            get: function () {
              return MiddlewareArray;
            },
            enumerable: false,
            configurable: true
          });
          MiddlewareArray.prototype.concat = function () {
            var arr = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              arr[_i] = arguments[_i];
            }
            return _super.prototype.concat.apply(this, arr);
          };
          MiddlewareArray.prototype.prepend = function () {
            var arr = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              arr[_i] = arguments[_i];
            }
            if (arr.length === 1 && Array.isArray(arr[0])) {
              return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([void 0], arr[0].concat(this))))();
            }
            return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([void 0], arr.concat(this))))();
          };
          return MiddlewareArray;
        }(Array);
        var EnhancerArray = /** @class */function (_super) {
          __extends(EnhancerArray, _super);
          function EnhancerArray() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, args) || this;
            Object.setPrototypeOf(_this, EnhancerArray.prototype);
            return _this;
          }
          Object.defineProperty(EnhancerArray, Symbol.species, {
            get: function () {
              return EnhancerArray;
            },
            enumerable: false,
            configurable: true
          });
          EnhancerArray.prototype.concat = function () {
            var arr = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              arr[_i] = arguments[_i];
            }
            return _super.prototype.concat.apply(this, arr);
          };
          EnhancerArray.prototype.prepend = function () {
            var arr = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              arr[_i] = arguments[_i];
            }
            if (arr.length === 1 && Array.isArray(arr[0])) {
              return new (EnhancerArray.bind.apply(EnhancerArray, __spreadArray([void 0], arr[0].concat(this))))();
            }
            return new (EnhancerArray.bind.apply(EnhancerArray, __spreadArray([void 0], arr.concat(this))))();
          };
          return EnhancerArray;
        }(Array);
        function freezeDraftable(val) {
          return t$4(val) ? fn(val, function () {}) : val;
        }
        // src/getDefaultMiddleware.ts
        function isBoolean(x) {
          return typeof x === "boolean";
        }
        function curryGetDefaultMiddleware() {
          return function curriedGetDefaultMiddleware(options) {
            return getDefaultMiddleware(options);
          };
        }
        function getDefaultMiddleware(options) {
          if (options === void 0) {
            options = {};
          }
          var _c = options.thunk,
            thunk = _c === void 0 ? true : _c;
          options.immutableCheck;
          options.serializableCheck;
          var middlewareArray = new MiddlewareArray();
          if (thunk) {
            if (isBoolean(thunk)) {
              middlewareArray.push(thunkMiddleware);
            } else {
              middlewareArray.push(thunkMiddleware.withExtraArgument(thunk.extraArgument));
            }
          }
          return middlewareArray;
        }
        // src/configureStore.ts
        var IS_PRODUCTION = "production" === "production";
        function configureStore(options) {
          var curriedGetDefaultMiddleware = curryGetDefaultMiddleware();
          var _c = options || {},
            _d = _c.reducer,
            reducer = _d === void 0 ? void 0 : _d,
            _e = _c.middleware,
            middleware = _e === void 0 ? curriedGetDefaultMiddleware() : _e,
            _f = _c.devTools,
            devTools = _f === void 0 ? true : _f,
            _g = _c.preloadedState,
            preloadedState = _g === void 0 ? void 0 : _g,
            _h = _c.enhancers,
            enhancers = _h === void 0 ? void 0 : _h;
          var rootReducer;
          if (typeof reducer === "function") {
            rootReducer = reducer;
          } else if (isPlainObject$2(reducer)) {
            rootReducer = combineReducers(reducer);
          } else {
            throw new Error('"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');
          }
          var finalMiddleware = middleware;
          if (typeof finalMiddleware === "function") {
            finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware);
          }
          var middlewareEnhancer = applyMiddleware.apply(void 0, finalMiddleware);
          var finalCompose = compose$1;
          if (devTools) {
            finalCompose = composeWithDevTools(__spreadValues({
              trace: !IS_PRODUCTION
            }, typeof devTools === "object" && devTools));
          }
          var defaultEnhancers = new EnhancerArray(middlewareEnhancer);
          var storeEnhancers = defaultEnhancers;
          if (Array.isArray(enhancers)) {
            storeEnhancers = __spreadArray([middlewareEnhancer], enhancers);
          } else if (typeof enhancers === "function") {
            storeEnhancers = enhancers(defaultEnhancers);
          }
          var composedEnhancer = finalCompose.apply(void 0, storeEnhancers);
          return createStore$1(rootReducer, preloadedState, composedEnhancer);
        }
        // src/createAction.ts
        function createAction(type, prepareAction) {
          function actionCreator() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (prepareAction) {
              var prepared = prepareAction.apply(void 0, args);
              if (!prepared) {
                throw new Error("prepareAction did not return an object");
              }
              return __spreadValues(__spreadValues({
                type: type,
                payload: prepared.payload
              }, "meta" in prepared && {
                meta: prepared.meta
              }), "error" in prepared && {
                error: prepared.error
              });
            }
            return {
              type: type,
              payload: args[0]
            };
          }
          actionCreator.toString = function () {
            return "" + type;
          };
          actionCreator.type = type;
          actionCreator.match = function (action) {
            return action.type === type;
          };
          return actionCreator;
        }
        // src/mapBuilders.ts
        function executeReducerBuilderCallback(builderCallback) {
          var actionsMap = {};
          var actionMatchers = [];
          var defaultCaseReducer;
          var builder = {
            addCase: function (typeOrActionCreator, reducer) {
              var type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
              if (type in actionsMap) {
                throw new Error("addCase cannot be called with two reducers for the same action type");
              }
              actionsMap[type] = reducer;
              return builder;
            },
            addMatcher: function (matcher, reducer) {
              actionMatchers.push({
                matcher: matcher,
                reducer: reducer
              });
              return builder;
            },
            addDefaultCase: function (reducer) {
              defaultCaseReducer = reducer;
              return builder;
            }
          };
          builderCallback(builder);
          return [actionsMap, actionMatchers, defaultCaseReducer];
        }
        // src/createReducer.ts
        function isStateFunction(x) {
          return typeof x === "function";
        }
        function createReducer(initialState, mapOrBuilderCallback, actionMatchers, defaultCaseReducer) {
          if (actionMatchers === void 0) {
            actionMatchers = [];
          }
          var _c = typeof mapOrBuilderCallback === "function" ? executeReducerBuilderCallback(mapOrBuilderCallback) : [mapOrBuilderCallback, actionMatchers, defaultCaseReducer],
            actionsMap = _c[0],
            finalActionMatchers = _c[1],
            finalDefaultCaseReducer = _c[2];
          var getInitialState;
          if (isStateFunction(initialState)) {
            getInitialState = function () {
              return freezeDraftable(initialState());
            };
          } else {
            var frozenInitialState_1 = freezeDraftable(initialState);
            getInitialState = function () {
              return frozenInitialState_1;
            };
          }
          function reducer(state, action) {
            if (state === void 0) {
              state = getInitialState();
            }
            var caseReducers = __spreadArray([actionsMap[action.type]], finalActionMatchers.filter(function (_c) {
              var matcher = _c.matcher;
              return matcher(action);
            }).map(function (_c) {
              var reducer2 = _c.reducer;
              return reducer2;
            }));
            if (caseReducers.filter(function (cr) {
              return !!cr;
            }).length === 0) {
              caseReducers = [finalDefaultCaseReducer];
            }
            return caseReducers.reduce(function (previousState, caseReducer) {
              if (caseReducer) {
                if (r$5(previousState)) {
                  var draft = previousState;
                  var result = caseReducer(draft, action);
                  if (result === void 0) {
                    return previousState;
                  }
                  return result;
                } else if (!t$4(previousState)) {
                  var result = caseReducer(previousState, action);
                  if (result === void 0) {
                    if (previousState === null) {
                      return previousState;
                    }
                    throw Error("A case reducer on a non-draftable value must not return undefined");
                  }
                  return result;
                } else {
                  return fn(previousState, function (draft) {
                    return caseReducer(draft, action);
                  });
                }
              }
              return previousState;
            }, state);
          }
          reducer.getInitialState = getInitialState;
          return reducer;
        }
        function getType2(slice, actionKey) {
          return slice + "/" + actionKey;
        }
        function createSlice(options) {
          var name = options.name;
          if (!name) {
            throw new Error("`name` is a required option for createSlice");
          }
          if (typeof process !== "undefined" && "production" === "development") {
            if (options.initialState === void 0) {
              console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
            }
          }
          var initialState = typeof options.initialState == "function" ? options.initialState : freezeDraftable(options.initialState);
          var reducers = options.reducers || {};
          var reducerNames = Object.keys(reducers);
          var sliceCaseReducersByName = {};
          var sliceCaseReducersByType = {};
          var actionCreators = {};
          reducerNames.forEach(function (reducerName) {
            var maybeReducerWithPrepare = reducers[reducerName];
            var type = getType2(name, reducerName);
            var caseReducer;
            var prepareCallback;
            if ("reducer" in maybeReducerWithPrepare) {
              caseReducer = maybeReducerWithPrepare.reducer;
              prepareCallback = maybeReducerWithPrepare.prepare;
            } else {
              caseReducer = maybeReducerWithPrepare;
            }
            sliceCaseReducersByName[reducerName] = caseReducer;
            sliceCaseReducersByType[type] = caseReducer;
            actionCreators[reducerName] = prepareCallback ? createAction(type, prepareCallback) : createAction(type);
          });
          function buildReducer() {
            var _c = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers],
              _d = _c[0],
              extraReducers = _d === void 0 ? {} : _d,
              _e = _c[1],
              actionMatchers = _e === void 0 ? [] : _e,
              _f = _c[2],
              defaultCaseReducer = _f === void 0 ? void 0 : _f;
            var finalCaseReducers = __spreadValues(__spreadValues({}, extraReducers), sliceCaseReducersByType);
            return createReducer(initialState, function (builder) {
              for (var key in finalCaseReducers) {
                builder.addCase(key, finalCaseReducers[key]);
              }
              for (var _i = 0, actionMatchers_1 = actionMatchers; _i < actionMatchers_1.length; _i++) {
                var m = actionMatchers_1[_i];
                builder.addMatcher(m.matcher, m.reducer);
              }
              if (defaultCaseReducer) {
                builder.addDefaultCase(defaultCaseReducer);
              }
            });
          }
          var _reducer;
          return {
            name: name,
            reducer: function (state, action) {
              if (!_reducer) _reducer = buildReducer();
              return _reducer(state, action);
            },
            actions: actionCreators,
            caseReducers: sliceCaseReducersByName,
            getInitialState: function () {
              if (!_reducer) _reducer = buildReducer();
              return _reducer.getInitialState();
            }
          };
        }
        // src/nanoid.ts
        var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
        var nanoid = function (size) {
          if (size === void 0) {
            size = 21;
          }
          var id = "";
          var i = size;
          while (i--) {
            id += urlAlphabet[Math.random() * 64 | 0];
          }
          return id;
        };
        // src/createAsyncThunk.ts
        var commonProperties = ["name", "message", "stack", "code"];
        var RejectWithValue = /** @class */function () {
          function RejectWithValue(payload, meta) {
            this.payload = payload;
            this.meta = meta;
          }
          return RejectWithValue;
        }();
        var FulfillWithMeta = /** @class */function () {
          function FulfillWithMeta(payload, meta) {
            this.payload = payload;
            this.meta = meta;
          }
          return FulfillWithMeta;
        }();
        var miniSerializeError = function (value) {
          if (typeof value === "object" && value !== null) {
            var simpleError = {};
            for (var _i = 0, commonProperties_1 = commonProperties; _i < commonProperties_1.length; _i++) {
              var property = commonProperties_1[_i];
              if (typeof value[property] === "string") {
                simpleError[property] = value[property];
              }
            }
            return simpleError;
          }
          return {
            message: String(value)
          };
        };
        (function () {
          function createAsyncThunk2(typePrefix, payloadCreator, options) {
            var fulfilled = createAction(typePrefix + "/fulfilled", function (payload, requestId, arg, meta) {
              return {
                payload: payload,
                meta: __spreadProps(__spreadValues({}, meta || {}), {
                  arg: arg,
                  requestId: requestId,
                  requestStatus: "fulfilled"
                })
              };
            });
            var pending = createAction(typePrefix + "/pending", function (requestId, arg, meta) {
              return {
                payload: void 0,
                meta: __spreadProps(__spreadValues({}, meta || {}), {
                  arg: arg,
                  requestId: requestId,
                  requestStatus: "pending"
                })
              };
            });
            var rejected = createAction(typePrefix + "/rejected", function (error, requestId, arg, payload, meta) {
              return {
                payload: payload,
                error: (options && options.serializeError || miniSerializeError)(error || "Rejected"),
                meta: __spreadProps(__spreadValues({}, meta || {}), {
                  arg: arg,
                  requestId: requestId,
                  rejectedWithValue: !!payload,
                  requestStatus: "rejected",
                  aborted: (error == null ? void 0 : error.name) === "AbortError",
                  condition: (error == null ? void 0 : error.name) === "ConditionError"
                })
              };
            });
            var AC = typeof AbortController !== "undefined" ? AbortController : /** @class */function () {
              function class_1() {
                this.signal = {
                  aborted: false,
                  addEventListener: function () {},
                  dispatchEvent: function () {
                    return false;
                  },
                  onabort: function () {},
                  removeEventListener: function () {},
                  reason: void 0,
                  throwIfAborted: function () {}
                };
              }
              class_1.prototype.abort = function () {};
              return class_1;
            }();
            function actionCreator(arg) {
              return function (dispatch, getState, extra) {
                var requestId = (options == null ? void 0 : options.idGenerator) ? options.idGenerator(arg) : nanoid();
                var abortController = new AC();
                var abortReason;
                function abort(reason) {
                  abortReason = reason;
                  abortController.abort();
                }
                var promise2 = function () {
                  return __async(this, null, function () {
                    var _a, _b, finalAction, conditionResult, abortedPromise, err_1, skipDispatch;
                    return __generator(this, function (_c) {
                      switch (_c.label) {
                        case 0:
                          _c.trys.push([0, 4,, 5]);
                          conditionResult = (_a = options == null ? void 0 : options.condition) == null ? void 0 : _a.call(options, arg, {
                            getState: getState,
                            extra: extra
                          });
                          if (!isThenable(conditionResult)) return [3 /*break*/, 2];
                          return [4 /*yield*/, conditionResult];
                        case 1:
                          conditionResult = _c.sent();
                          _c.label = 2;
                        case 2:
                          if (conditionResult === false || abortController.signal.aborted) {
                            throw {
                              name: "ConditionError",
                              message: "Aborted due to condition callback returning false."
                            };
                          }
                          abortedPromise = new Promise(function (_, reject) {
                            return abortController.signal.addEventListener("abort", function () {
                              return reject({
                                name: "AbortError",
                                message: abortReason || "Aborted"
                              });
                            });
                          });
                          dispatch(pending(requestId, arg, (_b = options == null ? void 0 : options.getPendingMeta) == null ? void 0 : _b.call(options, {
                            requestId: requestId,
                            arg: arg
                          }, {
                            getState: getState,
                            extra: extra
                          })));
                          return [4 /*yield*/, Promise.race([abortedPromise, Promise.resolve(payloadCreator(arg, {
                            dispatch: dispatch,
                            getState: getState,
                            extra: extra,
                            requestId: requestId,
                            signal: abortController.signal,
                            abort: abort,
                            rejectWithValue: function (value, meta) {
                              return new RejectWithValue(value, meta);
                            },
                            fulfillWithValue: function (value, meta) {
                              return new FulfillWithMeta(value, meta);
                            }
                          })).then(function (result) {
                            if (result instanceof RejectWithValue) {
                              throw result;
                            }
                            if (result instanceof FulfillWithMeta) {
                              return fulfilled(result.payload, requestId, arg, result.meta);
                            }
                            return fulfilled(result, requestId, arg);
                          })])];
                        case 3:
                          finalAction = _c.sent();
                          return [3 /*break*/, 5];
                        case 4:
                          err_1 = _c.sent();
                          finalAction = err_1 instanceof RejectWithValue ? rejected(null, requestId, arg, err_1.payload, err_1.meta) : rejected(err_1, requestId, arg);
                          return [3 /*break*/, 5];
                        case 5:
                          skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;
                          if (!skipDispatch) {
                            dispatch(finalAction);
                          }
                          return [2 /*return*/, finalAction];
                      }
                    });
                  });
                }();
                return Object.assign(promise2, {
                  abort: abort,
                  requestId: requestId,
                  arg: arg,
                  unwrap: function () {
                    return promise2.then(unwrapResult);
                  }
                });
              };
            }
            return Object.assign(actionCreator, {
              pending: pending,
              rejected: rejected,
              fulfilled: fulfilled,
              typePrefix: typePrefix
            });
          }
          createAsyncThunk2.withTypes = function () {
            return createAsyncThunk2;
          };
          return createAsyncThunk2;
        })();
        function unwrapResult(action) {
          if (action.meta && action.meta.rejectedWithValue) {
            throw action.payload;
          }
          if (action.error) {
            throw action.error;
          }
          return action.payload;
        }
        function isThenable(value) {
          return value !== null && typeof value === "object" && typeof value.then === "function";
        }
        var alm = "listenerMiddleware";
        createAction(alm + "/add");
        createAction(alm + "/removeAll");
        createAction(alm + "/remove");
        var promise;
        typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : globalThis) : function (cb) {
          return (promise || (promise = Promise.resolve())).then(cb).catch(function (err) {
            return setTimeout(function () {
              throw err;
            }, 0);
          });
        };
        // src/index.ts
        F$1();
        let frankieDependents = {};
        const runState = createSlice({
          name: "runState",
          initialState: {
            state: {}
          },
          reducers: {
            valueChange: (state, action) => {
              state = setValueInState(state, action.payload);
            },
            orderChange: (state, action) => {
              console.log(action.payload);
              let keys = Object.keys(action.payload);
              if (!state.order) {
                state.order = {};
              }
              keys.forEach(key => state.order[key] = action.payload[key]);
            },
            stateReceived: (state, action) => {
              let keys = Object.keys(state);
              keys.forEach(key => delete state[key]);
              frankieDependents = action.payload.state.frankieDependents;
              state.navigation = undefined;
              state.data = {
                survey: action.payload.survey,
                navigationIndex: action.payload.navigationIndex,
                additionalLang: action.payload.additionalLang,
                lang: action.payload.lang,
                responseId: action.payload.responseId
              };
              state.navProps = action.payload.navProps;
              state.values = action.payload.state.frankieVariables;
            },
            langChange: (state, action) => {
              state.navigation = {
                events: state.timings,
                values: getValues(state.values),
                lang: action.payload.lang,
                navigationDirection: {
                  name: "CHANGE_LANGE"
                }
              };
            },
            navigateNext: state => {
              next$1(state);
            },
            navigatePrevious: state => {
              state.navigation = {
                navigationDirection: {
                  name: "PREV"
                }
              };
            },
            jump: (state, action) => {
              state.navigation = {
                events: state.timings,
                values: getValues(state.values),
                navigationDirection: {
                  name: "JUMP",
                  navigationIndex: action.payload
                }
              };
            }
          }
        });
        const {
          valueChange,
          orderChange,
          stateReceived,
          langChange,
          navigateNext,
          navigatePrevious,
          jump
        } = runState.actions;
        exports({
          a5: valueChange,
          ad: orderChange,
          aj: stateReceived,
          ah: langChange,
          a4: navigateNext,
          a3: navigatePrevious,
          a2: jump
        });
        const runState$1 = runState.reducer;
        function onDependencyChanged(values, componentName, variableName, newValue, source) {
          if (typeof values[componentName] === "undefined") {
            return;
          }
          if (values[componentName][variableName] === newValue) {
            console.log("same value - " + componentName + "." + variableName + ": " + newValue);
          } else {
            console.log(componentName + "." + variableName + ": " + JSON.stringify(newValue) + " due to " + source);
            values[componentName][variableName] = newValue;
            getDependents(componentName, variableName).forEach(dependent => {
              onDependencyChanged(values, dependent[0], dependent[1], window.frankieRuntime[dependent[0]][dependent[1]](values), componentName + "." + variableName);
            });
          }
        }
        function getDependents(componentName, variableName) {
          if (typeof frankieDependents[componentName] !== "undefined" && typeof frankieDependents[componentName][variableName] !== "undefined") {
            return frankieDependents[componentName][variableName];
          } else {
            return [];
          }
        }
        function setValueInState(state, payload) {
          let componentCode = payload.componentCode;
          logTimes(state, componentCode);
          let value = payload.value;
          let element = state.values[componentCode];
          let newState = {
            ...state
          };
          if (typeof element !== "undefined" && element["value"] !== value) {
            let time = Date.now();
            onDependencyChanged(state.values, componentCode, "value", value, "VALUE CHANGE");
            console.log("NEW STATE in: " + (Date.now() - time) + " millis");
            return newState;
          }
          return state;
        }
        function logTimes(state, code) {
          if (!state.navProps.saveTimings) {
            return;
          }
          if (!state.timings) {
            state.timings = [];
          }
          let element = {
            code,
            time: new Date().toISOString().split(".")[0].replace("T", " "),
            name: "ValueTiming"
          };
          if (state.timings.length > 0 && state.timings[state.timings.length - 1].code === code) {
            state.timings[state.timings.length - 1] = element;
          } else {
            state.timings.push(element);
          }
        }
        function next$1(state) {
          if (!state.values.Survey.validity && !state.values.Survey.show_errors) {
            state.values.Survey.show_errors = true;
          } else {
            state.navigation = {
              events: state.timings,
              values: getValues(state.values),
              navigationDirection: {
                name: "NEXT"
              }
            };
          }
        }
        function getValues(values) {
          let retrunObj = {};
          for (var key in values) {
            if (values.hasOwnProperty(key)) {
              let element = values[key];
              if (element.hasOwnProperty("value")) {
                let value = element["value"];
                if (typeof value !== "undefined") {
                  retrunObj[key + ".value"] = value;
                }
              }
            }
          }
          return retrunObj;
        }
        const isEquivalent = exports('b6', (a, b) => {
          if (typeof a === "function" || typeof b === "function") {
            return false;
          } else if (typeof a !== "object" || typeof b !== "object") {
            return a === b;
          }

          // Create arrays of property names
          let aProps = a ? Object.getOwnPropertyNames(a) : [];
          let bProps = b ? Object.getOwnPropertyNames(b) : [];

          // If number of properties is different,
          // objects are not equivalent
          if (aProps.length !== bProps.length) {
            return false;
          }
          for (var i = 0; i < aProps.length; i++) {
            let propName = aProps[i];

            // If values of same property are not equal,
            // objects are not equivalent
            if (propName !== "key" && !isEquivalent(a[propName], b[propName])) {
              return false;
            }
          }

          // If we made it this far, objects
          // are considered equivalent
          return true;
        });
        const nextId = exports('b0', elements => {
          if (elements.length) {
            let arrayOfIntCodes = elements.filter(el => el.type != "other").map(el => el.code.replace(/^\D+/g, "")).filter(el => el.length > 0);
            if (arrayOfIntCodes.length) {
              let intCodes = arrayOfIntCodes.map(el => parseInt(el)).sort(function (a, b) {
                return a - b;
              });
              if (intCodes) {
                return intCodes[intCodes.length - 1] + 1;
              }
            }
          }
          return 1;
        });
        const instructionByCode = exports('br', (component, code) => component.instructionList ? component.instructionList.find(el => el.code === code) : undefined);
        const stripTags = exports('a1', string => {
          return string ? string.replace(/<[^>]*>?/gm, "").replace("\n", "").replace("&nbsp;", "") : string;
        });
        const isQuestion = exports('aL', code => /^Q[a-z0-9_]+$/.test(code));
        const isGroup = exports('aK', code => /^G[a-z0-9_]+$/.test(code));
        const lastIndexInArray = (array, func) => {
          if (!array) {
            return -1;
          }
          let index = array.length - 1;
          for (; index >= 0; index--) {
            if (func(array[index])) {
              return index;
            }
          }
          return -1;
        };
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          _setPrototypeOf(subClass, superClass);
        }
        function _extends() {
          exports('m', _extends = Object.assign ? Object.assign.bind() : function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          });
          return _extends.apply(this, arguments);
        }
        var ReactReduxContext$1 = /*#__PURE__*/React.createContext(null);

        // Default to a dummy "batch" implementation that just runs the callback
        function defaultNoopBatch$1(callback) {
          callback();
        }
        var batch$1 = defaultNoopBatch$1; // Allow injecting another batching function later

        var setBatch$1 = function setBatch(newBatch) {
          return batch$1 = newBatch;
        }; // Supply a getter just to skip dealing with ESM bindings

        var getBatch$1 = function getBatch() {
          return batch$1;
        };

        // well as nesting subscriptions of descendant components, so that we can ensure the
        // ancestor components re-render before descendants

        function createListenerCollection$1() {
          var batch = getBatch$1();
          var first = null;
          var last = null;
          return {
            clear: function clear() {
              first = null;
              last = null;
            },
            notify: function notify() {
              batch(function () {
                var listener = first;
                while (listener) {
                  listener.callback();
                  listener = listener.next;
                }
              });
            },
            get: function get() {
              var listeners = [];
              var listener = first;
              while (listener) {
                listeners.push(listener);
                listener = listener.next;
              }
              return listeners;
            },
            subscribe: function subscribe(callback) {
              var isSubscribed = true;
              var listener = last = {
                callback: callback,
                next: null,
                prev: last
              };
              if (listener.prev) {
                listener.prev.next = listener;
              } else {
                first = listener;
              }
              return function unsubscribe() {
                if (!isSubscribed || first === null) return;
                isSubscribed = false;
                if (listener.next) {
                  listener.next.prev = listener.prev;
                } else {
                  last = listener.prev;
                }
                if (listener.prev) {
                  listener.prev.next = listener.next;
                } else {
                  first = listener.next;
                }
              };
            }
          };
        }
        var nullListeners$1 = {
          notify: function notify() {},
          get: function get() {
            return [];
          }
        };
        function createSubscription$1(store, parentSub) {
          var unsubscribe;
          var listeners = nullListeners$1;
          function addNestedSub(listener) {
            trySubscribe();
            return listeners.subscribe(listener);
          }
          function notifyNestedSubs() {
            listeners.notify();
          }
          function handleChangeWrapper() {
            if (subscription.onStateChange) {
              subscription.onStateChange();
            }
          }
          function isSubscribed() {
            return Boolean(unsubscribe);
          }
          function trySubscribe() {
            if (!unsubscribe) {
              unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
              listeners = createListenerCollection$1();
            }
          }
          function tryUnsubscribe() {
            if (unsubscribe) {
              unsubscribe();
              unsubscribe = undefined;
              listeners.clear();
              listeners = nullListeners$1;
            }
          }
          var subscription = {
            addNestedSub: addNestedSub,
            notifyNestedSubs: notifyNestedSubs,
            handleChangeWrapper: handleChangeWrapper,
            isSubscribed: isSubscribed,
            trySubscribe: trySubscribe,
            tryUnsubscribe: tryUnsubscribe,
            getListeners: function getListeners() {
              return listeners;
            }
          };
          return subscription;
        }

        // To get around it, we can conditionally useEffect on the server (no-op) and
        // useLayoutEffect in the browser. We need useLayoutEffect to ensure the store
        // subscription callback always has the selector from the latest render commit
        // available, otherwise a store update may happen between render and the effect,
        // which may cause missed updates; we also must ensure the store subscription
        // is created synchronously, otherwise a store update may occur before the
        // subscription is created and an inconsistent state may be observed

        var useIsomorphicLayoutEffect$2 = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? reactExports.useLayoutEffect : reactExports.useEffect;
        function Provider$1(_ref) {
          var store = _ref.store,
            context = _ref.context,
            children = _ref.children;
          var contextValue = reactExports.useMemo(function () {
            var subscription = createSubscription$1(store);
            return {
              store: store,
              subscription: subscription
            };
          }, [store]);
          var previousState = reactExports.useMemo(function () {
            return store.getState();
          }, [store]);
          useIsomorphicLayoutEffect$2(function () {
            var subscription = contextValue.subscription;
            subscription.onStateChange = subscription.notifyNestedSubs;
            subscription.trySubscribe();
            if (previousState !== store.getState()) {
              subscription.notifyNestedSubs();
            }
            return function () {
              subscription.tryUnsubscribe();
              subscription.onStateChange = null;
            };
          }, [contextValue, previousState]);
          var Context = context || ReactReduxContext$1;
          return /*#__PURE__*/React.createElement(Context.Provider, {
            value: contextValue
          }, children);
        }
        var reactIs$2 = {
          exports: {}
        };
        var reactIs_production_min$2 = {};

        /** @license React v16.13.1
         * react-is.production.min.js
         *
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */
        var b$2 = "function" === typeof Symbol && Symbol.for,
          c$2 = b$2 ? Symbol.for("react.element") : 60103,
          d$2 = b$2 ? Symbol.for("react.portal") : 60106,
          e$3 = b$2 ? Symbol.for("react.fragment") : 60107,
          f$2 = b$2 ? Symbol.for("react.strict_mode") : 60108,
          g$2 = b$2 ? Symbol.for("react.profiler") : 60114,
          h$4 = b$2 ? Symbol.for("react.provider") : 60109,
          k$3 = b$2 ? Symbol.for("react.context") : 60110,
          l$3 = b$2 ? Symbol.for("react.async_mode") : 60111,
          m$3 = b$2 ? Symbol.for("react.concurrent_mode") : 60111,
          n$4 = b$2 ? Symbol.for("react.forward_ref") : 60112,
          p$4 = b$2 ? Symbol.for("react.suspense") : 60113,
          q$4 = b$2 ? Symbol.for("react.suspense_list") : 60120,
          r$4 = b$2 ? Symbol.for("react.memo") : 60115,
          t$3 = b$2 ? Symbol.for("react.lazy") : 60116,
          v$3 = b$2 ? Symbol.for("react.block") : 60121,
          w$2 = b$2 ? Symbol.for("react.fundamental") : 60117,
          x$1 = b$2 ? Symbol.for("react.responder") : 60118,
          y$1 = b$2 ? Symbol.for("react.scope") : 60119;
        function z$1(a) {
          if ("object" === typeof a && null !== a) {
            var u = a.$$typeof;
            switch (u) {
              case c$2:
                switch (a = a.type, a) {
                  case l$3:
                  case m$3:
                  case e$3:
                  case g$2:
                  case f$2:
                  case p$4:
                    return a;
                  default:
                    switch (a = a && a.$$typeof, a) {
                      case k$3:
                      case n$4:
                      case t$3:
                      case r$4:
                      case h$4:
                        return a;
                      default:
                        return u;
                    }
                }
              case d$2:
                return u;
            }
          }
        }
        function A$1(a) {
          return z$1(a) === m$3;
        }
        reactIs_production_min$2.AsyncMode = l$3;
        reactIs_production_min$2.ConcurrentMode = m$3;
        reactIs_production_min$2.ContextConsumer = k$3;
        reactIs_production_min$2.ContextProvider = h$4;
        reactIs_production_min$2.Element = c$2;
        reactIs_production_min$2.ForwardRef = n$4;
        reactIs_production_min$2.Fragment = e$3;
        reactIs_production_min$2.Lazy = t$3;
        reactIs_production_min$2.Memo = r$4;
        reactIs_production_min$2.Portal = d$2;
        reactIs_production_min$2.Profiler = g$2;
        reactIs_production_min$2.StrictMode = f$2;
        reactIs_production_min$2.Suspense = p$4;
        reactIs_production_min$2.isAsyncMode = function (a) {
          return A$1(a) || z$1(a) === l$3;
        };
        reactIs_production_min$2.isConcurrentMode = A$1;
        reactIs_production_min$2.isContextConsumer = function (a) {
          return z$1(a) === k$3;
        };
        reactIs_production_min$2.isContextProvider = function (a) {
          return z$1(a) === h$4;
        };
        reactIs_production_min$2.isElement = function (a) {
          return "object" === typeof a && null !== a && a.$$typeof === c$2;
        };
        reactIs_production_min$2.isForwardRef = function (a) {
          return z$1(a) === n$4;
        };
        reactIs_production_min$2.isFragment = function (a) {
          return z$1(a) === e$3;
        };
        reactIs_production_min$2.isLazy = function (a) {
          return z$1(a) === t$3;
        };
        reactIs_production_min$2.isMemo = function (a) {
          return z$1(a) === r$4;
        };
        reactIs_production_min$2.isPortal = function (a) {
          return z$1(a) === d$2;
        };
        reactIs_production_min$2.isProfiler = function (a) {
          return z$1(a) === g$2;
        };
        reactIs_production_min$2.isStrictMode = function (a) {
          return z$1(a) === f$2;
        };
        reactIs_production_min$2.isSuspense = function (a) {
          return z$1(a) === p$4;
        };
        reactIs_production_min$2.isValidElementType = function (a) {
          return "string" === typeof a || "function" === typeof a || a === e$3 || a === m$3 || a === g$2 || a === f$2 || a === p$4 || a === q$4 || "object" === typeof a && null !== a && (a.$$typeof === t$3 || a.$$typeof === r$4 || a.$$typeof === h$4 || a.$$typeof === k$3 || a.$$typeof === n$4 || a.$$typeof === w$2 || a.$$typeof === x$1 || a.$$typeof === y$1 || a.$$typeof === v$3);
        };
        reactIs_production_min$2.typeOf = z$1;
        {
          reactIs$2.exports = reactIs_production_min$2;
        }
        var reactIsExports$1 = reactIs$2.exports;
        var reactIs$1 = reactIsExports$1;

        /**
         * Copyright 2015, Yahoo! Inc.
         * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
         */
        var REACT_STATICS = {
          childContextTypes: true,
          contextType: true,
          contextTypes: true,
          defaultProps: true,
          displayName: true,
          getDefaultProps: true,
          getDerivedStateFromError: true,
          getDerivedStateFromProps: true,
          mixins: true,
          propTypes: true,
          type: true
        };
        var KNOWN_STATICS = {
          name: true,
          length: true,
          prototype: true,
          caller: true,
          callee: true,
          arguments: true,
          arity: true
        };
        var FORWARD_REF_STATICS = {
          '$$typeof': true,
          render: true,
          defaultProps: true,
          displayName: true,
          propTypes: true
        };
        var MEMO_STATICS = {
          '$$typeof': true,
          compare: true,
          defaultProps: true,
          displayName: true,
          propTypes: true,
          type: true
        };
        var TYPE_STATICS = {};
        TYPE_STATICS[reactIs$1.ForwardRef] = FORWARD_REF_STATICS;
        TYPE_STATICS[reactIs$1.Memo] = MEMO_STATICS;
        function getStatics(component) {
          // React v16.11 and below
          if (reactIs$1.isMemo(component)) {
            return MEMO_STATICS;
          } // React v16.12 and above

          return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
        }
        var defineProperty = Object.defineProperty;
        var getOwnPropertyNames = Object.getOwnPropertyNames;
        var getOwnPropertySymbols = Object.getOwnPropertySymbols;
        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        var getPrototypeOf = Object.getPrototypeOf;
        var objectPrototype = Object.prototype;
        function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
          if (typeof sourceComponent !== 'string') {
            // don't hoist over string (html) components
            if (objectPrototype) {
              var inheritedComponent = getPrototypeOf(sourceComponent);
              if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
              }
            }
            var keys = getOwnPropertyNames(sourceComponent);
            if (getOwnPropertySymbols) {
              keys = keys.concat(getOwnPropertySymbols(sourceComponent));
            }
            var targetStatics = getStatics(targetComponent);
            var sourceStatics = getStatics(sourceComponent);
            for (var i = 0; i < keys.length; ++i) {
              var key = keys[i];
              if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try {
                  // Avoid failures from read-only properties
                  defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
              }
            }
          }
          return targetComponent;
        }
        var hoistNonReactStatics_cjs = hoistNonReactStatics;
        const hoistStatics = exports('be', /*@__PURE__*/getDefaultExportFromCjs(hoistNonReactStatics_cjs));
        var reactIs = {
          exports: {}
        };
        var reactIs_production_min$1 = {};

        /** @license React v17.0.2
         * react-is.production.min.js
         *
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */
        var b$1 = 60103,
          c$1 = 60106,
          d$1 = 60107,
          e$2 = 60108,
          f$1 = 60114,
          g$1 = 60109,
          h$3 = 60110,
          k$2 = 60112,
          l$2 = 60113,
          m$2 = 60120,
          n$3 = 60115,
          p$3 = 60116,
          q$3 = 60121,
          r$3 = 60122,
          u$3 = 60117,
          v$2 = 60129,
          w$1 = 60131;
        if ("function" === typeof Symbol && Symbol.for) {
          var x = Symbol.for;
          b$1 = x("react.element");
          c$1 = x("react.portal");
          d$1 = x("react.fragment");
          e$2 = x("react.strict_mode");
          f$1 = x("react.profiler");
          g$1 = x("react.provider");
          h$3 = x("react.context");
          k$2 = x("react.forward_ref");
          l$2 = x("react.suspense");
          m$2 = x("react.suspense_list");
          n$3 = x("react.memo");
          p$3 = x("react.lazy");
          q$3 = x("react.block");
          r$3 = x("react.server.block");
          u$3 = x("react.fundamental");
          v$2 = x("react.debug_trace_mode");
          w$1 = x("react.legacy_hidden");
        }
        function y(a) {
          if ("object" === typeof a && null !== a) {
            var t = a.$$typeof;
            switch (t) {
              case b$1:
                switch (a = a.type, a) {
                  case d$1:
                  case f$1:
                  case e$2:
                  case l$2:
                  case m$2:
                    return a;
                  default:
                    switch (a = a && a.$$typeof, a) {
                      case h$3:
                      case k$2:
                      case p$3:
                      case n$3:
                      case g$1:
                        return a;
                      default:
                        return t;
                    }
                }
              case c$1:
                return t;
            }
          }
        }
        var z = g$1,
          A = b$1,
          B = k$2,
          C = d$1,
          D = p$3,
          E = n$3,
          F = c$1,
          G = f$1,
          H = e$2,
          I = l$2;
        reactIs_production_min$1.ContextConsumer = h$3;
        reactIs_production_min$1.ContextProvider = z;
        reactIs_production_min$1.Element = A;
        reactIs_production_min$1.ForwardRef = B;
        reactIs_production_min$1.Fragment = C;
        reactIs_production_min$1.Lazy = D;
        reactIs_production_min$1.Memo = E;
        reactIs_production_min$1.Portal = F;
        reactIs_production_min$1.Profiler = G;
        reactIs_production_min$1.StrictMode = H;
        reactIs_production_min$1.Suspense = I;
        reactIs_production_min$1.isAsyncMode = function () {
          return !1;
        };
        reactIs_production_min$1.isConcurrentMode = function () {
          return !1;
        };
        reactIs_production_min$1.isContextConsumer = function (a) {
          return y(a) === h$3;
        };
        reactIs_production_min$1.isContextProvider = function (a) {
          return y(a) === g$1;
        };
        reactIs_production_min$1.isElement = function (a) {
          return "object" === typeof a && null !== a && a.$$typeof === b$1;
        };
        reactIs_production_min$1.isForwardRef = function (a) {
          return y(a) === k$2;
        };
        reactIs_production_min$1.isFragment = function (a) {
          return y(a) === d$1;
        };
        reactIs_production_min$1.isLazy = function (a) {
          return y(a) === p$3;
        };
        reactIs_production_min$1.isMemo = function (a) {
          return y(a) === n$3;
        };
        reactIs_production_min$1.isPortal = function (a) {
          return y(a) === c$1;
        };
        reactIs_production_min$1.isProfiler = function (a) {
          return y(a) === f$1;
        };
        reactIs_production_min$1.isStrictMode = function (a) {
          return y(a) === e$2;
        };
        reactIs_production_min$1.isSuspense = function (a) {
          return y(a) === l$2;
        };
        reactIs_production_min$1.isValidElementType = function (a) {
          return "string" === typeof a || "function" === typeof a || a === d$1 || a === f$1 || a === v$2 || a === e$2 || a === l$2 || a === m$2 || a === w$1 || "object" === typeof a && null !== a && (a.$$typeof === p$3 || a.$$typeof === n$3 || a.$$typeof === g$1 || a.$$typeof === h$3 || a.$$typeof === k$2 || a.$$typeof === u$3 || a.$$typeof === q$3 || a[0] === r$3) ? !0 : !1;
        };
        reactIs_production_min$1.typeOf = y;
        {
          reactIs.exports = reactIs_production_min$1;
        }
        var reactIsExports = reactIs.exports;
        var _excluded$c = ["getDisplayName", "methodName", "renderCountProp", "shouldHandleStateChanges", "storeKey", "withRef", "forwardRef", "context"],
          _excluded2 = ["reactReduxForwardedRef"];
        var EMPTY_ARRAY = [];
        var NO_SUBSCRIPTION_ARRAY = [null, null];
        function storeStateUpdatesReducer(state, action) {
          var updateCount = state[1];
          return [action.payload, updateCount + 1];
        }
        function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
          useIsomorphicLayoutEffect$2(function () {
            return effectFunc.apply(void 0, effectArgs);
          }, dependencies);
        }
        function captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs) {
          // We want to capture the wrapper props and child props we used for later comparisons
          lastWrapperProps.current = wrapperProps;
          lastChildProps.current = actualChildProps;
          renderIsScheduled.current = false; // If the render was from a store update, clear out that reference and cascade the subscriber update

          if (childPropsFromStoreUpdate.current) {
            childPropsFromStoreUpdate.current = null;
            notifyNestedSubs();
          }
        }
        function subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch) {
          // If we're not subscribed to the store, nothing to do here
          if (!shouldHandleStateChanges) return; // Capture values for checking if and when this component unmounts

          var didUnsubscribe = false;
          var lastThrownError = null; // We'll run this callback every time a store subscription update propagates to this component

          var checkForUpdates = function checkForUpdates() {
            if (didUnsubscribe) {
              // Don't run stale listeners.
              // Redux doesn't guarantee unsubscriptions happen until next dispatch.
              return;
            }
            var latestStoreState = store.getState();
            var newChildProps, error;
            try {
              // Actually run the selector with the most recent store state and wrapper props
              // to determine what the child props should be
              newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);
            } catch (e) {
              error = e;
              lastThrownError = e;
            }
            if (!error) {
              lastThrownError = null;
            } // If the child props haven't changed, nothing to do here - cascade the subscription update

            if (newChildProps === lastChildProps.current) {
              if (!renderIsScheduled.current) {
                notifyNestedSubs();
              }
            } else {
              // Save references to the new child props.  Note that we track the "child props from store update"
              // as a ref instead of a useState/useReducer because we need a way to determine if that value has
              // been processed.  If this went into useState/useReducer, we couldn't clear out the value without
              // forcing another re-render, which we don't want.
              lastChildProps.current = newChildProps;
              childPropsFromStoreUpdate.current = newChildProps;
              renderIsScheduled.current = true; // If the child props _did_ change (or we caught an error), this wrapper component needs to re-render

              forceComponentUpdateDispatch({
                type: 'STORE_UPDATED',
                payload: {
                  error: error
                }
              });
            }
          }; // Actually subscribe to the nearest connected ancestor (or store)

          subscription.onStateChange = checkForUpdates;
          subscription.trySubscribe(); // Pull data from the store after first render in case the store has
          // changed since we began.

          checkForUpdates();
          var unsubscribeWrapper = function unsubscribeWrapper() {
            didUnsubscribe = true;
            subscription.tryUnsubscribe();
            subscription.onStateChange = null;
            if (lastThrownError) {
              // It's possible that we caught an error due to a bad mapState function, but the
              // parent re-rendered without this component and we're about to unmount.
              // This shouldn't happen as long as we do top-down subscriptions correctly, but
              // if we ever do those wrong, this throw will surface the error in our tests.
              // In that case, throw the error from here so it doesn't get lost.
              throw lastThrownError;
            }
          };
          return unsubscribeWrapper;
        }
        var initStateUpdates = function initStateUpdates() {
          return [null, 0];
        };
        function connectAdvanced(
        /*
          selectorFactory is a func that is responsible for returning the selector function used to
          compute new props from state, props, and dispatch. For example:
              export default connectAdvanced((dispatch, options) => (state, props) => ({
              thing: state.things[props.thingId],
              saveThing: fields => dispatch(actionCreators.saveThing(props.thingId, fields)),
            }))(YourComponent)
            Access to dispatch is provided to the factory so selectorFactories can bind actionCreators
          outside of their selector as an optimization. Options passed to connectAdvanced are passed to
          the selectorFactory, along with displayName and WrappedComponent, as the second argument.
            Note that selectorFactory is responsible for all caching/memoization of inbound and outbound
          props. Do not use connectAdvanced directly without memoizing results between calls to your
          selector, otherwise the Connect component will re-render on every state or props change.
        */
        selectorFactory,
        // options object:
        _ref) {
          if (_ref === void 0) {
            _ref = {};
          }
          var _ref2 = _ref,
            _ref2$getDisplayName = _ref2.getDisplayName,
            getDisplayName = _ref2$getDisplayName === void 0 ? function (name) {
              return "ConnectAdvanced(" + name + ")";
            } : _ref2$getDisplayName,
            _ref2$methodName = _ref2.methodName,
            methodName = _ref2$methodName === void 0 ? 'connectAdvanced' : _ref2$methodName,
            _ref2$renderCountProp = _ref2.renderCountProp,
            renderCountProp = _ref2$renderCountProp === void 0 ? undefined : _ref2$renderCountProp,
            _ref2$shouldHandleSta = _ref2.shouldHandleStateChanges,
            shouldHandleStateChanges = _ref2$shouldHandleSta === void 0 ? true : _ref2$shouldHandleSta,
            _ref2$storeKey = _ref2.storeKey,
            storeKey = _ref2$storeKey === void 0 ? 'store' : _ref2$storeKey;
          _ref2.withRef;
          var _ref2$forwardRef = _ref2.forwardRef,
            forwardRef = _ref2$forwardRef === void 0 ? false : _ref2$forwardRef,
            _ref2$context = _ref2.context,
            context = _ref2$context === void 0 ? ReactReduxContext$1 : _ref2$context,
            connectOptions = _objectWithoutPropertiesLoose$1(_ref2, _excluded$c);
          var Context = context;
          return function wrapWithConnect(WrappedComponent) {
            var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';
            var displayName = getDisplayName(wrappedComponentName);
            var selectorFactoryOptions = _extends({}, connectOptions, {
              getDisplayName: getDisplayName,
              methodName: methodName,
              renderCountProp: renderCountProp,
              shouldHandleStateChanges: shouldHandleStateChanges,
              storeKey: storeKey,
              displayName: displayName,
              wrappedComponentName: wrappedComponentName,
              WrappedComponent: WrappedComponent
            });
            var pure = connectOptions.pure;
            function createChildSelector(store) {
              return selectorFactory(store.dispatch, selectorFactoryOptions);
            } // If we aren't running in "pure" mode, we don't want to memoize values.
            // To avoid conditionally calling hooks, we fall back to a tiny wrapper
            // that just executes the given callback immediately.

            var usePureOnlyMemo = pure ? reactExports.useMemo : function (callback) {
              return callback();
            };
            function ConnectFunction(props) {
              var _useMemo = reactExports.useMemo(function () {
                  // Distinguish between actual "data" props that were passed to the wrapper component,
                  // and values needed to control behavior (forwarded refs, alternate context instances).
                  // To maintain the wrapperProps object reference, memoize this destructuring.
                  var reactReduxForwardedRef = props.reactReduxForwardedRef,
                    wrapperProps = _objectWithoutPropertiesLoose$1(props, _excluded2);
                  return [props.context, reactReduxForwardedRef, wrapperProps];
                }, [props]),
                propsContext = _useMemo[0],
                reactReduxForwardedRef = _useMemo[1],
                wrapperProps = _useMemo[2];
              var ContextToUse = reactExports.useMemo(function () {
                // Users may optionally pass in a custom context instance to use instead of our ReactReduxContext.
                // Memoize the check that determines which context instance we should use.
                return propsContext && propsContext.Consumer && reactIsExports.isContextConsumer( /*#__PURE__*/React.createElement(propsContext.Consumer, null)) ? propsContext : Context;
              }, [propsContext, Context]); // Retrieve the store and ancestor subscription via context, if available

              var contextValue = reactExports.useContext(ContextToUse); // The store _must_ exist as either a prop or in context.
              // We'll check to see if it _looks_ like a Redux store first.
              // This allows us to pass through a `store` prop that is just a plain value.

              var didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);
              Boolean(contextValue) && Boolean(contextValue.store);
              var store = didStoreComeFromProps ? props.store : contextValue.store;
              var childPropsSelector = reactExports.useMemo(function () {
                // The child props selector needs the store reference as an input.
                // Re-create this selector whenever the store changes.
                return createChildSelector(store);
              }, [store]);
              var _useMemo2 = reactExports.useMemo(function () {
                  if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY; // This Subscription's source should match where store came from: props vs. context. A component
                  // connected to the store via props shouldn't use subscription from context, or vice versa.

                  // This Subscription's source should match where store came from: props vs. context. A component
                  // connected to the store via props shouldn't use subscription from context, or vice versa.
                  var subscription = createSubscription$1(store, didStoreComeFromProps ? null : contextValue.subscription); // `notifyNestedSubs` is duplicated to handle the case where the component is unmounted in
                  // the middle of the notification loop, where `subscription` will then be null. This can
                  // probably be avoided if Subscription's listeners logic is changed to not call listeners
                  // that have been unsubscribed in the  middle of the notification loop.

                  // `notifyNestedSubs` is duplicated to handle the case where the component is unmounted in
                  // the middle of the notification loop, where `subscription` will then be null. This can
                  // probably be avoided if Subscription's listeners logic is changed to not call listeners
                  // that have been unsubscribed in the  middle of the notification loop.
                  var notifyNestedSubs = subscription.notifyNestedSubs.bind(subscription);
                  return [subscription, notifyNestedSubs];
                }, [store, didStoreComeFromProps, contextValue]),
                subscription = _useMemo2[0],
                notifyNestedSubs = _useMemo2[1]; // Determine what {store, subscription} value should be put into nested context, if necessary,
              // and memoize that value to avoid unnecessary context updates.

              var overriddenContextValue = reactExports.useMemo(function () {
                if (didStoreComeFromProps) {
                  // This component is directly subscribed to a store from props.
                  // We don't want descendants reading from this store - pass down whatever
                  // the existing context value is from the nearest connected ancestor.
                  return contextValue;
                } // Otherwise, put this component's subscription instance into context, so that
                // connected descendants won't update until after this component is done

                return _extends({}, contextValue, {
                  subscription: subscription
                });
              }, [didStoreComeFromProps, contextValue, subscription]); // We need to force this wrapper component to re-render whenever a Redux store update
              // causes a change to the calculated child component props (or we caught an error in mapState)

              var _useReducer = reactExports.useReducer(storeStateUpdatesReducer, EMPTY_ARRAY, initStateUpdates),
                _useReducer$ = _useReducer[0],
                previousStateUpdateResult = _useReducer$[0],
                forceComponentUpdateDispatch = _useReducer[1]; // Propagate any mapState/mapDispatch errors upwards

              if (previousStateUpdateResult && previousStateUpdateResult.error) {
                throw previousStateUpdateResult.error;
              } // Set up refs to coordinate values between the subscription effect and the render logic

              var lastChildProps = reactExports.useRef();
              var lastWrapperProps = reactExports.useRef(wrapperProps);
              var childPropsFromStoreUpdate = reactExports.useRef();
              var renderIsScheduled = reactExports.useRef(false);
              var actualChildProps = usePureOnlyMemo(function () {
                // Tricky logic here:
                // - This render may have been triggered by a Redux store update that produced new child props
                // - However, we may have gotten new wrapper props after that
                // If we have new child props, and the same wrapper props, we know we should use the new child props as-is.
                // But, if we have new wrapper props, those might change the child props, so we have to recalculate things.
                // So, we'll use the child props from store update only if the wrapper props are the same as last time.
                if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {
                  return childPropsFromStoreUpdate.current;
                } // TODO We're reading the store directly in render() here. Bad idea?
                // This will likely cause Bad Things (TM) to happen in Concurrent Mode.
                // Note that we do this because on renders _not_ caused by store updates, we need the latest store state
                // to determine what the child props should be.

                return childPropsSelector(store.getState(), wrapperProps);
              }, [store, previousStateUpdateResult, wrapperProps]); // We need this to execute synchronously every time we re-render. However, React warns
              // about useLayoutEffect in SSR, so we try to detect environment and fall back to
              // just useEffect instead to avoid the warning, since neither will run anyway.

              useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs]); // Our re-subscribe logic only runs when the store/subscription setup changes

              useIsomorphicLayoutEffectWithArgs(subscribeUpdates, [shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch], [store, subscription, childPropsSelector]); // Now that all that's done, we can finally try to actually render the child component.
              // We memoize the elements for the rendered child component as an optimization.

              var renderedWrappedComponent = reactExports.useMemo(function () {
                return /*#__PURE__*/React.createElement(WrappedComponent, _extends({}, actualChildProps, {
                  ref: reactReduxForwardedRef
                }));
              }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]); // If React sees the exact same element reference as last time, it bails out of re-rendering
              // that child, same as if it was wrapped in React.memo() or returned false from shouldComponentUpdate.

              var renderedChild = reactExports.useMemo(function () {
                if (shouldHandleStateChanges) {
                  // If this component is subscribed to store updates, we need to pass its own
                  // subscription instance down to our descendants. That means rendering the same
                  // Context instance, and putting a different value into the context.
                  return /*#__PURE__*/React.createElement(ContextToUse.Provider, {
                    value: overriddenContextValue
                  }, renderedWrappedComponent);
                }
                return renderedWrappedComponent;
              }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);
              return renderedChild;
            } // If we're in "pure" mode, ensure our wrapper component only re-renders when incoming props have changed.

            var Connect = pure ? React.memo(ConnectFunction) : ConnectFunction;
            Connect.WrappedComponent = WrappedComponent;
            Connect.displayName = ConnectFunction.displayName = displayName;
            if (forwardRef) {
              var forwarded = React.forwardRef(function forwardConnectRef(props, ref) {
                return /*#__PURE__*/React.createElement(Connect, _extends({}, props, {
                  reactReduxForwardedRef: ref
                }));
              });
              forwarded.displayName = displayName;
              forwarded.WrappedComponent = WrappedComponent;
              return hoistStatics(forwarded, WrappedComponent);
            }
            return hoistStatics(Connect, WrappedComponent);
          };
        }
        function is(x, y) {
          if (x === y) {
            return x !== 0 || y !== 0 || 1 / x === 1 / y;
          } else {
            return x !== x && y !== y;
          }
        }
        function shallowEqual(objA, objB) {
          if (is(objA, objB)) return true;
          if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
            return false;
          }
          var keysA = Object.keys(objA);
          var keysB = Object.keys(objB);
          if (keysA.length !== keysB.length) return false;
          for (var i = 0; i < keysA.length; i++) {
            if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
              return false;
            }
          }
          return true;
        }
        function bindActionCreators(actionCreators, dispatch) {
          var boundActionCreators = {};
          var _loop = function _loop(key) {
            var actionCreator = actionCreators[key];
            if (typeof actionCreator === 'function') {
              boundActionCreators[key] = function () {
                return dispatch(actionCreator.apply(void 0, arguments));
              };
            }
          };
          for (var key in actionCreators) {
            _loop(key);
          }
          return boundActionCreators;
        }
        function wrapMapToPropsConstant(getConstant) {
          return function initConstantSelector(dispatch, options) {
            var constant = getConstant(dispatch, options);
            function constantSelector() {
              return constant;
            }
            constantSelector.dependsOnOwnProps = false;
            return constantSelector;
          };
        } // dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args
        // to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine
        // whether mapToProps needs to be invoked when props have changed.
        //
        // A length of one signals that mapToProps does not depend on props from the parent component.
        // A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and
        // therefore not reporting its length accurately..

        function getDependsOnOwnProps(mapToProps) {
          return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
        } // Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,
        // this function wraps mapToProps in a proxy function which does several things:
        //
        //  * Detects whether the mapToProps function being called depends on props, which
        //    is used by selectorFactory to decide if it should reinvoke on props changes.
        //
        //  * On first call, handles mapToProps if returns another function, and treats that
        //    new function as the true mapToProps for subsequent calls.
        //
        //  * On first call, verifies the first result is a plain object, in order to warn
        //    the developer that their mapToProps function is not returning a valid result.
        //

        function wrapMapToPropsFunc(mapToProps, methodName) {
          return function initProxySelector(dispatch, _ref) {
            _ref.displayName;
            var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
              return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
            }; // allow detectFactoryAndVerify to get ownProps

            proxy.dependsOnOwnProps = true;
            proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
              proxy.mapToProps = mapToProps;
              proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
              var props = proxy(stateOrDispatch, ownProps);
              if (typeof props === 'function') {
                proxy.mapToProps = props;
                proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
                props = proxy(stateOrDispatch, ownProps);
              }
              return props;
            };
            return proxy;
          };
        }
        function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
          return typeof mapDispatchToProps === 'function' ? wrapMapToPropsFunc(mapDispatchToProps) : undefined;
        }
        function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
          return !mapDispatchToProps ? wrapMapToPropsConstant(function (dispatch) {
            return {
              dispatch: dispatch
            };
          }) : undefined;
        }
        function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
          return mapDispatchToProps && typeof mapDispatchToProps === 'object' ? wrapMapToPropsConstant(function (dispatch) {
            return bindActionCreators(mapDispatchToProps, dispatch);
          }) : undefined;
        }
        const defaultMapDispatchToPropsFactories = [whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject];
        function whenMapStateToPropsIsFunction(mapStateToProps) {
          return typeof mapStateToProps === 'function' ? wrapMapToPropsFunc(mapStateToProps) : undefined;
        }
        function whenMapStateToPropsIsMissing(mapStateToProps) {
          return !mapStateToProps ? wrapMapToPropsConstant(function () {
            return {};
          }) : undefined;
        }
        const defaultMapStateToPropsFactories = [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing];
        function defaultMergeProps(stateProps, dispatchProps, ownProps) {
          return _extends({}, ownProps, stateProps, dispatchProps);
        }
        function wrapMergePropsFunc(mergeProps) {
          return function initMergePropsProxy(dispatch, _ref) {
            _ref.displayName;
            var pure = _ref.pure,
              areMergedPropsEqual = _ref.areMergedPropsEqual;
            var hasRunOnce = false;
            var mergedProps;
            return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
              var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);
              if (hasRunOnce) {
                if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;
              } else {
                hasRunOnce = true;
                mergedProps = nextMergedProps;
              }
              return mergedProps;
            };
          };
        }
        function whenMergePropsIsFunction(mergeProps) {
          return typeof mergeProps === 'function' ? wrapMergePropsFunc(mergeProps) : undefined;
        }
        function whenMergePropsIsOmitted(mergeProps) {
          return !mergeProps ? function () {
            return defaultMergeProps;
          } : undefined;
        }
        const defaultMergePropsFactories = [whenMergePropsIsFunction, whenMergePropsIsOmitted];
        var _excluded$b = ["initMapStateToProps", "initMapDispatchToProps", "initMergeProps"];
        function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {
          return function impureFinalPropsSelector(state, ownProps) {
            return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);
          };
        }
        function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {
          var areStatesEqual = _ref.areStatesEqual,
            areOwnPropsEqual = _ref.areOwnPropsEqual,
            areStatePropsEqual = _ref.areStatePropsEqual;
          var hasRunAtLeastOnce = false;
          var state;
          var ownProps;
          var stateProps;
          var dispatchProps;
          var mergedProps;
          function handleFirstCall(firstState, firstOwnProps) {
            state = firstState;
            ownProps = firstOwnProps;
            stateProps = mapStateToProps(state, ownProps);
            dispatchProps = mapDispatchToProps(dispatch, ownProps);
            mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
            hasRunAtLeastOnce = true;
            return mergedProps;
          }
          function handleNewPropsAndNewState() {
            stateProps = mapStateToProps(state, ownProps);
            if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
            mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
            return mergedProps;
          }
          function handleNewProps() {
            if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);
            if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
            mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
            return mergedProps;
          }
          function handleNewState() {
            var nextStateProps = mapStateToProps(state, ownProps);
            var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
            stateProps = nextStateProps;
            if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
            return mergedProps;
          }
          function handleSubsequentCalls(nextState, nextOwnProps) {
            var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
            var stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);
            state = nextState;
            ownProps = nextOwnProps;
            if (propsChanged && stateChanged) return handleNewPropsAndNewState();
            if (propsChanged) return handleNewProps();
            if (stateChanged) return handleNewState();
            return mergedProps;
          }
          return function pureFinalPropsSelector(nextState, nextOwnProps) {
            return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
          };
        } // TODO: Add more comments
        // If pure is true, the selector returned by selectorFactory will memoize its results,
        // allowing connectAdvanced's shouldComponentUpdate to return false if final
        // props have not changed. If false, the selector will always return a new
        // object and shouldComponentUpdate will always return true.

        function finalPropsSelectorFactory(dispatch, _ref2) {
          var initMapStateToProps = _ref2.initMapStateToProps,
            initMapDispatchToProps = _ref2.initMapDispatchToProps,
            initMergeProps = _ref2.initMergeProps,
            options = _objectWithoutPropertiesLoose$1(_ref2, _excluded$b);
          var mapStateToProps = initMapStateToProps(dispatch, options);
          var mapDispatchToProps = initMapDispatchToProps(dispatch, options);
          var mergeProps = initMergeProps(dispatch, options);
          var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;
          return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
        }
        var _excluded$a = ["pure", "areStatesEqual", "areOwnPropsEqual", "areStatePropsEqual", "areMergedPropsEqual"];
        /*
          connect is a facade over connectAdvanced. It turns its args into a compatible
          selectorFactory, which has the signature:
              (dispatch, options) => (nextState, nextOwnProps) => nextFinalProps
          
          connect passes its args to connectAdvanced as options, which will in turn pass them to
          selectorFactory each time a Connect component instance is instantiated or hot reloaded.
            selectorFactory returns a final props selector from its mapStateToProps,
          mapStateToPropsFactories, mapDispatchToProps, mapDispatchToPropsFactories, mergeProps,
          mergePropsFactories, and pure args.
            The resulting final props selector is called by the Connect component instance whenever
          it receives new props or store state.
         */

        function match$1(arg, factories, name) {
          for (var i = factories.length - 1; i >= 0; i--) {
            var result = factories[i](arg);
            if (result) return result;
          }
          return function (dispatch, options) {
            throw new Error("Invalid value of type " + typeof arg + " for " + name + " argument when connecting component " + options.wrappedComponentName + ".");
          };
        }
        function strictEqual(a, b) {
          return a === b;
        } // createConnect with default args builds the 'official' connect behavior. Calling it with
        // different options opens up some testing and extensibility scenarios

        function createConnect(_temp) {
          var _ref = _temp === void 0 ? {} : _temp,
            _ref$connectHOC = _ref.connectHOC,
            connectHOC = _ref$connectHOC === void 0 ? connectAdvanced : _ref$connectHOC,
            _ref$mapStateToPropsF = _ref.mapStateToPropsFactories,
            mapStateToPropsFactories = _ref$mapStateToPropsF === void 0 ? defaultMapStateToPropsFactories : _ref$mapStateToPropsF,
            _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories,
            mapDispatchToPropsFactories = _ref$mapDispatchToPro === void 0 ? defaultMapDispatchToPropsFactories : _ref$mapDispatchToPro,
            _ref$mergePropsFactor = _ref.mergePropsFactories,
            mergePropsFactories = _ref$mergePropsFactor === void 0 ? defaultMergePropsFactories : _ref$mergePropsFactor,
            _ref$selectorFactory = _ref.selectorFactory,
            selectorFactory = _ref$selectorFactory === void 0 ? finalPropsSelectorFactory : _ref$selectorFactory;
          return function connect(mapStateToProps, mapDispatchToProps, mergeProps, _ref2) {
            if (_ref2 === void 0) {
              _ref2 = {};
            }
            var _ref3 = _ref2,
              _ref3$pure = _ref3.pure,
              pure = _ref3$pure === void 0 ? true : _ref3$pure,
              _ref3$areStatesEqual = _ref3.areStatesEqual,
              areStatesEqual = _ref3$areStatesEqual === void 0 ? strictEqual : _ref3$areStatesEqual,
              _ref3$areOwnPropsEqua = _ref3.areOwnPropsEqual,
              areOwnPropsEqual = _ref3$areOwnPropsEqua === void 0 ? shallowEqual : _ref3$areOwnPropsEqua,
              _ref3$areStatePropsEq = _ref3.areStatePropsEqual,
              areStatePropsEqual = _ref3$areStatePropsEq === void 0 ? shallowEqual : _ref3$areStatePropsEq,
              _ref3$areMergedPropsE = _ref3.areMergedPropsEqual,
              areMergedPropsEqual = _ref3$areMergedPropsE === void 0 ? shallowEqual : _ref3$areMergedPropsE,
              extraOptions = _objectWithoutPropertiesLoose$1(_ref3, _excluded$a);
            var initMapStateToProps = match$1(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps');
            var initMapDispatchToProps = match$1(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps');
            var initMergeProps = match$1(mergeProps, mergePropsFactories, 'mergeProps');
            return connectHOC(selectorFactory, _extends({
              // used in error messages
              methodName: 'connect',
              // used to compute Connect's displayName from the wrapped component's displayName.
              getDisplayName: function getDisplayName(name) {
                return "Connect(" + name + ")";
              },
              // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
              shouldHandleStateChanges: Boolean(mapStateToProps),
              // passed through to selectorFactory
              initMapStateToProps: initMapStateToProps,
              initMapDispatchToProps: initMapDispatchToProps,
              initMergeProps: initMergeProps,
              pure: pure,
              areStatesEqual: areStatesEqual,
              areOwnPropsEqual: areOwnPropsEqual,
              areStatePropsEqual: areStatePropsEqual,
              areMergedPropsEqual: areMergedPropsEqual
            }, extraOptions));
          };
        }
        const connect = /*#__PURE__*/createConnect();

        // with standard React renderers (ReactDOM, React Native)

        setBatch$1(reactDomExports.unstable_batchedUpdates);
        function areInputsEqual$1(newInputs, lastInputs) {
          if (newInputs.length !== lastInputs.length) {
            return false;
          }
          for (var i = 0; i < newInputs.length; i++) {
            if (newInputs[i] !== lastInputs[i]) {
              return false;
            }
          }
          return true;
        }
        function useMemoOne(getResult, inputs) {
          var initial = reactExports.useState(function () {
            return {
              inputs: inputs,
              result: getResult()
            };
          })[0];
          var isFirstRun = reactExports.useRef(true);
          var committed = reactExports.useRef(initial);
          var useCache = isFirstRun.current || Boolean(inputs && committed.current.inputs && areInputsEqual$1(inputs, committed.current.inputs));
          var cache = useCache ? committed.current : {
            inputs: inputs,
            result: getResult()
          };
          reactExports.useEffect(function () {
            isFirstRun.current = false;
            committed.current = cache;
          }, [cache]);
          return cache.result;
        }
        function useCallbackOne(callback, inputs) {
          return useMemoOne(function () {
            return callback;
          }, inputs);
        }
        var useMemo = useMemoOne;
        var useCallback = useCallbackOne;
        var isProduction = "production" === 'production';
        var prefix$3 = 'Invariant failed';
        function invariant$1(condition, message) {
          if (condition) {
            return;
          }
          if (isProduction) {
            throw new Error(prefix$3);
          }
          var provided = typeof message === 'function' ? message() : message;
          var value = provided ? "".concat(prefix$3, ": ").concat(provided) : prefix$3;
          throw new Error(value);
        }
        var getRect = function getRect(_ref) {
          var top = _ref.top,
            right = _ref.right,
            bottom = _ref.bottom,
            left = _ref.left;
          var width = right - left;
          var height = bottom - top;
          var rect = {
            top: top,
            right: right,
            bottom: bottom,
            left: left,
            width: width,
            height: height,
            x: left,
            y: top,
            center: {
              x: (right + left) / 2,
              y: (bottom + top) / 2
            }
          };
          return rect;
        };
        var expand = function expand(target, expandBy) {
          return {
            top: target.top - expandBy.top,
            left: target.left - expandBy.left,
            bottom: target.bottom + expandBy.bottom,
            right: target.right + expandBy.right
          };
        };
        var shrink = function shrink(target, shrinkBy) {
          return {
            top: target.top + shrinkBy.top,
            left: target.left + shrinkBy.left,
            bottom: target.bottom - shrinkBy.bottom,
            right: target.right - shrinkBy.right
          };
        };
        var shift = function shift(target, shiftBy) {
          return {
            top: target.top + shiftBy.y,
            left: target.left + shiftBy.x,
            bottom: target.bottom + shiftBy.y,
            right: target.right + shiftBy.x
          };
        };
        var noSpacing$1 = {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        };
        var createBox = function createBox(_ref2) {
          var borderBox = _ref2.borderBox,
            _ref2$margin = _ref2.margin,
            margin = _ref2$margin === void 0 ? noSpacing$1 : _ref2$margin,
            _ref2$border = _ref2.border,
            border = _ref2$border === void 0 ? noSpacing$1 : _ref2$border,
            _ref2$padding = _ref2.padding,
            padding = _ref2$padding === void 0 ? noSpacing$1 : _ref2$padding;
          var marginBox = getRect(expand(borderBox, margin));
          var paddingBox = getRect(shrink(borderBox, border));
          var contentBox = getRect(shrink(paddingBox, padding));
          return {
            marginBox: marginBox,
            borderBox: getRect(borderBox),
            paddingBox: paddingBox,
            contentBox: contentBox,
            margin: margin,
            border: border,
            padding: padding
          };
        };
        var parse$1 = function parse(raw) {
          var value = raw.slice(0, -2);
          var suffix = raw.slice(-2);
          if (suffix !== 'px') {
            return 0;
          }
          var result = Number(value);
          !!isNaN(result) ? invariant$1(false) : void 0;
          return result;
        };
        var getWindowScroll$1 = function getWindowScroll() {
          return {
            x: window.pageXOffset,
            y: window.pageYOffset
          };
        };
        var offset = function offset(original, change) {
          var borderBox = original.borderBox,
            border = original.border,
            margin = original.margin,
            padding = original.padding;
          var shifted = shift(borderBox, change);
          return createBox({
            borderBox: shifted,
            border: border,
            margin: margin,
            padding: padding
          });
        };
        var withScroll = function withScroll(original, scroll) {
          if (scroll === void 0) {
            scroll = getWindowScroll$1();
          }
          return offset(original, scroll);
        };
        var calculateBox = function calculateBox(borderBox, styles) {
          var margin = {
            top: parse$1(styles.marginTop),
            right: parse$1(styles.marginRight),
            bottom: parse$1(styles.marginBottom),
            left: parse$1(styles.marginLeft)
          };
          var padding = {
            top: parse$1(styles.paddingTop),
            right: parse$1(styles.paddingRight),
            bottom: parse$1(styles.paddingBottom),
            left: parse$1(styles.paddingLeft)
          };
          var border = {
            top: parse$1(styles.borderTopWidth),
            right: parse$1(styles.borderRightWidth),
            bottom: parse$1(styles.borderBottomWidth),
            left: parse$1(styles.borderLeftWidth)
          };
          return createBox({
            borderBox: borderBox,
            margin: margin,
            padding: padding,
            border: border
          });
        };
        var getBox = function getBox(el) {
          var borderBox = el.getBoundingClientRect();
          var styles = window.getComputedStyle(el);
          return calculateBox(borderBox, styles);
        };
        var safeIsNaN = Number.isNaN || function ponyfill(value) {
          return typeof value === 'number' && value !== value;
        };
        function isEqual$2(first, second) {
          if (first === second) {
            return true;
          }
          if (safeIsNaN(first) && safeIsNaN(second)) {
            return true;
          }
          return false;
        }
        function areInputsEqual(newInputs, lastInputs) {
          if (newInputs.length !== lastInputs.length) {
            return false;
          }
          for (var i = 0; i < newInputs.length; i++) {
            if (!isEqual$2(newInputs[i], lastInputs[i])) {
              return false;
            }
          }
          return true;
        }
        function memoizeOne(resultFn, isEqual) {
          if (isEqual === void 0) {
            isEqual = areInputsEqual;
          }
          var lastThis;
          var lastArgs = [];
          var lastResult;
          var calledOnce = false;
          function memoized() {
            var newArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              newArgs[_i] = arguments[_i];
            }
            if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {
              return lastResult;
            }
            lastResult = resultFn.apply(this, newArgs);
            calledOnce = true;
            lastThis = this;
            lastArgs = newArgs;
            return lastResult;
          }
          return memoized;
        }
        const memoizeOne_esm = /*#__PURE__*/Object.freeze( /*#__PURE__*/Object.defineProperty({
          __proto__: null,
          default: memoizeOne
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        exports('bL', memoizeOne_esm);
        var rafSchd = function rafSchd(fn) {
          var lastArgs = [];
          var frameId = null;
          var wrapperFn = function wrapperFn() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            lastArgs = args;
            if (frameId) {
              return;
            }
            frameId = requestAnimationFrame(function () {
              frameId = null;
              fn.apply(void 0, lastArgs);
            });
          };
          wrapperFn.cancel = function () {
            if (!frameId) {
              return;
            }
            cancelAnimationFrame(frameId);
            frameId = null;
          };
          return wrapperFn;
        };
        const rafSchd$1 = rafSchd;
        function log(type, message) {
          {
            return;
          }
        }
        log.bind(null, 'warn');
        log.bind(null, 'error');
        function noop() {}
        function getOptions(shared, fromBinding) {
          return _extends({}, shared, {}, fromBinding);
        }
        function bindEvents(el, bindings, sharedOptions) {
          var unbindings = bindings.map(function (binding) {
            var options = getOptions(sharedOptions, binding.options);
            el.addEventListener(binding.eventName, binding.fn, options);
            return function unbind() {
              el.removeEventListener(binding.eventName, binding.fn, options);
            };
          });
          return function unbindAll() {
            unbindings.forEach(function (unbind) {
              unbind();
            });
          };
        }
        var prefix$2 = 'Invariant failed';
        function RbdInvariant(message) {
          this.message = message;
        }
        RbdInvariant.prototype.toString = function toString() {
          return this.message;
        };
        function invariant(condition, message) {
          if (condition) {
            return;
          }
          {
            throw new RbdInvariant(prefix$2);
          }
        }
        var ErrorBoundary = function (_React$Component) {
          _inheritsLoose(ErrorBoundary, _React$Component);
          function ErrorBoundary() {
            var _this;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
            _this.callbacks = null;
            _this.unbind = noop;
            _this.onWindowError = function (event) {
              var callbacks = _this.getCallbacks();
              if (callbacks.isDragging()) {
                callbacks.tryAbort();
              }
              var err = event.error;
              if (err instanceof RbdInvariant) {
                event.preventDefault();
              }
            };
            _this.getCallbacks = function () {
              if (!_this.callbacks) {
                throw new Error('Unable to find AppCallbacks in <ErrorBoundary/>');
              }
              return _this.callbacks;
            };
            _this.setCallbacks = function (callbacks) {
              _this.callbacks = callbacks;
            };
            return _this;
          }
          var _proto = ErrorBoundary.prototype;
          _proto.componentDidMount = function componentDidMount() {
            this.unbind = bindEvents(window, [{
              eventName: 'error',
              fn: this.onWindowError
            }]);
          };
          _proto.componentDidCatch = function componentDidCatch(err) {
            if (err instanceof RbdInvariant) {
              this.setState({});
              return;
            }
            throw err;
          };
          _proto.componentWillUnmount = function componentWillUnmount() {
            this.unbind();
          };
          _proto.render = function render() {
            return this.props.children(this.setCallbacks);
          };
          return ErrorBoundary;
        }(React.Component);
        var dragHandleUsageInstructions = "\n  Press space bar to start a drag.\n  When dragging you can use the arrow keys to move the item around and escape to cancel.\n  Some screen readers may require you to be in focus mode or to use your pass through key\n";
        var position$1 = function position(index) {
          return index + 1;
        };
        var onDragStart = function onDragStart(start) {
          return "\n  You have lifted an item in position " + position$1(start.source.index) + "\n";
        };
        var withLocation = function withLocation(source, destination) {
          var isInHomeList = source.droppableId === destination.droppableId;
          var startPosition = position$1(source.index);
          var endPosition = position$1(destination.index);
          if (isInHomeList) {
            return "\n      You have moved the item from position " + startPosition + "\n      to position " + endPosition + "\n    ";
          }
          return "\n    You have moved the item from position " + startPosition + "\n    in list " + source.droppableId + "\n    to list " + destination.droppableId + "\n    in position " + endPosition + "\n  ";
        };
        var withCombine = function withCombine(id, source, combine) {
          var inHomeList = source.droppableId === combine.droppableId;
          if (inHomeList) {
            return "\n      The item " + id + "\n      has been combined with " + combine.draggableId;
          }
          return "\n      The item " + id + "\n      in list " + source.droppableId + "\n      has been combined with " + combine.draggableId + "\n      in list " + combine.droppableId + "\n    ";
        };
        var onDragUpdate = function onDragUpdate(update) {
          var location = update.destination;
          if (location) {
            return withLocation(update.source, location);
          }
          var combine = update.combine;
          if (combine) {
            return withCombine(update.draggableId, update.source, combine);
          }
          return 'You are over an area that cannot be dropped on';
        };
        var returnedToStart = function returnedToStart(source) {
          return "\n  The item has returned to its starting position\n  of " + position$1(source.index) + "\n";
        };
        var onDragEnd = function onDragEnd(result) {
          if (result.reason === 'CANCEL') {
            return "\n      Movement cancelled.\n      " + returnedToStart(result.source) + "\n    ";
          }
          var location = result.destination;
          var combine = result.combine;
          if (location) {
            return "\n      You have dropped the item.\n      " + withLocation(result.source, location) + "\n    ";
          }
          if (combine) {
            return "\n      You have dropped the item.\n      " + withCombine(result.draggableId, result.source, combine) + "\n    ";
          }
          return "\n    The item has been dropped while not over a drop area.\n    " + returnedToStart(result.source) + "\n  ";
        };
        var preset = {
          dragHandleUsageInstructions: dragHandleUsageInstructions,
          onDragStart: onDragStart,
          onDragUpdate: onDragUpdate,
          onDragEnd: onDragEnd
        };
        var origin = {
          x: 0,
          y: 0
        };
        var add = function add(point1, point2) {
          return {
            x: point1.x + point2.x,
            y: point1.y + point2.y
          };
        };
        var subtract = function subtract(point1, point2) {
          return {
            x: point1.x - point2.x,
            y: point1.y - point2.y
          };
        };
        var isEqual = function isEqual(point1, point2) {
          return point1.x === point2.x && point1.y === point2.y;
        };
        var negate = function negate(point) {
          return {
            x: point.x !== 0 ? -point.x : 0,
            y: point.y !== 0 ? -point.y : 0
          };
        };
        var patch = function patch(line, value, otherValue) {
          var _ref;
          if (otherValue === void 0) {
            otherValue = 0;
          }
          return _ref = {}, _ref[line] = value, _ref[line === 'x' ? 'y' : 'x'] = otherValue, _ref;
        };
        var distance = function distance(point1, point2) {
          return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
        };
        var closest = function closest(target, points) {
          return Math.min.apply(Math, points.map(function (point) {
            return distance(target, point);
          }));
        };
        var apply = function apply(fn) {
          return function (point) {
            return {
              x: fn(point.x),
              y: fn(point.y)
            };
          };
        };
        var executeClip = function (frame, subject) {
          var result = getRect({
            top: Math.max(subject.top, frame.top),
            right: Math.min(subject.right, frame.right),
            bottom: Math.min(subject.bottom, frame.bottom),
            left: Math.max(subject.left, frame.left)
          });
          if (result.width <= 0 || result.height <= 0) {
            return null;
          }
          return result;
        };
        var offsetByPosition = function offsetByPosition(spacing, point) {
          return {
            top: spacing.top + point.y,
            left: spacing.left + point.x,
            bottom: spacing.bottom + point.y,
            right: spacing.right + point.x
          };
        };
        var getCorners = function getCorners(spacing) {
          return [{
            x: spacing.left,
            y: spacing.top
          }, {
            x: spacing.right,
            y: spacing.top
          }, {
            x: spacing.left,
            y: spacing.bottom
          }, {
            x: spacing.right,
            y: spacing.bottom
          }];
        };
        var noSpacing = {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        };
        var scroll = function scroll(target, frame) {
          if (!frame) {
            return target;
          }
          return offsetByPosition(target, frame.scroll.diff.displacement);
        };
        var increase = function increase(target, axis, withPlaceholder) {
          if (withPlaceholder && withPlaceholder.increasedBy) {
            var _extends2;
            return _extends({}, target, (_extends2 = {}, _extends2[axis.end] = target[axis.end] + withPlaceholder.increasedBy[axis.line], _extends2));
          }
          return target;
        };
        var clip = function clip(target, frame) {
          if (frame && frame.shouldClipSubject) {
            return executeClip(frame.pageMarginBox, target);
          }
          return getRect(target);
        };
        var getSubject = function (_ref) {
          var page = _ref.page,
            withPlaceholder = _ref.withPlaceholder,
            axis = _ref.axis,
            frame = _ref.frame;
          var scrolled = scroll(page.marginBox, frame);
          var increased = increase(scrolled, axis, withPlaceholder);
          var clipped = clip(increased, frame);
          return {
            page: page,
            withPlaceholder: withPlaceholder,
            active: clipped
          };
        };
        var scrollDroppable = function (droppable, newScroll) {
          !droppable.frame ? invariant(false) : void 0;
          var scrollable = droppable.frame;
          var scrollDiff = subtract(newScroll, scrollable.scroll.initial);
          var scrollDisplacement = negate(scrollDiff);
          var frame = _extends({}, scrollable, {
            scroll: {
              initial: scrollable.scroll.initial,
              current: newScroll,
              diff: {
                value: scrollDiff,
                displacement: scrollDisplacement
              },
              max: scrollable.scroll.max
            }
          });
          var subject = getSubject({
            page: droppable.subject.page,
            withPlaceholder: droppable.subject.withPlaceholder,
            axis: droppable.axis,
            frame: frame
          });
          var result = _extends({}, droppable, {
            frame: frame,
            subject: subject
          });
          return result;
        };
        function values$1(map) {
          if (Object.values) {
            return Object.values(map);
          }
          return Object.keys(map).map(function (key) {
            return map[key];
          });
        }
        function findIndex(list, predicate) {
          if (list.findIndex) {
            return list.findIndex(predicate);
          }
          for (var i = 0; i < list.length; i++) {
            if (predicate(list[i])) {
              return i;
            }
          }
          return -1;
        }
        function find(list, predicate) {
          if (list.find) {
            return list.find(predicate);
          }
          var index = findIndex(list, predicate);
          if (index !== -1) {
            return list[index];
          }
          return undefined;
        }
        function toArray$1(list) {
          return Array.prototype.slice.call(list);
        }
        var toDroppableMap = memoizeOne(function (droppables) {
          return droppables.reduce(function (previous, current) {
            previous[current.descriptor.id] = current;
            return previous;
          }, {});
        });
        var toDraggableMap = memoizeOne(function (draggables) {
          return draggables.reduce(function (previous, current) {
            previous[current.descriptor.id] = current;
            return previous;
          }, {});
        });
        var toDroppableList = memoizeOne(function (droppables) {
          return values$1(droppables);
        });
        var toDraggableList = memoizeOne(function (draggables) {
          return values$1(draggables);
        });
        var getDraggablesInsideDroppable = memoizeOne(function (droppableId, draggables) {
          var result = toDraggableList(draggables).filter(function (draggable) {
            return droppableId === draggable.descriptor.droppableId;
          }).sort(function (a, b) {
            return a.descriptor.index - b.descriptor.index;
          });
          return result;
        });
        function tryGetDestination(impact) {
          if (impact.at && impact.at.type === 'REORDER') {
            return impact.at.destination;
          }
          return null;
        }
        function tryGetCombine(impact) {
          if (impact.at && impact.at.type === 'COMBINE') {
            return impact.at.combine;
          }
          return null;
        }
        var removeDraggableFromList = memoizeOne(function (remove, list) {
          return list.filter(function (item) {
            return item.descriptor.id !== remove.descriptor.id;
          });
        });
        var moveToNextCombine = function (_ref) {
          var isMovingForward = _ref.isMovingForward,
            draggable = _ref.draggable,
            destination = _ref.destination,
            insideDestination = _ref.insideDestination,
            previousImpact = _ref.previousImpact;
          if (!destination.isCombineEnabled) {
            return null;
          }
          var location = tryGetDestination(previousImpact);
          if (!location) {
            return null;
          }
          function getImpact(target) {
            var at = {
              type: 'COMBINE',
              combine: {
                draggableId: target,
                droppableId: destination.descriptor.id
              }
            };
            return _extends({}, previousImpact, {
              at: at
            });
          }
          var all = previousImpact.displaced.all;
          var closestId = all.length ? all[0] : null;
          if (isMovingForward) {
            return closestId ? getImpact(closestId) : null;
          }
          var withoutDraggable = removeDraggableFromList(draggable, insideDestination);
          if (!closestId) {
            if (!withoutDraggable.length) {
              return null;
            }
            var last = withoutDraggable[withoutDraggable.length - 1];
            return getImpact(last.descriptor.id);
          }
          var indexOfClosest = findIndex(withoutDraggable, function (d) {
            return d.descriptor.id === closestId;
          });
          !(indexOfClosest !== -1) ? invariant(false) : void 0;
          var proposedIndex = indexOfClosest - 1;
          if (proposedIndex < 0) {
            return null;
          }
          var before = withoutDraggable[proposedIndex];
          return getImpact(before.descriptor.id);
        };
        var isHomeOf = function (draggable, destination) {
          return draggable.descriptor.droppableId === destination.descriptor.id;
        };
        var noDisplacedBy = {
          point: origin,
          value: 0
        };
        var emptyGroups = {
          invisible: {},
          visible: {},
          all: []
        };
        var noImpact = {
          displaced: emptyGroups,
          displacedBy: noDisplacedBy,
          at: null
        };
        var isWithin = function (lowerBound, upperBound) {
          return function (value) {
            return lowerBound <= value && value <= upperBound;
          };
        };
        var isPartiallyVisibleThroughFrame = function (frame) {
          var isWithinVertical = isWithin(frame.top, frame.bottom);
          var isWithinHorizontal = isWithin(frame.left, frame.right);
          return function (subject) {
            var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
            if (isContained) {
              return true;
            }
            var isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);
            var isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);
            var isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;
            if (isPartiallyContained) {
              return true;
            }
            var isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;
            var isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;
            var isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;
            if (isTargetBiggerThanFrame) {
              return true;
            }
            var isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;
            return isTargetBiggerOnOneAxis;
          };
        };
        var isTotallyVisibleThroughFrame = function (frame) {
          var isWithinVertical = isWithin(frame.top, frame.bottom);
          var isWithinHorizontal = isWithin(frame.left, frame.right);
          return function (subject) {
            var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
            return isContained;
          };
        };
        var vertical = {
          direction: 'vertical',
          line: 'y',
          crossAxisLine: 'x',
          start: 'top',
          end: 'bottom',
          size: 'height',
          crossAxisStart: 'left',
          crossAxisEnd: 'right',
          crossAxisSize: 'width'
        };
        var horizontal = {
          direction: 'horizontal',
          line: 'x',
          crossAxisLine: 'y',
          start: 'left',
          end: 'right',
          size: 'width',
          crossAxisStart: 'top',
          crossAxisEnd: 'bottom',
          crossAxisSize: 'height'
        };
        var isTotallyVisibleThroughFrameOnAxis = function (axis) {
          return function (frame) {
            var isWithinVertical = isWithin(frame.top, frame.bottom);
            var isWithinHorizontal = isWithin(frame.left, frame.right);
            return function (subject) {
              if (axis === vertical) {
                return isWithinVertical(subject.top) && isWithinVertical(subject.bottom);
              }
              return isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
            };
          };
        };
        var getDroppableDisplaced = function getDroppableDisplaced(target, destination) {
          var displacement = destination.frame ? destination.frame.scroll.diff.displacement : origin;
          return offsetByPosition(target, displacement);
        };
        var isVisibleInDroppable = function isVisibleInDroppable(target, destination, isVisibleThroughFrameFn) {
          if (!destination.subject.active) {
            return false;
          }
          return isVisibleThroughFrameFn(destination.subject.active)(target);
        };
        var isVisibleInViewport = function isVisibleInViewport(target, viewport, isVisibleThroughFrameFn) {
          return isVisibleThroughFrameFn(viewport)(target);
        };
        var isVisible = function isVisible(_ref) {
          var toBeDisplaced = _ref.target,
            destination = _ref.destination,
            viewport = _ref.viewport,
            withDroppableDisplacement = _ref.withDroppableDisplacement,
            isVisibleThroughFrameFn = _ref.isVisibleThroughFrameFn;
          var displacedTarget = withDroppableDisplacement ? getDroppableDisplaced(toBeDisplaced, destination) : toBeDisplaced;
          return isVisibleInDroppable(displacedTarget, destination, isVisibleThroughFrameFn) && isVisibleInViewport(displacedTarget, viewport, isVisibleThroughFrameFn);
        };
        var isPartiallyVisible = function isPartiallyVisible(args) {
          return isVisible(_extends({}, args, {
            isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame
          }));
        };
        var isTotallyVisible = function isTotallyVisible(args) {
          return isVisible(_extends({}, args, {
            isVisibleThroughFrameFn: isTotallyVisibleThroughFrame
          }));
        };
        var isTotallyVisibleOnAxis = function isTotallyVisibleOnAxis(args) {
          return isVisible(_extends({}, args, {
            isVisibleThroughFrameFn: isTotallyVisibleThroughFrameOnAxis(args.destination.axis)
          }));
        };
        var getShouldAnimate = function getShouldAnimate(id, last, forceShouldAnimate) {
          if (typeof forceShouldAnimate === 'boolean') {
            return forceShouldAnimate;
          }
          if (!last) {
            return true;
          }
          var invisible = last.invisible,
            visible = last.visible;
          if (invisible[id]) {
            return false;
          }
          var previous = visible[id];
          return previous ? previous.shouldAnimate : true;
        };
        function getTarget(draggable, displacedBy) {
          var marginBox = draggable.page.marginBox;
          var expandBy = {
            top: displacedBy.point.y,
            right: 0,
            bottom: 0,
            left: displacedBy.point.x
          };
          return getRect(expand(marginBox, expandBy));
        }
        function getDisplacementGroups(_ref) {
          var afterDragging = _ref.afterDragging,
            destination = _ref.destination,
            displacedBy = _ref.displacedBy,
            viewport = _ref.viewport,
            forceShouldAnimate = _ref.forceShouldAnimate,
            last = _ref.last;
          return afterDragging.reduce(function process(groups, draggable) {
            var target = getTarget(draggable, displacedBy);
            var id = draggable.descriptor.id;
            groups.all.push(id);
            var isVisible = isPartiallyVisible({
              target: target,
              destination: destination,
              viewport: viewport,
              withDroppableDisplacement: true
            });
            if (!isVisible) {
              groups.invisible[draggable.descriptor.id] = true;
              return groups;
            }
            var shouldAnimate = getShouldAnimate(id, last, forceShouldAnimate);
            var displacement = {
              draggableId: id,
              shouldAnimate: shouldAnimate
            };
            groups.visible[id] = displacement;
            return groups;
          }, {
            all: [],
            visible: {},
            invisible: {}
          });
        }
        function getIndexOfLastItem(draggables, options) {
          if (!draggables.length) {
            return 0;
          }
          var indexOfLastItem = draggables[draggables.length - 1].descriptor.index;
          return options.inHomeList ? indexOfLastItem : indexOfLastItem + 1;
        }
        function goAtEnd(_ref) {
          var insideDestination = _ref.insideDestination,
            inHomeList = _ref.inHomeList,
            displacedBy = _ref.displacedBy,
            destination = _ref.destination;
          var newIndex = getIndexOfLastItem(insideDestination, {
            inHomeList: inHomeList
          });
          return {
            displaced: emptyGroups,
            displacedBy: displacedBy,
            at: {
              type: 'REORDER',
              destination: {
                droppableId: destination.descriptor.id,
                index: newIndex
              }
            }
          };
        }
        function calculateReorderImpact(_ref2) {
          var draggable = _ref2.draggable,
            insideDestination = _ref2.insideDestination,
            destination = _ref2.destination,
            viewport = _ref2.viewport,
            displacedBy = _ref2.displacedBy,
            last = _ref2.last,
            index = _ref2.index,
            forceShouldAnimate = _ref2.forceShouldAnimate;
          var inHomeList = isHomeOf(draggable, destination);
          if (index == null) {
            return goAtEnd({
              insideDestination: insideDestination,
              inHomeList: inHomeList,
              displacedBy: displacedBy,
              destination: destination
            });
          }
          var match = find(insideDestination, function (item) {
            return item.descriptor.index === index;
          });
          if (!match) {
            return goAtEnd({
              insideDestination: insideDestination,
              inHomeList: inHomeList,
              displacedBy: displacedBy,
              destination: destination
            });
          }
          var withoutDragging = removeDraggableFromList(draggable, insideDestination);
          var sliceFrom = insideDestination.indexOf(match);
          var impacted = withoutDragging.slice(sliceFrom);
          var displaced = getDisplacementGroups({
            afterDragging: impacted,
            destination: destination,
            displacedBy: displacedBy,
            last: last,
            viewport: viewport.frame,
            forceShouldAnimate: forceShouldAnimate
          });
          return {
            displaced: displaced,
            displacedBy: displacedBy,
            at: {
              type: 'REORDER',
              destination: {
                droppableId: destination.descriptor.id,
                index: index
              }
            }
          };
        }
        function didStartAfterCritical(draggableId, afterCritical) {
          return Boolean(afterCritical.effected[draggableId]);
        }
        var fromCombine = function (_ref) {
          var isMovingForward = _ref.isMovingForward,
            destination = _ref.destination,
            draggables = _ref.draggables,
            combine = _ref.combine,
            afterCritical = _ref.afterCritical;
          if (!destination.isCombineEnabled) {
            return null;
          }
          var combineId = combine.draggableId;
          var combineWith = draggables[combineId];
          var combineWithIndex = combineWith.descriptor.index;
          var didCombineWithStartAfterCritical = didStartAfterCritical(combineId, afterCritical);
          if (didCombineWithStartAfterCritical) {
            if (isMovingForward) {
              return combineWithIndex;
            }
            return combineWithIndex - 1;
          }
          if (isMovingForward) {
            return combineWithIndex + 1;
          }
          return combineWithIndex;
        };
        var fromReorder = function (_ref) {
          var isMovingForward = _ref.isMovingForward,
            isInHomeList = _ref.isInHomeList,
            insideDestination = _ref.insideDestination,
            location = _ref.location;
          if (!insideDestination.length) {
            return null;
          }
          var currentIndex = location.index;
          var proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;
          var firstIndex = insideDestination[0].descriptor.index;
          var lastIndex = insideDestination[insideDestination.length - 1].descriptor.index;
          var upperBound = isInHomeList ? lastIndex : lastIndex + 1;
          if (proposedIndex < firstIndex) {
            return null;
          }
          if (proposedIndex > upperBound) {
            return null;
          }
          return proposedIndex;
        };
        var moveToNextIndex = function (_ref) {
          var isMovingForward = _ref.isMovingForward,
            isInHomeList = _ref.isInHomeList,
            draggable = _ref.draggable,
            draggables = _ref.draggables,
            destination = _ref.destination,
            insideDestination = _ref.insideDestination,
            previousImpact = _ref.previousImpact,
            viewport = _ref.viewport,
            afterCritical = _ref.afterCritical;
          var wasAt = previousImpact.at;
          !wasAt ? invariant(false) : void 0;
          if (wasAt.type === 'REORDER') {
            var _newIndex = fromReorder({
              isMovingForward: isMovingForward,
              isInHomeList: isInHomeList,
              location: wasAt.destination,
              insideDestination: insideDestination
            });
            if (_newIndex == null) {
              return null;
            }
            return calculateReorderImpact({
              draggable: draggable,
              insideDestination: insideDestination,
              destination: destination,
              viewport: viewport,
              last: previousImpact.displaced,
              displacedBy: previousImpact.displacedBy,
              index: _newIndex
            });
          }
          var newIndex = fromCombine({
            isMovingForward: isMovingForward,
            destination: destination,
            displaced: previousImpact.displaced,
            draggables: draggables,
            combine: wasAt.combine,
            afterCritical: afterCritical
          });
          if (newIndex == null) {
            return null;
          }
          return calculateReorderImpact({
            draggable: draggable,
            insideDestination: insideDestination,
            destination: destination,
            viewport: viewport,
            last: previousImpact.displaced,
            displacedBy: previousImpact.displacedBy,
            index: newIndex
          });
        };
        var getCombinedItemDisplacement = function (_ref) {
          var displaced = _ref.displaced,
            afterCritical = _ref.afterCritical,
            combineWith = _ref.combineWith,
            displacedBy = _ref.displacedBy;
          var isDisplaced = Boolean(displaced.visible[combineWith] || displaced.invisible[combineWith]);
          if (didStartAfterCritical(combineWith, afterCritical)) {
            return isDisplaced ? origin : negate(displacedBy.point);
          }
          return isDisplaced ? displacedBy.point : origin;
        };
        var whenCombining = function (_ref) {
          var afterCritical = _ref.afterCritical,
            impact = _ref.impact,
            draggables = _ref.draggables;
          var combine = tryGetCombine(impact);
          !combine ? invariant(false) : void 0;
          var combineWith = combine.draggableId;
          var center = draggables[combineWith].page.borderBox.center;
          var displaceBy = getCombinedItemDisplacement({
            displaced: impact.displaced,
            afterCritical: afterCritical,
            combineWith: combineWith,
            displacedBy: impact.displacedBy
          });
          return add(center, displaceBy);
        };
        var distanceFromStartToBorderBoxCenter = function distanceFromStartToBorderBoxCenter(axis, box) {
          return box.margin[axis.start] + box.borderBox[axis.size] / 2;
        };
        var distanceFromEndToBorderBoxCenter = function distanceFromEndToBorderBoxCenter(axis, box) {
          return box.margin[axis.end] + box.borderBox[axis.size] / 2;
        };
        var getCrossAxisBorderBoxCenter = function getCrossAxisBorderBoxCenter(axis, target, isMoving) {
          return target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;
        };
        var goAfter = function goAfter(_ref) {
          var axis = _ref.axis,
            moveRelativeTo = _ref.moveRelativeTo,
            isMoving = _ref.isMoving;
          return patch(axis.line, moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
        };
        var goBefore = function goBefore(_ref2) {
          var axis = _ref2.axis,
            moveRelativeTo = _ref2.moveRelativeTo,
            isMoving = _ref2.isMoving;
          return patch(axis.line, moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
        };
        var goIntoStart = function goIntoStart(_ref3) {
          var axis = _ref3.axis,
            moveInto = _ref3.moveInto,
            isMoving = _ref3.isMoving;
          return patch(axis.line, moveInto.contentBox[axis.start] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveInto.contentBox, isMoving));
        };
        var whenReordering = function (_ref) {
          var impact = _ref.impact,
            draggable = _ref.draggable,
            draggables = _ref.draggables,
            droppable = _ref.droppable,
            afterCritical = _ref.afterCritical;
          var insideDestination = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);
          var draggablePage = draggable.page;
          var axis = droppable.axis;
          if (!insideDestination.length) {
            return goIntoStart({
              axis: axis,
              moveInto: droppable.page,
              isMoving: draggablePage
            });
          }
          var displaced = impact.displaced,
            displacedBy = impact.displacedBy;
          var closestAfter = displaced.all[0];
          if (closestAfter) {
            var closest = draggables[closestAfter];
            if (didStartAfterCritical(closestAfter, afterCritical)) {
              return goBefore({
                axis: axis,
                moveRelativeTo: closest.page,
                isMoving: draggablePage
              });
            }
            var withDisplacement = offset(closest.page, displacedBy.point);
            return goBefore({
              axis: axis,
              moveRelativeTo: withDisplacement,
              isMoving: draggablePage
            });
          }
          var last = insideDestination[insideDestination.length - 1];
          if (last.descriptor.id === draggable.descriptor.id) {
            return draggablePage.borderBox.center;
          }
          if (didStartAfterCritical(last.descriptor.id, afterCritical)) {
            var page = offset(last.page, negate(afterCritical.displacedBy.point));
            return goAfter({
              axis: axis,
              moveRelativeTo: page,
              isMoving: draggablePage
            });
          }
          return goAfter({
            axis: axis,
            moveRelativeTo: last.page,
            isMoving: draggablePage
          });
        };
        var withDroppableDisplacement = function (droppable, point) {
          var frame = droppable.frame;
          if (!frame) {
            return point;
          }
          return add(point, frame.scroll.diff.displacement);
        };
        var getResultWithoutDroppableDisplacement = function getResultWithoutDroppableDisplacement(_ref) {
          var impact = _ref.impact,
            draggable = _ref.draggable,
            droppable = _ref.droppable,
            draggables = _ref.draggables,
            afterCritical = _ref.afterCritical;
          var original = draggable.page.borderBox.center;
          var at = impact.at;
          if (!droppable) {
            return original;
          }
          if (!at) {
            return original;
          }
          if (at.type === 'REORDER') {
            return whenReordering({
              impact: impact,
              draggable: draggable,
              draggables: draggables,
              droppable: droppable,
              afterCritical: afterCritical
            });
          }
          return whenCombining({
            impact: impact,
            draggables: draggables,
            afterCritical: afterCritical
          });
        };
        var getPageBorderBoxCenterFromImpact = function (args) {
          var withoutDisplacement = getResultWithoutDroppableDisplacement(args);
          var droppable = args.droppable;
          var withDisplacement = droppable ? withDroppableDisplacement(droppable, withoutDisplacement) : withoutDisplacement;
          return withDisplacement;
        };
        var scrollViewport = function (viewport, newScroll) {
          var diff = subtract(newScroll, viewport.scroll.initial);
          var displacement = negate(diff);
          var frame = getRect({
            top: newScroll.y,
            bottom: newScroll.y + viewport.frame.height,
            left: newScroll.x,
            right: newScroll.x + viewport.frame.width
          });
          var updated = {
            frame: frame,
            scroll: {
              initial: viewport.scroll.initial,
              max: viewport.scroll.max,
              current: newScroll,
              diff: {
                value: diff,
                displacement: displacement
              }
            }
          };
          return updated;
        };
        function getDraggables(ids, draggables) {
          return ids.map(function (id) {
            return draggables[id];
          });
        }
        function tryGetVisible(id, groups) {
          for (var i = 0; i < groups.length; i++) {
            var displacement = groups[i].visible[id];
            if (displacement) {
              return displacement;
            }
          }
          return null;
        }
        var speculativelyIncrease = function (_ref) {
          var impact = _ref.impact,
            viewport = _ref.viewport,
            destination = _ref.destination,
            draggables = _ref.draggables,
            maxScrollChange = _ref.maxScrollChange;
          var scrolledViewport = scrollViewport(viewport, add(viewport.scroll.current, maxScrollChange));
          var scrolledDroppable = destination.frame ? scrollDroppable(destination, add(destination.frame.scroll.current, maxScrollChange)) : destination;
          var last = impact.displaced;
          var withViewportScroll = getDisplacementGroups({
            afterDragging: getDraggables(last.all, draggables),
            destination: destination,
            displacedBy: impact.displacedBy,
            viewport: scrolledViewport.frame,
            last: last,
            forceShouldAnimate: false
          });
          var withDroppableScroll = getDisplacementGroups({
            afterDragging: getDraggables(last.all, draggables),
            destination: scrolledDroppable,
            displacedBy: impact.displacedBy,
            viewport: viewport.frame,
            last: last,
            forceShouldAnimate: false
          });
          var invisible = {};
          var visible = {};
          var groups = [last, withViewportScroll, withDroppableScroll];
          last.all.forEach(function (id) {
            var displacement = tryGetVisible(id, groups);
            if (displacement) {
              visible[id] = displacement;
              return;
            }
            invisible[id] = true;
          });
          var newImpact = _extends({}, impact, {
            displaced: {
              all: last.all,
              invisible: invisible,
              visible: visible
            }
          });
          return newImpact;
        };
        var withViewportDisplacement = function (viewport, point) {
          return add(viewport.scroll.diff.displacement, point);
        };
        var getClientFromPageBorderBoxCenter = function (_ref) {
          var pageBorderBoxCenter = _ref.pageBorderBoxCenter,
            draggable = _ref.draggable,
            viewport = _ref.viewport;
          var withoutPageScrollChange = withViewportDisplacement(viewport, pageBorderBoxCenter);
          var offset = subtract(withoutPageScrollChange, draggable.page.borderBox.center);
          return add(draggable.client.borderBox.center, offset);
        };
        var isTotallyVisibleInNewLocation = function (_ref) {
          var draggable = _ref.draggable,
            destination = _ref.destination,
            newPageBorderBoxCenter = _ref.newPageBorderBoxCenter,
            viewport = _ref.viewport,
            withDroppableDisplacement = _ref.withDroppableDisplacement,
            _ref$onlyOnMainAxis = _ref.onlyOnMainAxis,
            onlyOnMainAxis = _ref$onlyOnMainAxis === void 0 ? false : _ref$onlyOnMainAxis;
          var changeNeeded = subtract(newPageBorderBoxCenter, draggable.page.borderBox.center);
          var shifted = offsetByPosition(draggable.page.borderBox, changeNeeded);
          var args = {
            target: shifted,
            destination: destination,
            withDroppableDisplacement: withDroppableDisplacement,
            viewport: viewport
          };
          return onlyOnMainAxis ? isTotallyVisibleOnAxis(args) : isTotallyVisible(args);
        };
        var moveToNextPlace = function (_ref) {
          var isMovingForward = _ref.isMovingForward,
            draggable = _ref.draggable,
            destination = _ref.destination,
            draggables = _ref.draggables,
            previousImpact = _ref.previousImpact,
            viewport = _ref.viewport,
            previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter,
            previousClientSelection = _ref.previousClientSelection,
            afterCritical = _ref.afterCritical;
          if (!destination.isEnabled) {
            return null;
          }
          var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
          var isInHomeList = isHomeOf(draggable, destination);
          var impact = moveToNextCombine({
            isMovingForward: isMovingForward,
            draggable: draggable,
            destination: destination,
            insideDestination: insideDestination,
            previousImpact: previousImpact
          }) || moveToNextIndex({
            isMovingForward: isMovingForward,
            isInHomeList: isInHomeList,
            draggable: draggable,
            draggables: draggables,
            destination: destination,
            insideDestination: insideDestination,
            previousImpact: previousImpact,
            viewport: viewport,
            afterCritical: afterCritical
          });
          if (!impact) {
            return null;
          }
          var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
            impact: impact,
            draggable: draggable,
            droppable: destination,
            draggables: draggables,
            afterCritical: afterCritical
          });
          var isVisibleInNewLocation = isTotallyVisibleInNewLocation({
            draggable: draggable,
            destination: destination,
            newPageBorderBoxCenter: pageBorderBoxCenter,
            viewport: viewport.frame,
            withDroppableDisplacement: false,
            onlyOnMainAxis: true
          });
          if (isVisibleInNewLocation) {
            var clientSelection = getClientFromPageBorderBoxCenter({
              pageBorderBoxCenter: pageBorderBoxCenter,
              draggable: draggable,
              viewport: viewport
            });
            return {
              clientSelection: clientSelection,
              impact: impact,
              scrollJumpRequest: null
            };
          }
          var distance = subtract(pageBorderBoxCenter, previousPageBorderBoxCenter);
          var cautious = speculativelyIncrease({
            impact: impact,
            viewport: viewport,
            destination: destination,
            draggables: draggables,
            maxScrollChange: distance
          });
          return {
            clientSelection: previousClientSelection,
            impact: cautious,
            scrollJumpRequest: distance
          };
        };
        var getKnownActive = function getKnownActive(droppable) {
          var rect = droppable.subject.active;
          !rect ? invariant(false) : void 0;
          return rect;
        };
        var getBestCrossAxisDroppable = function (_ref) {
          var isMovingForward = _ref.isMovingForward,
            pageBorderBoxCenter = _ref.pageBorderBoxCenter,
            source = _ref.source,
            droppables = _ref.droppables,
            viewport = _ref.viewport;
          var active = source.subject.active;
          if (!active) {
            return null;
          }
          var axis = source.axis;
          var isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);
          var candidates = toDroppableList(droppables).filter(function (droppable) {
            return droppable !== source;
          }).filter(function (droppable) {
            return droppable.isEnabled;
          }).filter(function (droppable) {
            return Boolean(droppable.subject.active);
          }).filter(function (droppable) {
            return isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable));
          }).filter(function (droppable) {
            var activeOfTarget = getKnownActive(droppable);
            if (isMovingForward) {
              return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];
            }
            return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];
          }).filter(function (droppable) {
            var activeOfTarget = getKnownActive(droppable);
            var isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);
            return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);
          }).sort(function (a, b) {
            var first = getKnownActive(a)[axis.crossAxisStart];
            var second = getKnownActive(b)[axis.crossAxisStart];
            if (isMovingForward) {
              return first - second;
            }
            return second - first;
          }).filter(function (droppable, index, array) {
            return getKnownActive(droppable)[axis.crossAxisStart] === getKnownActive(array[0])[axis.crossAxisStart];
          });
          if (!candidates.length) {
            return null;
          }
          if (candidates.length === 1) {
            return candidates[0];
          }
          var contains = candidates.filter(function (droppable) {
            var isWithinDroppable = isWithin(getKnownActive(droppable)[axis.start], getKnownActive(droppable)[axis.end]);
            return isWithinDroppable(pageBorderBoxCenter[axis.line]);
          });
          if (contains.length === 1) {
            return contains[0];
          }
          if (contains.length > 1) {
            return contains.sort(function (a, b) {
              return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];
            })[0];
          }
          return candidates.sort(function (a, b) {
            var first = closest(pageBorderBoxCenter, getCorners(getKnownActive(a)));
            var second = closest(pageBorderBoxCenter, getCorners(getKnownActive(b)));
            if (first !== second) {
              return first - second;
            }
            return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];
          })[0];
        };
        var getCurrentPageBorderBoxCenter = function getCurrentPageBorderBoxCenter(draggable, afterCritical) {
          var original = draggable.page.borderBox.center;
          return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? subtract(original, afterCritical.displacedBy.point) : original;
        };
        var getCurrentPageBorderBox = function getCurrentPageBorderBox(draggable, afterCritical) {
          var original = draggable.page.borderBox;
          return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? offsetByPosition(original, negate(afterCritical.displacedBy.point)) : original;
        };
        var getClosestDraggable = function (_ref) {
          var pageBorderBoxCenter = _ref.pageBorderBoxCenter,
            viewport = _ref.viewport,
            destination = _ref.destination,
            insideDestination = _ref.insideDestination,
            afterCritical = _ref.afterCritical;
          var sorted = insideDestination.filter(function (draggable) {
            return isTotallyVisible({
              target: getCurrentPageBorderBox(draggable, afterCritical),
              destination: destination,
              viewport: viewport.frame,
              withDroppableDisplacement: true
            });
          }).sort(function (a, b) {
            var distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a, afterCritical)));
            var distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b, afterCritical)));
            if (distanceToA < distanceToB) {
              return -1;
            }
            if (distanceToB < distanceToA) {
              return 1;
            }
            return a.descriptor.index - b.descriptor.index;
          });
          return sorted[0] || null;
        };
        var getDisplacedBy = memoizeOne(function getDisplacedBy(axis, displaceBy) {
          var displacement = displaceBy[axis.line];
          return {
            value: displacement,
            point: patch(axis.line, displacement)
          };
        });
        var getRequiredGrowthForPlaceholder = function getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables) {
          var axis = droppable.axis;
          if (droppable.descriptor.mode === 'virtual') {
            return patch(axis.line, placeholderSize[axis.line]);
          }
          var availableSpace = droppable.subject.page.contentBox[axis.size];
          var insideDroppable = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);
          var spaceUsed = insideDroppable.reduce(function (sum, dimension) {
            return sum + dimension.client.marginBox[axis.size];
          }, 0);
          var requiredSpace = spaceUsed + placeholderSize[axis.line];
          var needsToGrowBy = requiredSpace - availableSpace;
          if (needsToGrowBy <= 0) {
            return null;
          }
          return patch(axis.line, needsToGrowBy);
        };
        var withMaxScroll = function withMaxScroll(frame, max) {
          return _extends({}, frame, {
            scroll: _extends({}, frame.scroll, {
              max: max
            })
          });
        };
        var addPlaceholder = function addPlaceholder(droppable, draggable, draggables) {
          var frame = droppable.frame;
          !!isHomeOf(draggable, droppable) ? invariant(false) : void 0;
          !!droppable.subject.withPlaceholder ? invariant(false) : void 0;
          var placeholderSize = getDisplacedBy(droppable.axis, draggable.displaceBy).point;
          var requiredGrowth = getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables);
          var added = {
            placeholderSize: placeholderSize,
            increasedBy: requiredGrowth,
            oldFrameMaxScroll: droppable.frame ? droppable.frame.scroll.max : null
          };
          if (!frame) {
            var _subject = getSubject({
              page: droppable.subject.page,
              withPlaceholder: added,
              axis: droppable.axis,
              frame: droppable.frame
            });
            return _extends({}, droppable, {
              subject: _subject
            });
          }
          var maxScroll = requiredGrowth ? add(frame.scroll.max, requiredGrowth) : frame.scroll.max;
          var newFrame = withMaxScroll(frame, maxScroll);
          var subject = getSubject({
            page: droppable.subject.page,
            withPlaceholder: added,
            axis: droppable.axis,
            frame: newFrame
          });
          return _extends({}, droppable, {
            subject: subject,
            frame: newFrame
          });
        };
        var removePlaceholder = function removePlaceholder(droppable) {
          var added = droppable.subject.withPlaceholder;
          !added ? invariant(false) : void 0;
          var frame = droppable.frame;
          if (!frame) {
            var _subject2 = getSubject({
              page: droppable.subject.page,
              axis: droppable.axis,
              frame: null,
              withPlaceholder: null
            });
            return _extends({}, droppable, {
              subject: _subject2
            });
          }
          var oldMaxScroll = added.oldFrameMaxScroll;
          !oldMaxScroll ? invariant(false) : void 0;
          var newFrame = withMaxScroll(frame, oldMaxScroll);
          var subject = getSubject({
            page: droppable.subject.page,
            axis: droppable.axis,
            frame: newFrame,
            withPlaceholder: null
          });
          return _extends({}, droppable, {
            subject: subject,
            frame: newFrame
          });
        };
        var moveToNewDroppable = function (_ref) {
          var previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter,
            moveRelativeTo = _ref.moveRelativeTo,
            insideDestination = _ref.insideDestination,
            draggable = _ref.draggable,
            draggables = _ref.draggables,
            destination = _ref.destination,
            viewport = _ref.viewport,
            afterCritical = _ref.afterCritical;
          if (!moveRelativeTo) {
            if (insideDestination.length) {
              return null;
            }
            var proposed = {
              displaced: emptyGroups,
              displacedBy: noDisplacedBy,
              at: {
                type: 'REORDER',
                destination: {
                  droppableId: destination.descriptor.id,
                  index: 0
                }
              }
            };
            var proposedPageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
              impact: proposed,
              draggable: draggable,
              droppable: destination,
              draggables: draggables,
              afterCritical: afterCritical
            });
            var withPlaceholder = isHomeOf(draggable, destination) ? destination : addPlaceholder(destination, draggable, draggables);
            var isVisibleInNewLocation = isTotallyVisibleInNewLocation({
              draggable: draggable,
              destination: withPlaceholder,
              newPageBorderBoxCenter: proposedPageBorderBoxCenter,
              viewport: viewport.frame,
              withDroppableDisplacement: false,
              onlyOnMainAxis: true
            });
            return isVisibleInNewLocation ? proposed : null;
          }
          var isGoingBeforeTarget = Boolean(previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);
          var proposedIndex = function () {
            var relativeTo = moveRelativeTo.descriptor.index;
            if (moveRelativeTo.descriptor.id === draggable.descriptor.id) {
              return relativeTo;
            }
            if (isGoingBeforeTarget) {
              return relativeTo;
            }
            return relativeTo + 1;
          }();
          var displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);
          return calculateReorderImpact({
            draggable: draggable,
            insideDestination: insideDestination,
            destination: destination,
            viewport: viewport,
            displacedBy: displacedBy,
            last: emptyGroups,
            index: proposedIndex
          });
        };
        var moveCrossAxis = function (_ref) {
          var isMovingForward = _ref.isMovingForward,
            previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter,
            draggable = _ref.draggable,
            isOver = _ref.isOver,
            draggables = _ref.draggables,
            droppables = _ref.droppables,
            viewport = _ref.viewport,
            afterCritical = _ref.afterCritical;
          var destination = getBestCrossAxisDroppable({
            isMovingForward: isMovingForward,
            pageBorderBoxCenter: previousPageBorderBoxCenter,
            source: isOver,
            droppables: droppables,
            viewport: viewport
          });
          if (!destination) {
            return null;
          }
          var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
          var moveRelativeTo = getClosestDraggable({
            pageBorderBoxCenter: previousPageBorderBoxCenter,
            viewport: viewport,
            destination: destination,
            insideDestination: insideDestination,
            afterCritical: afterCritical
          });
          var impact = moveToNewDroppable({
            previousPageBorderBoxCenter: previousPageBorderBoxCenter,
            destination: destination,
            draggable: draggable,
            draggables: draggables,
            moveRelativeTo: moveRelativeTo,
            insideDestination: insideDestination,
            viewport: viewport,
            afterCritical: afterCritical
          });
          if (!impact) {
            return null;
          }
          var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
            impact: impact,
            draggable: draggable,
            droppable: destination,
            draggables: draggables,
            afterCritical: afterCritical
          });
          var clientSelection = getClientFromPageBorderBoxCenter({
            pageBorderBoxCenter: pageBorderBoxCenter,
            draggable: draggable,
            viewport: viewport
          });
          return {
            clientSelection: clientSelection,
            impact: impact,
            scrollJumpRequest: null
          };
        };
        var whatIsDraggedOver = function (impact) {
          var at = impact.at;
          if (!at) {
            return null;
          }
          if (at.type === 'REORDER') {
            return at.destination.droppableId;
          }
          return at.combine.droppableId;
        };
        var getDroppableOver = function getDroppableOver(impact, droppables) {
          var id = whatIsDraggedOver(impact);
          return id ? droppables[id] : null;
        };
        var moveInDirection = function (_ref) {
          var state = _ref.state,
            type = _ref.type;
          var isActuallyOver = getDroppableOver(state.impact, state.dimensions.droppables);
          var isMainAxisMovementAllowed = Boolean(isActuallyOver);
          var home = state.dimensions.droppables[state.critical.droppable.id];
          var isOver = isActuallyOver || home;
          var direction = isOver.axis.direction;
          var isMovingOnMainAxis = direction === 'vertical' && (type === 'MOVE_UP' || type === 'MOVE_DOWN') || direction === 'horizontal' && (type === 'MOVE_LEFT' || type === 'MOVE_RIGHT');
          if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {
            return null;
          }
          var isMovingForward = type === 'MOVE_DOWN' || type === 'MOVE_RIGHT';
          var draggable = state.dimensions.draggables[state.critical.draggable.id];
          var previousPageBorderBoxCenter = state.current.page.borderBoxCenter;
          var _state$dimensions = state.dimensions,
            draggables = _state$dimensions.draggables,
            droppables = _state$dimensions.droppables;
          return isMovingOnMainAxis ? moveToNextPlace({
            isMovingForward: isMovingForward,
            previousPageBorderBoxCenter: previousPageBorderBoxCenter,
            draggable: draggable,
            destination: isOver,
            draggables: draggables,
            viewport: state.viewport,
            previousClientSelection: state.current.client.selection,
            previousImpact: state.impact,
            afterCritical: state.afterCritical
          }) : moveCrossAxis({
            isMovingForward: isMovingForward,
            previousPageBorderBoxCenter: previousPageBorderBoxCenter,
            draggable: draggable,
            isOver: isOver,
            draggables: draggables,
            droppables: droppables,
            viewport: state.viewport,
            afterCritical: state.afterCritical
          });
        };
        function isMovementAllowed(state) {
          return state.phase === 'DRAGGING' || state.phase === 'COLLECTING';
        }
        function isPositionInFrame(frame) {
          var isWithinVertical = isWithin(frame.top, frame.bottom);
          var isWithinHorizontal = isWithin(frame.left, frame.right);
          return function run(point) {
            return isWithinVertical(point.y) && isWithinHorizontal(point.x);
          };
        }
        function getHasOverlap(first, second) {
          return first.left < second.right && first.right > second.left && first.top < second.bottom && first.bottom > second.top;
        }
        function getFurthestAway(_ref) {
          var pageBorderBox = _ref.pageBorderBox,
            draggable = _ref.draggable,
            candidates = _ref.candidates;
          var startCenter = draggable.page.borderBox.center;
          var sorted = candidates.map(function (candidate) {
            var axis = candidate.axis;
            var target = patch(candidate.axis.line, pageBorderBox.center[axis.line], candidate.page.borderBox.center[axis.crossAxisLine]);
            return {
              id: candidate.descriptor.id,
              distance: distance(startCenter, target)
            };
          }).sort(function (a, b) {
            return b.distance - a.distance;
          });
          return sorted[0] ? sorted[0].id : null;
        }
        function getDroppableOver$1(_ref2) {
          var pageBorderBox = _ref2.pageBorderBox,
            draggable = _ref2.draggable,
            droppables = _ref2.droppables;
          var candidates = toDroppableList(droppables).filter(function (item) {
            if (!item.isEnabled) {
              return false;
            }
            var active = item.subject.active;
            if (!active) {
              return false;
            }
            if (!getHasOverlap(pageBorderBox, active)) {
              return false;
            }
            if (isPositionInFrame(active)(pageBorderBox.center)) {
              return true;
            }
            var axis = item.axis;
            var childCenter = active.center[axis.crossAxisLine];
            var crossAxisStart = pageBorderBox[axis.crossAxisStart];
            var crossAxisEnd = pageBorderBox[axis.crossAxisEnd];
            var isContained = isWithin(active[axis.crossAxisStart], active[axis.crossAxisEnd]);
            var isStartContained = isContained(crossAxisStart);
            var isEndContained = isContained(crossAxisEnd);
            if (!isStartContained && !isEndContained) {
              return true;
            }
            if (isStartContained) {
              return crossAxisStart < childCenter;
            }
            return crossAxisEnd > childCenter;
          });
          if (!candidates.length) {
            return null;
          }
          if (candidates.length === 1) {
            return candidates[0].descriptor.id;
          }
          return getFurthestAway({
            pageBorderBox: pageBorderBox,
            draggable: draggable,
            candidates: candidates
          });
        }
        var offsetRectByPosition = function offsetRectByPosition(rect, point) {
          return getRect(offsetByPosition(rect, point));
        };
        var withDroppableScroll = function (droppable, area) {
          var frame = droppable.frame;
          if (!frame) {
            return area;
          }
          return offsetRectByPosition(area, frame.scroll.diff.value);
        };
        function getIsDisplaced(_ref) {
          var displaced = _ref.displaced,
            id = _ref.id;
          return Boolean(displaced.visible[id] || displaced.invisible[id]);
        }
        function atIndex(_ref) {
          var draggable = _ref.draggable,
            closest = _ref.closest,
            inHomeList = _ref.inHomeList;
          if (!closest) {
            return null;
          }
          if (!inHomeList) {
            return closest.descriptor.index;
          }
          if (closest.descriptor.index > draggable.descriptor.index) {
            return closest.descriptor.index - 1;
          }
          return closest.descriptor.index;
        }
        var getReorderImpact = function (_ref2) {
          var targetRect = _ref2.pageBorderBoxWithDroppableScroll,
            draggable = _ref2.draggable,
            destination = _ref2.destination,
            insideDestination = _ref2.insideDestination,
            last = _ref2.last,
            viewport = _ref2.viewport,
            afterCritical = _ref2.afterCritical;
          var axis = destination.axis;
          var displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);
          var displacement = displacedBy.value;
          var targetStart = targetRect[axis.start];
          var targetEnd = targetRect[axis.end];
          var withoutDragging = removeDraggableFromList(draggable, insideDestination);
          var closest = find(withoutDragging, function (child) {
            var id = child.descriptor.id;
            var childCenter = child.page.borderBox.center[axis.line];
            var didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);
            var isDisplaced = getIsDisplaced({
              displaced: last,
              id: id
            });
            if (didStartAfterCritical$1) {
              if (isDisplaced) {
                return targetEnd <= childCenter;
              }
              return targetStart < childCenter - displacement;
            }
            if (isDisplaced) {
              return targetEnd <= childCenter + displacement;
            }
            return targetStart < childCenter;
          });
          var newIndex = atIndex({
            draggable: draggable,
            closest: closest,
            inHomeList: isHomeOf(draggable, destination)
          });
          return calculateReorderImpact({
            draggable: draggable,
            insideDestination: insideDestination,
            destination: destination,
            viewport: viewport,
            last: last,
            displacedBy: displacedBy,
            index: newIndex
          });
        };
        var combineThresholdDivisor = 4;
        var getCombineImpact = function (_ref) {
          var draggable = _ref.draggable,
            targetRect = _ref.pageBorderBoxWithDroppableScroll,
            previousImpact = _ref.previousImpact,
            destination = _ref.destination,
            insideDestination = _ref.insideDestination,
            afterCritical = _ref.afterCritical;
          if (!destination.isCombineEnabled) {
            return null;
          }
          var axis = destination.axis;
          var displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);
          var displacement = displacedBy.value;
          var targetStart = targetRect[axis.start];
          var targetEnd = targetRect[axis.end];
          var withoutDragging = removeDraggableFromList(draggable, insideDestination);
          var combineWith = find(withoutDragging, function (child) {
            var id = child.descriptor.id;
            var childRect = child.page.borderBox;
            var childSize = childRect[axis.size];
            var threshold = childSize / combineThresholdDivisor;
            var didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);
            var isDisplaced = getIsDisplaced({
              displaced: previousImpact.displaced,
              id: id
            });
            if (didStartAfterCritical$1) {
              if (isDisplaced) {
                return targetEnd > childRect[axis.start] + threshold && targetEnd < childRect[axis.end] - threshold;
              }
              return targetStart > childRect[axis.start] - displacement + threshold && targetStart < childRect[axis.end] - displacement - threshold;
            }
            if (isDisplaced) {
              return targetEnd > childRect[axis.start] + displacement + threshold && targetEnd < childRect[axis.end] + displacement - threshold;
            }
            return targetStart > childRect[axis.start] + threshold && targetStart < childRect[axis.end] - threshold;
          });
          if (!combineWith) {
            return null;
          }
          var impact = {
            displacedBy: displacedBy,
            displaced: previousImpact.displaced,
            at: {
              type: 'COMBINE',
              combine: {
                draggableId: combineWith.descriptor.id,
                droppableId: destination.descriptor.id
              }
            }
          };
          return impact;
        };
        var getDragImpact = function (_ref) {
          var pageOffset = _ref.pageOffset,
            draggable = _ref.draggable,
            draggables = _ref.draggables,
            droppables = _ref.droppables,
            previousImpact = _ref.previousImpact,
            viewport = _ref.viewport,
            afterCritical = _ref.afterCritical;
          var pageBorderBox = offsetRectByPosition(draggable.page.borderBox, pageOffset);
          var destinationId = getDroppableOver$1({
            pageBorderBox: pageBorderBox,
            draggable: draggable,
            droppables: droppables
          });
          if (!destinationId) {
            return noImpact;
          }
          var destination = droppables[destinationId];
          var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
          var pageBorderBoxWithDroppableScroll = withDroppableScroll(destination, pageBorderBox);
          return getCombineImpact({
            pageBorderBoxWithDroppableScroll: pageBorderBoxWithDroppableScroll,
            draggable: draggable,
            previousImpact: previousImpact,
            destination: destination,
            insideDestination: insideDestination,
            afterCritical: afterCritical
          }) || getReorderImpact({
            pageBorderBoxWithDroppableScroll: pageBorderBoxWithDroppableScroll,
            draggable: draggable,
            destination: destination,
            insideDestination: insideDestination,
            last: previousImpact.displaced,
            viewport: viewport,
            afterCritical: afterCritical
          });
        };
        var patchDroppableMap = function (droppables, updated) {
          var _extends2;
          return _extends({}, droppables, (_extends2 = {}, _extends2[updated.descriptor.id] = updated, _extends2));
        };
        var clearUnusedPlaceholder = function clearUnusedPlaceholder(_ref) {
          var previousImpact = _ref.previousImpact,
            impact = _ref.impact,
            droppables = _ref.droppables;
          var last = whatIsDraggedOver(previousImpact);
          var now = whatIsDraggedOver(impact);
          if (!last) {
            return droppables;
          }
          if (last === now) {
            return droppables;
          }
          var lastDroppable = droppables[last];
          if (!lastDroppable.subject.withPlaceholder) {
            return droppables;
          }
          var updated = removePlaceholder(lastDroppable);
          return patchDroppableMap(droppables, updated);
        };
        var recomputePlaceholders = function (_ref2) {
          var draggable = _ref2.draggable,
            draggables = _ref2.draggables,
            droppables = _ref2.droppables,
            previousImpact = _ref2.previousImpact,
            impact = _ref2.impact;
          var cleaned = clearUnusedPlaceholder({
            previousImpact: previousImpact,
            impact: impact,
            droppables: droppables
          });
          var isOver = whatIsDraggedOver(impact);
          if (!isOver) {
            return cleaned;
          }
          var droppable = droppables[isOver];
          if (isHomeOf(draggable, droppable)) {
            return cleaned;
          }
          if (droppable.subject.withPlaceholder) {
            return cleaned;
          }
          var patched = addPlaceholder(droppable, draggable, draggables);
          return patchDroppableMap(cleaned, patched);
        };
        var update = function (_ref) {
          var state = _ref.state,
            forcedClientSelection = _ref.clientSelection,
            forcedDimensions = _ref.dimensions,
            forcedViewport = _ref.viewport,
            forcedImpact = _ref.impact,
            scrollJumpRequest = _ref.scrollJumpRequest;
          var viewport = forcedViewport || state.viewport;
          var dimensions = forcedDimensions || state.dimensions;
          var clientSelection = forcedClientSelection || state.current.client.selection;
          var offset = subtract(clientSelection, state.initial.client.selection);
          var client = {
            offset: offset,
            selection: clientSelection,
            borderBoxCenter: add(state.initial.client.borderBoxCenter, offset)
          };
          var page = {
            selection: add(client.selection, viewport.scroll.current),
            borderBoxCenter: add(client.borderBoxCenter, viewport.scroll.current),
            offset: add(client.offset, viewport.scroll.diff.value)
          };
          var current = {
            client: client,
            page: page
          };
          if (state.phase === 'COLLECTING') {
            return _extends({
              phase: 'COLLECTING'
            }, state, {
              dimensions: dimensions,
              viewport: viewport,
              current: current
            });
          }
          var draggable = dimensions.draggables[state.critical.draggable.id];
          var newImpact = forcedImpact || getDragImpact({
            pageOffset: page.offset,
            draggable: draggable,
            draggables: dimensions.draggables,
            droppables: dimensions.droppables,
            previousImpact: state.impact,
            viewport: viewport,
            afterCritical: state.afterCritical
          });
          var withUpdatedPlaceholders = recomputePlaceholders({
            draggable: draggable,
            impact: newImpact,
            previousImpact: state.impact,
            draggables: dimensions.draggables,
            droppables: dimensions.droppables
          });
          var result = _extends({}, state, {
            current: current,
            dimensions: {
              draggables: dimensions.draggables,
              droppables: withUpdatedPlaceholders
            },
            impact: newImpact,
            viewport: viewport,
            scrollJumpRequest: scrollJumpRequest || null,
            forceShouldAnimate: scrollJumpRequest ? false : null
          });
          return result;
        };
        function getDraggables$1(ids, draggables) {
          return ids.map(function (id) {
            return draggables[id];
          });
        }
        var recompute = function (_ref) {
          var impact = _ref.impact,
            viewport = _ref.viewport,
            draggables = _ref.draggables,
            destination = _ref.destination,
            forceShouldAnimate = _ref.forceShouldAnimate;
          var last = impact.displaced;
          var afterDragging = getDraggables$1(last.all, draggables);
          var displaced = getDisplacementGroups({
            afterDragging: afterDragging,
            destination: destination,
            displacedBy: impact.displacedBy,
            viewport: viewport.frame,
            forceShouldAnimate: forceShouldAnimate,
            last: last
          });
          return _extends({}, impact, {
            displaced: displaced
          });
        };
        var getClientBorderBoxCenter = function (_ref) {
          var impact = _ref.impact,
            draggable = _ref.draggable,
            droppable = _ref.droppable,
            draggables = _ref.draggables,
            viewport = _ref.viewport,
            afterCritical = _ref.afterCritical;
          var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
            impact: impact,
            draggable: draggable,
            draggables: draggables,
            droppable: droppable,
            afterCritical: afterCritical
          });
          return getClientFromPageBorderBoxCenter({
            pageBorderBoxCenter: pageBorderBoxCenter,
            draggable: draggable,
            viewport: viewport
          });
        };
        var refreshSnap = function (_ref) {
          var state = _ref.state,
            forcedDimensions = _ref.dimensions,
            forcedViewport = _ref.viewport;
          !(state.movementMode === 'SNAP') ? invariant(false) : void 0;
          var needsVisibilityCheck = state.impact;
          var viewport = forcedViewport || state.viewport;
          var dimensions = forcedDimensions || state.dimensions;
          var draggables = dimensions.draggables,
            droppables = dimensions.droppables;
          var draggable = draggables[state.critical.draggable.id];
          var isOver = whatIsDraggedOver(needsVisibilityCheck);
          !isOver ? invariant(false) : void 0;
          var destination = droppables[isOver];
          var impact = recompute({
            impact: needsVisibilityCheck,
            viewport: viewport,
            destination: destination,
            draggables: draggables
          });
          var clientSelection = getClientBorderBoxCenter({
            impact: impact,
            draggable: draggable,
            droppable: destination,
            draggables: draggables,
            viewport: viewport,
            afterCritical: state.afterCritical
          });
          return update({
            impact: impact,
            clientSelection: clientSelection,
            state: state,
            dimensions: dimensions,
            viewport: viewport
          });
        };
        var getHomeLocation = function (descriptor) {
          return {
            index: descriptor.index,
            droppableId: descriptor.droppableId
          };
        };
        var getLiftEffect = function (_ref) {
          var draggable = _ref.draggable,
            home = _ref.home,
            draggables = _ref.draggables,
            viewport = _ref.viewport;
          var displacedBy = getDisplacedBy(home.axis, draggable.displaceBy);
          var insideHome = getDraggablesInsideDroppable(home.descriptor.id, draggables);
          var rawIndex = insideHome.indexOf(draggable);
          !(rawIndex !== -1) ? invariant(false) : void 0;
          var afterDragging = insideHome.slice(rawIndex + 1);
          var effected = afterDragging.reduce(function (previous, item) {
            previous[item.descriptor.id] = true;
            return previous;
          }, {});
          var afterCritical = {
            inVirtualList: home.descriptor.mode === 'virtual',
            displacedBy: displacedBy,
            effected: effected
          };
          var displaced = getDisplacementGroups({
            afterDragging: afterDragging,
            destination: home,
            displacedBy: displacedBy,
            last: null,
            viewport: viewport.frame,
            forceShouldAnimate: false
          });
          var impact = {
            displaced: displaced,
            displacedBy: displacedBy,
            at: {
              type: 'REORDER',
              destination: getHomeLocation(draggable.descriptor)
            }
          };
          return {
            impact: impact,
            afterCritical: afterCritical
          };
        };
        var patchDimensionMap = function (dimensions, updated) {
          return {
            draggables: dimensions.draggables,
            droppables: patchDroppableMap(dimensions.droppables, updated)
          };
        };
        var offsetDraggable = function (_ref) {
          var draggable = _ref.draggable,
            offset$1 = _ref.offset,
            initialWindowScroll = _ref.initialWindowScroll;
          var client = offset(draggable.client, offset$1);
          var page = withScroll(client, initialWindowScroll);
          var moved = _extends({}, draggable, {
            placeholder: _extends({}, draggable.placeholder, {
              client: client
            }),
            client: client,
            page: page
          });
          return moved;
        };
        var getFrame = function (droppable) {
          var frame = droppable.frame;
          !frame ? invariant(false) : void 0;
          return frame;
        };
        var adjustAdditionsForScrollChanges = function (_ref) {
          var additions = _ref.additions,
            updatedDroppables = _ref.updatedDroppables,
            viewport = _ref.viewport;
          var windowScrollChange = viewport.scroll.diff.value;
          return additions.map(function (draggable) {
            var droppableId = draggable.descriptor.droppableId;
            var modified = updatedDroppables[droppableId];
            var frame = getFrame(modified);
            var droppableScrollChange = frame.scroll.diff.value;
            var totalChange = add(windowScrollChange, droppableScrollChange);
            var moved = offsetDraggable({
              draggable: draggable,
              offset: totalChange,
              initialWindowScroll: viewport.scroll.initial
            });
            return moved;
          });
        };
        var publishWhileDraggingInVirtual = function (_ref) {
          var state = _ref.state,
            published = _ref.published;
          var withScrollChange = published.modified.map(function (update) {
            var existing = state.dimensions.droppables[update.droppableId];
            var scrolled = scrollDroppable(existing, update.scroll);
            return scrolled;
          });
          var droppables = _extends({}, state.dimensions.droppables, {}, toDroppableMap(withScrollChange));
          var updatedAdditions = toDraggableMap(adjustAdditionsForScrollChanges({
            additions: published.additions,
            updatedDroppables: droppables,
            viewport: state.viewport
          }));
          var draggables = _extends({}, state.dimensions.draggables, {}, updatedAdditions);
          published.removals.forEach(function (id) {
            delete draggables[id];
          });
          var dimensions = {
            droppables: droppables,
            draggables: draggables
          };
          var wasOverId = whatIsDraggedOver(state.impact);
          var wasOver = wasOverId ? dimensions.droppables[wasOverId] : null;
          var draggable = dimensions.draggables[state.critical.draggable.id];
          var home = dimensions.droppables[state.critical.droppable.id];
          var _getLiftEffect = getLiftEffect({
              draggable: draggable,
              home: home,
              draggables: draggables,
              viewport: state.viewport
            }),
            onLiftImpact = _getLiftEffect.impact,
            afterCritical = _getLiftEffect.afterCritical;
          var previousImpact = wasOver && wasOver.isCombineEnabled ? state.impact : onLiftImpact;
          var impact = getDragImpact({
            pageOffset: state.current.page.offset,
            draggable: dimensions.draggables[state.critical.draggable.id],
            draggables: dimensions.draggables,
            droppables: dimensions.droppables,
            previousImpact: previousImpact,
            viewport: state.viewport,
            afterCritical: afterCritical
          });
          var draggingState = _extends({
            phase: 'DRAGGING'
          }, state, {
            phase: 'DRAGGING',
            impact: impact,
            onLiftImpact: onLiftImpact,
            dimensions: dimensions,
            afterCritical: afterCritical,
            forceShouldAnimate: false
          });
          if (state.phase === 'COLLECTING') {
            return draggingState;
          }
          var dropPending = _extends({
            phase: 'DROP_PENDING'
          }, draggingState, {
            phase: 'DROP_PENDING',
            reason: state.reason,
            isWaiting: false
          });
          return dropPending;
        };
        var isSnapping = function isSnapping(state) {
          return state.movementMode === 'SNAP';
        };
        var postDroppableChange = function postDroppableChange(state, updated, isEnabledChanging) {
          var dimensions = patchDimensionMap(state.dimensions, updated);
          if (!isSnapping(state) || isEnabledChanging) {
            return update({
              state: state,
              dimensions: dimensions
            });
          }
          return refreshSnap({
            state: state,
            dimensions: dimensions
          });
        };
        function removeScrollJumpRequest(state) {
          if (state.isDragging && state.movementMode === 'SNAP') {
            return _extends({
              phase: 'DRAGGING'
            }, state, {
              scrollJumpRequest: null
            });
          }
          return state;
        }
        var idle = {
          phase: 'IDLE',
          completed: null,
          shouldFlush: false
        };
        var reducer = function (state, action) {
          if (state === void 0) {
            state = idle;
          }
          if (action.type === 'FLUSH') {
            return _extends({}, idle, {
              shouldFlush: true
            });
          }
          if (action.type === 'INITIAL_PUBLISH') {
            !(state.phase === 'IDLE') ? invariant(false) : void 0;
            var _action$payload = action.payload,
              critical = _action$payload.critical,
              clientSelection = _action$payload.clientSelection,
              viewport = _action$payload.viewport,
              dimensions = _action$payload.dimensions,
              movementMode = _action$payload.movementMode;
            var draggable = dimensions.draggables[critical.draggable.id];
            var home = dimensions.droppables[critical.droppable.id];
            var client = {
              selection: clientSelection,
              borderBoxCenter: draggable.client.borderBox.center,
              offset: origin
            };
            var initial = {
              client: client,
              page: {
                selection: add(client.selection, viewport.scroll.initial),
                borderBoxCenter: add(client.selection, viewport.scroll.initial),
                offset: add(client.selection, viewport.scroll.diff.value)
              }
            };
            var isWindowScrollAllowed = toDroppableList(dimensions.droppables).every(function (item) {
              return !item.isFixedOnPage;
            });
            var _getLiftEffect = getLiftEffect({
                draggable: draggable,
                home: home,
                draggables: dimensions.draggables,
                viewport: viewport
              }),
              impact = _getLiftEffect.impact,
              afterCritical = _getLiftEffect.afterCritical;
            var result = {
              phase: 'DRAGGING',
              isDragging: true,
              critical: critical,
              movementMode: movementMode,
              dimensions: dimensions,
              initial: initial,
              current: initial,
              isWindowScrollAllowed: isWindowScrollAllowed,
              impact: impact,
              afterCritical: afterCritical,
              onLiftImpact: impact,
              viewport: viewport,
              scrollJumpRequest: null,
              forceShouldAnimate: null
            };
            return result;
          }
          if (action.type === 'COLLECTION_STARTING') {
            if (state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') {
              return state;
            }
            !(state.phase === 'DRAGGING') ? invariant(false) : void 0;
            var _result = _extends({
              phase: 'COLLECTING'
            }, state, {
              phase: 'COLLECTING'
            });
            return _result;
          }
          if (action.type === 'PUBLISH_WHILE_DRAGGING') {
            !(state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') ? invariant(false) : void 0;
            return publishWhileDraggingInVirtual({
              state: state,
              published: action.payload
            });
          }
          if (action.type === 'MOVE') {
            if (state.phase === 'DROP_PENDING') {
              return state;
            }
            !isMovementAllowed(state) ? invariant(false) : void 0;
            var _clientSelection = action.payload.client;
            if (isEqual(_clientSelection, state.current.client.selection)) {
              return state;
            }
            return update({
              state: state,
              clientSelection: _clientSelection,
              impact: isSnapping(state) ? state.impact : null
            });
          }
          if (action.type === 'UPDATE_DROPPABLE_SCROLL') {
            if (state.phase === 'DROP_PENDING') {
              return removeScrollJumpRequest(state);
            }
            if (state.phase === 'COLLECTING') {
              return removeScrollJumpRequest(state);
            }
            !isMovementAllowed(state) ? invariant(false) : void 0;
            var _action$payload2 = action.payload,
              id = _action$payload2.id,
              newScroll = _action$payload2.newScroll;
            var target = state.dimensions.droppables[id];
            if (!target) {
              return state;
            }
            var scrolled = scrollDroppable(target, newScroll);
            return postDroppableChange(state, scrolled, false);
          }
          if (action.type === 'UPDATE_DROPPABLE_IS_ENABLED') {
            if (state.phase === 'DROP_PENDING') {
              return state;
            }
            !isMovementAllowed(state) ? invariant(false) : void 0;
            var _action$payload3 = action.payload,
              _id = _action$payload3.id,
              isEnabled = _action$payload3.isEnabled;
            var _target = state.dimensions.droppables[_id];
            !_target ? invariant(false) : void 0;
            !(_target.isEnabled !== isEnabled) ? invariant(false) : void 0;
            var updated = _extends({}, _target, {
              isEnabled: isEnabled
            });
            return postDroppableChange(state, updated, true);
          }
          if (action.type === 'UPDATE_DROPPABLE_IS_COMBINE_ENABLED') {
            if (state.phase === 'DROP_PENDING') {
              return state;
            }
            !isMovementAllowed(state) ? invariant(false) : void 0;
            var _action$payload4 = action.payload,
              _id2 = _action$payload4.id,
              isCombineEnabled = _action$payload4.isCombineEnabled;
            var _target2 = state.dimensions.droppables[_id2];
            !_target2 ? invariant(false) : void 0;
            !(_target2.isCombineEnabled !== isCombineEnabled) ? invariant(false) : void 0;
            var _updated = _extends({}, _target2, {
              isCombineEnabled: isCombineEnabled
            });
            return postDroppableChange(state, _updated, true);
          }
          if (action.type === 'MOVE_BY_WINDOW_SCROLL') {
            if (state.phase === 'DROP_PENDING' || state.phase === 'DROP_ANIMATING') {
              return state;
            }
            !isMovementAllowed(state) ? invariant(false) : void 0;
            !state.isWindowScrollAllowed ? invariant(false) : void 0;
            var _newScroll = action.payload.newScroll;
            if (isEqual(state.viewport.scroll.current, _newScroll)) {
              return removeScrollJumpRequest(state);
            }
            var _viewport = scrollViewport(state.viewport, _newScroll);
            if (isSnapping(state)) {
              return refreshSnap({
                state: state,
                viewport: _viewport
              });
            }
            return update({
              state: state,
              viewport: _viewport
            });
          }
          if (action.type === 'UPDATE_VIEWPORT_MAX_SCROLL') {
            if (!isMovementAllowed(state)) {
              return state;
            }
            var maxScroll = action.payload.maxScroll;
            if (isEqual(maxScroll, state.viewport.scroll.max)) {
              return state;
            }
            var withMaxScroll = _extends({}, state.viewport, {
              scroll: _extends({}, state.viewport.scroll, {
                max: maxScroll
              })
            });
            return _extends({
              phase: 'DRAGGING'
            }, state, {
              viewport: withMaxScroll
            });
          }
          if (action.type === 'MOVE_UP' || action.type === 'MOVE_DOWN' || action.type === 'MOVE_LEFT' || action.type === 'MOVE_RIGHT') {
            if (state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') {
              return state;
            }
            !(state.phase === 'DRAGGING') ? invariant(false) : void 0;
            var _result2 = moveInDirection({
              state: state,
              type: action.type
            });
            if (!_result2) {
              return state;
            }
            return update({
              state: state,
              impact: _result2.impact,
              clientSelection: _result2.clientSelection,
              scrollJumpRequest: _result2.scrollJumpRequest
            });
          }
          if (action.type === 'DROP_PENDING') {
            var reason = action.payload.reason;
            !(state.phase === 'COLLECTING') ? invariant(false) : void 0;
            var newState = _extends({
              phase: 'DROP_PENDING'
            }, state, {
              phase: 'DROP_PENDING',
              isWaiting: true,
              reason: reason
            });
            return newState;
          }
          if (action.type === 'DROP_ANIMATE') {
            var _action$payload5 = action.payload,
              completed = _action$payload5.completed,
              dropDuration = _action$payload5.dropDuration,
              newHomeClientOffset = _action$payload5.newHomeClientOffset;
            !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ? invariant(false) : void 0;
            var _result3 = {
              phase: 'DROP_ANIMATING',
              completed: completed,
              dropDuration: dropDuration,
              newHomeClientOffset: newHomeClientOffset,
              dimensions: state.dimensions
            };
            return _result3;
          }
          if (action.type === 'DROP_COMPLETE') {
            var _completed = action.payload.completed;
            return {
              phase: 'IDLE',
              completed: _completed,
              shouldFlush: false
            };
          }
          return state;
        };
        var beforeInitialCapture = function beforeInitialCapture(args) {
          return {
            type: 'BEFORE_INITIAL_CAPTURE',
            payload: args
          };
        };
        var lift = function lift(args) {
          return {
            type: 'LIFT',
            payload: args
          };
        };
        var initialPublish = function initialPublish(args) {
          return {
            type: 'INITIAL_PUBLISH',
            payload: args
          };
        };
        var publishWhileDragging = function publishWhileDragging(args) {
          return {
            type: 'PUBLISH_WHILE_DRAGGING',
            payload: args
          };
        };
        var collectionStarting = function collectionStarting() {
          return {
            type: 'COLLECTION_STARTING',
            payload: null
          };
        };
        var updateDroppableScroll = function updateDroppableScroll(args) {
          return {
            type: 'UPDATE_DROPPABLE_SCROLL',
            payload: args
          };
        };
        var updateDroppableIsEnabled = function updateDroppableIsEnabled(args) {
          return {
            type: 'UPDATE_DROPPABLE_IS_ENABLED',
            payload: args
          };
        };
        var updateDroppableIsCombineEnabled = function updateDroppableIsCombineEnabled(args) {
          return {
            type: 'UPDATE_DROPPABLE_IS_COMBINE_ENABLED',
            payload: args
          };
        };
        var move = function move(args) {
          return {
            type: 'MOVE',
            payload: args
          };
        };
        var moveByWindowScroll = function moveByWindowScroll(args) {
          return {
            type: 'MOVE_BY_WINDOW_SCROLL',
            payload: args
          };
        };
        var updateViewportMaxScroll = function updateViewportMaxScroll(args) {
          return {
            type: 'UPDATE_VIEWPORT_MAX_SCROLL',
            payload: args
          };
        };
        var moveUp = function moveUp() {
          return {
            type: 'MOVE_UP',
            payload: null
          };
        };
        var moveDown = function moveDown() {
          return {
            type: 'MOVE_DOWN',
            payload: null
          };
        };
        var moveRight = function moveRight() {
          return {
            type: 'MOVE_RIGHT',
            payload: null
          };
        };
        var moveLeft = function moveLeft() {
          return {
            type: 'MOVE_LEFT',
            payload: null
          };
        };
        var flush = function flush() {
          return {
            type: 'FLUSH',
            payload: null
          };
        };
        var animateDrop = function animateDrop(args) {
          return {
            type: 'DROP_ANIMATE',
            payload: args
          };
        };
        var completeDrop = function completeDrop(args) {
          return {
            type: 'DROP_COMPLETE',
            payload: args
          };
        };
        var drop = function drop(args) {
          return {
            type: 'DROP',
            payload: args
          };
        };
        var dropPending = function dropPending(args) {
          return {
            type: 'DROP_PENDING',
            payload: args
          };
        };
        var dropAnimationFinished = function dropAnimationFinished() {
          return {
            type: 'DROP_ANIMATION_FINISHED',
            payload: null
          };
        };
        var lift$1 = function (marshal) {
          return function (_ref) {
            var getState = _ref.getState,
              dispatch = _ref.dispatch;
            return function (next) {
              return function (action) {
                if (action.type !== 'LIFT') {
                  next(action);
                  return;
                }
                var _action$payload = action.payload,
                  id = _action$payload.id,
                  clientSelection = _action$payload.clientSelection,
                  movementMode = _action$payload.movementMode;
                var initial = getState();
                if (initial.phase === 'DROP_ANIMATING') {
                  dispatch(completeDrop({
                    completed: initial.completed
                  }));
                }
                !(getState().phase === 'IDLE') ? invariant(false) : void 0;
                dispatch(flush());
                dispatch(beforeInitialCapture({
                  draggableId: id,
                  movementMode: movementMode
                }));
                var scrollOptions = {
                  shouldPublishImmediately: movementMode === 'SNAP'
                };
                var request = {
                  draggableId: id,
                  scrollOptions: scrollOptions
                };
                var _marshal$startPublish = marshal.startPublishing(request),
                  critical = _marshal$startPublish.critical,
                  dimensions = _marshal$startPublish.dimensions,
                  viewport = _marshal$startPublish.viewport;
                dispatch(initialPublish({
                  critical: critical,
                  dimensions: dimensions,
                  clientSelection: clientSelection,
                  movementMode: movementMode,
                  viewport: viewport
                }));
              };
            };
          };
        };
        var style$2 = function (marshal) {
          return function () {
            return function (next) {
              return function (action) {
                if (action.type === 'INITIAL_PUBLISH') {
                  marshal.dragging();
                }
                if (action.type === 'DROP_ANIMATE') {
                  marshal.dropping(action.payload.completed.result.reason);
                }
                if (action.type === 'FLUSH' || action.type === 'DROP_COMPLETE') {
                  marshal.resting();
                }
                next(action);
              };
            };
          };
        };
        var curves = {
          outOfTheWay: 'cubic-bezier(0.2, 0, 0, 1)',
          drop: 'cubic-bezier(.2,1,.1,1)'
        };
        var combine$1 = {
          opacity: {
            drop: 0,
            combining: 0.7
          },
          scale: {
            drop: 0.75
          }
        };
        var timings = {
          outOfTheWay: 0.2,
          minDropTime: 0.33,
          maxDropTime: 0.55
        };
        var outOfTheWayTiming = timings.outOfTheWay + "s " + curves.outOfTheWay;
        var transitions = {
          fluid: "opacity " + outOfTheWayTiming,
          snap: "transform " + outOfTheWayTiming + ", opacity " + outOfTheWayTiming,
          drop: function drop(duration) {
            var timing = duration + "s " + curves.drop;
            return "transform " + timing + ", opacity " + timing;
          },
          outOfTheWay: "transform " + outOfTheWayTiming,
          placeholder: "height " + outOfTheWayTiming + ", width " + outOfTheWayTiming + ", margin " + outOfTheWayTiming
        };
        var moveTo = function moveTo(offset) {
          return isEqual(offset, origin) ? null : "translate(" + offset.x + "px, " + offset.y + "px)";
        };
        var transforms = {
          moveTo: moveTo,
          drop: function drop(offset, isCombining) {
            var translate = moveTo(offset);
            if (!translate) {
              return null;
            }
            if (!isCombining) {
              return translate;
            }
            return translate + " scale(" + combine$1.scale.drop + ")";
          }
        };
        var minDropTime = timings.minDropTime,
          maxDropTime = timings.maxDropTime;
        var dropTimeRange = maxDropTime - minDropTime;
        var maxDropTimeAtDistance = 1500;
        var cancelDropModifier = 0.6;
        var getDropDuration = function (_ref) {
          var current = _ref.current,
            destination = _ref.destination,
            reason = _ref.reason;
          var distance$1 = distance(current, destination);
          if (distance$1 <= 0) {
            return minDropTime;
          }
          if (distance$1 >= maxDropTimeAtDistance) {
            return maxDropTime;
          }
          var percentage = distance$1 / maxDropTimeAtDistance;
          var duration = minDropTime + dropTimeRange * percentage;
          var withDuration = reason === 'CANCEL' ? duration * cancelDropModifier : duration;
          return Number(withDuration.toFixed(2));
        };
        var getNewHomeClientOffset = function (_ref) {
          var impact = _ref.impact,
            draggable = _ref.draggable,
            dimensions = _ref.dimensions,
            viewport = _ref.viewport,
            afterCritical = _ref.afterCritical;
          var draggables = dimensions.draggables,
            droppables = dimensions.droppables;
          var droppableId = whatIsDraggedOver(impact);
          var destination = droppableId ? droppables[droppableId] : null;
          var home = droppables[draggable.descriptor.droppableId];
          var newClientCenter = getClientBorderBoxCenter({
            impact: impact,
            draggable: draggable,
            draggables: draggables,
            afterCritical: afterCritical,
            droppable: destination || home,
            viewport: viewport
          });
          var offset = subtract(newClientCenter, draggable.client.borderBox.center);
          return offset;
        };
        var getDropImpact = function (_ref) {
          var draggables = _ref.draggables,
            reason = _ref.reason,
            lastImpact = _ref.lastImpact,
            home = _ref.home,
            viewport = _ref.viewport,
            onLiftImpact = _ref.onLiftImpact;
          if (!lastImpact.at || reason !== 'DROP') {
            var recomputedHomeImpact = recompute({
              draggables: draggables,
              impact: onLiftImpact,
              destination: home,
              viewport: viewport,
              forceShouldAnimate: true
            });
            return {
              impact: recomputedHomeImpact,
              didDropInsideDroppable: false
            };
          }
          if (lastImpact.at.type === 'REORDER') {
            return {
              impact: lastImpact,
              didDropInsideDroppable: true
            };
          }
          var withoutMovement = _extends({}, lastImpact, {
            displaced: emptyGroups
          });
          return {
            impact: withoutMovement,
            didDropInsideDroppable: true
          };
        };
        var drop$1 = function (_ref) {
          var getState = _ref.getState,
            dispatch = _ref.dispatch;
          return function (next) {
            return function (action) {
              if (action.type !== 'DROP') {
                next(action);
                return;
              }
              var state = getState();
              var reason = action.payload.reason;
              if (state.phase === 'COLLECTING') {
                dispatch(dropPending({
                  reason: reason
                }));
                return;
              }
              if (state.phase === 'IDLE') {
                return;
              }
              var isWaitingForDrop = state.phase === 'DROP_PENDING' && state.isWaiting;
              !!isWaitingForDrop ? invariant(false) : void 0;
              !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ? invariant(false) : void 0;
              var critical = state.critical;
              var dimensions = state.dimensions;
              var draggable = dimensions.draggables[state.critical.draggable.id];
              var _getDropImpact = getDropImpact({
                  reason: reason,
                  lastImpact: state.impact,
                  afterCritical: state.afterCritical,
                  onLiftImpact: state.onLiftImpact,
                  home: state.dimensions.droppables[state.critical.droppable.id],
                  viewport: state.viewport,
                  draggables: state.dimensions.draggables
                }),
                impact = _getDropImpact.impact,
                didDropInsideDroppable = _getDropImpact.didDropInsideDroppable;
              var destination = didDropInsideDroppable ? tryGetDestination(impact) : null;
              var combine = didDropInsideDroppable ? tryGetCombine(impact) : null;
              var source = {
                index: critical.draggable.index,
                droppableId: critical.droppable.id
              };
              var result = {
                draggableId: draggable.descriptor.id,
                type: draggable.descriptor.type,
                source: source,
                reason: reason,
                mode: state.movementMode,
                destination: destination,
                combine: combine
              };
              var newHomeClientOffset = getNewHomeClientOffset({
                impact: impact,
                draggable: draggable,
                dimensions: dimensions,
                viewport: state.viewport,
                afterCritical: state.afterCritical
              });
              var completed = {
                critical: state.critical,
                afterCritical: state.afterCritical,
                result: result,
                impact: impact
              };
              var isAnimationRequired = !isEqual(state.current.client.offset, newHomeClientOffset) || Boolean(result.combine);
              if (!isAnimationRequired) {
                dispatch(completeDrop({
                  completed: completed
                }));
                return;
              }
              var dropDuration = getDropDuration({
                current: state.current.client.offset,
                destination: newHomeClientOffset,
                reason: reason
              });
              var args = {
                newHomeClientOffset: newHomeClientOffset,
                dropDuration: dropDuration,
                completed: completed
              };
              dispatch(animateDrop(args));
            };
          };
        };
        var getWindowScroll = function () {
          return {
            x: window.pageXOffset,
            y: window.pageYOffset
          };
        };
        function getWindowScrollBinding(update) {
          return {
            eventName: 'scroll',
            options: {
              passive: true,
              capture: false
            },
            fn: function fn(event) {
              if (event.target !== window && event.target !== window.document) {
                return;
              }
              update();
            }
          };
        }
        function getScrollListener(_ref) {
          var onWindowScroll = _ref.onWindowScroll;
          function updateScroll() {
            onWindowScroll(getWindowScroll());
          }
          var scheduled = rafSchd$1(updateScroll);
          var binding = getWindowScrollBinding(scheduled);
          var unbind = noop;
          function isActive() {
            return unbind !== noop;
          }
          function start() {
            !!isActive() ? invariant(false) : void 0;
            unbind = bindEvents(window, [binding]);
          }
          function stop() {
            !isActive() ? invariant(false) : void 0;
            scheduled.cancel();
            unbind();
            unbind = noop;
          }
          return {
            start: start,
            stop: stop,
            isActive: isActive
          };
        }
        var shouldEnd = function shouldEnd(action) {
          return action.type === 'DROP_COMPLETE' || action.type === 'DROP_ANIMATE' || action.type === 'FLUSH';
        };
        var scrollListener = function (store) {
          var listener = getScrollListener({
            onWindowScroll: function onWindowScroll(newScroll) {
              store.dispatch(moveByWindowScroll({
                newScroll: newScroll
              }));
            }
          });
          return function (next) {
            return function (action) {
              if (!listener.isActive() && action.type === 'INITIAL_PUBLISH') {
                listener.start();
              }
              if (listener.isActive() && shouldEnd(action)) {
                listener.stop();
              }
              next(action);
            };
          };
        };
        var getExpiringAnnounce = function (announce) {
          var wasCalled = false;
          var isExpired = false;
          var timeoutId = setTimeout(function () {
            isExpired = true;
          });
          var result = function result(message) {
            if (wasCalled) {
              return;
            }
            if (isExpired) {
              return;
            }
            wasCalled = true;
            announce(message);
            clearTimeout(timeoutId);
          };
          result.wasCalled = function () {
            return wasCalled;
          };
          return result;
        };
        var getAsyncMarshal = function () {
          var entries = [];
          var execute = function execute(timerId) {
            var index = findIndex(entries, function (item) {
              return item.timerId === timerId;
            });
            !(index !== -1) ? invariant(false) : void 0;
            var _entries$splice = entries.splice(index, 1),
              entry = _entries$splice[0];
            entry.callback();
          };
          var add = function add(fn) {
            var timerId = setTimeout(function () {
              return execute(timerId);
            });
            var entry = {
              timerId: timerId,
              callback: fn
            };
            entries.push(entry);
          };
          var flush = function flush() {
            if (!entries.length) {
              return;
            }
            var shallow = [].concat(entries);
            entries.length = 0;
            shallow.forEach(function (entry) {
              clearTimeout(entry.timerId);
              entry.callback();
            });
          };
          return {
            add: add,
            flush: flush
          };
        };
        var areLocationsEqual = function areLocationsEqual(first, second) {
          if (first == null && second == null) {
            return true;
          }
          if (first == null || second == null) {
            return false;
          }
          return first.droppableId === second.droppableId && first.index === second.index;
        };
        var isCombineEqual = function isCombineEqual(first, second) {
          if (first == null && second == null) {
            return true;
          }
          if (first == null || second == null) {
            return false;
          }
          return first.draggableId === second.draggableId && first.droppableId === second.droppableId;
        };
        var isCriticalEqual = function isCriticalEqual(first, second) {
          if (first === second) {
            return true;
          }
          var isDraggableEqual = first.draggable.id === second.draggable.id && first.draggable.droppableId === second.draggable.droppableId && first.draggable.type === second.draggable.type && first.draggable.index === second.draggable.index;
          var isDroppableEqual = first.droppable.id === second.droppable.id && first.droppable.type === second.droppable.type;
          return isDraggableEqual && isDroppableEqual;
        };
        var withTimings = function withTimings(key, fn) {
          fn();
        };
        var getDragStart = function getDragStart(critical, mode) {
          return {
            draggableId: critical.draggable.id,
            type: critical.droppable.type,
            source: {
              droppableId: critical.droppable.id,
              index: critical.draggable.index
            },
            mode: mode
          };
        };
        var execute = function execute(responder, data, announce, getDefaultMessage) {
          if (!responder) {
            announce(getDefaultMessage(data));
            return;
          }
          var willExpire = getExpiringAnnounce(announce);
          var provided = {
            announce: willExpire
          };
          responder(data, provided);
          if (!willExpire.wasCalled()) {
            announce(getDefaultMessage(data));
          }
        };
        var getPublisher = function (getResponders, announce) {
          var asyncMarshal = getAsyncMarshal();
          var dragging = null;
          var beforeCapture = function beforeCapture(draggableId, mode) {
            !!dragging ? invariant(false) : void 0;
            withTimings('onBeforeCapture', function () {
              var fn = getResponders().onBeforeCapture;
              if (fn) {
                var before = {
                  draggableId: draggableId,
                  mode: mode
                };
                fn(before);
              }
            });
          };
          var beforeStart = function beforeStart(critical, mode) {
            !!dragging ? invariant(false) : void 0;
            withTimings('onBeforeDragStart', function () {
              var fn = getResponders().onBeforeDragStart;
              if (fn) {
                fn(getDragStart(critical, mode));
              }
            });
          };
          var start = function start(critical, mode) {
            !!dragging ? invariant(false) : void 0;
            var data = getDragStart(critical, mode);
            dragging = {
              mode: mode,
              lastCritical: critical,
              lastLocation: data.source,
              lastCombine: null
            };
            asyncMarshal.add(function () {
              withTimings('onDragStart', function () {
                return execute(getResponders().onDragStart, data, announce, preset.onDragStart);
              });
            });
          };
          var update = function update(critical, impact) {
            var location = tryGetDestination(impact);
            var combine = tryGetCombine(impact);
            !dragging ? invariant(false) : void 0;
            var hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);
            if (hasCriticalChanged) {
              dragging.lastCritical = critical;
            }
            var hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location);
            if (hasLocationChanged) {
              dragging.lastLocation = location;
            }
            var hasGroupingChanged = !isCombineEqual(dragging.lastCombine, combine);
            if (hasGroupingChanged) {
              dragging.lastCombine = combine;
            }
            if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {
              return;
            }
            var data = _extends({}, getDragStart(critical, dragging.mode), {
              combine: combine,
              destination: location
            });
            asyncMarshal.add(function () {
              withTimings('onDragUpdate', function () {
                return execute(getResponders().onDragUpdate, data, announce, preset.onDragUpdate);
              });
            });
          };
          var flush = function flush() {
            !dragging ? invariant(false) : void 0;
            asyncMarshal.flush();
          };
          var drop = function drop(result) {
            !dragging ? invariant(false) : void 0;
            dragging = null;
            withTimings('onDragEnd', function () {
              return execute(getResponders().onDragEnd, result, announce, preset.onDragEnd);
            });
          };
          var abort = function abort() {
            if (!dragging) {
              return;
            }
            var result = _extends({}, getDragStart(dragging.lastCritical, dragging.mode), {
              combine: null,
              destination: null,
              reason: 'CANCEL'
            });
            drop(result);
          };
          return {
            beforeCapture: beforeCapture,
            beforeStart: beforeStart,
            start: start,
            update: update,
            flush: flush,
            drop: drop,
            abort: abort
          };
        };
        var responders = function (getResponders, announce) {
          var publisher = getPublisher(getResponders, announce);
          return function (store) {
            return function (next) {
              return function (action) {
                if (action.type === 'BEFORE_INITIAL_CAPTURE') {
                  publisher.beforeCapture(action.payload.draggableId, action.payload.movementMode);
                  return;
                }
                if (action.type === 'INITIAL_PUBLISH') {
                  var critical = action.payload.critical;
                  publisher.beforeStart(critical, action.payload.movementMode);
                  next(action);
                  publisher.start(critical, action.payload.movementMode);
                  return;
                }
                if (action.type === 'DROP_COMPLETE') {
                  var result = action.payload.completed.result;
                  publisher.flush();
                  next(action);
                  publisher.drop(result);
                  return;
                }
                next(action);
                if (action.type === 'FLUSH') {
                  publisher.abort();
                  return;
                }
                var state = store.getState();
                if (state.phase === 'DRAGGING') {
                  publisher.update(state.critical, state.impact);
                }
              };
            };
          };
        };
        var dropAnimationFinish = function (store) {
          return function (next) {
            return function (action) {
              if (action.type !== 'DROP_ANIMATION_FINISHED') {
                next(action);
                return;
              }
              var state = store.getState();
              !(state.phase === 'DROP_ANIMATING') ? invariant(false) : void 0;
              store.dispatch(completeDrop({
                completed: state.completed
              }));
            };
          };
        };
        var dropAnimationFlushOnScroll = function (store) {
          var unbind = null;
          var frameId = null;
          function clear() {
            if (frameId) {
              cancelAnimationFrame(frameId);
              frameId = null;
            }
            if (unbind) {
              unbind();
              unbind = null;
            }
          }
          return function (next) {
            return function (action) {
              if (action.type === 'FLUSH' || action.type === 'DROP_COMPLETE' || action.type === 'DROP_ANIMATION_FINISHED') {
                clear();
              }
              next(action);
              if (action.type !== 'DROP_ANIMATE') {
                return;
              }
              var binding = {
                eventName: 'scroll',
                options: {
                  capture: true,
                  passive: false,
                  once: true
                },
                fn: function flushDropAnimation() {
                  var state = store.getState();
                  if (state.phase === 'DROP_ANIMATING') {
                    store.dispatch(dropAnimationFinished());
                  }
                }
              };
              frameId = requestAnimationFrame(function () {
                frameId = null;
                unbind = bindEvents(window, [binding]);
              });
            };
          };
        };
        var dimensionMarshalStopper = function (marshal) {
          return function () {
            return function (next) {
              return function (action) {
                if (action.type === 'DROP_COMPLETE' || action.type === 'FLUSH' || action.type === 'DROP_ANIMATE') {
                  marshal.stopPublishing();
                }
                next(action);
              };
            };
          };
        };
        var focus = function (marshal) {
          var isWatching = false;
          return function () {
            return function (next) {
              return function (action) {
                if (action.type === 'INITIAL_PUBLISH') {
                  isWatching = true;
                  marshal.tryRecordFocus(action.payload.critical.draggable.id);
                  next(action);
                  marshal.tryRestoreFocusRecorded();
                  return;
                }
                next(action);
                if (!isWatching) {
                  return;
                }
                if (action.type === 'FLUSH') {
                  isWatching = false;
                  marshal.tryRestoreFocusRecorded();
                  return;
                }
                if (action.type === 'DROP_COMPLETE') {
                  isWatching = false;
                  var result = action.payload.completed.result;
                  if (result.combine) {
                    marshal.tryShiftRecord(result.draggableId, result.combine.draggableId);
                  }
                  marshal.tryRestoreFocusRecorded();
                }
              };
            };
          };
        };
        var shouldStop = function shouldStop(action) {
          return action.type === 'DROP_COMPLETE' || action.type === 'DROP_ANIMATE' || action.type === 'FLUSH';
        };
        var autoScroll = function (autoScroller) {
          return function (store) {
            return function (next) {
              return function (action) {
                if (shouldStop(action)) {
                  autoScroller.stop();
                  next(action);
                  return;
                }
                if (action.type === 'INITIAL_PUBLISH') {
                  next(action);
                  var state = store.getState();
                  !(state.phase === 'DRAGGING') ? invariant(false) : void 0;
                  autoScroller.start(state);
                  return;
                }
                next(action);
                autoScroller.scroll(store.getState());
              };
            };
          };
        };
        var pendingDrop = function (store) {
          return function (next) {
            return function (action) {
              next(action);
              if (action.type !== 'PUBLISH_WHILE_DRAGGING') {
                return;
              }
              var postActionState = store.getState();
              if (postActionState.phase !== 'DROP_PENDING') {
                return;
              }
              if (postActionState.isWaiting) {
                return;
              }
              store.dispatch(drop({
                reason: postActionState.reason
              }));
            };
          };
        };
        var composeEnhancers = compose$1;
        var createStore = function (_ref) {
          var dimensionMarshal = _ref.dimensionMarshal,
            focusMarshal = _ref.focusMarshal,
            styleMarshal = _ref.styleMarshal,
            getResponders = _ref.getResponders,
            announce = _ref.announce,
            autoScroller = _ref.autoScroller;
          return createStore$1(reducer, composeEnhancers(applyMiddleware(style$2(styleMarshal), dimensionMarshalStopper(dimensionMarshal), lift$1(dimensionMarshal), drop$1, dropAnimationFinish, dropAnimationFlushOnScroll, pendingDrop, autoScroll(autoScroller), scrollListener, focus(focusMarshal), responders(getResponders, announce))));
        };
        var clean$1 = function clean() {
          return {
            additions: {},
            removals: {},
            modified: {}
          };
        };
        function createPublisher(_ref) {
          var registry = _ref.registry,
            callbacks = _ref.callbacks;
          var staging = clean$1();
          var frameId = null;
          var collect = function collect() {
            if (frameId) {
              return;
            }
            callbacks.collectionStarting();
            frameId = requestAnimationFrame(function () {
              frameId = null;
              var _staging = staging,
                additions = _staging.additions,
                removals = _staging.removals,
                modified = _staging.modified;
              var added = Object.keys(additions).map(function (id) {
                return registry.draggable.getById(id).getDimension(origin);
              }).sort(function (a, b) {
                return a.descriptor.index - b.descriptor.index;
              });
              var updated = Object.keys(modified).map(function (id) {
                var entry = registry.droppable.getById(id);
                var scroll = entry.callbacks.getScrollWhileDragging();
                return {
                  droppableId: id,
                  scroll: scroll
                };
              });
              var result = {
                additions: added,
                removals: Object.keys(removals),
                modified: updated
              };
              staging = clean$1();
              callbacks.publish(result);
            });
          };
          var add = function add(entry) {
            var id = entry.descriptor.id;
            staging.additions[id] = entry;
            staging.modified[entry.descriptor.droppableId] = true;
            if (staging.removals[id]) {
              delete staging.removals[id];
            }
            collect();
          };
          var remove = function remove(entry) {
            var descriptor = entry.descriptor;
            staging.removals[descriptor.id] = true;
            staging.modified[descriptor.droppableId] = true;
            if (staging.additions[descriptor.id]) {
              delete staging.additions[descriptor.id];
            }
            collect();
          };
          var stop = function stop() {
            if (!frameId) {
              return;
            }
            cancelAnimationFrame(frameId);
            frameId = null;
            staging = clean$1();
          };
          return {
            add: add,
            remove: remove,
            stop: stop
          };
        }
        var getMaxScroll = function (_ref) {
          var scrollHeight = _ref.scrollHeight,
            scrollWidth = _ref.scrollWidth,
            height = _ref.height,
            width = _ref.width;
          var maxScroll = subtract({
            x: scrollWidth,
            y: scrollHeight
          }, {
            x: width,
            y: height
          });
          var adjustedMaxScroll = {
            x: Math.max(0, maxScroll.x),
            y: Math.max(0, maxScroll.y)
          };
          return adjustedMaxScroll;
        };
        var getDocumentElement = function () {
          var doc = document.documentElement;
          !doc ? invariant(false) : void 0;
          return doc;
        };
        var getMaxWindowScroll = function () {
          var doc = getDocumentElement();
          var maxScroll = getMaxScroll({
            scrollHeight: doc.scrollHeight,
            scrollWidth: doc.scrollWidth,
            width: doc.clientWidth,
            height: doc.clientHeight
          });
          return maxScroll;
        };
        var getViewport = function () {
          var scroll = getWindowScroll();
          var maxScroll = getMaxWindowScroll();
          var top = scroll.y;
          var left = scroll.x;
          var doc = getDocumentElement();
          var width = doc.clientWidth;
          var height = doc.clientHeight;
          var right = left + width;
          var bottom = top + height;
          var frame = getRect({
            top: top,
            left: left,
            right: right,
            bottom: bottom
          });
          var viewport = {
            frame: frame,
            scroll: {
              initial: scroll,
              current: scroll,
              max: maxScroll,
              diff: {
                value: origin,
                displacement: origin
              }
            }
          };
          return viewport;
        };
        var getInitialPublish = function (_ref) {
          var critical = _ref.critical,
            scrollOptions = _ref.scrollOptions,
            registry = _ref.registry;
          var viewport = getViewport();
          var windowScroll = viewport.scroll.current;
          var home = critical.droppable;
          var droppables = registry.droppable.getAllByType(home.type).map(function (entry) {
            return entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions);
          });
          var draggables = registry.draggable.getAllByType(critical.draggable.type).map(function (entry) {
            return entry.getDimension(windowScroll);
          });
          var dimensions = {
            draggables: toDraggableMap(draggables),
            droppables: toDroppableMap(droppables)
          };
          var result = {
            dimensions: dimensions,
            critical: critical,
            viewport: viewport
          };
          return result;
        };
        function shouldPublishUpdate(registry, dragging, entry) {
          if (entry.descriptor.id === dragging.id) {
            return false;
          }
          if (entry.descriptor.type !== dragging.type) {
            return false;
          }
          var home = registry.droppable.getById(entry.descriptor.droppableId);
          if (home.descriptor.mode !== 'virtual') {
            return false;
          }
          return true;
        }
        var createDimensionMarshal = function (registry, callbacks) {
          var collection = null;
          var publisher = createPublisher({
            callbacks: {
              publish: callbacks.publishWhileDragging,
              collectionStarting: callbacks.collectionStarting
            },
            registry: registry
          });
          var updateDroppableIsEnabled = function updateDroppableIsEnabled(id, isEnabled) {
            !registry.droppable.exists(id) ? invariant(false) : void 0;
            if (!collection) {
              return;
            }
            callbacks.updateDroppableIsEnabled({
              id: id,
              isEnabled: isEnabled
            });
          };
          var updateDroppableIsCombineEnabled = function updateDroppableIsCombineEnabled(id, isCombineEnabled) {
            if (!collection) {
              return;
            }
            !registry.droppable.exists(id) ? invariant(false) : void 0;
            callbacks.updateDroppableIsCombineEnabled({
              id: id,
              isCombineEnabled: isCombineEnabled
            });
          };
          var updateDroppableScroll = function updateDroppableScroll(id, newScroll) {
            if (!collection) {
              return;
            }
            !registry.droppable.exists(id) ? invariant(false) : void 0;
            callbacks.updateDroppableScroll({
              id: id,
              newScroll: newScroll
            });
          };
          var scrollDroppable = function scrollDroppable(id, change) {
            if (!collection) {
              return;
            }
            registry.droppable.getById(id).callbacks.scroll(change);
          };
          var stopPublishing = function stopPublishing() {
            if (!collection) {
              return;
            }
            publisher.stop();
            var home = collection.critical.droppable;
            registry.droppable.getAllByType(home.type).forEach(function (entry) {
              return entry.callbacks.dragStopped();
            });
            collection.unsubscribe();
            collection = null;
          };
          var subscriber = function subscriber(event) {
            !collection ? invariant(false) : void 0;
            var dragging = collection.critical.draggable;
            if (event.type === 'ADDITION') {
              if (shouldPublishUpdate(registry, dragging, event.value)) {
                publisher.add(event.value);
              }
            }
            if (event.type === 'REMOVAL') {
              if (shouldPublishUpdate(registry, dragging, event.value)) {
                publisher.remove(event.value);
              }
            }
          };
          var startPublishing = function startPublishing(request) {
            !!collection ? invariant(false) : void 0;
            var entry = registry.draggable.getById(request.draggableId);
            var home = registry.droppable.getById(entry.descriptor.droppableId);
            var critical = {
              draggable: entry.descriptor,
              droppable: home.descriptor
            };
            var unsubscribe = registry.subscribe(subscriber);
            collection = {
              critical: critical,
              unsubscribe: unsubscribe
            };
            return getInitialPublish({
              critical: critical,
              registry: registry,
              scrollOptions: request.scrollOptions
            });
          };
          var marshal = {
            updateDroppableIsEnabled: updateDroppableIsEnabled,
            updateDroppableIsCombineEnabled: updateDroppableIsCombineEnabled,
            scrollDroppable: scrollDroppable,
            updateDroppableScroll: updateDroppableScroll,
            startPublishing: startPublishing,
            stopPublishing: stopPublishing
          };
          return marshal;
        };
        var canStartDrag = function (state, id) {
          if (state.phase === 'IDLE') {
            return true;
          }
          if (state.phase !== 'DROP_ANIMATING') {
            return false;
          }
          if (state.completed.result.draggableId === id) {
            return false;
          }
          return state.completed.result.reason === 'DROP';
        };
        var scrollWindow = function (change) {
          window.scrollBy(change.x, change.y);
        };
        var getScrollableDroppables = memoizeOne(function (droppables) {
          return toDroppableList(droppables).filter(function (droppable) {
            if (!droppable.isEnabled) {
              return false;
            }
            if (!droppable.frame) {
              return false;
            }
            return true;
          });
        });
        var getScrollableDroppableOver = function getScrollableDroppableOver(target, droppables) {
          var maybe = find(getScrollableDroppables(droppables), function (droppable) {
            !droppable.frame ? invariant(false) : void 0;
            return isPositionInFrame(droppable.frame.pageMarginBox)(target);
          });
          return maybe;
        };
        var getBestScrollableDroppable = function (_ref) {
          var center = _ref.center,
            destination = _ref.destination,
            droppables = _ref.droppables;
          if (destination) {
            var _dimension = droppables[destination];
            if (!_dimension.frame) {
              return null;
            }
            return _dimension;
          }
          var dimension = getScrollableDroppableOver(center, droppables);
          return dimension;
        };
        var config = {
          startFromPercentage: 0.25,
          maxScrollAtPercentage: 0.05,
          maxPixelScroll: 28,
          ease: function ease(percentage) {
            return Math.pow(percentage, 2);
          },
          durationDampening: {
            stopDampeningAt: 1200,
            accelerateAt: 360
          }
        };
        var getDistanceThresholds = function (container, axis) {
          var startScrollingFrom = container[axis.size] * config.startFromPercentage;
          var maxScrollValueAt = container[axis.size] * config.maxScrollAtPercentage;
          var thresholds = {
            startScrollingFrom: startScrollingFrom,
            maxScrollValueAt: maxScrollValueAt
          };
          return thresholds;
        };
        var getPercentage = function (_ref) {
          var startOfRange = _ref.startOfRange,
            endOfRange = _ref.endOfRange,
            current = _ref.current;
          var range = endOfRange - startOfRange;
          if (range === 0) {
            return 0;
          }
          var currentInRange = current - startOfRange;
          var percentage = currentInRange / range;
          return percentage;
        };
        var minScroll = 1;
        var getValueFromDistance = function (distanceToEdge, thresholds) {
          if (distanceToEdge > thresholds.startScrollingFrom) {
            return 0;
          }
          if (distanceToEdge <= thresholds.maxScrollValueAt) {
            return config.maxPixelScroll;
          }
          if (distanceToEdge === thresholds.startScrollingFrom) {
            return minScroll;
          }
          var percentageFromMaxScrollValueAt = getPercentage({
            startOfRange: thresholds.maxScrollValueAt,
            endOfRange: thresholds.startScrollingFrom,
            current: distanceToEdge
          });
          var percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;
          var scroll = config.maxPixelScroll * config.ease(percentageFromStartScrollingFrom);
          return Math.ceil(scroll);
        };
        var accelerateAt = config.durationDampening.accelerateAt;
        var stopAt = config.durationDampening.stopDampeningAt;
        var dampenValueByTime = function (proposedScroll, dragStartTime) {
          var startOfRange = dragStartTime;
          var endOfRange = stopAt;
          var now = Date.now();
          var runTime = now - startOfRange;
          if (runTime >= stopAt) {
            return proposedScroll;
          }
          if (runTime < accelerateAt) {
            return minScroll;
          }
          var betweenAccelerateAtAndStopAtPercentage = getPercentage({
            startOfRange: accelerateAt,
            endOfRange: endOfRange,
            current: runTime
          });
          var scroll = proposedScroll * config.ease(betweenAccelerateAtAndStopAtPercentage);
          return Math.ceil(scroll);
        };
        var getValue$1 = function (_ref) {
          var distanceToEdge = _ref.distanceToEdge,
            thresholds = _ref.thresholds,
            dragStartTime = _ref.dragStartTime,
            shouldUseTimeDampening = _ref.shouldUseTimeDampening;
          var scroll = getValueFromDistance(distanceToEdge, thresholds);
          if (scroll === 0) {
            return 0;
          }
          if (!shouldUseTimeDampening) {
            return scroll;
          }
          return Math.max(dampenValueByTime(scroll, dragStartTime), minScroll);
        };
        var getScrollOnAxis = function (_ref) {
          var container = _ref.container,
            distanceToEdges = _ref.distanceToEdges,
            dragStartTime = _ref.dragStartTime,
            axis = _ref.axis,
            shouldUseTimeDampening = _ref.shouldUseTimeDampening;
          var thresholds = getDistanceThresholds(container, axis);
          var isCloserToEnd = distanceToEdges[axis.end] < distanceToEdges[axis.start];
          if (isCloserToEnd) {
            return getValue$1({
              distanceToEdge: distanceToEdges[axis.end],
              thresholds: thresholds,
              dragStartTime: dragStartTime,
              shouldUseTimeDampening: shouldUseTimeDampening
            });
          }
          return -1 * getValue$1({
            distanceToEdge: distanceToEdges[axis.start],
            thresholds: thresholds,
            dragStartTime: dragStartTime,
            shouldUseTimeDampening: shouldUseTimeDampening
          });
        };
        var adjustForSizeLimits = function (_ref) {
          var container = _ref.container,
            subject = _ref.subject,
            proposedScroll = _ref.proposedScroll;
          var isTooBigVertically = subject.height > container.height;
          var isTooBigHorizontally = subject.width > container.width;
          if (!isTooBigHorizontally && !isTooBigVertically) {
            return proposedScroll;
          }
          if (isTooBigHorizontally && isTooBigVertically) {
            return null;
          }
          return {
            x: isTooBigHorizontally ? 0 : proposedScroll.x,
            y: isTooBigVertically ? 0 : proposedScroll.y
          };
        };
        var clean$2 = apply(function (value) {
          return value === 0 ? 0 : value;
        });
        var getScroll = function (_ref) {
          var dragStartTime = _ref.dragStartTime,
            container = _ref.container,
            subject = _ref.subject,
            center = _ref.center,
            shouldUseTimeDampening = _ref.shouldUseTimeDampening;
          var distanceToEdges = {
            top: center.y - container.top,
            right: container.right - center.x,
            bottom: container.bottom - center.y,
            left: center.x - container.left
          };
          var y = getScrollOnAxis({
            container: container,
            distanceToEdges: distanceToEdges,
            dragStartTime: dragStartTime,
            axis: vertical,
            shouldUseTimeDampening: shouldUseTimeDampening
          });
          var x = getScrollOnAxis({
            container: container,
            distanceToEdges: distanceToEdges,
            dragStartTime: dragStartTime,
            axis: horizontal,
            shouldUseTimeDampening: shouldUseTimeDampening
          });
          var required = clean$2({
            x: x,
            y: y
          });
          if (isEqual(required, origin)) {
            return null;
          }
          var limited = adjustForSizeLimits({
            container: container,
            subject: subject,
            proposedScroll: required
          });
          if (!limited) {
            return null;
          }
          return isEqual(limited, origin) ? null : limited;
        };
        var smallestSigned = apply(function (value) {
          if (value === 0) {
            return 0;
          }
          return value > 0 ? 1 : -1;
        });
        var getOverlap = function () {
          var getRemainder = function getRemainder(target, max) {
            if (target < 0) {
              return target;
            }
            if (target > max) {
              return target - max;
            }
            return 0;
          };
          return function (_ref) {
            var current = _ref.current,
              max = _ref.max,
              change = _ref.change;
            var targetScroll = add(current, change);
            var overlap = {
              x: getRemainder(targetScroll.x, max.x),
              y: getRemainder(targetScroll.y, max.y)
            };
            if (isEqual(overlap, origin)) {
              return null;
            }
            return overlap;
          };
        }();
        var canPartiallyScroll = function canPartiallyScroll(_ref2) {
          var rawMax = _ref2.max,
            current = _ref2.current,
            change = _ref2.change;
          var max = {
            x: Math.max(current.x, rawMax.x),
            y: Math.max(current.y, rawMax.y)
          };
          var smallestChange = smallestSigned(change);
          var overlap = getOverlap({
            max: max,
            current: current,
            change: smallestChange
          });
          if (!overlap) {
            return true;
          }
          if (smallestChange.x !== 0 && overlap.x === 0) {
            return true;
          }
          if (smallestChange.y !== 0 && overlap.y === 0) {
            return true;
          }
          return false;
        };
        var canScrollWindow = function canScrollWindow(viewport, change) {
          return canPartiallyScroll({
            current: viewport.scroll.current,
            max: viewport.scroll.max,
            change: change
          });
        };
        var getWindowOverlap = function getWindowOverlap(viewport, change) {
          if (!canScrollWindow(viewport, change)) {
            return null;
          }
          var max = viewport.scroll.max;
          var current = viewport.scroll.current;
          return getOverlap({
            current: current,
            max: max,
            change: change
          });
        };
        var canScrollDroppable = function canScrollDroppable(droppable, change) {
          var frame = droppable.frame;
          if (!frame) {
            return false;
          }
          return canPartiallyScroll({
            current: frame.scroll.current,
            max: frame.scroll.max,
            change: change
          });
        };
        var getDroppableOverlap = function getDroppableOverlap(droppable, change) {
          var frame = droppable.frame;
          if (!frame) {
            return null;
          }
          if (!canScrollDroppable(droppable, change)) {
            return null;
          }
          return getOverlap({
            current: frame.scroll.current,
            max: frame.scroll.max,
            change: change
          });
        };
        var getWindowScrollChange = function (_ref) {
          var viewport = _ref.viewport,
            subject = _ref.subject,
            center = _ref.center,
            dragStartTime = _ref.dragStartTime,
            shouldUseTimeDampening = _ref.shouldUseTimeDampening;
          var scroll = getScroll({
            dragStartTime: dragStartTime,
            container: viewport.frame,
            subject: subject,
            center: center,
            shouldUseTimeDampening: shouldUseTimeDampening
          });
          return scroll && canScrollWindow(viewport, scroll) ? scroll : null;
        };
        var getDroppableScrollChange = function (_ref) {
          var droppable = _ref.droppable,
            subject = _ref.subject,
            center = _ref.center,
            dragStartTime = _ref.dragStartTime,
            shouldUseTimeDampening = _ref.shouldUseTimeDampening;
          var frame = droppable.frame;
          if (!frame) {
            return null;
          }
          var scroll = getScroll({
            dragStartTime: dragStartTime,
            container: frame.pageMarginBox,
            subject: subject,
            center: center,
            shouldUseTimeDampening: shouldUseTimeDampening
          });
          return scroll && canScrollDroppable(droppable, scroll) ? scroll : null;
        };
        var scroll$1 = function (_ref) {
          var state = _ref.state,
            dragStartTime = _ref.dragStartTime,
            shouldUseTimeDampening = _ref.shouldUseTimeDampening,
            scrollWindow = _ref.scrollWindow,
            scrollDroppable = _ref.scrollDroppable;
          var center = state.current.page.borderBoxCenter;
          var draggable = state.dimensions.draggables[state.critical.draggable.id];
          var subject = draggable.page.marginBox;
          if (state.isWindowScrollAllowed) {
            var viewport = state.viewport;
            var _change = getWindowScrollChange({
              dragStartTime: dragStartTime,
              viewport: viewport,
              subject: subject,
              center: center,
              shouldUseTimeDampening: shouldUseTimeDampening
            });
            if (_change) {
              scrollWindow(_change);
              return;
            }
          }
          var droppable = getBestScrollableDroppable({
            center: center,
            destination: whatIsDraggedOver(state.impact),
            droppables: state.dimensions.droppables
          });
          if (!droppable) {
            return;
          }
          var change = getDroppableScrollChange({
            dragStartTime: dragStartTime,
            droppable: droppable,
            subject: subject,
            center: center,
            shouldUseTimeDampening: shouldUseTimeDampening
          });
          if (change) {
            scrollDroppable(droppable.descriptor.id, change);
          }
        };
        var createFluidScroller = function (_ref) {
          var scrollWindow = _ref.scrollWindow,
            scrollDroppable = _ref.scrollDroppable;
          var scheduleWindowScroll = rafSchd$1(scrollWindow);
          var scheduleDroppableScroll = rafSchd$1(scrollDroppable);
          var dragging = null;
          var tryScroll = function tryScroll(state) {
            !dragging ? invariant(false) : void 0;
            var _dragging = dragging,
              shouldUseTimeDampening = _dragging.shouldUseTimeDampening,
              dragStartTime = _dragging.dragStartTime;
            scroll$1({
              state: state,
              scrollWindow: scheduleWindowScroll,
              scrollDroppable: scheduleDroppableScroll,
              dragStartTime: dragStartTime,
              shouldUseTimeDampening: shouldUseTimeDampening
            });
          };
          var start$1 = function start$1(state) {
            !!dragging ? invariant(false) : void 0;
            var dragStartTime = Date.now();
            var wasScrollNeeded = false;
            var fakeScrollCallback = function fakeScrollCallback() {
              wasScrollNeeded = true;
            };
            scroll$1({
              state: state,
              dragStartTime: 0,
              shouldUseTimeDampening: false,
              scrollWindow: fakeScrollCallback,
              scrollDroppable: fakeScrollCallback
            });
            dragging = {
              dragStartTime: dragStartTime,
              shouldUseTimeDampening: wasScrollNeeded
            };
            if (wasScrollNeeded) {
              tryScroll(state);
            }
          };
          var stop = function stop() {
            if (!dragging) {
              return;
            }
            scheduleWindowScroll.cancel();
            scheduleDroppableScroll.cancel();
            dragging = null;
          };
          return {
            start: start$1,
            stop: stop,
            scroll: tryScroll
          };
        };
        var createJumpScroller = function (_ref) {
          var move = _ref.move,
            scrollDroppable = _ref.scrollDroppable,
            scrollWindow = _ref.scrollWindow;
          var moveByOffset = function moveByOffset(state, offset) {
            var client = add(state.current.client.selection, offset);
            move({
              client: client
            });
          };
          var scrollDroppableAsMuchAsItCan = function scrollDroppableAsMuchAsItCan(droppable, change) {
            if (!canScrollDroppable(droppable, change)) {
              return change;
            }
            var overlap = getDroppableOverlap(droppable, change);
            if (!overlap) {
              scrollDroppable(droppable.descriptor.id, change);
              return null;
            }
            var whatTheDroppableCanScroll = subtract(change, overlap);
            scrollDroppable(droppable.descriptor.id, whatTheDroppableCanScroll);
            var remainder = subtract(change, whatTheDroppableCanScroll);
            return remainder;
          };
          var scrollWindowAsMuchAsItCan = function scrollWindowAsMuchAsItCan(isWindowScrollAllowed, viewport, change) {
            if (!isWindowScrollAllowed) {
              return change;
            }
            if (!canScrollWindow(viewport, change)) {
              return change;
            }
            var overlap = getWindowOverlap(viewport, change);
            if (!overlap) {
              scrollWindow(change);
              return null;
            }
            var whatTheWindowCanScroll = subtract(change, overlap);
            scrollWindow(whatTheWindowCanScroll);
            var remainder = subtract(change, whatTheWindowCanScroll);
            return remainder;
          };
          var jumpScroller = function jumpScroller(state) {
            var request = state.scrollJumpRequest;
            if (!request) {
              return;
            }
            var destination = whatIsDraggedOver(state.impact);
            !destination ? invariant(false) : void 0;
            var droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request);
            if (!droppableRemainder) {
              return;
            }
            var viewport = state.viewport;
            var windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport, droppableRemainder);
            if (!windowRemainder) {
              return;
            }
            moveByOffset(state, windowRemainder);
          };
          return jumpScroller;
        };
        var createAutoScroller = function (_ref) {
          var scrollDroppable = _ref.scrollDroppable,
            scrollWindow = _ref.scrollWindow,
            move = _ref.move;
          var fluidScroller = createFluidScroller({
            scrollWindow: scrollWindow,
            scrollDroppable: scrollDroppable
          });
          var jumpScroll = createJumpScroller({
            move: move,
            scrollWindow: scrollWindow,
            scrollDroppable: scrollDroppable
          });
          var scroll = function scroll(state) {
            if (state.phase !== 'DRAGGING') {
              return;
            }
            if (state.movementMode === 'FLUID') {
              fluidScroller.scroll(state);
              return;
            }
            if (!state.scrollJumpRequest) {
              return;
            }
            jumpScroll(state);
          };
          var scroller = {
            scroll: scroll,
            start: fluidScroller.start,
            stop: fluidScroller.stop
          };
          return scroller;
        };
        var prefix$1$1 = 'data-rbd';
        var dragHandle = function () {
          var base = prefix$1$1 + "-drag-handle";
          return {
            base: base,
            draggableId: base + "-draggable-id",
            contextId: base + "-context-id"
          };
        }();
        var draggable = function () {
          var base = prefix$1$1 + "-draggable";
          return {
            base: base,
            contextId: base + "-context-id",
            id: base + "-id"
          };
        }();
        var droppable = function () {
          var base = prefix$1$1 + "-droppable";
          return {
            base: base,
            contextId: base + "-context-id",
            id: base + "-id"
          };
        }();
        var scrollContainer = {
          contextId: prefix$1$1 + "-scroll-container-context-id"
        };
        var makeGetSelector = function makeGetSelector(context) {
          return function (attribute) {
            return "[" + attribute + "=\"" + context + "\"]";
          };
        };
        var getStyles = function getStyles(rules, property) {
          return rules.map(function (rule) {
            var value = rule.styles[property];
            if (!value) {
              return '';
            }
            return rule.selector + " { " + value + " }";
          }).join(' ');
        };
        var noPointerEvents = 'pointer-events: none;';
        var getStyles$1 = function (contextId) {
          var getSelector = makeGetSelector(contextId);
          var dragHandle$1 = function () {
            var grabCursor = "\n      cursor: -webkit-grab;\n      cursor: grab;\n    ";
            return {
              selector: getSelector(dragHandle.contextId),
              styles: {
                always: "\n          -webkit-touch-callout: none;\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\n          touch-action: manipulation;\n        ",
                resting: grabCursor,
                dragging: noPointerEvents,
                dropAnimating: grabCursor
              }
            };
          }();
          var draggable$1 = function () {
            var transition = "\n      transition: " + transitions.outOfTheWay + ";\n    ";
            return {
              selector: getSelector(draggable.contextId),
              styles: {
                dragging: transition,
                dropAnimating: transition,
                userCancel: transition
              }
            };
          }();
          var droppable$1 = {
            selector: getSelector(droppable.contextId),
            styles: {
              always: "overflow-anchor: none;"
            }
          };
          var body = {
            selector: 'body',
            styles: {
              dragging: "\n        cursor: grabbing;\n        cursor: -webkit-grabbing;\n        user-select: none;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        overflow-anchor: none;\n      "
            }
          };
          var rules = [draggable$1, dragHandle$1, droppable$1, body];
          return {
            always: getStyles(rules, 'always'),
            resting: getStyles(rules, 'resting'),
            dragging: getStyles(rules, 'dragging'),
            dropAnimating: getStyles(rules, 'dropAnimating'),
            userCancel: getStyles(rules, 'userCancel')
          };
        };
        var useIsomorphicLayoutEffect$1 = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? reactExports.useLayoutEffect : reactExports.useEffect;
        var getHead = function getHead() {
          var head = document.querySelector('head');
          !head ? invariant(false) : void 0;
          return head;
        };
        var createStyleEl = function createStyleEl(nonce) {
          var el = document.createElement('style');
          if (nonce) {
            el.setAttribute('nonce', nonce);
          }
          el.type = 'text/css';
          return el;
        };
        function useStyleMarshal(contextId, nonce) {
          var styles = useMemo(function () {
            return getStyles$1(contextId);
          }, [contextId]);
          var alwaysRef = reactExports.useRef(null);
          var dynamicRef = reactExports.useRef(null);
          var setDynamicStyle = useCallback(memoizeOne(function (proposed) {
            var el = dynamicRef.current;
            !el ? invariant(false) : void 0;
            el.textContent = proposed;
          }), []);
          var setAlwaysStyle = useCallback(function (proposed) {
            var el = alwaysRef.current;
            !el ? invariant(false) : void 0;
            el.textContent = proposed;
          }, []);
          useIsomorphicLayoutEffect$1(function () {
            !(!alwaysRef.current && !dynamicRef.current) ? invariant(false) : void 0;
            var always = createStyleEl(nonce);
            var dynamic = createStyleEl(nonce);
            alwaysRef.current = always;
            dynamicRef.current = dynamic;
            always.setAttribute(prefix$1$1 + "-always", contextId);
            dynamic.setAttribute(prefix$1$1 + "-dynamic", contextId);
            getHead().appendChild(always);
            getHead().appendChild(dynamic);
            setAlwaysStyle(styles.always);
            setDynamicStyle(styles.resting);
            return function () {
              var remove = function remove(ref) {
                var current = ref.current;
                !current ? invariant(false) : void 0;
                getHead().removeChild(current);
                ref.current = null;
              };
              remove(alwaysRef);
              remove(dynamicRef);
            };
          }, [nonce, setAlwaysStyle, setDynamicStyle, styles.always, styles.resting, contextId]);
          var dragging = useCallback(function () {
            return setDynamicStyle(styles.dragging);
          }, [setDynamicStyle, styles.dragging]);
          var dropping = useCallback(function (reason) {
            if (reason === 'DROP') {
              setDynamicStyle(styles.dropAnimating);
              return;
            }
            setDynamicStyle(styles.userCancel);
          }, [setDynamicStyle, styles.dropAnimating, styles.userCancel]);
          var resting = useCallback(function () {
            if (!dynamicRef.current) {
              return;
            }
            setDynamicStyle(styles.resting);
          }, [setDynamicStyle, styles.resting]);
          var marshal = useMemo(function () {
            return {
              dragging: dragging,
              dropping: dropping,
              resting: resting
            };
          }, [dragging, dropping, resting]);
          return marshal;
        }
        var getWindowFromEl = function (el) {
          return el && el.ownerDocument ? el.ownerDocument.defaultView : window;
        };
        function isHtmlElement(el) {
          return el instanceof getWindowFromEl(el).HTMLElement;
        }
        function findDragHandle(contextId, draggableId) {
          var selector = "[" + dragHandle.contextId + "=\"" + contextId + "\"]";
          var possible = toArray$1(document.querySelectorAll(selector));
          if (!possible.length) {
            return null;
          }
          var handle = find(possible, function (el) {
            return el.getAttribute(dragHandle.draggableId) === draggableId;
          });
          if (!handle) {
            return null;
          }
          if (!isHtmlElement(handle)) {
            return null;
          }
          return handle;
        }
        function useFocusMarshal(contextId) {
          var entriesRef = reactExports.useRef({});
          var recordRef = reactExports.useRef(null);
          var restoreFocusFrameRef = reactExports.useRef(null);
          var isMountedRef = reactExports.useRef(false);
          var register = useCallback(function register(id, focus) {
            var entry = {
              id: id,
              focus: focus
            };
            entriesRef.current[id] = entry;
            return function unregister() {
              var entries = entriesRef.current;
              var current = entries[id];
              if (current !== entry) {
                delete entries[id];
              }
            };
          }, []);
          var tryGiveFocus = useCallback(function tryGiveFocus(tryGiveFocusTo) {
            var handle = findDragHandle(contextId, tryGiveFocusTo);
            if (handle && handle !== document.activeElement) {
              handle.focus();
            }
          }, [contextId]);
          var tryShiftRecord = useCallback(function tryShiftRecord(previous, redirectTo) {
            if (recordRef.current === previous) {
              recordRef.current = redirectTo;
            }
          }, []);
          var tryRestoreFocusRecorded = useCallback(function tryRestoreFocusRecorded() {
            if (restoreFocusFrameRef.current) {
              return;
            }
            if (!isMountedRef.current) {
              return;
            }
            restoreFocusFrameRef.current = requestAnimationFrame(function () {
              restoreFocusFrameRef.current = null;
              var record = recordRef.current;
              if (record) {
                tryGiveFocus(record);
              }
            });
          }, [tryGiveFocus]);
          var tryRecordFocus = useCallback(function tryRecordFocus(id) {
            recordRef.current = null;
            var focused = document.activeElement;
            if (!focused) {
              return;
            }
            if (focused.getAttribute(dragHandle.draggableId) !== id) {
              return;
            }
            recordRef.current = id;
          }, []);
          useIsomorphicLayoutEffect$1(function () {
            isMountedRef.current = true;
            return function clearFrameOnUnmount() {
              isMountedRef.current = false;
              var frameId = restoreFocusFrameRef.current;
              if (frameId) {
                cancelAnimationFrame(frameId);
              }
            };
          }, []);
          var marshal = useMemo(function () {
            return {
              register: register,
              tryRecordFocus: tryRecordFocus,
              tryRestoreFocusRecorded: tryRestoreFocusRecorded,
              tryShiftRecord: tryShiftRecord
            };
          }, [register, tryRecordFocus, tryRestoreFocusRecorded, tryShiftRecord]);
          return marshal;
        }
        function createRegistry() {
          var entries = {
            draggables: {},
            droppables: {}
          };
          var subscribers = [];
          function subscribe(cb) {
            subscribers.push(cb);
            return function unsubscribe() {
              var index = subscribers.indexOf(cb);
              if (index === -1) {
                return;
              }
              subscribers.splice(index, 1);
            };
          }
          function notify(event) {
            if (subscribers.length) {
              subscribers.forEach(function (cb) {
                return cb(event);
              });
            }
          }
          function findDraggableById(id) {
            return entries.draggables[id] || null;
          }
          function getDraggableById(id) {
            var entry = findDraggableById(id);
            !entry ? invariant(false) : void 0;
            return entry;
          }
          var draggableAPI = {
            register: function register(entry) {
              entries.draggables[entry.descriptor.id] = entry;
              notify({
                type: 'ADDITION',
                value: entry
              });
            },
            update: function update(entry, last) {
              var current = entries.draggables[last.descriptor.id];
              if (!current) {
                return;
              }
              if (current.uniqueId !== entry.uniqueId) {
                return;
              }
              delete entries.draggables[last.descriptor.id];
              entries.draggables[entry.descriptor.id] = entry;
            },
            unregister: function unregister(entry) {
              var draggableId = entry.descriptor.id;
              var current = findDraggableById(draggableId);
              if (!current) {
                return;
              }
              if (entry.uniqueId !== current.uniqueId) {
                return;
              }
              delete entries.draggables[draggableId];
              notify({
                type: 'REMOVAL',
                value: entry
              });
            },
            getById: getDraggableById,
            findById: findDraggableById,
            exists: function exists(id) {
              return Boolean(findDraggableById(id));
            },
            getAllByType: function getAllByType(type) {
              return values$1(entries.draggables).filter(function (entry) {
                return entry.descriptor.type === type;
              });
            }
          };
          function findDroppableById(id) {
            return entries.droppables[id] || null;
          }
          function getDroppableById(id) {
            var entry = findDroppableById(id);
            !entry ? invariant(false) : void 0;
            return entry;
          }
          var droppableAPI = {
            register: function register(entry) {
              entries.droppables[entry.descriptor.id] = entry;
            },
            unregister: function unregister(entry) {
              var current = findDroppableById(entry.descriptor.id);
              if (!current) {
                return;
              }
              if (entry.uniqueId !== current.uniqueId) {
                return;
              }
              delete entries.droppables[entry.descriptor.id];
            },
            getById: getDroppableById,
            findById: findDroppableById,
            exists: function exists(id) {
              return Boolean(findDroppableById(id));
            },
            getAllByType: function getAllByType(type) {
              return values$1(entries.droppables).filter(function (entry) {
                return entry.descriptor.type === type;
              });
            }
          };
          function clean() {
            entries.draggables = {};
            entries.droppables = {};
            subscribers.length = 0;
          }
          return {
            draggable: draggableAPI,
            droppable: droppableAPI,
            subscribe: subscribe,
            clean: clean
          };
        }
        function useRegistry() {
          var registry = useMemo(createRegistry, []);
          reactExports.useEffect(function () {
            return function unmount() {
              requestAnimationFrame(registry.clean);
            };
          }, [registry]);
          return registry;
        }
        var StoreContext = React.createContext(null);
        var getBodyElement = function () {
          var body = document.body;
          !body ? invariant(false) : void 0;
          return body;
        };
        var visuallyHidden = {
          position: 'absolute',
          width: '1px',
          height: '1px',
          margin: '-1px',
          border: '0',
          padding: '0',
          overflow: 'hidden',
          clip: 'rect(0 0 0 0)',
          'clip-path': 'inset(100%)'
        };
        var getId = function getId(contextId) {
          return "rbd-announcement-" + contextId;
        };
        function useAnnouncer(contextId) {
          var id = useMemo(function () {
            return getId(contextId);
          }, [contextId]);
          var ref = reactExports.useRef(null);
          reactExports.useEffect(function setup() {
            var el = document.createElement('div');
            ref.current = el;
            el.id = id;
            el.setAttribute('aria-live', 'assertive');
            el.setAttribute('aria-atomic', 'true');
            _extends(el.style, visuallyHidden);
            getBodyElement().appendChild(el);
            return function cleanup() {
              setTimeout(function remove() {
                var body = getBodyElement();
                if (body.contains(el)) {
                  body.removeChild(el);
                }
                if (el === ref.current) {
                  ref.current = null;
                }
              });
            };
          }, [id]);
          var announce = useCallback(function (message) {
            var el = ref.current;
            if (el) {
              el.textContent = message;
              return;
            }
          }, []);
          return announce;
        }
        var count = 0;
        var defaults$4 = {
          separator: '::'
        };
        function useUniqueId(prefix, options) {
          if (options === void 0) {
            options = defaults$4;
          }
          return useMemo(function () {
            return "" + prefix + options.separator + count++;
          }, [options.separator, prefix]);
        }
        function getElementId(_ref) {
          var contextId = _ref.contextId,
            uniqueId = _ref.uniqueId;
          return "rbd-hidden-text-" + contextId + "-" + uniqueId;
        }
        function useHiddenTextElement(_ref2) {
          var contextId = _ref2.contextId,
            text = _ref2.text;
          var uniqueId = useUniqueId('hidden-text', {
            separator: '-'
          });
          var id = useMemo(function () {
            return getElementId({
              contextId: contextId,
              uniqueId: uniqueId
            });
          }, [uniqueId, contextId]);
          reactExports.useEffect(function mount() {
            var el = document.createElement('div');
            el.id = id;
            el.textContent = text;
            el.style.display = 'none';
            getBodyElement().appendChild(el);
            return function unmount() {
              var body = getBodyElement();
              if (body.contains(el)) {
                body.removeChild(el);
              }
            };
          }, [id, text]);
          return id;
        }
        var AppContext = React.createContext(null);
        function usePrevious(current) {
          var ref = reactExports.useRef(current);
          reactExports.useEffect(function () {
            ref.current = current;
          });
          return ref;
        }
        function create() {
          var lock = null;
          function isClaimed() {
            return Boolean(lock);
          }
          function isActive(value) {
            return value === lock;
          }
          function claim(abandon) {
            !!lock ? invariant(false) : void 0;
            var newLock = {
              abandon: abandon
            };
            lock = newLock;
            return newLock;
          }
          function release() {
            !lock ? invariant(false) : void 0;
            lock = null;
          }
          function tryAbandon() {
            if (lock) {
              lock.abandon();
              release();
            }
          }
          return {
            isClaimed: isClaimed,
            isActive: isActive,
            claim: claim,
            release: release,
            tryAbandon: tryAbandon
          };
        }
        var tab = 9;
        var enter = 13;
        var escape$1 = 27;
        var space = 32;
        var pageUp = 33;
        var pageDown = 34;
        var end = 35;
        var home = 36;
        var arrowLeft = 37;
        var arrowUp = 38;
        var arrowRight = 39;
        var arrowDown = 40;
        var _preventedKeys;
        var preventedKeys = (_preventedKeys = {}, _preventedKeys[enter] = true, _preventedKeys[tab] = true, _preventedKeys);
        var preventStandardKeyEvents = function (event) {
          if (preventedKeys[event.keyCode]) {
            event.preventDefault();
          }
        };
        var supportedEventName = function () {
          var base = 'visibilitychange';
          if (typeof document === 'undefined') {
            return base;
          }
          var candidates = [base, "ms" + base, "webkit" + base, "moz" + base, "o" + base];
          var supported = find(candidates, function (eventName) {
            return "on" + eventName in document;
          });
          return supported || base;
        }();
        var primaryButton = 0;
        var sloppyClickThreshold = 5;
        function isSloppyClickThresholdExceeded(original, current) {
          return Math.abs(current.x - original.x) >= sloppyClickThreshold || Math.abs(current.y - original.y) >= sloppyClickThreshold;
        }
        var idle$1 = {
          type: 'IDLE'
        };
        function getCaptureBindings(_ref) {
          var cancel = _ref.cancel,
            completed = _ref.completed,
            getPhase = _ref.getPhase,
            setPhase = _ref.setPhase;
          return [{
            eventName: 'mousemove',
            fn: function fn(event) {
              var button = event.button,
                clientX = event.clientX,
                clientY = event.clientY;
              if (button !== primaryButton) {
                return;
              }
              var point = {
                x: clientX,
                y: clientY
              };
              var phase = getPhase();
              if (phase.type === 'DRAGGING') {
                event.preventDefault();
                phase.actions.move(point);
                return;
              }
              !(phase.type === 'PENDING') ? invariant(false) : void 0;
              var pending = phase.point;
              if (!isSloppyClickThresholdExceeded(pending, point)) {
                return;
              }
              event.preventDefault();
              var actions = phase.actions.fluidLift(point);
              setPhase({
                type: 'DRAGGING',
                actions: actions
              });
            }
          }, {
            eventName: 'mouseup',
            fn: function fn(event) {
              var phase = getPhase();
              if (phase.type !== 'DRAGGING') {
                cancel();
                return;
              }
              event.preventDefault();
              phase.actions.drop({
                shouldBlockNextClick: true
              });
              completed();
            }
          }, {
            eventName: 'mousedown',
            fn: function fn(event) {
              if (getPhase().type === 'DRAGGING') {
                event.preventDefault();
              }
              cancel();
            }
          }, {
            eventName: 'keydown',
            fn: function fn(event) {
              var phase = getPhase();
              if (phase.type === 'PENDING') {
                cancel();
                return;
              }
              if (event.keyCode === escape$1) {
                event.preventDefault();
                cancel();
                return;
              }
              preventStandardKeyEvents(event);
            }
          }, {
            eventName: 'resize',
            fn: cancel
          }, {
            eventName: 'scroll',
            options: {
              passive: true,
              capture: false
            },
            fn: function fn() {
              if (getPhase().type === 'PENDING') {
                cancel();
              }
            }
          }, {
            eventName: 'webkitmouseforcedown',
            fn: function fn(event) {
              var phase = getPhase();
              !(phase.type !== 'IDLE') ? invariant(false) : void 0;
              if (phase.actions.shouldRespectForcePress()) {
                cancel();
                return;
              }
              event.preventDefault();
            }
          }, {
            eventName: supportedEventName,
            fn: cancel
          }];
        }
        function useMouseSensor(api) {
          var phaseRef = reactExports.useRef(idle$1);
          var unbindEventsRef = reactExports.useRef(noop);
          var startCaptureBinding = useMemo(function () {
            return {
              eventName: 'mousedown',
              fn: function onMouseDown(event) {
                if (event.defaultPrevented) {
                  return;
                }
                if (event.button !== primaryButton) {
                  return;
                }
                if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {
                  return;
                }
                var draggableId = api.findClosestDraggableId(event);
                if (!draggableId) {
                  return;
                }
                var actions = api.tryGetLock(draggableId, stop, {
                  sourceEvent: event
                });
                if (!actions) {
                  return;
                }
                event.preventDefault();
                var point = {
                  x: event.clientX,
                  y: event.clientY
                };
                unbindEventsRef.current();
                startPendingDrag(actions, point);
              }
            };
          }, [api]);
          var preventForcePressBinding = useMemo(function () {
            return {
              eventName: 'webkitmouseforcewillbegin',
              fn: function fn(event) {
                if (event.defaultPrevented) {
                  return;
                }
                var id = api.findClosestDraggableId(event);
                if (!id) {
                  return;
                }
                var options = api.findOptionsForDraggable(id);
                if (!options) {
                  return;
                }
                if (options.shouldRespectForcePress) {
                  return;
                }
                if (!api.canGetLock(id)) {
                  return;
                }
                event.preventDefault();
              }
            };
          }, [api]);
          var listenForCapture = useCallback(function listenForCapture() {
            var options = {
              passive: false,
              capture: true
            };
            unbindEventsRef.current = bindEvents(window, [preventForcePressBinding, startCaptureBinding], options);
          }, [preventForcePressBinding, startCaptureBinding]);
          var stop = useCallback(function () {
            var current = phaseRef.current;
            if (current.type === 'IDLE') {
              return;
            }
            phaseRef.current = idle$1;
            unbindEventsRef.current();
            listenForCapture();
          }, [listenForCapture]);
          var cancel = useCallback(function () {
            var phase = phaseRef.current;
            stop();
            if (phase.type === 'DRAGGING') {
              phase.actions.cancel({
                shouldBlockNextClick: true
              });
            }
            if (phase.type === 'PENDING') {
              phase.actions.abort();
            }
          }, [stop]);
          var bindCapturingEvents = useCallback(function bindCapturingEvents() {
            var options = {
              capture: true,
              passive: false
            };
            var bindings = getCaptureBindings({
              cancel: cancel,
              completed: stop,
              getPhase: function getPhase() {
                return phaseRef.current;
              },
              setPhase: function setPhase(phase) {
                phaseRef.current = phase;
              }
            });
            unbindEventsRef.current = bindEvents(window, bindings, options);
          }, [cancel, stop]);
          var startPendingDrag = useCallback(function startPendingDrag(actions, point) {
            !(phaseRef.current.type === 'IDLE') ? invariant(false) : void 0;
            phaseRef.current = {
              type: 'PENDING',
              point: point,
              actions: actions
            };
            bindCapturingEvents();
          }, [bindCapturingEvents]);
          useIsomorphicLayoutEffect$1(function mount() {
            listenForCapture();
            return function unmount() {
              unbindEventsRef.current();
            };
          }, [listenForCapture]);
        }
        var _scrollJumpKeys;
        function noop$1() {}
        var scrollJumpKeys = (_scrollJumpKeys = {}, _scrollJumpKeys[pageDown] = true, _scrollJumpKeys[pageUp] = true, _scrollJumpKeys[home] = true, _scrollJumpKeys[end] = true, _scrollJumpKeys);
        function getDraggingBindings(actions, stop) {
          function cancel() {
            stop();
            actions.cancel();
          }
          function drop() {
            stop();
            actions.drop();
          }
          return [{
            eventName: 'keydown',
            fn: function fn(event) {
              if (event.keyCode === escape$1) {
                event.preventDefault();
                cancel();
                return;
              }
              if (event.keyCode === space) {
                event.preventDefault();
                drop();
                return;
              }
              if (event.keyCode === arrowDown) {
                event.preventDefault();
                actions.moveDown();
                return;
              }
              if (event.keyCode === arrowUp) {
                event.preventDefault();
                actions.moveUp();
                return;
              }
              if (event.keyCode === arrowRight) {
                event.preventDefault();
                actions.moveRight();
                return;
              }
              if (event.keyCode === arrowLeft) {
                event.preventDefault();
                actions.moveLeft();
                return;
              }
              if (scrollJumpKeys[event.keyCode]) {
                event.preventDefault();
                return;
              }
              preventStandardKeyEvents(event);
            }
          }, {
            eventName: 'mousedown',
            fn: cancel
          }, {
            eventName: 'mouseup',
            fn: cancel
          }, {
            eventName: 'click',
            fn: cancel
          }, {
            eventName: 'touchstart',
            fn: cancel
          }, {
            eventName: 'resize',
            fn: cancel
          }, {
            eventName: 'wheel',
            fn: cancel,
            options: {
              passive: true
            }
          }, {
            eventName: supportedEventName,
            fn: cancel
          }];
        }
        function useKeyboardSensor(api) {
          var unbindEventsRef = reactExports.useRef(noop$1);
          var startCaptureBinding = useMemo(function () {
            return {
              eventName: 'keydown',
              fn: function onKeyDown(event) {
                if (event.defaultPrevented) {
                  return;
                }
                if (event.keyCode !== space) {
                  return;
                }
                var draggableId = api.findClosestDraggableId(event);
                if (!draggableId) {
                  return;
                }
                var preDrag = api.tryGetLock(draggableId, stop, {
                  sourceEvent: event
                });
                if (!preDrag) {
                  return;
                }
                event.preventDefault();
                var isCapturing = true;
                var actions = preDrag.snapLift();
                unbindEventsRef.current();
                function stop() {
                  !isCapturing ? invariant(false) : void 0;
                  isCapturing = false;
                  unbindEventsRef.current();
                  listenForCapture();
                }
                unbindEventsRef.current = bindEvents(window, getDraggingBindings(actions, stop), {
                  capture: true,
                  passive: false
                });
              }
            };
          }, [api]);
          var listenForCapture = useCallback(function tryStartCapture() {
            var options = {
              passive: false,
              capture: true
            };
            unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);
          }, [startCaptureBinding]);
          useIsomorphicLayoutEffect$1(function mount() {
            listenForCapture();
            return function unmount() {
              unbindEventsRef.current();
            };
          }, [listenForCapture]);
        }
        var idle$2 = {
          type: 'IDLE'
        };
        var timeForLongPress = 120;
        var forcePressThreshold = 0.15;
        function getWindowBindings(_ref) {
          var cancel = _ref.cancel,
            getPhase = _ref.getPhase;
          return [{
            eventName: 'orientationchange',
            fn: cancel
          }, {
            eventName: 'resize',
            fn: cancel
          }, {
            eventName: 'contextmenu',
            fn: function fn(event) {
              event.preventDefault();
            }
          }, {
            eventName: 'keydown',
            fn: function fn(event) {
              if (getPhase().type !== 'DRAGGING') {
                cancel();
                return;
              }
              if (event.keyCode === escape$1) {
                event.preventDefault();
              }
              cancel();
            }
          }, {
            eventName: supportedEventName,
            fn: cancel
          }];
        }
        function getHandleBindings(_ref2) {
          var cancel = _ref2.cancel,
            completed = _ref2.completed,
            getPhase = _ref2.getPhase;
          return [{
            eventName: 'touchmove',
            options: {
              capture: false
            },
            fn: function fn(event) {
              var phase = getPhase();
              if (phase.type !== 'DRAGGING') {
                cancel();
                return;
              }
              phase.hasMoved = true;
              var _event$touches$ = event.touches[0],
                clientX = _event$touches$.clientX,
                clientY = _event$touches$.clientY;
              var point = {
                x: clientX,
                y: clientY
              };
              event.preventDefault();
              phase.actions.move(point);
            }
          }, {
            eventName: 'touchend',
            fn: function fn(event) {
              var phase = getPhase();
              if (phase.type !== 'DRAGGING') {
                cancel();
                return;
              }
              event.preventDefault();
              phase.actions.drop({
                shouldBlockNextClick: true
              });
              completed();
            }
          }, {
            eventName: 'touchcancel',
            fn: function fn(event) {
              if (getPhase().type !== 'DRAGGING') {
                cancel();
                return;
              }
              event.preventDefault();
              cancel();
            }
          }, {
            eventName: 'touchforcechange',
            fn: function fn(event) {
              var phase = getPhase();
              !(phase.type !== 'IDLE') ? invariant(false) : void 0;
              var touch = event.touches[0];
              if (!touch) {
                return;
              }
              var isForcePress = touch.force >= forcePressThreshold;
              if (!isForcePress) {
                return;
              }
              var shouldRespect = phase.actions.shouldRespectForcePress();
              if (phase.type === 'PENDING') {
                if (shouldRespect) {
                  cancel();
                }
                return;
              }
              if (shouldRespect) {
                if (phase.hasMoved) {
                  event.preventDefault();
                  return;
                }
                cancel();
                return;
              }
              event.preventDefault();
            }
          }, {
            eventName: supportedEventName,
            fn: cancel
          }];
        }
        function useTouchSensor(api) {
          var phaseRef = reactExports.useRef(idle$2);
          var unbindEventsRef = reactExports.useRef(noop);
          var getPhase = useCallback(function getPhase() {
            return phaseRef.current;
          }, []);
          var setPhase = useCallback(function setPhase(phase) {
            phaseRef.current = phase;
          }, []);
          var startCaptureBinding = useMemo(function () {
            return {
              eventName: 'touchstart',
              fn: function onTouchStart(event) {
                if (event.defaultPrevented) {
                  return;
                }
                var draggableId = api.findClosestDraggableId(event);
                if (!draggableId) {
                  return;
                }
                var actions = api.tryGetLock(draggableId, stop, {
                  sourceEvent: event
                });
                if (!actions) {
                  return;
                }
                var touch = event.touches[0];
                var clientX = touch.clientX,
                  clientY = touch.clientY;
                var point = {
                  x: clientX,
                  y: clientY
                };
                unbindEventsRef.current();
                startPendingDrag(actions, point);
              }
            };
          }, [api]);
          var listenForCapture = useCallback(function listenForCapture() {
            var options = {
              capture: true,
              passive: false
            };
            unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);
          }, [startCaptureBinding]);
          var stop = useCallback(function () {
            var current = phaseRef.current;
            if (current.type === 'IDLE') {
              return;
            }
            if (current.type === 'PENDING') {
              clearTimeout(current.longPressTimerId);
            }
            setPhase(idle$2);
            unbindEventsRef.current();
            listenForCapture();
          }, [listenForCapture, setPhase]);
          var cancel = useCallback(function () {
            var phase = phaseRef.current;
            stop();
            if (phase.type === 'DRAGGING') {
              phase.actions.cancel({
                shouldBlockNextClick: true
              });
            }
            if (phase.type === 'PENDING') {
              phase.actions.abort();
            }
          }, [stop]);
          var bindCapturingEvents = useCallback(function bindCapturingEvents() {
            var options = {
              capture: true,
              passive: false
            };
            var args = {
              cancel: cancel,
              completed: stop,
              getPhase: getPhase
            };
            var unbindTarget = bindEvents(window, getHandleBindings(args), options);
            var unbindWindow = bindEvents(window, getWindowBindings(args), options);
            unbindEventsRef.current = function unbindAll() {
              unbindTarget();
              unbindWindow();
            };
          }, [cancel, getPhase, stop]);
          var startDragging = useCallback(function startDragging() {
            var phase = getPhase();
            !(phase.type === 'PENDING') ? invariant(false) : void 0;
            var actions = phase.actions.fluidLift(phase.point);
            setPhase({
              type: 'DRAGGING',
              actions: actions,
              hasMoved: false
            });
          }, [getPhase, setPhase]);
          var startPendingDrag = useCallback(function startPendingDrag(actions, point) {
            !(getPhase().type === 'IDLE') ? invariant(false) : void 0;
            var longPressTimerId = setTimeout(startDragging, timeForLongPress);
            setPhase({
              type: 'PENDING',
              point: point,
              actions: actions,
              longPressTimerId: longPressTimerId
            });
            bindCapturingEvents();
          }, [bindCapturingEvents, getPhase, setPhase, startDragging]);
          useIsomorphicLayoutEffect$1(function mount() {
            listenForCapture();
            return function unmount() {
              unbindEventsRef.current();
              var phase = getPhase();
              if (phase.type === 'PENDING') {
                clearTimeout(phase.longPressTimerId);
                setPhase(idle$2);
              }
            };
          }, [getPhase, listenForCapture, setPhase]);
          useIsomorphicLayoutEffect$1(function webkitHack() {
            var unbind = bindEvents(window, [{
              eventName: 'touchmove',
              fn: function fn() {},
              options: {
                capture: false,
                passive: false
              }
            }]);
            return unbind;
          }, []);
        }
        var interactiveTagNames = {
          input: true,
          button: true,
          textarea: true,
          select: true,
          option: true,
          optgroup: true,
          video: true,
          audio: true
        };
        function isAnInteractiveElement(parent, current) {
          if (current == null) {
            return false;
          }
          var hasAnInteractiveTag = Boolean(interactiveTagNames[current.tagName.toLowerCase()]);
          if (hasAnInteractiveTag) {
            return true;
          }
          var attribute = current.getAttribute('contenteditable');
          if (attribute === 'true' || attribute === '') {
            return true;
          }
          if (current === parent) {
            return false;
          }
          return isAnInteractiveElement(parent, current.parentElement);
        }
        function isEventInInteractiveElement(draggable, event) {
          var target = event.target;
          if (!isHtmlElement(target)) {
            return false;
          }
          return isAnInteractiveElement(draggable, target);
        }
        var getBorderBoxCenterPosition = function (el) {
          return getRect(el.getBoundingClientRect()).center;
        };
        function isElement(el) {
          return el instanceof getWindowFromEl(el).Element;
        }
        var supportedMatchesName = function () {
          var base = 'matches';
          if (typeof document === 'undefined') {
            return base;
          }
          var candidates = [base, 'msMatchesSelector', 'webkitMatchesSelector'];
          var value = find(candidates, function (name) {
            return name in Element.prototype;
          });
          return value || base;
        }();
        function closestPonyfill(el, selector) {
          if (el == null) {
            return null;
          }
          if (el[supportedMatchesName](selector)) {
            return el;
          }
          return closestPonyfill(el.parentElement, selector);
        }
        function closest$1(el, selector) {
          if (el.closest) {
            return el.closest(selector);
          }
          return closestPonyfill(el, selector);
        }
        function getSelector(contextId) {
          return "[" + dragHandle.contextId + "=\"" + contextId + "\"]";
        }
        function findClosestDragHandleFromEvent(contextId, event) {
          var target = event.target;
          if (!isElement(target)) {
            return null;
          }
          var selector = getSelector(contextId);
          var handle = closest$1(target, selector);
          if (!handle) {
            return null;
          }
          if (!isHtmlElement(handle)) {
            return null;
          }
          return handle;
        }
        function tryGetClosestDraggableIdFromEvent(contextId, event) {
          var handle = findClosestDragHandleFromEvent(contextId, event);
          if (!handle) {
            return null;
          }
          return handle.getAttribute(dragHandle.draggableId);
        }
        function findDraggable(contextId, draggableId) {
          var selector = "[" + draggable.contextId + "=\"" + contextId + "\"]";
          var possible = toArray$1(document.querySelectorAll(selector));
          var draggable$1 = find(possible, function (el) {
            return el.getAttribute(draggable.id) === draggableId;
          });
          if (!draggable$1) {
            return null;
          }
          if (!isHtmlElement(draggable$1)) {
            return null;
          }
          return draggable$1;
        }
        function preventDefault(event) {
          event.preventDefault();
        }
        function _isActive(_ref) {
          var expected = _ref.expected,
            phase = _ref.phase,
            isLockActive = _ref.isLockActive;
          _ref.shouldWarn;
          if (!isLockActive()) {
            return false;
          }
          if (expected !== phase) {
            return false;
          }
          return true;
        }
        function canStart(_ref2) {
          var lockAPI = _ref2.lockAPI,
            store = _ref2.store,
            registry = _ref2.registry,
            draggableId = _ref2.draggableId;
          if (lockAPI.isClaimed()) {
            return false;
          }
          var entry = registry.draggable.findById(draggableId);
          if (!entry) {
            return false;
          }
          if (!entry.options.isEnabled) {
            return false;
          }
          if (!canStartDrag(store.getState(), draggableId)) {
            return false;
          }
          return true;
        }
        function tryStart(_ref3) {
          var lockAPI = _ref3.lockAPI,
            contextId = _ref3.contextId,
            store = _ref3.store,
            registry = _ref3.registry,
            draggableId = _ref3.draggableId,
            forceSensorStop = _ref3.forceSensorStop,
            sourceEvent = _ref3.sourceEvent;
          var shouldStart = canStart({
            lockAPI: lockAPI,
            store: store,
            registry: registry,
            draggableId: draggableId
          });
          if (!shouldStart) {
            return null;
          }
          var entry = registry.draggable.getById(draggableId);
          var el = findDraggable(contextId, entry.descriptor.id);
          if (!el) {
            return null;
          }
          if (sourceEvent && !entry.options.canDragInteractiveElements && isEventInInteractiveElement(el, sourceEvent)) {
            return null;
          }
          var lock = lockAPI.claim(forceSensorStop || noop);
          var phase = 'PRE_DRAG';
          function getShouldRespectForcePress() {
            return entry.options.shouldRespectForcePress;
          }
          function isLockActive() {
            return lockAPI.isActive(lock);
          }
          function tryDispatch(expected, getAction) {
            if (_isActive({
              expected: expected,
              phase: phase,
              isLockActive: isLockActive,
              shouldWarn: true
            })) {
              store.dispatch(getAction());
            }
          }
          var tryDispatchWhenDragging = tryDispatch.bind(null, 'DRAGGING');
          function lift$1(args) {
            function completed() {
              lockAPI.release();
              phase = 'COMPLETED';
            }
            if (phase !== 'PRE_DRAG') {
              completed();
              !(phase === 'PRE_DRAG') ? invariant(false) : void 0;
            }
            store.dispatch(lift(args.liftActionArgs));
            phase = 'DRAGGING';
            function finish(reason, options) {
              if (options === void 0) {
                options = {
                  shouldBlockNextClick: false
                };
              }
              args.cleanup();
              if (options.shouldBlockNextClick) {
                var unbind = bindEvents(window, [{
                  eventName: 'click',
                  fn: preventDefault,
                  options: {
                    once: true,
                    passive: false,
                    capture: true
                  }
                }]);
                setTimeout(unbind);
              }
              completed();
              store.dispatch(drop({
                reason: reason
              }));
            }
            return _extends({
              isActive: function isActive() {
                return _isActive({
                  expected: 'DRAGGING',
                  phase: phase,
                  isLockActive: isLockActive,
                  shouldWarn: false
                });
              },
              shouldRespectForcePress: getShouldRespectForcePress,
              drop: function drop(options) {
                return finish('DROP', options);
              },
              cancel: function cancel(options) {
                return finish('CANCEL', options);
              }
            }, args.actions);
          }
          function fluidLift(clientSelection) {
            var move$1 = rafSchd$1(function (client) {
              tryDispatchWhenDragging(function () {
                return move({
                  client: client
                });
              });
            });
            var api = lift$1({
              liftActionArgs: {
                id: draggableId,
                clientSelection: clientSelection,
                movementMode: 'FLUID'
              },
              cleanup: function cleanup() {
                return move$1.cancel();
              },
              actions: {
                move: move$1
              }
            });
            return _extends({}, api, {
              move: move$1
            });
          }
          function snapLift() {
            var actions = {
              moveUp: function moveUp$1() {
                return tryDispatchWhenDragging(moveUp);
              },
              moveRight: function moveRight$1() {
                return tryDispatchWhenDragging(moveRight);
              },
              moveDown: function moveDown$1() {
                return tryDispatchWhenDragging(moveDown);
              },
              moveLeft: function moveLeft$1() {
                return tryDispatchWhenDragging(moveLeft);
              }
            };
            return lift$1({
              liftActionArgs: {
                id: draggableId,
                clientSelection: getBorderBoxCenterPosition(el),
                movementMode: 'SNAP'
              },
              cleanup: noop,
              actions: actions
            });
          }
          function abortPreDrag() {
            var shouldRelease = _isActive({
              expected: 'PRE_DRAG',
              phase: phase,
              isLockActive: isLockActive,
              shouldWarn: true
            });
            if (shouldRelease) {
              lockAPI.release();
            }
          }
          var preDrag = {
            isActive: function isActive() {
              return _isActive({
                expected: 'PRE_DRAG',
                phase: phase,
                isLockActive: isLockActive,
                shouldWarn: false
              });
            },
            shouldRespectForcePress: getShouldRespectForcePress,
            fluidLift: fluidLift,
            snapLift: snapLift,
            abort: abortPreDrag
          };
          return preDrag;
        }
        var defaultSensors = [useMouseSensor, useKeyboardSensor, useTouchSensor];
        function useSensorMarshal(_ref4) {
          var contextId = _ref4.contextId,
            store = _ref4.store,
            registry = _ref4.registry,
            customSensors = _ref4.customSensors,
            enableDefaultSensors = _ref4.enableDefaultSensors;
          var useSensors = [].concat(enableDefaultSensors ? defaultSensors : [], customSensors || []);
          var lockAPI = reactExports.useState(function () {
            return create();
          })[0];
          var tryAbandonLock = useCallback(function tryAbandonLock(previous, current) {
            if (previous.isDragging && !current.isDragging) {
              lockAPI.tryAbandon();
            }
          }, [lockAPI]);
          useIsomorphicLayoutEffect$1(function listenToStore() {
            var previous = store.getState();
            var unsubscribe = store.subscribe(function () {
              var current = store.getState();
              tryAbandonLock(previous, current);
              previous = current;
            });
            return unsubscribe;
          }, [lockAPI, store, tryAbandonLock]);
          useIsomorphicLayoutEffect$1(function () {
            return lockAPI.tryAbandon;
          }, [lockAPI.tryAbandon]);
          var canGetLock = useCallback(function (draggableId) {
            return canStart({
              lockAPI: lockAPI,
              registry: registry,
              store: store,
              draggableId: draggableId
            });
          }, [lockAPI, registry, store]);
          var tryGetLock = useCallback(function (draggableId, forceStop, options) {
            return tryStart({
              lockAPI: lockAPI,
              registry: registry,
              contextId: contextId,
              store: store,
              draggableId: draggableId,
              forceSensorStop: forceStop,
              sourceEvent: options && options.sourceEvent ? options.sourceEvent : null
            });
          }, [contextId, lockAPI, registry, store]);
          var findClosestDraggableId = useCallback(function (event) {
            return tryGetClosestDraggableIdFromEvent(contextId, event);
          }, [contextId]);
          var findOptionsForDraggable = useCallback(function (id) {
            var entry = registry.draggable.findById(id);
            return entry ? entry.options : null;
          }, [registry.draggable]);
          var tryReleaseLock = useCallback(function tryReleaseLock() {
            if (!lockAPI.isClaimed()) {
              return;
            }
            lockAPI.tryAbandon();
            if (store.getState().phase !== 'IDLE') {
              store.dispatch(flush());
            }
          }, [lockAPI, store]);
          var isLockClaimed = useCallback(lockAPI.isClaimed, [lockAPI]);
          var api = useMemo(function () {
            return {
              canGetLock: canGetLock,
              tryGetLock: tryGetLock,
              findClosestDraggableId: findClosestDraggableId,
              findOptionsForDraggable: findOptionsForDraggable,
              tryReleaseLock: tryReleaseLock,
              isLockClaimed: isLockClaimed
            };
          }, [canGetLock, tryGetLock, findClosestDraggableId, findOptionsForDraggable, tryReleaseLock, isLockClaimed]);
          for (var i = 0; i < useSensors.length; i++) {
            useSensors[i](api);
          }
        }
        var createResponders = function createResponders(props) {
          return {
            onBeforeCapture: props.onBeforeCapture,
            onBeforeDragStart: props.onBeforeDragStart,
            onDragStart: props.onDragStart,
            onDragEnd: props.onDragEnd,
            onDragUpdate: props.onDragUpdate
          };
        };
        function getStore(lazyRef) {
          !lazyRef.current ? invariant(false) : void 0;
          return lazyRef.current;
        }
        function App$1(props) {
          var contextId = props.contextId,
            setCallbacks = props.setCallbacks,
            sensors = props.sensors,
            nonce = props.nonce,
            dragHandleUsageInstructions = props.dragHandleUsageInstructions;
          var lazyStoreRef = reactExports.useRef(null);
          var lastPropsRef = usePrevious(props);
          var getResponders = useCallback(function () {
            return createResponders(lastPropsRef.current);
          }, [lastPropsRef]);
          var announce = useAnnouncer(contextId);
          var dragHandleUsageInstructionsId = useHiddenTextElement({
            contextId: contextId,
            text: dragHandleUsageInstructions
          });
          var styleMarshal = useStyleMarshal(contextId, nonce);
          var lazyDispatch = useCallback(function (action) {
            getStore(lazyStoreRef).dispatch(action);
          }, []);
          var marshalCallbacks = useMemo(function () {
            return bindActionCreators$1({
              publishWhileDragging: publishWhileDragging,
              updateDroppableScroll: updateDroppableScroll,
              updateDroppableIsEnabled: updateDroppableIsEnabled,
              updateDroppableIsCombineEnabled: updateDroppableIsCombineEnabled,
              collectionStarting: collectionStarting
            }, lazyDispatch);
          }, [lazyDispatch]);
          var registry = useRegistry();
          var dimensionMarshal = useMemo(function () {
            return createDimensionMarshal(registry, marshalCallbacks);
          }, [registry, marshalCallbacks]);
          var autoScroller = useMemo(function () {
            return createAutoScroller(_extends({
              scrollWindow: scrollWindow,
              scrollDroppable: dimensionMarshal.scrollDroppable
            }, bindActionCreators$1({
              move: move
            }, lazyDispatch)));
          }, [dimensionMarshal.scrollDroppable, lazyDispatch]);
          var focusMarshal = useFocusMarshal(contextId);
          var store = useMemo(function () {
            return createStore({
              announce: announce,
              autoScroller: autoScroller,
              dimensionMarshal: dimensionMarshal,
              focusMarshal: focusMarshal,
              getResponders: getResponders,
              styleMarshal: styleMarshal
            });
          }, [announce, autoScroller, dimensionMarshal, focusMarshal, getResponders, styleMarshal]);
          lazyStoreRef.current = store;
          var tryResetStore = useCallback(function () {
            var current = getStore(lazyStoreRef);
            var state = current.getState();
            if (state.phase !== 'IDLE') {
              current.dispatch(flush());
            }
          }, []);
          var isDragging = useCallback(function () {
            var state = getStore(lazyStoreRef).getState();
            return state.isDragging || state.phase === 'DROP_ANIMATING';
          }, []);
          var appCallbacks = useMemo(function () {
            return {
              isDragging: isDragging,
              tryAbort: tryResetStore
            };
          }, [isDragging, tryResetStore]);
          setCallbacks(appCallbacks);
          var getCanLift = useCallback(function (id) {
            return canStartDrag(getStore(lazyStoreRef).getState(), id);
          }, []);
          var getIsMovementAllowed = useCallback(function () {
            return isMovementAllowed(getStore(lazyStoreRef).getState());
          }, []);
          var appContext = useMemo(function () {
            return {
              marshal: dimensionMarshal,
              focus: focusMarshal,
              contextId: contextId,
              canLift: getCanLift,
              isMovementAllowed: getIsMovementAllowed,
              dragHandleUsageInstructionsId: dragHandleUsageInstructionsId,
              registry: registry
            };
          }, [contextId, dimensionMarshal, dragHandleUsageInstructionsId, focusMarshal, getCanLift, getIsMovementAllowed, registry]);
          useSensorMarshal({
            contextId: contextId,
            store: store,
            registry: registry,
            customSensors: sensors,
            enableDefaultSensors: props.enableDefaultSensors !== false
          });
          reactExports.useEffect(function () {
            return tryResetStore;
          }, [tryResetStore]);
          return React.createElement(AppContext.Provider, {
            value: appContext
          }, React.createElement(Provider$1, {
            context: StoreContext,
            store: store
          }, props.children));
        }
        var count$1 = 0;
        function useInstanceCount() {
          return useMemo(function () {
            return "" + count$1++;
          }, []);
        }
        function DragDropContext(props) {
          var contextId = useInstanceCount();
          var dragHandleUsageInstructions = props.dragHandleUsageInstructions || preset.dragHandleUsageInstructions;
          return React.createElement(ErrorBoundary, null, function (setCallbacks) {
            return React.createElement(App$1, {
              nonce: props.nonce,
              contextId: contextId,
              setCallbacks: setCallbacks,
              dragHandleUsageInstructions: dragHandleUsageInstructions,
              enableDefaultSensors: props.enableDefaultSensors,
              sensors: props.sensors,
              onBeforeCapture: props.onBeforeCapture,
              onBeforeDragStart: props.onBeforeDragStart,
              onDragStart: props.onDragStart,
              onDragUpdate: props.onDragUpdate,
              onDragEnd: props.onDragEnd
            }, props.children);
          });
        }
        var isEqual$1 = function isEqual(base) {
          return function (value) {
            return base === value;
          };
        };
        var isScroll = isEqual$1('scroll');
        var isAuto = isEqual$1('auto');
        var isEither = function isEither(overflow, fn) {
          return fn(overflow.overflowX) || fn(overflow.overflowY);
        };
        var isElementScrollable = function isElementScrollable(el) {
          var style = window.getComputedStyle(el);
          var overflow = {
            overflowX: style.overflowX,
            overflowY: style.overflowY
          };
          return isEither(overflow, isScroll) || isEither(overflow, isAuto);
        };
        var isBodyScrollable = function isBodyScrollable() {
          {
            return false;
          }
        };
        var getClosestScrollable = function getClosestScrollable(el) {
          if (el == null) {
            return null;
          }
          if (el === document.body) {
            return isBodyScrollable() ? el : null;
          }
          if (el === document.documentElement) {
            return null;
          }
          if (!isElementScrollable(el)) {
            return getClosestScrollable(el.parentElement);
          }
          return el;
        };
        var getScroll$1 = function (el) {
          return {
            x: el.scrollLeft,
            y: el.scrollTop
          };
        };
        var getIsFixed = function getIsFixed(el) {
          if (!el) {
            return false;
          }
          var style = window.getComputedStyle(el);
          if (style.position === 'fixed') {
            return true;
          }
          return getIsFixed(el.parentElement);
        };
        var getEnv = function (start) {
          var closestScrollable = getClosestScrollable(start);
          var isFixedOnPage = getIsFixed(start);
          return {
            closestScrollable: closestScrollable,
            isFixedOnPage: isFixedOnPage
          };
        };
        var getDroppableDimension = function (_ref) {
          var descriptor = _ref.descriptor,
            isEnabled = _ref.isEnabled,
            isCombineEnabled = _ref.isCombineEnabled,
            isFixedOnPage = _ref.isFixedOnPage,
            direction = _ref.direction,
            client = _ref.client,
            page = _ref.page,
            closest = _ref.closest;
          var frame = function () {
            if (!closest) {
              return null;
            }
            var scrollSize = closest.scrollSize,
              frameClient = closest.client;
            var maxScroll = getMaxScroll({
              scrollHeight: scrollSize.scrollHeight,
              scrollWidth: scrollSize.scrollWidth,
              height: frameClient.paddingBox.height,
              width: frameClient.paddingBox.width
            });
            return {
              pageMarginBox: closest.page.marginBox,
              frameClient: frameClient,
              scrollSize: scrollSize,
              shouldClipSubject: closest.shouldClipSubject,
              scroll: {
                initial: closest.scroll,
                current: closest.scroll,
                max: maxScroll,
                diff: {
                  value: origin,
                  displacement: origin
                }
              }
            };
          }();
          var axis = direction === 'vertical' ? vertical : horizontal;
          var subject = getSubject({
            page: page,
            withPlaceholder: null,
            axis: axis,
            frame: frame
          });
          var dimension = {
            descriptor: descriptor,
            isCombineEnabled: isCombineEnabled,
            isFixedOnPage: isFixedOnPage,
            axis: axis,
            isEnabled: isEnabled,
            client: client,
            page: page,
            frame: frame,
            subject: subject
          };
          return dimension;
        };
        var getClient = function getClient(targetRef, closestScrollable) {
          var base = getBox(targetRef);
          if (!closestScrollable) {
            return base;
          }
          if (targetRef !== closestScrollable) {
            return base;
          }
          var top = base.paddingBox.top - closestScrollable.scrollTop;
          var left = base.paddingBox.left - closestScrollable.scrollLeft;
          var bottom = top + closestScrollable.scrollHeight;
          var right = left + closestScrollable.scrollWidth;
          var paddingBox = {
            top: top,
            right: right,
            bottom: bottom,
            left: left
          };
          var borderBox = expand(paddingBox, base.border);
          var client = createBox({
            borderBox: borderBox,
            margin: base.margin,
            border: base.border,
            padding: base.padding
          });
          return client;
        };
        var getDimension = function (_ref) {
          var ref = _ref.ref,
            descriptor = _ref.descriptor,
            env = _ref.env,
            windowScroll = _ref.windowScroll,
            direction = _ref.direction,
            isDropDisabled = _ref.isDropDisabled,
            isCombineEnabled = _ref.isCombineEnabled,
            shouldClipSubject = _ref.shouldClipSubject;
          var closestScrollable = env.closestScrollable;
          var client = getClient(ref, closestScrollable);
          var page = withScroll(client, windowScroll);
          var closest = function () {
            if (!closestScrollable) {
              return null;
            }
            var frameClient = getBox(closestScrollable);
            var scrollSize = {
              scrollHeight: closestScrollable.scrollHeight,
              scrollWidth: closestScrollable.scrollWidth
            };
            return {
              client: frameClient,
              page: withScroll(frameClient, windowScroll),
              scroll: getScroll$1(closestScrollable),
              scrollSize: scrollSize,
              shouldClipSubject: shouldClipSubject
            };
          }();
          var dimension = getDroppableDimension({
            descriptor: descriptor,
            isEnabled: !isDropDisabled,
            isCombineEnabled: isCombineEnabled,
            isFixedOnPage: env.isFixedOnPage,
            direction: direction,
            client: client,
            page: page,
            closest: closest
          });
          return dimension;
        };
        var immediate = {
          passive: false
        };
        var delayed = {
          passive: true
        };
        var getListenerOptions = function (options) {
          return options.shouldPublishImmediately ? immediate : delayed;
        };
        function useRequiredContext(Context) {
          var result = reactExports.useContext(Context);
          !result ? invariant(false) : void 0;
          return result;
        }
        var getClosestScrollableFromDrag = function getClosestScrollableFromDrag(dragging) {
          return dragging && dragging.env.closestScrollable || null;
        };
        function useDroppablePublisher(args) {
          var whileDraggingRef = reactExports.useRef(null);
          var appContext = useRequiredContext(AppContext);
          var uniqueId = useUniqueId('droppable');
          var registry = appContext.registry,
            marshal = appContext.marshal;
          var previousRef = usePrevious(args);
          var descriptor = useMemo(function () {
            return {
              id: args.droppableId,
              type: args.type,
              mode: args.mode
            };
          }, [args.droppableId, args.mode, args.type]);
          var publishedDescriptorRef = reactExports.useRef(descriptor);
          var memoizedUpdateScroll = useMemo(function () {
            return memoizeOne(function (x, y) {
              !whileDraggingRef.current ? invariant(false) : void 0;
              var scroll = {
                x: x,
                y: y
              };
              marshal.updateDroppableScroll(descriptor.id, scroll);
            });
          }, [descriptor.id, marshal]);
          var getClosestScroll = useCallback(function () {
            var dragging = whileDraggingRef.current;
            if (!dragging || !dragging.env.closestScrollable) {
              return origin;
            }
            return getScroll$1(dragging.env.closestScrollable);
          }, []);
          var updateScroll = useCallback(function () {
            var scroll = getClosestScroll();
            memoizedUpdateScroll(scroll.x, scroll.y);
          }, [getClosestScroll, memoizedUpdateScroll]);
          var scheduleScrollUpdate = useMemo(function () {
            return rafSchd$1(updateScroll);
          }, [updateScroll]);
          var onClosestScroll = useCallback(function () {
            var dragging = whileDraggingRef.current;
            var closest = getClosestScrollableFromDrag(dragging);
            !(dragging && closest) ? invariant(false) : void 0;
            var options = dragging.scrollOptions;
            if (options.shouldPublishImmediately) {
              updateScroll();
              return;
            }
            scheduleScrollUpdate();
          }, [scheduleScrollUpdate, updateScroll]);
          var getDimensionAndWatchScroll = useCallback(function (windowScroll, options) {
            !!whileDraggingRef.current ? invariant(false) : void 0;
            var previous = previousRef.current;
            var ref = previous.getDroppableRef();
            !ref ? invariant(false) : void 0;
            var env = getEnv(ref);
            var dragging = {
              ref: ref,
              descriptor: descriptor,
              env: env,
              scrollOptions: options
            };
            whileDraggingRef.current = dragging;
            var dimension = getDimension({
              ref: ref,
              descriptor: descriptor,
              env: env,
              windowScroll: windowScroll,
              direction: previous.direction,
              isDropDisabled: previous.isDropDisabled,
              isCombineEnabled: previous.isCombineEnabled,
              shouldClipSubject: !previous.ignoreContainerClipping
            });
            var scrollable = env.closestScrollable;
            if (scrollable) {
              scrollable.setAttribute(scrollContainer.contextId, appContext.contextId);
              scrollable.addEventListener('scroll', onClosestScroll, getListenerOptions(dragging.scrollOptions));
            }
            return dimension;
          }, [appContext.contextId, descriptor, onClosestScroll, previousRef]);
          var getScrollWhileDragging = useCallback(function () {
            var dragging = whileDraggingRef.current;
            var closest = getClosestScrollableFromDrag(dragging);
            !(dragging && closest) ? invariant(false) : void 0;
            return getScroll$1(closest);
          }, []);
          var dragStopped = useCallback(function () {
            var dragging = whileDraggingRef.current;
            !dragging ? invariant(false) : void 0;
            var closest = getClosestScrollableFromDrag(dragging);
            whileDraggingRef.current = null;
            if (!closest) {
              return;
            }
            scheduleScrollUpdate.cancel();
            closest.removeAttribute(scrollContainer.contextId);
            closest.removeEventListener('scroll', onClosestScroll, getListenerOptions(dragging.scrollOptions));
          }, [onClosestScroll, scheduleScrollUpdate]);
          var scroll = useCallback(function (change) {
            var dragging = whileDraggingRef.current;
            !dragging ? invariant(false) : void 0;
            var closest = getClosestScrollableFromDrag(dragging);
            !closest ? invariant(false) : void 0;
            closest.scrollTop += change.y;
            closest.scrollLeft += change.x;
          }, []);
          var callbacks = useMemo(function () {
            return {
              getDimensionAndWatchScroll: getDimensionAndWatchScroll,
              getScrollWhileDragging: getScrollWhileDragging,
              dragStopped: dragStopped,
              scroll: scroll
            };
          }, [dragStopped, getDimensionAndWatchScroll, getScrollWhileDragging, scroll]);
          var entry = useMemo(function () {
            return {
              uniqueId: uniqueId,
              descriptor: descriptor,
              callbacks: callbacks
            };
          }, [callbacks, descriptor, uniqueId]);
          useIsomorphicLayoutEffect$1(function () {
            publishedDescriptorRef.current = entry.descriptor;
            registry.droppable.register(entry);
            return function () {
              if (whileDraggingRef.current) {
                dragStopped();
              }
              registry.droppable.unregister(entry);
            };
          }, [callbacks, descriptor, dragStopped, entry, marshal, registry.droppable]);
          useIsomorphicLayoutEffect$1(function () {
            if (!whileDraggingRef.current) {
              return;
            }
            marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);
          }, [args.isDropDisabled, marshal]);
          useIsomorphicLayoutEffect$1(function () {
            if (!whileDraggingRef.current) {
              return;
            }
            marshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id, args.isCombineEnabled);
          }, [args.isCombineEnabled, marshal]);
        }
        function noop$2() {}
        var empty = {
          width: 0,
          height: 0,
          margin: noSpacing
        };
        var getSize = function getSize(_ref) {
          var isAnimatingOpenOnMount = _ref.isAnimatingOpenOnMount,
            placeholder = _ref.placeholder,
            animate = _ref.animate;
          if (isAnimatingOpenOnMount) {
            return empty;
          }
          if (animate === 'close') {
            return empty;
          }
          return {
            height: placeholder.client.borderBox.height,
            width: placeholder.client.borderBox.width,
            margin: placeholder.client.margin
          };
        };
        var getStyle = function getStyle(_ref2) {
          var isAnimatingOpenOnMount = _ref2.isAnimatingOpenOnMount,
            placeholder = _ref2.placeholder,
            animate = _ref2.animate;
          var size = getSize({
            isAnimatingOpenOnMount: isAnimatingOpenOnMount,
            placeholder: placeholder,
            animate: animate
          });
          return {
            display: placeholder.display,
            boxSizing: 'border-box',
            width: size.width,
            height: size.height,
            marginTop: size.margin.top,
            marginRight: size.margin.right,
            marginBottom: size.margin.bottom,
            marginLeft: size.margin.left,
            flexShrink: '0',
            flexGrow: '0',
            pointerEvents: 'none',
            transition: animate !== 'none' ? transitions.placeholder : null
          };
        };
        function Placeholder(props) {
          var animateOpenTimerRef = reactExports.useRef(null);
          var tryClearAnimateOpenTimer = useCallback(function () {
            if (!animateOpenTimerRef.current) {
              return;
            }
            clearTimeout(animateOpenTimerRef.current);
            animateOpenTimerRef.current = null;
          }, []);
          var animate = props.animate,
            onTransitionEnd = props.onTransitionEnd,
            onClose = props.onClose,
            contextId = props.contextId;
          var _useState = reactExports.useState(props.animate === 'open'),
            isAnimatingOpenOnMount = _useState[0],
            setIsAnimatingOpenOnMount = _useState[1];
          reactExports.useEffect(function () {
            if (!isAnimatingOpenOnMount) {
              return noop$2;
            }
            if (animate !== 'open') {
              tryClearAnimateOpenTimer();
              setIsAnimatingOpenOnMount(false);
              return noop$2;
            }
            if (animateOpenTimerRef.current) {
              return noop$2;
            }
            animateOpenTimerRef.current = setTimeout(function () {
              animateOpenTimerRef.current = null;
              setIsAnimatingOpenOnMount(false);
            });
            return tryClearAnimateOpenTimer;
          }, [animate, isAnimatingOpenOnMount, tryClearAnimateOpenTimer]);
          var onSizeChangeEnd = useCallback(function (event) {
            if (event.propertyName !== 'height') {
              return;
            }
            onTransitionEnd();
            if (animate === 'close') {
              onClose();
            }
          }, [animate, onClose, onTransitionEnd]);
          var style = getStyle({
            isAnimatingOpenOnMount: isAnimatingOpenOnMount,
            animate: props.animate,
            placeholder: props.placeholder
          });
          return React.createElement(props.placeholder.tagName, {
            style: style,
            'data-rbd-placeholder-context-id': contextId,
            onTransitionEnd: onSizeChangeEnd,
            ref: props.innerRef
          });
        }
        var Placeholder$1 = React.memo(Placeholder);
        var DroppableContext = React.createContext(null);
        var AnimateInOut = function (_React$PureComponent) {
          _inheritsLoose(AnimateInOut, _React$PureComponent);
          function AnimateInOut() {
            var _this;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;
            _this.state = {
              isVisible: Boolean(_this.props.on),
              data: _this.props.on,
              animate: _this.props.shouldAnimate && _this.props.on ? 'open' : 'none'
            };
            _this.onClose = function () {
              if (_this.state.animate !== 'close') {
                return;
              }
              _this.setState({
                isVisible: false
              });
            };
            return _this;
          }
          AnimateInOut.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
            if (!props.shouldAnimate) {
              return {
                isVisible: Boolean(props.on),
                data: props.on,
                animate: 'none'
              };
            }
            if (props.on) {
              return {
                isVisible: true,
                data: props.on,
                animate: 'open'
              };
            }
            if (state.isVisible) {
              return {
                isVisible: true,
                data: state.data,
                animate: 'close'
              };
            }
            return {
              isVisible: false,
              animate: 'close',
              data: null
            };
          };
          var _proto = AnimateInOut.prototype;
          _proto.render = function render() {
            if (!this.state.isVisible) {
              return null;
            }
            var provided = {
              onClose: this.onClose,
              data: this.state.data,
              animate: this.state.animate
            };
            return this.props.children(provided);
          };
          return AnimateInOut;
        }(React.PureComponent);
        var zIndexOptions = {
          dragging: 5000,
          dropAnimating: 4500
        };
        var getDraggingTransition = function getDraggingTransition(shouldAnimateDragMovement, dropping) {
          if (dropping) {
            return transitions.drop(dropping.duration);
          }
          if (shouldAnimateDragMovement) {
            return transitions.snap;
          }
          return transitions.fluid;
        };
        var getDraggingOpacity = function getDraggingOpacity(isCombining, isDropAnimating) {
          if (!isCombining) {
            return null;
          }
          return isDropAnimating ? combine$1.opacity.drop : combine$1.opacity.combining;
        };
        var getShouldDraggingAnimate = function getShouldDraggingAnimate(dragging) {
          if (dragging.forceShouldAnimate != null) {
            return dragging.forceShouldAnimate;
          }
          return dragging.mode === 'SNAP';
        };
        function getDraggingStyle(dragging) {
          var dimension = dragging.dimension;
          var box = dimension.client;
          var offset = dragging.offset,
            combineWith = dragging.combineWith,
            dropping = dragging.dropping;
          var isCombining = Boolean(combineWith);
          var shouldAnimate = getShouldDraggingAnimate(dragging);
          var isDropAnimating = Boolean(dropping);
          var transform = isDropAnimating ? transforms.drop(offset, isCombining) : transforms.moveTo(offset);
          var style = {
            position: 'fixed',
            top: box.marginBox.top,
            left: box.marginBox.left,
            boxSizing: 'border-box',
            width: box.borderBox.width,
            height: box.borderBox.height,
            transition: getDraggingTransition(shouldAnimate, dropping),
            transform: transform,
            opacity: getDraggingOpacity(isCombining, isDropAnimating),
            zIndex: isDropAnimating ? zIndexOptions.dropAnimating : zIndexOptions.dragging,
            pointerEvents: 'none'
          };
          return style;
        }
        function getSecondaryStyle(secondary) {
          return {
            transform: transforms.moveTo(secondary.offset),
            transition: secondary.shouldAnimateDisplacement ? null : 'none'
          };
        }
        function getStyle$1(mapped) {
          return mapped.type === 'DRAGGING' ? getDraggingStyle(mapped) : getSecondaryStyle(mapped);
        }
        function getDimension$1(descriptor, el, windowScroll) {
          if (windowScroll === void 0) {
            windowScroll = origin;
          }
          var computedStyles = window.getComputedStyle(el);
          var borderBox = el.getBoundingClientRect();
          var client = calculateBox(borderBox, computedStyles);
          var page = withScroll(client, windowScroll);
          var placeholder = {
            client: client,
            tagName: el.tagName.toLowerCase(),
            display: computedStyles.display
          };
          var displaceBy = {
            x: client.marginBox.width,
            y: client.marginBox.height
          };
          var dimension = {
            descriptor: descriptor,
            placeholder: placeholder,
            displaceBy: displaceBy,
            client: client,
            page: page
          };
          return dimension;
        }
        function useDraggablePublisher(args) {
          var uniqueId = useUniqueId('draggable');
          var descriptor = args.descriptor,
            registry = args.registry,
            getDraggableRef = args.getDraggableRef,
            canDragInteractiveElements = args.canDragInteractiveElements,
            shouldRespectForcePress = args.shouldRespectForcePress,
            isEnabled = args.isEnabled;
          var options = useMemo(function () {
            return {
              canDragInteractiveElements: canDragInteractiveElements,
              shouldRespectForcePress: shouldRespectForcePress,
              isEnabled: isEnabled
            };
          }, [canDragInteractiveElements, isEnabled, shouldRespectForcePress]);
          var getDimension = useCallback(function (windowScroll) {
            var el = getDraggableRef();
            !el ? invariant(false) : void 0;
            return getDimension$1(descriptor, el, windowScroll);
          }, [descriptor, getDraggableRef]);
          var entry = useMemo(function () {
            return {
              uniqueId: uniqueId,
              descriptor: descriptor,
              options: options,
              getDimension: getDimension
            };
          }, [descriptor, getDimension, options, uniqueId]);
          var publishedRef = reactExports.useRef(entry);
          var isFirstPublishRef = reactExports.useRef(true);
          useIsomorphicLayoutEffect$1(function () {
            registry.draggable.register(publishedRef.current);
            return function () {
              return registry.draggable.unregister(publishedRef.current);
            };
          }, [registry.draggable]);
          useIsomorphicLayoutEffect$1(function () {
            if (isFirstPublishRef.current) {
              isFirstPublishRef.current = false;
              return;
            }
            var last = publishedRef.current;
            publishedRef.current = entry;
            registry.draggable.update(entry, last);
          }, [entry, registry.draggable]);
        }
        function preventHtml5Dnd(event) {
          event.preventDefault();
        }
        function Draggable(props) {
          var ref = reactExports.useRef(null);
          var setRef = useCallback(function (el) {
            ref.current = el;
          }, []);
          var getRef = useCallback(function () {
            return ref.current;
          }, []);
          var _useRequiredContext = useRequiredContext(AppContext),
            contextId = _useRequiredContext.contextId,
            dragHandleUsageInstructionsId = _useRequiredContext.dragHandleUsageInstructionsId,
            registry = _useRequiredContext.registry;
          var _useRequiredContext2 = useRequiredContext(DroppableContext),
            type = _useRequiredContext2.type,
            droppableId = _useRequiredContext2.droppableId;
          var descriptor = useMemo(function () {
            return {
              id: props.draggableId,
              index: props.index,
              type: type,
              droppableId: droppableId
            };
          }, [props.draggableId, props.index, type, droppableId]);
          var children = props.children,
            draggableId = props.draggableId,
            isEnabled = props.isEnabled,
            shouldRespectForcePress = props.shouldRespectForcePress,
            canDragInteractiveElements = props.canDragInteractiveElements,
            isClone = props.isClone,
            mapped = props.mapped,
            dropAnimationFinishedAction = props.dropAnimationFinished;
          if (!isClone) {
            var forPublisher = useMemo(function () {
              return {
                descriptor: descriptor,
                registry: registry,
                getDraggableRef: getRef,
                canDragInteractiveElements: canDragInteractiveElements,
                shouldRespectForcePress: shouldRespectForcePress,
                isEnabled: isEnabled
              };
            }, [descriptor, registry, getRef, canDragInteractiveElements, shouldRespectForcePress, isEnabled]);
            useDraggablePublisher(forPublisher);
          }
          var dragHandleProps = useMemo(function () {
            return isEnabled ? {
              tabIndex: 0,
              role: 'button',
              'aria-describedby': dragHandleUsageInstructionsId,
              'data-rbd-drag-handle-draggable-id': draggableId,
              'data-rbd-drag-handle-context-id': contextId,
              draggable: false,
              onDragStart: preventHtml5Dnd
            } : null;
          }, [contextId, dragHandleUsageInstructionsId, draggableId, isEnabled]);
          var onMoveEnd = useCallback(function (event) {
            if (mapped.type !== 'DRAGGING') {
              return;
            }
            if (!mapped.dropping) {
              return;
            }
            if (event.propertyName !== 'transform') {
              return;
            }
            dropAnimationFinishedAction();
          }, [dropAnimationFinishedAction, mapped]);
          var provided = useMemo(function () {
            var style = getStyle$1(mapped);
            var onTransitionEnd = mapped.type === 'DRAGGING' && mapped.dropping ? onMoveEnd : null;
            var result = {
              innerRef: setRef,
              draggableProps: {
                'data-rbd-draggable-context-id': contextId,
                'data-rbd-draggable-id': draggableId,
                style: style,
                onTransitionEnd: onTransitionEnd
              },
              dragHandleProps: dragHandleProps
            };
            return result;
          }, [contextId, dragHandleProps, draggableId, mapped, onMoveEnd, setRef]);
          var rubric = useMemo(function () {
            return {
              draggableId: descriptor.id,
              type: descriptor.type,
              source: {
                index: descriptor.index,
                droppableId: descriptor.droppableId
              }
            };
          }, [descriptor.droppableId, descriptor.id, descriptor.index, descriptor.type]);
          return children(provided, mapped.snapshot, rubric);
        }
        var isStrictEqual = function (a, b) {
          return a === b;
        };
        var whatIsDraggedOverFromResult = function (result) {
          var combine = result.combine,
            destination = result.destination;
          if (destination) {
            return destination.droppableId;
          }
          if (combine) {
            return combine.droppableId;
          }
          return null;
        };
        var getCombineWithFromResult = function getCombineWithFromResult(result) {
          return result.combine ? result.combine.draggableId : null;
        };
        var getCombineWithFromImpact = function getCombineWithFromImpact(impact) {
          return impact.at && impact.at.type === 'COMBINE' ? impact.at.combine.draggableId : null;
        };
        function getDraggableSelector() {
          var memoizedOffset = memoizeOne(function (x, y) {
            return {
              x: x,
              y: y
            };
          });
          var getMemoizedSnapshot = memoizeOne(function (mode, isClone, draggingOver, combineWith, dropping) {
            return {
              isDragging: true,
              isClone: isClone,
              isDropAnimating: Boolean(dropping),
              dropAnimation: dropping,
              mode: mode,
              draggingOver: draggingOver,
              combineWith: combineWith,
              combineTargetFor: null
            };
          });
          var getMemoizedProps = memoizeOne(function (offset, mode, dimension, isClone, draggingOver, combineWith, forceShouldAnimate) {
            return {
              mapped: {
                type: 'DRAGGING',
                dropping: null,
                draggingOver: draggingOver,
                combineWith: combineWith,
                mode: mode,
                offset: offset,
                dimension: dimension,
                forceShouldAnimate: forceShouldAnimate,
                snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, null)
              }
            };
          });
          var selector = function selector(state, ownProps) {
            if (state.isDragging) {
              if (state.critical.draggable.id !== ownProps.draggableId) {
                return null;
              }
              var offset = state.current.client.offset;
              var dimension = state.dimensions.draggables[ownProps.draggableId];
              var draggingOver = whatIsDraggedOver(state.impact);
              var combineWith = getCombineWithFromImpact(state.impact);
              var forceShouldAnimate = state.forceShouldAnimate;
              return getMemoizedProps(memoizedOffset(offset.x, offset.y), state.movementMode, dimension, ownProps.isClone, draggingOver, combineWith, forceShouldAnimate);
            }
            if (state.phase === 'DROP_ANIMATING') {
              var completed = state.completed;
              if (completed.result.draggableId !== ownProps.draggableId) {
                return null;
              }
              var isClone = ownProps.isClone;
              var _dimension = state.dimensions.draggables[ownProps.draggableId];
              var result = completed.result;
              var mode = result.mode;
              var _draggingOver = whatIsDraggedOverFromResult(result);
              var _combineWith = getCombineWithFromResult(result);
              var duration = state.dropDuration;
              var dropping = {
                duration: duration,
                curve: curves.drop,
                moveTo: state.newHomeClientOffset,
                opacity: _combineWith ? combine$1.opacity.drop : null,
                scale: _combineWith ? combine$1.scale.drop : null
              };
              return {
                mapped: {
                  type: 'DRAGGING',
                  offset: state.newHomeClientOffset,
                  dimension: _dimension,
                  dropping: dropping,
                  draggingOver: _draggingOver,
                  combineWith: _combineWith,
                  mode: mode,
                  forceShouldAnimate: null,
                  snapshot: getMemoizedSnapshot(mode, isClone, _draggingOver, _combineWith, dropping)
                }
              };
            }
            return null;
          };
          return selector;
        }
        function getSecondarySnapshot(combineTargetFor) {
          return {
            isDragging: false,
            isDropAnimating: false,
            isClone: false,
            dropAnimation: null,
            mode: null,
            draggingOver: null,
            combineTargetFor: combineTargetFor,
            combineWith: null
          };
        }
        var atRest = {
          mapped: {
            type: 'SECONDARY',
            offset: origin,
            combineTargetFor: null,
            shouldAnimateDisplacement: true,
            snapshot: getSecondarySnapshot(null)
          }
        };
        function getSecondarySelector() {
          var memoizedOffset = memoizeOne(function (x, y) {
            return {
              x: x,
              y: y
            };
          });
          var getMemoizedSnapshot = memoizeOne(getSecondarySnapshot);
          var getMemoizedProps = memoizeOne(function (offset, combineTargetFor, shouldAnimateDisplacement) {
            if (combineTargetFor === void 0) {
              combineTargetFor = null;
            }
            return {
              mapped: {
                type: 'SECONDARY',
                offset: offset,
                combineTargetFor: combineTargetFor,
                shouldAnimateDisplacement: shouldAnimateDisplacement,
                snapshot: getMemoizedSnapshot(combineTargetFor)
              }
            };
          });
          var getFallback = function getFallback(combineTargetFor) {
            return combineTargetFor ? getMemoizedProps(origin, combineTargetFor, true) : null;
          };
          var getProps = function getProps(ownId, draggingId, impact, afterCritical) {
            var visualDisplacement = impact.displaced.visible[ownId];
            var isAfterCriticalInVirtualList = Boolean(afterCritical.inVirtualList && afterCritical.effected[ownId]);
            var combine = tryGetCombine(impact);
            var combineTargetFor = combine && combine.draggableId === ownId ? draggingId : null;
            if (!visualDisplacement) {
              if (!isAfterCriticalInVirtualList) {
                return getFallback(combineTargetFor);
              }
              if (impact.displaced.invisible[ownId]) {
                return null;
              }
              var change = negate(afterCritical.displacedBy.point);
              var _offset = memoizedOffset(change.x, change.y);
              return getMemoizedProps(_offset, combineTargetFor, true);
            }
            if (isAfterCriticalInVirtualList) {
              return getFallback(combineTargetFor);
            }
            var displaceBy = impact.displacedBy.point;
            var offset = memoizedOffset(displaceBy.x, displaceBy.y);
            return getMemoizedProps(offset, combineTargetFor, visualDisplacement.shouldAnimate);
          };
          var selector = function selector(state, ownProps) {
            if (state.isDragging) {
              if (state.critical.draggable.id === ownProps.draggableId) {
                return null;
              }
              return getProps(ownProps.draggableId, state.critical.draggable.id, state.impact, state.afterCritical);
            }
            if (state.phase === 'DROP_ANIMATING') {
              var completed = state.completed;
              if (completed.result.draggableId === ownProps.draggableId) {
                return null;
              }
              return getProps(ownProps.draggableId, completed.result.draggableId, completed.impact, completed.afterCritical);
            }
            return null;
          };
          return selector;
        }
        var makeMapStateToProps = function makeMapStateToProps() {
          var draggingSelector = getDraggableSelector();
          var secondarySelector = getSecondarySelector();
          var selector = function selector(state, ownProps) {
            return draggingSelector(state, ownProps) || secondarySelector(state, ownProps) || atRest;
          };
          return selector;
        };
        var mapDispatchToProps = {
          dropAnimationFinished: dropAnimationFinished
        };
        var ConnectedDraggable = connect(makeMapStateToProps, mapDispatchToProps, null, {
          context: StoreContext,
          pure: true,
          areStatePropsEqual: isStrictEqual
        })(Draggable);
        function PrivateDraggable(props) {
          var droppableContext = useRequiredContext(DroppableContext);
          var isUsingCloneFor = droppableContext.isUsingCloneFor;
          if (isUsingCloneFor === props.draggableId && !props.isClone) {
            return null;
          }
          return React.createElement(ConnectedDraggable, props);
        }
        function PublicDraggable(props) {
          var isEnabled = typeof props.isDragDisabled === 'boolean' ? !props.isDragDisabled : true;
          var canDragInteractiveElements = Boolean(props.disableInteractiveElementBlocking);
          var shouldRespectForcePress = Boolean(props.shouldRespectForcePress);
          return React.createElement(PrivateDraggable, _extends({}, props, {
            isClone: false,
            isEnabled: isEnabled,
            canDragInteractiveElements: canDragInteractiveElements,
            shouldRespectForcePress: shouldRespectForcePress
          }));
        }
        function Droppable(props) {
          var appContext = reactExports.useContext(AppContext);
          !appContext ? invariant(false) : void 0;
          var contextId = appContext.contextId,
            isMovementAllowed = appContext.isMovementAllowed;
          var droppableRef = reactExports.useRef(null);
          var placeholderRef = reactExports.useRef(null);
          var children = props.children,
            droppableId = props.droppableId,
            type = props.type,
            mode = props.mode,
            direction = props.direction,
            ignoreContainerClipping = props.ignoreContainerClipping,
            isDropDisabled = props.isDropDisabled,
            isCombineEnabled = props.isCombineEnabled,
            snapshot = props.snapshot,
            useClone = props.useClone,
            updateViewportMaxScroll = props.updateViewportMaxScroll,
            getContainerForClone = props.getContainerForClone;
          var getDroppableRef = useCallback(function () {
            return droppableRef.current;
          }, []);
          var setDroppableRef = useCallback(function (value) {
            droppableRef.current = value;
          }, []);
          useCallback(function () {
            return placeholderRef.current;
          }, []);
          var setPlaceholderRef = useCallback(function (value) {
            placeholderRef.current = value;
          }, []);
          var onPlaceholderTransitionEnd = useCallback(function () {
            if (isMovementAllowed()) {
              updateViewportMaxScroll({
                maxScroll: getMaxWindowScroll()
              });
            }
          }, [isMovementAllowed, updateViewportMaxScroll]);
          useDroppablePublisher({
            droppableId: droppableId,
            type: type,
            mode: mode,
            direction: direction,
            isDropDisabled: isDropDisabled,
            isCombineEnabled: isCombineEnabled,
            ignoreContainerClipping: ignoreContainerClipping,
            getDroppableRef: getDroppableRef
          });
          var placeholder = React.createElement(AnimateInOut, {
            on: props.placeholder,
            shouldAnimate: props.shouldAnimatePlaceholder
          }, function (_ref) {
            var onClose = _ref.onClose,
              data = _ref.data,
              animate = _ref.animate;
            return React.createElement(Placeholder$1, {
              placeholder: data,
              onClose: onClose,
              innerRef: setPlaceholderRef,
              animate: animate,
              contextId: contextId,
              onTransitionEnd: onPlaceholderTransitionEnd
            });
          });
          var provided = useMemo(function () {
            return {
              innerRef: setDroppableRef,
              placeholder: placeholder,
              droppableProps: {
                'data-rbd-droppable-id': droppableId,
                'data-rbd-droppable-context-id': contextId
              }
            };
          }, [contextId, droppableId, placeholder, setDroppableRef]);
          var isUsingCloneFor = useClone ? useClone.dragging.draggableId : null;
          var droppableContext = useMemo(function () {
            return {
              droppableId: droppableId,
              type: type,
              isUsingCloneFor: isUsingCloneFor
            };
          }, [droppableId, isUsingCloneFor, type]);
          function getClone() {
            if (!useClone) {
              return null;
            }
            var dragging = useClone.dragging,
              render = useClone.render;
            var node = React.createElement(PrivateDraggable, {
              draggableId: dragging.draggableId,
              index: dragging.source.index,
              isClone: true,
              isEnabled: true,
              shouldRespectForcePress: false,
              canDragInteractiveElements: true
            }, function (draggableProvided, draggableSnapshot) {
              return render(draggableProvided, draggableSnapshot, dragging);
            });
            return ReactDOM.createPortal(node, getContainerForClone());
          }
          return React.createElement(DroppableContext.Provider, {
            value: droppableContext
          }, children(provided, snapshot), getClone());
        }
        var isMatchingType = function isMatchingType(type, critical) {
          return type === critical.droppable.type;
        };
        var getDraggable = function getDraggable(critical, dimensions) {
          return dimensions.draggables[critical.draggable.id];
        };
        var makeMapStateToProps$1 = function makeMapStateToProps() {
          var idleWithAnimation = {
            placeholder: null,
            shouldAnimatePlaceholder: true,
            snapshot: {
              isDraggingOver: false,
              draggingOverWith: null,
              draggingFromThisWith: null,
              isUsingPlaceholder: false
            },
            useClone: null
          };
          var idleWithoutAnimation = _extends({}, idleWithAnimation, {
            shouldAnimatePlaceholder: false
          });
          var getDraggableRubric = memoizeOne(function (descriptor) {
            return {
              draggableId: descriptor.id,
              type: descriptor.type,
              source: {
                index: descriptor.index,
                droppableId: descriptor.droppableId
              }
            };
          });
          var getMapProps = memoizeOne(function (id, isEnabled, isDraggingOverForConsumer, isDraggingOverForImpact, dragging, renderClone) {
            var draggableId = dragging.descriptor.id;
            var isHome = dragging.descriptor.droppableId === id;
            if (isHome) {
              var useClone = renderClone ? {
                render: renderClone,
                dragging: getDraggableRubric(dragging.descriptor)
              } : null;
              var _snapshot = {
                isDraggingOver: isDraggingOverForConsumer,
                draggingOverWith: isDraggingOverForConsumer ? draggableId : null,
                draggingFromThisWith: draggableId,
                isUsingPlaceholder: true
              };
              return {
                placeholder: dragging.placeholder,
                shouldAnimatePlaceholder: false,
                snapshot: _snapshot,
                useClone: useClone
              };
            }
            if (!isEnabled) {
              return idleWithoutAnimation;
            }
            if (!isDraggingOverForImpact) {
              return idleWithAnimation;
            }
            var snapshot = {
              isDraggingOver: isDraggingOverForConsumer,
              draggingOverWith: draggableId,
              draggingFromThisWith: null,
              isUsingPlaceholder: true
            };
            return {
              placeholder: dragging.placeholder,
              shouldAnimatePlaceholder: true,
              snapshot: snapshot,
              useClone: null
            };
          });
          var selector = function selector(state, ownProps) {
            var id = ownProps.droppableId;
            var type = ownProps.type;
            var isEnabled = !ownProps.isDropDisabled;
            var renderClone = ownProps.renderClone;
            if (state.isDragging) {
              var critical = state.critical;
              if (!isMatchingType(type, critical)) {
                return idleWithoutAnimation;
              }
              var dragging = getDraggable(critical, state.dimensions);
              var isDraggingOver = whatIsDraggedOver(state.impact) === id;
              return getMapProps(id, isEnabled, isDraggingOver, isDraggingOver, dragging, renderClone);
            }
            if (state.phase === 'DROP_ANIMATING') {
              var completed = state.completed;
              if (!isMatchingType(type, completed.critical)) {
                return idleWithoutAnimation;
              }
              var _dragging = getDraggable(completed.critical, state.dimensions);
              return getMapProps(id, isEnabled, whatIsDraggedOverFromResult(completed.result) === id, whatIsDraggedOver(completed.impact) === id, _dragging, renderClone);
            }
            if (state.phase === 'IDLE' && state.completed && !state.shouldFlush) {
              var _completed = state.completed;
              if (!isMatchingType(type, _completed.critical)) {
                return idleWithoutAnimation;
              }
              var wasOver = whatIsDraggedOver(_completed.impact) === id;
              var wasCombining = Boolean(_completed.impact.at && _completed.impact.at.type === 'COMBINE');
              var isHome = _completed.critical.droppable.id === id;
              if (wasOver) {
                return wasCombining ? idleWithAnimation : idleWithoutAnimation;
              }
              if (isHome) {
                return idleWithAnimation;
              }
              return idleWithoutAnimation;
            }
            return idleWithoutAnimation;
          };
          return selector;
        };
        var mapDispatchToProps$1 = {
          updateViewportMaxScroll: updateViewportMaxScroll
        };
        function getBody() {
          !document.body ? invariant(false) : void 0;
          return document.body;
        }
        var defaultProps = {
          mode: 'standard',
          type: 'DEFAULT',
          direction: 'vertical',
          isDropDisabled: false,
          isCombineEnabled: false,
          ignoreContainerClipping: false,
          renderClone: null,
          getContainerForClone: getBody
        };
        var ConnectedDroppable = exports('ab', connect(makeMapStateToProps$1, mapDispatchToProps$1, null, {
          context: StoreContext,
          pure: true,
          areStatePropsEqual: isStrictEqual
        })(Droppable));
        ConnectedDroppable.defaultProps = defaultProps;
        var MailOutline = {};
        var interopRequireDefault = {
          exports: {}
        };
        (function (module) {
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              "default": obj
            };
          }
          module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
        })(interopRequireDefault);
        var interopRequireDefaultExports = exports('i', interopRequireDefault.exports);
        var createSvgIcon$1 = {};
        function isPlainObject$1(item) {
          return item !== null && typeof item === 'object' && item.constructor === Object;
        }
        function deepClone(source) {
          if (!isPlainObject$1(source)) {
            return source;
          }
          const output = {};
          Object.keys(source).forEach(key => {
            output[key] = deepClone(source[key]);
          });
          return output;
        }
        function deepmerge(target, source, options = {
          clone: true
        }) {
          const output = options.clone ? _extends({}, target) : target;
          if (isPlainObject$1(target) && isPlainObject$1(source)) {
            Object.keys(source).forEach(key => {
              // Avoid prototype pollution
              if (key === '__proto__') {
                return;
              }
              if (isPlainObject$1(source[key]) && key in target && isPlainObject$1(target[key])) {
                // Since `output` is a clone of `target` and we have narrowed `target` in this block we can cast to the same type.
                output[key] = deepmerge(target[key], source[key], options);
              } else if (options.clone) {
                output[key] = isPlainObject$1(source[key]) ? deepClone(source[key]) : source[key];
              } else {
                output[key] = source[key];
              }
            });
          }
          return output;
        }

        /**
         * WARNING: Don't import this directly.
         * Use `MuiError` from `@mui/utils/macros/MuiError.macro` instead.
         * @param {number} code
         */
        function formatMuiErrorMessage(code) {
          // Apply babel-plugin-transform-template-literals in loose mode
          // loose mode is safe iff we're concatenating primitives
          // see https://babeljs.io/docs/en/babel-plugin-transform-template-literals#loose
          /* eslint-disable prefer-template */
          let url = 'https://mui.com/production-error/?code=' + code;
          for (let i = 1; i < arguments.length; i += 1) {
            // rest params over-transpile for this case
            // eslint-disable-next-line prefer-rest-params
            url += '&args[]=' + encodeURIComponent(arguments[i]);
          }
          return 'Minified MUI error #' + code + '; visit ' + url + ' for the full message.';
          /* eslint-enable prefer-template */
        }

        var reactIs_production_min = {};

        /**
         * @license React
         * react-is.production.min.js
         *
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */
        var b = Symbol.for("react.element"),
          c = Symbol.for("react.portal"),
          d = Symbol.for("react.fragment"),
          e$1 = Symbol.for("react.strict_mode"),
          f = Symbol.for("react.profiler"),
          g = Symbol.for("react.provider"),
          h$2 = Symbol.for("react.context"),
          k$1 = Symbol.for("react.server_context"),
          l$1 = Symbol.for("react.forward_ref"),
          m$1 = Symbol.for("react.suspense"),
          n$2 = Symbol.for("react.suspense_list"),
          p$2 = Symbol.for("react.memo"),
          q$2 = Symbol.for("react.lazy"),
          t$2 = Symbol.for("react.offscreen"),
          u$2;
        u$2 = Symbol.for("react.module.reference");
        function v$1(a) {
          if ("object" === typeof a && null !== a) {
            var r = a.$$typeof;
            switch (r) {
              case b:
                switch (a = a.type, a) {
                  case d:
                  case f:
                  case e$1:
                  case m$1:
                  case n$2:
                    return a;
                  default:
                    switch (a = a && a.$$typeof, a) {
                      case k$1:
                      case h$2:
                      case l$1:
                      case q$2:
                      case p$2:
                      case g:
                        return a;
                      default:
                        return r;
                    }
                }
              case c:
                return r;
            }
          }
        }
        reactIs_production_min.ContextConsumer = h$2;
        reactIs_production_min.ContextProvider = g;
        reactIs_production_min.Element = b;
        reactIs_production_min.ForwardRef = l$1;
        reactIs_production_min.Fragment = d;
        reactIs_production_min.Lazy = q$2;
        reactIs_production_min.Memo = p$2;
        reactIs_production_min.Portal = c;
        reactIs_production_min.Profiler = f;
        reactIs_production_min.StrictMode = e$1;
        reactIs_production_min.Suspense = m$1;
        reactIs_production_min.SuspenseList = n$2;
        reactIs_production_min.isAsyncMode = function () {
          return !1;
        };
        reactIs_production_min.isConcurrentMode = function () {
          return !1;
        };
        reactIs_production_min.isContextConsumer = function (a) {
          return v$1(a) === h$2;
        };
        reactIs_production_min.isContextProvider = function (a) {
          return v$1(a) === g;
        };
        reactIs_production_min.isElement = function (a) {
          return "object" === typeof a && null !== a && a.$$typeof === b;
        };
        reactIs_production_min.isForwardRef = function (a) {
          return v$1(a) === l$1;
        };
        reactIs_production_min.isFragment = function (a) {
          return v$1(a) === d;
        };
        reactIs_production_min.isLazy = function (a) {
          return v$1(a) === q$2;
        };
        reactIs_production_min.isMemo = function (a) {
          return v$1(a) === p$2;
        };
        reactIs_production_min.isPortal = function (a) {
          return v$1(a) === c;
        };
        reactIs_production_min.isProfiler = function (a) {
          return v$1(a) === f;
        };
        reactIs_production_min.isStrictMode = function (a) {
          return v$1(a) === e$1;
        };
        reactIs_production_min.isSuspense = function (a) {
          return v$1(a) === m$1;
        };
        reactIs_production_min.isSuspenseList = function (a) {
          return v$1(a) === n$2;
        };
        reactIs_production_min.isValidElementType = function (a) {
          return "string" === typeof a || "function" === typeof a || a === d || a === f || a === e$1 || a === m$1 || a === n$2 || a === t$2 || "object" === typeof a && null !== a && (a.$$typeof === q$2 || a.$$typeof === p$2 || a.$$typeof === g || a.$$typeof === h$2 || a.$$typeof === l$1 || a.$$typeof === u$2 || void 0 !== a.getModuleId) ? !0 : !1;
        };
        reactIs_production_min.typeOf = v$1;

        // It should to be noted that this function isn't equivalent to `text-transform: capitalize`.
        //
        // A strict capitalization should uppercase the first letter of each word in the sentence.
        // We only handle the first word.
        function capitalize(string) {
          if (typeof string !== 'string') {
            throw new Error(formatMuiErrorMessage(7));
          }
          return string.charAt(0).toUpperCase() + string.slice(1);
        }

        /**
         * Safe chained function.
         *
         * Will only create a new function if needed,
         * otherwise will pass back existing functions or null.
         */
        function createChainedFunction(...funcs) {
          return funcs.reduce((acc, func) => {
            if (func == null) {
              return acc;
            }
            return function chainedFunction(...args) {
              acc.apply(this, args);
              func.apply(this, args);
            };
          }, () => {});
        }

        // Corresponds to 10 frames at 60 Hz.
        // A few bytes payload overhead when lodash/debounce is ~3 kB and debounce ~300 B.
        function debounce(func, wait = 166) {
          let timeout;
          function debounced(...args) {
            const later = () => {
              func.apply(this, args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
          }
          debounced.clear = () => {
            clearTimeout(timeout);
          };
          return debounced;
        }
        function deprecatedPropType(validator, reason) {
          {
            return () => null;
          }
        }
        function isMuiElement(element, muiNames) {
          return /*#__PURE__*/reactExports.isValidElement(element) && muiNames.indexOf(element.type.muiName) !== -1;
        }
        function ownerDocument(node) {
          return node && node.ownerDocument || document;
        }
        function ownerWindow(node) {
          const doc = ownerDocument(node);
          return doc.defaultView || window;
        }
        function requirePropFactory(componentNameInError, Component) {
          {
            return () => null;
          }
        }

        /**
         * TODO v5: consider making it private
         *
         * passes {value} to {ref}
         *
         * WARNING: Be sure to only call this inside a callback that is passed as a ref.
         * Otherwise, make sure to cleanup the previous {ref} if it changes. See
         * https://github.com/mui/material-ui/issues/13539
         *
         * Useful if you want to expose the ref of an inner component to the public API
         * while still using it inside the component.
         * @param ref A ref callback or ref object. If anything falsy, this is a no-op.
         */
        function setRef(ref, value) {
          if (typeof ref === 'function') {
            ref(value);
          } else if (ref) {
            ref.current = value;
          }
        }
        const useEnhancedEffect = typeof window !== 'undefined' ? reactExports.useLayoutEffect : reactExports.useEffect;
        const useEnhancedEffect$1 = exports('aE', useEnhancedEffect);
        let globalId = 0;
        function useGlobalId(idOverride) {
          const [defaultId, setDefaultId] = reactExports.useState(idOverride);
          const id = idOverride || defaultId;
          reactExports.useEffect(() => {
            if (defaultId == null) {
              // Fallback to this default id when possible.
              // Use the incrementing value for client-side rendering only.
              // We can't use it server-side.
              // If you want to use random values please consider the Birthday Problem: https://en.wikipedia.org/wiki/Birthday_problem
              globalId += 1;
              setDefaultId(`mui-${globalId}`);
            }
          }, [defaultId]);
          return id;
        }

        // eslint-disable-next-line no-useless-concat -- Workaround for https://github.com/webpack/webpack/issues/14814
        const maybeReactUseId = React$1['useId' + ''];
        /**
         *
         * @example <div id={useId()} />
         * @param idOverride
         * @returns {string}
         */
        function useId(idOverride) {
          if (maybeReactUseId !== undefined) {
            const reactId = maybeReactUseId();
            return idOverride != null ? idOverride : reactId;
          }
          // eslint-disable-next-line react-hooks/rules-of-hooks -- `React.useId` is invariant at runtime.
          return useGlobalId(idOverride);
        }
        function unsupportedProp(props, propName, componentName, location, propFullName) {
          {
            return null;
          }
        }

        /* eslint-disable react-hooks/rules-of-hooks, react-hooks/exhaustive-deps */
        function useControlled({
          controlled,
          default: defaultProp,
          name,
          state = 'value'
        }) {
          // isControlled is ignored in the hook dependency lists as it should never change.
          const {
            current: isControlled
          } = reactExports.useRef(controlled !== undefined);
          const [valueState, setValue] = reactExports.useState(defaultProp);
          const value = isControlled ? controlled : valueState;
          const setValueIfUncontrolled = reactExports.useCallback(newValue => {
            if (!isControlled) {
              setValue(newValue);
            }
          }, []);
          return [value, setValueIfUncontrolled];
        }

        /**
         * https://github.com/facebook/react/issues/14099#issuecomment-440013892
         */
        function useEventCallback(fn) {
          const ref = reactExports.useRef(fn);
          useEnhancedEffect$1(() => {
            ref.current = fn;
          });
          return reactExports.useCallback((...args) =>
          // @ts-expect-error hide `this`
          // tslint:disable-next-line:ban-comma-operator
          (0, ref.current)(...args), []);
        }
        function useForkRef(...refs) {
          /**
           * This will create a new function if the refs passed to this hook change and are all defined.
           * This means react will call the old forkRef with `null` and the new forkRef
           * with the ref. Cleanup naturally emerges from this behavior.
           */
          return reactExports.useMemo(() => {
            if (refs.every(ref => ref == null)) {
              return null;
            }
            return instance => {
              refs.forEach(ref => {
                setRef(ref, instance);
              });
            };
            // eslint-disable-next-line react-hooks/exhaustive-deps
          }, refs);
        }

        // based on https://github.com/WICG/focus-visible/blob/v4.1.5/src/focus-visible.js
        let hadKeyboardEvent = true;
        let hadFocusVisibleRecently = false;
        let hadFocusVisibleRecentlyTimeout;
        const inputTypesWhitelist = {
          text: true,
          search: true,
          url: true,
          tel: true,
          email: true,
          password: true,
          number: true,
          date: true,
          month: true,
          week: true,
          time: true,
          datetime: true,
          'datetime-local': true
        };

        /**
         * Computes whether the given element should automatically trigger the
         * `focus-visible` class being added, i.e. whether it should always match
         * `:focus-visible` when focused.
         * @param {Element} node
         * @returns {boolean}
         */
        function focusTriggersKeyboardModality(node) {
          const {
            type,
            tagName
          } = node;
          if (tagName === 'INPUT' && inputTypesWhitelist[type] && !node.readOnly) {
            return true;
          }
          if (tagName === 'TEXTAREA' && !node.readOnly) {
            return true;
          }
          if (node.isContentEditable) {
            return true;
          }
          return false;
        }

        /**
         * Keep track of our keyboard modality state with `hadKeyboardEvent`.
         * If the most recent user interaction was via the keyboard;
         * and the key press did not include a meta, alt/option, or control key;
         * then the modality is keyboard. Otherwise, the modality is not keyboard.
         * @param {KeyboardEvent} event
         */
        function handleKeyDown(event) {
          if (event.metaKey || event.altKey || event.ctrlKey) {
            return;
          }
          hadKeyboardEvent = true;
        }

        /**
         * If at any point a user clicks with a pointing device, ensure that we change
         * the modality away from keyboard.
         * This avoids the situation where a user presses a key on an already focused
         * element, and then clicks on a different element, focusing it with a
         * pointing device, while we still think we're in keyboard modality.
         */
        function handlePointerDown() {
          hadKeyboardEvent = false;
        }
        function handleVisibilityChange() {
          if (this.visibilityState === 'hidden') {
            // If the tab becomes active again, the browser will handle calling focus
            // on the element (Safari actually calls it twice).
            // If this tab change caused a blur on an element with focus-visible,
            // re-apply the class when the user switches back to the tab.
            if (hadFocusVisibleRecently) {
              hadKeyboardEvent = true;
            }
          }
        }
        function prepare(doc) {
          doc.addEventListener('keydown', handleKeyDown, true);
          doc.addEventListener('mousedown', handlePointerDown, true);
          doc.addEventListener('pointerdown', handlePointerDown, true);
          doc.addEventListener('touchstart', handlePointerDown, true);
          doc.addEventListener('visibilitychange', handleVisibilityChange, true);
        }
        function isFocusVisible(event) {
          const {
            target
          } = event;
          try {
            return target.matches(':focus-visible');
          } catch (error) {
            // Browsers not implementing :focus-visible will throw a SyntaxError.
            // We use our own heuristic for those browsers.
            // Rethrow might be better if it's not the expected error but do we really
            // want to crash if focus-visible malfunctioned?
          }

          // No need for validFocusTarget check. The user does that by attaching it to
          // focusable events only.
          return hadKeyboardEvent || focusTriggersKeyboardModality(target);
        }
        function useIsFocusVisible() {
          const ref = reactExports.useCallback(node => {
            if (node != null) {
              prepare(node.ownerDocument);
            }
          }, []);
          const isFocusVisibleRef = reactExports.useRef(false);

          /**
           * Should be called if a blur event is fired
           */
          function handleBlurVisible() {
            // checking against potential state variable does not suffice if we focus and blur synchronously.
            // React wouldn't have time to trigger a re-render so `focusVisible` would be stale.
            // Ideally we would adjust `isFocusVisible(event)` to look at `relatedTarget` for blur events.
            // This doesn't work in IE11 due to https://github.com/facebook/react/issues/3751
            // TODO: check again if React releases their internal changes to focus event handling (https://github.com/facebook/react/pull/19186).
            if (isFocusVisibleRef.current) {
              // To detect a tab/window switch, we look for a blur event followed
              // rapidly by a visibility change.
              // If we don't see a visibility change within 100ms, it's probably a
              // regular focus change.
              hadFocusVisibleRecently = true;
              window.clearTimeout(hadFocusVisibleRecentlyTimeout);
              hadFocusVisibleRecentlyTimeout = window.setTimeout(() => {
                hadFocusVisibleRecently = false;
              }, 100);
              isFocusVisibleRef.current = false;
              return true;
            }
            return false;
          }

          /**
           * Should be called if a blur event is fired
           */
          function handleFocusVisible(event) {
            if (isFocusVisible(event)) {
              isFocusVisibleRef.current = true;
              return true;
            }
            return false;
          }
          return {
            isFocusVisibleRef,
            onFocus: handleFocusVisible,
            onBlur: handleBlurVisible,
            ref
          };
        }

        /**
         * Add keys, values of `defaultProps` that does not exist in `props`
         * @param {object} defaultProps
         * @param {object} props
         * @returns {object} resolved props
         */
        function resolveProps(defaultProps, props) {
          const output = _extends({}, props);
          Object.keys(defaultProps).forEach(propName => {
            if (propName.toString().match(/^(components|slots)$/)) {
              output[propName] = _extends({}, defaultProps[propName], output[propName]);
            } else if (propName.toString().match(/^(componentsProps|slotProps)$/)) {
              const defaultSlotProps = defaultProps[propName] || {};
              const slotProps = props[propName];
              output[propName] = {};
              if (!slotProps || !Object.keys(slotProps)) {
                // Reduce the iteration if the slot props is empty
                output[propName] = defaultSlotProps;
              } else if (!defaultSlotProps || !Object.keys(defaultSlotProps)) {
                // Reduce the iteration if the default slot props is empty
                output[propName] = slotProps;
              } else {
                output[propName] = _extends({}, slotProps);
                Object.keys(defaultSlotProps).forEach(slotPropName => {
                  output[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName]);
                });
              }
            } else if (output[propName] === undefined) {
              output[propName] = defaultProps[propName];
            }
          });
          return output;
        }
        function composeClasses(slots, getUtilityClass, classes = undefined) {
          const output = {};
          Object.keys(slots).forEach(
          // `Objet.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
          // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
          slot => {
            output[slot] = slots[slot].reduce((acc, key) => {
              if (key) {
                const utilityClass = getUtilityClass(key);
                if (utilityClass !== '') {
                  acc.push(utilityClass);
                }
                if (classes && classes[key]) {
                  acc.push(classes[key]);
                }
              }
              return acc;
            }, []).join(' ');
          });
          return output;
        }
        const defaultGenerator = componentName => componentName;
        const createClassNameGenerator = () => {
          let generate = defaultGenerator;
          return {
            configure(generator) {
              generate = generator;
            },
            generate(componentName) {
              return generate(componentName);
            },
            reset() {
              generate = defaultGenerator;
            }
          };
        };
        const ClassNameGenerator = createClassNameGenerator();
        const ClassNameGenerator$1 = exports('c3', ClassNameGenerator);
        const globalStateClassesMapping = {
          active: 'active',
          checked: 'checked',
          completed: 'completed',
          disabled: 'disabled',
          readOnly: 'readOnly',
          error: 'error',
          expanded: 'expanded',
          focused: 'focused',
          focusVisible: 'focusVisible',
          required: 'required',
          selected: 'selected'
        };
        function generateUtilityClass(componentName, slot, globalStatePrefix = 'Mui') {
          const globalStateClass = globalStateClassesMapping[slot];
          return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator$1.generate(componentName)}-${slot}`;
        }
        function generateUtilityClasses(componentName, slots, globalStatePrefix = 'Mui') {
          const result = {};
          slots.forEach(slot => {
            result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
          });
          return result;
        }
        function r$2(e) {
          var t,
            f,
            n = "";
          if ("string" == typeof e || "number" == typeof e) n += e;else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (f = r$2(e[t])) && (n && (n += " "), n += f);else for (t in e) e[t] && (n && (n += " "), n += t);
          return n;
        }
        function clsx() {
          for (var e, t, f = 0, n = ""; f < arguments.length;) (e = arguments[f++]) && (t = r$2(e)) && (n && (n += " "), n += t);
          return n;
        }
        function memoize$1(fn) {
          var cache = Object.create(null);
          return function (arg) {
            if (cache[arg] === undefined) cache[arg] = fn(arg);
            return cache[arg];
          };
        }
        var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23

        var isPropValid = /* #__PURE__ */memoize$1(function (prop) {
          return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111
          /* o */ && prop.charCodeAt(1) === 110
          /* n */ && prop.charCodeAt(2) < 91;
        }
        /* Z+1 */);

        /*
         Based off glamor's StyleSheet, thanks Sunil 
         high performance StyleSheet for css-in-js systems
         - uses multiple style tags behind the scenes for millions of rules
        - uses `insertRule` for appending in production for *much* faster performance
         // usage
         import { StyleSheet } from '@emotion/sheet'
         let styleSheet = new StyleSheet({ key: '', container: document.head })
         styleSheet.insert('#box { border: 1px solid red; }')
        - appends a css rule into the stylesheet
         styleSheet.flush()
        - empties the stylesheet of all its contents
         */
        // $FlowFixMe
        function sheetForTag(tag) {
          if (tag.sheet) {
            // $FlowFixMe
            return tag.sheet;
          } // this weirdness brought to you by firefox

          /* istanbul ignore next */

          for (var i = 0; i < document.styleSheets.length; i++) {
            if (document.styleSheets[i].ownerNode === tag) {
              // $FlowFixMe
              return document.styleSheets[i];
            }
          }
        }
        function createStyleElement(options) {
          var tag = document.createElement('style');
          tag.setAttribute('data-emotion', options.key);
          if (options.nonce !== undefined) {
            tag.setAttribute('nonce', options.nonce);
          }
          tag.appendChild(document.createTextNode(''));
          tag.setAttribute('data-s', '');
          return tag;
        }
        var StyleSheet = /*#__PURE__*/function () {
          // Using Node instead of HTMLElement since container may be a ShadowRoot
          function StyleSheet(options) {
            var _this = this;
            this._insertTag = function (tag) {
              var before;
              if (_this.tags.length === 0) {
                if (_this.insertionPoint) {
                  before = _this.insertionPoint.nextSibling;
                } else if (_this.prepend) {
                  before = _this.container.firstChild;
                } else {
                  before = _this.before;
                }
              } else {
                before = _this.tags[_this.tags.length - 1].nextSibling;
              }
              _this.container.insertBefore(tag, before);
              _this.tags.push(tag);
            };
            this.isSpeedy = options.speedy === undefined ? "production" === 'production' : options.speedy;
            this.tags = [];
            this.ctr = 0;
            this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets

            this.key = options.key;
            this.container = options.container;
            this.prepend = options.prepend;
            this.insertionPoint = options.insertionPoint;
            this.before = null;
          }
          var _proto = StyleSheet.prototype;
          _proto.hydrate = function hydrate(nodes) {
            nodes.forEach(this._insertTag);
          };
          _proto.insert = function insert(rule) {
            // the max length is how many rules we have per style tag, it's 65000 in speedy mode
            // it's 1 in dev because we insert source maps that map a single rule to a location
            // and you can only have one source map per style tag
            if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
              this._insertTag(createStyleElement(this));
            }
            var tag = this.tags[this.tags.length - 1];
            if (this.isSpeedy) {
              var sheet = sheetForTag(tag);
              try {
                // this is the ultrafast version, works across browsers
                // the big drawback is that the css won't be editable in devtools
                sheet.insertRule(rule, sheet.cssRules.length);
              } catch (e) {}
            } else {
              tag.appendChild(document.createTextNode(rule));
            }
            this.ctr++;
          };
          _proto.flush = function flush() {
            // $FlowFixMe
            this.tags.forEach(function (tag) {
              return tag.parentNode && tag.parentNode.removeChild(tag);
            });
            this.tags = [];
            this.ctr = 0;
          };
          return StyleSheet;
        }();
        var MS = '-ms-';
        var MOZ = '-moz-';
        var WEBKIT = '-webkit-';
        var COMMENT = 'comm';
        var RULESET = 'rule';
        var DECLARATION = 'decl';
        var MEDIA = '@media';
        var IMPORT = '@import';
        var SUPPORTS = '@supports';
        var KEYFRAMES = '@keyframes';

        /**
         * @param {number}
         * @return {number}
         */
        var abs = Math.abs;

        /**
         * @param {number}
         * @return {string}
         */
        var from = String.fromCharCode;

        /**
         * @param {object}
         * @return {object}
         */
        var assign$1 = Object.assign;

        /**
         * @param {string} value
         * @param {number} length
         * @return {number}
         */
        function hash(value, length) {
          return charat(value, 0) ^ 45 ? (((length << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
        }

        /**
         * @param {string} value
         * @return {string}
         */
        function trim$1(value) {
          return value.trim();
        }

        /**
         * @param {string} value
         * @param {RegExp} pattern
         * @return {string?}
         */
        function match(value, pattern) {
          return (value = pattern.exec(value)) ? value[0] : value;
        }

        /**
         * @param {string} value
         * @param {(string|RegExp)} pattern
         * @param {string} replacement
         * @return {string}
         */
        function replace(value, pattern, replacement) {
          return value.replace(pattern, replacement);
        }

        /**
         * @param {string} value
         * @param {string} search
         * @return {number}
         */
        function indexof(value, search) {
          return value.indexOf(search);
        }

        /**
         * @param {string} value
         * @param {number} index
         * @return {number}
         */
        function charat(value, index) {
          return value.charCodeAt(index) | 0;
        }

        /**
         * @param {string} value
         * @param {number} begin
         * @param {number} end
         * @return {string}
         */
        function substr(value, begin, end) {
          return value.slice(begin, end);
        }

        /**
         * @param {string} value
         * @return {number}
         */
        function strlen(value) {
          return value.length;
        }

        /**
         * @param {any[]} value
         * @return {number}
         */
        function sizeof(value) {
          return value.length;
        }

        /**
         * @param {any} value
         * @param {any[]} array
         * @return {any}
         */
        function append(value, array) {
          return array.push(value), value;
        }

        /**
         * @param {string[]} array
         * @param {function} callback
         * @return {string}
         */
        function combine(array, callback) {
          return array.map(callback).join('');
        }
        var line = 1;
        var column = 1;
        var length = 0;
        var position = 0;
        var character = 0;
        var characters = '';

        /**
         * @param {string} value
         * @param {object | null} root
         * @param {object | null} parent
         * @param {string} type
         * @param {string[] | string} props
         * @param {object[] | string} children
         * @param {number} length
         */
        function node(value, root, parent, type, props, children, length) {
          return {
            value: value,
            root: root,
            parent: parent,
            type: type,
            props: props,
            children: children,
            line: line,
            column: column,
            length: length,
            return: ''
          };
        }

        /**
         * @param {object} root
         * @param {object} props
         * @return {object}
         */
        function copy(root, props) {
          return assign$1(node('', null, null, '', null, null, 0), root, {
            length: -root.length
          }, props);
        }

        /**
         * @return {number}
         */
        function char() {
          return character;
        }

        /**
         * @return {number}
         */
        function prev() {
          character = position > 0 ? charat(characters, --position) : 0;
          if (column--, character === 10) column = 1, line--;
          return character;
        }

        /**
         * @return {number}
         */
        function next() {
          character = position < length ? charat(characters, position++) : 0;
          if (column++, character === 10) column = 1, line++;
          return character;
        }

        /**
         * @return {number}
         */
        function peek() {
          return charat(characters, position);
        }

        /**
         * @return {number}
         */
        function caret() {
          return position;
        }

        /**
         * @param {number} begin
         * @param {number} end
         * @return {string}
         */
        function slice(begin, end) {
          return substr(characters, begin, end);
        }

        /**
         * @param {number} type
         * @return {number}
         */
        function token(type) {
          switch (type) {
            // \0 \t \n \r \s whitespace token
            case 0:
            case 9:
            case 10:
            case 13:
            case 32:
              return 5;
            // ! + , / > @ ~ isolate token
            case 33:
            case 43:
            case 44:
            case 47:
            case 62:
            case 64:
            case 126:
            // ; { } breakpoint token
            case 59:
            case 123:
            case 125:
              return 4;
            // : accompanied token
            case 58:
              return 3;
            // " ' ( [ opening delimit token
            case 34:
            case 39:
            case 40:
            case 91:
              return 2;
            // ) ] closing delimit token
            case 41:
            case 93:
              return 1;
          }
          return 0;
        }

        /**
         * @param {string} value
         * @return {any[]}
         */
        function alloc(value) {
          return line = column = 1, length = strlen(characters = value), position = 0, [];
        }

        /**
         * @param {any} value
         * @return {any}
         */
        function dealloc(value) {
          return characters = '', value;
        }

        /**
         * @param {number} type
         * @return {string}
         */
        function delimit(type) {
          return trim$1(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
        }

        /**
         * @param {number} type
         * @return {string}
         */
        function whitespace(type) {
          while (character = peek()) if (character < 33) next();else break;
          return token(type) > 2 || token(character) > 3 ? '' : ' ';
        }

        /**
         * @param {number} index
         * @param {number} count
         * @return {string}
         */
        function escaping(index, count) {
          while (--count && next())
          // not 0-9 A-F a-f
          if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97) break;
          return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
        }

        /**
         * @param {number} type
         * @return {number}
         */
        function delimiter(type) {
          while (next()) switch (character) {
            // ] ) " '
            case type:
              return position;
            // " '
            case 34:
            case 39:
              if (type !== 34 && type !== 39) delimiter(character);
              break;
            // (
            case 40:
              if (type === 41) delimiter(type);
              break;
            // \
            case 92:
              next();
              break;
          }
          return position;
        }

        /**
         * @param {number} type
         * @param {number} index
         * @return {number}
         */
        function commenter(type, index) {
          while (next())
          // //
          if (type + character === 47 + 10) break;
          // /*
          else if (type + character === 42 + 42 && peek() === 47) break;
          return '/*' + slice(index, position - 1) + '*' + from(type === 47 ? type : next());
        }

        /**
         * @param {number} index
         * @return {string}
         */
        function identifier(index) {
          while (!token(peek())) next();
          return slice(index, position);
        }

        /**
         * @param {string} value
         * @return {object[]}
         */
        function compile(value) {
          return dealloc(parse('', null, null, null, [''], value = alloc(value), 0, [0], value));
        }

        /**
         * @param {string} value
         * @param {object} root
         * @param {object?} parent
         * @param {string[]} rule
         * @param {string[]} rules
         * @param {string[]} rulesets
         * @param {number[]} pseudo
         * @param {number[]} points
         * @param {string[]} declarations
         * @return {object}
         */
        function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
          var index = 0;
          var offset = 0;
          var length = pseudo;
          var atrule = 0;
          var property = 0;
          var previous = 0;
          var variable = 1;
          var scanning = 1;
          var ampersand = 1;
          var character = 0;
          var type = '';
          var props = rules;
          var children = rulesets;
          var reference = rule;
          var characters = type;
          while (scanning) switch (previous = character, character = next()) {
            // (
            case 40:
              if (previous != 108 && charat(characters, length - 1) == 58) {
                if (indexof(characters += replace(delimit(character), '&', '&\f'), '&\f') != -1) ampersand = -1;
                break;
              }
            // " ' [
            case 34:
            case 39:
            case 91:
              characters += delimit(character);
              break;
            // \t \n \r \s
            case 9:
            case 10:
            case 13:
            case 32:
              characters += whitespace(previous);
              break;
            // \
            case 92:
              characters += escaping(caret() - 1, 7);
              continue;
            // /
            case 47:
              switch (peek()) {
                case 42:
                case 47:
                  append(comment(commenter(next(), caret()), root, parent), declarations);
                  break;
                default:
                  characters += '/';
              }
              break;
            // {
            case 123 * variable:
              points[index++] = strlen(characters) * ampersand;
            // } ; \0
            case 125 * variable:
            case 59:
            case 0:
              switch (character) {
                // \0 }
                case 0:
                case 125:
                  scanning = 0;
                // ;
                case 59 + offset:
                  if (ampersand == -1) characters = replace(characters, /\f/g, '');
                  if (property > 0 && strlen(characters) - length) append(property > 32 ? declaration(characters + ';', rule, parent, length - 1) : declaration(replace(characters, ' ', '') + ';', rule, parent, length - 2), declarations);
                  break;
                // @ ;
                case 59:
                  characters += ';';
                // { rule/at-rule
                default:
                  append(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length), rulesets);
                  if (character === 123) if (offset === 0) parse(characters, root, reference, reference, props, rulesets, length, points, children);else switch (atrule === 99 && charat(characters, 3) === 110 ? 100 : atrule) {
                    // d m s
                    case 100:
                    case 109:
                    case 115:
                      parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length), children), rules, children, length, points, rule ? props : children);
                      break;
                    default:
                      parse(characters, reference, reference, reference, [''], children, 0, points, children);
                  }
              }
              index = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo;
              break;
            // :
            case 58:
              length = 1 + strlen(characters), property = previous;
            default:
              if (variable < 1) if (character == 123) --variable;else if (character == 125 && variable++ == 0 && prev() == 125) continue;
              switch (characters += from(character), character * variable) {
                // &
                case 38:
                  ampersand = offset > 0 ? 1 : (characters += '\f', -1);
                  break;
                // ,
                case 44:
                  points[index++] = (strlen(characters) - 1) * ampersand, ampersand = 1;
                  break;
                // @
                case 64:
                  // -
                  if (peek() === 45) characters += delimit(next());
                  atrule = peek(), offset = length = strlen(type = characters += identifier(caret())), character++;
                  break;
                // -
                case 45:
                  if (previous === 45 && strlen(characters) == 2) variable = 0;
              }
          }
          return rulesets;
        }

        /**
         * @param {string} value
         * @param {object} root
         * @param {object?} parent
         * @param {number} index
         * @param {number} offset
         * @param {string[]} rules
         * @param {number[]} points
         * @param {string} type
         * @param {string[]} props
         * @param {string[]} children
         * @param {number} length
         * @return {object}
         */
        function ruleset(value, root, parent, index, offset, rules, points, type, props, children, length) {
          var post = offset - 1;
          var rule = offset === 0 ? rules : [''];
          var size = sizeof(rule);
          for (var i = 0, j = 0, k = 0; i < index; ++i) for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x) if (z = trim$1(j > 0 ? rule[x] + ' ' + y : replace(y, /&\f/g, rule[x]))) props[k++] = z;
          return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length);
        }

        /**
         * @param {number} value
         * @param {object} root
         * @param {object?} parent
         * @return {object}
         */
        function comment(value, root, parent) {
          return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
        }

        /**
         * @param {string} value
         * @param {object} root
         * @param {object?} parent
         * @param {number} length
         * @return {object}
         */
        function declaration(value, root, parent, length) {
          return node(value, root, parent, DECLARATION, substr(value, 0, length), substr(value, length + 1, -1), length);
        }

        /**
         * @param {string} value
         * @param {number} length
         * @param {object[]} children
         * @return {string}
         */
        function prefix$1(value, length, children) {
          switch (hash(value, length)) {
            // color-adjust
            case 5103:
              return WEBKIT + 'print-' + value + value;
            // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
            case 5737:
            case 4201:
            case 3177:
            case 3433:
            case 1641:
            case 4457:
            case 2921:
            // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
            case 5572:
            case 6356:
            case 5844:
            case 3191:
            case 6645:
            case 3005:
            // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
            case 6391:
            case 5879:
            case 5623:
            case 6135:
            case 4599:
            case 4855:
            // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
            case 4215:
            case 6389:
            case 5109:
            case 5365:
            case 5621:
            case 3829:
              return WEBKIT + value + value;
            // tab-size
            case 4789:
              return MOZ + value + value;
            // appearance, user-select, transform, hyphens, text-size-adjust
            case 5349:
            case 4246:
            case 4810:
            case 6968:
            case 2756:
              return WEBKIT + value + MOZ + value + MS + value + value;
            // writing-mode
            case 5936:
              switch (charat(value, length + 11)) {
                // vertical-l(r)
                case 114:
                  return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb') + value;
                // vertical-r(l)
                case 108:
                  return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb-rl') + value;
                // horizontal(-)tb
                case 45:
                  return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'lr') + value;
                // default: fallthrough to below
              }
            // flex, flex-direction, scroll-snap-type, writing-mode
            case 6828:
            case 4268:
            case 2903:
              return WEBKIT + value + MS + value + value;
            // order
            case 6165:
              return WEBKIT + value + MS + 'flex-' + value + value;
            // align-items
            case 5187:
              return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + 'box-$1$2' + MS + 'flex-$1$2') + value;
            // align-self
            case 5443:
              return WEBKIT + value + MS + 'flex-item-' + replace(value, /flex-|-self/g, '') + (!match(value, /flex-|baseline/) ? MS + 'grid-row-' + replace(value, /flex-|-self/g, '') : '') + value;
            // align-content
            case 4675:
              return WEBKIT + value + MS + 'flex-line-pack' + replace(value, /align-content|flex-|-self/g, '') + value;
            // flex-shrink
            case 5548:
              return WEBKIT + value + MS + replace(value, 'shrink', 'negative') + value;
            // flex-basis
            case 5292:
              return WEBKIT + value + MS + replace(value, 'basis', 'preferred-size') + value;
            // flex-grow
            case 6060:
              return WEBKIT + 'box-' + replace(value, '-grow', '') + WEBKIT + value + MS + replace(value, 'grow', 'positive') + value;
            // transition
            case 4554:
              return WEBKIT + replace(value, /([^-])(transform)/g, '$1' + WEBKIT + '$2') + value;
            // cursor
            case 6187:
              return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + '$1'), /(image-set)/, WEBKIT + '$1'), value, '') + value;
            // background, background-image
            case 5495:
            case 3959:
              return replace(value, /(image-set\([^]*)/, WEBKIT + '$1' + '$`$1');
            // justify-content
            case 4968:
              return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + 'box-pack:$3' + MS + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + WEBKIT + value + value;
            // justify-self
            case 4200:
              if (!match(value, /flex-|baseline/)) return MS + 'grid-column-align' + substr(value, length) + value;
              break;
            // grid-template-(columns|rows)
            case 2592:
            case 3360:
              return MS + replace(value, 'template-', '') + value;
            // grid-(row|column)-start
            case 4384:
            case 3616:
              if (children && children.some(function (element, index) {
                return length = index, match(element.props, /grid-\w+-end/);
              })) {
                return ~indexof(value + (children = children[length].value), 'span') ? value : MS + replace(value, '-start', '') + value + MS + 'grid-row-span:' + (~indexof(children, 'span') ? match(children, /\d+/) : +match(children, /\d+/) - +match(value, /\d+/)) + ';';
              }
              return MS + replace(value, '-start', '') + value;
            // grid-(row|column)-end
            case 4896:
            case 4128:
              return children && children.some(function (element) {
                return match(element.props, /grid-\w+-start/);
              }) ? value : MS + replace(replace(value, '-end', '-span'), 'span ', '') + value;
            // (margin|padding)-inline-(start|end)
            case 4095:
            case 3583:
            case 4068:
            case 2532:
              return replace(value, /(.+)-inline(.+)/, WEBKIT + '$1$2') + value;
            // (min|max)?(width|height|inline-size|block-size)
            case 8116:
            case 7059:
            case 5753:
            case 5535:
            case 5445:
            case 5701:
            case 4933:
            case 4677:
            case 5533:
            case 5789:
            case 5021:
            case 4765:
              // stretch, max-content, min-content, fill-available
              if (strlen(value) - 1 - length > 6) switch (charat(value, length + 1)) {
                // (m)ax-content, (m)in-content
                case 109:
                  // -
                  if (charat(value, length + 4) !== 45) break;
                // (f)ill-available, (f)it-content
                case 102:
                  return replace(value, /(.+:)(.+)-([^]+)/, '$1' + WEBKIT + '$2-$3' + '$1' + MOZ + (charat(value, length + 3) == 108 ? '$3' : '$2-$3')) + value;
                // (s)tretch
                case 115:
                  return ~indexof(value, 'stretch') ? prefix$1(replace(value, 'stretch', 'fill-available'), length, children) + value : value;
              }
              break;
            // grid-(column|row)
            case 5152:
            case 5920:
              return replace(value, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function (_, a, b, c, d, e, f) {
                return MS + a + ':' + b + f + (c ? MS + a + '-span:' + (d ? e : +e - +b) + f : '') + value;
              });
            // position: sticky
            case 4949:
              // stick(y)?
              if (charat(value, length + 6) === 121) return replace(value, ':', ':' + WEBKIT) + value;
              break;
            // display: (flex|inline-flex|grid|inline-grid)
            case 6444:
              switch (charat(value, charat(value, 14) === 45 ? 18 : 11)) {
                // (inline-)?fle(x)
                case 120:
                  return replace(value, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, '$1' + WEBKIT + (charat(value, 14) === 45 ? 'inline-' : '') + 'box$3' + '$1' + WEBKIT + '$2$3' + '$1' + MS + '$2box$3') + value;
                // (inline-)?gri(d)
                case 100:
                  return replace(value, ':', ':' + MS) + value;
              }
              break;
            // scroll-margin, scroll-margin-(top|right|bottom|left)
            case 5719:
            case 2647:
            case 2135:
            case 3927:
            case 2391:
              return replace(value, 'scroll-', 'scroll-snap-') + value;
          }
          return value;
        }

        /**
         * @param {object[]} children
         * @param {function} callback
         * @return {string}
         */
        function serialize(children, callback) {
          var output = '';
          var length = sizeof(children);
          for (var i = 0; i < length; i++) output += callback(children[i], i, children, callback) || '';
          return output;
        }

        /**
         * @param {object} element
         * @param {number} index
         * @param {object[]} children
         * @param {function} callback
         * @return {string}
         */
        function stringify(element, index, children, callback) {
          switch (element.type) {
            case IMPORT:
            case DECLARATION:
              return element.return = element.return || element.value;
            case COMMENT:
              return '';
            case KEYFRAMES:
              return element.return = element.value + '{' + serialize(element.children, callback) + '}';
            case RULESET:
              element.value = element.props.join(',');
          }
          return strlen(children = serialize(element.children, callback)) ? element.return = element.value + '{' + children + '}' : '';
        }

        /**
         * @param {function[]} collection
         * @return {function}
         */
        function middleware(collection) {
          var length = sizeof(collection);
          return function (element, index, children, callback) {
            var output = '';
            for (var i = 0; i < length; i++) output += collection[i](element, index, children, callback) || '';
            return output;
          };
        }

        /**
         * @param {function} callback
         * @return {function}
         */
        function rulesheet(callback) {
          return function (element) {
            if (!element.root) if (element = element.return) callback(element);
          };
        }

        /**
         * @param {object} element
         * @param {number} index
         * @param {object[]} children
         * @param {function} callback
         */
        function prefixer$1(element, index, children, callback) {
          if (element.length > -1) if (!element.return) switch (element.type) {
            case DECLARATION:
              element.return = prefix$1(element.value, element.length, children);
              return;
            case KEYFRAMES:
              return serialize([copy(element, {
                value: replace(element.value, '@', '@' + WEBKIT)
              })], callback);
            case RULESET:
              if (element.length) return combine(element.props, function (value) {
                switch (match(value, /(::plac\w+|:read-\w+)/)) {
                  // :read-(only|write)
                  case ':read-only':
                  case ':read-write':
                    return serialize([copy(element, {
                      props: [replace(value, /:(read-\w+)/, ':' + MOZ + '$1')]
                    })], callback);
                  // :placeholder
                  case '::placeholder':
                    return serialize([copy(element, {
                      props: [replace(value, /:(plac\w+)/, ':' + WEBKIT + 'input-$1')]
                    }), copy(element, {
                      props: [replace(value, /:(plac\w+)/, ':' + MOZ + '$1')]
                    }), copy(element, {
                      props: [replace(value, /:(plac\w+)/, MS + 'input-$1')]
                    })], callback);
                }
                return '';
              });
          }
        }
        var identifierWithPointTracking = function identifierWithPointTracking(begin, points, index) {
          var previous = 0;
          var character = 0;
          while (true) {
            previous = character;
            character = peek(); // &\f

            if (previous === 38 && character === 12) {
              points[index] = 1;
            }
            if (token(character)) {
              break;
            }
            next();
          }
          return slice(begin, position);
        };
        var toRules = function toRules(parsed, points) {
          // pretend we've started with a comma
          var index = -1;
          var character = 44;
          do {
            switch (token(character)) {
              case 0:
                // &\f
                if (character === 38 && peek() === 12) {
                  // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings
                  // stylis inserts \f after & to know when & where it should replace this sequence with the context selector
                  // and when it should just concatenate the outer and inner selectors
                  // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here
                  points[index] = 1;
                }
                parsed[index] += identifierWithPointTracking(position - 1, points, index);
                break;
              case 2:
                parsed[index] += delimit(character);
                break;
              case 4:
                // comma
                if (character === 44) {
                  // colon
                  parsed[++index] = peek() === 58 ? '&\f' : '';
                  points[index] = parsed[index].length;
                  break;
                }

              // fallthrough

              default:
                parsed[index] += from(character);
            }
          } while (character = next());
          return parsed;
        };
        var getRules = function getRules(value, points) {
          return dealloc(toRules(alloc(value), points));
        }; // WeakSet would be more appropriate, but only WeakMap is supported in IE11

        var fixedElements = /* #__PURE__ */new WeakMap();
        var compat = function compat(element) {
          if (element.type !== 'rule' || !element.parent ||
          // positive .length indicates that this rule contains pseudo
          // negative .length indicates that this rule has been already prefixed
          element.length < 1) {
            return;
          }
          var value = element.value,
            parent = element.parent;
          var isImplicitRule = element.column === parent.column && element.line === parent.line;
          while (parent.type !== 'rule') {
            parent = parent.parent;
            if (!parent) return;
          } // short-circuit for the simplest case

          if (element.props.length === 1 && value.charCodeAt(0) !== 58
          /* colon */ && !fixedElements.get(parent)) {
            return;
          } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)
          // then the props has already been manipulated beforehand as they that array is shared between it and its "rule parent"

          if (isImplicitRule) {
            return;
          }
          fixedElements.set(element, true);
          var points = [];
          var rules = getRules(value, points);
          var parentRules = parent.props;
          for (var i = 0, k = 0; i < rules.length; i++) {
            for (var j = 0; j < parentRules.length; j++, k++) {
              element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
            }
          }
        };
        var removeLabel = function removeLabel(element) {
          if (element.type === 'decl') {
            var value = element.value;
            if (
            // charcode for l
            value.charCodeAt(0) === 108 &&
            // charcode for b
            value.charCodeAt(2) === 98) {
              // this ignores label
              element["return"] = '';
              element.value = '';
            }
          }
        };

        /* eslint-disable no-fallthrough */

        function prefix(value, length) {
          switch (hash(value, length)) {
            // color-adjust
            case 5103:
              return WEBKIT + 'print-' + value + value;
            // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)

            case 5737:
            case 4201:
            case 3177:
            case 3433:
            case 1641:
            case 4457:
            case 2921: // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break

            case 5572:
            case 6356:
            case 5844:
            case 3191:
            case 6645:
            case 3005: // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,

            case 6391:
            case 5879:
            case 5623:
            case 6135:
            case 4599:
            case 4855: // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)

            case 4215:
            case 6389:
            case 5109:
            case 5365:
            case 5621:
            case 3829:
              return WEBKIT + value + value;
            // appearance, user-select, transform, hyphens, text-size-adjust

            case 5349:
            case 4246:
            case 4810:
            case 6968:
            case 2756:
              return WEBKIT + value + MOZ + value + MS + value + value;
            // flex, flex-direction

            case 6828:
            case 4268:
              return WEBKIT + value + MS + value + value;
            // order

            case 6165:
              return WEBKIT + value + MS + 'flex-' + value + value;
            // align-items

            case 5187:
              return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + 'box-$1$2' + MS + 'flex-$1$2') + value;
            // align-self

            case 5443:
              return WEBKIT + value + MS + 'flex-item-' + replace(value, /flex-|-self/, '') + value;
            // align-content

            case 4675:
              return WEBKIT + value + MS + 'flex-line-pack' + replace(value, /align-content|flex-|-self/, '') + value;
            // flex-shrink

            case 5548:
              return WEBKIT + value + MS + replace(value, 'shrink', 'negative') + value;
            // flex-basis

            case 5292:
              return WEBKIT + value + MS + replace(value, 'basis', 'preferred-size') + value;
            // flex-grow

            case 6060:
              return WEBKIT + 'box-' + replace(value, '-grow', '') + WEBKIT + value + MS + replace(value, 'grow', 'positive') + value;
            // transition

            case 4554:
              return WEBKIT + replace(value, /([^-])(transform)/g, '$1' + WEBKIT + '$2') + value;
            // cursor

            case 6187:
              return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + '$1'), /(image-set)/, WEBKIT + '$1'), value, '') + value;
            // background, background-image

            case 5495:
            case 3959:
              return replace(value, /(image-set\([^]*)/, WEBKIT + '$1' + '$`$1');
            // justify-content

            case 4968:
              return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + 'box-pack:$3' + MS + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + WEBKIT + value + value;
            // (margin|padding)-inline-(start|end)

            case 4095:
            case 3583:
            case 4068:
            case 2532:
              return replace(value, /(.+)-inline(.+)/, WEBKIT + '$1$2') + value;
            // (min|max)?(width|height|inline-size|block-size)

            case 8116:
            case 7059:
            case 5753:
            case 5535:
            case 5445:
            case 5701:
            case 4933:
            case 4677:
            case 5533:
            case 5789:
            case 5021:
            case 4765:
              // stretch, max-content, min-content, fill-available
              if (strlen(value) - 1 - length > 6) switch (charat(value, length + 1)) {
                // (m)ax-content, (m)in-content
                case 109:
                  // -
                  if (charat(value, length + 4) !== 45) break;
                // (f)ill-available, (f)it-content

                case 102:
                  return replace(value, /(.+:)(.+)-([^]+)/, '$1' + WEBKIT + '$2-$3' + '$1' + MOZ + (charat(value, length + 3) == 108 ? '$3' : '$2-$3')) + value;
                // (s)tretch

                case 115:
                  return ~indexof(value, 'stretch') ? prefix(replace(value, 'stretch', 'fill-available'), length) + value : value;
              }
              break;
            // position: sticky

            case 4949:
              // (s)ticky?
              if (charat(value, length + 1) !== 115) break;
            // display: (flex|inline-flex)

            case 6444:
              switch (charat(value, strlen(value) - 3 - (~indexof(value, '!important') && 10))) {
                // stic(k)y
                case 107:
                  return replace(value, ':', ':' + WEBKIT) + value;
                // (inline-)?fl(e)x

                case 101:
                  return replace(value, /(.+:)([^;!]+)(;|!.+)?/, '$1' + WEBKIT + (charat(value, 14) === 45 ? 'inline-' : '') + 'box$3' + '$1' + WEBKIT + '$2$3' + '$1' + MS + '$2box$3') + value;
              }
              break;
            // writing-mode

            case 5936:
              switch (charat(value, length + 11)) {
                // vertical-l(r)
                case 114:
                  return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb') + value;
                // vertical-r(l)

                case 108:
                  return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb-rl') + value;
                // horizontal(-)tb

                case 45:
                  return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'lr') + value;
              }
              return WEBKIT + value + MS + value + value;
          }
          return value;
        }
        var prefixer = function prefixer(element, index, children, callback) {
          if (element.length > -1) if (!element["return"]) switch (element.type) {
            case DECLARATION:
              element["return"] = prefix(element.value, element.length);
              break;
            case KEYFRAMES:
              return serialize([copy(element, {
                value: replace(element.value, '@', '@' + WEBKIT)
              })], callback);
            case RULESET:
              if (element.length) return combine(element.props, function (value) {
                switch (match(value, /(::plac\w+|:read-\w+)/)) {
                  // :read-(only|write)
                  case ':read-only':
                  case ':read-write':
                    return serialize([copy(element, {
                      props: [replace(value, /:(read-\w+)/, ':' + MOZ + '$1')]
                    })], callback);
                  // :placeholder

                  case '::placeholder':
                    return serialize([copy(element, {
                      props: [replace(value, /:(plac\w+)/, ':' + WEBKIT + 'input-$1')]
                    }), copy(element, {
                      props: [replace(value, /:(plac\w+)/, ':' + MOZ + '$1')]
                    }), copy(element, {
                      props: [replace(value, /:(plac\w+)/, MS + 'input-$1')]
                    })], callback);
                }
                return '';
              });
          }
        };
        var defaultStylisPlugins = [prefixer];
        var createCache = exports('ao', function createCache(options) {
          var key = options.key;
          if (key === 'css') {
            var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])"); // get SSRed styles out of the way of React's hydration
            // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)
            // note this very very intentionally targets all style elements regardless of the key to ensure
            // that creating a cache works inside of render of a React component

            Array.prototype.forEach.call(ssrStyles, function (node) {
              // we want to only move elements which have a space in the data-emotion attribute value
              // because that indicates that it is an Emotion 11 server-side rendered style elements
              // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector
              // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)
              // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles
              // will not result in the Emotion 10 styles being destroyed
              var dataEmotionAttribute = node.getAttribute('data-emotion');
              if (dataEmotionAttribute.indexOf(' ') === -1) {
                return;
              }
              document.head.appendChild(node);
              node.setAttribute('data-s', '');
            });
          }
          var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
          var inserted = {};
          var container;
          var nodesToHydrate = [];
          {
            container = options.container || document.head;
            Array.prototype.forEach.call(
            // this means we will ignore elements which don't have a space in them which
            // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
            document.querySelectorAll("style[data-emotion^=\"" + key + " \"]"), function (node) {
              var attrib = node.getAttribute("data-emotion").split(' '); // $FlowFixMe

              for (var i = 1; i < attrib.length; i++) {
                inserted[attrib[i]] = true;
              }
              nodesToHydrate.push(node);
            });
          }
          var _insert;
          var omnipresentPlugins = [compat, removeLabel];
          {
            var currentSheet;
            var finalizingPlugins = [stringify, rulesheet(function (rule) {
              currentSheet.insert(rule);
            })];
            var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
            var stylis = function stylis(styles) {
              return serialize(compile(styles), serializer);
            };
            _insert = function insert(selector, serialized, sheet, shouldCache) {
              currentSheet = sheet;
              stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
              if (shouldCache) {
                cache.inserted[serialized.name] = true;
              }
            };
          }
          var cache = {
            key: key,
            sheet: new StyleSheet({
              key: key,
              container: container,
              nonce: options.nonce,
              speedy: options.speedy,
              prepend: options.prepend,
              insertionPoint: options.insertionPoint
            }),
            nonce: options.nonce,
            inserted: inserted,
            registered: {},
            insert: _insert
          };
          cache.sheet.hydrate(nodesToHydrate);
          return cache;
        });
        var isBrowser = "object" !== 'undefined';
        function getRegisteredStyles(registered, registeredStyles, classNames) {
          var rawClassName = '';
          classNames.split(' ').forEach(function (className) {
            if (registered[className] !== undefined) {
              registeredStyles.push(registered[className] + ";");
            } else {
              rawClassName += className + " ";
            }
          });
          return rawClassName;
        }
        var registerStyles = function registerStyles(cache, serialized, isStringTag) {
          var className = cache.key + "-" + serialized.name;
          if (
          // we only need to add the styles to the registered cache if the
          // class name could be used further down
          // the tree but if it's a string tag, we know it won't
          // so we don't have to add it to registered cache.
          // this improves memory usage since we can avoid storing the whole style string
          (isStringTag === false ||
          // we need to always store it if we're in compat mode and
          // in node since emotion-server relies on whether a style is in
          // the registered cache to know whether a style is global or not
          // also, note that this check will be dead code eliminated in the browser
          isBrowser === false) && cache.registered[className] === undefined) {
            cache.registered[className] = serialized.styles;
          }
        };
        var insertStyles = function insertStyles(cache, serialized, isStringTag) {
          registerStyles(cache, serialized, isStringTag);
          var className = cache.key + "-" + serialized.name;
          if (cache.inserted[serialized.name] === undefined) {
            var current = serialized;
            do {
              cache.insert(serialized === current ? "." + className : '', current, cache.sheet, true);
              current = current.next;
            } while (current !== undefined);
          }
        };

        /* eslint-disable */
        // Inspired by https://github.com/garycourt/murmurhash-js
        // Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
        function murmur2(str) {
          // 'm' and 'r' are mixing constants generated offline.
          // They're not really 'magic', they just happen to work well.
          // const m = 0x5bd1e995;
          // const r = 24;
          // Initialize the hash
          var h = 0; // Mix 4 bytes at a time into the hash

          var k,
            i = 0,
            len = str.length;
          for (; len >= 4; ++i, len -= 4) {
            k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
            k = /* Math.imul(k, m): */
            (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
            k ^= /* k >>> r: */
            k >>> 24;
            h = /* Math.imul(k, m): */
            (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^ /* Math.imul(h, m): */
            (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
          } // Handle the last few bytes of the input array

          switch (len) {
            case 3:
              h ^= (str.charCodeAt(i + 2) & 0xff) << 16;
            case 2:
              h ^= (str.charCodeAt(i + 1) & 0xff) << 8;
            case 1:
              h ^= str.charCodeAt(i) & 0xff;
              h = /* Math.imul(h, m): */
              (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
          } // Do a few final mixes of the hash to ensure the last few
          // bytes are well-incorporated.

          h ^= h >>> 13;
          h = /* Math.imul(h, m): */
          (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
          return ((h ^ h >>> 15) >>> 0).toString(36);
        }
        var unitlessKeys = {
          animationIterationCount: 1,
          borderImageOutset: 1,
          borderImageSlice: 1,
          borderImageWidth: 1,
          boxFlex: 1,
          boxFlexGroup: 1,
          boxOrdinalGroup: 1,
          columnCount: 1,
          columns: 1,
          flex: 1,
          flexGrow: 1,
          flexPositive: 1,
          flexShrink: 1,
          flexNegative: 1,
          flexOrder: 1,
          gridRow: 1,
          gridRowEnd: 1,
          gridRowSpan: 1,
          gridRowStart: 1,
          gridColumn: 1,
          gridColumnEnd: 1,
          gridColumnSpan: 1,
          gridColumnStart: 1,
          msGridRow: 1,
          msGridRowSpan: 1,
          msGridColumn: 1,
          msGridColumnSpan: 1,
          fontWeight: 1,
          lineHeight: 1,
          opacity: 1,
          order: 1,
          orphans: 1,
          tabSize: 1,
          widows: 1,
          zIndex: 1,
          zoom: 1,
          WebkitLineClamp: 1,
          // SVG-related properties
          fillOpacity: 1,
          floodOpacity: 1,
          stopOpacity: 1,
          strokeDasharray: 1,
          strokeDashoffset: 1,
          strokeMiterlimit: 1,
          strokeOpacity: 1,
          strokeWidth: 1
        };
        var hyphenateRegex = /[A-Z]|^ms/g;
        var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
        var isCustomProperty = function isCustomProperty(property) {
          return property.charCodeAt(1) === 45;
        };
        var isProcessableValue = function isProcessableValue(value) {
          return value != null && typeof value !== 'boolean';
        };
        var processStyleName = /* #__PURE__ */memoize$1(function (styleName) {
          return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, '-$&').toLowerCase();
        });
        var processStyleValue = function processStyleValue(key, value) {
          switch (key) {
            case 'animation':
            case 'animationName':
              {
                if (typeof value === 'string') {
                  return value.replace(animationRegex, function (match, p1, p2) {
                    cursor = {
                      name: p1,
                      styles: p2,
                      next: cursor
                    };
                    return p1;
                  });
                }
              }
          }
          if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === 'number' && value !== 0) {
            return value + 'px';
          }
          return value;
        };
        var noComponentSelectorMessage = 'Component selectors can only be used in conjunction with ' + '@emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware ' + 'compiler transform.';
        function handleInterpolation(mergedProps, registered, interpolation) {
          if (interpolation == null) {
            return '';
          }
          if (interpolation.__emotion_styles !== undefined) {
            return interpolation;
          }
          switch (typeof interpolation) {
            case 'boolean':
              {
                return '';
              }
            case 'object':
              {
                if (interpolation.anim === 1) {
                  cursor = {
                    name: interpolation.name,
                    styles: interpolation.styles,
                    next: cursor
                  };
                  return interpolation.name;
                }
                if (interpolation.styles !== undefined) {
                  var next = interpolation.next;
                  if (next !== undefined) {
                    // not the most efficient thing ever but this is a pretty rare case
                    // and there will be very few iterations of this generally
                    while (next !== undefined) {
                      cursor = {
                        name: next.name,
                        styles: next.styles,
                        next: cursor
                      };
                      next = next.next;
                    }
                  }
                  var styles = interpolation.styles + ";";
                  return styles;
                }
                return createStringFromObject(mergedProps, registered, interpolation);
              }
            case 'function':
              {
                if (mergedProps !== undefined) {
                  var previousCursor = cursor;
                  var result = interpolation(mergedProps);
                  cursor = previousCursor;
                  return handleInterpolation(mergedProps, registered, result);
                }
                break;
              }
          } // finalize string values (regular strings and functions interpolated into css calls)

          if (registered == null) {
            return interpolation;
          }
          var cached = registered[interpolation];
          return cached !== undefined ? cached : interpolation;
        }
        function createStringFromObject(mergedProps, registered, obj) {
          var string = '';
          if (Array.isArray(obj)) {
            for (var i = 0; i < obj.length; i++) {
              string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
            }
          } else {
            for (var _key in obj) {
              var value = obj[_key];
              if (typeof value !== 'object') {
                if (registered != null && registered[value] !== undefined) {
                  string += _key + "{" + registered[value] + "}";
                } else if (isProcessableValue(value)) {
                  string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
                }
              } else {
                if (_key === 'NO_COMPONENT_SELECTOR' && "production" !== 'production') {
                  throw new Error(noComponentSelectorMessage);
                }
                if (Array.isArray(value) && typeof value[0] === 'string' && (registered == null || registered[value[0]] === undefined)) {
                  for (var _i = 0; _i < value.length; _i++) {
                    if (isProcessableValue(value[_i])) {
                      string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
                    }
                  }
                } else {
                  var interpolated = handleInterpolation(mergedProps, registered, value);
                  switch (_key) {
                    case 'animation':
                    case 'animationName':
                      {
                        string += processStyleName(_key) + ":" + interpolated + ";";
                        break;
                      }
                    default:
                      {
                        string += _key + "{" + interpolated + "}";
                      }
                  }
                }
              }
            }
          }
          return string;
        }
        var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
        // keyframes are stored on the SerializedStyles object as a linked list

        var cursor;
        var serializeStyles = function serializeStyles(args, registered, mergedProps) {
          if (args.length === 1 && typeof args[0] === 'object' && args[0] !== null && args[0].styles !== undefined) {
            return args[0];
          }
          var stringMode = true;
          var styles = '';
          cursor = undefined;
          var strings = args[0];
          if (strings == null || strings.raw === undefined) {
            stringMode = false;
            styles += handleInterpolation(mergedProps, registered, strings);
          } else {
            styles += strings[0];
          } // we start at 1 since we've already handled the first arg

          for (var i = 1; i < args.length; i++) {
            styles += handleInterpolation(mergedProps, registered, args[i]);
            if (stringMode) {
              styles += strings[i];
            }
          }
          labelPattern.lastIndex = 0;
          var identifierName = '';
          var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5

          while ((match = labelPattern.exec(styles)) !== null) {
            identifierName += '-' +
            // $FlowFixMe we know it's not null
            match[1];
          }
          var name = murmur2(styles) + identifierName;
          return {
            name: name,
            styles: styles,
            next: cursor
          };
        };
        var syncFallback = function syncFallback(create) {
          return create();
        };
        var useInsertionEffect = React$1['useInsertion' + 'Effect'] ? React$1['useInsertion' + 'Effect'] : false;
        var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
        var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;
        var EmotionCacheContext = /* #__PURE__ */reactExports.createContext(
        // we're doing this to avoid preconstruct's dead code elimination in this one case
        // because this module is primarily intended for the browser and node
        // but it's also required in react native and similar environments sometimes
        // and we could have a special build just for that
        // but this is much easier and the native packages
        // might use a different theme context in the future anyway
        typeof HTMLElement !== 'undefined' ? /* #__PURE__ */createCache({
          key: 'css'
        }) : null);
        var CacheProvider = exports('ar', EmotionCacheContext.Provider);
        var withEmotionCache = function withEmotionCache(func) {
          // $FlowFixMe
          return /*#__PURE__*/reactExports.forwardRef(function (props, ref) {
            // the cache will never be null in the browser
            var cache = reactExports.useContext(EmotionCacheContext);
            return func(props, cache, ref);
          });
        };
        var ThemeContext = exports('bI', /* #__PURE__ */reactExports.createContext({}));
        var useTheme$2 = exports('a0', function useTheme() {
          return reactExports.useContext(ThemeContext);
        });

        // initial render from browser, insertBefore context.sheet.tags[0] or if a style hasn't been inserted there yet, appendChild
        // initial client-side render from SSR, use place of hydrating tag

        var Global = exports('bW', /* #__PURE__ */withEmotionCache(function (props, cache) {
          var styles = props.styles;
          var serialized = serializeStyles([styles], undefined, reactExports.useContext(ThemeContext));
          // but it is based on a constant that will never change at runtime
          // it's effectively like having two implementations and switching them out
          // so it's not actually breaking anything

          var sheetRef = reactExports.useRef();
          useInsertionEffectWithLayoutFallback(function () {
            var key = cache.key + "-global"; // use case of https://github.com/emotion-js/emotion/issues/2675

            var sheet = new cache.sheet.constructor({
              key: key,
              nonce: cache.sheet.nonce,
              container: cache.sheet.container,
              speedy: cache.sheet.isSpeedy
            });
            var rehydrating = false; // $FlowFixMe

            var node = document.querySelector("style[data-emotion=\"" + key + " " + serialized.name + "\"]");
            if (cache.sheet.tags.length) {
              sheet.before = cache.sheet.tags[0];
            }
            if (node !== null) {
              rehydrating = true; // clear the hash so this node won't be recognizable as rehydratable by other <Global/>s

              node.setAttribute('data-emotion', key);
              sheet.hydrate([node]);
            }
            sheetRef.current = [sheet, rehydrating];
            return function () {
              sheet.flush();
            };
          }, [cache]);
          useInsertionEffectWithLayoutFallback(function () {
            var sheetRefCurrent = sheetRef.current;
            var sheet = sheetRefCurrent[0],
              rehydrating = sheetRefCurrent[1];
            if (rehydrating) {
              sheetRefCurrent[1] = false;
              return;
            }
            if (serialized.next !== undefined) {
              // insert keyframes
              insertStyles(cache, serialized.next, true);
            }
            if (sheet.tags.length) {
              // if this doesn't exist then it will be null so the style element will be appended
              var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
              sheet.before = element;
              sheet.flush();
            }
            cache.insert("", serialized, sheet, false);
          }, [cache, serialized.name]);
          return null;
        }));
        function css() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return serializeStyles(args);
        }
        var keyframes = exports('c1', function keyframes() {
          var insertable = css.apply(void 0, arguments);
          var name = "animation-" + insertable.name; // $FlowFixMe

          return {
            name: name,
            styles: "@keyframes " + name + "{" + insertable.styles + "}",
            anim: 1,
            toString: function toString() {
              return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
            }
          };
        });
        var testOmitPropsOnStringTag = isPropValid;
        var testOmitPropsOnComponent = function testOmitPropsOnComponent(key) {
          return key !== 'theme';
        };
        var getDefaultShouldForwardProp = function getDefaultShouldForwardProp(tag) {
          return typeof tag === 'string' &&
          // 96 is one less than the char code
          // for "a" so this is checking that
          // it's a lowercase character
          tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
        };
        var composeShouldForwardProps = function composeShouldForwardProps(tag, options, isReal) {
          var shouldForwardProp;
          if (options) {
            var optionsShouldForwardProp = options.shouldForwardProp;
            shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function (propName) {
              return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
            } : optionsShouldForwardProp;
          }
          if (typeof shouldForwardProp !== 'function' && isReal) {
            shouldForwardProp = tag.__emotion_forwardProp;
          }
          return shouldForwardProp;
        };
        var Insertion = function Insertion(_ref) {
          var cache = _ref.cache,
            serialized = _ref.serialized,
            isStringTag = _ref.isStringTag;
          registerStyles(cache, serialized, isStringTag);
          useInsertionEffectAlwaysWithSyncFallback(function () {
            return insertStyles(cache, serialized, isStringTag);
          });
          return null;
        };
        var createStyled$1 = function createStyled(tag, options) {
          var isReal = tag.__emotion_real === tag;
          var baseTag = isReal && tag.__emotion_base || tag;
          var identifierName;
          var targetClassName;
          if (options !== undefined) {
            identifierName = options.label;
            targetClassName = options.target;
          }
          var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);
          var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);
          var shouldUseAs = !defaultShouldForwardProp('as');
          return function () {
            var args = arguments;
            var styles = isReal && tag.__emotion_styles !== undefined ? tag.__emotion_styles.slice(0) : [];
            if (identifierName !== undefined) {
              styles.push("label:" + identifierName + ";");
            }
            if (args[0] == null || args[0].raw === undefined) {
              styles.push.apply(styles, args);
            } else {
              styles.push(args[0][0]);
              var len = args.length;
              var i = 1;
              for (; i < len; i++) {
                styles.push(args[i], args[0][i]);
              }
            } // $FlowFixMe: we need to cast StatelessFunctionalComponent to our PrivateStyledComponent class

            var Styled = withEmotionCache(function (props, cache, ref) {
              var FinalTag = shouldUseAs && props.as || baseTag;
              var className = '';
              var classInterpolations = [];
              var mergedProps = props;
              if (props.theme == null) {
                mergedProps = {};
                for (var key in props) {
                  mergedProps[key] = props[key];
                }
                mergedProps.theme = reactExports.useContext(ThemeContext);
              }
              if (typeof props.className === 'string') {
                className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
              } else if (props.className != null) {
                className = props.className + " ";
              }
              var serialized = serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);
              className += cache.key + "-" + serialized.name;
              if (targetClassName !== undefined) {
                className += " " + targetClassName;
              }
              var finalShouldForwardProp = shouldUseAs && shouldForwardProp === undefined ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
              var newProps = {};
              for (var _key in props) {
                if (shouldUseAs && _key === 'as') continue;
                if (
                // $FlowFixMe
                finalShouldForwardProp(_key)) {
                  newProps[_key] = props[_key];
                }
              }
              newProps.className = className;
              newProps.ref = ref;
              return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Insertion, {
                cache: cache,
                serialized: serialized,
                isStringTag: typeof FinalTag === 'string'
              }), /*#__PURE__*/reactExports.createElement(FinalTag, newProps));
            });
            Styled.displayName = identifierName !== undefined ? identifierName : "Styled(" + (typeof baseTag === 'string' ? baseTag : baseTag.displayName || baseTag.name || 'Component') + ")";
            Styled.defaultProps = tag.defaultProps;
            Styled.__emotion_real = Styled;
            Styled.__emotion_base = baseTag;
            Styled.__emotion_styles = styles;
            Styled.__emotion_forwardProp = shouldForwardProp;
            Object.defineProperty(Styled, 'toString', {
              value: function value() {
                if (targetClassName === undefined && "production" !== 'production') {
                  return 'NO_COMPONENT_SELECTOR';
                } // $FlowFixMe: coerce undefined to string

                return "." + targetClassName;
              }
            });
            Styled.withComponent = function (nextTag, nextOptions) {
              return createStyled(nextTag, _extends({}, options, nextOptions, {
                shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
              })).apply(void 0, styles);
            };
            return Styled;
          };
        };
        const createStyled$2 = createStyled$1;
        var tags = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr',
        // SVG
        'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan'];
        var newStyled = createStyled$2.bind();
        tags.forEach(function (tagName) {
          // $FlowFixMe: we can ignore this because its exposed type is defined by the CreateStyled type
          newStyled[tagName] = newStyled(tagName);
        });
        const emStyled = newStyled;

        /**
         * @mui/styled-engine v5.12.0
         *
         * @license MIT
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */
        /* eslint-disable no-underscore-dangle */
        function styled$2(tag, options) {
          const stylesFactory = emStyled(tag, options);
          return stylesFactory;
        }

        // eslint-disable-next-line @typescript-eslint/naming-convention
        const internal_processStyles = (tag, processor) => {
          // Emotion attaches all the styles as `__emotion_styles`.
          // Ref: https://github.com/emotion-js/emotion/blob/16d971d0da229596d6bcc39d282ba9753c9ee7cf/packages/styled/src/base.js#L186
          if (Array.isArray(tag.__emotion_styles)) {
            tag.__emotion_styles = processor(tag.__emotion_styles);
          }
        };
        const _excluded$9 = ["values", "unit", "step"];
        const sortBreakpointsValues = values => {
          const breakpointsAsArray = Object.keys(values).map(key => ({
            key,
            val: values[key]
          })) || [];
          // Sort in ascending order
          breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
          return breakpointsAsArray.reduce((acc, obj) => {
            return _extends({}, acc, {
              [obj.key]: obj.val
            });
          }, {});
        };

        // Keep in mind that @media is inclusive by the CSS specification.
        function createBreakpoints(breakpoints) {
          const {
              // The breakpoint **start** at this value.
              // For instance with the first breakpoint xs: [xs, sm).
              values = {
                xs: 0,
                // phone
                sm: 600,
                // tablet
                md: 900,
                // small laptop
                lg: 1200,
                // desktop
                xl: 1536 // large screen
              },

              unit = 'px',
              step = 5
            } = breakpoints,
            other = _objectWithoutPropertiesLoose$1(breakpoints, _excluded$9);
          const sortedValues = sortBreakpointsValues(values);
          const keys = Object.keys(sortedValues);
          function up(key) {
            const value = typeof values[key] === 'number' ? values[key] : key;
            return `@media (min-width:${value}${unit})`;
          }
          function down(key) {
            const value = typeof values[key] === 'number' ? values[key] : key;
            return `@media (max-width:${value - step / 100}${unit})`;
          }
          function between(start, end) {
            const endIndex = keys.indexOf(end);
            return `@media (min-width:${typeof values[start] === 'number' ? values[start] : start}${unit}) and ` + `(max-width:${(endIndex !== -1 && typeof values[keys[endIndex]] === 'number' ? values[keys[endIndex]] : end) - step / 100}${unit})`;
          }
          function only(key) {
            if (keys.indexOf(key) + 1 < keys.length) {
              return between(key, keys[keys.indexOf(key) + 1]);
            }
            return up(key);
          }
          function not(key) {
            // handle first and last key separately, for better readability
            const keyIndex = keys.indexOf(key);
            if (keyIndex === 0) {
              return up(keys[1]);
            }
            if (keyIndex === keys.length - 1) {
              return down(keys[keyIndex]);
            }
            return between(key, keys[keys.indexOf(key) + 1]).replace('@media', '@media not all and');
          }
          return _extends({
            keys,
            values: sortedValues,
            up,
            down,
            between,
            only,
            not,
            unit
          }, other);
        }
        const shape = {
          borderRadius: 4
        };
        const shape$1 = shape;
        function merge$1(acc, item) {
          if (!item) {
            return acc;
          }
          return deepmerge(acc, item, {
            clone: false // No need to clone deep, it's way faster.
          });
        }

        // The breakpoint **start** at this value.
        // For instance with the first breakpoint xs: [xs, sm[.
        const values = {
          xs: 0,
          // phone
          sm: 600,
          // tablet
          md: 900,
          // small laptop
          lg: 1200,
          // desktop
          xl: 1536 // large screen
        };

        const defaultBreakpoints = {
          // Sorted ASC by size. That's important.
          // It can't be configured as it's used statically for propTypes.
          keys: ['xs', 'sm', 'md', 'lg', 'xl'],
          up: key => `@media (min-width:${values[key]}px)`
        };
        function handleBreakpoints(props, propValue, styleFromPropValue) {
          const theme = props.theme || {};
          if (Array.isArray(propValue)) {
            const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
            return propValue.reduce((acc, item, index) => {
              acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
              return acc;
            }, {});
          }
          if (typeof propValue === 'object') {
            const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
            return Object.keys(propValue).reduce((acc, breakpoint) => {
              // key is breakpoint
              if (Object.keys(themeBreakpoints.values || values).indexOf(breakpoint) !== -1) {
                const mediaKey = themeBreakpoints.up(breakpoint);
                acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
              } else {
                const cssKey = breakpoint;
                acc[cssKey] = propValue[cssKey];
              }
              return acc;
            }, {});
          }
          const output = styleFromPropValue(propValue);
          return output;
        }
        function createEmptyBreakpointObject(breakpointsInput = {}) {
          var _breakpointsInput$key;
          const breakpointsInOrder = (_breakpointsInput$key = breakpointsInput.keys) == null ? void 0 : _breakpointsInput$key.reduce((acc, key) => {
            const breakpointStyleKey = breakpointsInput.up(key);
            acc[breakpointStyleKey] = {};
            return acc;
          }, {});
          return breakpointsInOrder || {};
        }
        function removeUnusedBreakpoints(breakpointKeys, style) {
          return breakpointKeys.reduce((acc, key) => {
            const breakpointOutput = acc[key];
            const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
            if (isBreakpointUnused) {
              delete acc[key];
            }
            return acc;
          }, style);
        }
        function mergeBreakpointsInOrder(breakpointsInput, ...styles) {
          const emptyBreakpoints = createEmptyBreakpointObject(breakpointsInput);
          const mergedOutput = [emptyBreakpoints, ...styles].reduce((prev, next) => deepmerge(prev, next), {});
          return removeUnusedBreakpoints(Object.keys(emptyBreakpoints), mergedOutput);
        }

        // compute base for responsive values; e.g.,
        // [1,2,3] => {xs: true, sm: true, md: true}
        // {xs: 1, sm: 2, md: 3} => {xs: true, sm: true, md: true}
        function computeBreakpointsBase(breakpointValues, themeBreakpoints) {
          // fixed value
          if (typeof breakpointValues !== 'object') {
            return {};
          }
          const base = {};
          const breakpointsKeys = Object.keys(themeBreakpoints);
          if (Array.isArray(breakpointValues)) {
            breakpointsKeys.forEach((breakpoint, i) => {
              if (i < breakpointValues.length) {
                base[breakpoint] = true;
              }
            });
          } else {
            breakpointsKeys.forEach(breakpoint => {
              if (breakpointValues[breakpoint] != null) {
                base[breakpoint] = true;
              }
            });
          }
          return base;
        }
        function resolveBreakpointValues({
          values: breakpointValues,
          breakpoints: themeBreakpoints,
          base: customBase
        }) {
          const base = customBase || computeBreakpointsBase(breakpointValues, themeBreakpoints);
          const keys = Object.keys(base);
          if (keys.length === 0) {
            return breakpointValues;
          }
          let previous;
          return keys.reduce((acc, breakpoint, i) => {
            if (Array.isArray(breakpointValues)) {
              acc[breakpoint] = breakpointValues[i] != null ? breakpointValues[i] : breakpointValues[previous];
              previous = i;
            } else if (typeof breakpointValues === 'object') {
              acc[breakpoint] = breakpointValues[breakpoint] != null ? breakpointValues[breakpoint] : breakpointValues[previous];
              previous = breakpoint;
            } else {
              acc[breakpoint] = breakpointValues;
            }
            return acc;
          }, {});
        }
        function getPath(obj, path, checkVars = true) {
          if (!path || typeof path !== 'string') {
            return null;
          }

          // Check if CSS variables are used
          if (obj && obj.vars && checkVars) {
            const val = `vars.${path}`.split('.').reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
            if (val != null) {
              return val;
            }
          }
          return path.split('.').reduce((acc, item) => {
            if (acc && acc[item] != null) {
              return acc[item];
            }
            return null;
          }, obj);
        }
        function getStyleValue(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
          let value;
          if (typeof themeMapping === 'function') {
            value = themeMapping(propValueFinal);
          } else if (Array.isArray(themeMapping)) {
            value = themeMapping[propValueFinal] || userValue;
          } else {
            value = getPath(themeMapping, propValueFinal) || userValue;
          }
          if (transform) {
            value = transform(value, userValue, themeMapping);
          }
          return value;
        }
        function style$1(options) {
          const {
            prop,
            cssProperty = options.prop,
            themeKey,
            transform
          } = options;

          // false positive
          // eslint-disable-next-line react/function-component-definition
          const fn = props => {
            if (props[prop] == null) {
              return null;
            }
            const propValue = props[prop];
            const theme = props.theme;
            const themeMapping = getPath(theme, themeKey) || {};
            const styleFromPropValue = propValueFinal => {
              let value = getStyleValue(themeMapping, transform, propValueFinal);
              if (propValueFinal === value && typeof propValueFinal === 'string') {
                // Haven't found value
                value = getStyleValue(themeMapping, transform, `${prop}${propValueFinal === 'default' ? '' : capitalize(propValueFinal)}`, propValueFinal);
              }
              if (cssProperty === false) {
                return value;
              }
              return {
                [cssProperty]: value
              };
            };
            return handleBreakpoints(props, propValue, styleFromPropValue);
          };
          fn.propTypes = {};
          fn.filterProps = [prop];
          return fn;
        }
        function memoize(fn) {
          const cache = {};
          return arg => {
            if (cache[arg] === undefined) {
              cache[arg] = fn(arg);
            }
            return cache[arg];
          };
        }
        const properties = {
          m: 'margin',
          p: 'padding'
        };
        const directions = {
          t: 'Top',
          r: 'Right',
          b: 'Bottom',
          l: 'Left',
          x: ['Left', 'Right'],
          y: ['Top', 'Bottom']
        };
        const aliases = {
          marginX: 'mx',
          marginY: 'my',
          paddingX: 'px',
          paddingY: 'py'
        };

        // memoize() impact:
        // From 300,000 ops/sec
        // To 350,000 ops/sec
        const getCssProperties = memoize(prop => {
          // It's not a shorthand notation.
          if (prop.length > 2) {
            if (aliases[prop]) {
              prop = aliases[prop];
            } else {
              return [prop];
            }
          }
          const [a, b] = prop.split('');
          const property = properties[a];
          const direction = directions[b] || '';
          return Array.isArray(direction) ? direction.map(dir => property + dir) : [property + direction];
        });
        const marginKeys = ['m', 'mt', 'mr', 'mb', 'ml', 'mx', 'my', 'margin', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'marginX', 'marginY', 'marginInline', 'marginInlineStart', 'marginInlineEnd', 'marginBlock', 'marginBlockStart', 'marginBlockEnd'];
        const paddingKeys = ['p', 'pt', 'pr', 'pb', 'pl', 'px', 'py', 'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', 'paddingX', 'paddingY', 'paddingInline', 'paddingInlineStart', 'paddingInlineEnd', 'paddingBlock', 'paddingBlockStart', 'paddingBlockEnd'];
        [...marginKeys, ...paddingKeys];
        function createUnaryUnit(theme, themeKey, defaultValue, propName) {
          var _getPath;
          const themeSpacing = (_getPath = getPath(theme, themeKey, false)) != null ? _getPath : defaultValue;
          if (typeof themeSpacing === 'number') {
            return abs => {
              if (typeof abs === 'string') {
                return abs;
              }
              return themeSpacing * abs;
            };
          }
          if (Array.isArray(themeSpacing)) {
            return abs => {
              if (typeof abs === 'string') {
                return abs;
              }
              return themeSpacing[abs];
            };
          }
          if (typeof themeSpacing === 'function') {
            return themeSpacing;
          }
          return () => undefined;
        }
        function createUnarySpacing(theme) {
          return createUnaryUnit(theme, 'spacing', 8);
        }
        function getValue(transformer, propValue) {
          if (typeof propValue === 'string' || propValue == null) {
            return propValue;
          }
          const abs = Math.abs(propValue);
          const transformed = transformer(abs);
          if (propValue >= 0) {
            return transformed;
          }
          if (typeof transformed === 'number') {
            return -transformed;
          }
          return `-${transformed}`;
        }
        function getStyleFromPropValue(cssProperties, transformer) {
          return propValue => cssProperties.reduce((acc, cssProperty) => {
            acc[cssProperty] = getValue(transformer, propValue);
            return acc;
          }, {});
        }
        function resolveCssProperty(props, keys, prop, transformer) {
          // Using a hash computation over an array iteration could be faster, but with only 28 items,
          // it's doesn't worth the bundle size.
          if (keys.indexOf(prop) === -1) {
            return null;
          }
          const cssProperties = getCssProperties(prop);
          const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
          const propValue = props[prop];
          return handleBreakpoints(props, propValue, styleFromPropValue);
        }
        function style(props, keys) {
          const transformer = createUnarySpacing(props.theme);
          return Object.keys(props).map(prop => resolveCssProperty(props, keys, prop, transformer)).reduce(merge$1, {});
        }
        function margin(props) {
          return style(props, marginKeys);
        }
        margin.propTypes = {};
        margin.filterProps = marginKeys;
        function padding(props) {
          return style(props, paddingKeys);
        }
        padding.propTypes = {};
        padding.filterProps = paddingKeys;

        /* tslint:enable:unified-signatures */

        function createSpacing(spacingInput = 8) {
          // Already transformed.
          if (spacingInput.mui) {
            return spacingInput;
          }

          // Material Design layouts are visually balanced. Most measurements align to an 8dp grid, which aligns both spacing and the overall layout.
          // Smaller components, such as icons, can align to a 4dp grid.
          // https://m2.material.io/design/layout/understanding-layout.html
          const transform = createUnarySpacing({
            spacing: spacingInput
          });
          const spacing = (...argsInput) => {
            const args = argsInput.length === 0 ? [1] : argsInput;
            return args.map(argument => {
              const output = transform(argument);
              return typeof output === 'number' ? `${output}px` : output;
            }).join(' ');
          };
          spacing.mui = true;
          return spacing;
        }
        function compose(...styles) {
          const handlers = styles.reduce((acc, style) => {
            style.filterProps.forEach(prop => {
              acc[prop] = style;
            });
            return acc;
          }, {});

          // false positive
          // eslint-disable-next-line react/function-component-definition
          const fn = props => {
            return Object.keys(props).reduce((acc, prop) => {
              if (handlers[prop]) {
                return merge$1(acc, handlers[prop](props));
              }
              return acc;
            }, {});
          };
          fn.propTypes = {};
          fn.filterProps = styles.reduce((acc, style) => acc.concat(style.filterProps), []);
          return fn;
        }
        function borderTransform(value) {
          if (typeof value !== 'number') {
            return value;
          }
          return `${value}px solid`;
        }
        const border = style$1({
          prop: 'border',
          themeKey: 'borders',
          transform: borderTransform
        });
        const borderTop = style$1({
          prop: 'borderTop',
          themeKey: 'borders',
          transform: borderTransform
        });
        const borderRight = style$1({
          prop: 'borderRight',
          themeKey: 'borders',
          transform: borderTransform
        });
        const borderBottom = style$1({
          prop: 'borderBottom',
          themeKey: 'borders',
          transform: borderTransform
        });
        const borderLeft = style$1({
          prop: 'borderLeft',
          themeKey: 'borders',
          transform: borderTransform
        });
        const borderColor = style$1({
          prop: 'borderColor',
          themeKey: 'palette'
        });
        const borderTopColor = style$1({
          prop: 'borderTopColor',
          themeKey: 'palette'
        });
        const borderRightColor = style$1({
          prop: 'borderRightColor',
          themeKey: 'palette'
        });
        const borderBottomColor = style$1({
          prop: 'borderBottomColor',
          themeKey: 'palette'
        });
        const borderLeftColor = style$1({
          prop: 'borderLeftColor',
          themeKey: 'palette'
        });

        // false positive
        // eslint-disable-next-line react/function-component-definition
        const borderRadius = props => {
          if (props.borderRadius !== undefined && props.borderRadius !== null) {
            const transformer = createUnaryUnit(props.theme, 'shape.borderRadius', 4);
            const styleFromPropValue = propValue => ({
              borderRadius: getValue(transformer, propValue)
            });
            return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
          }
          return null;
        };
        borderRadius.propTypes = {};
        borderRadius.filterProps = ['borderRadius'];
        compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius);

        // false positive
        // eslint-disable-next-line react/function-component-definition
        const gap = props => {
          if (props.gap !== undefined && props.gap !== null) {
            const transformer = createUnaryUnit(props.theme, 'spacing', 8);
            const styleFromPropValue = propValue => ({
              gap: getValue(transformer, propValue)
            });
            return handleBreakpoints(props, props.gap, styleFromPropValue);
          }
          return null;
        };
        gap.propTypes = {};
        gap.filterProps = ['gap'];

        // false positive
        // eslint-disable-next-line react/function-component-definition
        const columnGap = props => {
          if (props.columnGap !== undefined && props.columnGap !== null) {
            const transformer = createUnaryUnit(props.theme, 'spacing', 8);
            const styleFromPropValue = propValue => ({
              columnGap: getValue(transformer, propValue)
            });
            return handleBreakpoints(props, props.columnGap, styleFromPropValue);
          }
          return null;
        };
        columnGap.propTypes = {};
        columnGap.filterProps = ['columnGap'];

        // false positive
        // eslint-disable-next-line react/function-component-definition
        const rowGap = props => {
          if (props.rowGap !== undefined && props.rowGap !== null) {
            const transformer = createUnaryUnit(props.theme, 'spacing', 8);
            const styleFromPropValue = propValue => ({
              rowGap: getValue(transformer, propValue)
            });
            return handleBreakpoints(props, props.rowGap, styleFromPropValue);
          }
          return null;
        };
        rowGap.propTypes = {};
        rowGap.filterProps = ['rowGap'];
        const gridColumn = style$1({
          prop: 'gridColumn'
        });
        const gridRow = style$1({
          prop: 'gridRow'
        });
        const gridAutoFlow = style$1({
          prop: 'gridAutoFlow'
        });
        const gridAutoColumns = style$1({
          prop: 'gridAutoColumns'
        });
        const gridAutoRows = style$1({
          prop: 'gridAutoRows'
        });
        const gridTemplateColumns = style$1({
          prop: 'gridTemplateColumns'
        });
        const gridTemplateRows = style$1({
          prop: 'gridTemplateRows'
        });
        const gridTemplateAreas = style$1({
          prop: 'gridTemplateAreas'
        });
        const gridArea = style$1({
          prop: 'gridArea'
        });
        compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
        function paletteTransform(value, userValue) {
          if (userValue === 'grey') {
            return userValue;
          }
          return value;
        }
        const color = style$1({
          prop: 'color',
          themeKey: 'palette',
          transform: paletteTransform
        });
        const bgcolor = style$1({
          prop: 'bgcolor',
          cssProperty: 'backgroundColor',
          themeKey: 'palette',
          transform: paletteTransform
        });
        const backgroundColor = style$1({
          prop: 'backgroundColor',
          themeKey: 'palette',
          transform: paletteTransform
        });
        compose(color, bgcolor, backgroundColor);
        function sizingTransform(value) {
          return value <= 1 && value !== 0 ? `${value * 100}%` : value;
        }
        const width = style$1({
          prop: 'width',
          transform: sizingTransform
        });
        const maxWidth = props => {
          if (props.maxWidth !== undefined && props.maxWidth !== null) {
            const styleFromPropValue = propValue => {
              var _props$theme, _props$theme$breakpoi, _props$theme$breakpoi2;
              const breakpoint = ((_props$theme = props.theme) == null ? void 0 : (_props$theme$breakpoi = _props$theme.breakpoints) == null ? void 0 : (_props$theme$breakpoi2 = _props$theme$breakpoi.values) == null ? void 0 : _props$theme$breakpoi2[propValue]) || values[propValue];
              return {
                maxWidth: breakpoint || sizingTransform(propValue)
              };
            };
            return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
          }
          return null;
        };
        maxWidth.filterProps = ['maxWidth'];
        const minWidth = style$1({
          prop: 'minWidth',
          transform: sizingTransform
        });
        const height = style$1({
          prop: 'height',
          transform: sizingTransform
        });
        const maxHeight = style$1({
          prop: 'maxHeight',
          transform: sizingTransform
        });
        const minHeight = style$1({
          prop: 'minHeight',
          transform: sizingTransform
        });
        style$1({
          prop: 'size',
          cssProperty: 'width',
          transform: sizingTransform
        });
        style$1({
          prop: 'size',
          cssProperty: 'height',
          transform: sizingTransform
        });
        const boxSizing = style$1({
          prop: 'boxSizing'
        });
        compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
        const defaultSxConfig = {
          // borders
          border: {
            themeKey: 'borders',
            transform: borderTransform
          },
          borderTop: {
            themeKey: 'borders',
            transform: borderTransform
          },
          borderRight: {
            themeKey: 'borders',
            transform: borderTransform
          },
          borderBottom: {
            themeKey: 'borders',
            transform: borderTransform
          },
          borderLeft: {
            themeKey: 'borders',
            transform: borderTransform
          },
          borderColor: {
            themeKey: 'palette'
          },
          borderTopColor: {
            themeKey: 'palette'
          },
          borderRightColor: {
            themeKey: 'palette'
          },
          borderBottomColor: {
            themeKey: 'palette'
          },
          borderLeftColor: {
            themeKey: 'palette'
          },
          borderRadius: {
            themeKey: 'shape.borderRadius',
            style: borderRadius
          },
          // palette
          color: {
            themeKey: 'palette',
            transform: paletteTransform
          },
          bgcolor: {
            themeKey: 'palette',
            cssProperty: 'backgroundColor',
            transform: paletteTransform
          },
          backgroundColor: {
            themeKey: 'palette',
            transform: paletteTransform
          },
          // spacing
          p: {
            style: padding
          },
          pt: {
            style: padding
          },
          pr: {
            style: padding
          },
          pb: {
            style: padding
          },
          pl: {
            style: padding
          },
          px: {
            style: padding
          },
          py: {
            style: padding
          },
          padding: {
            style: padding
          },
          paddingTop: {
            style: padding
          },
          paddingRight: {
            style: padding
          },
          paddingBottom: {
            style: padding
          },
          paddingLeft: {
            style: padding
          },
          paddingX: {
            style: padding
          },
          paddingY: {
            style: padding
          },
          paddingInline: {
            style: padding
          },
          paddingInlineStart: {
            style: padding
          },
          paddingInlineEnd: {
            style: padding
          },
          paddingBlock: {
            style: padding
          },
          paddingBlockStart: {
            style: padding
          },
          paddingBlockEnd: {
            style: padding
          },
          m: {
            style: margin
          },
          mt: {
            style: margin
          },
          mr: {
            style: margin
          },
          mb: {
            style: margin
          },
          ml: {
            style: margin
          },
          mx: {
            style: margin
          },
          my: {
            style: margin
          },
          margin: {
            style: margin
          },
          marginTop: {
            style: margin
          },
          marginRight: {
            style: margin
          },
          marginBottom: {
            style: margin
          },
          marginLeft: {
            style: margin
          },
          marginX: {
            style: margin
          },
          marginY: {
            style: margin
          },
          marginInline: {
            style: margin
          },
          marginInlineStart: {
            style: margin
          },
          marginInlineEnd: {
            style: margin
          },
          marginBlock: {
            style: margin
          },
          marginBlockStart: {
            style: margin
          },
          marginBlockEnd: {
            style: margin
          },
          // display
          displayPrint: {
            cssProperty: false,
            transform: value => ({
              '@media print': {
                display: value
              }
            })
          },
          display: {},
          overflow: {},
          textOverflow: {},
          visibility: {},
          whiteSpace: {},
          // flexbox
          flexBasis: {},
          flexDirection: {},
          flexWrap: {},
          justifyContent: {},
          alignItems: {},
          alignContent: {},
          order: {},
          flex: {},
          flexGrow: {},
          flexShrink: {},
          alignSelf: {},
          justifyItems: {},
          justifySelf: {},
          // grid
          gap: {
            style: gap
          },
          rowGap: {
            style: rowGap
          },
          columnGap: {
            style: columnGap
          },
          gridColumn: {},
          gridRow: {},
          gridAutoFlow: {},
          gridAutoColumns: {},
          gridAutoRows: {},
          gridTemplateColumns: {},
          gridTemplateRows: {},
          gridTemplateAreas: {},
          gridArea: {},
          // positions
          position: {},
          zIndex: {
            themeKey: 'zIndex'
          },
          top: {},
          right: {},
          bottom: {},
          left: {},
          // shadows
          boxShadow: {
            themeKey: 'shadows'
          },
          // sizing
          width: {
            transform: sizingTransform
          },
          maxWidth: {
            style: maxWidth
          },
          minWidth: {
            transform: sizingTransform
          },
          height: {
            transform: sizingTransform
          },
          maxHeight: {
            transform: sizingTransform
          },
          minHeight: {
            transform: sizingTransform
          },
          boxSizing: {},
          // typography
          fontFamily: {
            themeKey: 'typography'
          },
          fontSize: {
            themeKey: 'typography'
          },
          fontStyle: {
            themeKey: 'typography'
          },
          fontWeight: {
            themeKey: 'typography'
          },
          letterSpacing: {},
          textTransform: {},
          lineHeight: {},
          textAlign: {},
          typography: {
            cssProperty: false,
            themeKey: 'typography'
          }
        };
        const defaultSxConfig$1 = exports('bX', defaultSxConfig);
        function objectsHaveSameKeys(...objects) {
          const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);
          const union = new Set(allKeys);
          return objects.every(object => union.size === Object.keys(object).length);
        }
        function callIfFn(maybeFn, arg) {
          return typeof maybeFn === 'function' ? maybeFn(arg) : maybeFn;
        }

        // eslint-disable-next-line @typescript-eslint/naming-convention
        function unstable_createStyleFunctionSx() {
          function getThemeValue(prop, val, theme, config) {
            const props = {
              [prop]: val,
              theme
            };
            const options = config[prop];
            if (!options) {
              return {
                [prop]: val
              };
            }
            const {
              cssProperty = prop,
              themeKey,
              transform,
              style
            } = options;
            if (val == null) {
              return null;
            }
            if (themeKey === 'typography' && val === 'inherit') {
              return {
                [prop]: val
              };
            }
            const themeMapping = getPath(theme, themeKey) || {};
            if (style) {
              return style(props);
            }
            const styleFromPropValue = propValueFinal => {
              let value = getStyleValue(themeMapping, transform, propValueFinal);
              if (propValueFinal === value && typeof propValueFinal === 'string') {
                // Haven't found value
                value = getStyleValue(themeMapping, transform, `${prop}${propValueFinal === 'default' ? '' : capitalize(propValueFinal)}`, propValueFinal);
              }
              if (cssProperty === false) {
                return value;
              }
              return {
                [cssProperty]: value
              };
            };
            return handleBreakpoints(props, val, styleFromPropValue);
          }
          function styleFunctionSx(props) {
            var _theme$unstable_sxCon;
            const {
              sx,
              theme = {}
            } = props || {};
            if (!sx) {
              return null; // Emotion & styled-components will neglect null
            }

            const config = (_theme$unstable_sxCon = theme.unstable_sxConfig) != null ? _theme$unstable_sxCon : defaultSxConfig$1;

            /*
             * Receive `sxInput` as object or callback
             * and then recursively check keys & values to create media query object styles.
             * (the result will be used in `styled`)
             */
            function traverse(sxInput) {
              let sxObject = sxInput;
              if (typeof sxInput === 'function') {
                sxObject = sxInput(theme);
              } else if (typeof sxInput !== 'object') {
                // value
                return sxInput;
              }
              if (!sxObject) {
                return null;
              }
              const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
              const breakpointsKeys = Object.keys(emptyBreakpoints);
              let css = emptyBreakpoints;
              Object.keys(sxObject).forEach(styleKey => {
                const value = callIfFn(sxObject[styleKey], theme);
                if (value !== null && value !== undefined) {
                  if (typeof value === 'object') {
                    if (config[styleKey]) {
                      css = merge$1(css, getThemeValue(styleKey, value, theme, config));
                    } else {
                      const breakpointsValues = handleBreakpoints({
                        theme
                      }, value, x => ({
                        [styleKey]: x
                      }));
                      if (objectsHaveSameKeys(breakpointsValues, value)) {
                        css[styleKey] = styleFunctionSx({
                          sx: value,
                          theme
                        });
                      } else {
                        css = merge$1(css, breakpointsValues);
                      }
                    }
                  } else {
                    css = merge$1(css, getThemeValue(styleKey, value, theme, config));
                  }
                }
              });
              return removeUnusedBreakpoints(breakpointsKeys, css);
            }
            return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
          }
          return styleFunctionSx;
        }
        const styleFunctionSx = unstable_createStyleFunctionSx();
        styleFunctionSx.filterProps = ['sx'];
        const styleFunctionSx$1 = exports('b_', styleFunctionSx);
        const _excluded$8 = ["breakpoints", "palette", "spacing", "shape"];
        function createTheme$1(options = {}, ...args) {
          const {
              breakpoints: breakpointsInput = {},
              palette: paletteInput = {},
              spacing: spacingInput,
              shape: shapeInput = {}
            } = options,
            other = _objectWithoutPropertiesLoose$1(options, _excluded$8);
          const breakpoints = createBreakpoints(breakpointsInput);
          const spacing = createSpacing(spacingInput);
          let muiTheme = deepmerge({
            breakpoints,
            direction: 'ltr',
            components: {},
            // Inject component definitions.
            palette: _extends({
              mode: 'light'
            }, paletteInput),
            spacing,
            shape: _extends({}, shape$1, shapeInput)
          }, other);
          muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
          muiTheme.unstable_sxConfig = _extends({}, defaultSxConfig$1, other == null ? void 0 : other.unstable_sxConfig);
          muiTheme.unstable_sx = function sx(props) {
            return styleFunctionSx$1({
              sx: props,
              theme: this
            });
          };
          return muiTheme;
        }
        function isObjectEmpty(obj) {
          return Object.keys(obj).length === 0;
        }
        function useTheme$1(defaultTheme = null) {
          const contextTheme = reactExports.useContext(ThemeContext);
          return !contextTheme || isObjectEmpty(contextTheme) ? defaultTheme : contextTheme;
        }
        const systemDefaultTheme$1 = createTheme$1();
        function useTheme(defaultTheme = systemDefaultTheme$1) {
          return useTheme$1(defaultTheme);
        }
        const _excluded$7 = ["variant"];
        function isEmpty$1(string) {
          return string.length === 0;
        }

        /**
         * Generates string classKey based on the properties provided. It starts with the
         * variant if defined, and then it appends all other properties in alphabetical order.
         * @param {object} props - the properties for which the classKey should be created.
         */
        function propsToClassKey(props) {
          const {
              variant
            } = props,
            other = _objectWithoutPropertiesLoose$1(props, _excluded$7);
          let classKey = variant || '';
          Object.keys(other).sort().forEach(key => {
            if (key === 'color') {
              classKey += isEmpty$1(classKey) ? props[key] : capitalize(props[key]);
            } else {
              classKey += `${isEmpty$1(classKey) ? key : capitalize(key)}${capitalize(props[key].toString())}`;
            }
          });
          return classKey;
        }
        const _excluded$6 = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
        function isEmpty(obj) {
          return Object.keys(obj).length === 0;
        }

        // https://github.com/emotion-js/emotion/blob/26ded6109fcd8ca9875cc2ce4564fee678a3f3c5/packages/styled/src/utils.js#L40
        function isStringTag(tag) {
          return typeof tag === 'string' &&
          // 96 is one less than the char code
          // for "a" so this is checking that
          // it's a lowercase character
          tag.charCodeAt(0) > 96;
        }
        const getStyleOverrides = (name, theme) => {
          if (theme.components && theme.components[name] && theme.components[name].styleOverrides) {
            return theme.components[name].styleOverrides;
          }
          return null;
        };
        const getVariantStyles = (name, theme) => {
          let variants = [];
          if (theme && theme.components && theme.components[name] && theme.components[name].variants) {
            variants = theme.components[name].variants;
          }
          const variantsStyles = {};
          variants.forEach(definition => {
            const key = propsToClassKey(definition.props);
            variantsStyles[key] = definition.style;
          });
          return variantsStyles;
        };
        const variantsResolver = (props, styles, theme, name) => {
          var _theme$components, _theme$components$nam;
          const {
            ownerState = {}
          } = props;
          const variantsStyles = [];
          const themeVariants = theme == null ? void 0 : (_theme$components = theme.components) == null ? void 0 : (_theme$components$nam = _theme$components[name]) == null ? void 0 : _theme$components$nam.variants;
          if (themeVariants) {
            themeVariants.forEach(themeVariant => {
              let isMatch = true;
              Object.keys(themeVariant.props).forEach(key => {
                if (ownerState[key] !== themeVariant.props[key] && props[key] !== themeVariant.props[key]) {
                  isMatch = false;
                }
              });
              if (isMatch) {
                variantsStyles.push(styles[propsToClassKey(themeVariant.props)]);
              }
            });
          }
          return variantsStyles;
        };

        // Update /system/styled/#api in case if this changes
        function shouldForwardProp(prop) {
          return prop !== 'ownerState' && prop !== 'theme' && prop !== 'sx' && prop !== 'as';
        }
        const systemDefaultTheme = createTheme$1();
        function resolveTheme({
          defaultTheme,
          theme,
          themeId
        }) {
          return isEmpty(theme) ? defaultTheme : theme[themeId] || theme;
        }
        function createStyled(input = {}) {
          const {
            themeId,
            defaultTheme = systemDefaultTheme,
            rootShouldForwardProp = shouldForwardProp,
            slotShouldForwardProp = shouldForwardProp
          } = input;
          const systemSx = props => {
            return styleFunctionSx$1(_extends({}, props, {
              theme: resolveTheme(_extends({}, props, {
                defaultTheme,
                themeId
              }))
            }));
          };
          systemSx.__mui_systemSx = true;
          return (tag, inputOptions = {}) => {
            // Filter out the `sx` style function from the previous styled component to prevent unnecessary styles generated by the composite components.
            internal_processStyles(tag, styles => styles.filter(style => !(style != null && style.__mui_systemSx)));
            const {
                name: componentName,
                slot: componentSlot,
                skipVariantsResolver: inputSkipVariantsResolver,
                skipSx: inputSkipSx,
                overridesResolver
              } = inputOptions,
              options = _objectWithoutPropertiesLoose$1(inputOptions, _excluded$6);

            // if skipVariantsResolver option is defined, take the value, otherwise, true for root and false for other slots.
            const skipVariantsResolver = inputSkipVariantsResolver !== undefined ? inputSkipVariantsResolver : componentSlot && componentSlot !== 'Root' || false;
            const skipSx = inputSkipSx || false;
            let label;
            let shouldForwardPropOption = shouldForwardProp;
            if (componentSlot === 'Root') {
              shouldForwardPropOption = rootShouldForwardProp;
            } else if (componentSlot) {
              // any other slot specified
              shouldForwardPropOption = slotShouldForwardProp;
            } else if (isStringTag(tag)) {
              // for string (html) tag, preserve the behavior in emotion & styled-components.
              shouldForwardPropOption = undefined;
            }
            const defaultStyledResolver = styled$2(tag, _extends({
              shouldForwardProp: shouldForwardPropOption,
              label
            }, options));
            const muiStyledResolver = (styleArg, ...expressions) => {
              const expressionsWithDefaultTheme = expressions ? expressions.map(stylesArg => {
                // On the server Emotion doesn't use React.forwardRef for creating components, so the created
                // component stays as a function. This condition makes sure that we do not interpolate functions
                // which are basically components used as a selectors.
                return typeof stylesArg === 'function' && stylesArg.__emotion_real !== stylesArg ? props => {
                  return stylesArg(_extends({}, props, {
                    theme: resolveTheme(_extends({}, props, {
                      defaultTheme,
                      themeId
                    }))
                  }));
                } : stylesArg;
              }) : [];
              let transformedStyleArg = styleArg;
              if (componentName && overridesResolver) {
                expressionsWithDefaultTheme.push(props => {
                  const theme = resolveTheme(_extends({}, props, {
                    defaultTheme,
                    themeId
                  }));
                  const styleOverrides = getStyleOverrides(componentName, theme);
                  if (styleOverrides) {
                    const resolvedStyleOverrides = {};
                    Object.entries(styleOverrides).forEach(([slotKey, slotStyle]) => {
                      resolvedStyleOverrides[slotKey] = typeof slotStyle === 'function' ? slotStyle(_extends({}, props, {
                        theme
                      })) : slotStyle;
                    });
                    return overridesResolver(props, resolvedStyleOverrides);
                  }
                  return null;
                });
              }
              if (componentName && !skipVariantsResolver) {
                expressionsWithDefaultTheme.push(props => {
                  const theme = resolveTheme(_extends({}, props, {
                    defaultTheme,
                    themeId
                  }));
                  return variantsResolver(props, getVariantStyles(componentName, theme), theme, componentName);
                });
              }
              if (!skipSx) {
                expressionsWithDefaultTheme.push(systemSx);
              }
              const numOfCustomFnsApplied = expressionsWithDefaultTheme.length - expressions.length;
              if (Array.isArray(styleArg) && numOfCustomFnsApplied > 0) {
                const placeholders = new Array(numOfCustomFnsApplied).fill('');
                // If the type is array, than we need to add placeholders in the template for the overrides, variants and the sx styles.
                transformedStyleArg = [...styleArg, ...placeholders];
                transformedStyleArg.raw = [...styleArg.raw, ...placeholders];
              } else if (typeof styleArg === 'function' &&
              // On the server Emotion doesn't use React.forwardRef for creating components, so the created
              // component stays as a function. This condition makes sure that we do not interpolate functions
              // which are basically components used as a selectors.
              styleArg.__emotion_real !== styleArg) {
                // If the type is function, we need to define the default theme.
                transformedStyleArg = props => styleArg(_extends({}, props, {
                  theme: resolveTheme(_extends({}, props, {
                    defaultTheme,
                    themeId
                  }))
                }));
              }
              const Component = defaultStyledResolver(transformedStyleArg, ...expressionsWithDefaultTheme);
              if (tag.muiName) {
                Component.muiName = tag.muiName;
              }
              return Component;
            };
            if (defaultStyledResolver.withConfig) {
              muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
            }
            return muiStyledResolver;
          };
        }
        function getThemeProps(params) {
          const {
            theme,
            name,
            props
          } = params;
          if (!theme || !theme.components || !theme.components[name] || !theme.components[name].defaultProps) {
            return props;
          }
          return resolveProps(theme.components[name].defaultProps, props);
        }
        function useThemeProps$1({
          props,
          name,
          defaultTheme,
          themeId
        }) {
          let theme = useTheme(defaultTheme);
          if (themeId) {
            theme = theme[themeId] || theme;
          }
          const mergedProps = getThemeProps({
            theme,
            name,
            props
          });
          return mergedProps;
        }

        /**
         * Returns a number whose value is limited to the given range.
         * @param {number} value The value to be clamped
         * @param {number} min The lower boundary of the output range
         * @param {number} max The upper boundary of the output range
         * @returns {number} A number in the range [min, max]
         */
        function clamp(value, min = 0, max = 1) {
          return Math.min(Math.max(min, value), max);
        }

        /**
         * Converts a color from CSS hex format to CSS rgb format.
         * @param {string} color - Hex color, i.e. #nnn or #nnnnnn
         * @returns {string} A CSS rgb color string
         */
        function hexToRgb(color) {
          color = color.slice(1);
          const re = new RegExp(`.{1,${color.length >= 6 ? 2 : 1}}`, 'g');
          let colors = color.match(re);
          if (colors && colors[0].length === 1) {
            colors = colors.map(n => n + n);
          }
          return colors ? `rgb${colors.length === 4 ? 'a' : ''}(${colors.map((n, index) => {
            return index < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1000) / 1000;
          }).join(', ')})` : '';
        }

        /**
         * Returns an object with the type and values of a color.
         *
         * Note: Does not support rgb % values.
         * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
         * @returns {object} - A MUI color object: {type: string, values: number[]}
         */
        function decomposeColor(color) {
          // Idempotent
          if (color.type) {
            return color;
          }
          if (color.charAt(0) === '#') {
            return decomposeColor(hexToRgb(color));
          }
          const marker = color.indexOf('(');
          const type = color.substring(0, marker);
          if (['rgb', 'rgba', 'hsl', 'hsla', 'color'].indexOf(type) === -1) {
            throw new Error(formatMuiErrorMessage(9, color));
          }
          let values = color.substring(marker + 1, color.length - 1);
          let colorSpace;
          if (type === 'color') {
            values = values.split(' ');
            colorSpace = values.shift();
            if (values.length === 4 && values[3].charAt(0) === '/') {
              values[3] = values[3].slice(1);
            }
            if (['srgb', 'display-p3', 'a98-rgb', 'prophoto-rgb', 'rec-2020'].indexOf(colorSpace) === -1) {
              throw new Error(formatMuiErrorMessage(10, colorSpace));
            }
          } else {
            values = values.split(',');
          }
          values = values.map(value => parseFloat(value));
          return {
            type,
            values,
            colorSpace
          };
        }

        /**
         * Converts a color object with type and values to a string.
         * @param {object} color - Decomposed color
         * @param {string} color.type - One of: 'rgb', 'rgba', 'hsl', 'hsla', 'color'
         * @param {array} color.values - [n,n,n] or [n,n,n,n]
         * @returns {string} A CSS color string
         */
        function recomposeColor(color) {
          const {
            type,
            colorSpace
          } = color;
          let {
            values
          } = color;
          if (type.indexOf('rgb') !== -1) {
            // Only convert the first 3 values to int (i.e. not alpha)
            values = values.map((n, i) => i < 3 ? parseInt(n, 10) : n);
          } else if (type.indexOf('hsl') !== -1) {
            values[1] = `${values[1]}%`;
            values[2] = `${values[2]}%`;
          }
          if (type.indexOf('color') !== -1) {
            values = `${colorSpace} ${values.join(' ')}`;
          } else {
            values = `${values.join(', ')}`;
          }
          return `${type}(${values})`;
        }

        /**
         * Converts a color from hsl format to rgb format.
         * @param {string} color - HSL color values
         * @returns {string} rgb color values
         */
        function hslToRgb(color) {
          color = decomposeColor(color);
          const {
            values
          } = color;
          const h = values[0];
          const s = values[1] / 100;
          const l = values[2] / 100;
          const a = s * Math.min(l, 1 - l);
          const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
          let type = 'rgb';
          const rgb = [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];
          if (color.type === 'hsla') {
            type += 'a';
            rgb.push(values[3]);
          }
          return recomposeColor({
            type,
            values: rgb
          });
        }
        /**
         * The relative brightness of any point in a color space,
         * normalized to 0 for darkest black and 1 for lightest white.
         *
         * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
         * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
         * @returns {number} The relative brightness of the color in the range 0 - 1
         */
        function getLuminance(color) {
          color = decomposeColor(color);
          let rgb = color.type === 'hsl' || color.type === 'hsla' ? decomposeColor(hslToRgb(color)).values : color.values;
          rgb = rgb.map(val => {
            if (color.type !== 'color') {
              val /= 255; // normalized
            }

            return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
          });

          // Truncate at 3 digits
          return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
        }

        /**
         * Calculates the contrast ratio between two colors.
         *
         * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
         * @param {string} foreground - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
         * @param {string} background - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
         * @returns {number} A contrast ratio value in the range 0 - 21.
         */
        function getContrastRatio(foreground, background) {
          const lumA = getLuminance(foreground);
          const lumB = getLuminance(background);
          return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
        }

        /**
         * Sets the absolute transparency of a color.
         * Any existing alpha values are overwritten.
         * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
         * @param {number} value - value to set the alpha channel to in the range 0 - 1
         * @returns {string} A CSS color string. Hex input values are returned as rgb
         */
        function alpha(color, value) {
          color = decomposeColor(color);
          value = clamp(value);
          if (color.type === 'rgb' || color.type === 'hsl') {
            color.type += 'a';
          }
          if (color.type === 'color') {
            color.values[3] = `/${value}`;
          } else {
            color.values[3] = value;
          }
          return recomposeColor(color);
        }

        /**
         * Darkens a color.
         * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
         * @param {number} coefficient - multiplier in the range 0 - 1
         * @returns {string} A CSS color string. Hex input values are returned as rgb
         */
        function darken(color, coefficient) {
          color = decomposeColor(color);
          coefficient = clamp(coefficient);
          if (color.type.indexOf('hsl') !== -1) {
            color.values[2] *= 1 - coefficient;
          } else if (color.type.indexOf('rgb') !== -1 || color.type.indexOf('color') !== -1) {
            for (let i = 0; i < 3; i += 1) {
              color.values[i] *= 1 - coefficient;
            }
          }
          return recomposeColor(color);
        }

        /**
         * Lightens a color.
         * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
         * @param {number} coefficient - multiplier in the range 0 - 1
         * @returns {string} A CSS color string. Hex input values are returned as rgb
         */
        function lighten(color, coefficient) {
          color = decomposeColor(color);
          coefficient = clamp(coefficient);
          if (color.type.indexOf('hsl') !== -1) {
            color.values[2] += (100 - color.values[2]) * coefficient;
          } else if (color.type.indexOf('rgb') !== -1) {
            for (let i = 0; i < 3; i += 1) {
              color.values[i] += (255 - color.values[i]) * coefficient;
            }
          } else if (color.type.indexOf('color') !== -1) {
            for (let i = 0; i < 3; i += 1) {
              color.values[i] += (1 - color.values[i]) * coefficient;
            }
          }
          return recomposeColor(color);
        }

        /**
         * Darken or lighten a color, depending on its luminance.
         * Light colors are darkened, dark colors are lightened.
         * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
         * @param {number} coefficient=0.15 - multiplier in the range 0 - 1
         * @returns {string} A CSS color string. Hex input values are returned as rgb
         */
        function emphasize(color, coefficient = 0.15) {
          return getLuminance(color) > 0.5 ? darken(color, coefficient) : lighten(color, coefficient);
        }
        function createMixins(breakpoints, mixins) {
          return _extends({
            toolbar: {
              minHeight: 56,
              [breakpoints.up('xs')]: {
                '@media (orientation: landscape)': {
                  minHeight: 48
                }
              },
              [breakpoints.up('sm')]: {
                minHeight: 64
              }
            }
          }, mixins);
        }
        const common = {
          black: '#000',
          white: '#fff'
        };
        const common$1 = common;
        const grey = {
          50: '#fafafa',
          100: '#f5f5f5',
          200: '#eeeeee',
          300: '#e0e0e0',
          400: '#bdbdbd',
          500: '#9e9e9e',
          600: '#757575',
          700: '#616161',
          800: '#424242',
          900: '#212121',
          A100: '#f5f5f5',
          A200: '#eeeeee',
          A400: '#bdbdbd',
          A700: '#616161'
        };
        const grey$1 = exports('aO', grey);
        const purple = {
          50: '#f3e5f5',
          100: '#e1bee7',
          200: '#ce93d8',
          300: '#ba68c8',
          400: '#ab47bc',
          500: '#9c27b0',
          600: '#8e24aa',
          700: '#7b1fa2',
          800: '#6a1b9a',
          900: '#4a148c',
          A100: '#ea80fc',
          A200: '#e040fb',
          A400: '#d500f9',
          A700: '#aa00ff'
        };
        const purple$1 = purple;
        const red = {
          50: '#ffebee',
          100: '#ffcdd2',
          200: '#ef9a9a',
          300: '#e57373',
          400: '#ef5350',
          500: '#f44336',
          600: '#e53935',
          700: '#d32f2f',
          800: '#c62828',
          900: '#b71c1c',
          A100: '#ff8a80',
          A200: '#ff5252',
          A400: '#ff1744',
          A700: '#d50000'
        };
        const red$1 = red;
        const orange = {
          50: '#fff3e0',
          100: '#ffe0b2',
          200: '#ffcc80',
          300: '#ffb74d',
          400: '#ffa726',
          500: '#ff9800',
          600: '#fb8c00',
          700: '#f57c00',
          800: '#ef6c00',
          900: '#e65100',
          A100: '#ffd180',
          A200: '#ffab40',
          A400: '#ff9100',
          A700: '#ff6d00'
        };
        const orange$1 = orange;
        const blue = {
          50: '#e3f2fd',
          100: '#bbdefb',
          200: '#90caf9',
          300: '#64b5f6',
          400: '#42a5f5',
          500: '#2196f3',
          600: '#1e88e5',
          700: '#1976d2',
          800: '#1565c0',
          900: '#0d47a1',
          A100: '#82b1ff',
          A200: '#448aff',
          A400: '#2979ff',
          A700: '#2962ff'
        };
        const blue$1 = blue;
        const lightBlue = {
          50: '#e1f5fe',
          100: '#b3e5fc',
          200: '#81d4fa',
          300: '#4fc3f7',
          400: '#29b6f6',
          500: '#03a9f4',
          600: '#039be5',
          700: '#0288d1',
          800: '#0277bd',
          900: '#01579b',
          A100: '#80d8ff',
          A200: '#40c4ff',
          A400: '#00b0ff',
          A700: '#0091ea'
        };
        const lightBlue$1 = lightBlue;
        const green = {
          50: '#e8f5e9',
          100: '#c8e6c9',
          200: '#a5d6a7',
          300: '#81c784',
          400: '#66bb6a',
          500: '#4caf50',
          600: '#43a047',
          700: '#388e3c',
          800: '#2e7d32',
          900: '#1b5e20',
          A100: '#b9f6ca',
          A200: '#69f0ae',
          A400: '#00e676',
          A700: '#00c853'
        };
        const green$1 = green;
        const _excluded$5 = ["mode", "contrastThreshold", "tonalOffset"];
        const light = {
          // The colors used to style the text.
          text: {
            // The most important text.
            primary: 'rgba(0, 0, 0, 0.87)',
            // Secondary text.
            secondary: 'rgba(0, 0, 0, 0.6)',
            // Disabled text have even lower visual prominence.
            disabled: 'rgba(0, 0, 0, 0.38)'
          },
          // The color used to divide different elements.
          divider: 'rgba(0, 0, 0, 0.12)',
          // The background colors used to style the surfaces.
          // Consistency between these values is important.
          background: {
            paper: common$1.white,
            default: common$1.white
          },
          // The colors used to style the action elements.
          action: {
            // The color of an active action like an icon button.
            active: 'rgba(0, 0, 0, 0.54)',
            // The color of an hovered action.
            hover: 'rgba(0, 0, 0, 0.04)',
            hoverOpacity: 0.04,
            // The color of a selected action.
            selected: 'rgba(0, 0, 0, 0.08)',
            selectedOpacity: 0.08,
            // The color of a disabled action.
            disabled: 'rgba(0, 0, 0, 0.26)',
            // The background color of a disabled action.
            disabledBackground: 'rgba(0, 0, 0, 0.12)',
            disabledOpacity: 0.38,
            focus: 'rgba(0, 0, 0, 0.12)',
            focusOpacity: 0.12,
            activatedOpacity: 0.12
          }
        };
        const dark = {
          text: {
            primary: common$1.white,
            secondary: 'rgba(255, 255, 255, 0.7)',
            disabled: 'rgba(255, 255, 255, 0.5)',
            icon: 'rgba(255, 255, 255, 0.5)'
          },
          divider: 'rgba(255, 255, 255, 0.12)',
          background: {
            paper: '#121212',
            default: '#121212'
          },
          action: {
            active: common$1.white,
            hover: 'rgba(255, 255, 255, 0.08)',
            hoverOpacity: 0.08,
            selected: 'rgba(255, 255, 255, 0.16)',
            selectedOpacity: 0.16,
            disabled: 'rgba(255, 255, 255, 0.3)',
            disabledBackground: 'rgba(255, 255, 255, 0.12)',
            disabledOpacity: 0.38,
            focus: 'rgba(255, 255, 255, 0.12)',
            focusOpacity: 0.12,
            activatedOpacity: 0.24
          }
        };
        function addLightOrDark(intent, direction, shade, tonalOffset) {
          const tonalOffsetLight = tonalOffset.light || tonalOffset;
          const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
          if (!intent[direction]) {
            if (intent.hasOwnProperty(shade)) {
              intent[direction] = intent[shade];
            } else if (direction === 'light') {
              intent.light = lighten(intent.main, tonalOffsetLight);
            } else if (direction === 'dark') {
              intent.dark = darken(intent.main, tonalOffsetDark);
            }
          }
        }
        function getDefaultPrimary(mode = 'light') {
          if (mode === 'dark') {
            return {
              main: blue$1[200],
              light: blue$1[50],
              dark: blue$1[400]
            };
          }
          return {
            main: blue$1[700],
            light: blue$1[400],
            dark: blue$1[800]
          };
        }
        function getDefaultSecondary(mode = 'light') {
          if (mode === 'dark') {
            return {
              main: purple$1[200],
              light: purple$1[50],
              dark: purple$1[400]
            };
          }
          return {
            main: purple$1[500],
            light: purple$1[300],
            dark: purple$1[700]
          };
        }
        function getDefaultError(mode = 'light') {
          if (mode === 'dark') {
            return {
              main: red$1[500],
              light: red$1[300],
              dark: red$1[700]
            };
          }
          return {
            main: red$1[700],
            light: red$1[400],
            dark: red$1[800]
          };
        }
        function getDefaultInfo(mode = 'light') {
          if (mode === 'dark') {
            return {
              main: lightBlue$1[400],
              light: lightBlue$1[300],
              dark: lightBlue$1[700]
            };
          }
          return {
            main: lightBlue$1[700],
            light: lightBlue$1[500],
            dark: lightBlue$1[900]
          };
        }
        function getDefaultSuccess(mode = 'light') {
          if (mode === 'dark') {
            return {
              main: green$1[400],
              light: green$1[300],
              dark: green$1[700]
            };
          }
          return {
            main: green$1[800],
            light: green$1[500],
            dark: green$1[900]
          };
        }
        function getDefaultWarning(mode = 'light') {
          if (mode === 'dark') {
            return {
              main: orange$1[400],
              light: orange$1[300],
              dark: orange$1[700]
            };
          }
          return {
            main: '#ed6c02',
            // closest to orange[800] that pass 3:1.
            light: orange$1[500],
            dark: orange$1[900]
          };
        }
        function createPalette(palette) {
          const {
              mode = 'light',
              contrastThreshold = 3,
              tonalOffset = 0.2
            } = palette,
            other = _objectWithoutPropertiesLoose$1(palette, _excluded$5);
          const primary = palette.primary || getDefaultPrimary(mode);
          const secondary = palette.secondary || getDefaultSecondary(mode);
          const error = palette.error || getDefaultError(mode);
          const info = palette.info || getDefaultInfo(mode);
          const success = palette.success || getDefaultSuccess(mode);
          const warning = palette.warning || getDefaultWarning(mode);

          // Use the same logic as
          // Bootstrap: https://github.com/twbs/bootstrap/blob/1d6e3710dd447de1a200f29e8fa521f8a0908f70/scss/_functions.scss#L59
          // and material-components-web https://github.com/material-components/material-components-web/blob/ac46b8863c4dab9fc22c4c662dc6bd1b65dd652f/packages/mdc-theme/_functions.scss#L54
          function getContrastText(background) {
            const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
            return contrastText;
          }
          const augmentColor = ({
            color,
            name,
            mainShade = 500,
            lightShade = 300,
            darkShade = 700
          }) => {
            color = _extends({}, color);
            if (!color.main && color[mainShade]) {
              color.main = color[mainShade];
            }
            if (!color.hasOwnProperty('main')) {
              throw new Error(formatMuiErrorMessage(11, name ? ` (${name})` : '', mainShade));
            }
            if (typeof color.main !== 'string') {
              throw new Error(formatMuiErrorMessage(12, name ? ` (${name})` : '', JSON.stringify(color.main)));
            }
            addLightOrDark(color, 'light', lightShade, tonalOffset);
            addLightOrDark(color, 'dark', darkShade, tonalOffset);
            if (!color.contrastText) {
              color.contrastText = getContrastText(color.main);
            }
            return color;
          };
          const modes = {
            dark,
            light
          };
          const paletteOutput = deepmerge(_extends({
            // A collection of common colors.
            common: _extends({}, common$1),
            // prevent mutable object.
            // The palette mode, can be light or dark.
            mode,
            // The colors used to represent primary interface elements for a user.
            primary: augmentColor({
              color: primary,
              name: 'primary'
            }),
            // The colors used to represent secondary interface elements for a user.
            secondary: augmentColor({
              color: secondary,
              name: 'secondary',
              mainShade: 'A400',
              lightShade: 'A200',
              darkShade: 'A700'
            }),
            // The colors used to represent interface elements that the user should be made aware of.
            error: augmentColor({
              color: error,
              name: 'error'
            }),
            // The colors used to represent potentially dangerous actions or important messages.
            warning: augmentColor({
              color: warning,
              name: 'warning'
            }),
            // The colors used to present information to the user that is neutral and not necessarily important.
            info: augmentColor({
              color: info,
              name: 'info'
            }),
            // The colors used to indicate the successful completion of an action that user triggered.
            success: augmentColor({
              color: success,
              name: 'success'
            }),
            // The grey colors.
            grey: grey$1,
            // Used by `getContrastText()` to maximize the contrast between
            // the background and the text.
            contrastThreshold,
            // Takes a background color and returns the text color that maximizes the contrast.
            getContrastText,
            // Generate a rich color object.
            augmentColor,
            // Used by the functions below to shift a color's luminance by approximately
            // two indexes within its tonal palette.
            // E.g., shift from Red 500 to Red 300 or Red 700.
            tonalOffset
          }, modes[mode]), other);
          return paletteOutput;
        }
        const _excluded$4 = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
        function round(value) {
          return Math.round(value * 1e5) / 1e5;
        }
        const caseAllCaps = {
          textTransform: 'uppercase'
        };
        const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';

        /**
         * @see @link{https://m2.material.io/design/typography/the-type-system.html}
         * @see @link{https://m2.material.io/design/typography/understanding-typography.html}
         */
        function createTypography(palette, typography) {
          const _ref = typeof typography === 'function' ? typography(palette) : typography,
            {
              fontFamily = defaultFontFamily,
              // The default font size of the Material Specification.
              fontSize = 14,
              // px
              fontWeightLight = 300,
              fontWeightRegular = 400,
              fontWeightMedium = 500,
              fontWeightBold = 700,
              // Tell MUI what's the font-size on the html element.
              // 16px is the default font-size used by browsers.
              htmlFontSize = 16,
              // Apply the CSS properties to all the variants.
              allVariants,
              pxToRem: pxToRem2
            } = _ref,
            other = _objectWithoutPropertiesLoose$1(_ref, _excluded$4);
          const coef = fontSize / 14;
          const pxToRem = pxToRem2 || (size => `${size / htmlFontSize * coef}rem`);
          const buildVariant = (fontWeight, size, lineHeight, letterSpacing, casing) => _extends({
            fontFamily,
            fontWeight,
            fontSize: pxToRem(size),
            // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
            lineHeight
          }, fontFamily === defaultFontFamily ? {
            letterSpacing: `${round(letterSpacing / size)}em`
          } : {}, casing, allVariants);
          const variants = {
            h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
            h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
            h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
            h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
            h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
            h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
            subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
            subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
            body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
            body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
            button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
            caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
            overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
            inherit: {
              fontFamily: 'inherit',
              fontWeight: 'inherit',
              fontSize: 'inherit',
              lineHeight: 'inherit',
              letterSpacing: 'inherit'
            }
          };
          return deepmerge(_extends({
            htmlFontSize,
            pxToRem,
            fontFamily,
            fontSize,
            fontWeightLight,
            fontWeightRegular,
            fontWeightMedium,
            fontWeightBold
          }, variants), other, {
            clone: false // No need to clone deep
          });
        }

        const shadowKeyUmbraOpacity = 0.2;
        const shadowKeyPenumbraOpacity = 0.14;
        const shadowAmbientShadowOpacity = 0.12;
        function createShadow(...px) {
          return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(',');
        }

        // Values from https://github.com/material-components/material-components-web/blob/be8747f94574669cb5e7add1a7c54fa41a89cec7/packages/mdc-elevation/_variables.scss
        const shadows = ['none', createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
        const shadows$1 = shadows;
        const _excluded$3 = ["duration", "easing", "delay"];
        // Follow https://material.google.com/motion/duration-easing.html#duration-easing-natural-easing-curves
        // to learn the context in which each easing should be used.
        const easing = {
          // This is the most common easing curve.
          easeInOut: 'cubic-bezier(0.4, 0, 0.2, 1)',
          // Objects enter the screen at full velocity from off-screen and
          // slowly decelerate to a resting point.
          easeOut: 'cubic-bezier(0.0, 0, 0.2, 1)',
          // Objects leave the screen at full velocity. They do not decelerate when off-screen.
          easeIn: 'cubic-bezier(0.4, 0, 1, 1)',
          // The sharp curve is used by objects that may return to the screen at any time.
          sharp: 'cubic-bezier(0.4, 0, 0.6, 1)'
        };

        // Follow https://m2.material.io/guidelines/motion/duration-easing.html#duration-easing-common-durations
        // to learn when use what timing
        const duration = exports('bF', {
          shortest: 150,
          shorter: 200,
          short: 250,
          // most basic recommended timing
          standard: 300,
          // this is to be used in complex animations
          complex: 375,
          // recommended when something is entering screen
          enteringScreen: 225,
          // recommended when something is leaving screen
          leavingScreen: 195
        });
        function formatMs(milliseconds) {
          return `${Math.round(milliseconds)}ms`;
        }
        function getAutoHeightDuration(height) {
          if (!height) {
            return 0;
          }
          const constant = height / 36;

          // https://www.wolframalpha.com/input/?i=(4+%2B+15+*+(x+%2F+36+)+**+0.25+%2B+(x+%2F+36)+%2F+5)+*+10
          return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
        }
        function createTransitions(inputTransitions) {
          const mergedEasing = _extends({}, easing, inputTransitions.easing);
          const mergedDuration = _extends({}, duration, inputTransitions.duration);
          const create = (props = ['all'], options = {}) => {
            const {
              duration: durationOption = mergedDuration.standard,
              easing: easingOption = mergedEasing.easeInOut,
              delay = 0
            } = options;
            _objectWithoutPropertiesLoose$1(options, _excluded$3);
            return (Array.isArray(props) ? props : [props]).map(animatedProp => `${animatedProp} ${typeof durationOption === 'string' ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === 'string' ? delay : formatMs(delay)}`).join(',');
          };
          return _extends({
            getAutoHeightDuration,
            create
          }, inputTransitions, {
            easing: mergedEasing,
            duration: mergedDuration
          });
        }

        // We need to centralize the zIndex definitions as they work
        // like global values in the browser.
        const zIndex = {
          mobileStepper: 1000,
          fab: 1050,
          speedDial: 1050,
          appBar: 1100,
          drawer: 1200,
          modal: 1300,
          snackbar: 1400,
          tooltip: 1500
        };
        const zIndex$1 = zIndex;
        const _excluded$2 = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
        function createTheme(options = {}, ...args) {
          const {
              mixins: mixinsInput = {},
              palette: paletteInput = {},
              transitions: transitionsInput = {},
              typography: typographyInput = {}
            } = options,
            other = _objectWithoutPropertiesLoose$1(options, _excluded$2);
          if (options.vars) {
            throw new Error(formatMuiErrorMessage(18));
          }
          const palette = createPalette(paletteInput);
          const systemTheme = createTheme$1(options);
          let muiTheme = deepmerge(systemTheme, {
            mixins: createMixins(systemTheme.breakpoints, mixinsInput),
            palette,
            // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
            shadows: shadows$1.slice(),
            typography: createTypography(palette, typographyInput),
            transitions: createTransitions(transitionsInput),
            zIndex: _extends({}, zIndex$1)
          });
          muiTheme = deepmerge(muiTheme, other);
          muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
          muiTheme.unstable_sxConfig = _extends({}, defaultSxConfig$1, other == null ? void 0 : other.unstable_sxConfig);
          muiTheme.unstable_sx = function sx(props) {
            return styleFunctionSx$1({
              sx: props,
              theme: this
            });
          };
          return muiTheme;
        }
        const defaultTheme = createTheme();
        const defaultTheme$1 = exports('b$', defaultTheme);
        const THEME_ID = exports('bJ', '$$material');
        function useThemeProps({
          props,
          name
        }) {
          return useThemeProps$1({
            props,
            name,
            defaultTheme: defaultTheme$1,
            themeId: THEME_ID
          });
        }
        const rootShouldForwardProp = exports('$', prop => shouldForwardProp(prop) && prop !== 'classes');
        const slotShouldForwardProp = exports('aI', shouldForwardProp);
        const styled = createStyled({
          themeId: THEME_ID,
          defaultTheme: defaultTheme$1,
          rootShouldForwardProp
        });
        const styled$1 = exports('t', styled);
        function getSvgIconUtilityClass(slot) {
          return generateUtilityClass('MuiSvgIcon', slot);
        }
        generateUtilityClasses('MuiSvgIcon', ['root', 'colorPrimary', 'colorSecondary', 'colorAction', 'colorError', 'colorDisabled', 'fontSizeInherit', 'fontSizeSmall', 'fontSizeMedium', 'fontSizeLarge']);
        const _excluded$1 = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"];
        const useUtilityClasses$1 = ownerState => {
          const {
            color,
            fontSize,
            classes
          } = ownerState;
          const slots = {
            root: ['root', color !== 'inherit' && `color${capitalize(color)}`, `fontSize${capitalize(fontSize)}`]
          };
          return composeClasses(slots, getSvgIconUtilityClass, classes);
        };
        const SvgIconRoot = styled$1('svg', {
          name: 'MuiSvgIcon',
          slot: 'Root',
          overridesResolver: (props, styles) => {
            const {
              ownerState
            } = props;
            return [styles.root, ownerState.color !== 'inherit' && styles[`color${capitalize(ownerState.color)}`], styles[`fontSize${capitalize(ownerState.fontSize)}`]];
          }
        })(({
          theme,
          ownerState
        }) => {
          var _theme$transitions, _theme$transitions$cr, _theme$transitions2, _theme$transitions2$d, _theme$typography, _theme$typography$pxT, _theme$typography2, _theme$typography2$px, _theme$typography3, _theme$typography3$px, _palette$ownerState$c, _palette, _palette$ownerState$c2, _palette2, _palette2$action, _palette3, _palette3$action;
          return {
            userSelect: 'none',
            width: '1em',
            height: '1em',
            display: 'inline-block',
            fill: 'currentColor',
            flexShrink: 0,
            transition: (_theme$transitions = theme.transitions) == null ? void 0 : (_theme$transitions$cr = _theme$transitions.create) == null ? void 0 : _theme$transitions$cr.call(_theme$transitions, 'fill', {
              duration: (_theme$transitions2 = theme.transitions) == null ? void 0 : (_theme$transitions2$d = _theme$transitions2.duration) == null ? void 0 : _theme$transitions2$d.shorter
            }),
            fontSize: {
              inherit: 'inherit',
              small: ((_theme$typography = theme.typography) == null ? void 0 : (_theme$typography$pxT = _theme$typography.pxToRem) == null ? void 0 : _theme$typography$pxT.call(_theme$typography, 20)) || '1.25rem',
              medium: ((_theme$typography2 = theme.typography) == null ? void 0 : (_theme$typography2$px = _theme$typography2.pxToRem) == null ? void 0 : _theme$typography2$px.call(_theme$typography2, 24)) || '1.5rem',
              large: ((_theme$typography3 = theme.typography) == null ? void 0 : (_theme$typography3$px = _theme$typography3.pxToRem) == null ? void 0 : _theme$typography3$px.call(_theme$typography3, 35)) || '2.1875rem'
            }[ownerState.fontSize],
            // TODO v5 deprecate, v6 remove for sx
            color: (_palette$ownerState$c = (_palette = (theme.vars || theme).palette) == null ? void 0 : (_palette$ownerState$c2 = _palette[ownerState.color]) == null ? void 0 : _palette$ownerState$c2.main) != null ? _palette$ownerState$c : {
              action: (_palette2 = (theme.vars || theme).palette) == null ? void 0 : (_palette2$action = _palette2.action) == null ? void 0 : _palette2$action.active,
              disabled: (_palette3 = (theme.vars || theme).palette) == null ? void 0 : (_palette3$action = _palette3.action) == null ? void 0 : _palette3$action.disabled,
              inherit: undefined
            }[ownerState.color]
          };
        });
        const SvgIcon = /*#__PURE__*/reactExports.forwardRef(function SvgIcon(inProps, ref) {
          const props = useThemeProps({
            props: inProps,
            name: 'MuiSvgIcon'
          });
          const {
              children,
              className,
              color = 'inherit',
              component = 'svg',
              fontSize = 'medium',
              htmlColor,
              inheritViewBox = false,
              titleAccess,
              viewBox = '0 0 24 24'
            } = props,
            other = _objectWithoutPropertiesLoose$1(props, _excluded$1);
          const ownerState = _extends({}, props, {
            color,
            component,
            fontSize,
            instanceFontSize: inProps.fontSize,
            inheritViewBox,
            viewBox
          });
          const more = {};
          if (!inheritViewBox) {
            more.viewBox = viewBox;
          }
          const classes = useUtilityClasses$1(ownerState);
          return /*#__PURE__*/jsxRuntimeExports.jsxs(SvgIconRoot, _extends({
            as: component,
            className: clsx(classes.root, className),
            focusable: "false",
            color: htmlColor,
            "aria-hidden": titleAccess ? undefined : true,
            role: titleAccess ? 'img' : undefined,
            ref: ref
          }, more, other, {
            ownerState: ownerState,
            children: [children, titleAccess ? /*#__PURE__*/jsxRuntimeExports.jsx("title", {
              children: titleAccess
            }) : null]
          }));
        });
        SvgIcon.muiName = 'SvgIcon';
        const SvgIcon$1 = SvgIcon;
        function createSvgIcon(path, displayName) {
          function Component(props, ref) {
            return /*#__PURE__*/jsxRuntimeExports.jsx(SvgIcon$1, _extends({
              "data-testid": `${displayName}Icon`,
              ref: ref
            }, props, {
              children: path
            }));
          }
          Component.muiName = SvgIcon$1.muiName;
          return /*#__PURE__*/reactExports.memo( /*#__PURE__*/reactExports.forwardRef(Component));
        }

        // TODO: remove this export once ClassNameGenerator is stable
        // eslint-disable-next-line @typescript-eslint/naming-convention
        const unstable_ClassNameGenerator = {
          configure: generator => {
            ClassNameGenerator$1.configure(generator);
          }
        };
        const utils$c = /*#__PURE__*/Object.freeze( /*#__PURE__*/Object.defineProperty({
          __proto__: null,
          capitalize,
          createChainedFunction,
          createSvgIcon,
          debounce,
          deprecatedPropType,
          isMuiElement,
          ownerDocument,
          ownerWindow,
          requirePropFactory,
          setRef,
          unstable_ClassNameGenerator,
          unstable_useEnhancedEffect: useEnhancedEffect$1,
          unstable_useId: useId,
          unsupportedProp,
          useControlled,
          useEventCallback,
          useForkRef,
          useIsFocusVisible
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        const require$$0 = /*@__PURE__*/getAugmentedNamespace(utils$c);
        var hasRequiredCreateSvgIcon;
        function requireCreateSvgIcon() {
          if (hasRequiredCreateSvgIcon) return createSvgIcon$1;
          hasRequiredCreateSvgIcon = 1;
          (function (exports) {
            Object.defineProperty(exports, "__esModule", {
              value: true
            });
            Object.defineProperty(exports, "default", {
              enumerable: true,
              get: function () {
                return _utils.createSvgIcon;
              }
            });
            var _utils = require$$0;
          })(createSvgIcon$1);
          return createSvgIcon$1;
        }
        var _interopRequireDefault$l = interopRequireDefaultExports;
        Object.defineProperty(MailOutline, "__esModule", {
          value: true
        });
        var default_1$l = MailOutline.default = void 0;
        var _createSvgIcon$l = _interopRequireDefault$l(requireCreateSvgIcon());
        var _jsxRuntime$l = jsxRuntimeExports;
        var _default$l = (0, _createSvgIcon$l.default)( /*#__PURE__*/(0, _jsxRuntime$l.jsx)("path", {
          d: "M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 14H4V8l8 5 8-5v10zm-8-7L4 6h16l-8 5z"
        }), 'MailOutline');
        default_1$l = MailOutline.default = _default$l;
        var Abc = {};
        var _interopRequireDefault$k = interopRequireDefaultExports;
        Object.defineProperty(Abc, "__esModule", {
          value: true
        });
        var default_1$k = Abc.default = void 0;
        var _createSvgIcon$k = _interopRequireDefault$k(requireCreateSvgIcon());
        var _jsxRuntime$k = jsxRuntimeExports;
        var _default$k = (0, _createSvgIcon$k.default)( /*#__PURE__*/(0, _jsxRuntime$k.jsx)("path", {
          d: "M21 11h-1.5v-.5h-2v3h2V13H21v1c0 .55-.45 1-1 1h-3c-.55 0-1-.45-1-1v-4c0-.55.45-1 1-1h3c.55 0 1 .45 1 1v1zM8 10v5H6.5v-1.5h-2V15H3v-5c0-.55.45-1 1-1h3c.55 0 1 .45 1 1zm-1.5.5h-2V12h2v-1.5zm7 1.5c.55 0 1 .45 1 1v1c0 .55-.45 1-1 1h-4V9h4c.55 0 1 .45 1 1v1c0 .55-.45 1-1 1zM11 10.5v.75h2v-.75h-2zm2 2.25h-2v.75h2v-.75z"
        }), 'Abc');
        default_1$k = Abc.default = _default$k;
        var Pin = {};
        var _interopRequireDefault$j = interopRequireDefaultExports;
        Object.defineProperty(Pin, "__esModule", {
          value: true
        });
        var default_1$j = Pin.default = void 0;
        var _createSvgIcon$j = _interopRequireDefault$j(requireCreateSvgIcon());
        var _jsxRuntime$j = jsxRuntimeExports;
        var _default$j = (0, _createSvgIcon$j.default)( /*#__PURE__*/(0, _jsxRuntime$j.jsx)("path", {
          d: "M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zM7.64 15H6.49v-4.5l-.9.66-.58-.89L6.77 9h.87v6zm5.86 0H9.61v-1.02c1.07-1.07 1.77-1.77 2.13-2.15.4-.42.54-.69.54-1.06 0-.4-.31-.72-.81-.72-.52 0-.8.39-.9.72l-1.01-.42c.01-.02.18-.76 1-1.15.69-.33 1.48-.2 1.95.03.86.44.91 1.24.91 1.48 0 .64-.31 1.26-.92 1.86-.25.25-.72.71-1.4 1.39l.03.05h2.37V15zm5.25-.85c-.08.13-.56.85-1.76.85-.04 0-1.6.08-2.05-1.51l1.03-.41c.03.1.19.86 1.02.86.41 0 .89-.28.89-.77 0-.55-.48-.79-1.04-.79h-.5v-1h.46c.33 0 .88-.14.88-.72 0-.39-.31-.65-.75-.65-.5 0-.74.32-.85.64l-.99-.41C15.2 9.9 15.68 9 16.94 9c1.09 0 1.54.64 1.62.75.33.5.28 1.16.02 1.57-.15.22-.32.38-.52.48v.07c.28.11.51.28.68.52.37.52.33 1.27.01 1.76z"
        }), 'Pin');
        default_1$j = Pin.default = _default$j;
        var Pages = {};
        var _interopRequireDefault$i = interopRequireDefaultExports;
        Object.defineProperty(Pages, "__esModule", {
          value: true
        });
        var default_1$i = Pages.default = void 0;
        var _createSvgIcon$i = _interopRequireDefault$i(requireCreateSvgIcon());
        var _jsxRuntime$i = jsxRuntimeExports;
        var _default$i = (0, _createSvgIcon$i.default)( /*#__PURE__*/(0, _jsxRuntime$i.jsx)("path", {
          d: "M3 5v6h5L7 7l4 1V3H5c-1.1 0-2 .9-2 2zm5 8H3v6c0 1.1.9 2 2 2h6v-5l-4 1 1-4zm9 4-4-1v5h6c1.1 0 2-.9 2-2v-6h-5l1 4zm2-14h-6v5l4-1-1 4h5V5c0-1.1-.9-2-2-2z"
        }), 'Pages');
        default_1$i = Pages.default = _default$i;
        var Feed = {};
        var _interopRequireDefault$h = interopRequireDefaultExports;
        Object.defineProperty(Feed, "__esModule", {
          value: true
        });
        var default_1$h = Feed.default = void 0;
        var _createSvgIcon$h = _interopRequireDefault$h(requireCreateSvgIcon());
        var _jsxRuntime$h = jsxRuntimeExports;
        var _default$h = (0, _createSvgIcon$h.default)( /*#__PURE__*/(0, _jsxRuntime$h.jsx)("path", {
          d: "M16 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V8l-5-5zM7 7h5v2H7V7zm10 10H7v-2h10v2zm0-4H7v-2h10v2zm-2-4V5l4 4h-4z"
        }), 'Feed');
        default_1$h = Feed.default = _default$h;
        var Photo = {};
        var _interopRequireDefault$g = interopRequireDefaultExports;
        Object.defineProperty(Photo, "__esModule", {
          value: true
        });
        var default_1$g = exports('aU', Photo.default = void 0);
        var _createSvgIcon$g = _interopRequireDefault$g(requireCreateSvgIcon());
        var _jsxRuntime$g = jsxRuntimeExports;
        var _default$g = (0, _createSvgIcon$g.default)( /*#__PURE__*/(0, _jsxRuntime$g.jsx)("path", {
          d: "M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"
        }), 'Photo');
        exports('aU', default_1$g = Photo.default = _default$g);
        var RadioButtonChecked = {};
        var _interopRequireDefault$f = interopRequireDefaultExports;
        Object.defineProperty(RadioButtonChecked, "__esModule", {
          value: true
        });
        var default_1$f = RadioButtonChecked.default = void 0;
        var _createSvgIcon$f = _interopRequireDefault$f(requireCreateSvgIcon());
        var _jsxRuntime$f = jsxRuntimeExports;
        var _default$f = (0, _createSvgIcon$f.default)( /*#__PURE__*/(0, _jsxRuntime$f.jsx)("path", {
          d: "M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zm0-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
        }), 'RadioButtonChecked');
        default_1$f = RadioButtonChecked.default = _default$f;
        var CheckBox = {};
        var _interopRequireDefault$e = interopRequireDefaultExports;
        Object.defineProperty(CheckBox, "__esModule", {
          value: true
        });
        var default_1$e = exports('bm', CheckBox.default = void 0);
        var _createSvgIcon$e = _interopRequireDefault$e(requireCreateSvgIcon());
        var _jsxRuntime$e = jsxRuntimeExports;
        var _default$e = (0, _createSvgIcon$e.default)( /*#__PURE__*/(0, _jsxRuntime$e.jsx)("path", {
          d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
        }), 'CheckBox');
        exports('bm', default_1$e = CheckBox.default = _default$e);
        var UploadFile = {};
        var _interopRequireDefault$d = interopRequireDefaultExports;
        Object.defineProperty(UploadFile, "__esModule", {
          value: true
        });
        var default_1$d = UploadFile.default = void 0;
        var _createSvgIcon$d = _interopRequireDefault$d(requireCreateSvgIcon());
        var _jsxRuntime$d = jsxRuntimeExports;
        var _default$d = (0, _createSvgIcon$d.default)( /*#__PURE__*/(0, _jsxRuntime$d.jsx)("path", {
          d: "M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm4 18H6V4h7v5h5v11zM8 15.01l1.41 1.41L11 14.84V19h2v-4.16l1.59 1.59L16 15.01 12.01 11z"
        }), 'UploadFile');
        default_1$d = UploadFile.default = _default$d;
        var EventAvailable = {};
        var _interopRequireDefault$c = interopRequireDefaultExports;
        Object.defineProperty(EventAvailable, "__esModule", {
          value: true
        });
        var default_1$c = EventAvailable.default = void 0;
        var _createSvgIcon$c = _interopRequireDefault$c(requireCreateSvgIcon());
        var _jsxRuntime$c = jsxRuntimeExports;
        var _default$c = (0, _createSvgIcon$c.default)( /*#__PURE__*/(0, _jsxRuntime$c.jsx)("path", {
          d: "M16.53 11.06 15.47 10l-4.88 4.88-2.12-2.12-1.06 1.06L10.59 17l5.94-5.94zM19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11z"
        }), 'EventAvailable');
        default_1$c = EventAvailable.default = _default$c;
        var Today = {};
        var _interopRequireDefault$b = interopRequireDefaultExports;
        Object.defineProperty(Today, "__esModule", {
          value: true
        });
        var default_1$b = Today.default = void 0;
        var _createSvgIcon$b = _interopRequireDefault$b(requireCreateSvgIcon());
        var _jsxRuntime$b = jsxRuntimeExports;
        var _default$b = (0, _createSvgIcon$b.default)( /*#__PURE__*/(0, _jsxRuntime$b.jsx)("path", {
          d: "M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z"
        }), 'Today');
        default_1$b = Today.default = _default$b;
        var Schedule = {};
        var _interopRequireDefault$a = interopRequireDefaultExports;
        Object.defineProperty(Schedule, "__esModule", {
          value: true
        });
        var default_1$a = Schedule.default = void 0;
        var _createSvgIcon$a = _interopRequireDefault$a(requireCreateSvgIcon());
        var _jsxRuntime$a = jsxRuntimeExports;
        var _default$a = (0, _createSvgIcon$a.default)([/*#__PURE__*/(0, _jsxRuntime$a.jsx)("path", {
          d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
        }, "0"), /*#__PURE__*/(0, _jsxRuntime$a.jsx)("path", {
          d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
        }, "1")], 'Schedule');
        default_1$a = Schedule.default = _default$a;
        var Flag = {};
        var _interopRequireDefault$9 = interopRequireDefaultExports;
        Object.defineProperty(Flag, "__esModule", {
          value: true
        });
        var default_1$9 = Flag.default = void 0;
        var _createSvgIcon$9 = _interopRequireDefault$9(requireCreateSvgIcon());
        var _jsxRuntime$9 = jsxRuntimeExports;
        var _default$9 = (0, _createSvgIcon$9.default)( /*#__PURE__*/(0, _jsxRuntime$9.jsx)("path", {
          d: "M14.4 6 14 4H5v17h2v-7h5.6l.4 2h7V6z"
        }), 'Flag');
        default_1$9 = Flag.default = _default$9;
        var Start = {};
        var _interopRequireDefault$8 = interopRequireDefaultExports;
        Object.defineProperty(Start, "__esModule", {
          value: true
        });
        var default_1$8 = Start.default = void 0;
        var _createSvgIcon$8 = _interopRequireDefault$8(requireCreateSvgIcon());
        var _jsxRuntime$8 = jsxRuntimeExports;
        var _default$8 = (0, _createSvgIcon$8.default)( /*#__PURE__*/(0, _jsxRuntime$8.jsx)("path", {
          d: "M14.59 7.41 18.17 11H6v2h12.17l-3.59 3.59L16 18l6-6-6-6-1.41 1.41zM2 6v12h2V6H2z"
        }), 'Start');
        default_1$8 = Start.default = _default$8;
        var BurstMode = {};
        var _interopRequireDefault$7 = interopRequireDefaultExports;
        Object.defineProperty(BurstMode, "__esModule", {
          value: true
        });
        var default_1$7 = BurstMode.default = void 0;
        var _createSvgIcon$7 = _interopRequireDefault$7(requireCreateSvgIcon());
        var _jsxRuntime$7 = jsxRuntimeExports;
        var _default$7 = (0, _createSvgIcon$7.default)( /*#__PURE__*/(0, _jsxRuntime$7.jsx)("path", {
          d: "M1 5h2v14H1zm4 0h2v14H5zm17 0H10c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zM11 17l2.5-3.15L15.29 16l2.5-3.22L21 17H11z"
        }), 'BurstMode');
        default_1$7 = BurstMode.default = _default$7;
        var Sort = {};
        var _interopRequireDefault$6 = interopRequireDefaultExports;
        Object.defineProperty(Sort, "__esModule", {
          value: true
        });
        var default_1$6 = exports('aS', Sort.default = void 0);
        var _createSvgIcon$6 = _interopRequireDefault$6(requireCreateSvgIcon());
        var _jsxRuntime$6 = jsxRuntimeExports;
        var _default$6 = (0, _createSvgIcon$6.default)( /*#__PURE__*/(0, _jsxRuntime$6.jsx)("path", {
          d: "M3 18h6v-2H3v2zM3 6v2h18V6H3zm0 7h12v-2H3v2z"
        }), 'Sort');
        exports('aS', default_1$6 = Sort.default = _default$6);
        var Brush = {};
        var _interopRequireDefault$5 = interopRequireDefaultExports;
        Object.defineProperty(Brush, "__esModule", {
          value: true
        });
        var default_1$5 = Brush.default = void 0;
        var _createSvgIcon$5 = _interopRequireDefault$5(requireCreateSvgIcon());
        var _jsxRuntime$5 = jsxRuntimeExports;
        var _default$5 = (0, _createSvgIcon$5.default)( /*#__PURE__*/(0, _jsxRuntime$5.jsx)("path", {
          d: "M7 14c-1.66 0-3 1.34-3 3 0 1.31-1.16 2-2 2 .92 1.22 2.49 2 4 2 2.21 0 4-1.79 4-4 0-1.66-1.34-3-3-3zm13.71-9.37-1.34-1.34a.9959.9959 0 0 0-1.41 0L9 12.25 11.75 15l8.96-8.96c.39-.39.39-1.02 0-1.41z"
        }), 'Brush');
        default_1$5 = Brush.default = _default$5;
        var Videocam = {};
        var _interopRequireDefault$4 = interopRequireDefaultExports;
        Object.defineProperty(Videocam, "__esModule", {
          value: true
        });
        var default_1$4 = exports('aY', Videocam.default = void 0);
        var _createSvgIcon$4 = _interopRequireDefault$4(requireCreateSvgIcon());
        var _jsxRuntime$4 = jsxRuntimeExports;
        var _default$4 = (0, _createSvgIcon$4.default)( /*#__PURE__*/(0, _jsxRuntime$4.jsx)("path", {
          d: "M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"
        }), 'Videocam');
        exports('aY', default_1$4 = Videocam.default = _default$4);
        var AutoAwesomeMotion = {};
        var _interopRequireDefault$3 = interopRequireDefaultExports;
        Object.defineProperty(AutoAwesomeMotion, "__esModule", {
          value: true
        });
        var default_1$3 = AutoAwesomeMotion.default = void 0;
        var _createSvgIcon$3 = _interopRequireDefault$3(requireCreateSvgIcon());
        var _jsxRuntime$3 = jsxRuntimeExports;
        var _default$3 = (0, _createSvgIcon$3.default)( /*#__PURE__*/(0, _jsxRuntime$3.jsx)("path", {
          d: "M14 2H4c-1.11 0-2 .9-2 2v10h2V4h10V2zm4 4H8c-1.11 0-2 .9-2 2v10h2V8h10V6zm2 4h-8c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h8c1.1 0 2-.9 2-2v-8c0-1.1-.9-2-2-2z"
        }), 'AutoAwesomeMotion');
        default_1$3 = AutoAwesomeMotion.default = _default$3;
        var Speed = {};
        var _interopRequireDefault$2 = interopRequireDefaultExports;
        Object.defineProperty(Speed, "__esModule", {
          value: true
        });
        var default_1$2 = Speed.default = void 0;
        var _createSvgIcon$2 = _interopRequireDefault$2(requireCreateSvgIcon());
        var _jsxRuntime$2 = jsxRuntimeExports;
        var _default$2 = (0, _createSvgIcon$2.default)( /*#__PURE__*/(0, _jsxRuntime$2.jsx)("path", {
          d: "m20.38 8.57-1.23 1.85a8 8 0 0 1-.22 7.58H5.07A8 8 0 0 1 15.58 6.85l1.85-1.23A10 10 0 0 0 3.35 19a2 2 0 0 0 1.72 1h13.85a2 2 0 0 0 1.74-1 10 10 0 0 0-.27-10.44zm-9.79 6.84a2 2 0 0 0 2.83 0l5.66-8.49-8.49 5.66a2 2 0 0 0 0 2.83z"
        }), 'Speed');
        default_1$2 = Speed.default = _default$2;
        var QrCode = {};
        var _interopRequireDefault$1 = interopRequireDefaultExports;
        Object.defineProperty(QrCode, "__esModule", {
          value: true
        });
        var default_1$1 = QrCode.default = void 0;
        var _createSvgIcon$1 = _interopRequireDefault$1(requireCreateSvgIcon());
        var _jsxRuntime$1 = jsxRuntimeExports;
        var _default$1 = (0, _createSvgIcon$1.default)( /*#__PURE__*/(0, _jsxRuntime$1.jsx)("path", {
          d: "M3 11h8V3H3v8zm2-6h4v4H5V5zM3 21h8v-8H3v8zm2-6h4v4H5v-4zm8-12v8h8V3h-8zm6 6h-4V5h4v4zm0 10h2v2h-2zm-6-6h2v2h-2zm2 2h2v2h-2zm-2 2h2v2h-2zm2 2h2v2h-2zm2-2h2v2h-2zm0-4h2v2h-2zm2 2h2v2h-2z"
        }), 'QrCode');
        default_1$1 = QrCode.default = _default$1;
        const leftPanelGroupItem = "_leftPanelGroupItem_ckjs5_1";
        const groupTitle = "_groupTitle_ckjs5_6";
        const iconMenu = "_iconMenu_ckjs5_12";
        const tabHeader = "_tabHeader_ckjs5_16";
        const styles$2 = {
          leftPanelGroupItem: leftPanelGroupItem,
          groupTitle: groupTitle,
          iconMenu: iconMenu,
          tabHeader: tabHeader
        };
        const leftPannelItem = "_leftPannelItem_1kak4_1";
        const icon = "_icon_1kak4_11";
        const title = "_title_1kak4_15";
        const styles$1 = {
          leftPannelItem: leftPannelItem,
          icon: icon,
          title: title
        };
        function NewComponentsItem({
          item,
          t
        }) {
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            className: styles$1.leftPannelItem,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: styles$1.icon,
              children: item.icon
            }), /* @__PURE__ */jsxRuntimeExports.jsx("span", {
              className: styles$1.title,
              children: t("component_" + item.type + "_title")
            })]
          });
        }
        var Dvr = {};
        var _interopRequireDefault = interopRequireDefaultExports;
        Object.defineProperty(Dvr, "__esModule", {
          value: true
        });
        var default_1 = Dvr.default = void 0;
        var _createSvgIcon = _interopRequireDefault(requireCreateSvgIcon());
        var _jsxRuntime = jsxRuntimeExports;
        var _default = (0, _createSvgIcon.default)( /*#__PURE__*/(0, _jsxRuntime.jsx)("path", {
          d: "M21 3H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h5v2h8v-2h5c1.1 0 1.99-.9 1.99-2L23 5c0-1.1-.9-2-2-2zm0 14H3V5h18v12zm-2-9H8v2h11V8zm0 4H8v2h11v-2zM7 8H5v2h2V8zm0 4H5v2h2v-2z"
        }), 'Dvr');
        default_1 = Dvr.default = _default;
        const iconByType = exports('b3', (type, size = "medium") => {
          switch (type) {
            case "text":
              return /* @__PURE__ */jsxRuntimeExports.jsx(default_1$k, {
                fontSize: size
              });
            case "paragraph":
              return /* @__PURE__ */jsxRuntimeExports.jsx(default_1$h, {
                fontSize: size
              });
            case "barcode":
              return /* @__PURE__ */jsxRuntimeExports.jsx(default_1$1, {
                fontSize: size
              });
            case "number":
              return /* @__PURE__ */jsxRuntimeExports.jsx(default_1$j, {
                fontSize: size
              });
            case "email":
              return /* @__PURE__ */jsxRuntimeExports.jsx(default_1$l, {
                fontSize: size
              });
            case "scq":
              return /* @__PURE__ */jsxRuntimeExports.jsx(default_1$f, {
                fontSize: size
              });
            case "image_scq":
              return /* @__PURE__ */jsxRuntimeExports.jsx(default_1$g, {
                fontSize: size
              });
            case "scq_array":
              return /* @__PURE__ */jsxRuntimeExports.jsx(default_1$f, {
                fontSize: size
              });
            case "mcq":
              return /* @__PURE__ */jsxRuntimeExports.jsx(default_1$e, {
                fontSize: size
              });
            case "image_mcq":
              return /* @__PURE__ */jsxRuntimeExports.jsx(default_1$7, {
                fontSize: size
              });
            case "nps":
              return /* @__PURE__ */jsxRuntimeExports.jsx(default_1$2, {
                fontSize: size
              });
            case "date":
              return /* @__PURE__ */jsxRuntimeExports.jsx(default_1$b, {
                fontSize: size
              });
            case "date_time":
              return /* @__PURE__ */jsxRuntimeExports.jsx(default_1$c, {
                fontSize: size
              });
            case "time":
              return /* @__PURE__ */jsxRuntimeExports.jsx(default_1$a, {
                fontSize: size
              });
            case "file_upload":
              return /* @__PURE__ */jsxRuntimeExports.jsx(default_1$d, {
                fontSize: size
              });
            case "signature":
              return /* @__PURE__ */jsxRuntimeExports.jsx(default_1$5, {
                fontSize: size
              });
            case "photo_capture":
              return /* @__PURE__ */jsxRuntimeExports.jsx(default_1$g, {
                fontSize: size
              });
            case "video_capture":
              return /* @__PURE__ */jsxRuntimeExports.jsx(default_1$4, {
                fontSize: size
              });
            case "ranking":
              return /* @__PURE__ */jsxRuntimeExports.jsx(default_1$6, {
                fontSize: size
              });
            case "image_ranking":
              return /* @__PURE__ */jsxRuntimeExports.jsx(default_1$3, {
                fontSize: size
              });
            case "text_display":
              return /* @__PURE__ */jsxRuntimeExports.jsx(default_1, {
                fontSize: size
              });
            case "image_display":
              return /* @__PURE__ */jsxRuntimeExports.jsx(default_1$g, {
                fontSize: size
              });
            case "video_display":
              return /* @__PURE__ */jsxRuntimeExports.jsx(default_1$4, {
                fontSize: size
              });
          }
        });
        const questions = [{
          name: "section_text_based",
          type: "text",
          items: [{
            type: "text",
            icon: iconByType("text")
          }, {
            type: "paragraph",
            icon: iconByType("paragraph")
          }, {
            type: "number",
            icon: iconByType("number")
          }, {
            type: "email",
            icon: iconByType("email")
          }]
        }, {
          name: "section_choice_based",
          type: "choice",
          items: [{
            type: "scq",
            icon: iconByType("scq")
          }, {
            type: "image_scq",
            icon: iconByType("image_scq")
          }, {
            type: "scq_array",
            icon: iconByType("scq_array")
          }, {
            type: "mcq",
            icon: iconByType("mcq")
          }, {
            type: "image_mcq",
            icon: iconByType("image_mcq")
          }, {
            type: "nps",
            icon: iconByType("nps")
          }]
        }, {
          name: "section_date_time",
          type: "date-time",
          items: [{
            type: "date",
            icon: iconByType("date")
          }, {
            type: "date_time",
            icon: iconByType("date_time")
          }, {
            type: "time",
            icon: iconByType("time")
          }]
        }, {
          name: "section_file_based",
          type: "file",
          items: [{
            type: "file_upload",
            icon: iconByType("file_upload")
          }, {
            type: "signature",
            icon: iconByType("signature")
          }, {
            type: "photo_capture",
            icon: iconByType("photo_capture")
          }, {
            type: "video_capture",
            icon: iconByType("video_capture")
          }]
        }, {
          name: "section_other",
          type: "other",
          items: [{
            type: "ranking",
            icon: iconByType("ranking")
          }, {
            type: "image_ranking",
            icon: iconByType("image_ranking")
          }, {
            type: "barcode",
            icon: iconByType("barcode")
          }]
        }, {
          name: "section_info",
          type: "info",
          items: [{
            type: "text_display",
            icon: iconByType("text_display")
          }, {
            type: "image_display",
            icon: iconByType("image_display")
          }, {
            type: "video_display",
            icon: iconByType("video_display")
          }]
        }];
        const groups = [{
          name: "section_sections",
          type: "sections",
          items: [{
            idType: 1,
            type: "welcome",
            icon: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$8, {})
          }, {
            idType: 2,
            type: "group",
            icon: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$i, {})
          }, {
            idType: 3,
            type: "end",
            icon: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$9, {})
          }]
        }];
        function NewComponentsPanel({
          t
        }) {
          let draggableIndex = 0;
          let groupsdraggableIndex = 0;
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(ConnectedDroppable, {
              droppableId: "new-groups",
              type: "groups",
              isDropDisabled: true,
              children: provided => /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                className: styles$2.leftContent,
                ref: provided.innerRef,
                ...provided.droppableProps,
                children: [groups.map((item, index) => /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                  className: styles$2.leftPanelGroupItem,
                  index,
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx("div", {
                    className: styles$2.groupTitle,
                    children: t(item.name)
                  }), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                    className: styles$2.leftItems,
                    children: item.items.map((question, index2) => {
                      groupsdraggableIndex++;
                      return /* @__PURE__ */jsxRuntimeExports.jsx(PublicDraggable, {
                        draggableId: question.type,
                        index: groupsdraggableIndex,
                        children: (provided2, snapshot) => {
                          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                            ref: provided2.innerRef,
                            snapshot,
                            ...provided2.draggableProps,
                            ...provided2.dragHandleProps,
                            children: /* @__PURE__ */jsxRuntimeExports.jsx(NewComponentsItem, {
                              t,
                              item: question,
                              index: index2
                            })
                          });
                        }
                      }, question.type);
                    })
                  })]
                }, index)), provided.placeholder]
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(ConnectedDroppable, {
              droppableId: "new-questions",
              type: "questions",
              isDropDisabled: true,
              children: provided => /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                className: styles$2.leftContent,
                ref: provided.innerRef,
                ...provided.droppableProps,
                children: [questions.map((item, index) => /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                  className: styles$2.leftPanelGroupItem,
                  index,
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx("div", {
                    className: styles$2.groupTitle,
                    children: t(item.name)
                  }), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                    className: styles$2.leftItems,
                    children: item.items.map((question, index2) => {
                      draggableIndex++;
                      return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                        children: /* @__PURE__ */jsxRuntimeExports.jsx(PublicDraggable, {
                          draggableId: question.type,
                          index: draggableIndex,
                          children: (provided2, snapshot) => {
                            return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                              ref: provided2.innerRef,
                              snapshot,
                              ...provided2.draggableProps,
                              ...provided2.dragHandleProps,
                              children: /* @__PURE__ */jsxRuntimeExports.jsx(NewComponentsItem, {
                                t,
                                item: question,
                                index: index2
                              })
                            });
                          }
                        })
                      }, `draggable-${index2}`);
                    })
                  })]
                }, index)), provided.placeholder]
              })
            })]
          });
        }
        const createQuestion = (type, qId, lang) => {
          let code = `Q${qId}`;
          let returnObj = {};
          let state = {
            type
          };
          let newQuestion = {
            code: `Q${qId}`,
            qualifiedCode: `Q${qId}`,
            type
          };
          returnObj[code] = state;
          returnObj.question = newQuestion;
          switch (type) {
            case "text":
              state.content = {
                hint: {},
                label: {},
                description: {}
              };
              state.instructionList = [{
                code: "value",
                isActive: false,
                returnType: {
                  name: "String"
                },
                text: ""
              }];
              state.maxChars = 30;
              state.content.hint[lang] = "Short text Question";
              state.content.label[lang] = "Short text Question";
              state.showHint = true;
              state.content.description[lang] = "General purpose short text questions, we can use it to ask for name, or city...etc.";
              break;
            case "number":
              state.content = {
                hint: {},
                label: {},
                description: {}
              };
              state.maxChars = 30;
              state.instructionList = [{
                code: "value",
                isActive: false,
                returnType: {
                  name: "Double"
                },
                text: ""
              }];
              state.showHint = true;
              state.content.hint[lang] = "Number Questions";
              state.content.label[lang] = "Number Questions";
              state.content.description[lang] = "For age, weight, distances and other numerical values";
              break;
            case "email":
              state.content = {
                hint: {},
                label: {},
                description: {}
              };
              state.maxChars = 30;
              state.instructionList = [{
                code: "value",
                isActive: false,
                returnType: {
                  name: "String"
                },
                text: ""
              }];
              state.showHint = true;
              state.content.hint[lang] = "Email Question";
              state.content.label[lang] = "Email Question";
              break;
            case "paragraph":
              state.content = {
                hint: {},
                label: {},
                description: {}
              };
              state.instructionList = [{
                code: "value",
                isActive: false,
                returnType: {
                  name: "String"
                },
                text: ""
              }];
              state.showHint = true;
              state.content.hint[lang] = "Long Text Question";
              state.content.label[lang] = "Long Text Question";
              state.content.description[lang] = "for longer text";
              break;
            case "barcode":
              state.content = {
                hint: {},
                label: {},
                description: {}
              };
              state.instructionList = [{
                code: "value",
                isActive: false,
                returnType: {
                  name: "String"
                },
                text: ""
              }, {
                code: "mode",
                isActive: false,
                returnType: {
                  name: "String"
                },
                text: "offline"
              }];
              state.showHint = true;
              state.content.hint[lang] = "click on image above to open barcode scanner";
              state.content.label[lang] = "Barcode Question";
              state.content.description[lang] = "Barcode Question";
              break;
            case "scq":
              state.content = {
                hint: {},
                label: {},
                description: {}
              };
              state.instructionList = [{
                code: "value",
                isActive: false,
                returnType: {
                  name: "String"
                },
                text: ""
              }];
              state.content.label[lang] = "Single Choice Question";
              state.content.description[lang] = "Single Choice Question Description";
              returnObj[`Q${qId}A1`] = {
                content: {
                  label: {
                    [lang]: "Option 1"
                  }
                }
              };
              returnObj[`Q${qId}A2`] = {
                content: {
                  label: {
                    [lang]: "Option 2"
                  }
                }
              };
              returnObj[`Q${qId}A3`] = {
                content: {
                  label: {
                    [lang]: "Option 3"
                  }
                }
              };
              state.children = [{
                code: "A1",
                qualifiedCode: `Q${qId}A1`
              }, {
                code: "A2",
                qualifiedCode: `Q${qId}A2`
              }, {
                code: "A3",
                qualifiedCode: `Q${qId}A3`
              }];
              break;
            case "image_scq":
              state.content = {
                label: {},
                description: {}
              };
              state.columns = 3;
              state.imageAspectRatio = 1;
              state.spacing = 8;
              state.instructionList = [{
                code: "value",
                isActive: false,
                returnType: {
                  name: "String"
                },
                text: ""
              }];
              state.content.label[lang] = "Image Single Choice Question";
              state.content.description[lang] = "Image Single Choice Question Description";
              returnObj[`Q${qId}A1`] = {
                content: {
                  label: {
                    [lang]: "Option 1"
                  }
                }
              };
              returnObj[`Q${qId}A2`] = {
                content: {
                  label: {
                    [lang]: "Option 2"
                  }
                }
              };
              returnObj[`Q${qId}A3`] = {
                content: {
                  label: {
                    [lang]: "Option 3"
                  }
                }
              };
              state.children = [{
                code: "A1",
                qualifiedCode: `Q${qId}A1`
              }, {
                code: "A2",
                qualifiedCode: `Q${qId}A2`
              }, {
                code: "A3",
                qualifiedCode: `Q${qId}A3`
              }];
              break;
            case "mcq":
              state.content = {
                hint: {},
                label: {},
                description: {}
              };
              state.content.label[lang] = "Multiple Choice Question";
              state.content.description[lang] = "Multiple Choice Question Description";
              returnObj[`Q${qId}A1`] = {
                instructionList: [{
                  code: "value",
                  isActive: false,
                  returnType: {
                    name: "Boolean"
                  },
                  text: ""
                }],
                content: {
                  label: {
                    [lang]: "Option 1"
                  }
                }
              };
              returnObj[`Q${qId}A2`] = {
                instructionList: [{
                  code: "value",
                  isActive: false,
                  returnType: {
                    name: "Boolean"
                  },
                  text: ""
                }],
                content: {
                  label: {
                    [lang]: "Option 2"
                  }
                }
              };
              returnObj[`Q${qId}A3`] = {
                instructionList: [{
                  code: "value",
                  isActive: false,
                  returnType: {
                    name: "Boolean"
                  },
                  text: ""
                }],
                content: {
                  label: {
                    [lang]: "Option 3"
                  }
                }
              };
              state.children = [{
                code: "A1",
                qualifiedCode: `Q${qId}A1`
              }, {
                code: "A2",
                qualifiedCode: `Q${qId}A2`
              }, {
                code: "A3",
                qualifiedCode: `Q${qId}A3`
              }];
              break;
            case "image_ranking":
              state.content = {
                label: {},
                description: {}
              };
              state.content.label[lang] = "Image Ranking Question";
              state.content.description[lang] = "Image Ranking Question Description";
              state.columns = 3;
              state.imageAspectRatio = 1;
              state.spacing = 8;
              returnObj[`Q${qId}A1`] = {
                instructionList: [{
                  code: "value",
                  isActive: false,
                  returnType: {
                    name: "Int"
                  },
                  text: ""
                }],
                content: {
                  label: {
                    [lang]: "Option 1"
                  }
                }
              };
              returnObj[`Q${qId}A2`] = {
                instructionList: [{
                  code: "value",
                  isActive: false,
                  returnType: {
                    name: "Int"
                  },
                  text: ""
                }],
                content: {
                  label: {
                    [lang]: "Option 2"
                  }
                }
              };
              returnObj[`Q${qId}A3`] = {
                instructionList: [{
                  code: "value",
                  isActive: false,
                  returnType: {
                    name: "Int"
                  },
                  text: ""
                }],
                content: {
                  label: {
                    [lang]: "Option 3"
                  }
                }
              };
              state.children = [{
                code: "A1",
                qualifiedCode: `Q${qId}A1`
              }, {
                code: "A2",
                qualifiedCode: `Q${qId}A2`
              }, {
                code: "A3",
                qualifiedCode: `Q${qId}A3`
              }];
              break;
            case "ranking":
              state.content = {
                label: {},
                description: {}
              };
              state.content.label[lang] = "Ranking Question";
              state.content.description[lang] = "Ranking Question Description";
              returnObj[`Q${qId}A1`] = {
                instructionList: [{
                  code: "value",
                  isActive: false,
                  returnType: {
                    name: "Int"
                  },
                  text: ""
                }],
                content: {
                  label: {
                    [lang]: "Option 1"
                  }
                }
              };
              returnObj[`Q${qId}A2`] = {
                instructionList: [{
                  code: "value",
                  isActive: false,
                  returnType: {
                    name: "Int"
                  },
                  text: ""
                }],
                content: {
                  label: {
                    [lang]: "Option 2"
                  }
                }
              };
              returnObj[`Q${qId}A3`] = {
                instructionList: [{
                  code: "value",
                  isActive: false,
                  returnType: {
                    name: "Int"
                  },
                  text: ""
                }],
                content: {
                  label: {
                    [lang]: "Option 3"
                  }
                }
              };
              state.children = [{
                code: "A1",
                qualifiedCode: `Q${qId}A1`
              }, {
                code: "A2",
                qualifiedCode: `Q${qId}A2`
              }, {
                code: "A3",
                qualifiedCode: `Q${qId}A3`
              }];
              break;
            case "nps":
              state.content = {
                label: {},
                description: {},
                lower_bound_hint: {},
                higher_bound_hint: {}
              };
              state.content.label[lang] = "NPS Question";
              state.content.lower_bound_hint[lang] = "Least Likely";
              state.content.higher_bound_hint[lang] = "Most Likely";
              state.content.description[lang] = "NPS Question Description";
              state.instructionList = [{
                code: "value",
                isActive: false,
                returnType: {
                  name: "Int"
                },
                text: ""
              }];
              break;
            case "image_mcq":
              state.content = {
                label: {},
                description: {}
              };
              state.content.label[lang] = "Image Multiple Choice Question";
              state.content.description[lang] = "Image Multiple Choice Question Description";
              state.columns = 3;
              state.imageAspectRatio = 1;
              state.spacing = 8;
              returnObj[`Q${qId}A1`] = {
                instructionList: [{
                  code: "value",
                  isActive: false,
                  returnType: {
                    name: "Boolean"
                  },
                  text: ""
                }],
                content: {
                  label: {
                    [lang]: "Option 1"
                  }
                }
              };
              returnObj[`Q${qId}A2`] = {
                instructionList: [{
                  code: "value",
                  isActive: false,
                  returnType: {
                    name: "Boolean"
                  },
                  text: ""
                }],
                content: {
                  label: {
                    [lang]: "Option 2"
                  }
                }
              };
              returnObj[`Q${qId}A3`] = {
                instructionList: [{
                  code: "value",
                  isActive: false,
                  returnType: {
                    name: "Boolean"
                  },
                  text: ""
                }],
                content: {
                  label: {
                    [lang]: "Option 3"
                  }
                }
              };
              state.children = [{
                code: "A1",
                qualifiedCode: `Q${qId}A1`
              }, {
                code: "A2",
                qualifiedCode: `Q${qId}A2`
              }, {
                code: "A3",
                qualifiedCode: `Q${qId}A3`
              }];
              break;
            case "scq_array":
              state.content = {
                hint: {},
                label: {},
                description: {}
              };
              state.content.hint[lang] = "Single Choice Question Array";
              state.content.label[lang] = "Single Choice Question Array";
              state.content.description[lang] = "Single Choice Question Array Description";
              returnObj[`Q${qId}Ac1`] = {
                type: "column",
                content: {
                  label: {
                    [lang]: "Col 1"
                  }
                }
              };
              returnObj[`Q${qId}Ac2`] = {
                type: "column",
                content: {
                  label: {
                    [lang]: "Col 2"
                  }
                }
              };
              returnObj[`Q${qId}Ac3`] = {
                type: "column",
                content: {
                  label: {
                    [lang]: "Col 3"
                  }
                }
              };
              returnObj[`Q${qId}A1`] = {
                type: "row",
                instructionList: [{
                  code: "value",
                  isActive: false,
                  returnType: {
                    name: "String"
                  },
                  text: ""
                }],
                content: {
                  label: {
                    [lang]: "Row 1"
                  }
                }
              };
              returnObj[`Q${qId}A2`] = {
                type: "row",
                instructionList: [{
                  code: "value",
                  isActive: false,
                  returnType: {
                    name: "String"
                  },
                  text: ""
                }],
                content: {
                  label: {
                    [lang]: "Row 2"
                  }
                }
              };
              returnObj[`Q${qId}A3`] = {
                type: "row",
                instructionList: [{
                  code: "value",
                  isActive: false,
                  returnType: {
                    name: "String"
                  },
                  text: ""
                }],
                content: {
                  label: {
                    [lang]: "Row 3"
                  }
                }
              };
              state.children = [{
                code: "Ac1",
                qualifiedCode: `Q${qId}Ac1`,
                type: "column"
              }, {
                code: "Ac2",
                qualifiedCode: `Q${qId}Ac2`,
                type: "column"
              }, {
                code: "Ac3",
                qualifiedCode: `Q${qId}Ac3`,
                type: "column"
              }, {
                code: "A1",
                qualifiedCode: `Q${qId}A1`,
                type: "row"
              }, {
                code: "A2",
                qualifiedCode: `Q${qId}A2`,
                type: "row"
              }, {
                code: "A3",
                qualifiedCode: `Q${qId}A3`,
                type: "row"
              }];
              break;
            case "file_upload":
              state.content = {
                hint: {},
                label: {},
                description: {}
              };
              state.content.label[lang] = "File Upload";
              state.content.description[lang] = "File Upload Description";
              state.instructionList = [{
                code: "value",
                isActive: false,
                returnType: {
                  name: "File"
                },
                text: ""
              }];
              break;
            case "signature":
              state.content = {
                label: {},
                description: {}
              };
              state.content.label[lang] = "Signature";
              state.content.description[lang] = "Signature Description";
              state.instructionList = [{
                code: "value",
                isActive: false,
                returnType: {
                  name: "File"
                },
                text: ""
              }];
              break;
            case "photo_capture":
              state.content = {
                label: {},
                description: {},
                hint: {}
              };
              state.showHint = true;
              state.content.label[lang] = "Photo Capture";
              state.content.description[lang] = "Photo Capture Description";
              state.content.hint[lang] = "Click on photo to activate camera";
              state.instructionList = [{
                code: "value",
                isActive: false,
                returnType: {
                  name: "File"
                },
                text: ""
              }, {
                code: "mode",
                isActive: false,
                returnType: {
                  name: "String"
                },
                text: "offline"
              }];
              break;
            case "video_capture":
              state.content = {
                label: {},
                description: {},
                hint: {}
              };
              state.showHint = true;
              state.content.label[lang] = "Video Capture";
              state.content.description[lang] = "Video Capture Description";
              state.content.hint[lang] = "Click on photo to activate camera";
              state.instructionList = [{
                code: "value",
                isActive: false,
                returnType: {
                  name: "File"
                },
                text: ""
              }, {
                code: "mode",
                isActive: false,
                returnType: {
                  name: "String"
                },
                text: "offline"
              }];
              break;
            case "date":
              state.type = "date";
              state.content = {
                hint: {},
                label: {},
                description: {}
              };
              state.content.label[lang] = "Date";
              state.content.description[lang] = "Date Description";
              state.dateFormat = "YYYY/MM/DD";
              state.maxDate = "";
              state.minDate = "";
              state.instructionList = [{
                code: "value",
                isActive: false,
                returnType: {
                  name: "Date"
                },
                text: ""
              }];
              break;
            case "date_time":
              state.content = {
                hint: {},
                label: {},
                description: {}
              };
              state.content.label[lang] = "Date time";
              state.content.description[lang] = "Date time Description";
              state.dateFormat = "YYYY/MM/DD";
              state.fullDayFormat = false;
              state.maxDate = "";
              state.minDate = "";
              state.instructionList = [{
                code: "value",
                isActive: false,
                returnType: {
                  name: "Date"
                },
                text: ""
              }];
              break;
            case "time":
              state.content = {
                hint: {},
                label: {},
                description: {}
              };
              state.content.label[lang] = "Time";
              state.content.description[lang] = "Time Description";
              state.fullDayFormat = false;
              state.instructionList = [{
                code: "value",
                isActive: false,
                returnType: {
                  name: "Date"
                },
                text: ""
              }];
              break;
            case "text_display":
              state.content = {
                label: {},
                description: {}
              };
              state.content.label[lang] = "Text Display";
              state.content.description[lang] = "To just show some infor";
              break;
            case "video_display":
              state.content = {
                label: {},
                description: {}
              };
              state.content.label[lang] = "Video/Audio Display";
              state.content.description[lang] = "To just show some infor";
              break;
            case "image_display":
              state.content = {
                label: {},
                description: {}
              };
              state.content.label[lang] = "Image Display";
              state.content.description[lang] = "To just show some infor";
              break;
          }
          return returnObj;
        };
        const createGroup = (groupType, gId, lang) => {
          let code = `G${gId}`;
          let state = {
            groupType,
            content: {
              label: {},
              description: {}
            }
          };
          let newGroup = {
            code,
            qualifiedCode: code,
            type: groupType.toLowerCase()
          };
          switch (groupType) {
            case "WELCOME":
              state.content.label[lang] = "Welcome Group";
              state.content.description[lang] = "Here you make an introduction about survey, display privacy rules, and also take consent";
              break;
            case "END":
              state.content.label[lang] = "End Group";
              state.content.description[lang] = "You can thank the user for filling in the survey... you can also redirect to another url, or repeat the survey";
              break;
            case "GROUP":
              state.content.label[lang] = code;
              state.content.description[lang] = code + " Description";
              break;
          }
          return {
            newGroup,
            state
          };
        };
        var lodash_clonedeep = {
          exports: {}
        };

        /**
         * lodash (Custom Build) <https://lodash.com/>
         * Build: `lodash modularize exports="npm" -o ./`
         * Copyright jQuery Foundation and other contributors <https://jquery.org/>
         * Released under MIT license <https://lodash.com/license>
         * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
         * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
         */
        lodash_clonedeep.exports;
        (function (module, exports$1) {
          /** Used as the size to enable large array optimizations. */
          var LARGE_ARRAY_SIZE = 200;

          /** Used to stand-in for `undefined` hash values. */
          var HASH_UNDEFINED = '__lodash_hash_undefined__';

          /** Used as references for various `Number` constants. */
          var MAX_SAFE_INTEGER = 9007199254740991;

          /** `Object#toString` result references. */
          var argsTag = '[object Arguments]',
            arrayTag = '[object Array]',
            boolTag = '[object Boolean]',
            dateTag = '[object Date]',
            errorTag = '[object Error]',
            funcTag = '[object Function]',
            genTag = '[object GeneratorFunction]',
            mapTag = '[object Map]',
            numberTag = '[object Number]',
            objectTag = '[object Object]',
            promiseTag = '[object Promise]',
            regexpTag = '[object RegExp]',
            setTag = '[object Set]',
            stringTag = '[object String]',
            symbolTag = '[object Symbol]',
            weakMapTag = '[object WeakMap]';
          var arrayBufferTag = '[object ArrayBuffer]',
            dataViewTag = '[object DataView]',
            float32Tag = '[object Float32Array]',
            float64Tag = '[object Float64Array]',
            int8Tag = '[object Int8Array]',
            int16Tag = '[object Int16Array]',
            int32Tag = '[object Int32Array]',
            uint8Tag = '[object Uint8Array]',
            uint8ClampedTag = '[object Uint8ClampedArray]',
            uint16Tag = '[object Uint16Array]',
            uint32Tag = '[object Uint32Array]';

          /**
           * Used to match `RegExp`
           * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
           */
          var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

          /** Used to match `RegExp` flags from their coerced string values. */
          var reFlags = /\w*$/;

          /** Used to detect host constructors (Safari). */
          var reIsHostCtor = /^\[object .+?Constructor\]$/;

          /** Used to detect unsigned integer values. */
          var reIsUint = /^(?:0|[1-9]\d*)$/;

          /** Used to identify `toStringTag` values supported by `_.clone`. */
          var cloneableTags = {};
          cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
          cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;

          /** Detect free variable `global` from Node.js. */
          var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

          /** Detect free variable `self`. */
          var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

          /** Used as a reference to the global object. */
          var root = freeGlobal || freeSelf || Function('return this')();

          /** Detect free variable `exports`. */
          var freeExports = exports$1 && !exports$1.nodeType && exports$1;

          /** Detect free variable `module`. */
          var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

          /** Detect the popular CommonJS extension `module.exports`. */
          var moduleExports = freeModule && freeModule.exports === freeExports;

          /**
           * Adds the key-value `pair` to `map`.
           *
           * @private
           * @param {Object} map The map to modify.
           * @param {Array} pair The key-value pair to add.
           * @returns {Object} Returns `map`.
           */
          function addMapEntry(map, pair) {
            // Don't return `map.set` because it's not chainable in IE 11.
            map.set(pair[0], pair[1]);
            return map;
          }

          /**
           * Adds `value` to `set`.
           *
           * @private
           * @param {Object} set The set to modify.
           * @param {*} value The value to add.
           * @returns {Object} Returns `set`.
           */
          function addSetEntry(set, value) {
            // Don't return `set.add` because it's not chainable in IE 11.
            set.add(value);
            return set;
          }

          /**
           * A specialized version of `_.forEach` for arrays without support for
           * iteratee shorthands.
           *
           * @private
           * @param {Array} [array] The array to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array} Returns `array`.
           */
          function arrayEach(array, iteratee) {
            var index = -1,
              length = array ? array.length : 0;
            while (++index < length) {
              if (iteratee(array[index], index, array) === false) {
                break;
              }
            }
            return array;
          }

          /**
           * Appends the elements of `values` to `array`.
           *
           * @private
           * @param {Array} array The array to modify.
           * @param {Array} values The values to append.
           * @returns {Array} Returns `array`.
           */
          function arrayPush(array, values) {
            var index = -1,
              length = values.length,
              offset = array.length;
            while (++index < length) {
              array[offset + index] = values[index];
            }
            return array;
          }

          /**
           * A specialized version of `_.reduce` for arrays without support for
           * iteratee shorthands.
           *
           * @private
           * @param {Array} [array] The array to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {*} [accumulator] The initial value.
           * @param {boolean} [initAccum] Specify using the first element of `array` as
           *  the initial value.
           * @returns {*} Returns the accumulated value.
           */
          function arrayReduce(array, iteratee, accumulator, initAccum) {
            var index = -1,
              length = array ? array.length : 0;
            if (initAccum && length) {
              accumulator = array[++index];
            }
            while (++index < length) {
              accumulator = iteratee(accumulator, array[index], index, array);
            }
            return accumulator;
          }

          /**
           * The base implementation of `_.times` without support for iteratee shorthands
           * or max array length checks.
           *
           * @private
           * @param {number} n The number of times to invoke `iteratee`.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array} Returns the array of results.
           */
          function baseTimes(n, iteratee) {
            var index = -1,
              result = Array(n);
            while (++index < n) {
              result[index] = iteratee(index);
            }
            return result;
          }

          /**
           * Gets the value at `key` of `object`.
           *
           * @private
           * @param {Object} [object] The object to query.
           * @param {string} key The key of the property to get.
           * @returns {*} Returns the property value.
           */
          function getValue(object, key) {
            return object == null ? undefined : object[key];
          }

          /**
           * Checks if `value` is a host object in IE < 9.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
           */
          function isHostObject(value) {
            // Many host objects are `Object` objects that can coerce to strings
            // despite having improperly defined `toString` methods.
            var result = false;
            if (value != null && typeof value.toString != 'function') {
              try {
                result = !!(value + '');
              } catch (e) {}
            }
            return result;
          }

          /**
           * Converts `map` to its key-value pairs.
           *
           * @private
           * @param {Object} map The map to convert.
           * @returns {Array} Returns the key-value pairs.
           */
          function mapToArray(map) {
            var index = -1,
              result = Array(map.size);
            map.forEach(function (value, key) {
              result[++index] = [key, value];
            });
            return result;
          }

          /**
           * Creates a unary function that invokes `func` with its argument transformed.
           *
           * @private
           * @param {Function} func The function to wrap.
           * @param {Function} transform The argument transform.
           * @returns {Function} Returns the new function.
           */
          function overArg(func, transform) {
            return function (arg) {
              return func(transform(arg));
            };
          }

          /**
           * Converts `set` to an array of its values.
           *
           * @private
           * @param {Object} set The set to convert.
           * @returns {Array} Returns the values.
           */
          function setToArray(set) {
            var index = -1,
              result = Array(set.size);
            set.forEach(function (value) {
              result[++index] = value;
            });
            return result;
          }

          /** Used for built-in method references. */
          var arrayProto = Array.prototype,
            funcProto = Function.prototype,
            objectProto = Object.prototype;

          /** Used to detect overreaching core-js shims. */
          var coreJsData = root['__core-js_shared__'];

          /** Used to detect methods masquerading as native. */
          var maskSrcKey = function () {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
            return uid ? 'Symbol(src)_1.' + uid : '';
          }();

          /** Used to resolve the decompiled source of functions. */
          var funcToString = funcProto.toString;

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty;

          /**
           * Used to resolve the
           * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
           * of values.
           */
          var objectToString = objectProto.toString;

          /** Used to detect if a method is native. */
          var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

          /** Built-in value references. */
          var Buffer = moduleExports ? root.Buffer : undefined,
            Symbol = root.Symbol,
            Uint8Array = root.Uint8Array,
            getPrototype = overArg(Object.getPrototypeOf, Object),
            objectCreate = Object.create,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            splice = arrayProto.splice;

          /* Built-in method references for those with the same name as other `lodash` methods. */
          var nativeGetSymbols = Object.getOwnPropertySymbols,
            nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
            nativeKeys = overArg(Object.keys, Object);

          /* Built-in method references that are verified to be native. */
          var DataView = getNative(root, 'DataView'),
            Map = getNative(root, 'Map'),
            Promise = getNative(root, 'Promise'),
            Set = getNative(root, 'Set'),
            WeakMap = getNative(root, 'WeakMap'),
            nativeCreate = getNative(Object, 'create');

          /** Used to detect maps, sets, and weakmaps. */
          var dataViewCtorString = toSource(DataView),
            mapCtorString = toSource(Map),
            promiseCtorString = toSource(Promise),
            setCtorString = toSource(Set),
            weakMapCtorString = toSource(WeakMap);

          /** Used to convert symbols to primitives and strings. */
          var symbolProto = Symbol ? Symbol.prototype : undefined,
            symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

          /**
           * Creates a hash object.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function Hash(entries) {
            var index = -1,
              length = entries ? entries.length : 0;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }

          /**
           * Removes all key-value entries from the hash.
           *
           * @private
           * @name clear
           * @memberOf Hash
           */
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
          }

          /**
           * Removes `key` and its value from the hash.
           *
           * @private
           * @name delete
           * @memberOf Hash
           * @param {Object} hash The hash to modify.
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function hashDelete(key) {
            return this.has(key) && delete this.__data__[key];
          }

          /**
           * Gets the hash value for `key`.
           *
           * @private
           * @name get
           * @memberOf Hash
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result = data[key];
              return result === HASH_UNDEFINED ? undefined : result;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined;
          }

          /**
           * Checks if a hash value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf Hash
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
          }

          /**
           * Sets the hash `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf Hash
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the hash instance.
           */
          function hashSet(key, value) {
            var data = this.__data__;
            data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
            return this;
          }

          // Add methods to `Hash`.
          Hash.prototype.clear = hashClear;
          Hash.prototype['delete'] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;

          /**
           * Creates an list cache object.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function ListCache(entries) {
            var index = -1,
              length = entries ? entries.length : 0;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }

          /**
           * Removes all key-value entries from the list cache.
           *
           * @private
           * @name clear
           * @memberOf ListCache
           */
          function listCacheClear() {
            this.__data__ = [];
          }

          /**
           * Removes `key` and its value from the list cache.
           *
           * @private
           * @name delete
           * @memberOf ListCache
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function listCacheDelete(key) {
            var data = this.__data__,
              index = assocIndexOf(data, key);
            if (index < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index, 1);
            }
            return true;
          }

          /**
           * Gets the list cache value for `key`.
           *
           * @private
           * @name get
           * @memberOf ListCache
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function listCacheGet(key) {
            var data = this.__data__,
              index = assocIndexOf(data, key);
            return index < 0 ? undefined : data[index][1];
          }

          /**
           * Checks if a list cache value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf ListCache
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }

          /**
           * Sets the list cache `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf ListCache
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the list cache instance.
           */
          function listCacheSet(key, value) {
            var data = this.__data__,
              index = assocIndexOf(data, key);
            if (index < 0) {
              data.push([key, value]);
            } else {
              data[index][1] = value;
            }
            return this;
          }

          // Add methods to `ListCache`.
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype['delete'] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;

          /**
           * Creates a map cache object to store key-value pairs.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function MapCache(entries) {
            var index = -1,
              length = entries ? entries.length : 0;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }

          /**
           * Removes all key-value entries from the map.
           *
           * @private
           * @name clear
           * @memberOf MapCache
           */
          function mapCacheClear() {
            this.__data__ = {
              'hash': new Hash(),
              'map': new (Map || ListCache)(),
              'string': new Hash()
            };
          }

          /**
           * Removes `key` and its value from the map.
           *
           * @private
           * @name delete
           * @memberOf MapCache
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function mapCacheDelete(key) {
            return getMapData(this, key)['delete'](key);
          }

          /**
           * Gets the map value for `key`.
           *
           * @private
           * @name get
           * @memberOf MapCache
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }

          /**
           * Checks if a map value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf MapCache
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }

          /**
           * Sets the map `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf MapCache
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the map cache instance.
           */
          function mapCacheSet(key, value) {
            getMapData(this, key).set(key, value);
            return this;
          }

          // Add methods to `MapCache`.
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype['delete'] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;

          /**
           * Creates a stack cache object to store key-value pairs.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function Stack(entries) {
            this.__data__ = new ListCache(entries);
          }

          /**
           * Removes all key-value entries from the stack.
           *
           * @private
           * @name clear
           * @memberOf Stack
           */
          function stackClear() {
            this.__data__ = new ListCache();
          }

          /**
           * Removes `key` and its value from the stack.
           *
           * @private
           * @name delete
           * @memberOf Stack
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function stackDelete(key) {
            return this.__data__['delete'](key);
          }

          /**
           * Gets the stack value for `key`.
           *
           * @private
           * @name get
           * @memberOf Stack
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function stackGet(key) {
            return this.__data__.get(key);
          }

          /**
           * Checks if a stack value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf Stack
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function stackHas(key) {
            return this.__data__.has(key);
          }

          /**
           * Sets the stack `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf Stack
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the stack cache instance.
           */
          function stackSet(key, value) {
            var cache = this.__data__;
            if (cache instanceof ListCache) {
              var pairs = cache.__data__;
              if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                return this;
              }
              cache = this.__data__ = new MapCache(pairs);
            }
            cache.set(key, value);
            return this;
          }

          // Add methods to `Stack`.
          Stack.prototype.clear = stackClear;
          Stack.prototype['delete'] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;

          /**
           * Creates an array of the enumerable property names of the array-like `value`.
           *
           * @private
           * @param {*} value The value to query.
           * @param {boolean} inherited Specify returning inherited property names.
           * @returns {Array} Returns the array of property names.
           */
          function arrayLikeKeys(value, inherited) {
            // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
            // Safari 9 makes `arguments.length` enumerable in strict mode.
            var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
            var length = result.length,
              skipIndexes = !!length;
            for (var key in value) {
              if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
                result.push(key);
              }
            }
            return result;
          }

          /**
           * Assigns `value` to `key` of `object` if the existing value is not equivalent
           * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {string} key The key of the property to assign.
           * @param {*} value The value to assign.
           */
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
              object[key] = value;
            }
          }

          /**
           * Gets the index at which the `key` is found in `array` of key-value pairs.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {*} key The key to search for.
           * @returns {number} Returns the index of the matched value, else `-1`.
           */
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }

          /**
           * The base implementation of `_.assign` without support for multiple sources
           * or `customizer` functions.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @returns {Object} Returns `object`.
           */
          function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
          }

          /**
           * The base implementation of `_.clone` and `_.cloneDeep` which tracks
           * traversed objects.
           *
           * @private
           * @param {*} value The value to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @param {boolean} [isFull] Specify a clone including symbols.
           * @param {Function} [customizer] The function to customize cloning.
           * @param {string} [key] The key of `value`.
           * @param {Object} [object] The parent object of `value`.
           * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
           * @returns {*} Returns the cloned value.
           */
          function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
            var result;
            if (customizer) {
              result = object ? customizer(value, key, object, stack) : customizer(value);
            }
            if (result !== undefined) {
              return result;
            }
            if (!isObject(value)) {
              return value;
            }
            var isArr = isArray(value);
            if (isArr) {
              result = initCloneArray(value);
              if (!isDeep) {
                return copyArray(value, result);
              }
            } else {
              var tag = getTag(value),
                isFunc = tag == funcTag || tag == genTag;
              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
              }
              if (tag == objectTag || tag == argsTag || isFunc && !object) {
                if (isHostObject(value)) {
                  return object ? value : {};
                }
                result = initCloneObject(isFunc ? {} : value);
                if (!isDeep) {
                  return copySymbols(value, baseAssign(result, value));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object ? value : {};
                }
                result = initCloneByTag(value, tag, baseClone, isDeep);
              }
            }
            // Check for circular references and return its corresponding clone.
            stack || (stack = new Stack());
            var stacked = stack.get(value);
            if (stacked) {
              return stacked;
            }
            stack.set(value, result);
            if (!isArr) {
              var props = isFull ? getAllKeys(value) : keys(value);
            }
            arrayEach(props || value, function (subValue, key) {
              if (props) {
                key = subValue;
                subValue = value[key];
              }
              // Recursively populate clone (susceptible to call stack limits).
              assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
            });
            return result;
          }

          /**
           * The base implementation of `_.create` without support for assigning
           * properties to the created object.
           *
           * @private
           * @param {Object} prototype The object to inherit from.
           * @returns {Object} Returns the new object.
           */
          function baseCreate(proto) {
            return isObject(proto) ? objectCreate(proto) : {};
          }

          /**
           * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
           * `keysFunc` and `symbolsFunc` to get the enumerable property names and
           * symbols of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Function} keysFunc The function to get the keys of `object`.
           * @param {Function} symbolsFunc The function to get the symbols of `object`.
           * @returns {Array} Returns the array of property names and symbols.
           */
          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result = keysFunc(object);
            return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
          }

          /**
           * The base implementation of `getTag`.
           *
           * @private
           * @param {*} value The value to query.
           * @returns {string} Returns the `toStringTag`.
           */
          function baseGetTag(value) {
            return objectToString.call(value);
          }

          /**
           * The base implementation of `_.isNative` without bad shim checks.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a native function,
           *  else `false`.
           */
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }

          /**
           * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           */
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }
            var result = [];
            for (var key in Object(object)) {
              if (hasOwnProperty.call(object, key) && key != 'constructor') {
                result.push(key);
              }
            }
            return result;
          }

          /**
           * Creates a clone of  `buffer`.
           *
           * @private
           * @param {Buffer} buffer The buffer to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Buffer} Returns the cloned buffer.
           */
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }
            var result = new buffer.constructor(buffer.length);
            buffer.copy(result);
            return result;
          }

          /**
           * Creates a clone of `arrayBuffer`.
           *
           * @private
           * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
           * @returns {ArrayBuffer} Returns the cloned array buffer.
           */
          function cloneArrayBuffer(arrayBuffer) {
            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array(result).set(new Uint8Array(arrayBuffer));
            return result;
          }

          /**
           * Creates a clone of `dataView`.
           *
           * @private
           * @param {Object} dataView The data view to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Object} Returns the cloned data view.
           */
          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
          }

          /**
           * Creates a clone of `map`.
           *
           * @private
           * @param {Object} map The map to clone.
           * @param {Function} cloneFunc The function to clone values.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Object} Returns the cloned map.
           */
          function cloneMap(map, isDeep, cloneFunc) {
            var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
            return arrayReduce(array, addMapEntry, new map.constructor());
          }

          /**
           * Creates a clone of `regexp`.
           *
           * @private
           * @param {Object} regexp The regexp to clone.
           * @returns {Object} Returns the cloned regexp.
           */
          function cloneRegExp(regexp) {
            var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result.lastIndex = regexp.lastIndex;
            return result;
          }

          /**
           * Creates a clone of `set`.
           *
           * @private
           * @param {Object} set The set to clone.
           * @param {Function} cloneFunc The function to clone values.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Object} Returns the cloned set.
           */
          function cloneSet(set, isDeep, cloneFunc) {
            var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
            return arrayReduce(array, addSetEntry, new set.constructor());
          }

          /**
           * Creates a clone of the `symbol` object.
           *
           * @private
           * @param {Object} symbol The symbol object to clone.
           * @returns {Object} Returns the cloned symbol object.
           */
          function cloneSymbol(symbol) {
            return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
          }

          /**
           * Creates a clone of `typedArray`.
           *
           * @private
           * @param {Object} typedArray The typed array to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Object} Returns the cloned typed array.
           */
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }

          /**
           * Copies the values of `source` to `array`.
           *
           * @private
           * @param {Array} source The array to copy values from.
           * @param {Array} [array=[]] The array to copy values to.
           * @returns {Array} Returns `array`.
           */
          function copyArray(source, array) {
            var index = -1,
              length = source.length;
            array || (array = Array(length));
            while (++index < length) {
              array[index] = source[index];
            }
            return array;
          }

          /**
           * Copies properties of `source` to `object`.
           *
           * @private
           * @param {Object} source The object to copy properties from.
           * @param {Array} props The property identifiers to copy.
           * @param {Object} [object={}] The object to copy properties to.
           * @param {Function} [customizer] The function to customize copied values.
           * @returns {Object} Returns `object`.
           */
          function copyObject(source, props, object, customizer) {
            object || (object = {});
            var index = -1,
              length = props.length;
            while (++index < length) {
              var key = props[index];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
              assignValue(object, key, newValue === undefined ? source[key] : newValue);
            }
            return object;
          }

          /**
           * Copies own symbol properties of `source` to `object`.
           *
           * @private
           * @param {Object} source The object to copy symbols from.
           * @param {Object} [object={}] The object to copy symbols to.
           * @returns {Object} Returns `object`.
           */
          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
          }

          /**
           * Creates an array of own enumerable property names and symbols of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names and symbols.
           */
          function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
          }

          /**
           * Gets the data for `map`.
           *
           * @private
           * @param {Object} map The map to query.
           * @param {string} key The reference key.
           * @returns {*} Returns the map data.
           */
          function getMapData(map, key) {
            var data = map.__data__;
            return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
          }

          /**
           * Gets the native function at `key` of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {string} key The key of the method to get.
           * @returns {*} Returns the function if it's native, else `undefined`.
           */
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined;
          }

          /**
           * Creates an array of the own enumerable symbol properties of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of symbols.
           */
          var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

          /**
           * Gets the `toStringTag` of `value`.
           *
           * @private
           * @param {*} value The value to query.
           * @returns {string} Returns the `toStringTag`.
           */
          var getTag = baseGetTag;

          // Fallback for data views, maps, sets, and weak maps in IE 11,
          // for data views in Edge < 14, and promises in Node.js.
          if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
            getTag = function (value) {
              var result = objectToString.call(value),
                Ctor = result == objectTag ? value.constructor : undefined,
                ctorString = Ctor ? toSource(Ctor) : undefined;
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;
                  case mapCtorString:
                    return mapTag;
                  case promiseCtorString:
                    return promiseTag;
                  case setCtorString:
                    return setTag;
                  case weakMapCtorString:
                    return weakMapTag;
                }
              }
              return result;
            };
          }

          /**
           * Initializes an array clone.
           *
           * @private
           * @param {Array} array The array to clone.
           * @returns {Array} Returns the initialized clone.
           */
          function initCloneArray(array) {
            var length = array.length,
              result = array.constructor(length);

            // Add properties assigned by `RegExp#exec`.
            if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
              result.index = array.index;
              result.input = array.input;
            }
            return result;
          }

          /**
           * Initializes an object clone.
           *
           * @private
           * @param {Object} object The object to clone.
           * @returns {Object} Returns the initialized clone.
           */
          function initCloneObject(object) {
            return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
          }

          /**
           * Initializes an object clone based on its `toStringTag`.
           *
           * **Note:** This function only supports cloning values with tags of
           * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
           *
           * @private
           * @param {Object} object The object to clone.
           * @param {string} tag The `toStringTag` of the object to clone.
           * @param {Function} cloneFunc The function to clone values.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Object} Returns the initialized clone.
           */
          function initCloneByTag(object, tag, cloneFunc, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);
              case boolTag:
              case dateTag:
                return new Ctor(+object);
              case dataViewTag:
                return cloneDataView(object, isDeep);
              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep);
              case mapTag:
                return cloneMap(object, isDeep, cloneFunc);
              case numberTag:
              case stringTag:
                return new Ctor(object);
              case regexpTag:
                return cloneRegExp(object);
              case setTag:
                return cloneSet(object, isDeep, cloneFunc);
              case symbolTag:
                return cloneSymbol(object);
            }
          }

          /**
           * Checks if `value` is a valid array-like index.
           *
           * @private
           * @param {*} value The value to check.
           * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
           * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
           */
          function isIndex(value, length) {
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
          }

          /**
           * Checks if `value` is suitable for use as unique object key.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
           */
          function isKeyable(value) {
            var type = typeof value;
            return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
          }

          /**
           * Checks if `func` has its source masked.
           *
           * @private
           * @param {Function} func The function to check.
           * @returns {boolean} Returns `true` if `func` is masked, else `false`.
           */
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }

          /**
           * Checks if `value` is likely a prototype object.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
           */
          function isPrototype(value) {
            var Ctor = value && value.constructor,
              proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
            return value === proto;
          }

          /**
           * Converts `func` to its source code.
           *
           * @private
           * @param {Function} func The function to process.
           * @returns {string} Returns the source code.
           */
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {}
              try {
                return func + '';
              } catch (e) {}
            }
            return '';
          }

          /**
           * This method is like `_.clone` except that it recursively clones `value`.
           *
           * @static
           * @memberOf _
           * @since 1.0.0
           * @category Lang
           * @param {*} value The value to recursively clone.
           * @returns {*} Returns the deep cloned value.
           * @see _.clone
           * @example
           *
           * var objects = [{ 'a': 1 }, { 'b': 2 }];
           *
           * var deep = _.cloneDeep(objects);
           * console.log(deep[0] === objects[0]);
           * // => false
           */
          function cloneDeep(value) {
            return baseClone(value, true, true);
          }

          /**
           * Performs a
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * comparison between two values to determine if they are equivalent.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           * @example
           *
           * var object = { 'a': 1 };
           * var other = { 'a': 1 };
           *
           * _.eq(object, object);
           * // => true
           *
           * _.eq(object, other);
           * // => false
           *
           * _.eq('a', 'a');
           * // => true
           *
           * _.eq('a', Object('a'));
           * // => false
           *
           * _.eq(NaN, NaN);
           * // => true
           */
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }

          /**
           * Checks if `value` is likely an `arguments` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an `arguments` object,
           *  else `false`.
           * @example
           *
           * _.isArguments(function() { return arguments; }());
           * // => true
           *
           * _.isArguments([1, 2, 3]);
           * // => false
           */
          function isArguments(value) {
            // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
            return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
          }

          /**
           * Checks if `value` is classified as an `Array` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an array, else `false`.
           * @example
           *
           * _.isArray([1, 2, 3]);
           * // => true
           *
           * _.isArray(document.body.children);
           * // => false
           *
           * _.isArray('abc');
           * // => false
           *
           * _.isArray(_.noop);
           * // => false
           */
          var isArray = Array.isArray;

          /**
           * Checks if `value` is array-like. A value is considered array-like if it's
           * not a function and has a `value.length` that's an integer greater than or
           * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
           * @example
           *
           * _.isArrayLike([1, 2, 3]);
           * // => true
           *
           * _.isArrayLike(document.body.children);
           * // => true
           *
           * _.isArrayLike('abc');
           * // => true
           *
           * _.isArrayLike(_.noop);
           * // => false
           */
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
          }

          /**
           * This method is like `_.isArrayLike` except that it also checks if `value`
           * is an object.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an array-like object,
           *  else `false`.
           * @example
           *
           * _.isArrayLikeObject([1, 2, 3]);
           * // => true
           *
           * _.isArrayLikeObject(document.body.children);
           * // => true
           *
           * _.isArrayLikeObject('abc');
           * // => false
           *
           * _.isArrayLikeObject(_.noop);
           * // => false
           */
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }

          /**
           * Checks if `value` is a buffer.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
           * @example
           *
           * _.isBuffer(new Buffer(2));
           * // => true
           *
           * _.isBuffer(new Uint8Array(2));
           * // => false
           */
          var isBuffer = nativeIsBuffer || stubFalse;

          /**
           * Checks if `value` is classified as a `Function` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a function, else `false`.
           * @example
           *
           * _.isFunction(_);
           * // => true
           *
           * _.isFunction(/abc/);
           * // => false
           */
          function isFunction(value) {
            // The use of `Object#toString` avoids issues with the `typeof` operator
            // in Safari 8-9 which returns 'object' for typed array and other constructors.
            var tag = isObject(value) ? objectToString.call(value) : '';
            return tag == funcTag || tag == genTag;
          }

          /**
           * Checks if `value` is a valid array-like length.
           *
           * **Note:** This method is loosely based on
           * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
           * @example
           *
           * _.isLength(3);
           * // => true
           *
           * _.isLength(Number.MIN_VALUE);
           * // => false
           *
           * _.isLength(Infinity);
           * // => false
           *
           * _.isLength('3');
           * // => false
           */
          function isLength(value) {
            return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }

          /**
           * Checks if `value` is the
           * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
           * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an object, else `false`.
           * @example
           *
           * _.isObject({});
           * // => true
           *
           * _.isObject([1, 2, 3]);
           * // => true
           *
           * _.isObject(_.noop);
           * // => true
           *
           * _.isObject(null);
           * // => false
           */
          function isObject(value) {
            var type = typeof value;
            return !!value && (type == 'object' || type == 'function');
          }

          /**
           * Checks if `value` is object-like. A value is object-like if it's not `null`
           * and has a `typeof` result of "object".
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
           * @example
           *
           * _.isObjectLike({});
           * // => true
           *
           * _.isObjectLike([1, 2, 3]);
           * // => true
           *
           * _.isObjectLike(_.noop);
           * // => false
           *
           * _.isObjectLike(null);
           * // => false
           */
          function isObjectLike(value) {
            return !!value && typeof value == 'object';
          }

          /**
           * Creates an array of the own enumerable property names of `object`.
           *
           * **Note:** Non-object values are coerced to objects. See the
           * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
           * for more details.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.keys(new Foo);
           * // => ['a', 'b'] (iteration order is not guaranteed)
           *
           * _.keys('hi');
           * // => ['0', '1']
           */
          function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }

          /**
           * This method returns a new empty array.
           *
           * @static
           * @memberOf _
           * @since 4.13.0
           * @category Util
           * @returns {Array} Returns the new empty array.
           * @example
           *
           * var arrays = _.times(2, _.stubArray);
           *
           * console.log(arrays);
           * // => [[], []]
           *
           * console.log(arrays[0] === arrays[1]);
           * // => false
           */
          function stubArray() {
            return [];
          }

          /**
           * This method returns `false`.
           *
           * @static
           * @memberOf _
           * @since 4.13.0
           * @category Util
           * @returns {boolean} Returns `false`.
           * @example
           *
           * _.times(2, _.stubFalse);
           * // => [false, false]
           */
          function stubFalse() {
            return false;
          }
          module.exports = cloneDeep;
        })(lodash_clonedeep, lodash_clonedeep.exports);
        var lodash_clonedeepExports = lodash_clonedeep.exports;
        const fileTypesToMimesArray = exports('a7', fileTypes => {
          let accepted = [];
          fileTypes === null || fileTypes === void 0 ? void 0 : fileTypes.forEach(el => {
            accepted = accepted.concat(acceptedFileTypes(el));
          });
          return accepted;
        });
        const acceptedFileTypes = fileType => {
          switch (fileType) {
            case "presentation":
              return ["application/mspowerpoint", "application/vnd.google-apps.presentation", "application/vnd.ms-powerpoint", "application/vnd.ms-powerpoint.presentation.macroEnabled.12", "application/vnd.ms-powerpoint.presentation.macroenabled.12", "application/vnd.ms-powerpoint.slideshow.macroEnabled.12", "application/vnd.ms-powerpoint.slideshow.macroenabled.12", "application/vnd.ms-powerpoint.template.macroEnabled.12", "application/vnd.ms-powerpoint.template.macroenabled.12", "application/vnd.oasis.opendocument.presentation", "application/vnd.openxmlformats-officedocument.presentationml.presentation", "application/vnd.openxmlformats-officedocument.presentationml.slideshow", "application/vnd.openxmlformats-officedocument.presentationml.template"];
            case "document":
              return ["application/vnd.google-apps.document", "application/vnd.ms-word", "application/vnd.ms-word.document.macroEnabled.12", "application/vnd.ms-word.document.macroenabled.12", "application/vnd.ms-word.template.macroEnabled.12", "application/vnd.ms-word.template.macroenabled.12", "application/vnd.oasis.opendocument.text", "application/vnd.openxmlformats-officedocument.wordprocessingml.document", "application/vnd.openxmlformats-officedocument.wordprocessingml.template", "text/plain", "application/msword"];
            case "spreadsheet":
              return ["application/msexcel", "application/vnd.google-apps.spreadsheet", "application/vnd.ms-excel", "application/vnd.ms-excel.sheet.macroEnabled.12", "application/vnd.ms-excel.sheet.macroenabled.12", "application/vnd.ms-excel.template.macroEnabled.12", "application/vnd.ms-excel.template.macroenabled.12", "application/vnd.oasis.opendocument.spreadsheet", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "application/vnd.openxmlformats-officedocument.spreadsheetml.template", "text/csv"];
            case "pdf":
              return ["application/pdf"];
            case "image":
              return ["image/bmp", "image/gif", "image/heic", "image/heif", "image/jpeg", "image/png", "image/tiff", "image/vnd.microsoft.icon", "image/webp", "image/x-ms-bmp"];
            case "video":
              return ["application/vnd.google-apps.video", "video/3gpp", "video/3gpp2", "video/avi", "video/flv", "video/mp2t", "video/mp4", "video/mp4v-es", "video/mpeg", "video/ogg", "video/quicktime", "video/vnd.mts", "video/webm", "video/x-flv", "video/x-m4v", "video/x-matroska", "video/x-ms-asf", "video/x-ms-wm", "video/x-ms-wmv", "video/x-ms-wvx", "video/x-msvideo", "video/x-quicktime"];
            case "audio":
              return ["application/vnd.google-apps.audio", "audio/mpeg", "audio/mp3", "audio/mp4", "audio/midi", "audio/x-mid", "audio/x-midi", "audio/wav", "audio/x-wav", "audio/vnd.wav", "audio/flac", "audio/ogg", "audio/vorbis"];
          }
        };
        const jsonToJs = (json, nested, getComponentType) => {
          const key = Object.keys(json)[0];
          const value = json[key];
          switch (key) {
            case "and":
              return wrapIfNested(nested, value.map(el => jsonToJs(el, true, getComponentType)).join(" && "));
            case "or":
              return wrapIfNested(nested, value.map(el => jsonToJs(el, true, getComponentType)).join(" || "));
            case "!":
              return "!" + wrapIfNested(nested, jsonToJs(value, true, getComponentType) + (nested ? ")" : ""));
            case "relevance":
              return `${capture(value)}.relevance`;
            case "not_relevance":
              return `!${capture(value)}.relevance`;
            case "is_online":
              return `Survey.mode=="online"`;
            case "is_offline":
              return `Survey.mode=="offline"`;
            case "validity":
              return `${capture(value)}.validity`;
            case "not_validity":
              return `!${capture(value)}.validity`;
            case "is_void":
              return `FrankieScripts.isVoid(${capture(value)}.value)`;
            case "is_not_void":
              return `FrankieScripts.isNotVoid(${capture(value)}.value)`;
            case "is_file_void":
              let qCode = capture(value);
              return wrapIfNested(nested, `FrankieScripts.isVoid(${qCode}.value) || !${qCode}.value.size || !${qCode}.value.stored_filename`);
            case "is_file_not_void":
              let qCode1 = capture(value);
              return wrapIfNested(nested, `FrankieScripts.isNotVoid(${qCode1}.value) && ${qCode1}.value.size && ${qCode1}.value.stored_filename`);
            case "==":
            case "!=":
            case "<":
            case "<=":
            case ">":
            case ">=":
            case "between":
            case "not_between":
              let type = getComponentType(capture(value[0]));
              let leftOperand = type == "date" || type == "date_time" || type == "time" ? `FrankieScripts.sqlDateTimeToDate(${capture(value[0])}.value)` : `${capture(value[0])}.value`;
              if (["==", "!=", "<", "<=", ">", ">="].includes(key)) {
                return `${leftOperand}${key}${capture(value[1], type)}`;
              } else if (key == "between") {
                return wrapIfNested(nested, `(${leftOperand}>=${capture(value[1], type)} && ${leftOperand}<=${capture(value[2], type)})`);
              } else if (key == "not_between") {
                return wrapIfNested(nested, `(${leftOperand}<${capture(value[1], type)} || ${leftOperand}>${capture(value[2], type)})`);
              } else {
                throw "WTF";
              }
            case "startsWith":
              return wrapIfNested(nested, `(${capture(value[0])}.value && ${capture(value[0])}.value.startsWith(${capture(value[1])})`);
            case "endsWith":
              return wrapIfNested(nested, `(${capture(value[0])}.value && ${capture(value[0])}.value.endsWith(${capture(value[1])})`);
            case "contains":
              return wrapIfNested(nested, `(${capture(value[0])}.value && ${capture(value[0])}.value.contains(${capture(value[1])})`);
            case "not_contains":
              return wrapIfNested(nested, `(${capture(value[0])}.value && !${capture(value[0])}.value.contains(${capture(value[1])})`);
            case "in":
              const code = capture(value[0]);
              if (code == "survey_lang") {
                return `[${value[1].map(el => '"' + el + '"')}].indexOf(Survey.lang) !== -1`;
              }
              return `[${value[1].map(el => '"' + el + '"')}].indexOf(${code}.value) !== -1`;
            case "not_in":
              if (code == "survey_lang") {
                return `[${value[1].map(el => '"' + el + '"')}].indexOf(Survey.lang) == -1`;
              }
              return `[${value[1].map(el => '"' + el + '"')}].indexOf(${code}.value) == -1`;
            case "any_in":
              const questionCode = capture(value[0]);
              return `[${value[1].map(el => questionCode + el + ".value")}].filter(Boolean).length > 0`;
            case "none_in":
              const questionCode1 = capture(value[0]);
              return `[${value[1].map(el => questionCode1 + el + ".value")}].filter(Boolean).length == 0`;
            default:
              return "";
          }
        };
        const wrapIfNested = (nested, text) => {
          return (nested ? "(" : "") + text + (nested ? ")" : "");
        };
        const capture = (value, type) => {
          if (type == "time") {
            return `FrankieScripts.sqlDateTimeToDate(\"1970-01-01 ${integerToTime(value)}\")`;
          } else if (typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]") {
            return type == "date_time" ? `FrankieScripts.sqlDateTimeToDate(\"${toSqlDateTime(value)}\")` : `FrankieScripts.sqlDateTimeToDate(\"${toSqlDateTimeIgnoreTime(value)}\")`;
          }
          if (typeof value === "object") {
            return value[Object.keys(value)[0]];
          } else if (typeof value === "string") {
            return '"' + value + '"';
          } else {
            return value;
          }
        };
        const integerToTime = time => {
          let hours = Math.floor(time / 3600);
          let hoursString = hours >= 10 && hours <= 23 ? "" + hours : "0" + hours;
          let minutes = time % 3600 / 60;
          let minutesString = minutes >= 10 && minutes <= 59 ? "" + minutes : "0" + minutes;
          return hoursString + ":" + minutesString + ":00";
        };
        const toSqlDateTime = date => {
          return date.getFullYear() + "-" + ("00" + (date.getMonth() + 1)).slice(-2) + "-" + ("00" + date.getDate()).slice(-2) + " " + ("00" + date.getHours()).slice(-2) + ":" + ("00" + date.getMinutes()).slice(-2) + ":" + ("00" + date.getSeconds()).slice(-2);
        };
        const toSqlDateTimeIgnoreTime = date => {
          return date.getFullYear() + "-" + ("00" + (date.getMonth() + 1)).slice(-2) + "-" + ("00" + date.getDate()).slice(-2) + " 00:00:00";
        };
        const questionDesignError = question => {
          let errors = [];
          switch (question.type) {
            case "scq_array":
              if (!question.children || question.children.filter(child => child.type == "row").length === 0) {
                errors.push({
                  code: "insufficient_rows_min_1",
                  message: "must have at least 1 row"
                });
              }
              if (!question.children || question.children.filter(child => child.type == "column").length < 2) {
                errors.push({
                  code: "insufficient_cols_min_2",
                  message: "must have at least 2 columns"
                });
              }
              break;
            case "image_ranking":
            case "ranking":
            case "image_scq":
            case "scq":
              if (!question.children || question.children.length < 2) {
                errors.push({
                  code: "insufficient_options_min_2",
                  message: "must have at least 2 options"
                });
              }
              break;
            case "image_mcq":
            case "mcq":
              if (!question.children || question.children.length < 1) {
                errors.push({
                  code: "insufficient_options_min_1",
                  message: "must have at least 1 option"
                });
              }
              break;
          }
          return errors;
        };
        const validationEquation = (qualifiedCode, component, key, validation) => {
          if (!validation.isActive || key == "validation_not_contains" && !validation.not_contains) {
            return {
              code: key,
              remove: true
            };
          }
          let instructionText = "";
          switch (key) {
            case "validation_required":
              instructionText = requiredText(qualifiedCode, component);
              return booleanActiveInstruction(key, instructionText);
            case "validation_min_char_length":
              instructionText = `FrankieScripts.isNotVoid(${qualifiedCode}.value) ` + `&& ${qualifiedCode}.value.length < ${validation.min_length || 0}`;
              return booleanActiveInstruction(key, instructionText);
            case "validation_max_char_length":
              instructionText = `FrankieScripts.isNotVoid(${qualifiedCode}.value) ` + `&& ${qualifiedCode}.value.length > ${validation.max_length || 0}`;
              return booleanActiveInstruction(key, instructionText);
            case "validation_contains":
              instructionText = `FrankieScripts.isNotVoid(${qualifiedCode}.value) ` + `&& !${qualifiedCode}.value.includes("${validation.contains || ""}")`;
              return booleanActiveInstruction(key, instructionText);
            case "validation_not_contains":
              instructionText = `FrankieScripts.isNotVoid(${qualifiedCode}.value) ` + `&& ${qualifiedCode}.value.includes("${validation.not_contains}")`;
            case "validation_file_types":
              const mimes = fileTypesToMimesArray(validation.fileTypes);
              instructionText = `FrankieScripts.isNotVoid(${qualifiedCode}.value) ` + `&& ![${mimes.map(el => '"' + el + '"').join(",")}].includes(${qualifiedCode}.value.type)`;
              return booleanActiveInstruction(key, instructionText);
            case "validation_max_file_size":
              instructionText = `FrankieScripts.isNotVoid(${qualifiedCode}.value) ` + `&& ${qualifiedCode}.value.size > ${validation.max_size}`;
              return booleanActiveInstruction(key, instructionText);
            case "validation_pattern":
              if (!isValidRegex(validation.pattern)) {
                return {
                  code: key,
                  remove: true
                };
              }
              instructionText = `FrankieScripts.isNotVoid(${qualifiedCode}.value) ` + `&& !RegExp("${validation.pattern}").test(${qualifiedCode}.value)`;
              return booleanActiveInstruction(key, instructionText);
            case "validation_pattern_email":
              instructionText = `FrankieScripts.isNotVoid(${qualifiedCode}.value) ` + `&&  !/^\\w+@[a-zA-Z_]+?\\.[a-zA-Z]{2,3}$/.test(${qualifiedCode}.value)`;
              return booleanActiveInstruction(key, instructionText);
            case "validation_max_word_count":
              instructionText = `FrankieScripts.isNotVoid(${qualifiedCode}.value) ` + `&&  FrankieScripts.wordCount(${qualifiedCode}.value) > ${validation.max_count || 0}`;
              return booleanActiveInstruction(key, instructionText);
            case "validation_min_word_count":
              instructionText = `FrankieScripts.isNotVoid(${qualifiedCode}.value) ` + `&&  FrankieScripts.wordCount(${qualifiedCode}.value) < ${validation.min_count || 0}`;
              return booleanActiveInstruction(key, instructionText);
            case "validation_between":
              instructionText = `FrankieScripts.isNotVoid(${qualifiedCode}.value) ` + `&& (${qualifiedCode}.value < ${validation.lower_limit || 0} ` + `|| ${qualifiedCode}.value > ${validation.upper_limit || 0})`;
              return booleanActiveInstruction(key, instructionText);
            case "validation_not_between":
              instructionText = `FrankieScripts.isNotVoid(${qualifiedCode}.value) ` + `&& (${qualifiedCode}.value >= ${validation.lower_limit || 0} ` + `&& ${qualifiedCode}.value <= ${validation.upper_limit || 0})`;
              return booleanActiveInstruction(key, instructionText);
            case "validation_lt":
              instructionText = `FrankieScripts.isNotVoid(${qualifiedCode}.value) ` + `&& ${qualifiedCode}.value >= ${validation.number || 0}`;
              return booleanActiveInstruction(key, instructionText);
            case "validation_lte":
              instructionText = `FrankieScripts.isNotVoid(${qualifiedCode}.value) ` + `&& ${qualifiedCode}.value > ${validation.number || 0}`;
              return booleanActiveInstruction(key, instructionText);
            case "validation_gt":
              instructionText = `FrankieScripts.isNotVoid(${qualifiedCode}.value) ` + `&& ${qualifiedCode}.value <= ${validation.number || 0}`;
              return booleanActiveInstruction(key, instructionText);
            case "validation_gte":
              instructionText = `FrankieScripts.isNotVoid(${qualifiedCode}.value) ` + `&& ${qualifiedCode}.value < ${validation.number || 0}`;
              return booleanActiveInstruction(key, instructionText);
            case "validation_equals":
              instructionText = `FrankieScripts.isVoid(${qualifiedCode}.value) ` + `&& ${qualifiedCode}.value != ${validation.number || 0}`;
              return booleanActiveInstruction(key, instructionText);
            case "validation_not_equal":
              instructionText = `FrankieScripts.isVoid(${qualifiedCode}.value) ` + `&& ${qualifiedCode}.value == ${validation.number || 0}`;
              return booleanActiveInstruction(key, instructionText);
            case "validation_min_option_count":
              instructionText = `[${component.children.map(answer => answer.qualifiedCode + ".value")}].filter(Boolean).length ` + `< ${validation.min_count || 0}`;
              return booleanActiveInstruction(key, instructionText);
            case "validation_max_option_count":
              instructionText = `[${component.children.map(answer => answer.qualifiedCode + ".value")}].filter(Boolean).length ` + `> ${validation.max_count || 0}`;
              return booleanActiveInstruction(key, instructionText);
            case "validation_option_count":
              instructionText = `[${component.children.map(answer => answer.qualifiedCode + ".value")}].filter(Boolean).length ` + `!== ${validation.count || 0}`;
              return booleanActiveInstruction(key, instructionText);
            case "validation_min_ranking_count":
              instructionText = `[${component.children.map(answer => answer.qualifiedCode + ".value")}].filter(Boolean).length ` + `< ${validation.min_count || 0}`;
              return booleanActiveInstruction(key, instructionText);
            case "validation_max_ranking_count":
              instructionText = `[${component.children.map(answer => answer.qualifiedCode + ".value")}].filter(Boolean).length ` + `> ${validation.max_count || 0}`;
              return booleanActiveInstruction(key, instructionText);
            case "validation_ranking_count":
              instructionText = `[${component.children.map(answer => answer.qualifiedCode + ".value")}].filter(Boolean).length ` + `!== ${validation.count || 0}`;
              return booleanActiveInstruction(key, instructionText);
          }
        };
        const booleanActiveInstruction = (key, instructionText) => {
          return {
            code: key,
            text: instructionText,
            isActive: true,
            returnType: {
              name: "Boolean"
            }
          };
        };
        const requiredText = (qualifiedCode, component) => {
          if (component.type == "file_upload" || component.type == "signature" || component.type == "photo_capture" || component.type == "video_capture") {
            return `FrankieScripts.isVoid(${qualifiedCode}.value) || !${qualifiedCode}.value.size || !${qualifiedCode}.value.stored_filename`;
          } else if (component.type == "scq_array") {
            const rows = component.children.filter(child => child.type == "row");
            return `[${rows.map(answer => answer.qualifiedCode + ".value")}].filter(Boolean).length ` + ` < ` + rows.length;
          } else {
            return `FrankieScripts.isVoid(${qualifiedCode}.value)`;
          }
        };
        const isValidRegex = regex => {
          if (!regex) {
            return false;
          }
          try {
            new RegExp(regex);
          } catch (e) {
            return false;
          }
          return true;
        };
        const cleanupValidationData = (component, key, validation) => {
          switch (key) {
            case "validation_required":
            case "validation_pattern_email":
            case "validation_contains":
            case "validation_not_contains":
            case "validation_pattern":
            case "validation_max_word_count":
            case "validation_min_word_count":
            case "validation_between":
            case "validation_not_between":
            case "validation_lt":
            case "validation_lte":
            case "validation_gt":
            case "validation_gte":
            case "validation_equals":
            case "validation_not_equal":
              return validation;
            case "validation_min_char_length":
              return {
                ...validation,
                min_length: Math.min(component.maxChars || 30, validation.min_length)
              };
            case "validation_max_char_length":
              return {
                ...validation,
                max_length: Math.max(component.maxChars || 30, validation.max_length)
              };
            case "validation_min_ranking_count":
            case "validation_min_option_count":
              return {
                ...validation,
                min_count: Math.min(component.children.length, validation.min_count)
              };
            case "validation_max_ranking_count":
            case "validation_max_option_count":
              return {
                ...validation,
                max_count: Math.min(component.children.length, validation.max_count)
              };
            case "validation_ranking_count":
            case "validation_option_count":
              return {
                ...validation,
                count: Math.min(component.children.length, validation.count)
              };
            default:
              return validation;
          }
        };
        const buildValidationDefaultData = rule => {
          switch (rule) {
            case "validation_required":
            case "validation_pattern_email":
              return {};
            case "validation_min_char_length":
              return {
                min_length: 2
              };
            case "validation_max_char_length":
              return {
                max_length: 30
              };
            case "validation_contains":
              return {
                contains: ""
              };
            case "validation_not_contains":
              return {
                not_contains: ""
              };
            case "validation_pattern":
              return {
                pattern: ""
              };
            case "validation_max_word_count":
              return {
                max_count: 300
              };
            case "validation_min_word_count":
              return {
                min_count: 300
              };
            case "validation_between":
              return {
                lower_limit: 20,
                upper_limit: 100
              };
            case "validation_not_between":
              return {
                lower_limit: 20,
                upper_limit: 100
              };
            case "validation_lt":
              return {
                number: 20
              };
            case "validation_lte":
              return {
                number: 20
              };
            case "validation_gt":
              return {
                number: 20
              };
            case "validation_gte":
              return {
                number: 20
              };
            case "validation_equals":
              return {
                number: 20
              };
            case "validation_not_equal":
              return {
                number: 20
              };
            case "validation_min_ranking_count":
            case "validation_min_option_count":
              return {
                min_count: 1
              };
            case "validation_max_ranking_count":
            case "validation_max_option_count":
              return {
                max_count: 1
              };
            case "validation_ranking_count":
            case "validation_option_count":
              return {
                count: 1
              };
            case "validation_file_types":
              return {
                fileTypes: ["image"]
              };
            case "validation_max_file_size":
              return {
                max_size: 250
              };
            default:
              throw "unrecognized rule " + rule;
          }
        };
        const scqSkipEquations = (qualifiedCode, component, skipLogic) => {
          const instructionList = [];
          component.children.forEach(el => {
            const key = el.code;
            const skipObj = skipLogic[key];
            const instructionCode = "skip_to_on_" + key;
            if (!skipObj || !skipObj.skipTo || skipObj.skipTo == "proceed") {
              instructionList.push({
                code: instructionCode,
                remove: true
              });
            } else {
              component.instructionList.find(el => el.code == instructionCode);
              const instruction = {
                code: instructionCode,
                condition: qualifiedCode + '.value == "' + key + '"',
                isActive: true,
                toEnd: skipObj.toEnd || false,
                skipToComponent: skipObj.skipTo
              };
              instructionList.push(instruction);
            }
          });
          return instructionList;
        };
        const conditionalRelevanceEquation = (logic, rule, state) => {
          const code = "conditional_relevance";
          if (rule == "show_always") {
            return {
              code,
              remove: true
            };
          } else if (rule == "hide_always") {
            return {
              code,
              text: "false",
              isActive: false,
              returnType: {
                name: "Boolean"
              }
            };
          }
          const text = jsonToJs(logic, false, code => state[code].type);
          if (rule == "show_if") {
            return {
              code,
              text,
              isActive: true,
              returnType: {
                name: "Boolean"
              }
            };
          } else if (rule == "hide_if") {
            return {
              code,
              text: `!${text}`,
              isActive: true,
              returnType: {
                name: "Boolean"
              }
            };
          } else {
            throw "WTF";
          }
        };
        const reorder = (list, startIndex, endIndex) => {
          const result = Array.from(list);
          const [removed] = result.splice(startIndex, 1);
          result.splice(endIndex, 0, removed);
          return result;
        };
        const nextGroupId = groups => {
          if (groups && groups.length) {
            return groups.map(group => parseInt(group.code.replace("G", ""))).sort(function (a, b) {
              return a - b;
            })[groups.length - 1] + 1;
          }
          return 1;
        };
        const nextQuestionId = (state, groups) => {
          if (groups.length) {
            let questions = [];
            groups.forEach(group => {
              let groupObj = state[group.code];
              if (groupObj.children) {
                groupObj.children.forEach(question => {
                  questions.push(parseInt(question.code.replace("Q", "")));
                });
              }
            });
            if (questions.length) {
              return questions.sort(function (a, b) {
                return a - b;
              })[questions.length - 1] + 1;
            }
          }
          return 1;
        };
        const buildReferenceInstruction = (content, name, key) => {
          const allMatches = getAllMatches(content);
          if (allMatches.length) {
            return {
              code: `reference_${name}_${key}`,
              references: allMatches,
              lang: key
            };
          } else {
            return {
              code: `reference_${name}_${key}`,
              remove: true
            };
          }
        };
        const getAllMatches = inputString => {
          const regex = /data-instruction=(\"|\')([\w\.!\"!\']+)(\"|\')/g;
          var m;
          var returnList = [];
          do {
            m = regex.exec(inputString);
            if (m) {
              returnList.push(m[2]);
            }
          } while (m);
          return returnList;
        };
        const serveyRandomSetup = exports('aT', {
          code: "Survey",
          rules: [{
            title: "order_priority",
            key: "random",
            rules: ["randomize_groups", "prioritize_groups"]
          }]
        });
        const setupOptions = exports('aQ', type => {
          switch (type) {
            case "group":
              return [{
                title: "show_hide",
                key: "relevance",
                rules: ["relevance"]
              }, {
                title: "order_priority",
                key: "random",
                rules: ["randomize_questions", "prioritize_questions"]
              }];
            case "text_display":
              return [{
                title: "show_hide",
                key: "relevance",
                rules: ["relevance"]
              }];
            case "image_display":
              return [{
                title: "show_hide",
                key: "relevance",
                rules: ["relevance"]
              }];
            case "video_display":
              return [{
                title: "show_hide",
                key: "relevance",
                rules: ["relevance"]
              }, {
                title: "video_options",
                key: "video_options",
                rules: ["audio_only", "loop"]
              }];
            case "text":
              return [{
                title: "show_hide",
                key: "relevance",
                rules: ["relevance"]
              }, {
                title: "setup",
                key: "setup",
                rules: ["maxChars", "hint"]
              }, {
                title: "validation",
                key: "validation",
                rules: ["validation_required", "validation_max_char_length", "validation_min_char_length", "validation_pattern", "validation_contains", "validation_not_contains"]
              }];
            case "other_text":
              return [{
                title: "setup",
                key: "setup",
                rules: ["maxChars"]
              }, {
                title: "validation",
                key: "validation",
                rules: ["validation_required", "validation_max_char_length", "validation_min_char_length", "validation_pattern", "validation_contains", "validation_not_contains"]
              }];
            case "number":
              return [{
                title: "show_hide",
                key: "relevance",
                rules: ["relevance"]
              }, {
                title: "setup",
                key: "setup",
                rules: ["maxChars", "hint"]
              }, {
                title: "validation",
                key: "validation",
                rules: ["validation_required", "validation_between", "validation_not_between", "validation_lt", "validation_lte", "validation_gt", "validation_gte", "validation_equals", "validation_not_equal"]
              }];
            case "email":
              return [{
                title: "show_hide",
                key: "relevance",
                rules: ["relevance"]
              }, {
                title: "setup",
                key: "setup",
                rules: ["maxChars", "hint"]
              }, {
                title: "validation",
                key: "validation",
                rules: ["validation_required", "validation_pattern_email", "validation_max_char_length", "validation_min_char_length"]
              }];
            case "paragraph":
              return [{
                title: "show_hide",
                key: "relevance",
                rules: ["relevance"]
              }, {
                title: "setup",
                key: "setup",
                rules: ["minRows", "showWordCount", "hint"]
              }, {
                title: "validation",
                key: "validation",
                rules: ["validation_required", "validation_max_word_count", "validation_min_word_count", "validation_contains", "validation_not_contains"]
              }];
            case "file_upload":
              return [{
                title: "show_hide",
                key: "relevance",
                rules: ["relevance"]
              }, {
                title: "validation",
                key: "validation",
                rules: ["validation_required", "validation_file_types", "validation_max_file_size"]
              }];
            case "signature":
              return [{
                title: "show_hide",
                key: "relevance",
                rules: ["relevance"]
              }, {
                title: "validation",
                key: "validation",
                rules: ["validation_required"]
              }];
            case "photo_capture":
              return [{
                title: "show_hide",
                key: "relevance",
                rules: ["relevance"]
              }, {
                title: "setup",
                key: "setup",
                rules: ["hint"]
              }, {
                title: "validation",
                key: "validation",
                rules: ["validation_required", "validation_max_file_size"]
              }];
            case "barcode":
              return [{
                title: "show_hide",
                key: "relevance",
                rules: ["relevance"]
              }, {
                title: "setup",
                key: "setup",
                rules: ["hint"]
              }, {
                title: "validation",
                key: "validation",
                rules: ["validation_required"]
              }];
            case "video_capture":
              return [{
                title: "show_hide",
                key: "relevance",
                rules: ["relevance"]
              }, {
                title: "setup",
                key: "setup",
                rules: ["hint"]
              }, {
                title: "validation",
                key: "validation",
                rules: ["validation_required", "validation_max_file_size"]
              }];
            case "date_time":
              return [{
                title: "show_hide",
                key: "relevance",
                rules: ["relevance"]
              }, {
                title: "setup",
                key: "setup",
                rules: ["dateFormat", "fullDayFormat", "maxDate", "minDate"]
              }, {
                title: "validation",
                key: "validation",
                rules: ["validation_required"]
              }];
            case "date":
              return [{
                title: "show_hide",
                key: "relevance",
                rules: ["relevance"]
              }, {
                title: "setup",
                key: "setup",
                rules: ["dateFormat", "maxDate", "minDate"]
              }, {
                title: "validation",
                key: "validation",
                rules: ["validation_required"]
              }];
            case "time":
              return [{
                title: "show_hide",
                key: "relevance",
                rules: ["relevance"]
              }, {
                title: "setup",
                key: "setup",
                rules: ["fullDayFormat"]
              }, {
                title: "validation",
                key: "validation",
                rules: ["validation_required"]
              }];
            case "scq":
              return [{
                title: "skip_logic",
                key: "skip_logic",
                rules: ["skip_logic"]
              }, {
                title: "show_hide",
                key: "relevance",
                rules: ["relevance"]
              }, {
                title: "order_priority",
                key: "random",
                rules: ["randomize_options", "prioritize_options"]
              }, {
                title: "validation",
                key: "validation",
                rules: ["validation_required"]
              }];
            case "image_scq":
              return [{
                title: "display",
                key: "display",
                rules: ["hideText", "columns", "imageAspectRatio", "spacing"]
              }, {
                title: "skip_logic",
                key: "skip_logic",
                rules: ["skip_logic"]
              }, {
                title: "show_hide",
                key: "relevance",
                rules: ["relevance"]
              }, {
                title: "order_priority",
                key: "random",
                rules: ["randomize_options", "prioritize_options"]
              }, {
                title: "validation",
                key: "validation",
                rules: ["validation_required"]
              }];
            case "mcq":
              return [{
                title: "show_hide",
                key: "relevance",
                rules: ["relevance"]
              }, {
                title: "order_priority",
                key: "random",
                rules: ["randomize_options", "prioritize_options"]
              }, {
                title: "validation",
                key: "validation",
                rules: ["validation_min_option_count", "validation_max_option_count", "validation_option_count"]
              }];
            case "ranking":
              return [{
                title: "show_hide",
                key: "relevance",
                rules: ["relevance"]
              }, {
                title: "order_priority",
                key: "random",
                rules: ["randomize_options", "prioritize_options"]
              }, {
                title: "validation",
                key: "validation",
                rules: ["validation_min_ranking_count", "validation_max_ranking_count", "validation_ranking_count"]
              }];
            case "image_ranking":
              return [{
                title: "display",
                key: "display",
                rules: ["hideText", "columns", "imageAspectRatio", "spacing"]
              }, {
                title: "show_hide",
                key: "relevance",
                rules: ["relevance"]
              }, {
                title: "order_priority",
                key: "random",
                rules: ["randomize_options", "prioritize_options"]
              }, {
                title: "validation",
                key: "validation",
                rules: ["validation_min_ranking_count", "validation_max_ranking_count", "validation_ranking_count"]
              }];
            case "image_mcq":
              return [{
                title: "display",
                key: "display",
                rules: ["hideText", "columns", "imageAspectRatio", "spacing"]
              }, {
                title: "show_hide",
                key: "relevance",
                rules: ["relevance"]
              }, {
                title: "order_priority",
                key: "random",
                rules: ["randomize_options", "prioritize_options"]
              }, {
                title: "validation",
                key: "validation",
                rules: ["validation_min_option_count", "validation_max_option_count", "validation_option_count"]
              }];
            case "scq_array":
              return [{
                title: "show_hide",
                key: "relevance",
                rules: ["relevance"]
              }, {
                title: "order_priority",
                key: "random",
                rules: ["randomize_rows", "prioritize_rows", "randomize_columns", "prioritize_columns"]
              }, {
                title: "validation",
                key: "validation",
                rules: ["validation_required"]
              }];
            case "nps":
              return [{
                title: "show_hide",
                key: "relevance",
                rules: ["relevance"]
              }, {
                title: "setup",
                key: "setup",
                rules: ["lower_bound_hint", "higher_bound_hint"]
              }, {
                title: "validation",
                key: "validation",
                rules: ["validation_required"]
              }];
          }
        });
        const reservedKeys = ["setup"];
        const designState = createSlice({
          name: "designState",
          initialState: {
            state: {}
          },
          reducers: {
            designStateReceived: (state, action) => {
              let keys = Object.keys(state).filter(el => !reservedKeys.includes(el));
              let newState = action.payload;
              keys = Object.keys(newState);
              keys.forEach(key => {
                if (!isEquivalent(state[key], newState[key])) {
                  state[key] = newState[key];
                }
              });
            },
            setup(state, action) {
              var _state$setup, _state$setup2;
              const payload = action.payload;
              // we want to ignore multiple clicks on the same setup button
              // but acknowledge when we highlight or expand a specific section
              if (payload.code != ((_state$setup = state.setup) === null || _state$setup === void 0 ? void 0 : _state$setup.code) || !isEquivalent(payload.rules, (_state$setup2 = state.setup) === null || _state$setup2 === void 0 ? void 0 : _state$setup2.rules) || payload.expanded || payload.highlighted) {
                state.setup = action.payload;
              }
            },
            newVersionReceived(state, action) {
              const payload = action.payload;
              state.versionDto = payload;
            },
            setupToggleExpand(state, action) {
              const key = action.payload;
              if (!state.setup.expanded) {
                state.setup.expanded = [];
              }
              if (!state.setup.expanded.includes(key)) {
                state.setup.expanded.push(key);
              } else {
                state.setup.expanded.splice(state.setup.expanded.indexOf(key), 1);
              }
            },
            changeValidationValue(state, action) {
              let payload = action.payload;
              if (!state[payload.code]["validation"]) {
                state[payload.code]["validation"] = {};
              }
              if (!state[payload.code]["validation"][payload.rule]) {
                state[payload.code]["validation"][payload.rule] = buildValidationDefaultData(payload.rule);
              }
              state[payload.code]["validation"][payload.rule][payload.key] = payload.value;
              processValidation(state, payload.code, payload.rule, payload.rule != "content");
            },
            resetSetup(state) {
              delete state["setup"];
            },
            changeAttribute: (state, action) => {
              let payload = action.payload;
              if (action.payload.key == "content" || action.payload.key == "instructionList" || action.payload.key == "relevance" || action.payload.key == "resources") {
                throw "We are changing attributes way too much than we should";
              }
              state[payload.code][payload.key] = payload.value;
              if (action.payload.key == "maxChars") {
                cleanupValidation(state, payload.code);
              } else if (action.payload.key == "dateFormat") {
                addMaskedValuesInstructions(payload.code, state[payload.code], state);
              } else if (action.payload.key == "fullDayFormat") {
                addMaskedValuesInstructions(payload.code, state[payload.code], state);
              } else if (["randomize_questions", "randomize_groups", "randomize_options", "randomize_rows", "randomize_columns"].indexOf(action.payload.key) > -1) {
                updateRandomByRule(state[payload.code], action.payload.key);
              } else if (["prioritize_questions", "prioritize_groups", "prioritize_options", "prioritize_rows", "prioritize_columns"].indexOf(action.payload.key) > -1) {
                if (!payload.value) {
                  removeInstruction(state[payload.code], "priority_groups");
                }
              }
            },
            toggleComponentCollapse: (state, action) => {
              let groupCode = action.payload;
              state[groupCode].collapsed = !(state[groupCode].collapsed || false);
            },
            changeRelevance: (state, action) => {
              let payload = action.payload;
              state[payload.code].relevance = payload.value;
              addRelevanceInstructions(state, payload.code, payload.value);
            },
            cloneQuestion: (state, action) => {
              var _survey$children, _survey$children$map, _survey$children$map$;
              const code = action.payload;
              const survey = state.Survey;
              const group = (_survey$children = survey.children) === null || _survey$children === void 0 ? void 0 : (_survey$children$map = _survey$children.map(group => state[group.code])) === null || _survey$children$map === void 0 ? void 0 : (_survey$children$map$ = _survey$children$map.filter(group => group.children && group.children.findIndex(child => child.code == code) !== -1)) === null || _survey$children$map$ === void 0 ? void 0 : _survey$children$map$[0];
              if (!group) {
                return;
              }
              const newQuestionId = "Q" + nextQuestionId(state, survey.children);
              const questionChild = group.children.find(el => el.code == code);
              const newQuestion = {
                type: questionChild.type,
                code: newQuestionId,
                qualifiedCode: newQuestionId
              };
              creatNewState(state, state[code], newQuestionId, code, newQuestionId);
              group.children.splice(group.children.indexOf(questionChild) + 1, 0, newQuestion);
              designState.caseReducers.setup(state, {
                payload: {
                  code: newQuestionId,
                  rules: setupOptions(newQuestion.type)
                }
              });
              cleanupRandomRules(group);
            },
            removeAnswer: (state, action) => {
              var _state$setup3, _state$setup3$code;
              const answerQualifiedCode = action.payload;
              const codes = splitQuestionCodes(answerQualifiedCode);
              let question = state[codes[0]];
              question.children = question.children.filter(el => el.code !== codes[1]);
              delete state[answerQualifiedCode];
              // could be otherText
              if ((_state$setup3 = state.setup) !== null && _state$setup3 !== void 0 && (_state$setup3$code = _state$setup3.code) !== null && _state$setup3$code !== void 0 && _state$setup3$code.includes(answerQualifiedCode)) {
                designState.caseReducers.resetSetup(state);
              }
              question.designErrors = questionDesignError(question);
              cleanupValidation(state, codes[0]);
              addMaskedValuesInstructions(codes[0], question, state);
              cleanupRandomRules(question);
            },
            addNewAnswer: (state, action) => {
              const lang = state.langInfo.mainLang;
              const payload = action.payload;
              const answer = payload.answer;
              const label = payload.label;
              const instructionList = payload.instructionList;
              const qualifiedCode = answer.qualifiedCode;
              state[qualifiedCode] = {};
              if (!insertAnswer(state, answer)) {
                return;
              }
              if (label) {
                state[qualifiedCode].content = {
                  label: {
                    [lang]: label
                  }
                };
              }
              if (answer.type) {
                state[qualifiedCode].type = answer.type;
              }
              instructionList === null || instructionList === void 0 ? void 0 : instructionList.forEach(instruction => changeInstruction(state[qualifiedCode], instruction));
            },
            deleteGroup: (state, action) => {
              var _state$setup4, _survey$children2;
              const groupCode = action.payload;
              if (((_state$setup4 = state.setup) === null || _state$setup4 === void 0 ? void 0 : _state$setup4.code) == groupCode) {
                designState.caseReducers.resetSetup(state);
              }
              if (state[groupCode].groupType == "END") {
                state.error = {
                  message: "There must always be an end group. for an end message "
                };
                return;
              }
              const survey = state.Survey;
              const index = (_survey$children2 = survey.children) === null || _survey$children2 === void 0 ? void 0 : _survey$children2.findIndex(x => x.code === groupCode);
              survey.children.splice(index, 1);
              delete state[groupCode];
              cleanupRandomRules(survey);
            },
            deleteQuestion: (state, action) => {
              var _state$setup5, _survey$children3, _survey$children3$map, _survey$children3$map2;
              const questionCode = action.payload;
              if (((_state$setup5 = state.setup) === null || _state$setup5 === void 0 ? void 0 : _state$setup5.code) == questionCode) {
                designState.caseReducers.resetSetup(state);
              }
              const survey = state.Survey;
              const group = (_survey$children3 = survey.children) === null || _survey$children3 === void 0 ? void 0 : (_survey$children3$map = _survey$children3.map(group => state[group.code])) === null || _survey$children3$map === void 0 ? void 0 : (_survey$children3$map2 = _survey$children3$map.filter(group => group.children && group.children.findIndex(child => child.code == questionCode) !== -1)) === null || _survey$children3$map2 === void 0 ? void 0 : _survey$children3$map2[0];
              if (!group) {
                return;
              }
              const questionIndex = group.children.findIndex(x => x.code === questionCode);
              let children = [...group.children];
              if (children.length === 1) {
                group.children = [];
              } else {
                group.children.splice(questionIndex, 1);
              }
              delete state[questionCode];
              cleanupRandomRules(group);
            },
            changeContent: (state, action) => {
              let payload = action.payload;
              if (!state[payload.code].content) {
                state[payload.code].content = {};
                state[payload.code].content[payload.key] = {};
              } else if (!state[payload.code].content[payload.key]) {
                state[payload.code].content[payload.key] = {};
              }
              const referenceInstruction = buildReferenceInstruction(payload.value, payload.key, payload.lang);
              changeInstruction(state[payload.code], referenceInstruction);
              state[payload.code].content[payload.key][payload.lang] = payload.value;
            },
            changeResources: (state, action) => {
              let payload = action.payload;
              if (!state[payload.code].resources) {
                state[payload.code].resources = {};
              }
              state[payload.code].resources[payload.key] = payload.value;
            },
            updateRandom: (state, action) => {
              const payload = action.payload;
              const componentState = state[payload.code];
              if (payload.groups) {
                const instruction = {
                  code: "random_group",
                  groups: payload.groups
                };
                changeInstruction(componentState, instruction);
              } else {
                removeInstruction(componentState, "random_group");
              }
            },
            updatePriority: (state, action) => {
              const payload = action.payload;
              const componentState = state[payload.code];
              if (payload.priorities) {
                const instruction = {
                  code: "priority_groups",
                  priorities: payload.priorities
                };
                changeInstruction(componentState, instruction);
              } else {
                removeInstruction(componentState, "priority_groups");
              }
            },
            updateRandomByType: (state, action) => {
              var _state$payload$code, _state$payload$code$c, _state$payload$code$c2, _randomInstruction$gr;
              const payload = action.payload;
              const componentState = state[payload.code];
              const otherChildrenCodes = (_state$payload$code = state[payload.code]) === null || _state$payload$code === void 0 ? void 0 : (_state$payload$code$c = _state$payload$code.children) === null || _state$payload$code$c === void 0 ? void 0 : (_state$payload$code$c2 = _state$payload$code$c.filter(el => el.type !== payload.type)) === null || _state$payload$code$c2 === void 0 ? void 0 : _state$payload$code$c2.map(el => el.code);
              const randomInstruction = instructionByCode(componentState, "random_group");
              const otherRandomOrders = (randomInstruction === null || randomInstruction === void 0 ? void 0 : (_randomInstruction$gr = randomInstruction.groups) === null || _randomInstruction$gr === void 0 ? void 0 : _randomInstruction$gr.filter(x => x.length && x.some(elem => otherChildrenCodes.includes(elem)))) || [];
              const groups = payload.groups.concat(otherRandomOrders);
              if (groups) {
                const instruction = {
                  code: "random_group",
                  groups
                };
                changeInstruction(componentState, instruction);
              } else {
                removeInstruction(componentState, "random_group");
              }
            },
            updatePriorityByType: (state, action) => {
              var _state$payload$code2, _state$payload$code2$, _state$payload$code2$2, _priorityInstruction$;
              const payload = action.payload;
              const componentState = state[payload.code];
              const otherChildrenCodes = (_state$payload$code2 = state[payload.code]) === null || _state$payload$code2 === void 0 ? void 0 : (_state$payload$code2$ = _state$payload$code2.children) === null || _state$payload$code2$ === void 0 ? void 0 : (_state$payload$code2$2 = _state$payload$code2$.filter(el => el.type !== payload.type)) === null || _state$payload$code2$2 === void 0 ? void 0 : _state$payload$code2$2.map(el => el.code);
              const priorityInstruction = instructionByCode(componentState, "priority_groups");
              const otherPriorities = (priorityInstruction === null || priorityInstruction === void 0 ? void 0 : (_priorityInstruction$ = priorityInstruction.priorities) === null || _priorityInstruction$ === void 0 ? void 0 : _priorityInstruction$.filter(x => x && x.weights.some(el => otherChildrenCodes.includes(el.code)))) || [];
              const priorities = payload.priorities.concat(otherPriorities);
              if (priorities) {
                const instruction = {
                  code: "priority_groups",
                  priorities
                };
                changeInstruction(componentState, instruction);
              } else {
                removeInstruction(componentState, "priority_groups");
              }
            },
            removeSkipDestination: (state, action) => {
              const payload = action.payload;
              delete state[payload.code].skip_logic[payload.answerCode];
              addSkipInstructions(state, payload.code, state[payload.code].skip_logic);
            },
            editSkipDestination: (state, action) => {
              var _state$payload$code$s;
              const payload = action.payload;
              if (!state[payload.code].skip_logic) {
                state[payload.code].skip_logic = {};
              }
              if (!state[payload.code].skip_logic[payload.answerCode]) {
                state[payload.code].skip_logic[payload.answerCode] = {};
              }
              if (((_state$payload$code$s = state[payload.code].skip_logic) === null || _state$payload$code$s === void 0 ? void 0 : _state$payload$code$s[payload.answerCode].skipTo) !== payload.skipTo) {
                state[payload.code].skip_logic[payload.answerCode] = {
                  skipTo: payload.skipTo
                };
                addSkipInstructions(state, payload.code, state[payload.code].skip_logic);
              }
            },
            editSkipToEnd: (state, action) => {
              const payload = action.payload;
              state[payload.code].skip_logic[payload.answerCode].toEnd = payload.toEnd;
              addSkipInstructions(state, payload.code, state[payload.code].skip_logic);
            },
            changeLang: (state, action) => {
              state.langInfo.lang = action.payload;
            },
            setSaving: (state, action) => {
              state.isSaving = action.payload;
            },
            setUpdating: (state, action) => {
              state.isUpdating = action.payload;
            },
            onDrag: (state, action) => {
              const payload = action.payload;
              switch (payload.type) {
                case "reorder_questions":
                  reorderQuestions(state, state.Survey, payload);
                  break;
                case "reorder_groups":
                  reorderGroups(state.Survey, payload);
                  break;
                case "reorder_answers":
                  reorderAnswers(state, payload);
                  break;
                case "reorder_answers_by_type":
                  reorderAnswersByType(state, payload);
                  break;
                case "new_question":
                  newQuestion(state, payload);
                  break;
                case "new_group":
                  if (payload.groupType == "group") {
                    newGroup(state, payload);
                  } else if (payload.groupType == "end" || payload.groupType == "welcome") {
                    specialGroup(state, payload);
                  }
                  break;
              }
            },
            collapseAllGroups: state => {
              state.Survey.children.forEach(group => state[group.code].collapsed = true);
            },
            onError: (state, action) => {
              state.error = action.payload || false;
            },
            onErrorSeen: state => {
              state.error.seen = true;
            }
          }
        });
        const {
          newVersionReceived,
          designStateReceived,
          changeLang,
          changeAttribute,
          changeTimeFormats,
          changeContent,
          changeResources,
          deleteQuestion,
          cloneQuestion,
          deleteGroup,
          addNewAnswer,
          removeAnswer,
          setup,
          setupToggleExpand,
          resetSetup,
          changeValidationValue,
          updateRandom,
          updatePriority,
          updateRandomByType,
          updatePriorityByType,
          removeSkipDestination,
          editSkipDestination,
          editSkipToEnd,
          changeRelevance,
          onDrag,
          collapseAllGroups,
          toggleComponentCollapse,
          setSaving: setSaving$1,
          setUpdating: setUpdating$1,
          onError: onError$1,
          onErrorSeen: onErrorSeen$1
        } = designState.actions;
        exports({
          bA: newVersionReceived,
          bD: designStateReceived,
          bx: changeLang,
          b7: changeAttribute,
          aN: changeContent,
          aW: changeResources,
          a_: deleteQuestion,
          aZ: cloneQuestion,
          b2: deleteGroup,
          b1: addNewAnswer,
          aR: removeAnswer,
          aP: setup,
          bw: setupToggleExpand,
          by: resetSetup,
          b8: changeValidationValue,
          bv: updateRandom,
          bt: updatePriority,
          bu: updateRandomByType,
          bs: updatePriorityByType,
          bo: removeSkipDestination,
          bp: editSkipDestination,
          bq: editSkipToEnd,
          bn: changeRelevance,
          aX: onDrag,
          b4: collapseAllGroups,
          a$: toggleComponentCollapse,
          bE: onError$1,
          bB: onErrorSeen$1
        });
        const designState$1 = designState.reducer;
        const changeInstruction = (componentState, instruction) => {
          if (typeof componentState.instructionList === "undefined") {
            componentState.instructionList = [];
          }
          if (instruction.remove) {
            removeInstruction(componentState, instruction.code);
          } else {
            editInstruction(componentState, instruction);
          }
        };

        // there is always an assumption that instructionList exists!!!
        const removeInstruction = (componentState, code) => {
          if (componentState.instructionList.length) {
            const index = componentState.instructionList.findIndex(el => el.code === code);
            if (index < 0) {
              return;
            } else if (componentState.instructionList.length == 1) {
              componentState.instructionList = [];
            } else {
              componentState.instructionList.splice(index, 1);
            }
          }
        };
        const cleanupRandomRules = componentState => {
          if (componentState["randomize_questions"]) {
            updateRandomByRule(componentState, "randomize_questions");
          } else if (componentState["randomize_groups"]) {
            updateRandomByRule(componentState, "randomize_groups");
          } else if (componentState["randomize_options"]) {
            updateRandomByRule(componentState, "randomize_options");
          } else if (componentState["randomize_rows"]) {
            updateRandomByRule(componentState, "randomize_rows");
          } else if (componentState["randomize_columns"]) {
            updateRandomByRule(componentState, "randomize_columns");
          }
        };
        const updateRandomByRule = (componentState, randomRule) => {
          console.log(R(componentState));
          if (["randomize_questions", "randomize_groups", "randomize_options"].indexOf(randomRule) > -1 && componentState[randomRule] !== "custom") {
            var _componentState$child, _componentState$child2;
            const childCodes = (_componentState$child = componentState.children) === null || _componentState$child === void 0 ? void 0 : (_componentState$child2 = _componentState$child.filter(it => {
              var _it$groupType, _it$groupType2;
              return ((_it$groupType = it.groupType) === null || _it$groupType === void 0 ? void 0 : _it$groupType.toLowerCase()) != "end" && ((_it$groupType2 = it.groupType) === null || _it$groupType2 === void 0 ? void 0 : _it$groupType2.toLowerCase()) != "welcome";
            })) === null || _componentState$child2 === void 0 ? void 0 : _componentState$child2.map(it => it.code);
            if (childCodes.length == 0 || !componentState[randomRule]) {
              componentState[randomRule] = false;
              removeInstruction(componentState, "random_group");
              return;
            }
            const instruction = {
              code: "random_group",
              groups: [{
                codes: childCodes,
                randomOption: componentState[randomRule]
              }]
            };
            changeInstruction(componentState, instruction);
          } else if (["randomize_rows"].indexOf(randomRule) > -1 && componentState[randomRule] !== "custom") {
            var _componentState$child3, _componentState$child4;
            const childCodes = (_componentState$child3 = componentState.children) === null || _componentState$child3 === void 0 ? void 0 : (_componentState$child4 = _componentState$child3.filter(child => child.type == "row")) === null || _componentState$child4 === void 0 ? void 0 : _componentState$child4.map(it => it.code);
            if (childCodes.length == 0 || !componentState[randomRule]) {
              componentState[randomRule] = false;
              removeInstruction(componentState, "random_group");
              return;
            }
            const instruction = {
              code: "random_group",
              groups: [{
                codes: childCodes,
                randomOption: componentState[randomRule]
              }]
            };
            changeInstruction(componentState, instruction);
          } else if (["randomize_columns"].indexOf(randomRule) > -1 && componentState[randomRule] !== "custom") {
            var _componentState$child5, _componentState$child6;
            const childCodes = (_componentState$child5 = componentState.children) === null || _componentState$child5 === void 0 ? void 0 : (_componentState$child6 = _componentState$child5.filter(child => child.type == "column")) === null || _componentState$child6 === void 0 ? void 0 : _componentState$child6.map(it => it.code);
            if (childCodes.length == 0 || !componentState[randomRule]) {
              componentState[randomRule] = false;
              removeInstruction(componentState, "random_group");
              return;
            }
            const instruction = {
              code: "random_group",
              groups: [{
                codes: childCodes,
                randomOption: componentState[randomRule]
              }]
            };
            changeInstruction(componentState, instruction);
          }
        };

        // there is always an assumption that instructionList exists!!!
        const editInstruction = (componentState, instruction) => {
          const index = componentState.instructionList.findIndex(el => el.code === instruction.code);
          if (index < 0) {
            componentState.instructionList.push(instruction);
          } else {
            componentState.instructionList[index] = instruction;
          }
        };
        const reorderQuestions = (state, survey, payload) => {
          let index = buildIndex(state, survey.children);
          const sourceGroup = state[payload.source];
          const destinationGroup = state[payload.destination];
          const sourceQuestionIndex = sourceGroup.children.findIndex(question => question.code == payload.id);
          const destinationQuestionIndex = payload.toIndex - index.indexOf(payload.destination) - 1;
          const question = sourceGroup.children[sourceQuestionIndex];
          sourceGroup.children.splice(sourceQuestionIndex, 1);
          if (!destinationGroup.children) {
            destinationGroup.children = [];
          }
          destinationGroup.children.splice(destinationQuestionIndex, 0, question);
          cleanupRandomRules(destinationGroup);
          cleanupRandomRules(sourceGroup);
        };
        const newQuestion = (state, payload) => {
          const survey = state.Survey;
          let index = buildIndex(state, survey.children);
          let questionId = nextQuestionId(state, survey.children);
          const questionObject = createQuestion(payload.questionType, questionId, state.langInfo.mainLang);
          const destinationGroup = state[payload.destination];
          const destinationQuestionIndex = payload.toIndex - index.indexOf(payload.destination) - 1;
          if (!destinationGroup.children) {
            destinationGroup.children = [];
          }
          Object.keys(questionObject).filter(key => key != "question").forEach(key => {
            state[key] = questionObject[key];
          });
          const newCode = `Q${questionId}`;
          addMaskedValuesInstructions(newCode, questionObject[newCode], state);
          destinationGroup.children.splice(destinationQuestionIndex, 0, questionObject.question);
          cleanupRandomRules(destinationGroup);
        };
        const newGroup = (state, payload) => {
          var _survey$children4;
          const survey = state.Survey;
          let index = buildIndex(state, survey.children);
          const toIndex = (_survey$children4 = survey.children) === null || _survey$children4 === void 0 ? void 0 : _survey$children4.findIndex(group => group.code == index[payload.toIndex]);
          const group = createGroup("GROUP", nextGroupId(survey.children), state.langInfo.mainLang);
          if (!survey.children) {
            survey.children = [];
          }
          if (toIndex == -1) {
            survey.children.push(group.newGroup);
          } else {
            survey.children.splice(toIndex, 0, group.newGroup);
          }
          state[group.newGroup.code] = group.state;
          cleanupRandomRules(survey);
        };
        const specialGroup = (state, payload) => {
          const survey = state.Survey;
          if (!survey.children) {
            survey.children = [];
          }
          const index = survey.children.findIndex(group => {
            var _state$group$code$gro;
            return ((_state$group$code$gro = state[group.code].groupType) === null || _state$group$code$gro === void 0 ? void 0 : _state$group$code$gro.toLowerCase()) === payload.groupType;
          });
          if (index !== -1) {
            state.error = {
              message: "cannot have duplicate " + (payload.groupType == "welcome" ? "Welcome groups" : "End groups")
            };
            return;
          }
          if (payload.groupType == "welcome") {
            const group = createGroup("WELCOME", nextGroupId(survey.children), state.langInfo.mainLang);
            survey.children.splice(0, 0, group.newGroup);
            state[group.newGroup.code] = group.state;
          } else if (payload.groupType == "end") {
            const group = createGroup("END", nextGroupId(survey.children), state.langInfo.mainLang);
            survey.children.push(group.newGroup);
            state[group.newGroup.code] = group.state;
          }
        };
        const reorderGroups = (survey, payload) => {
          survey.children = reorder(survey.children, payload.fromIndex, payload.toIndex);
        };
        const reorderAnswers = (state, payload) => {
          const codes = splitQuestionCodes(payload.id);
          const parentCode = codes.slice(0, codes.length - 1).join("");
          const component = state[parentCode];
          component.children = reorder(component.children, payload.fromIndex, payload.toIndex);
        };
        const reorderAnswersByType = (state, payload) => {
          const codes = splitQuestionCodes(payload.id);
          const parentCode = codes.slice(0, codes.length - 1).join("");
          const component = state[parentCode];
          const type = state[payload.id].type;
          const filteredChildren = component.children.filter(child => child.type == type);
          const fromIndex = component.children.indexOf(filteredChildren[payload.fromIndex]);
          const toIndex = component.children.indexOf(filteredChildren[payload.toIndex]);
          component.children = reorder(component.children, fromIndex, toIndex);
        };
        const insertAnswer = (state, answer) => {
          const codes = splitQuestionCodes(answer.qualifiedCode);
          const parentCode = codes.slice(0, codes.length - 1).join("");
          const component = state[parentCode];
          if (component) {
            if (!component.children) {
              component.children = [];
            }
            const insertIndex = lastIndexInArray(component.children, child => child.type == answer.type || !child.type);
            component.children.splice(insertIndex + 1, 0, answer);
            component.designErrors = questionDesignError(component);
            cleanupValidation(state, parentCode);
            addMaskedValuesInstructions(parentCode, component, state);
            cleanupRandomRules(component);
            return true;
          } else {
            return false;
          }
        };
        const buildIndex = exports('b5', (state, groups) => {
          let retrunRestult = [];
          groups === null || groups === void 0 ? void 0 : groups.forEach(group => {
            retrunRestult.push(group.code);
            let groupObj = state[group.code];
            if (groupObj.children && !groupObj.collapsed) {
              groupObj.children.forEach(question => {
                retrunRestult.push(question.code);
              });
            }
          });
          return retrunRestult;
        });
        const splitQuestionCodes = code => {
          return code.split(/(A[a-z_0-9]+|Q[a-z_0-9]+)/).filter(Boolean);
        };
        const addValidationEquation = (state, qualifiedCode, rule) => {
          const component = state[qualifiedCode];
          const validationInstruction = validationEquation(qualifiedCode, component, rule, component["validation"][rule]);
          changeInstruction(component, validationInstruction);
        };
        const processValidation = (state, code, rule, modifyEquation) => {
          const component = state[code];
          if (component.designErrors && component.designErrors.length) {
            component.validation[rule].isActive = false;
            removeInstruction(component, rule);
            return;
          }
          component.validation[rule] = cleanupValidationData(component, rule, component.validation[rule]);
          // we have this special situation that the SCQ array validation is copied to its children
          // This is specifically important when an SCQ array is implemented at SCQ in smaller screens
          if (component.type == "scq_array" && rule == "validation_required") {
            component.children.filter(child => child.type == "row").forEach(row => {
              const child = state[row.qualifiedCode];
              if (!child.validation) {
                child.validation = {};
              }
              child.validation[rule] = component.validation[rule];
              addValidationEquation(state, row.qualifiedCode, rule);
            });
            return;
          }
          if (modifyEquation) {
            addValidationEquation(state, code, rule);
          }
        };
        const cleanupValidation = (state, code) => {
          const component = state[code];
          if (!component.validation) {
            return;
          }
          const ruleKeys = Object.keys(component["validation"]);
          ruleKeys.forEach(key => processValidation(state, code, key, true));
        };
        const addSkipInstructions = (state, code, skipLogic) => {
          const component = state[code];
          if (component.type != "scq" && component.type != "image_scq") {
            return;
          }
          const instructions = scqSkipEquations(code, component, skipLogic);
          instructions.forEach(instruction => {
            changeInstruction(state[code], instruction);
          });
        };
        const addRelevanceInstructions = (state, code, relevance) => {
          const instruction = conditionalRelevanceEquation(relevance.logic, relevance.rule, state);
          changeInstruction(state[code], instruction);
        };
        const addMaskedValuesInstructions = (qualifiedCode, component, state) => {
          if (!component.type || !["mcq", "image_mcq", "scq", "image_scq", "scq_array", "date", "date_time", "time"].includes(component.type)) {
            return;
          }
          switch (component.type) {
            case "date":
              if (component.dateFormat) {
                changeInstruction(component, {
                  code: "masked_value",
                  isActive: true,
                  returnType: {
                    name: "String"
                  },
                  text: `FrankieScripts.formatSqlDate(${qualifiedCode}.value, "${component.dateFormat}")`
                });
              } else {
                changeInstruction(component, {
                  code: "masked_value",
                  remove: true
                });
              }
              break;
            case "time":
              changeInstruction(component, {
                code: "masked_value",
                isActive: true,
                returnType: {
                  name: "String"
                },
                text: `FrankieScripts.formatTime(${qualifiedCode}.value, ${component.fullDayFormat || false})`
              });
              break;
            case "date_time":
              if (component.dateFormat) {
                changeInstruction(component, {
                  code: "masked_value",
                  isActive: true,
                  returnType: {
                    name: "String"
                  },
                  text: `FrankieScripts.formatSqlDate(${qualifiedCode}.value, "${component.dateFormat}") + " " + FrankieScripts.formatTime(${qualifiedCode}.value, ${component.fullDayFormat || false})`
                });
              } else {
                changeInstruction(component, {
                  code: "masked_value",
                  remove: true
                });
              }
              break;
            case "image_scq":
            case "scq":
              if (component.children && component.children.length) {
                let objText = "{" + component.children.map(el => el.type == "other" ? `${el.code}: ${el.qualifiedCode}Atext.value` : `${el.code}: ${el.qualifiedCode}.label`).join(",") + "}";
                const instruction = {
                  code: "masked_value",
                  isActive: true,
                  returnType: {
                    name: "String"
                  },
                  text: `${qualifiedCode}.value ? ${objText}[${qualifiedCode}.value] : ''`
                };
                changeInstruction(component, instruction);
              } else {
                changeInstruction(component, {
                  code: "masked_value",
                  remove: true
                });
              }
              break;
            case "image_mcq":
            case "mcq":
              if (component.children && component.children.length) {
                let text = "[" + component.children.map(answer => {
                  return `{ value:${answer.qualifiedCode}.value,` + ` label:${answer.type == "other" ? answer.qualifiedCode + "Atext.value" : answer.qualifiedCode + ".label"} }`;
                }).join(", ") + "]";
                const instruction = {
                  code: "masked_value",
                  isActive: true,
                  returnType: {
                    name: "String"
                  },
                  text: `FrankieScripts.listStrings(${text}.filter(function(elem){return elem.value}).map(function(elem){return elem.label}), Survey.lang)`
                };
                changeInstruction(component, instruction);
              } else {
                changeInstruction(component, {
                  code: "masked_value",
                  remove: true
                });
              }
              break;
            case "scq_array":
              if (component.children && component.children.length && component.children.filter(el => el.type == "column").length && component.children.filter(el => el.type === "row").length) {
                let objText = "{" + component.children.filter(el => el.type == "column").map(el => `${el.code}: ${el.qualifiedCode}.label`).join(",") + "}";
                component.children.filter(el => el.type === "row").forEach(el => {
                  const instruction = {
                    code: "masked_value",
                    isActive: true,
                    returnType: {
                      name: "String"
                    },
                    text: `${el.qualifiedCode}.value ? ${objText}[${el.qualifiedCode}.value] : ''`
                  };
                  changeInstruction(state[el.qualifiedCode], instruction);
                });
              } else if (component.children && component.children.filter(el => el.type === "row").length) {
                component.children.filter(el => el.type === "row").forEach(el => {
                  changeInstruction(state[el.qualifiedCode], {
                    code: "masked_value",
                    remove: true
                  });
                });
              }
          }
          return component;
        };
        const creatNewState = (state, toBeCopied, newStateCode, oldQuestionCode, newQuestionCode) => {
          var _newState$instruction3, _state$newStateCode, _state$newStateCode$c;
          const newState = lodash_clonedeepExports.cloneDeep(toBeCopied);
          if (newState.relevance) {
            var _newState$instruction;
            delete newState.relevance;
            const index = (_newState$instruction = newState.instructionList) === null || _newState$instruction === void 0 ? void 0 : _newState$instruction.findIndex(instruction => instruction.code == "conditional_relevance");
            if (index) {
              var _newState$instruction2;
              (_newState$instruction2 = newState.instructionList) === null || _newState$instruction2 === void 0 ? void 0 : _newState$instruction2.splice(index, 1);
            }
          }
          if (newState.skip_logic) {
            delete newState.skip_logic;
            newState.instructionList = newState.instructionList.filter(eq => !eq.code.startsWith("skip_to_on_"));
          }
          (_newState$instruction3 = newState.instructionList) === null || _newState$instruction3 === void 0 ? void 0 : _newState$instruction3.forEach(eq => {
            eq.text = eq.text.replaceAll(oldQuestionCode, newQuestionCode);
          });
          state[newStateCode] = newState;
          (_state$newStateCode = state[newStateCode]) === null || _state$newStateCode === void 0 ? void 0 : (_state$newStateCode$c = _state$newStateCode.children) === null || _state$newStateCode$c === void 0 ? void 0 : _state$newStateCode$c.forEach(child => {
            let oldChildCode = child.qualifiedCode;
            let newChildCode = child.qualifiedCode.replaceAll(oldQuestionCode, newQuestionCode);
            child.qualifiedCode = newChildCode;
            creatNewState(state, state[oldChildCode], newChildCode, oldQuestionCode, newQuestionCode);
          });
        };
        const editState = createSlice({
          name: "editState",
          initialState: {
            state: {}
          },
          reducers: {
            setSaving: (state, action) => {
              state.isSaving = action.payload;
            },
            setUpdating: (state, action) => {
              state.isUpdating = action.payload;
            },
            surveyReceived: (state, action) => {
              let survey = action.payload;
              if (!isEquivalent(state.survey, survey)) {
                state.survey = survey;
              }
              state.error = "";
            },
            permissionsReceived: (state, action) => {
              let permissions = action.payload;
              if (!isEquivalent(state.permissions, permissions)) {
                state.permissions = permissions;
              }
            },
            permissionsLoading: (state, action) => {
              state.permissionsLoading = action.payload;
            },
            surveyAttributeChanged: (state, action) => {
              let payload = action.payload;
              state.survey[payload.key] = payload.value;
            },
            surveyAttributeChangedImmediate: (state, action) => {
              let payload = action.payload;
              state.survey[payload.key] = payload.value;
            },
            onError: (state, action) => {
              state.error = action.payload || false;
            },
            onErrorSeen: state => {
              state.error = "";
            }
          }
        });
        const {
          surveyReceived,
          permissionsReceived,
          permissionsLoading,
          setSaving,
          setUpdating,
          onError,
          onErrorSeen,
          surveyAttributeChanged,
          surveyAttributeChangedImmediate
        } = editState.actions;
        exports({
          f: surveyReceived,
          k: permissionsReceived,
          h: permissionsLoading,
          o: onError,
          l: onErrorSeen,
          e: surveyAttributeChanged,
          s: surveyAttributeChangedImmediate
        });
        const editState$1 = editState.reducer;
        const BG_COLOR = "#d7ccc8";
        const TEXT_COLOR = "#000000CC";
        const PRIMARY_COLOR = "#3f51b5";
        const SECONDARY_COLOR = "#5e35b1";
        const ERR_COLOR = "#f44336";
        const PAPER_COLOR = "#fafafa";
        const defualtTheme = exports('an', theme => {
          var _theme$textStyles, _theme$textStyles$gro, _theme$textStyles2, _theme$textStyles2$gr, _theme$textStyles3, _theme$textStyles3$gr, _theme$textStyles4, _theme$textStyles4$qu, _theme$textStyles5, _theme$textStyles5$qu, _theme$textStyles6, _theme$textStyles6$qu, _theme$textStyles7, _theme$textStyles7$te, _theme$textStyles8, _theme$textStyles8$te, _theme$textStyles9, _theme$textStyles9$te;
          return {
            textStyles: {
              group: {
                font: (theme === null || theme === void 0 ? void 0 : (_theme$textStyles = theme.textStyles) === null || _theme$textStyles === void 0 ? void 0 : (_theme$textStyles$gro = _theme$textStyles.group) === null || _theme$textStyles$gro === void 0 ? void 0 : _theme$textStyles$gro.font) || "Google Sans",
                size: (theme === null || theme === void 0 ? void 0 : (_theme$textStyles2 = theme.textStyles) === null || _theme$textStyles2 === void 0 ? void 0 : (_theme$textStyles2$gr = _theme$textStyles2.group) === null || _theme$textStyles2$gr === void 0 ? void 0 : _theme$textStyles2$gr.size) || 26,
                color: (theme === null || theme === void 0 ? void 0 : (_theme$textStyles3 = theme.textStyles) === null || _theme$textStyles3 === void 0 ? void 0 : (_theme$textStyles3$gr = _theme$textStyles3.group) === null || _theme$textStyles3$gr === void 0 ? void 0 : _theme$textStyles3$gr.color) || TEXT_COLOR
              },
              question: {
                font: (theme === null || theme === void 0 ? void 0 : (_theme$textStyles4 = theme.textStyles) === null || _theme$textStyles4 === void 0 ? void 0 : (_theme$textStyles4$qu = _theme$textStyles4.question) === null || _theme$textStyles4$qu === void 0 ? void 0 : _theme$textStyles4$qu.font) || "Google Sans",
                size: (theme === null || theme === void 0 ? void 0 : (_theme$textStyles5 = theme.textStyles) === null || _theme$textStyles5 === void 0 ? void 0 : (_theme$textStyles5$qu = _theme$textStyles5.question) === null || _theme$textStyles5$qu === void 0 ? void 0 : _theme$textStyles5$qu.size) || 18,
                color: (theme === null || theme === void 0 ? void 0 : (_theme$textStyles6 = theme.textStyles) === null || _theme$textStyles6 === void 0 ? void 0 : (_theme$textStyles6$qu = _theme$textStyles6.question) === null || _theme$textStyles6$qu === void 0 ? void 0 : _theme$textStyles6$qu.color) || TEXT_COLOR
              },
              text: {
                font: (theme === null || theme === void 0 ? void 0 : (_theme$textStyles7 = theme.textStyles) === null || _theme$textStyles7 === void 0 ? void 0 : (_theme$textStyles7$te = _theme$textStyles7.text) === null || _theme$textStyles7$te === void 0 ? void 0 : _theme$textStyles7$te.font) || "Google Sans",
                size: (theme === null || theme === void 0 ? void 0 : (_theme$textStyles8 = theme.textStyles) === null || _theme$textStyles8 === void 0 ? void 0 : (_theme$textStyles8$te = _theme$textStyles8.text) === null || _theme$textStyles8$te === void 0 ? void 0 : _theme$textStyles8$te.size) || 14,
                color: (theme === null || theme === void 0 ? void 0 : (_theme$textStyles9 = theme.textStyles) === null || _theme$textStyles9 === void 0 ? void 0 : (_theme$textStyles9$te = _theme$textStyles9.text) === null || _theme$textStyles9$te === void 0 ? void 0 : _theme$textStyles9$te.color) || TEXT_COLOR
              }
            },
            palette: {
              type: "light",
              primary: {
                main: (theme === null || theme === void 0 ? void 0 : theme.primaryColor) || PRIMARY_COLOR
              },
              secondary: {
                main: SECONDARY_COLOR
              },
              error: {
                main: ERR_COLOR
              },
              background: {
                default: (theme === null || theme === void 0 ? void 0 : theme.bgColor) || BG_COLOR,
                paper: (theme === null || theme === void 0 ? void 0 : theme.paperColor) || PAPER_COLOR
              }
            }
          };
        });
        const defaultSurveyTheme = exports('b9', {
          textStyles: {
            group: {
              font: "Google Sans",
              size: 26,
              color: TEXT_COLOR
            },
            question: {
              font: "Google Sans",
              size: 18,
              color: TEXT_COLOR
            },
            text: {
              font: "Google Sans",
              size: 14,
              color: TEXT_COLOR
            }
          },
          primaryColor: PRIMARY_COLOR,
          bgColor: BG_COLOR,
          paperColor: PAPER_COLOR
        });
        var axios$3 = {
          exports: {}
        };
        var bind$2 = function bind(fn, thisArg) {
          return function wrap() {
            var args = new Array(arguments.length);
            for (var i = 0; i < args.length; i++) {
              args[i] = arguments[i];
            }
            return fn.apply(thisArg, args);
          };
        };
        var bind$1 = bind$2;

        // utils is a library of generic helper functions non-specific to axios

        var toString = Object.prototype.toString;

        // eslint-disable-next-line func-names
        var kindOf = function (cache) {
          // eslint-disable-next-line func-names
          return function (thing) {
            var str = toString.call(thing);
            return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
          };
        }(Object.create(null));
        function kindOfTest(type) {
          type = type.toLowerCase();
          return function isKindOf(thing) {
            return kindOf(thing) === type;
          };
        }

        /**
         * Determine if a value is an Array
         *
         * @param {Object} val The value to test
         * @returns {boolean} True if value is an Array, otherwise false
         */
        function isArray(val) {
          return Array.isArray(val);
        }

        /**
         * Determine if a value is undefined
         *
         * @param {Object} val The value to test
         * @returns {boolean} True if the value is undefined, otherwise false
         */
        function isUndefined(val) {
          return typeof val === 'undefined';
        }

        /**
         * Determine if a value is a Buffer
         *
         * @param {Object} val The value to test
         * @returns {boolean} True if value is a Buffer, otherwise false
         */
        function isBuffer(val) {
          return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
        }

        /**
         * Determine if a value is an ArrayBuffer
         *
         * @function
         * @param {Object} val The value to test
         * @returns {boolean} True if value is an ArrayBuffer, otherwise false
         */
        var isArrayBuffer = kindOfTest('ArrayBuffer');

        /**
         * Determine if a value is a view on an ArrayBuffer
         *
         * @param {Object} val The value to test
         * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
         */
        function isArrayBufferView(val) {
          var result;
          if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
            result = ArrayBuffer.isView(val);
          } else {
            result = val && val.buffer && isArrayBuffer(val.buffer);
          }
          return result;
        }

        /**
         * Determine if a value is a String
         *
         * @param {Object} val The value to test
         * @returns {boolean} True if value is a String, otherwise false
         */
        function isString(val) {
          return typeof val === 'string';
        }

        /**
         * Determine if a value is a Number
         *
         * @param {Object} val The value to test
         * @returns {boolean} True if value is a Number, otherwise false
         */
        function isNumber(val) {
          return typeof val === 'number';
        }

        /**
         * Determine if a value is an Object
         *
         * @param {Object} val The value to test
         * @returns {boolean} True if value is an Object, otherwise false
         */
        function isObject(val) {
          return val !== null && typeof val === 'object';
        }

        /**
         * Determine if a value is a plain Object
         *
         * @param {Object} val The value to test
         * @return {boolean} True if value is a plain Object, otherwise false
         */
        function isPlainObject(val) {
          if (kindOf(val) !== 'object') {
            return false;
          }
          var prototype = Object.getPrototypeOf(val);
          return prototype === null || prototype === Object.prototype;
        }

        /**
         * Determine if a value is a Date
         *
         * @function
         * @param {Object} val The value to test
         * @returns {boolean} True if value is a Date, otherwise false
         */
        var isDate = kindOfTest('Date');

        /**
         * Determine if a value is a File
         *
         * @function
         * @param {Object} val The value to test
         * @returns {boolean} True if value is a File, otherwise false
         */
        var isFile = kindOfTest('File');

        /**
         * Determine if a value is a Blob
         *
         * @function
         * @param {Object} val The value to test
         * @returns {boolean} True if value is a Blob, otherwise false
         */
        var isBlob = kindOfTest('Blob');

        /**
         * Determine if a value is a FileList
         *
         * @function
         * @param {Object} val The value to test
         * @returns {boolean} True if value is a File, otherwise false
         */
        var isFileList = kindOfTest('FileList');

        /**
         * Determine if a value is a Function
         *
         * @param {Object} val The value to test
         * @returns {boolean} True if value is a Function, otherwise false
         */
        function isFunction(val) {
          return toString.call(val) === '[object Function]';
        }

        /**
         * Determine if a value is a Stream
         *
         * @param {Object} val The value to test
         * @returns {boolean} True if value is a Stream, otherwise false
         */
        function isStream(val) {
          return isObject(val) && isFunction(val.pipe);
        }

        /**
         * Determine if a value is a FormData
         *
         * @param {Object} thing The value to test
         * @returns {boolean} True if value is an FormData, otherwise false
         */
        function isFormData(thing) {
          var pattern = '[object FormData]';
          return thing && (typeof FormData === 'function' && thing instanceof FormData || toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
        }

        /**
         * Determine if a value is a URLSearchParams object
         * @function
         * @param {Object} val The value to test
         * @returns {boolean} True if value is a URLSearchParams object, otherwise false
         */
        var isURLSearchParams = kindOfTest('URLSearchParams');

        /**
         * Trim excess whitespace off the beginning and end of a string
         *
         * @param {String} str The String to trim
         * @returns {String} The String freed of excess whitespace
         */
        function trim(str) {
          return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
        }

        /**
         * Determine if we're running in a standard browser environment
         *
         * This allows axios to run in a web worker, and react-native.
         * Both environments support XMLHttpRequest, but not fully standard globals.
         *
         * web workers:
         *  typeof window -> undefined
         *  typeof document -> undefined
         *
         * react-native:
         *  navigator.product -> 'ReactNative'
         * nativescript
         *  navigator.product -> 'NativeScript' or 'NS'
         */
        function isStandardBrowserEnv() {
          if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) {
            return false;
          }
          return typeof window !== 'undefined' && typeof document !== 'undefined';
        }

        /**
         * Iterate over an Array or an Object invoking a function for each item.
         *
         * If `obj` is an Array callback will be called passing
         * the value, index, and complete array for each item.
         *
         * If 'obj' is an Object callback will be called passing
         * the value, key, and complete object for each property.
         *
         * @param {Object|Array} obj The object to iterate
         * @param {Function} fn The callback to invoke for each item
         */
        function forEach(obj, fn) {
          // Don't bother if no value provided
          if (obj === null || typeof obj === 'undefined') {
            return;
          }

          // Force an array if not already something iterable
          if (typeof obj !== 'object') {
            /*eslint no-param-reassign:0*/
            obj = [obj];
          }
          if (isArray(obj)) {
            // Iterate over array values
            for (var i = 0, l = obj.length; i < l; i++) {
              fn.call(null, obj[i], i, obj);
            }
          } else {
            // Iterate over object keys
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) {
                fn.call(null, obj[key], key, obj);
              }
            }
          }
        }

        /**
         * Accepts varargs expecting each argument to be an object, then
         * immutably merges the properties of each object and returns result.
         *
         * When multiple objects contain the same key the later object in
         * the arguments list will take precedence.
         *
         * Example:
         *
         * ```js
         * var result = merge({foo: 123}, {foo: 456});
         * console.log(result.foo); // outputs 456
         * ```
         *
         * @param {Object} obj1 Object to merge
         * @returns {Object} Result of all merge properties
         */
        function merge( /* obj1, obj2, obj3, ... */
        ) {
          var result = {};
          function assignValue(val, key) {
            if (isPlainObject(result[key]) && isPlainObject(val)) {
              result[key] = merge(result[key], val);
            } else if (isPlainObject(val)) {
              result[key] = merge({}, val);
            } else if (isArray(val)) {
              result[key] = val.slice();
            } else {
              result[key] = val;
            }
          }
          for (var i = 0, l = arguments.length; i < l; i++) {
            forEach(arguments[i], assignValue);
          }
          return result;
        }

        /**
         * Extends object a by mutably adding to it the properties of object b.
         *
         * @param {Object} a The object to be extended
         * @param {Object} b The object to copy properties from
         * @param {Object} thisArg The object to bind function to
         * @return {Object} The resulting value of object a
         */
        function extend(a, b, thisArg) {
          forEach(b, function assignValue(val, key) {
            if (thisArg && typeof val === 'function') {
              a[key] = bind$1(val, thisArg);
            } else {
              a[key] = val;
            }
          });
          return a;
        }

        /**
         * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
         *
         * @param {string} content with BOM
         * @return {string} content value without BOM
         */
        function stripBOM(content) {
          if (content.charCodeAt(0) === 0xFEFF) {
            content = content.slice(1);
          }
          return content;
        }

        /**
         * Inherit the prototype methods from one constructor into another
         * @param {function} constructor
         * @param {function} superConstructor
         * @param {object} [props]
         * @param {object} [descriptors]
         */

        function inherits(constructor, superConstructor, props, descriptors) {
          constructor.prototype = Object.create(superConstructor.prototype, descriptors);
          constructor.prototype.constructor = constructor;
          props && Object.assign(constructor.prototype, props);
        }

        /**
         * Resolve object with deep prototype chain to a flat object
         * @param {Object} sourceObj source object
         * @param {Object} [destObj]
         * @param {Function} [filter]
         * @returns {Object}
         */

        function toFlatObject(sourceObj, destObj, filter) {
          var props;
          var i;
          var prop;
          var merged = {};
          destObj = destObj || {};
          do {
            props = Object.getOwnPropertyNames(sourceObj);
            i = props.length;
            while (i-- > 0) {
              prop = props[i];
              if (!merged[prop]) {
                destObj[prop] = sourceObj[prop];
                merged[prop] = true;
              }
            }
            sourceObj = Object.getPrototypeOf(sourceObj);
          } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
          return destObj;
        }

        /*
         * determines whether a string ends with the characters of a specified string
         * @param {String} str
         * @param {String} searchString
         * @param {Number} [position= 0]
         * @returns {boolean}
         */
        function endsWith(str, searchString, position) {
          str = String(str);
          if (position === undefined || position > str.length) {
            position = str.length;
          }
          position -= searchString.length;
          var lastIndex = str.indexOf(searchString, position);
          return lastIndex !== -1 && lastIndex === position;
        }

        /**
         * Returns new array from array like object
         * @param {*} [thing]
         * @returns {Array}
         */
        function toArray(thing) {
          if (!thing) return null;
          var i = thing.length;
          if (isUndefined(i)) return null;
          var arr = new Array(i);
          while (i-- > 0) {
            arr[i] = thing[i];
          }
          return arr;
        }

        // eslint-disable-next-line func-names
        var isTypedArray = function (TypedArray) {
          // eslint-disable-next-line func-names
          return function (thing) {
            return TypedArray && thing instanceof TypedArray;
          };
        }(typeof Uint8Array !== 'undefined' && Object.getPrototypeOf(Uint8Array));
        var utils$b = {
          isArray: isArray,
          isArrayBuffer: isArrayBuffer,
          isBuffer: isBuffer,
          isFormData: isFormData,
          isArrayBufferView: isArrayBufferView,
          isString: isString,
          isNumber: isNumber,
          isObject: isObject,
          isPlainObject: isPlainObject,
          isUndefined: isUndefined,
          isDate: isDate,
          isFile: isFile,
          isBlob: isBlob,
          isFunction: isFunction,
          isStream: isStream,
          isURLSearchParams: isURLSearchParams,
          isStandardBrowserEnv: isStandardBrowserEnv,
          forEach: forEach,
          merge: merge,
          extend: extend,
          trim: trim,
          stripBOM: stripBOM,
          inherits: inherits,
          toFlatObject: toFlatObject,
          kindOf: kindOf,
          kindOfTest: kindOfTest,
          endsWith: endsWith,
          toArray: toArray,
          isTypedArray: isTypedArray,
          isFileList: isFileList
        };
        var utils$a = utils$b;
        function encode(val) {
          return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
        }

        /**
         * Build a URL by appending params to the end
         *
         * @param {string} url The base of the url (e.g., http://www.google.com)
         * @param {object} [params] The params to be appended
         * @returns {string} The formatted url
         */
        var buildURL$1 = function buildURL(url, params, paramsSerializer) {
          /*eslint no-param-reassign:0*/
          if (!params) {
            return url;
          }
          var serializedParams;
          if (paramsSerializer) {
            serializedParams = paramsSerializer(params);
          } else if (utils$a.isURLSearchParams(params)) {
            serializedParams = params.toString();
          } else {
            var parts = [];
            utils$a.forEach(params, function serialize(val, key) {
              if (val === null || typeof val === 'undefined') {
                return;
              }
              if (utils$a.isArray(val)) {
                key = key + '[]';
              } else {
                val = [val];
              }
              utils$a.forEach(val, function parseValue(v) {
                if (utils$a.isDate(v)) {
                  v = v.toISOString();
                } else if (utils$a.isObject(v)) {
                  v = JSON.stringify(v);
                }
                parts.push(encode(key) + '=' + encode(v));
              });
            });
            serializedParams = parts.join('&');
          }
          if (serializedParams) {
            var hashmarkIndex = url.indexOf('#');
            if (hashmarkIndex !== -1) {
              url = url.slice(0, hashmarkIndex);
            }
            url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
          }
          return url;
        };
        var utils$9 = utils$b;
        function InterceptorManager$1() {
          this.handlers = [];
        }

        /**
         * Add a new interceptor to the stack
         *
         * @param {Function} fulfilled The function to handle `then` for a `Promise`
         * @param {Function} rejected The function to handle `reject` for a `Promise`
         *
         * @return {Number} An ID used to remove interceptor later
         */
        InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
          this.handlers.push({
            fulfilled: fulfilled,
            rejected: rejected,
            synchronous: options ? options.synchronous : false,
            runWhen: options ? options.runWhen : null
          });
          return this.handlers.length - 1;
        };

        /**
         * Remove an interceptor from the stack
         *
         * @param {Number} id The ID that was returned by `use`
         */
        InterceptorManager$1.prototype.eject = function eject(id) {
          if (this.handlers[id]) {
            this.handlers[id] = null;
          }
        };

        /**
         * Iterate over all the registered interceptors
         *
         * This method is particularly useful for skipping over any
         * interceptors that may have become `null` calling `eject`.
         *
         * @param {Function} fn The function to call for each interceptor
         */
        InterceptorManager$1.prototype.forEach = function forEach(fn) {
          utils$9.forEach(this.handlers, function forEachHandler(h) {
            if (h !== null) {
              fn(h);
            }
          });
        };
        var InterceptorManager_1 = InterceptorManager$1;
        var utils$8 = utils$b;
        var normalizeHeaderName$1 = function normalizeHeaderName(headers, normalizedName) {
          utils$8.forEach(headers, function processHeader(value, name) {
            if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
              headers[normalizedName] = value;
              delete headers[name];
            }
          });
        };
        var utils$7 = utils$b;

        /**
         * Create an Error with the specified message, config, error code, request and response.
         *
         * @param {string} message The error message.
         * @param {string} [code] The error code (for example, 'ECONNABORTED').
         * @param {Object} [config] The config.
         * @param {Object} [request] The request.
         * @param {Object} [response] The response.
         * @returns {Error} The created error.
         */
        function AxiosError$2(message, code, config, request, response) {
          Error.call(this);
          this.message = message;
          this.name = 'AxiosError';
          code && (this.code = code);
          config && (this.config = config);
          request && (this.request = request);
          response && (this.response = response);
        }
        utils$7.inherits(AxiosError$2, Error, {
          toJSON: function toJSON() {
            return {
              // Standard
              message: this.message,
              name: this.name,
              // Microsoft
              description: this.description,
              number: this.number,
              // Mozilla
              fileName: this.fileName,
              lineNumber: this.lineNumber,
              columnNumber: this.columnNumber,
              stack: this.stack,
              // Axios
              config: this.config,
              code: this.code,
              status: this.response && this.response.status ? this.response.status : null
            };
          }
        });
        var prototype = AxiosError$2.prototype;
        var descriptors = {};
        ['ERR_BAD_OPTION_VALUE', 'ERR_BAD_OPTION', 'ECONNABORTED', 'ETIMEDOUT', 'ERR_NETWORK', 'ERR_FR_TOO_MANY_REDIRECTS', 'ERR_DEPRECATED', 'ERR_BAD_RESPONSE', 'ERR_BAD_REQUEST', 'ERR_CANCELED'
        // eslint-disable-next-line func-names
        ].forEach(function (code) {
          descriptors[code] = {
            value: code
          };
        });
        Object.defineProperties(AxiosError$2, descriptors);
        Object.defineProperty(prototype, 'isAxiosError', {
          value: true
        });

        // eslint-disable-next-line func-names
        AxiosError$2.from = function (error, code, config, request, response, customProps) {
          var axiosError = Object.create(prototype);
          utils$7.toFlatObject(error, axiosError, function filter(obj) {
            return obj !== Error.prototype;
          });
          AxiosError$2.call(axiosError, error.message, code, config, request, response);
          axiosError.name = error.name;
          customProps && Object.assign(axiosError, customProps);
          return axiosError;
        };
        var AxiosError_1 = AxiosError$2;
        var transitional = {
          silentJSONParsing: true,
          forcedJSONParsing: true,
          clarifyTimeoutError: false
        };
        var utils$6 = utils$b;

        /**
         * Convert a data object to FormData
         * @param {Object} obj
         * @param {?Object} [formData]
         * @returns {Object}
         **/

        function toFormData$1(obj, formData) {
          // eslint-disable-next-line no-param-reassign
          formData = formData || new FormData();
          var stack = [];
          function convertValue(value) {
            if (value === null) return '';
            if (utils$6.isDate(value)) {
              return value.toISOString();
            }
            if (utils$6.isArrayBuffer(value) || utils$6.isTypedArray(value)) {
              return typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
            }
            return value;
          }
          function build(data, parentKey) {
            if (utils$6.isPlainObject(data) || utils$6.isArray(data)) {
              if (stack.indexOf(data) !== -1) {
                throw Error('Circular reference detected in ' + parentKey);
              }
              stack.push(data);
              utils$6.forEach(data, function each(value, key) {
                if (utils$6.isUndefined(value)) return;
                var fullKey = parentKey ? parentKey + '.' + key : key;
                var arr;
                if (value && !parentKey && typeof value === 'object') {
                  if (utils$6.endsWith(key, '{}')) {
                    // eslint-disable-next-line no-param-reassign
                    value = JSON.stringify(value);
                  } else if (utils$6.endsWith(key, '[]') && (arr = utils$6.toArray(value))) {
                    // eslint-disable-next-line func-names
                    arr.forEach(function (el) {
                      !utils$6.isUndefined(el) && formData.append(fullKey, convertValue(el));
                    });
                    return;
                  }
                }
                build(value, fullKey);
              });
              stack.pop();
            } else {
              formData.append(parentKey, convertValue(data));
            }
          }
          build(obj);
          return formData;
        }
        var toFormData_1 = toFormData$1;
        var settle;
        var hasRequiredSettle;
        function requireSettle() {
          if (hasRequiredSettle) return settle;
          hasRequiredSettle = 1;
          var AxiosError = AxiosError_1;

          /**
           * Resolve or reject a Promise based on response status.
           *
           * @param {Function} resolve A function that resolves the promise.
           * @param {Function} reject A function that rejects the promise.
           * @param {object} response The response.
           */
          settle = function settle(resolve, reject, response) {
            var validateStatus = response.config.validateStatus;
            if (!response.status || !validateStatus || validateStatus(response.status)) {
              resolve(response);
            } else {
              reject(new AxiosError('Request failed with status code ' + response.status, [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
            }
          };
          return settle;
        }
        var cookies;
        var hasRequiredCookies;
        function requireCookies() {
          if (hasRequiredCookies) return cookies;
          hasRequiredCookies = 1;
          var utils = utils$b;
          cookies = utils.isStandardBrowserEnv() ?
          // Standard browser envs support document.cookie
          function standardBrowserEnv() {
            return {
              write: function write(name, value, expires, path, domain, secure) {
                var cookie = [];
                cookie.push(name + '=' + encodeURIComponent(value));
                if (utils.isNumber(expires)) {
                  cookie.push('expires=' + new Date(expires).toGMTString());
                }
                if (utils.isString(path)) {
                  cookie.push('path=' + path);
                }
                if (utils.isString(domain)) {
                  cookie.push('domain=' + domain);
                }
                if (secure === true) {
                  cookie.push('secure');
                }
                document.cookie = cookie.join('; ');
              },
              read: function read(name) {
                var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
                return match ? decodeURIComponent(match[3]) : null;
              },
              remove: function remove(name) {
                this.write(name, '', Date.now() - 86400000);
              }
            };
          }() :
          // Non standard browser env (web workers, react-native) lack needed support.
          function nonStandardBrowserEnv() {
            return {
              write: function write() {},
              read: function read() {
                return null;
              },
              remove: function remove() {}
            };
          }();
          return cookies;
        }

        /**
         * Determines whether the specified URL is absolute
         *
         * @param {string} url The URL to test
         * @returns {boolean} True if the specified URL is absolute, otherwise false
         */
        var isAbsoluteURL$1 = function isAbsoluteURL(url) {
          // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
          // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
          // by any combination of letters, digits, plus, period, or hyphen.
          return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
        };

        /**
         * Creates a new URL by combining the specified URLs
         *
         * @param {string} baseURL The base URL
         * @param {string} relativeURL The relative URL
         * @returns {string} The combined URL
         */
        var combineURLs$1 = function combineURLs(baseURL, relativeURL) {
          return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
        };
        var isAbsoluteURL = isAbsoluteURL$1;
        var combineURLs = combineURLs$1;

        /**
         * Creates a new URL by combining the baseURL with the requestedURL,
         * only when the requestedURL is not already an absolute URL.
         * If the requestURL is absolute, this function returns the requestedURL untouched.
         *
         * @param {string} baseURL The base URL
         * @param {string} requestedURL Absolute or relative URL to combine
         * @returns {string} The combined full path
         */
        var buildFullPath$1 = function buildFullPath(baseURL, requestedURL) {
          if (baseURL && !isAbsoluteURL(requestedURL)) {
            return combineURLs(baseURL, requestedURL);
          }
          return requestedURL;
        };
        var parseHeaders;
        var hasRequiredParseHeaders;
        function requireParseHeaders() {
          if (hasRequiredParseHeaders) return parseHeaders;
          hasRequiredParseHeaders = 1;
          var utils = utils$b;

          // Headers whose duplicates are ignored by node
          // c.f. https://nodejs.org/api/http.html#http_message_headers
          var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];

          /**
           * Parse headers into an object
           *
           * ```
           * Date: Wed, 27 Aug 2014 08:58:49 GMT
           * Content-Type: application/json
           * Connection: keep-alive
           * Transfer-Encoding: chunked
           * ```
           *
           * @param {String} headers Headers needing to be parsed
           * @returns {Object} Headers parsed into an object
           */
          parseHeaders = function parseHeaders(headers) {
            var parsed = {};
            var key;
            var val;
            var i;
            if (!headers) {
              return parsed;
            }
            utils.forEach(headers.split('\n'), function parser(line) {
              i = line.indexOf(':');
              key = utils.trim(line.substr(0, i)).toLowerCase();
              val = utils.trim(line.substr(i + 1));
              if (key) {
                if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
                  return;
                }
                if (key === 'set-cookie') {
                  parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
                } else {
                  parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
                }
              }
            });
            return parsed;
          };
          return parseHeaders;
        }
        var isURLSameOrigin;
        var hasRequiredIsURLSameOrigin;
        function requireIsURLSameOrigin() {
          if (hasRequiredIsURLSameOrigin) return isURLSameOrigin;
          hasRequiredIsURLSameOrigin = 1;
          var utils = utils$b;
          isURLSameOrigin = utils.isStandardBrowserEnv() ?
          // Standard browser envs have full support of the APIs needed to test
          // whether the request URL is of the same origin as current location.
          function standardBrowserEnv() {
            var msie = /(msie|trident)/i.test(navigator.userAgent);
            var urlParsingNode = document.createElement('a');
            var originURL;

            /**
            * Parse a URL to discover it's components
            *
            * @param {String} url The URL to be parsed
            * @returns {Object}
            */
            function resolveURL(url) {
              var href = url;
              if (msie) {
                // IE needs attribute set twice to normalize properties
                urlParsingNode.setAttribute('href', href);
                href = urlParsingNode.href;
              }
              urlParsingNode.setAttribute('href', href);

              // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
              return {
                href: urlParsingNode.href,
                protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
                host: urlParsingNode.host,
                search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
                hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
                hostname: urlParsingNode.hostname,
                port: urlParsingNode.port,
                pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
              };
            }
            originURL = resolveURL(window.location.href);

            /**
            * Determine if a URL shares the same origin as the current location
            *
            * @param {String} requestURL The URL to test
            * @returns {boolean} True if URL shares the same origin, otherwise false
            */
            return function isURLSameOrigin(requestURL) {
              var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
              return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
            };
          }() :
          // Non standard browser envs (web workers, react-native) lack needed support.
          function nonStandardBrowserEnv() {
            return function isURLSameOrigin() {
              return true;
            };
          }();
          return isURLSameOrigin;
        }
        var CanceledError_1;
        var hasRequiredCanceledError;
        function requireCanceledError() {
          if (hasRequiredCanceledError) return CanceledError_1;
          hasRequiredCanceledError = 1;
          var AxiosError = AxiosError_1;
          var utils = utils$b;

          /**
           * A `CanceledError` is an object that is thrown when an operation is canceled.
           *
           * @class
           * @param {string=} message The message.
           */
          function CanceledError(message) {
            // eslint-disable-next-line no-eq-null,eqeqeq
            AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED);
            this.name = 'CanceledError';
          }
          utils.inherits(CanceledError, AxiosError, {
            __CANCEL__: true
          });
          CanceledError_1 = CanceledError;
          return CanceledError_1;
        }
        var parseProtocol;
        var hasRequiredParseProtocol;
        function requireParseProtocol() {
          if (hasRequiredParseProtocol) return parseProtocol;
          hasRequiredParseProtocol = 1;
          parseProtocol = function parseProtocol(url) {
            var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
            return match && match[1] || '';
          };
          return parseProtocol;
        }
        var xhr;
        var hasRequiredXhr;
        function requireXhr() {
          if (hasRequiredXhr) return xhr;
          hasRequiredXhr = 1;
          var utils = utils$b;
          var settle = requireSettle();
          var cookies = requireCookies();
          var buildURL = buildURL$1;
          var buildFullPath = buildFullPath$1;
          var parseHeaders = requireParseHeaders();
          var isURLSameOrigin = requireIsURLSameOrigin();
          var transitionalDefaults = transitional;
          var AxiosError = AxiosError_1;
          var CanceledError = requireCanceledError();
          var parseProtocol = requireParseProtocol();
          xhr = function xhrAdapter(config) {
            return new Promise(function dispatchXhrRequest(resolve, reject) {
              var requestData = config.data;
              var requestHeaders = config.headers;
              var responseType = config.responseType;
              var onCanceled;
              function done() {
                if (config.cancelToken) {
                  config.cancelToken.unsubscribe(onCanceled);
                }
                if (config.signal) {
                  config.signal.removeEventListener('abort', onCanceled);
                }
              }
              if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {
                delete requestHeaders['Content-Type']; // Let the browser set it
              }

              var request = new XMLHttpRequest();

              // HTTP basic authentication
              if (config.auth) {
                var username = config.auth.username || '';
                var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
                requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
              }
              var fullPath = buildFullPath(config.baseURL, config.url);
              request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

              // Set the request timeout in MS
              request.timeout = config.timeout;
              function onloadend() {
                if (!request) {
                  return;
                }
                // Prepare the response
                var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
                var responseData = !responseType || responseType === 'text' || responseType === 'json' ? request.responseText : request.response;
                var response = {
                  data: responseData,
                  status: request.status,
                  statusText: request.statusText,
                  headers: responseHeaders,
                  config: config,
                  request: request
                };
                settle(function _resolve(value) {
                  resolve(value);
                  done();
                }, function _reject(err) {
                  reject(err);
                  done();
                }, response);

                // Clean up request
                request = null;
              }
              if ('onloadend' in request) {
                // Use onloadend if available
                request.onloadend = onloadend;
              } else {
                // Listen for ready state to emulate onloadend
                request.onreadystatechange = function handleLoad() {
                  if (!request || request.readyState !== 4) {
                    return;
                  }

                  // The request errored out and we didn't get a response, this will be
                  // handled by onerror instead
                  // With one exception: request that using file: protocol, most browsers
                  // will return status as 0 even though it's a successful request
                  if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
                    return;
                  }
                  // readystate handler is calling before onerror or ontimeout handlers,
                  // so we should call onloadend on the next 'tick'
                  setTimeout(onloadend);
                };
              }

              // Handle browser request cancellation (as opposed to a manual cancellation)
              request.onabort = function handleAbort() {
                if (!request) {
                  return;
                }
                reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

                // Clean up request
                request = null;
              };

              // Handle low level network errors
              request.onerror = function handleError() {
                // Real errors are hidden from us by the browser
                // onerror should only fire if it's a network error
                reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request, request));

                // Clean up request
                request = null;
              };

              // Handle timeout
              request.ontimeout = function handleTimeout() {
                var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
                var transitional = config.transitional || transitionalDefaults;
                if (config.timeoutErrorMessage) {
                  timeoutErrorMessage = config.timeoutErrorMessage;
                }
                reject(new AxiosError(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, config, request));

                // Clean up request
                request = null;
              };

              // Add xsrf header
              // This is only done if running in a standard browser environment.
              // Specifically not if we're in a web worker, or react-native.
              if (utils.isStandardBrowserEnv()) {
                // Add xsrf header
                var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;
                if (xsrfValue) {
                  requestHeaders[config.xsrfHeaderName] = xsrfValue;
                }
              }

              // Add headers to the request
              if ('setRequestHeader' in request) {
                utils.forEach(requestHeaders, function setRequestHeader(val, key) {
                  if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
                    // Remove Content-Type if data is undefined
                    delete requestHeaders[key];
                  } else {
                    // Otherwise add header to the request
                    request.setRequestHeader(key, val);
                  }
                });
              }

              // Add withCredentials to request if needed
              if (!utils.isUndefined(config.withCredentials)) {
                request.withCredentials = !!config.withCredentials;
              }

              // Add responseType to request if needed
              if (responseType && responseType !== 'json') {
                request.responseType = config.responseType;
              }

              // Handle progress if needed
              if (typeof config.onDownloadProgress === 'function') {
                request.addEventListener('progress', config.onDownloadProgress);
              }

              // Not all browsers support upload events
              if (typeof config.onUploadProgress === 'function' && request.upload) {
                request.upload.addEventListener('progress', config.onUploadProgress);
              }
              if (config.cancelToken || config.signal) {
                // Handle cancellation
                // eslint-disable-next-line func-names
                onCanceled = function (cancel) {
                  if (!request) {
                    return;
                  }
                  reject(!cancel || cancel && cancel.type ? new CanceledError() : cancel);
                  request.abort();
                  request = null;
                };
                config.cancelToken && config.cancelToken.subscribe(onCanceled);
                if (config.signal) {
                  config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
                }
              }
              if (!requestData) {
                requestData = null;
              }
              var protocol = parseProtocol(fullPath);
              if (protocol && ['http', 'https', 'file'].indexOf(protocol) === -1) {
                reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
                return;
              }

              // Send the request
              request.send(requestData);
            });
          };
          return xhr;
        }
        var _null;
        var hasRequired_null;
        function require_null() {
          if (hasRequired_null) return _null;
          hasRequired_null = 1;
          // eslint-disable-next-line strict
          _null = null;
          return _null;
        }
        var utils$5 = utils$b;
        var normalizeHeaderName = normalizeHeaderName$1;
        var AxiosError$1 = AxiosError_1;
        var transitionalDefaults = transitional;
        var toFormData = toFormData_1;
        var DEFAULT_CONTENT_TYPE = {
          'Content-Type': 'application/x-www-form-urlencoded'
        };
        function setContentTypeIfUnset(headers, value) {
          if (!utils$5.isUndefined(headers) && utils$5.isUndefined(headers['Content-Type'])) {
            headers['Content-Type'] = value;
          }
        }
        function getDefaultAdapter() {
          var adapter;
          if (typeof XMLHttpRequest !== 'undefined') {
            // For browsers use XHR adapter
            adapter = requireXhr();
          } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
            // For node use HTTP adapter
            adapter = requireXhr();
          }
          return adapter;
        }
        function stringifySafely(rawValue, parser, encoder) {
          if (utils$5.isString(rawValue)) {
            try {
              (parser || JSON.parse)(rawValue);
              return utils$5.trim(rawValue);
            } catch (e) {
              if (e.name !== 'SyntaxError') {
                throw e;
              }
            }
          }
          return (encoder || JSON.stringify)(rawValue);
        }
        var defaults$3 = {
          transitional: transitionalDefaults,
          adapter: getDefaultAdapter(),
          transformRequest: [function transformRequest(data, headers) {
            normalizeHeaderName(headers, 'Accept');
            normalizeHeaderName(headers, 'Content-Type');
            if (utils$5.isFormData(data) || utils$5.isArrayBuffer(data) || utils$5.isBuffer(data) || utils$5.isStream(data) || utils$5.isFile(data) || utils$5.isBlob(data)) {
              return data;
            }
            if (utils$5.isArrayBufferView(data)) {
              return data.buffer;
            }
            if (utils$5.isURLSearchParams(data)) {
              setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
              return data.toString();
            }
            var isObjectPayload = utils$5.isObject(data);
            var contentType = headers && headers['Content-Type'];
            var isFileList;
            if ((isFileList = utils$5.isFileList(data)) || isObjectPayload && contentType === 'multipart/form-data') {
              var _FormData = this.env && this.env.FormData;
              return toFormData(isFileList ? {
                'files[]': data
              } : data, _FormData && new _FormData());
            } else if (isObjectPayload || contentType === 'application/json') {
              setContentTypeIfUnset(headers, 'application/json');
              return stringifySafely(data);
            }
            return data;
          }],
          transformResponse: [function transformResponse(data) {
            var transitional = this.transitional || defaults$3.transitional;
            var silentJSONParsing = transitional && transitional.silentJSONParsing;
            var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
            var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';
            if (strictJSONParsing || forcedJSONParsing && utils$5.isString(data) && data.length) {
              try {
                return JSON.parse(data);
              } catch (e) {
                if (strictJSONParsing) {
                  if (e.name === 'SyntaxError') {
                    throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
                  }
                  throw e;
                }
              }
            }
            return data;
          }],
          /**
           * A timeout in milliseconds to abort a request. If set to 0 (default) a
           * timeout is not created.
           */
          timeout: 0,
          xsrfCookieName: 'XSRF-TOKEN',
          xsrfHeaderName: 'X-XSRF-TOKEN',
          maxContentLength: -1,
          maxBodyLength: -1,
          env: {
            FormData: require_null()
          },
          validateStatus: function validateStatus(status) {
            return status >= 200 && status < 300;
          },
          headers: {
            common: {
              'Accept': 'application/json, text/plain, */*'
            }
          }
        };
        utils$5.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
          defaults$3.headers[method] = {};
        });
        utils$5.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
          defaults$3.headers[method] = utils$5.merge(DEFAULT_CONTENT_TYPE);
        });
        var defaults_1 = defaults$3;
        var utils$4 = utils$b;
        var defaults$2 = defaults_1;

        /**
         * Transform the data for a request or a response
         *
         * @param {Object|String} data The data to be transformed
         * @param {Array} headers The headers for the request or response
         * @param {Array|Function} fns A single function or Array of functions
         * @returns {*} The resulting transformed data
         */
        var transformData$1 = function transformData(data, headers, fns) {
          var context = this || defaults$2;
          /*eslint no-param-reassign:0*/
          utils$4.forEach(fns, function transform(fn) {
            data = fn.call(context, data, headers);
          });
          return data;
        };
        var isCancel$1;
        var hasRequiredIsCancel;
        function requireIsCancel() {
          if (hasRequiredIsCancel) return isCancel$1;
          hasRequiredIsCancel = 1;
          isCancel$1 = function isCancel(value) {
            return !!(value && value.__CANCEL__);
          };
          return isCancel$1;
        }
        var utils$3 = utils$b;
        var transformData = transformData$1;
        var isCancel = requireIsCancel();
        var defaults$1 = defaults_1;
        var CanceledError = requireCanceledError();

        /**
         * Throws a `CanceledError` if cancellation has been requested.
         */
        function throwIfCancellationRequested(config) {
          if (config.cancelToken) {
            config.cancelToken.throwIfRequested();
          }
          if (config.signal && config.signal.aborted) {
            throw new CanceledError();
          }
        }

        /**
         * Dispatch a request to the server using the configured adapter.
         *
         * @param {object} config The config that is to be used for the request
         * @returns {Promise} The Promise to be fulfilled
         */
        var dispatchRequest$1 = function dispatchRequest(config) {
          throwIfCancellationRequested(config);

          // Ensure headers exist
          config.headers = config.headers || {};

          // Transform request data
          config.data = transformData.call(config, config.data, config.headers, config.transformRequest);

          // Flatten headers
          config.headers = utils$3.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
          utils$3.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
            delete config.headers[method];
          });
          var adapter = config.adapter || defaults$1.adapter;
          return adapter(config).then(function onAdapterResolution(response) {
            throwIfCancellationRequested(config);

            // Transform response data
            response.data = transformData.call(config, response.data, response.headers, config.transformResponse);
            return response;
          }, function onAdapterRejection(reason) {
            if (!isCancel(reason)) {
              throwIfCancellationRequested(config);

              // Transform response data
              if (reason && reason.response) {
                reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);
              }
            }
            return Promise.reject(reason);
          });
        };
        var utils$2 = utils$b;

        /**
         * Config-specific merge-function which creates a new config-object
         * by merging two configuration objects together.
         *
         * @param {Object} config1
         * @param {Object} config2
         * @returns {Object} New object resulting from merging config2 to config1
         */
        var mergeConfig$2 = function mergeConfig(config1, config2) {
          // eslint-disable-next-line no-param-reassign
          config2 = config2 || {};
          var config = {};
          function getMergedValue(target, source) {
            if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source)) {
              return utils$2.merge(target, source);
            } else if (utils$2.isPlainObject(source)) {
              return utils$2.merge({}, source);
            } else if (utils$2.isArray(source)) {
              return source.slice();
            }
            return source;
          }

          // eslint-disable-next-line consistent-return
          function mergeDeepProperties(prop) {
            if (!utils$2.isUndefined(config2[prop])) {
              return getMergedValue(config1[prop], config2[prop]);
            } else if (!utils$2.isUndefined(config1[prop])) {
              return getMergedValue(undefined, config1[prop]);
            }
          }

          // eslint-disable-next-line consistent-return
          function valueFromConfig2(prop) {
            if (!utils$2.isUndefined(config2[prop])) {
              return getMergedValue(undefined, config2[prop]);
            }
          }

          // eslint-disable-next-line consistent-return
          function defaultToConfig2(prop) {
            if (!utils$2.isUndefined(config2[prop])) {
              return getMergedValue(undefined, config2[prop]);
            } else if (!utils$2.isUndefined(config1[prop])) {
              return getMergedValue(undefined, config1[prop]);
            }
          }

          // eslint-disable-next-line consistent-return
          function mergeDirectKeys(prop) {
            if (prop in config2) {
              return getMergedValue(config1[prop], config2[prop]);
            } else if (prop in config1) {
              return getMergedValue(undefined, config1[prop]);
            }
          }
          var mergeMap = {
            'url': valueFromConfig2,
            'method': valueFromConfig2,
            'data': valueFromConfig2,
            'baseURL': defaultToConfig2,
            'transformRequest': defaultToConfig2,
            'transformResponse': defaultToConfig2,
            'paramsSerializer': defaultToConfig2,
            'timeout': defaultToConfig2,
            'timeoutMessage': defaultToConfig2,
            'withCredentials': defaultToConfig2,
            'adapter': defaultToConfig2,
            'responseType': defaultToConfig2,
            'xsrfCookieName': defaultToConfig2,
            'xsrfHeaderName': defaultToConfig2,
            'onUploadProgress': defaultToConfig2,
            'onDownloadProgress': defaultToConfig2,
            'decompress': defaultToConfig2,
            'maxContentLength': defaultToConfig2,
            'maxBodyLength': defaultToConfig2,
            'beforeRedirect': defaultToConfig2,
            'transport': defaultToConfig2,
            'httpAgent': defaultToConfig2,
            'httpsAgent': defaultToConfig2,
            'cancelToken': defaultToConfig2,
            'socketPath': defaultToConfig2,
            'responseEncoding': defaultToConfig2,
            'validateStatus': mergeDirectKeys
          };
          utils$2.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
            var merge = mergeMap[prop] || mergeDeepProperties;
            var configValue = merge(prop);
            utils$2.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
          });
          return config;
        };
        var data;
        var hasRequiredData;
        function requireData() {
          if (hasRequiredData) return data;
          hasRequiredData = 1;
          data = {
            "version": "0.27.2"
          };
          return data;
        }
        var VERSION = requireData().version;
        var AxiosError = AxiosError_1;
        var validators$1 = {};

        // eslint-disable-next-line func-names
        ['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function (type, i) {
          validators$1[type] = function validator(thing) {
            return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
          };
        });
        var deprecatedWarnings = {};

        /**
         * Transitional option validator
         * @param {function|boolean?} validator - set to false if the transitional option has been removed
         * @param {string?} version - deprecated version / removed since version
         * @param {string?} message - some message with additional info
         * @returns {function}
         */
        validators$1.transitional = function transitional(validator, version, message) {
          function formatMessage(opt, desc) {
            return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
          }

          // eslint-disable-next-line func-names
          return function (value, opt, opts) {
            if (validator === false) {
              throw new AxiosError(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')), AxiosError.ERR_DEPRECATED);
            }
            if (version && !deprecatedWarnings[opt]) {
              deprecatedWarnings[opt] = true;
              // eslint-disable-next-line no-console
              console.warn(formatMessage(opt, ' has been deprecated since v' + version + ' and will be removed in the near future'));
            }
            return validator ? validator(value, opt, opts) : true;
          };
        };

        /**
         * Assert object's properties type
         * @param {object} options
         * @param {object} schema
         * @param {boolean?} allowUnknown
         */

        function assertOptions(options, schema, allowUnknown) {
          if (typeof options !== 'object') {
            throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
          }
          var keys = Object.keys(options);
          var i = keys.length;
          while (i-- > 0) {
            var opt = keys[i];
            var validator = schema[opt];
            if (validator) {
              var value = options[opt];
              var result = value === undefined || validator(value, opt, options);
              if (result !== true) {
                throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
              }
              continue;
            }
            if (allowUnknown !== true) {
              throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
            }
          }
        }
        var validator$1 = {
          assertOptions: assertOptions,
          validators: validators$1
        };
        var utils$1 = utils$b;
        var buildURL = buildURL$1;
        var InterceptorManager = InterceptorManager_1;
        var dispatchRequest = dispatchRequest$1;
        var mergeConfig$1 = mergeConfig$2;
        var buildFullPath = buildFullPath$1;
        var validator = validator$1;
        var validators = validator.validators;
        /**
         * Create a new instance of Axios
         *
         * @param {Object} instanceConfig The default config for the instance
         */
        function Axios$1(instanceConfig) {
          this.defaults = instanceConfig;
          this.interceptors = {
            request: new InterceptorManager(),
            response: new InterceptorManager()
          };
        }

        /**
         * Dispatch a request
         *
         * @param {Object} config The config specific for this request (merged with this.defaults)
         */
        Axios$1.prototype.request = function request(configOrUrl, config) {
          /*eslint no-param-reassign:0*/
          // Allow for axios('example/url'[, config]) a la fetch API
          if (typeof configOrUrl === 'string') {
            config = config || {};
            config.url = configOrUrl;
          } else {
            config = configOrUrl || {};
          }
          config = mergeConfig$1(this.defaults, config);

          // Set config.method
          if (config.method) {
            config.method = config.method.toLowerCase();
          } else if (this.defaults.method) {
            config.method = this.defaults.method.toLowerCase();
          } else {
            config.method = 'get';
          }
          var transitional = config.transitional;
          if (transitional !== undefined) {
            validator.assertOptions(transitional, {
              silentJSONParsing: validators.transitional(validators.boolean),
              forcedJSONParsing: validators.transitional(validators.boolean),
              clarifyTimeoutError: validators.transitional(validators.boolean)
            }, false);
          }

          // filter out skipped interceptors
          var requestInterceptorChain = [];
          var synchronousRequestInterceptors = true;
          this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
            if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
              return;
            }
            synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
            requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
          });
          var responseInterceptorChain = [];
          this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
            responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
          });
          var promise;
          if (!synchronousRequestInterceptors) {
            var chain = [dispatchRequest, undefined];
            Array.prototype.unshift.apply(chain, requestInterceptorChain);
            chain = chain.concat(responseInterceptorChain);
            promise = Promise.resolve(config);
            while (chain.length) {
              promise = promise.then(chain.shift(), chain.shift());
            }
            return promise;
          }
          var newConfig = config;
          while (requestInterceptorChain.length) {
            var onFulfilled = requestInterceptorChain.shift();
            var onRejected = requestInterceptorChain.shift();
            try {
              newConfig = onFulfilled(newConfig);
            } catch (error) {
              onRejected(error);
              break;
            }
          }
          try {
            promise = dispatchRequest(newConfig);
          } catch (error) {
            return Promise.reject(error);
          }
          while (responseInterceptorChain.length) {
            promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
          }
          return promise;
        };
        Axios$1.prototype.getUri = function getUri(config) {
          config = mergeConfig$1(this.defaults, config);
          var fullPath = buildFullPath(config.baseURL, config.url);
          return buildURL(fullPath, config.params, config.paramsSerializer);
        };

        // Provide aliases for supported request methods
        utils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
          /*eslint func-names:0*/
          Axios$1.prototype[method] = function (url, config) {
            return this.request(mergeConfig$1(config || {}, {
              method: method,
              url: url,
              data: (config || {}).data
            }));
          };
        });
        utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
          /*eslint func-names:0*/

          function generateHTTPMethod(isForm) {
            return function httpMethod(url, data, config) {
              return this.request(mergeConfig$1(config || {}, {
                method: method,
                headers: isForm ? {
                  'Content-Type': 'multipart/form-data'
                } : {},
                url: url,
                data: data
              }));
            };
          }
          Axios$1.prototype[method] = generateHTTPMethod();
          Axios$1.prototype[method + 'Form'] = generateHTTPMethod(true);
        });
        var Axios_1 = Axios$1;
        var CancelToken_1;
        var hasRequiredCancelToken;
        function requireCancelToken() {
          if (hasRequiredCancelToken) return CancelToken_1;
          hasRequiredCancelToken = 1;
          var CanceledError = requireCanceledError();

          /**
           * A `CancelToken` is an object that can be used to request cancellation of an operation.
           *
           * @class
           * @param {Function} executor The executor function.
           */
          function CancelToken(executor) {
            if (typeof executor !== 'function') {
              throw new TypeError('executor must be a function.');
            }
            var resolvePromise;
            this.promise = new Promise(function promiseExecutor(resolve) {
              resolvePromise = resolve;
            });
            var token = this;

            // eslint-disable-next-line func-names
            this.promise.then(function (cancel) {
              if (!token._listeners) return;
              var i;
              var l = token._listeners.length;
              for (i = 0; i < l; i++) {
                token._listeners[i](cancel);
              }
              token._listeners = null;
            });

            // eslint-disable-next-line func-names
            this.promise.then = function (onfulfilled) {
              var _resolve;
              // eslint-disable-next-line func-names
              var promise = new Promise(function (resolve) {
                token.subscribe(resolve);
                _resolve = resolve;
              }).then(onfulfilled);
              promise.cancel = function reject() {
                token.unsubscribe(_resolve);
              };
              return promise;
            };
            executor(function cancel(message) {
              if (token.reason) {
                // Cancellation has already been requested
                return;
              }
              token.reason = new CanceledError(message);
              resolvePromise(token.reason);
            });
          }

          /**
           * Throws a `CanceledError` if cancellation has been requested.
           */
          CancelToken.prototype.throwIfRequested = function throwIfRequested() {
            if (this.reason) {
              throw this.reason;
            }
          };

          /**
           * Subscribe to the cancel signal
           */

          CancelToken.prototype.subscribe = function subscribe(listener) {
            if (this.reason) {
              listener(this.reason);
              return;
            }
            if (this._listeners) {
              this._listeners.push(listener);
            } else {
              this._listeners = [listener];
            }
          };

          /**
           * Unsubscribe from the cancel signal
           */

          CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
            if (!this._listeners) {
              return;
            }
            var index = this._listeners.indexOf(listener);
            if (index !== -1) {
              this._listeners.splice(index, 1);
            }
          };

          /**
           * Returns an object that contains a new `CancelToken` and a function that, when called,
           * cancels the `CancelToken`.
           */
          CancelToken.source = function source() {
            var cancel;
            var token = new CancelToken(function executor(c) {
              cancel = c;
            });
            return {
              token: token,
              cancel: cancel
            };
          };
          CancelToken_1 = CancelToken;
          return CancelToken_1;
        }
        var spread;
        var hasRequiredSpread;
        function requireSpread() {
          if (hasRequiredSpread) return spread;
          hasRequiredSpread = 1;

          /**
           * Syntactic sugar for invoking a function and expanding an array for arguments.
           *
           * Common use case would be to use `Function.prototype.apply`.
           *
           *  ```js
           *  function f(x, y, z) {}
           *  var args = [1, 2, 3];
           *  f.apply(null, args);
           *  ```
           *
           * With `spread` this example can be re-written.
           *
           *  ```js
           *  spread(function(x, y, z) {})([1, 2, 3]);
           *  ```
           *
           * @param {Function} callback
           * @returns {Function}
           */
          spread = function spread(callback) {
            return function wrap(arr) {
              return callback.apply(null, arr);
            };
          };
          return spread;
        }
        var isAxiosError;
        var hasRequiredIsAxiosError;
        function requireIsAxiosError() {
          if (hasRequiredIsAxiosError) return isAxiosError;
          hasRequiredIsAxiosError = 1;
          var utils = utils$b;

          /**
           * Determines whether the payload is an error thrown by Axios
           *
           * @param {*} payload The value to test
           * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
           */
          isAxiosError = function isAxiosError(payload) {
            return utils.isObject(payload) && payload.isAxiosError === true;
          };
          return isAxiosError;
        }
        var utils = utils$b;
        var bind = bind$2;
        var Axios = Axios_1;
        var mergeConfig = mergeConfig$2;
        var defaults = defaults_1;

        /**
         * Create an instance of Axios
         *
         * @param {Object} defaultConfig The default config for the instance
         * @return {Axios} A new instance of Axios
         */
        function createInstance(defaultConfig) {
          var context = new Axios(defaultConfig);
          var instance = bind(Axios.prototype.request, context);

          // Copy axios.prototype to instance
          utils.extend(instance, Axios.prototype, context);

          // Copy context to instance
          utils.extend(instance, context);

          // Factory for creating new instances
          instance.create = function create(instanceConfig) {
            return createInstance(mergeConfig(defaultConfig, instanceConfig));
          };
          return instance;
        }

        // Create the default instance to be exported
        var axios$2 = createInstance(defaults);

        // Expose Axios class to allow class inheritance
        axios$2.Axios = Axios;

        // Expose Cancel & CancelToken
        axios$2.CanceledError = requireCanceledError();
        axios$2.CancelToken = requireCancelToken();
        axios$2.isCancel = requireIsCancel();
        axios$2.VERSION = requireData().version;
        axios$2.toFormData = toFormData_1;

        // Expose AxiosError class
        axios$2.AxiosError = AxiosError_1;

        // alias for CanceledError for backward compatibility
        axios$2.Cancel = axios$2.CanceledError;

        // Expose all/spread
        axios$2.all = function all(promises) {
          return Promise.all(promises);
        };
        axios$2.spread = requireSpread();

        // Expose isAxiosError
        axios$2.isAxiosError = requireIsAxiosError();
        axios$3.exports = axios$2;

        // Allow use of default import syntax in TypeScript
        axios$3.exports.default = axios$2;
        var axiosExports = axios$3.exports;
        var axios = axiosExports;
        const axios$1 = /*@__PURE__*/getDefaultExportFromCjs(axios);
        const FRONT_END_HOST = exports('F', "frankie.localhost:3000");
        const FRONT_END_DOMAIN = "frankie.localhost:3000".split(":")[0];
        const PROTOCOL = exports('E', "http");
        const BACKEND_BASE_URL = exports('bO', `${"http"}://${"localhost:8080"}`);

        /*! js-cookie v3.0.5 | MIT */
        /* eslint-disable no-var */
        function assign(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              target[key] = source[key];
            }
          }
          return target;
        }
        /* eslint-enable no-var */

        /* eslint-disable no-var */
        var defaultConverter = {
          read: function (value) {
            if (value[0] === '"') {
              value = value.slice(1, -1);
            }
            return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
          },
          write: function (value) {
            return encodeURIComponent(value).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g, decodeURIComponent);
          }
        };
        /* eslint-enable no-var */

        /* eslint-disable no-var */

        function init(converter, defaultAttributes) {
          function set(name, value, attributes) {
            if (typeof document === 'undefined') {
              return;
            }
            attributes = assign({}, defaultAttributes, attributes);
            if (typeof attributes.expires === 'number') {
              attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
            }
            if (attributes.expires) {
              attributes.expires = attributes.expires.toUTCString();
            }
            name = encodeURIComponent(name).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
            var stringifiedAttributes = '';
            for (var attributeName in attributes) {
              if (!attributes[attributeName]) {
                continue;
              }
              stringifiedAttributes += '; ' + attributeName;
              if (attributes[attributeName] === true) {
                continue;
              }

              // Considers RFC 6265 section 5.2:
              // ...
              // 3.  If the remaining unparsed-attributes contains a %x3B (";")
              //     character:
              // Consume the characters of the unparsed-attributes up to,
              // not including, the first %x3B (";") character.
              // ...
              stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
            }
            return document.cookie = name + '=' + converter.write(value, name) + stringifiedAttributes;
          }
          function get(name) {
            if (typeof document === 'undefined' || arguments.length && !name) {
              return;
            }

            // To prevent the for loop in the first place assign an empty array
            // in case there are no cookies at all.
            var cookies = document.cookie ? document.cookie.split('; ') : [];
            var jar = {};
            for (var i = 0; i < cookies.length; i++) {
              var parts = cookies[i].split('=');
              var value = parts.slice(1).join('=');
              try {
                var found = decodeURIComponent(parts[0]);
                jar[found] = converter.read(value, found);
                if (name === found) {
                  break;
                }
              } catch (e) {}
            }
            return name ? jar[name] : jar;
          }
          return Object.create({
            set,
            get,
            remove: function (name, attributes) {
              set(name, '', assign({}, attributes, {
                expires: -1
              }));
            },
            withAttributes: function (attributes) {
              return init(this.converter, assign({}, this.attributes, attributes));
            },
            withConverter: function (converter) {
              return init(assign({}, this.converter, converter), this.attributes);
            }
          }, {
            attributes: {
              value: Object.freeze(defaultAttributes)
            },
            converter: {
              value: Object.freeze(converter)
            }
          });
        }
        var api = init(defaultConverter, {
          path: '/'
        });
        class CookiesService {
          setObject(value, key) {
            api.set(key, JSON.stringify(value), {
              domain: FRONT_END_DOMAIN,
              SameSite: "Strict"
            });
          }
          setValue(value, key) {
            api.set(key, value, {
              domain: FRONT_END_DOMAIN,
              SameSite: "Strict"
            });
          }
          getObject(key) {
            const value = api.get(key);
            return value && JSON.parse(value);
          }
          getValue(key) {
            return api.get(key);
          }
          removeByKey(key) {
            api.remove(key);
          }
        }
        const CookiesService$1 = exports('V', new CookiesService());
        class TokenService {
          getRefreshToken() {
            var _this$getUser;
            return (_this$getUser = this.getUser()) === null || _this$getUser === void 0 ? void 0 : _this$getUser.refreshToken;
          }
          getAuthToken() {
            var _this$getUser2;
            return (_this$getUser2 = this.getUser()) === null || _this$getUser2 === void 0 ? void 0 : _this$getUser2.accessToken;
          }
          getSubdomain() {
            var _this$getUser3;
            return (_this$getUser3 = this.getUser()) === null || _this$getUser3 === void 0 ? void 0 : _this$getUser3.subdomain;
          }
          getUser() {
            const user = CookiesService$1.getObject("user");
            return user;
          }
          isAuthenticated() {
            const authToken = this.getAuthToken();
            return authToken && authToken.length > 0;
          }
          setSession(user) {
            CookiesService$1.setObject(user, "user");
          }
          removeSession() {
            CookiesService$1.removeByKey("user");
          }
        }
        const TokenService$1 = exports('T', new TokenService());
        const REFRESH_URL = "/user/refresh_token";
        const instance$1 = exports('G', axios$1.create({
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        }));
        instance$1.interceptors.request.use(config => {
          const token = TokenService$1.getAuthToken();
          if (config.url !== REFRESH_URL && config.headers != token) {
            config.headers["Authorization"] = "Bearer " + token;
          } else {
            delete config.headers["Authorization"];
          }
          config.baseURL = BACKEND_BASE_URL;
          return config;
        }, error => {
          return Promise.reject(error);
        });
        instance$1.interceptors.response.use(res => {
          return res;
        }, async err => {
          const originalConfig = err.config;
          // Access Token was expired
          if (originalConfig.url !== REFRESH_URL && err.response && err.response.status === 401 && !originalConfig._retry) {
            originalConfig._retry = true;
            try {
              const rs = await instance$1.post(`/user/refresh_token`, {
                accessToken: TokenService$1.getAuthToken(),
                refreshToken: TokenService$1.getRefreshToken()
              });
              TokenService$1.setSession(rs.data);
              return instance$1(originalConfig);
            } catch (_error) {
              window.location.href = "/login";
              // return Promise.reject(_error);
            }
          }

          return Promise.reject(err);
        });
        class DesignService {
          getSurveyDesign() {
            const surveyId = sessionStorage.getItem("surveyId");
            return instance$1.get(`/survey/${surveyId}/design`).then(response => {
              return response.data;
            });
          }
          setSurveyDesign(data, params) {
            const surveyId = sessionStorage.getItem("surveyId");
            return instance$1.post(`/survey/${surveyId}/design`, data, {
              params
            }).then(response => {
              return response.data;
            });
          }
          publish(params) {
            const surveyId = sessionStorage.getItem("surveyId");
            return instance$1.post(`/survey/${surveyId}/design/publish`, {}, {
              params
            }).then(response => {
              return response.data;
            });
          }
          uploadResource(file) {
            const surveyId = sessionStorage.getItem("surveyId");
            const formData = new FormData();
            formData.append("file", file);
            return instance$1.post(`/survey/${surveyId}/resource`, formData, {
              headers: {
                Accept: "application/json",
                "Content-Type": "multipart/form-data"
              }
            }).then(response => {
              return response.data;
            });
          }
        }
        const DesignService$1 = exports('aV', new DesignService());
        async function GetData(setState, setError) {
          setError(false);
          try {
            const response = await DesignService$1.getSurveyDesign();
            return processResponse(response, setState);
          } catch (err) {
            console.log(err);
            setError({
              errorType: "click",
              message: err.message
            });
          }
        }
        async function SetData(state, setState, setError, showLoading) {
          setError(false);
          try {
            const params = new URLSearchParams([["version", state.versionDto.version], ["sub_version", state.versionDto.subVersion]]);
            const response = await DesignService$1.setSurveyDesign(state, params);
            processResponse(response, setState, state.langInfo);
          } catch (err) {
            setError({
              errorType: "click",
              message: err.message
            });
            console.log(err);
            GetData(setState, setError);
          }
        }
        const processResponse = (response, setState, langInfo) => {
          let state = response.designerInput.state;
          if (!state.Survey.theme) {
            state.Survey.theme = defaultSurveyTheme;
          }
          state.langInfo = {
            languagesList: response.designerInput.languages,
            mainLang: response.designerInput.languages[0].code,
            lang: (langInfo === null || langInfo === void 0 ? void 0 : langInfo.lang) || response.designerInput.languages[0].code
          };
          state.versionDto = response.versionDto;
          state.componentIndex = response.designerInput.componentIndexList;
          setState(state);
          return state;
        };
        let saveTimer$1;
        let buffer$1 = [];
        let debounceTime = 3000;
        const saveDebounce$1 = store => {
          if (saveTimer$1) {
            clearTimeout(saveTimer$1);
          }
          saveTimer$1 = setTimeout(() => {
            store.dispatch(setUpdating$1(true));
            const state = store.getState();
            SetData(state.designState, state => {
              setState$1(store, state);
            }, error => {
              setError$1(store, error);
            });
          }, debounceTime);
        };
        const dataSaver = store => next => action => {
          if (!NONE_MUTATING.includes(action.type)) {
            console.log(action.type);
            if (!store.getState().designState.isUpdating) {
              store.dispatch(setSaving$1(true));
              console.log(action.type);
              saveDebounce$1(store);
            } else {
              buffer$1.push(action);
            }
          }
          return next(action);
        };
        const NONE_MUTATING = ["templateState/setFetching", "designState/setUpdating", "designState/setupToggleExpand", "designState/collapseAllGroups", "designState/onErrorSeen", "designState/toggleComponentCollapse", "designState/resetSetup", "designState/setSaving", "designState/onError", "designState/changeLang", "designState/setup", "designState/designStateReceived", "designState/newVersionReceived"];
        const setState$1 = (store, state) => {
          store.dispatch(setUpdating$1(false));
          store.dispatch(designStateReceived(state));
          store.dispatch(setSaving$1(false));
          buffer$1.forEach(action => {
            store.dispatch(action);
          });
          buffer$1 = [];
        };
        const setError$1 = (store, error) => {
          store.dispatch(onError$1(error));
        };
        const templateState = createSlice({
          name: "templateState",
          initialState: {
            state: {}
          },
          reducers: {
            setDirty: (state, action) => {
              state[action.payload] = true;
            },
            setFetching: (state, action) => {
              state.isLoading = action.payload;
            }
          }
        });
        const {
          setDirty,
          setFetching
        } = templateState.actions;
        exports({
          a6: setDirty,
          ak: setFetching
        });
        const templateState$1 = templateState.reducer;
        const PROCESSED_ERRORS = exports('P', {
          NETWORK_ERR: "network_err",
          BACKEND_DOWN: "backend_down",
          WRONG_CREDENTIALS: "wrong_credentials",
          DUPLICATE_EMAIL: "duplicate_email",
          DUPLICATE_DOMAIN: "duplicate_domain",
          DUPLICATE_SURVEY_NAME: "duplicate_survey_name",
          EXPIRED_RESET_TOKEN: "expired_reset_token",
          WRONG_RESET_TOKEN: "wrong_reset_token",
          USED_CONFIRMATION_TOKEN: "used_confirmation_token",
          EXPIRED_CONFIRMATION_TOKEN: "expired_confirmation_token",
          USER_NOT_FOUND: "user_not_found",
          MISSING_CREDENTIALS: "missing_credentials",
          SURVEY_DESIGN_ERROR: "survey_design_error",
          SURVEY_NOT_ACTIVE: "survey_not_active",
          SURVEY_CLOSED: "survey_closed",
          SURVEY_SCHEDULED: "survey_scheduled",
          SURVEY_EXPIRED: "survey_expired",
          INVALID_DOMAIN: "invalid_domain",
          UNIDENTIFIED_ERROR: "unidentified_error"
        });
        const processError = exports('p', e => {
          var _e$response, _e$response$data;
          console.log(e);
          if (e.code == "ERR_NETWORK" && navigator.onLine) {
            return PROCESSED_ERRORS.BACKEND_DOWN;
          } else if (e.code == "ERR_NETWORK" && !navigator.onLine) {
            return PROCESSED_ERRORS.NETWORK_ERR;
          } else if ((_e$response = e.response) !== null && _e$response !== void 0 && (_e$response$data = _e$response.data) !== null && _e$response$data !== void 0 && _e$response$data.error) {
            var _e$response2, _e$response2$data;
            switch ((_e$response2 = e.response) === null || _e$response2 === void 0 ? void 0 : (_e$response2$data = _e$response2.data) === null || _e$response2$data === void 0 ? void 0 : _e$response2$data.error) {
              case "WrongCredentialsException":
                return PROCESSED_ERRORS.WRONG_CREDENTIALS;
              case "DuplicateEmailException":
                return PROCESSED_ERRORS.DUPLICATE_EMAIL;
              case "DuplicateDomainException":
                return PROCESSED_ERRORS.DUPLICATE_DOMAIN;
              case "ExpiredResetTokenException":
                return PROCESSED_ERRORS.EXPIRED_RESET_TOKEN;
              case "WrongResetTokenException":
                return PROCESSED_ERRORS.WRONG_RESET_TOKEN;
              case "UsedConfirmationTokenException":
                return PROCESSED_ERRORS.USED_CONFIRMATION_TOKEN;
              case "ExpiredConfirmationTokenException":
                return PROCESSED_ERRORS.EXPIRED_CONFIRMATION_TOKEN;
              case "UserNotFoundException":
                return PROCESSED_ERRORS.USER_NOT_FOUND;
              case "DuplicateEmailException":
                return PROCESSED_ERRORS.DUPLICATE_EMAIL;
              case "MissingCredentialsException":
                return PROCESSED_ERRORS.MISSING_CREDENTIALS;
              case "SurveyDesignWithErrorException":
                return PROCESSED_ERRORS.SURVEY_DESIGN_ERROR;
              case "DuplicateSurveyException":
                return PROCESSED_ERRORS.DUPLICATE_SURVEY_NAME;
              case "SurveyIsNotActiveException":
                return PROCESSED_ERRORS.SURVEY_NOT_ACTIVE;
              case "SurveyExpiredException":
                return PROCESSED_ERRORS.SURVEY_EXPIRED;
              case "SurveyNotStartedException":
                return PROCESSED_ERRORS.SURVEY_SCHEDULED;
              case "InvalidDomainException":
                return PROCESSED_ERRORS.INVALID_DOMAIN;
              case "SurveyIsClosedException":
                return PROCESSED_ERRORS.SURVEY_CLOSED;
              default:
                return PROCESSED_ERRORS.UNIDENTIFIED_ERROR;
            }
          }
        });
        class SurveyService {
          async getAllSurveys() {
            return instance$1.get(`/survey/all`).then(response => {
              return response.data;
            });
          }
          async getSurvey() {
            const surveyId = sessionStorage.getItem("surveyId");
            return instance$1.get(`/survey/${surveyId}`).then(response => {
              return response.data;
            });
          }
          async createSurvey(data) {
            const response = await instance$1.post(`/survey/create`, data);
            return response.data;
          }
          async putSurvey(data, surveyId) {
            const response = await instance$1.put(`/survey/${surveyId}`, data);
            return response.data;
          }
          async closeSurvey(surveyId) {
            const response = await instance$1.put(`/survey/${surveyId}/close`);
            return response.data;
          }
          async cloneSurvey(surveyId, data) {
            const response = await instance$1.post(`/survey/${surveyId}/clone`, data);
            return response.data;
          }
          async deleteSurvey(surveyId) {
            const response = await instance$1.delete(`/survey/${surveyId}`);
            return response.data;
          }
          async getSurveyPermissionAll(surveyId) {
            const response = await instance$1.get(`/survey/${surveyId}/permission/all`);
            return response.data;
          }
          async removePermission(surveyId, userId) {
            const response = await instance$1.delete(`/survey/${surveyId}/permission/${userId}`);
            return response.data;
          }
          async addPermission(surveyId, userId) {
            const response = await instance$1.post(`/survey/${surveyId}/permission/${userId}`);
            return response.data;
          }
          async editPermission(surveyId, userId, data) {
            const response = await instance$1.put(`/survey/${surveyId}/permission/${userId}`, data);
            return response.data;
          }
          async allResponse(surveyId, dbValues, page, per_page, complete, preview) {
            const shouldAddComplete = complete === true || complete === false;
            const shouldAddPreview = preview === true || preview === false;
            const response = await instance$1.get(`/survey/${surveyId}/response/all?db_values=${dbValues}&page=${page}&per_page=${per_page}` + `${shouldAddComplete ? `&complete=${complete}` : ""}${shouldAddPreview ? `&preview=${preview}` : ""}`);
            return response.data;
          }
          async exportResponses(surveyId, dbValues, complete, preview) {
            const shouldAddComplete = complete === true || complete === false;
            const shouldAddPreview = preview === true || preview === false;
            const response = await instance$1.get(`/survey/${surveyId}/response/export?db_values=${dbValues}` + `${shouldAddComplete ? `&complete=${complete}` : ""}${shouldAddPreview ? `&preview=${preview}` : ""}`);
            return response.data;
          }
          async deleteResponse(surveyId, responseId) {
            const response = await instance$1.delete(`/survey/${surveyId}/response/${responseId}`);
            return response;
          }
          async eventResponse(surveyId, responseId) {
            const response = await instance$1.get(`/survey/${surveyId}/response/${responseId}/events`);
            return response;
          }
          async responseAttach(surveyId, filename) {
            const response = await instance$1.get(`/survey/${surveyId}/response/attach/${filename}`, {
              responseType: "blob"
            });
            return response;
          }
        }
        const SurveyService$1 = exports('S', new SurveyService());
        let saveTimer;
        let buffer = [];
        let defaultDebounceTime = 3000;
        const saveDebounce = (store, debounceTime) => {
          if (saveTimer) {
            clearTimeout(saveTimer);
          }
          saveTimer = setTimeout(() => {
            store.dispatch(setUpdating(true));
            const state = store.getState();
            SurveyService$1.putSurvey(state.editState.survey, state.editState.survey.id).then(state => {
              setState(store, state);
            }).catch(error => {
              setError(store, error);
            });
          }, debounceTime);
        };
        const editDataSaver = store => next => action => {
          if (action.type == "editState/surveyAttributeChanged" || action.type == "editState/surveyAttributeChangedImmediate") {
            if (!store.getState().editState.isUpdating) {
              store.dispatch(setSaving(true));
              let debounceTime = defaultDebounceTime;
              if (action.type == "editState/surveyAttributeChangedImmediate") {
                debounceTime = 0;
              }
              saveDebounce(store, debounceTime);
            } else {
              buffer.push(action);
            }
          }
          return next(action);
        };
        const setState = (store, state) => {
          store.dispatch(setUpdating(false));
          store.dispatch(surveyReceived(state));
          store.dispatch(setSaving(false));
          buffer.forEach(action => {
            store.dispatch(action);
          });
          store.dispatch(onError(""));
          buffer = [];
        };
        const setError = (store, error) => {
          console.log(processError(error));
          store.dispatch(onError(processError(error)));
          store.dispatch(setUpdating(false));
          store.dispatch(setSaving(false));
        };
        const runStore = configureStore({
          reducer: {
            templateState: templateState$1,
            runState: runState$1
          }
        });
        const designStore = exports('aM', configureStore({
          reducer: {
            templateState: templateState$1,
            designState: designState$1
          },
          middleware: getDefaultMiddleware => getDefaultMiddleware().concat(dataSaver)
        }));
        configureStore({
          reducer: {
            editState: editState$1
          },
          middleware: getDefaultMiddleware => getDefaultMiddleware().concat(editDataSaver)
        });
        var shim = {
          exports: {}
        };
        var useSyncExternalStoreShim_production_min = {};

        /**
         * @license React
         * use-sync-external-store-shim.production.min.js
         *
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */
        var e = reactExports;
        function h$1(a, b) {
          return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
        }
        var k = "function" === typeof Object.is ? Object.is : h$1,
          l = e.useState,
          m = e.useEffect,
          n$1 = e.useLayoutEffect,
          p$1 = e.useDebugValue;
        function q$1(a, b) {
          var d = b(),
            f = l({
              inst: {
                value: d,
                getSnapshot: b
              }
            }),
            c = f[0].inst,
            g = f[1];
          n$1(function () {
            c.value = d;
            c.getSnapshot = b;
            r$1(c) && g({
              inst: c
            });
          }, [a, d, b]);
          m(function () {
            r$1(c) && g({
              inst: c
            });
            return a(function () {
              r$1(c) && g({
                inst: c
              });
            });
          }, [a]);
          p$1(d);
          return d;
        }
        function r$1(a) {
          var b = a.getSnapshot;
          a = a.value;
          try {
            var d = b();
            return !k(a, d);
          } catch (f) {
            return !0;
          }
        }
        function t$1(a, b) {
          return b();
        }
        var u$1 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t$1 : q$1;
        useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e.useSyncExternalStore ? e.useSyncExternalStore : u$1;
        {
          shim.exports = useSyncExternalStoreShim_production_min;
        }
        var shimExports = shim.exports;
        var withSelector = {
          exports: {}
        };
        var withSelector_production_min = {};

        /**
         * @license React
         * use-sync-external-store-shim/with-selector.production.min.js
         *
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */
        var h = reactExports,
          n = shimExports;
        function p(a, b) {
          return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
        }
        var q = "function" === typeof Object.is ? Object.is : p,
          r = n.useSyncExternalStore,
          t = h.useRef,
          u = h.useEffect,
          v = h.useMemo,
          w = h.useDebugValue;
        withSelector_production_min.useSyncExternalStoreWithSelector = function (a, b, e, l, g) {
          var c = t(null);
          if (null === c.current) {
            var f = {
              hasValue: !1,
              value: null
            };
            c.current = f;
          } else f = c.current;
          c = v(function () {
            function a(a) {
              if (!c) {
                c = !0;
                d = a;
                a = l(a);
                if (void 0 !== g && f.hasValue) {
                  var b = f.value;
                  if (g(b, a)) return k = b;
                }
                return k = a;
              }
              b = k;
              if (q(d, a)) return b;
              var e = l(a);
              if (void 0 !== g && g(b, e)) return b;
              d = a;
              return k = e;
            }
            var c = !1,
              d,
              k,
              m = void 0 === e ? null : e;
            return [function () {
              return a(b());
            }, null === m ? void 0 : function () {
              return a(m());
            }];
          }, [b, e, l, g]);
          var d = r(a, c[0], c[1]);
          u(function () {
            f.hasValue = !0;
            f.value = d;
          }, [d]);
          w(d);
          return d;
        };
        {
          withSelector.exports = withSelector_production_min;
        }
        var withSelectorExports = withSelector.exports;

        // Default to a dummy "batch" implementation that just runs the callback
        function defaultNoopBatch(callback) {
          callback();
        }
        let batch = defaultNoopBatch; // Allow injecting another batching function later

        const setBatch = newBatch => batch = newBatch; // Supply a getter just to skip dealing with ESM bindings

        const getBatch = () => batch;
        const ReactReduxContext = exports('bM', /*#__PURE__*/reactExports.createContext(null));

        /**
         * A hook to access the value of the `ReactReduxContext`. This is a low-level
         * hook that you should usually not need to call directly.
         *
         * @returns {any} the value of the `ReactReduxContext`
         *
         * @example
         *
         * import React from 'react'
         * import { useReduxContext } from 'react-redux'
         *
         * export const CounterComponent = () => {
         *   const { store } = useReduxContext()
         *   return <div>{store.getState()}</div>
         * }
         */
        function useReduxContext() {
          const contextValue = reactExports.useContext(ReactReduxContext);
          return contextValue;
        }
        const notInitialized = () => {
          throw new Error('uSES not initialized!');
        };
        let useSyncExternalStoreWithSelector = notInitialized;
        const initializeUseSelector = fn => {
          useSyncExternalStoreWithSelector = fn;
        };
        const refEquality = (a, b) => a === b;
        /**
         * Hook factory, which creates a `useSelector` hook bound to a given context.
         *
         * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
         * @returns {Function} A `useSelector` hook bound to the specified context.
         */

        function createSelectorHook(context = ReactReduxContext) {
          const useReduxContext$1 = context === ReactReduxContext ? useReduxContext : () => reactExports.useContext(context);
          return function useSelector(selector, equalityFn = refEquality) {
            const {
              store,
              subscription,
              getServerState
            } = useReduxContext$1();
            const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store.getState, getServerState || store.getState, selector, equalityFn);
            reactExports.useDebugValue(selectedState);
            return selectedState;
          };
        }
        /**
         * A hook to access the redux store's state. This hook takes a selector function
         * as an argument. The selector is called with the store state.
         *
         * This hook takes an optional equality comparison function as the second parameter
         * that allows you to customize the way the selected state is compared to determine
         * whether the component needs to be re-rendered.
         *
         * @param {Function} selector the selector function
         * @param {Function=} equalityFn the function that will be used to determine equality
         *
         * @returns {any} the selected state
         *
         * @example
         *
         * import React from 'react'
         * import { useSelector } from 'react-redux'
         *
         * export const CounterComponent = () => {
         *   const counter = useSelector(state => state.counter)
         *   return <div>{counter}</div>
         * }
         */

        const useSelector = exports('b', /*#__PURE__*/createSelectorHook());

        // well as nesting subscriptions of descendant components, so that we can ensure the
        // ancestor components re-render before descendants

        function createListenerCollection() {
          const batch = getBatch();
          let first = null;
          let last = null;
          return {
            clear() {
              first = null;
              last = null;
            },
            notify() {
              batch(() => {
                let listener = first;
                while (listener) {
                  listener.callback();
                  listener = listener.next;
                }
              });
            },
            get() {
              let listeners = [];
              let listener = first;
              while (listener) {
                listeners.push(listener);
                listener = listener.next;
              }
              return listeners;
            },
            subscribe(callback) {
              let isSubscribed = true;
              let listener = last = {
                callback,
                next: null,
                prev: last
              };
              if (listener.prev) {
                listener.prev.next = listener;
              } else {
                first = listener;
              }
              return function unsubscribe() {
                if (!isSubscribed || first === null) return;
                isSubscribed = false;
                if (listener.next) {
                  listener.next.prev = listener.prev;
                } else {
                  last = listener.prev;
                }
                if (listener.prev) {
                  listener.prev.next = listener.next;
                } else {
                  first = listener.next;
                }
              };
            }
          };
        }
        const nullListeners = {
          notify() {},
          get: () => []
        };
        function createSubscription(store, parentSub) {
          let unsubscribe;
          let listeners = nullListeners;
          function addNestedSub(listener) {
            trySubscribe();
            return listeners.subscribe(listener);
          }
          function notifyNestedSubs() {
            listeners.notify();
          }
          function handleChangeWrapper() {
            if (subscription.onStateChange) {
              subscription.onStateChange();
            }
          }
          function isSubscribed() {
            return Boolean(unsubscribe);
          }
          function trySubscribe() {
            if (!unsubscribe) {
              unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
              listeners = createListenerCollection();
            }
          }
          function tryUnsubscribe() {
            if (unsubscribe) {
              unsubscribe();
              unsubscribe = undefined;
              listeners.clear();
              listeners = nullListeners;
            }
          }
          const subscription = {
            addNestedSub,
            notifyNestedSubs,
            handleChangeWrapper,
            isSubscribed,
            trySubscribe,
            tryUnsubscribe,
            getListeners: () => listeners
          };
          return subscription;
        }

        // To get around it, we can conditionally useEffect on the server (no-op) and
        // useLayoutEffect in the browser. We need useLayoutEffect to ensure the store
        // subscription callback always has the selector from the latest render commit
        // available, otherwise a store update may happen between render and the effect,
        // which may cause missed updates; we also must ensure the store subscription
        // is created synchronously, otherwise a store update may occur before the
        // subscription is created and an inconsistent state may be observed
        // Matches logic in React's `shared/ExecutionEnvironment` file

        const canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');
        const useIsomorphicLayoutEffect = canUseDOM ? reactExports.useLayoutEffect : reactExports.useEffect;
        function Provider({
          store,
          context,
          children,
          serverState
        }) {
          const contextValue = reactExports.useMemo(() => {
            const subscription = createSubscription(store);
            return {
              store,
              subscription,
              getServerState: serverState ? () => serverState : undefined
            };
          }, [store, serverState]);
          const previousState = reactExports.useMemo(() => store.getState(), [store]);
          useIsomorphicLayoutEffect(() => {
            const {
              subscription
            } = contextValue;
            subscription.onStateChange = subscription.notifyNestedSubs;
            subscription.trySubscribe();
            if (previousState !== store.getState()) {
              subscription.notifyNestedSubs();
            }
            return () => {
              subscription.tryUnsubscribe();
              subscription.onStateChange = undefined;
            };
          }, [contextValue, previousState]);
          const Context = context || ReactReduxContext; // @ts-ignore 'AnyAction' is assignable to the constraint of type 'A', but 'A' could be instantiated with a different subtype

          return /*#__PURE__*/React.createElement(Context.Provider, {
            value: contextValue
          }, children);
        }

        // The primary entry point assumes we're working with standard ReactDOM/RN, but
        // older versions that do not include `useSyncExternalStore` (React 16.9 - 17.x).
        // Because of that, the useSyncExternalStore compat shim is needed.
        initializeUseSelector(withSelectorExports.useSyncExternalStoreWithSelector);
        // with standard React renderers (ReactDOM, React Native)

        setBatch(reactDomExports.unstable_batchedUpdates);
        const instance = exports('bG', axios$1.create({
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        }));
        instance.interceptors.request.use(config => {
          config.baseURL = BACKEND_BASE_URL;
          return config;
        }, error => {
          return Promise.reject(error);
        });
        class RunService {
          start(lang, preview = false) {
            const surveyId = sessionStorage.getItem("surveyId");
            if (preview) {
              return instance$1.post(`/survey/${surveyId}/preview/start`, {
                lang
              }).then(response => {
                return response.data;
              });
            } else {
              return instance.post(`/survey/${surveyId}/run/start`, {
                lang
              }).then(response => {
                return response.data;
              });
            }
          }
          navigate(payload, preview = false) {
            const surveyId = sessionStorage.getItem("surveyId");
            if (preview) {
              return instance$1.post(`/survey/${surveyId}/preview/navigate`, payload).then(response => {
                return response.data;
              });
            } else {
              return instance.post(`/survey/${surveyId}/run/navigate`, payload).then(response => {
                return response.data;
              });
            }
          }
          runtimeJs(preview) {
            const surveyId = sessionStorage.getItem("surveyId");
            if (preview) {
              return instance$1.get(`/survey/${surveyId}/preview/runtime.js`).then(response => {
                return response.data;
              });
            } else {
              return instance.get(`/survey/${surveyId}/run/runtime.js`).then(response => {
                return response.data;
              });
            }
          }
          runtimeUrl() {
            const surveyId = sessionStorage.getItem("surveyId");
            return BACKEND_BASE_URL + `/survey/${surveyId}/run/runtime.js`;
          }
          previewUrl(fileName) {
            const surveyId = sessionStorage.getItem("surveyId");
            return BACKEND_BASE_URL + `/survey/${surveyId}/response/attach/${fileName}`;
          }
          uploadResponseFile(key, file) {
            const surveyId = sessionStorage.getItem("surveyId");
            const responseId = sessionStorage.getItem("responseId");
            const formData = new FormData();
            formData.append("file", file);
            return instance.post(`/survey/${surveyId}/response/attach/${responseId}/${key}`, formData, {
              headers: {
                Accept: "application/json",
                "Content-Type": "multipart/form-data"
              }
            }).then(response => {
              return response.data;
            });
          }
          uploadResponseBlob(key, blob, fileName) {
            const surveyId = sessionStorage.getItem("surveyId");
            const responseId = sessionStorage.getItem("responseId");
            const formData = new FormData();
            formData.append("file", blob, fileName);
            return instance.post(`/survey/${surveyId}/response/attach/${responseId}/${key}`, formData, {
              headers: {
                Accept: "application/json",
                "Content-Type": "multipart/form-data"
              }
            }).then(response => {
              return response.data;
            });
          }
        }
        const RunService$1 = new RunService();
        const getparam = (params, key) => {
          if (window["Android"]) {
            return window["Android"].getParam(key);
          } else {
            return params[key];
          }
        };
        const startNavigation = exports('as', (lang, preview) => {
          if (window["Android"]) {
            return new Promise((resolve, reject) => {
              window["Android"].start();
              window["navigateOffline"] = res => {
                resolve(res);
              };
            });
          } else {
            return RunService$1.start(lang, preview);
          }
        });
        const continueNavigation = exports('ai', (payload, responseId, preview) => {
          const finalObj = {
            ...payload,
            responseId: responseId
          };
          if (window["Android"]) {
            return new Promise((resolve, reject) => {
              window["Android"].navigate(JSON.stringify(finalObj));
              window["navigateOffline"] = res => {
                resolve(res);
              };
            });
          } else {
            return RunService$1.navigate(finalObj, preview);
          }
        });
        const uploadFile = exports('a8', (key, selectedFile) => {
          if (window["Android"]) {
            return new Promise((resolve, reject) => {
              window["Android"].uploadFile(key, selectedFile.name);
              window["onFileUploaded"] = res => {
                resolve(res);
              };
            });
          }
          return RunService$1.uploadResponseFile(key, selectedFile);
        });
        const uploadDataUrl = exports('ag', (key, dataurl, fileName) => {
          if (window["Android"]) {
            return new Promise((resolve, reject) => {
              window["Android"].uploadDataUrl(key, dataurl, fileName);
              window["onDataUrlUploaded"] = res => {
                resolve(res);
              };
            });
          }
          const blob = dataURLtoBlob(dataurl);
          return RunService$1.uploadResponseBlob(key, blob, fileName);
        });
        const dataURLtoBlob = dataurl => {
          var arr = dataurl.split(","),
            mime = arr[0].match(/:(.*?);/)[1],
            bstr = atob(arr[1]),
            n = bstr.length,
            u8arr = new Uint8Array(n);
          while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
          }
          return new Blob([u8arr], {
            type: mime
          });
        };
        const downloadFileAsBase64 = exports('af', url => {
          return fetch(url).then(response => response.blob()).then(blob => new Promise(callback => {
            let reader = new FileReader();
            reader.onload = function () {
              callback(this.result);
            };
            reader.readAsDataURL(blob);
          }));
        });
        const previewUrl = exports('B', filename => {
          return RunService$1.previewUrl(filename);
        });
        const loadScript = exports('al', preview => new Promise((resolve, reject) => {
          RunService$1.runtimeJs(preview).then(data => {
            const script = document.createElement("script");
            script.innerHTML = data;
            document.body.appendChild(script);
            resolve();
          }).catch(err => {
            reject(err);
          });
        }));
        function getCircularProgressUtilityClass(slot) {
          return generateUtilityClass('MuiCircularProgress', slot);
        }
        generateUtilityClasses('MuiCircularProgress', ['root', 'determinate', 'indeterminate', 'colorPrimary', 'colorSecondary', 'svg', 'circle', 'circleDeterminate', 'circleIndeterminate', 'circleDisableShrink']);
        const _excluded = ["className", "color", "disableShrink", "size", "style", "thickness", "value", "variant"];
        let _ = t => t,
          _t,
          _t2,
          _t3,
          _t4;
        const SIZE = 44;
        const circularRotateKeyframe = keyframes(_t || (_t = _`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`));
        const circularDashKeyframe = keyframes(_t2 || (_t2 = _`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -125px;
  }
`));
        const useUtilityClasses = ownerState => {
          const {
            classes,
            variant,
            color,
            disableShrink
          } = ownerState;
          const slots = {
            root: ['root', variant, `color${capitalize(color)}`],
            svg: ['svg'],
            circle: ['circle', `circle${capitalize(variant)}`, disableShrink && 'circleDisableShrink']
          };
          return composeClasses(slots, getCircularProgressUtilityClass, classes);
        };
        const CircularProgressRoot = styled$1('span', {
          name: 'MuiCircularProgress',
          slot: 'Root',
          overridesResolver: (props, styles) => {
            const {
              ownerState
            } = props;
            return [styles.root, styles[ownerState.variant], styles[`color${capitalize(ownerState.color)}`]];
          }
        })(({
          ownerState,
          theme
        }) => _extends({
          display: 'inline-block'
        }, ownerState.variant === 'determinate' && {
          transition: theme.transitions.create('transform')
        }, ownerState.color !== 'inherit' && {
          color: (theme.vars || theme).palette[ownerState.color].main
        }), ({
          ownerState
        }) => ownerState.variant === 'indeterminate' && css(_t3 || (_t3 = _`
      animation: ${0} 1.4s linear infinite;
    `), circularRotateKeyframe));
        const CircularProgressSVG = styled$1('svg', {
          name: 'MuiCircularProgress',
          slot: 'Svg',
          overridesResolver: (props, styles) => styles.svg
        })({
          display: 'block' // Keeps the progress centered
        });

        const CircularProgressCircle = styled$1('circle', {
          name: 'MuiCircularProgress',
          slot: 'Circle',
          overridesResolver: (props, styles) => {
            const {
              ownerState
            } = props;
            return [styles.circle, styles[`circle${capitalize(ownerState.variant)}`], ownerState.disableShrink && styles.circleDisableShrink];
          }
        })(({
          ownerState,
          theme
        }) => _extends({
          stroke: 'currentColor'
        }, ownerState.variant === 'determinate' && {
          transition: theme.transitions.create('stroke-dashoffset')
        }, ownerState.variant === 'indeterminate' && {
          // Some default value that looks fine waiting for the animation to kicks in.
          strokeDasharray: '80px, 200px',
          strokeDashoffset: 0 // Add the unit to fix a Edge 16 and below bug.
        }), ({
          ownerState
        }) => ownerState.variant === 'indeterminate' && !ownerState.disableShrink && css(_t4 || (_t4 = _`
      animation: ${0} 1.4s ease-in-out infinite;
    `), circularDashKeyframe));

        /**
         * ## ARIA
         *
         * If the progress bar is describing the loading progress of a particular region of a page,
         * you should use `aria-describedby` to point to the progress bar, and set the `aria-busy`
         * attribute to `true` on that region until it has finished loading.
         */
        const CircularProgress = /*#__PURE__*/reactExports.forwardRef(function CircularProgress(inProps, ref) {
          const props = useThemeProps({
            props: inProps,
            name: 'MuiCircularProgress'
          });
          const {
              className,
              color = 'primary',
              disableShrink = false,
              size = 40,
              style,
              thickness = 3.6,
              value = 0,
              variant = 'indeterminate'
            } = props,
            other = _objectWithoutPropertiesLoose$1(props, _excluded);
          const ownerState = _extends({}, props, {
            color,
            disableShrink,
            size,
            thickness,
            value,
            variant
          });
          const classes = useUtilityClasses(ownerState);
          const circleStyle = {};
          const rootStyle = {};
          const rootProps = {};
          if (variant === 'determinate') {
            const circumference = 2 * Math.PI * ((SIZE - thickness) / 2);
            circleStyle.strokeDasharray = circumference.toFixed(3);
            rootProps['aria-valuenow'] = Math.round(value);
            circleStyle.strokeDashoffset = `${((100 - value) / 100 * circumference).toFixed(3)}px`;
            rootStyle.transform = 'rotate(-90deg)';
          }
          return /*#__PURE__*/jsxRuntimeExports.jsx(CircularProgressRoot, _extends({
            className: clsx(classes.root, className),
            style: _extends({
              width: size,
              height: size
            }, rootStyle, style),
            ownerState: ownerState,
            ref: ref,
            role: "progressbar"
          }, rootProps, other, {
            children: /*#__PURE__*/jsxRuntimeExports.jsx(CircularProgressSVG, {
              className: classes.svg,
              ownerState: ownerState,
              viewBox: `${SIZE / 2} ${SIZE / 2} ${SIZE} ${SIZE}`,
              children: /*#__PURE__*/jsxRuntimeExports.jsx(CircularProgressCircle, {
                className: classes.circle,
                style: circleStyle,
                ownerState: ownerState,
                cx: SIZE,
                cy: SIZE,
                r: (SIZE - thickness) / 2,
                fill: "none",
                strokeWidth: thickness
              })
            })
          }));
        });
        const CircularProgress$1 = exports('C', CircularProgress);
        const loading = "_loading_c5al4_1";
        const loadingWrapper = "_loadingWrapper_c5al4_14";
        const styles = {
          loading: loading,
          loadingWrapper: loadingWrapper
        };
        function LoadingIndicator() {
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            className: styles.loading,
            children: /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: styles.loadingWrapper,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(CircularProgress$1, {})
            })
          });
        }
        var cssjanus$1 = {
          exports: {}
        };

        /*!
         * CSSJanus. https://github.com/cssjanus/cssjanus
         *
         * Copyright 2014 Trevor Parscal
         * Copyright 2010 Roan Kattouw
         * Copyright 2008 Google Inc.
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        (function (module, exports) {
          var cssjanus;

          /**
           * Create a tokenizer object.
           *
           * This utility class is used by CSSJanus to protect strings by replacing them temporarily with
           * tokens and later transforming them back.
           *
           * @class
           * @constructor
           * @param {RegExp} regex Regular expression whose matches to replace by a token
           * @param {string} token Placeholder text
           */
          function Tokenizer(regex, token) {
            var matches = [],
              index = 0;

            /**
             * Add a match.
             *
             * @private
             * @param {string} match Matched string
             * @return {string} Token to leave in the matched string's place
             */
            function tokenizeCallback(match) {
              matches.push(match);
              return token;
            }

            /**
             * Get a match.
             *
             * @private
             * @return {string} Original matched string to restore
             */
            function detokenizeCallback() {
              return matches[index++];
            }
            return {
              /**
               * Replace matching strings with tokens.
               *
               * @param {string} str String to tokenize
               * @return {string} Tokenized string
               */
              tokenize: function (str) {
                return str.replace(regex, tokenizeCallback);
              },
              /**
               * Restores tokens to their original values.
               *
               * @param {string} str String previously run through tokenize()
               * @return {string} Original string
               */
              detokenize: function (str) {
                return str.replace(new RegExp('(' + token + ')', 'g'), detokenizeCallback);
              }
            };
          }

          /**
           * Create a CSSJanus object.
           *
           * CSSJanus transforms CSS rules with horizontal relevance so that a left-to-right stylesheet can
           * become a right-to-left stylesheet automatically. Processing can be bypassed for an entire rule
           * or a single property by adding a / * @noflip * / comment above the rule or property.
           *
           * @class
           * @constructor
           */
          function CSSJanus() {
            var
              // Tokens
              temporaryToken = '`TMP`',
              noFlipSingleToken = '`NOFLIP_SINGLE`',
              noFlipClassToken = '`NOFLIP_CLASS`',
              commentToken = '`COMMENT`',
              // Patterns
              nonAsciiPattern = '[^\\u0020-\\u007e]',
              unicodePattern = '(?:(?:\\\\[0-9a-f]{1,6})(?:\\r\\n|\\s)?)',
              numPattern = '(?:[0-9]*\\.[0-9]+|[0-9]+)',
              unitPattern = '(?:em|ex|px|cm|mm|in|pt|pc|deg|rad|grad|ms|s|hz|khz|%)',
              directionPattern = 'direction\\s*:\\s*',
              urlSpecialCharsPattern = '[!#$%&*-~]',
              validAfterUriCharsPattern = '[\'"]?\\s*',
              nonLetterPattern = '(^|[^a-zA-Z])',
              charsWithinSelectorPattern = '[^\\}]*?',
              noFlipPattern = '\\/\\*\\!?\\s*@noflip\\s*\\*\\/',
              commentPattern = '\\/\\*[^*]*\\*+([^\\/*][^*]*\\*+)*\\/',
              escapePattern = '(?:' + unicodePattern + '|\\\\[^\\r\\n\\f0-9a-f])',
              nmstartPattern = '(?:[_a-z]|' + nonAsciiPattern + '|' + escapePattern + ')',
              nmcharPattern = '(?:[_a-z0-9-]|' + nonAsciiPattern + '|' + escapePattern + ')',
              identPattern = '-?' + nmstartPattern + nmcharPattern + '*',
              quantPattern = numPattern + '(?:\\s*' + unitPattern + '|' + identPattern + ')?',
              signedQuantPattern = '((?:-?' + quantPattern + ')|(?:inherit|auto))',
              fourNotationQuantPropsPattern = '((?:margin|padding|border-width)\\s*:\\s*)',
              fourNotationColorPropsPattern = '((?:-color|border-style)\\s*:\\s*)',
              colorPattern = '(#?' + nmcharPattern + '+|(?:rgba?|hsla?)\\([ \\d.,%-]+\\))',
              // The use of a lazy match ("*?") may cause a backtrack limit to be exceeded before finding
              // the intended match. This affects 'urlCharsPattern' and 'lookAheadNotOpenBracePattern'.
              // We have not yet found this problem on Node.js, but we have on PHP 7, where it was
              // mitigated by using a possessive quantifier ("*+"), which are not supported in JS.
              // See <https://github.com/cssjanus/php-cssjanus/issues/14> and <https://phabricator.wikimedia.org/T215746#4944830>.
              urlCharsPattern = '(?:' + urlSpecialCharsPattern + '|' + nonAsciiPattern + '|' + escapePattern + ')*?',
              lookAheadNotLetterPattern = '(?![a-zA-Z])',
              lookAheadNotOpenBracePattern = '(?!(' + nmcharPattern + '|\\r?\\n|\\s|#|\\:|\\.|\\,|\\+|>|~|\\(|\\)|\\[|\\]|=|\\*=|~=|\\^=|\'[^\']*\'|"[^"]*"|' + commentToken + ')*?{)',
              lookAheadNotClosingParenPattern = '(?!' + urlCharsPattern + validAfterUriCharsPattern + '\\))',
              lookAheadForClosingParenPattern = '(?=' + urlCharsPattern + validAfterUriCharsPattern + '\\))',
              suffixPattern = '(\\s*(?:!important\\s*)?[;}])',
              // Regular expressions
              temporaryTokenRegExp = /`TMP`/g,
              commentRegExp = new RegExp(commentPattern, 'gi'),
              noFlipSingleRegExp = new RegExp('(' + noFlipPattern + lookAheadNotOpenBracePattern + '[^;}]+;?)', 'gi'),
              noFlipClassRegExp = new RegExp('(' + noFlipPattern + charsWithinSelectorPattern + '})', 'gi'),
              directionLtrRegExp = new RegExp('(' + directionPattern + ')ltr', 'gi'),
              directionRtlRegExp = new RegExp('(' + directionPattern + ')rtl', 'gi'),
              leftRegExp = new RegExp(nonLetterPattern + '(left)' + lookAheadNotLetterPattern + lookAheadNotClosingParenPattern + lookAheadNotOpenBracePattern, 'gi'),
              rightRegExp = new RegExp(nonLetterPattern + '(right)' + lookAheadNotLetterPattern + lookAheadNotClosingParenPattern + lookAheadNotOpenBracePattern, 'gi'),
              leftInUrlRegExp = new RegExp(nonLetterPattern + '(left)' + lookAheadForClosingParenPattern, 'gi'),
              rightInUrlRegExp = new RegExp(nonLetterPattern + '(right)' + lookAheadForClosingParenPattern, 'gi'),
              ltrInUrlRegExp = new RegExp(nonLetterPattern + '(ltr)' + lookAheadForClosingParenPattern, 'gi'),
              rtlInUrlRegExp = new RegExp(nonLetterPattern + '(rtl)' + lookAheadForClosingParenPattern, 'gi'),
              cursorEastRegExp = new RegExp(nonLetterPattern + '([ns]?)e-resize', 'gi'),
              cursorWestRegExp = new RegExp(nonLetterPattern + '([ns]?)w-resize', 'gi'),
              fourNotationQuantRegExp = new RegExp(fourNotationQuantPropsPattern + signedQuantPattern + '(\\s+)' + signedQuantPattern + '(\\s+)' + signedQuantPattern + '(\\s+)' + signedQuantPattern + suffixPattern, 'gi'),
              fourNotationColorRegExp = new RegExp(fourNotationColorPropsPattern + colorPattern + '(\\s+)' + colorPattern + '(\\s+)' + colorPattern + '(\\s+)' + colorPattern + suffixPattern, 'gi'),
              bgHorizontalPercentageRegExp = new RegExp('(background(?:-position)?\\s*:\\s*(?:[^:;}\\s]+\\s+)*?)(' + quantPattern + ')', 'gi'),
              bgHorizontalPercentageXRegExp = new RegExp('(background-position-x\\s*:\\s*)(-?' + numPattern + '%)', 'gi'),
              // border-radius: <length or percentage>{1,4} [optional: / <length or percentage>{1,4} ]
              borderRadiusRegExp = new RegExp('(border-radius\\s*:\\s*)' + signedQuantPattern + '(?:(?:\\s+' + signedQuantPattern + ')(?:\\s+' + signedQuantPattern + ')?(?:\\s+' + signedQuantPattern + ')?)?' + '(?:(?:(?:\\s*\\/\\s*)' + signedQuantPattern + ')(?:\\s+' + signedQuantPattern + ')?(?:\\s+' + signedQuantPattern + ')?(?:\\s+' + signedQuantPattern + ')?)?' + suffixPattern, 'gi'),
              boxShadowRegExp = new RegExp('(box-shadow\\s*:\\s*(?:inset\\s*)?)' + signedQuantPattern, 'gi'),
              textShadow1RegExp = new RegExp('(text-shadow\\s*:\\s*)' + signedQuantPattern + '(\\s*)' + colorPattern, 'gi'),
              textShadow2RegExp = new RegExp('(text-shadow\\s*:\\s*)' + colorPattern + '(\\s*)' + signedQuantPattern, 'gi'),
              textShadow3RegExp = new RegExp('(text-shadow\\s*:\\s*)' + signedQuantPattern, 'gi'),
              translateXRegExp = new RegExp('(transform\\s*:[^;}]*)(translateX\\s*\\(\\s*)' + signedQuantPattern + '(\\s*\\))', 'gi'),
              translateRegExp = new RegExp('(transform\\s*:[^;}]*)(translate\\s*\\(\\s*)' + signedQuantPattern + '((?:\\s*,\\s*' + signedQuantPattern + '){0,2}\\s*\\))', 'gi');

            /**
             * Invert the horizontal value of a background position property.
             *
             * @private
             * @param {string} match Matched property
             * @param {string} pre Text before value
             * @param {string} value Horizontal value
             * @return {string} Inverted property
             */
            function calculateNewBackgroundPosition(match, pre, value) {
              var idx, len;
              if (value.slice(-1) === '%') {
                idx = value.indexOf('.');
                if (idx !== -1) {
                  // Two off, one for the "%" at the end, one for the dot itself
                  len = value.length - idx - 2;
                  value = 100 - parseFloat(value);
                  value = value.toFixed(len) + '%';
                } else {
                  value = 100 - parseFloat(value) + '%';
                }
              }
              return pre + value;
            }

            /**
             * Invert a set of border radius values.
             *
             * @private
             * @param {Array} values Matched values
             * @return {string} Inverted values
             */
            function flipBorderRadiusValues(values) {
              switch (values.length) {
                case 4:
                  values = [values[1], values[0], values[3], values[2]];
                  break;
                case 3:
                  values = [values[1], values[0], values[1], values[2]];
                  break;
                case 2:
                  values = [values[1], values[0]];
                  break;
                case 1:
                  values = [values[0]];
                  break;
              }
              return values.join(' ');
            }

            /**
             * Invert a set of border radius values.
             *
             * @private
             * @param {string} match Matched property
             * @param {string} pre Text before value
             * @param {string} [firstGroup1]
             * @param {string} [firstGroup2]
             * @param {string} [firstGroup3]
             * @param {string} [firstGroup4]
             * @param {string} [secondGroup1]
             * @param {string} [secondGroup2]
             * @param {string} [secondGroup3]
             * @param {string} [secondGroup4]
             * @param {string} [post] Text after value
             * @return {string} Inverted property
             */
            function calculateNewBorderRadius(match, pre) {
              var values,
                args = [].slice.call(arguments),
                firstGroup = args.slice(2, 6).filter(function (val) {
                  return val;
                }),
                secondGroup = args.slice(6, 10).filter(function (val) {
                  return val;
                }),
                post = args[10] || '';
              if (secondGroup.length) {
                values = flipBorderRadiusValues(firstGroup) + ' / ' + flipBorderRadiusValues(secondGroup);
              } else {
                values = flipBorderRadiusValues(firstGroup);
              }
              return pre + values + post;
            }

            /**
             * Flip the sign of a CSS value, possibly with a unit.
             *
             * We can't just negate the value with unary minus due to the units.
             *
             * @private
             * @param {string} value
             * @return {string}
             */
            function flipSign(value) {
              if (parseFloat(value) === 0) {
                // Don't mangle zeroes
                return value;
              }
              if (value[0] === '-') {
                return value.slice(1);
              }
              return '-' + value;
            }

            /**
             * @private
             * @param {string} match
             * @param {string} property
             * @param {string} offset
             * @return {string}
             */
            function calculateNewShadow(match, property, offset) {
              return property + flipSign(offset);
            }

            /**
             * @private
             * @param {string} match
             * @param {string} property
             * @param {string} prefix
             * @param {string} offset
             * @param {string} suffix
             * @return {string}
             */
            function calculateNewTranslate(match, property, prefix, offset, suffix) {
              return property + prefix + flipSign(offset) + suffix;
            }

            /**
             * @private
             * @param {string} match
             * @param {string} property
             * @param {string} color
             * @param {string} space
             * @param {string} offset
             * @return {string}
             */
            function calculateNewFourTextShadow(match, property, color, space, offset) {
              return property + color + space + flipSign(offset);
            }
            return {
              /**
               * Transform a left-to-right stylesheet to right-to-left.
               *
               * @param {string} css Stylesheet to transform
               * @param {Object} options Options
               * @param {boolean} [options.transformDirInUrl=false] Transform directions in URLs
               * (e.g. 'ltr', 'rtl')
               * @param {boolean} [options.transformEdgeInUrl=false] Transform edges in URLs
               * (e.g. 'left', 'right')
               * @return {string} Transformed stylesheet
               */
              'transform': function (css, options) {
                // eslint-disable-line quote-props
                // Use single quotes in this object literal key for closure compiler.
                // Tokenizers
                var noFlipSingleTokenizer = new Tokenizer(noFlipSingleRegExp, noFlipSingleToken),
                  noFlipClassTokenizer = new Tokenizer(noFlipClassRegExp, noFlipClassToken),
                  commentTokenizer = new Tokenizer(commentRegExp, commentToken);

                // Tokenize
                css = commentTokenizer.tokenize(noFlipClassTokenizer.tokenize(noFlipSingleTokenizer.tokenize(
                // We wrap tokens in ` , not ~ like the original implementation does.
                // This was done because ` is not a legal character in CSS and can only
                // occur in URLs, where we escape it to %60 before inserting our tokens.
                css.replace('`', '%60'))));

                // Transform URLs
                if (options.transformDirInUrl) {
                  // Replace 'ltr' with 'rtl' and vice versa in background URLs
                  css = css.replace(ltrInUrlRegExp, '$1' + temporaryToken).replace(rtlInUrlRegExp, '$1ltr').replace(temporaryTokenRegExp, 'rtl');
                }
                if (options.transformEdgeInUrl) {
                  // Replace 'left' with 'right' and vice versa in background URLs
                  css = css.replace(leftInUrlRegExp, '$1' + temporaryToken).replace(rightInUrlRegExp, '$1left').replace(temporaryTokenRegExp, 'right');
                }

                // Transform rules
                css = css
                // Replace direction: ltr; with direction: rtl; and vice versa.
                .replace(directionLtrRegExp, '$1' + temporaryToken).replace(directionRtlRegExp, '$1ltr').replace(temporaryTokenRegExp, 'rtl')
                // Flip rules like left: , padding-right: , etc.
                .replace(leftRegExp, '$1' + temporaryToken).replace(rightRegExp, '$1left').replace(temporaryTokenRegExp, 'right')
                // Flip East and West in rules like cursor: nw-resize;
                .replace(cursorEastRegExp, '$1$2' + temporaryToken).replace(cursorWestRegExp, '$1$2e-resize').replace(temporaryTokenRegExp, 'w-resize')
                // Border radius
                .replace(borderRadiusRegExp, calculateNewBorderRadius)
                // Shadows
                .replace(boxShadowRegExp, calculateNewShadow).replace(textShadow1RegExp, calculateNewFourTextShadow).replace(textShadow2RegExp, calculateNewFourTextShadow).replace(textShadow3RegExp, calculateNewShadow)
                // Translate
                .replace(translateXRegExp, calculateNewTranslate).replace(translateRegExp, calculateNewTranslate)
                // Swap the second and fourth parts in four-part notation rules
                // like padding: 1px 2px 3px 4px;
                .replace(fourNotationQuantRegExp, '$1$2$3$8$5$6$7$4$9').replace(fourNotationColorRegExp, '$1$2$3$8$5$6$7$4$9')
                // Flip horizontal background percentages
                .replace(bgHorizontalPercentageRegExp, calculateNewBackgroundPosition).replace(bgHorizontalPercentageXRegExp, calculateNewBackgroundPosition);

                // Detokenize
                css = noFlipSingleTokenizer.detokenize(noFlipClassTokenizer.detokenize(commentTokenizer.detokenize(css)));
                return css;
              }
            };
          }

          /* Initialization */

          cssjanus = new CSSJanus();

          /* Exports */

          if (module.exports) {
            /**
             * Transform a left-to-right stylesheet to right-to-left.
             *
             * This function is a static wrapper around the transform method of an instance of CSSJanus.
             *
             * @param {string} css Stylesheet to transform
             * @param {Object|boolean} [options] Options object, or transformDirInUrl option (back-compat)
             * @param {boolean} [options.transformDirInUrl=false] Transform directions in URLs
             * (e.g. 'ltr', 'rtl')
             * @param {boolean} [options.transformEdgeInUrl=false] Transform edges in URLs
             * (e.g. 'left', 'right')
             * @param {boolean} [transformEdgeInUrl] Back-compat parameter
             * @return {string} Transformed stylesheet
             */
            exports.transform = function (css, options, transformEdgeInUrl) {
              var norm;
              if (typeof options === 'object') {
                norm = options;
              } else {
                norm = {};
                if (typeof options === 'boolean') {
                  norm.transformDirInUrl = options;
                }
                if (typeof transformEdgeInUrl === 'boolean') {
                  norm.transformEdgeInUrl = transformEdgeInUrl;
                }
              }
              return cssjanus.transform(css, norm);
            };
          } else if (typeof window !== 'undefined') {
            /* global window */
            // Allow cssjanus to be used in a browser.
            // eslint-disable-next-line dot-notation
            window['cssjanus'] = cssjanus;
          }
        })(cssjanus$1, cssjanus$1.exports);
        var cssjanusExports = cssjanus$1.exports;
        const cssjanus = /*@__PURE__*/getDefaultExportFromCjs(cssjanusExports);
        function stringifyPreserveComments(element, index, children) {
          switch (element.type) {
            case IMPORT:
            case DECLARATION:
            case COMMENT:
              return element.return = element.return || element.value;
            case RULESET:
              {
                element.value = Array.isArray(element.props) ? element.props.join(',') : element.props;
                if (Array.isArray(element.children)) {
                  element.children.forEach(function (x) {
                    if (x.type === COMMENT) x.children = x.value;
                  });
                }
              }
          }
          var serializedChildren = serialize(Array.prototype.concat(element.children), stringifyPreserveComments);
          return strlen(serializedChildren) ? element.return = element.value + '{' + serializedChildren + '}' : '';
        }
        function stylisRTLPlugin(element, index, children, callback) {
          if (element.type === KEYFRAMES || element.type === SUPPORTS || element.type === RULESET && (!element.parent || element.parent.type === MEDIA || element.parent.type === RULESET)) {
            var stringified = cssjanus.transform(stringifyPreserveComments(element));
            element.children = stringified ? compile(stringified)[0].children : [];
            element.return = '';
          }
        }
        // stable identifier that will not be dropped by minification unless the whole module
        // is unused
        Object.defineProperty(stylisRTLPlugin, 'name', {
          value: 'stylisRTLPlugin'
        });
        reactExports.lazy(() => __vitePreload(() => module.import('./index-legacy-c5624c66.js'), false ? "__VITE_PRELOAD__" : void 0));
        reactExports.lazy(() => __vitePreload(() => module.import('./index-legacy-60e15135.js'), false ? "__VITE_PRELOAD__" : void 0));
        reactExports.lazy(() => __vitePreload(() => module.import('./index-legacy-7f6845bf.js'), false ? "__VITE_PRELOAD__" : void 0));
        reactExports.lazy(() => __vitePreload(() => module.import('./index-legacy-2bd69487.js'), false ? "__VITE_PRELOAD__" : void 0));
        reactExports.lazy(() => __vitePreload(() => module.import('./index-legacy-e8c0962e.js'), false ? "__VITE_PRELOAD__" : void 0));
        reactExports.lazy(() => __vitePreload(() => module.import('./index-legacy-5c10a9d7.js'), false ? "__VITE_PRELOAD__" : void 0));
        reactExports.lazy(() => __vitePreload(() => module.import('./index-legacy-95b73b6e.js'), false ? "__VITE_PRELOAD__" : void 0));
        reactExports.lazy(() => __vitePreload(() => module.import('./index-legacy-4f577570.js'), false ? "__VITE_PRELOAD__" : void 0));
        reactExports.lazy(() => __vitePreload(() => module.import('./index-legacy-d131b3e9.js'), false ? "__VITE_PRELOAD__" : void 0));
        reactExports.lazy(() => __vitePreload(() => module.import('./index-legacy-d3320e3c.js'), false ? "__VITE_PRELOAD__" : void 0));
        reactExports.lazy(() => __vitePreload(() => module.import('./index-legacy-9f5adbf1.js'), false ? "__VITE_PRELOAD__" : void 0));
        reactExports.lazy(() => __vitePreload(() => module.import('./index-legacy-a8050e90.js'), false ? "__VITE_PRELOAD__" : void 0));
        reactExports.lazy(() => __vitePreload(() => module.import('./index-legacy-cc016a9d.js'), false ? "__VITE_PRELOAD__" : void 0));
        reactExports.lazy(() => __vitePreload(() => module.import('./index-legacy-b391002e.js'), false ? "__VITE_PRELOAD__" : void 0));
        const RunSurvey = reactExports.lazy(() => __vitePreload(() => module.import('./index-legacy-26c7a8f3.js'), false ? "__VITE_PRELOAD__" : void 0));
        reactExports.lazy(() => __vitePreload(() => module.import('./index-legacy-0c6b21ae.js'), false ? "__VITE_PRELOAD__" : void 0));
        function App() {
          {
            const surveyId = getparam(useParams(), "surveyId");
            sessionStorage.setItem("surveyId", surveyId);
            return /* @__PURE__ */jsxRuntimeExports.jsx(reactExports.Suspense, {
              fallback: /* @__PURE__ */jsxRuntimeExports.jsx(LoadingIndicator, {}),
              children: /* @__PURE__ */jsxRuntimeExports.jsx(Provider, {
                store: runStore,
                children: /* @__PURE__ */jsxRuntimeExports.jsx(RunSurvey, {})
              })
            });
          }
        }
        const index = '';
        const globalStyles = '';
        instance$2.init({
          interpolation: {
            escapeValue: false
          },
          // React already does escaping
          lng: "en",
          fallbackLng: "en",
          resources: {
            en: {
              design: design_en,
              run: run_en,
              manage: manage_en
            },
            de: {
              design: design_de,
              run: run_de,
              manage: manage_de
            },
            ar: {
              design: design_ar,
              run: run_ar,
              manage: manage_ar
            }
          }
        });
        const container = document.getElementById("root");
        const root = createRoot(container);
        root.render( /* @__PURE__ */jsxRuntimeExports.jsx(I18nextProvider, {
          i18n: instance$2,
          children: /* @__PURE__ */jsxRuntimeExports.jsx(BrowserRouter, {
            children: /* @__PURE__ */jsxRuntimeExports.jsx(App, {})
          })
        }));
        unregister();
      }
    };
  });
})();
