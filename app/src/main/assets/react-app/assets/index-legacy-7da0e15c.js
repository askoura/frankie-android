;
(function () {
  System.register(['./index-legacy-4fb9792c.js', './index-legacy-0b5ac1fa.js', './common-legacy-09fb4163.js', './TextField-legacy-cb08e608.js', './useDispatch-legacy-905d57c1.js', './index-legacy-04d0d50e.js', './DatePicker-legacy-eaeb540f.js', './common-legacy-34feaaf1.js', './Card-legacy-6189c383.js', './AuthService-legacy-d2677483.js', './Delete-legacy-44391002.js', './InputLabel-legacy-b05782a9.js', './Checkbox-legacy-383eda19.js', './FormControlLabel-legacy-953c1997.js', './ArrowBack-legacy-33bf5310.js', './LogoutOutlined-legacy-d5aae7e6.js', './FormGroup-legacy-e7adf2ba.js', './KeyboardArrowRight-legacy-f003461c.js', './InputAdornment-legacy-02205919.js'], function (exports, module) {
    'use strict';

    var __vite_style__ = document.createElement('style');
    __vite_style__.textContent = "._mainContainer_1qlrg_1 {\n  max-width: 1440px;\n  margin: auto;\n  display: grid;\n  grid-template-columns: 0.5fr 1fr;\n  align-items: flex-start;\n}\n\n._updateButtons_1qlrg_9 {\n  width: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  margin-bottom: 20px;\n  margin-top: 20px;\n}\n\n._save_1qlrg_18 {\n  margin-left: 10px;\n}\n._questionItem_wb37f_1 {\n  margin-bottom: 15px;\n  width: 50%;\n}\n\n._questionItem_wb37f_1:last-child {\n  margin-bottom: 0;\n}\n\n@media screen and (max-width: 768px) {\n  ._questionItem_wb37f_1 {\n    width: 100%;\n  }\n}\n._questionItem_1sx0f_1 {\n  margin-bottom: 15px;\n  width: 50%;\n}\n\n._questionItem_1sx0f_1:last-child {\n  margin-bottom: 0;\n}\n\n@media only screen and (max-width: 767px) {\n  ._questionItem_1sx0f_1 {\n    width: 100%;\n  }\n}\n._questionItem_169qj_1 {\n  margin-bottom: 15px;\n  width: 50%;\n}\n\n._questionItem_169qj_1:last-child {\n  margin-bottom: 0;\n}\n\n@media (max-width: 767px) {\n  ._questionItem_169qj_1 {\n    width: 100%;\n  }\n}\n._questionItem_13fbu_1 {\n  margin-bottom: 15px;\n}\n\n._questionItem_13fbu_1:last-child {\n  margin-bottom: 0;\n}\n\n@media (max-width: 767px) {\n  ._questionItem_13fbu_1 {\n    width: 100%;\n  }\n}\n\n._paragraph_13fbu_15 {\n  width: 100%;\n}\n\n._wordCount_13fbu_19 {\n  text-align: end;\n}\n._textDescriptionContent_meegl_1 {\n  display: flex;\n  align-items: center;\n  margin-top: 6px;\n}\n\n._groupQuestion_meegl_7 {\n  position: relative;\n  margin-bottom: 24px;\n  padding: 24px;\n  border: 1px solid;\n  border-radius: 8px;\n  word-wrap: break-word;\n  page-break-inside: avoid;\n  transition: all 200ms cubic-bezier(0, 0, 0.2, 1);\n  cursor: default;\n}\n\n._titleQuestion_meegl_19 {\n  display: flex;\n  align-items: center;\n}\n\n._titleQuestion_meegl_19 h3 {\n  width: auto;\n}\n\n._questionWrapper_meegl_28 {\n  margin-bottom: 8px;\n}\n\n._questionWrapper_meegl_28 ._inputQuestionTitle_meegl_32 {\n  width: 100%;\n  letter-spacing: 0.1px;\n  word-break: break-word;\n}\n\n._questionWrapper_meegl_28 ._inputQuestionDescription_meegl_38 {\n  width: 100%;\n}\n\n._questionWrapper_meegl_28 ._moveBox_meegl_42 {\n  position: absolute;\n  top: 0;\n  left: 50%;\n  transform: translateX(-50%);\n  display: flex;\n  justify-content: center;\n  width: 50%;\n  font-size: 22px;\n  cursor: move;\n}\n._fullWidth_1dvff_1 {\n  width: 100%;\n  cursor: text;\n}\n\n._toolbarClass_1dvff_6 div ._rdw-editor-toolbar_1dvff_6 {\n  border: 0 !important;\n  margin: 0 !important;\n  padding: 0 !important;\n}\n\n._noPadding_1dvff_12 > :last-child {\n  margin-bottom: 0;\n}\n\n._noPadding_1dvff_12 > :first-child {\n  margin-top: 0;\n}\n\np {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n._placeholder_1dvff_25 {\n  color: #aaa;\n}\n\n._placeholder_1dvff_25 > :first-child {\n  margin-top: 0;\n}\n\n._placeholder_1dvff_25 > :last-child {\n  margin-bottom: 0;\n}\n.ql-editor {\n  padding: 0 !important;\n}\n\n.ql-container {\n  font-size: inherit !important;\n  font-family: inherit !important;\n}\n\n.ql-snow {\n  padding: 0 !important;\n  border: 0 !important;\n}\n\n.quill {\n  display: flex;\n  flex-direction: column-reverse;\n}\n\n.rtl .ql-editor {\n  direction: rtl !important;\n  text-align: right !important;\n}\n\n.rtl {\n  direction: rtl !important;\n  text-align: right !important;\n}\n/*!\n * Quill Editor v1.3.7\n * https://quilljs.com/\n * Copyright (c) 2014, Jason Chen\n * Copyright (c) 2013, salesforce.com\n */\n.ql-container {\n  box-sizing: border-box;\n  font-family: Helvetica, Arial, sans-serif;\n  font-size: 13px;\n  height: 100%;\n  margin: 0px;\n  position: relative;\n}\n.ql-container.ql-disabled .ql-tooltip {\n  visibility: hidden;\n}\n.ql-container.ql-disabled .ql-editor ul[data-checked] > li::before {\n  pointer-events: none;\n}\n.ql-clipboard {\n  left: -100000px;\n  height: 1px;\n  overflow-y: hidden;\n  position: absolute;\n  top: 50%;\n}\n.ql-clipboard p {\n  margin: 0;\n  padding: 0;\n}\n.ql-editor {\n  box-sizing: border-box;\n  line-height: 1.42;\n  height: 100%;\n  outline: none;\n  overflow-y: auto;\n  padding: 12px 15px;\n  tab-size: 4;\n  -moz-tab-size: 4;\n  text-align: left;\n  white-space: pre-wrap;\n  word-wrap: break-word;\n}\n.ql-editor > * {\n  cursor: text;\n}\n.ql-editor p,\n.ql-editor ol,\n.ql-editor ul,\n.ql-editor pre,\n.ql-editor blockquote,\n.ql-editor h1,\n.ql-editor h2,\n.ql-editor h3,\n.ql-editor h4,\n.ql-editor h5,\n.ql-editor h6 {\n  margin: 0;\n  padding: 0;\n  counter-reset: list-1 list-2 list-3 list-4 list-5 list-6 list-7 list-8 list-9;\n}\n.ql-editor ol,\n.ql-editor ul {\n  padding-left: 1.5em;\n}\n.ql-editor ol > li,\n.ql-editor ul > li {\n  list-style-type: none;\n}\n.ql-editor ul > li::before {\n  content: '\\2022';\n}\n.ql-editor ul[data-checked=true],\n.ql-editor ul[data-checked=false] {\n  pointer-events: none;\n}\n.ql-editor ul[data-checked=true] > li *,\n.ql-editor ul[data-checked=false] > li * {\n  pointer-events: all;\n}\n.ql-editor ul[data-checked=true] > li::before,\n.ql-editor ul[data-checked=false] > li::before {\n  color: #777;\n  cursor: pointer;\n  pointer-events: all;\n}\n.ql-editor ul[data-checked=true] > li::before {\n  content: '\\2611';\n}\n.ql-editor ul[data-checked=false] > li::before {\n  content: '\\2610';\n}\n.ql-editor li::before {\n  display: inline-block;\n  white-space: nowrap;\n  width: 1.2em;\n}\n.ql-editor li:not(.ql-direction-rtl)::before {\n  margin-left: -1.5em;\n  margin-right: 0.3em;\n  text-align: right;\n}\n.ql-editor li.ql-direction-rtl::before {\n  margin-left: 0.3em;\n  margin-right: -1.5em;\n}\n.ql-editor ol li:not(.ql-direction-rtl),\n.ql-editor ul li:not(.ql-direction-rtl) {\n  padding-left: 1.5em;\n}\n.ql-editor ol li.ql-direction-rtl,\n.ql-editor ul li.ql-direction-rtl {\n  padding-right: 1.5em;\n}\n.ql-editor ol li {\n  counter-reset: list-1 list-2 list-3 list-4 list-5 list-6 list-7 list-8 list-9;\n  counter-increment: list-0;\n}\n.ql-editor ol li:before {\n  content: counter(list-0, decimal) '. ';\n}\n.ql-editor ol li.ql-indent-1 {\n  counter-increment: list-1;\n}\n.ql-editor ol li.ql-indent-1:before {\n  content: counter(list-1, lower-alpha) '. ';\n}\n.ql-editor ol li.ql-indent-1 {\n  counter-reset: list-2 list-3 list-4 list-5 list-6 list-7 list-8 list-9;\n}\n.ql-editor ol li.ql-indent-2 {\n  counter-increment: list-2;\n}\n.ql-editor ol li.ql-indent-2:before {\n  content: counter(list-2, lower-roman) '. ';\n}\n.ql-editor ol li.ql-indent-2 {\n  counter-reset: list-3 list-4 list-5 list-6 list-7 list-8 list-9;\n}\n.ql-editor ol li.ql-indent-3 {\n  counter-increment: list-3;\n}\n.ql-editor ol li.ql-indent-3:before {\n  content: counter(list-3, decimal) '. ';\n}\n.ql-editor ol li.ql-indent-3 {\n  counter-reset: list-4 list-5 list-6 list-7 list-8 list-9;\n}\n.ql-editor ol li.ql-indent-4 {\n  counter-increment: list-4;\n}\n.ql-editor ol li.ql-indent-4:before {\n  content: counter(list-4, lower-alpha) '. ';\n}\n.ql-editor ol li.ql-indent-4 {\n  counter-reset: list-5 list-6 list-7 list-8 list-9;\n}\n.ql-editor ol li.ql-indent-5 {\n  counter-increment: list-5;\n}\n.ql-editor ol li.ql-indent-5:before {\n  content: counter(list-5, lower-roman) '. ';\n}\n.ql-editor ol li.ql-indent-5 {\n  counter-reset: list-6 list-7 list-8 list-9;\n}\n.ql-editor ol li.ql-indent-6 {\n  counter-increment: list-6;\n}\n.ql-editor ol li.ql-indent-6:before {\n  content: counter(list-6, decimal) '. ';\n}\n.ql-editor ol li.ql-indent-6 {\n  counter-reset: list-7 list-8 list-9;\n}\n.ql-editor ol li.ql-indent-7 {\n  counter-increment: list-7;\n}\n.ql-editor ol li.ql-indent-7:before {\n  content: counter(list-7, lower-alpha) '. ';\n}\n.ql-editor ol li.ql-indent-7 {\n  counter-reset: list-8 list-9;\n}\n.ql-editor ol li.ql-indent-8 {\n  counter-increment: list-8;\n}\n.ql-editor ol li.ql-indent-8:before {\n  content: counter(list-8, lower-roman) '. ';\n}\n.ql-editor ol li.ql-indent-8 {\n  counter-reset: list-9;\n}\n.ql-editor ol li.ql-indent-9 {\n  counter-increment: list-9;\n}\n.ql-editor ol li.ql-indent-9:before {\n  content: counter(list-9, decimal) '. ';\n}\n.ql-editor .ql-indent-1:not(.ql-direction-rtl) {\n  padding-left: 3em;\n}\n.ql-editor li.ql-indent-1:not(.ql-direction-rtl) {\n  padding-left: 4.5em;\n}\n.ql-editor .ql-indent-1.ql-direction-rtl.ql-align-right {\n  padding-right: 3em;\n}\n.ql-editor li.ql-indent-1.ql-direction-rtl.ql-align-right {\n  padding-right: 4.5em;\n}\n.ql-editor .ql-indent-2:not(.ql-direction-rtl) {\n  padding-left: 6em;\n}\n.ql-editor li.ql-indent-2:not(.ql-direction-rtl) {\n  padding-left: 7.5em;\n}\n.ql-editor .ql-indent-2.ql-direction-rtl.ql-align-right {\n  padding-right: 6em;\n}\n.ql-editor li.ql-indent-2.ql-direction-rtl.ql-align-right {\n  padding-right: 7.5em;\n}\n.ql-editor .ql-indent-3:not(.ql-direction-rtl) {\n  padding-left: 9em;\n}\n.ql-editor li.ql-indent-3:not(.ql-direction-rtl) {\n  padding-left: 10.5em;\n}\n.ql-editor .ql-indent-3.ql-direction-rtl.ql-align-right {\n  padding-right: 9em;\n}\n.ql-editor li.ql-indent-3.ql-direction-rtl.ql-align-right {\n  padding-right: 10.5em;\n}\n.ql-editor .ql-indent-4:not(.ql-direction-rtl) {\n  padding-left: 12em;\n}\n.ql-editor li.ql-indent-4:not(.ql-direction-rtl) {\n  padding-left: 13.5em;\n}\n.ql-editor .ql-indent-4.ql-direction-rtl.ql-align-right {\n  padding-right: 12em;\n}\n.ql-editor li.ql-indent-4.ql-direction-rtl.ql-align-right {\n  padding-right: 13.5em;\n}\n.ql-editor .ql-indent-5:not(.ql-direction-rtl) {\n  padding-left: 15em;\n}\n.ql-editor li.ql-indent-5:not(.ql-direction-rtl) {\n  padding-left: 16.5em;\n}\n.ql-editor .ql-indent-5.ql-direction-rtl.ql-align-right {\n  padding-right: 15em;\n}\n.ql-editor li.ql-indent-5.ql-direction-rtl.ql-align-right {\n  padding-right: 16.5em;\n}\n.ql-editor .ql-indent-6:not(.ql-direction-rtl) {\n  padding-left: 18em;\n}\n.ql-editor li.ql-indent-6:not(.ql-direction-rtl) {\n  padding-left: 19.5em;\n}\n.ql-editor .ql-indent-6.ql-direction-rtl.ql-align-right {\n  padding-right: 18em;\n}\n.ql-editor li.ql-indent-6.ql-direction-rtl.ql-align-right {\n  padding-right: 19.5em;\n}\n.ql-editor .ql-indent-7:not(.ql-direction-rtl) {\n  padding-left: 21em;\n}\n.ql-editor li.ql-indent-7:not(.ql-direction-rtl) {\n  padding-left: 22.5em;\n}\n.ql-editor .ql-indent-7.ql-direction-rtl.ql-align-right {\n  padding-right: 21em;\n}\n.ql-editor li.ql-indent-7.ql-direction-rtl.ql-align-right {\n  padding-right: 22.5em;\n}\n.ql-editor .ql-indent-8:not(.ql-direction-rtl) {\n  padding-left: 24em;\n}\n.ql-editor li.ql-indent-8:not(.ql-direction-rtl) {\n  padding-left: 25.5em;\n}\n.ql-editor .ql-indent-8.ql-direction-rtl.ql-align-right {\n  padding-right: 24em;\n}\n.ql-editor li.ql-indent-8.ql-direction-rtl.ql-align-right {\n  padding-right: 25.5em;\n}\n.ql-editor .ql-indent-9:not(.ql-direction-rtl) {\n  padding-left: 27em;\n}\n.ql-editor li.ql-indent-9:not(.ql-direction-rtl) {\n  padding-left: 28.5em;\n}\n.ql-editor .ql-indent-9.ql-direction-rtl.ql-align-right {\n  padding-right: 27em;\n}\n.ql-editor li.ql-indent-9.ql-direction-rtl.ql-align-right {\n  padding-right: 28.5em;\n}\n.ql-editor .ql-video {\n  display: block;\n  max-width: 100%;\n}\n.ql-editor .ql-video.ql-align-center {\n  margin: 0 auto;\n}\n.ql-editor .ql-video.ql-align-right {\n  margin: 0 0 0 auto;\n}\n.ql-editor .ql-bg-black {\n  background-color: #000;\n}\n.ql-editor .ql-bg-red {\n  background-color: #e60000;\n}\n.ql-editor .ql-bg-orange {\n  background-color: #f90;\n}\n.ql-editor .ql-bg-yellow {\n  background-color: #ff0;\n}\n.ql-editor .ql-bg-green {\n  background-color: #008a00;\n}\n.ql-editor .ql-bg-blue {\n  background-color: #06c;\n}\n.ql-editor .ql-bg-purple {\n  background-color: #93f;\n}\n.ql-editor .ql-color-white {\n  color: #fff;\n}\n.ql-editor .ql-color-red {\n  color: #e60000;\n}\n.ql-editor .ql-color-orange {\n  color: #f90;\n}\n.ql-editor .ql-color-yellow {\n  color: #ff0;\n}\n.ql-editor .ql-color-green {\n  color: #008a00;\n}\n.ql-editor .ql-color-blue {\n  color: #06c;\n}\n.ql-editor .ql-color-purple {\n  color: #93f;\n}\n.ql-editor .ql-font-serif {\n  font-family: Georgia, Times New Roman, serif;\n}\n.ql-editor .ql-font-monospace {\n  font-family: Monaco, Courier New, monospace;\n}\n.ql-editor .ql-size-small {\n  font-size: 0.75em;\n}\n.ql-editor .ql-size-large {\n  font-size: 1.5em;\n}\n.ql-editor .ql-size-huge {\n  font-size: 2.5em;\n}\n.ql-editor .ql-direction-rtl {\n  direction: rtl;\n  text-align: inherit;\n}\n.ql-editor .ql-align-center {\n  text-align: center;\n}\n.ql-editor .ql-align-justify {\n  text-align: justify;\n}\n.ql-editor .ql-align-right {\n  text-align: right;\n}\n.ql-editor.ql-blank::before {\n  color: rgba(0,0,0,0.6);\n  content: attr(data-placeholder);\n  font-style: italic;\n  left: 15px;\n  pointer-events: none;\n  position: absolute;\n  right: 15px;\n}\n.ql-snow.ql-toolbar:after,\n.ql-snow .ql-toolbar:after {\n  clear: both;\n  content: '';\n  display: table;\n}\n.ql-snow.ql-toolbar button,\n.ql-snow .ql-toolbar button {\n  background: none;\n  border: none;\n  cursor: pointer;\n  display: inline-block;\n  float: left;\n  height: 24px;\n  padding: 3px 5px;\n  width: 28px;\n}\n.ql-snow.ql-toolbar button svg,\n.ql-snow .ql-toolbar button svg {\n  float: left;\n  height: 100%;\n}\n.ql-snow.ql-toolbar button:active:hover,\n.ql-snow .ql-toolbar button:active:hover {\n  outline: none;\n}\n.ql-snow.ql-toolbar input.ql-image[type=file],\n.ql-snow .ql-toolbar input.ql-image[type=file] {\n  display: none;\n}\n.ql-snow.ql-toolbar button:hover,\n.ql-snow .ql-toolbar button:hover,\n.ql-snow.ql-toolbar button:focus,\n.ql-snow .ql-toolbar button:focus,\n.ql-snow.ql-toolbar button.ql-active,\n.ql-snow .ql-toolbar button.ql-active,\n.ql-snow.ql-toolbar .ql-picker-label:hover,\n.ql-snow .ql-toolbar .ql-picker-label:hover,\n.ql-snow.ql-toolbar .ql-picker-label.ql-active,\n.ql-snow .ql-toolbar .ql-picker-label.ql-active,\n.ql-snow.ql-toolbar .ql-picker-item:hover,\n.ql-snow .ql-toolbar .ql-picker-item:hover,\n.ql-snow.ql-toolbar .ql-picker-item.ql-selected,\n.ql-snow .ql-toolbar .ql-picker-item.ql-selected {\n  color: #06c;\n}\n.ql-snow.ql-toolbar button:hover .ql-fill,\n.ql-snow .ql-toolbar button:hover .ql-fill,\n.ql-snow.ql-toolbar button:focus .ql-fill,\n.ql-snow .ql-toolbar button:focus .ql-fill,\n.ql-snow.ql-toolbar button.ql-active .ql-fill,\n.ql-snow .ql-toolbar button.ql-active .ql-fill,\n.ql-snow.ql-toolbar .ql-picker-label:hover .ql-fill,\n.ql-snow .ql-toolbar .ql-picker-label:hover .ql-fill,\n.ql-snow.ql-toolbar .ql-picker-label.ql-active .ql-fill,\n.ql-snow .ql-toolbar .ql-picker-label.ql-active .ql-fill,\n.ql-snow.ql-toolbar .ql-picker-item:hover .ql-fill,\n.ql-snow .ql-toolbar .ql-picker-item:hover .ql-fill,\n.ql-snow.ql-toolbar .ql-picker-item.ql-selected .ql-fill,\n.ql-snow .ql-toolbar .ql-picker-item.ql-selected .ql-fill,\n.ql-snow.ql-toolbar button:hover .ql-stroke.ql-fill,\n.ql-snow .ql-toolbar button:hover .ql-stroke.ql-fill,\n.ql-snow.ql-toolbar button:focus .ql-stroke.ql-fill,\n.ql-snow .ql-toolbar button:focus .ql-stroke.ql-fill,\n.ql-snow.ql-toolbar button.ql-active .ql-stroke.ql-fill,\n.ql-snow .ql-toolbar button.ql-active .ql-stroke.ql-fill,\n.ql-snow.ql-toolbar .ql-picker-label:hover .ql-stroke.ql-fill,\n.ql-snow .ql-toolbar .ql-picker-label:hover .ql-stroke.ql-fill,\n.ql-snow.ql-toolbar .ql-picker-label.ql-active .ql-stroke.ql-fill,\n.ql-snow .ql-toolbar .ql-picker-label.ql-active .ql-stroke.ql-fill,\n.ql-snow.ql-toolbar .ql-picker-item:hover .ql-stroke.ql-fill,\n.ql-snow .ql-toolbar .ql-picker-item:hover .ql-stroke.ql-fill,\n.ql-snow.ql-toolbar .ql-picker-item.ql-selected .ql-stroke.ql-fill,\n.ql-snow .ql-toolbar .ql-picker-item.ql-selected .ql-stroke.ql-fill {\n  fill: #06c;\n}\n.ql-snow.ql-toolbar button:hover .ql-stroke,\n.ql-snow .ql-toolbar button:hover .ql-stroke,\n.ql-snow.ql-toolbar button:focus .ql-stroke,\n.ql-snow .ql-toolbar button:focus .ql-stroke,\n.ql-snow.ql-toolbar button.ql-active .ql-stroke,\n.ql-snow .ql-toolbar button.ql-active .ql-stroke,\n.ql-snow.ql-toolbar .ql-picker-label:hover .ql-stroke,\n.ql-snow .ql-toolbar .ql-picker-label:hover .ql-stroke,\n.ql-snow.ql-toolbar .ql-picker-label.ql-active .ql-stroke,\n.ql-snow .ql-toolbar .ql-picker-label.ql-active .ql-stroke,\n.ql-snow.ql-toolbar .ql-picker-item:hover .ql-stroke,\n.ql-snow .ql-toolbar .ql-picker-item:hover .ql-stroke,\n.ql-snow.ql-toolbar .ql-picker-item.ql-selected .ql-stroke,\n.ql-snow .ql-toolbar .ql-picker-item.ql-selected .ql-stroke,\n.ql-snow.ql-toolbar button:hover .ql-stroke-miter,\n.ql-snow .ql-toolbar button:hover .ql-stroke-miter,\n.ql-snow.ql-toolbar button:focus .ql-stroke-miter,\n.ql-snow .ql-toolbar button:focus .ql-stroke-miter,\n.ql-snow.ql-toolbar button.ql-active .ql-stroke-miter,\n.ql-snow .ql-toolbar button.ql-active .ql-stroke-miter,\n.ql-snow.ql-toolbar .ql-picker-label:hover .ql-stroke-miter,\n.ql-snow .ql-toolbar .ql-picker-label:hover .ql-stroke-miter,\n.ql-snow.ql-toolbar .ql-picker-label.ql-active .ql-stroke-miter,\n.ql-snow .ql-toolbar .ql-picker-label.ql-active .ql-stroke-miter,\n.ql-snow.ql-toolbar .ql-picker-item:hover .ql-stroke-miter,\n.ql-snow .ql-toolbar .ql-picker-item:hover .ql-stroke-miter,\n.ql-snow.ql-toolbar .ql-picker-item.ql-selected .ql-stroke-miter,\n.ql-snow .ql-toolbar .ql-picker-item.ql-selected .ql-stroke-miter {\n  stroke: #06c;\n}\n@media (pointer: coarse) {\n  .ql-snow.ql-toolbar button:hover:not(.ql-active),\n  .ql-snow .ql-toolbar button:hover:not(.ql-active) {\n    color: #444;\n  }\n  .ql-snow.ql-toolbar button:hover:not(.ql-active) .ql-fill,\n  .ql-snow .ql-toolbar button:hover:not(.ql-active) .ql-fill,\n  .ql-snow.ql-toolbar button:hover:not(.ql-active) .ql-stroke.ql-fill,\n  .ql-snow .ql-toolbar button:hover:not(.ql-active) .ql-stroke.ql-fill {\n    fill: #444;\n  }\n  .ql-snow.ql-toolbar button:hover:not(.ql-active) .ql-stroke,\n  .ql-snow .ql-toolbar button:hover:not(.ql-active) .ql-stroke,\n  .ql-snow.ql-toolbar button:hover:not(.ql-active) .ql-stroke-miter,\n  .ql-snow .ql-toolbar button:hover:not(.ql-active) .ql-stroke-miter {\n    stroke: #444;\n  }\n}\n.ql-snow {\n  box-sizing: border-box;\n}\n.ql-snow * {\n  box-sizing: border-box;\n}\n.ql-snow .ql-hidden {\n  display: none;\n}\n.ql-snow .ql-out-bottom,\n.ql-snow .ql-out-top {\n  visibility: hidden;\n}\n.ql-snow .ql-tooltip {\n  position: absolute;\n  transform: translateY(10px);\n}\n.ql-snow .ql-tooltip a {\n  cursor: pointer;\n  text-decoration: none;\n}\n.ql-snow .ql-tooltip.ql-flip {\n  transform: translateY(-10px);\n}\n.ql-snow .ql-formats {\n  display: inline-block;\n  vertical-align: middle;\n}\n.ql-snow .ql-formats:after {\n  clear: both;\n  content: '';\n  display: table;\n}\n.ql-snow .ql-stroke {\n  fill: none;\n  stroke: #444;\n  stroke-linecap: round;\n  stroke-linejoin: round;\n  stroke-width: 2;\n}\n.ql-snow .ql-stroke-miter {\n  fill: none;\n  stroke: #444;\n  stroke-miterlimit: 10;\n  stroke-width: 2;\n}\n.ql-snow .ql-fill,\n.ql-snow .ql-stroke.ql-fill {\n  fill: #444;\n}\n.ql-snow .ql-empty {\n  fill: none;\n}\n.ql-snow .ql-even {\n  fill-rule: evenodd;\n}\n.ql-snow .ql-thin,\n.ql-snow .ql-stroke.ql-thin {\n  stroke-width: 1;\n}\n.ql-snow .ql-transparent {\n  opacity: 0.4;\n}\n.ql-snow .ql-direction svg:last-child {\n  display: none;\n}\n.ql-snow .ql-direction.ql-active svg:last-child {\n  display: inline;\n}\n.ql-snow .ql-direction.ql-active svg:first-child {\n  display: none;\n}\n.ql-snow .ql-editor h1 {\n  font-size: 2em;\n}\n.ql-snow .ql-editor h2 {\n  font-size: 1.5em;\n}\n.ql-snow .ql-editor h3 {\n  font-size: 1.17em;\n}\n.ql-snow .ql-editor h4 {\n  font-size: 1em;\n}\n.ql-snow .ql-editor h5 {\n  font-size: 0.83em;\n}\n.ql-snow .ql-editor h6 {\n  font-size: 0.67em;\n}\n.ql-snow .ql-editor a {\n  text-decoration: underline;\n}\n.ql-snow .ql-editor blockquote {\n  border-left: 4px solid #ccc;\n  margin-bottom: 5px;\n  margin-top: 5px;\n  padding-left: 16px;\n}\n.ql-snow .ql-editor code,\n.ql-snow .ql-editor pre {\n  background-color: #f0f0f0;\n  border-radius: 3px;\n}\n.ql-snow .ql-editor pre {\n  white-space: pre-wrap;\n  margin-bottom: 5px;\n  margin-top: 5px;\n  padding: 5px 10px;\n}\n.ql-snow .ql-editor code {\n  font-size: 85%;\n  padding: 2px 4px;\n}\n.ql-snow .ql-editor pre.ql-syntax {\n  background-color: #23241f;\n  color: #f8f8f2;\n  overflow: visible;\n}\n.ql-snow .ql-editor img {\n  max-width: 100%;\n}\n.ql-snow .ql-picker {\n  color: #444;\n  display: inline-block;\n  float: left;\n  font-size: 14px;\n  font-weight: 500;\n  height: 24px;\n  position: relative;\n  vertical-align: middle;\n}\n.ql-snow .ql-picker-label {\n  cursor: pointer;\n  display: inline-block;\n  height: 100%;\n  padding-left: 8px;\n  padding-right: 2px;\n  position: relative;\n  width: 100%;\n}\n.ql-snow .ql-picker-label::before {\n  display: inline-block;\n  line-height: 22px;\n}\n.ql-snow .ql-picker-options {\n  background-color: #fff;\n  display: none;\n  min-width: 100%;\n  padding: 4px 8px;\n  position: absolute;\n  white-space: nowrap;\n}\n.ql-snow .ql-picker-options .ql-picker-item {\n  cursor: pointer;\n  display: block;\n  padding-bottom: 5px;\n  padding-top: 5px;\n}\n.ql-snow .ql-picker.ql-expanded .ql-picker-label {\n  color: #ccc;\n  z-index: 2;\n}\n.ql-snow .ql-picker.ql-expanded .ql-picker-label .ql-fill {\n  fill: #ccc;\n}\n.ql-snow .ql-picker.ql-expanded .ql-picker-label .ql-stroke {\n  stroke: #ccc;\n}\n.ql-snow .ql-picker.ql-expanded .ql-picker-options {\n  display: block;\n  margin-top: -1px;\n  top: 100%;\n  z-index: 1;\n}\n.ql-snow .ql-color-picker,\n.ql-snow .ql-icon-picker {\n  width: 28px;\n}\n.ql-snow .ql-color-picker .ql-picker-label,\n.ql-snow .ql-icon-picker .ql-picker-label {\n  padding: 2px 4px;\n}\n.ql-snow .ql-color-picker .ql-picker-label svg,\n.ql-snow .ql-icon-picker .ql-picker-label svg {\n  right: 4px;\n}\n.ql-snow .ql-icon-picker .ql-picker-options {\n  padding: 4px 0px;\n}\n.ql-snow .ql-icon-picker .ql-picker-item {\n  height: 24px;\n  width: 24px;\n  padding: 2px 4px;\n}\n.ql-snow .ql-color-picker .ql-picker-options {\n  padding: 3px 5px;\n  width: 152px;\n}\n.ql-snow .ql-color-picker .ql-picker-item {\n  border: 1px solid transparent;\n  float: left;\n  height: 16px;\n  margin: 2px;\n  padding: 0px;\n  width: 16px;\n}\n.ql-snow .ql-picker:not(.ql-color-picker):not(.ql-icon-picker) svg {\n  position: absolute;\n  margin-top: -9px;\n  right: 0;\n  top: 50%;\n  width: 18px;\n}\n.ql-snow .ql-picker.ql-header .ql-picker-label[data-label]:not([data-label=''])::before,\n.ql-snow .ql-picker.ql-font .ql-picker-label[data-label]:not([data-label=''])::before,\n.ql-snow .ql-picker.ql-size .ql-picker-label[data-label]:not([data-label=''])::before,\n.ql-snow .ql-picker.ql-header .ql-picker-item[data-label]:not([data-label=''])::before,\n.ql-snow .ql-picker.ql-font .ql-picker-item[data-label]:not([data-label=''])::before,\n.ql-snow .ql-picker.ql-size .ql-picker-item[data-label]:not([data-label=''])::before {\n  content: attr(data-label);\n}\n.ql-snow .ql-picker.ql-header {\n  width: 98px;\n}\n.ql-snow .ql-picker.ql-header .ql-picker-label::before,\n.ql-snow .ql-picker.ql-header .ql-picker-item::before {\n  content: 'Normal';\n}\n.ql-snow .ql-picker.ql-header .ql-picker-label[data-value=\"1\"]::before,\n.ql-snow .ql-picker.ql-header .ql-picker-item[data-value=\"1\"]::before {\n  content: 'Heading 1';\n}\n.ql-snow .ql-picker.ql-header .ql-picker-label[data-value=\"2\"]::before,\n.ql-snow .ql-picker.ql-header .ql-picker-item[data-value=\"2\"]::before {\n  content: 'Heading 2';\n}\n.ql-snow .ql-picker.ql-header .ql-picker-label[data-value=\"3\"]::before,\n.ql-snow .ql-picker.ql-header .ql-picker-item[data-value=\"3\"]::before {\n  content: 'Heading 3';\n}\n.ql-snow .ql-picker.ql-header .ql-picker-label[data-value=\"4\"]::before,\n.ql-snow .ql-picker.ql-header .ql-picker-item[data-value=\"4\"]::before {\n  content: 'Heading 4';\n}\n.ql-snow .ql-picker.ql-header .ql-picker-label[data-value=\"5\"]::before,\n.ql-snow .ql-picker.ql-header .ql-picker-item[data-value=\"5\"]::before {\n  content: 'Heading 5';\n}\n.ql-snow .ql-picker.ql-header .ql-picker-label[data-value=\"6\"]::before,\n.ql-snow .ql-picker.ql-header .ql-picker-item[data-value=\"6\"]::before {\n  content: 'Heading 6';\n}\n.ql-snow .ql-picker.ql-header .ql-picker-item[data-value=\"1\"]::before {\n  font-size: 2em;\n}\n.ql-snow .ql-picker.ql-header .ql-picker-item[data-value=\"2\"]::before {\n  font-size: 1.5em;\n}\n.ql-snow .ql-picker.ql-header .ql-picker-item[data-value=\"3\"]::before {\n  font-size: 1.17em;\n}\n.ql-snow .ql-picker.ql-header .ql-picker-item[data-value=\"4\"]::before {\n  font-size: 1em;\n}\n.ql-snow .ql-picker.ql-header .ql-picker-item[data-value=\"5\"]::before {\n  font-size: 0.83em;\n}\n.ql-snow .ql-picker.ql-header .ql-picker-item[data-value=\"6\"]::before {\n  font-size: 0.67em;\n}\n.ql-snow .ql-picker.ql-font {\n  width: 108px;\n}\n.ql-snow .ql-picker.ql-font .ql-picker-label::before,\n.ql-snow .ql-picker.ql-font .ql-picker-item::before {\n  content: 'Sans Serif';\n}\n.ql-snow .ql-picker.ql-font .ql-picker-label[data-value=serif]::before,\n.ql-snow .ql-picker.ql-font .ql-picker-item[data-value=serif]::before {\n  content: 'Serif';\n}\n.ql-snow .ql-picker.ql-font .ql-picker-label[data-value=monospace]::before,\n.ql-snow .ql-picker.ql-font .ql-picker-item[data-value=monospace]::before {\n  content: 'Monospace';\n}\n.ql-snow .ql-picker.ql-font .ql-picker-item[data-value=serif]::before {\n  font-family: Georgia, Times New Roman, serif;\n}\n.ql-snow .ql-picker.ql-font .ql-picker-item[data-value=monospace]::before {\n  font-family: Monaco, Courier New, monospace;\n}\n.ql-snow .ql-picker.ql-size {\n  width: 98px;\n}\n.ql-snow .ql-picker.ql-size .ql-picker-label::before,\n.ql-snow .ql-picker.ql-size .ql-picker-item::before {\n  content: 'Normal';\n}\n.ql-snow .ql-picker.ql-size .ql-picker-label[data-value=small]::before,\n.ql-snow .ql-picker.ql-size .ql-picker-item[data-value=small]::before {\n  content: 'Small';\n}\n.ql-snow .ql-picker.ql-size .ql-picker-label[data-value=large]::before,\n.ql-snow .ql-picker.ql-size .ql-picker-item[data-value=large]::before {\n  content: 'Large';\n}\n.ql-snow .ql-picker.ql-size .ql-picker-label[data-value=huge]::before,\n.ql-snow .ql-picker.ql-size .ql-picker-item[data-value=huge]::before {\n  content: 'Huge';\n}\n.ql-snow .ql-picker.ql-size .ql-picker-item[data-value=small]::before {\n  font-size: 10px;\n}\n.ql-snow .ql-picker.ql-size .ql-picker-item[data-value=large]::before {\n  font-size: 18px;\n}\n.ql-snow .ql-picker.ql-size .ql-picker-item[data-value=huge]::before {\n  font-size: 32px;\n}\n.ql-snow .ql-color-picker.ql-background .ql-picker-item {\n  background-color: #fff;\n}\n.ql-snow .ql-color-picker.ql-color .ql-picker-item {\n  background-color: #000;\n}\n.ql-toolbar.ql-snow {\n  border: 1px solid #ccc;\n  box-sizing: border-box;\n  font-family: 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif;\n  padding: 8px;\n}\n.ql-toolbar.ql-snow .ql-formats {\n  margin-right: 15px;\n}\n.ql-toolbar.ql-snow .ql-picker-label {\n  border: 1px solid transparent;\n}\n.ql-toolbar.ql-snow .ql-picker-options {\n  border: 1px solid transparent;\n  box-shadow: rgba(0,0,0,0.2) 0 2px 8px;\n}\n.ql-toolbar.ql-snow .ql-picker.ql-expanded .ql-picker-label {\n  border-color: #ccc;\n}\n.ql-toolbar.ql-snow .ql-picker.ql-expanded .ql-picker-options {\n  border-color: #ccc;\n}\n.ql-toolbar.ql-snow .ql-color-picker .ql-picker-item.ql-selected,\n.ql-toolbar.ql-snow .ql-color-picker .ql-picker-item:hover {\n  border-color: #000;\n}\n.ql-toolbar.ql-snow + .ql-container.ql-snow {\n  border-top: 0px;\n}\n.ql-snow .ql-tooltip {\n  background-color: #fff;\n  border: 1px solid #ccc;\n  box-shadow: 0px 0px 5px #ddd;\n  color: #444;\n  padding: 5px 12px;\n  white-space: nowrap;\n}\n.ql-snow .ql-tooltip::before {\n  content: \"Visit URL:\";\n  line-height: 26px;\n  margin-right: 8px;\n}\n.ql-snow .ql-tooltip input[type=text] {\n  display: none;\n  border: 1px solid #ccc;\n  font-size: 13px;\n  height: 26px;\n  margin: 0px;\n  padding: 3px 5px;\n  width: 170px;\n}\n.ql-snow .ql-tooltip a.ql-preview {\n  display: inline-block;\n  max-width: 200px;\n  overflow-x: hidden;\n  text-overflow: ellipsis;\n  vertical-align: top;\n}\n.ql-snow .ql-tooltip a.ql-action::after {\n  border-right: 1px solid #ccc;\n  content: 'Edit';\n  margin-left: 16px;\n  padding-right: 8px;\n}\n.ql-snow .ql-tooltip a.ql-remove::before {\n  content: 'Remove';\n  margin-left: 8px;\n}\n.ql-snow .ql-tooltip a {\n  line-height: 26px;\n}\n.ql-snow .ql-tooltip.ql-editing a.ql-preview,\n.ql-snow .ql-tooltip.ql-editing a.ql-remove {\n  display: none;\n}\n.ql-snow .ql-tooltip.ql-editing input[type=text] {\n  display: inline-block;\n}\n.ql-snow .ql-tooltip.ql-editing a.ql-action::after {\n  border-right: 0px;\n  content: 'Save';\n  padding-right: 0px;\n}\n.ql-snow .ql-tooltip[data-mode=link]::before {\n  content: \"Enter link:\";\n}\n.ql-snow .ql-tooltip[data-mode=formula]::before {\n  content: \"Enter formula:\";\n}\n.ql-snow .ql-tooltip[data-mode=video]::before {\n  content: \"Enter video:\";\n}\n.ql-snow a {\n  color: #06c;\n}\n.ql-container.ql-snow {\n  border: 1px solid #ccc;\n}\n.ql-mention-list-container {\r\n  width: 270px;\r\n  border: 1px solid #f0f0f0;\r\n  border-radius: 4px;\r\n  background-color: #ffffff;\r\n  box-shadow: 0 2px 12px 0 rgba(30, 30, 30, 0.08);\r\n  z-index: 9001;\r\n  overflow: auto;\r\n}\r\n\r\n.ql-mention-loading {\r\n  line-height: 44px;\r\n  padding: 0 20px;\r\n  vertical-align: middle;\r\n  font-size: 16px;\r\n}\r\n\r\n.ql-mention-list {\r\n  list-style: none;\r\n  margin: 0;\r\n  padding: 0;\r\n  overflow: hidden;\r\n}\r\n\r\n.ql-mention-list-item {\r\n  cursor: pointer;\r\n  line-height: 44px;\r\n  font-size: 16px;\r\n  padding: 0 20px;\r\n  vertical-align: middle;\r\n}\r\n\r\n.ql-mention-list-item.disabled {\r\n  cursor: auto;\r\n}\r\n\r\n.ql-mention-list-item.selected {\r\n  background-color: #d3e1eb;\r\n  text-decoration: none;\r\n}\r\n\r\n.mention {\r\n  height: 24px;\r\n  width: 65px;\r\n  border-radius: 6px;\r\n  background-color: #d3e1eb;\r\n  padding: 3px 0;\r\n  margin-right: 2px;\r\n  user-select: all;\r\n}\r\n\r\n.mention > span {\r\n  margin: 0 3px;\r\n}\r\n._questionItem_1sx0f_1 {\n  margin-bottom: 15px;\n  width: 50%;\n}\n\n._questionItem_1sx0f_1:last-child {\n  margin-bottom: 0;\n}\n\n@media only screen and (max-width: 767px) {\n  ._questionItem_1sx0f_1 {\n    width: 100%;\n  }\n}\n._questionItem_1sx0f_1 {\n  margin-bottom: 15px;\n  width: 50%;\n}\n\n._questionItem_1sx0f_1:last-child {\n  margin-bottom: 0;\n}\n\n@media only screen and (max-width: 767px) {\n  ._questionItem_1sx0f_1 {\n    width: 100%;\n  }\n}\n._questionItem_wb37f_1 {\n  margin-bottom: 15px;\n  width: 50%;\n}\n\n._questionItem_wb37f_1:last-child {\n  margin-bottom: 0;\n}\n\n@media screen and (max-width: 768px) {\n  ._questionItem_wb37f_1 {\n    width: 100%;\n  }\n}\n._answerAdd_1mqlf_1 {\n  display: flex;\n  align-items: baseline;\n  padding-left: 18px;\n}\n\n._answerIcon_1mqlf_7 {\n  align-self: center;\n}\n._answerItem_1h53l_1 {\n  display: flex;\n  flex-flow: row wrap;\n  align-items: baseline;\n  margin-bottom: 15px;\n}\n\n._answerItem_1h53l_1 ._answerIcon_1h53l_8 {\n  align-self: center;\n}\n\n._answerItem_1h53l_1 ._answerIcon_1h53l_8:hover {\n  cursor: pointer;\n}\n\n._answerItem_1h53l_1 ._answerIconOther_1h53l_16 {\n  align-self: center;\n  margin-right: 10px;\n}\n\n._answerItem_1h53l_1 ._answerIconOther_1h53l_16:hover {\n  cursor: pointer;\n}\n\n._answerItem_1h53l_1 ._answerNumberOrder_1h53l_25 {\n  width: 30px;\n  text-align: center;\n}\n\n._answerItem_1h53l_1 ._answerControl_1h53l_30 {\n  margin-left: 7px;\n  width: calc(100% - 88px);\n}\n\n._answerItem_1h53l_1 ._answerControlRtl_1h53l_35 {\n  margin-right: 7px;\n  width: calc(100% - 88px);\n}\n\n._answerItem_1h53l_1 ._answerControlOther_1h53l_40 {\n  margin-left: 7px;\n  width: calc(100% - 140px);\n}\n\n._answerItem_1h53l_1 ._answerControlOtherRtl_1h53l_45 {\n  margin-right: 7px;\n  width: calc(100% - 140px);\n}\n\n._answerItem_1h53l_1 ._answerOtherControl_1h53l_50 {\n  margin-left: 43px;\n  width: 50%;\n}\n._scqList_13vte_1 {\n  display: flex;\n  flex-flow: row wrap;\n  justify-content: space-between;\n\n  ._scqItem_13vte_6 {\n    flex-basis: 49%;\n\n    > h5 {\n      margin: 10px 0;\n    }\n  }\n}\n\n._answerAdd_13vte_15 {\n  display: flex;\n  align-items: baseline;\n  padding-left: 18px;\n\n  ._answerIcon_13vte_20 {\n    align-self: center;\n  }\n\n  ._answerNumberOrder_13vte_24 {\n    width: 18px;\n    text-align: center;\n  }\n}\n._errorDisplay_1joy4_1 {\n  margin-bottom: 15px;\n  border: 1px solid orange;\n  background-color: rgba(255, 166, 0, 0.13);\n  border-radius: 4px;\n  margin: 8px;\n  padding: 8px;\n}\n\n._clickable_1joy4_10 {\n  cursor: pointer;\n}\n._actionControl_1xa5v_1 {\n  display: flex;\n  margin-right: 8px;\n  margin-left: 8px;\n  justify-content: flex-end;\n}\n\n._statusIcon_1xa5v_8 {\n  cursor: default;\n}\n\n._questionContainer_1xa5v_12 {\n  padding: 16px;\n}\n\n._actionIcon_1xa5v_16,\n._settingIcon_1xa5v_17 {\n  font-size: 22px;\n}\n\n._settingIcon_1xa5v_17 {\n  transform: rotate(90deg);\n}\n\n._deleteIcon_1xa5v_25 {\n  font-size: 32px;\n}\n._addAnswerIcon_1fnbz_1 {\n  scale: 4;\n}\n\n._addAnswerButton_1fnbz_5 {\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  text-align: center;\n  vertical-align: middle;\n}\n._imageIconButton_12ufg_1 {\n  float: right;\n  border-radius: 0 !important;\n  padding: 4px !important;\n  margin: 4px !important;\n  background-color: #ffffff7f !important;\n}\n\n._imageContainer_12ufg_9 {\n  background-size: contain;\n  background-position: center;\n  background-repeat: no-repeat;\n}\n\n._addAnswerIcon_12ufg_15 {\n  scale: 4;\n}\n\n._addAnswerButton_12ufg_19 {\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  text-align: center;\n  vertical-align: middle;\n}\n._placeholder_4iqf5_1 {\n  width: 100%;\n  height: 100%;\n  display: inline-block;\n  vertical-align: middle;\n  text-align: center;\n}\n\n._buttonContainer_4iqf5_9 {\n  text-align: center;\n  margin-top: 24px;\n}\n._signatureCanvas_1uxb1_1 {\n  border: 1px solid transparent;\n  padding: 8px;\n  border-radius: 4px;\n  text-align: center;\n}\n._placeholder_xjf3c_1 {\n  width: 100%;\n  height: 100%;\n  display: inline-block;\n  vertical-align: middle;\n  text-align: center;\n}\n\n._buttonContainer_xjf3c_9 {\n  text-align: center;\n  margin-top: 24px;\n}\n\n._imageContainer_xjf3c_14 {\n  background-position: center;\n  background-repeat: no-repeat;\n}\n._choicesContainer_k0bnu_1 {\n  display: flex;\n  width: 100%;\n  table-layout: fixed;\n  margin-bottom: 16px;\n  justify-content: space-between;\n}\n\n._choicesContainer_k0bnu_1 ._choice_k0bnu_1 {\n  padding: 8px;\n  width: 100%;\n  margin: 1px;\n  font-weight: bold;\n  font-size: larger;\n  border: 1px solid;\n  text-align: center;\n}\n\n._choiceLabels_k0bnu_19 {\n  margin-top: 16px;\n  display: flex;\n  justify-content: space-between;\n}\n._container_cyg3h_1 {\n  text-align: center;\n}._container_cyg3h_1 {\n  text-align: center;\n}._textHeader_iiwtl_1 {\n  display: flex;\n  align-items: center;\n}\n\n._textDescription_iiwtl_6 {\n  display: flex;\n  align-items: center;\n  margin-top: 6px;\n}\n\n._titleRow_iiwtl_12 {\n  display: block;\n  justify-content: space-between;\n  align-items: center;\n  box-align: center;\n  margin-right: 24px;\n  margin-left: 24px;\n  flex-wrap: wrap;\n  box-pack: justify;\n}\n\n._groupCard_iiwtl_23 {\n  margin-top: 48px;\n  position: relative;\n  box-shadow: inherit !important;\n  border-top-right-radius: 8px;\n  border-top-left-radius: 8px;\n  padding-bottom: 24px;\n  cursor: default;\n}\n\n._groupEmptyHint_iiwtl_33 {\n  text-align: center;\n  font-size: 32px;\n  padding: 16px;\n  color: gray;\n  margin: 16px;\n  border: 2px dashed gray;\n  border-radius: 4px;\n}\n\n._type_iiwtl_43 {\n  display: flex;\n  align-items: center;\n  justify-content: flex-start;\n  color: rgba(0, 0, 0, 0.33);\n}\n\n._questionsOuterContainer_iiwtl_50 {\n  padding: 24px;\n}\n\n._questionsInnerContainer_iiwtl_54 {\n  border-radius: 8px;\n  padding: 24px;\n}\n\n._groupDesignError_iiwtl_59 {\n  border-color: red !important;\n  background-color: #ff000010 !important;\n}\n\n._groupHeader_iiwtl_64 {\n  border: 1px solid transparent;\n  border-top-right-radius: 8px;\n  border-top-left-radius: 8px;\n}\n\n._inputGroupTitle_iiwtl_70 {\n  width: 100%;\n  line-height: 135%;\n}\n\n._inputGroupDescription_iiwtl_75 {\n  width: 100%;\n  margin-top: 4px;\n}\n\n._moveBox_iiwtl_80 {\n  position: absolute;\n  top: 5px;\n  left: 50%;\n  transform: translateX(-50%);\n  display: flex;\n  margin-top: 8px;\n  justify-content: center;\n  width: 50%;\n  cursor: move;\n}\n._surveyGroups_10g3b_1 {\n  max-width: 750px;\n  margin: auto;\n}\n\n\n\n._groupEmptyHint_10g3b_8 {\n  text-align: center;\n  font-size: 32px;\n  padding: 16px;\n  color: gray;\n  margin: 16px;\n  border: 2px dashed gray;\n  border-radius: 4px;\n}\n\n._footer_10g3b_18 {\n  height: 100px;\n}\n\n._contentPanel_10g3b_22{\n  padding-top: 32px;\n  padding-right: 8px;\n  padding-left: 8px;\n  overflow-y: auto;\n  height: 100vh;\n}\n\n._headerImage_10g3b_30 {\n  max-height: 22.5vw;\n  max-width: 90vw;\n  height: 160px;\n  width: 640px;\n  margin: 12px auto;\n  background-size: cover;\n  background-position: center;\n  border: 1px solid black;\n  border-radius: 8px;\n}._leftContent_1b40q_1 {\n  padding: 15px;\n  width: 390px;\n  overflow-y: auto;\n  height: 100vh;\n  padding-top: 16px;\n}\n\n._leftPanelGroupItem_1b40q_9 {\n  text-align: center;\n}\n\n._close_1b40q_13 {\n  padding: 8px;\n  text-align: right;\n}\n._showHint_9iocv_1 {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  margin-top: 20px;\n  width: 100%;\n}\n\n._inputValue_9iocv_9 {\n  max-width: 80%;\n}\n._boxContainer_182us_1 {\n  border: 1px solid;\n  padding: 15px;\n}\n\n._boxContainer_182us_1 h4 {\n  margin: 0;\n}\n\n._boxContainer_182us_1 ._mt10_182us_10 {\n  margin-top: 10px;\n}\n\n._boxContainer_182us_1 ._uppercase_182us_14 {\n  text-transform: uppercase;\n}\n\n._title_182us_18 {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  width: 100%;\n}\n\n._title_182us_18 p {\n  margin: 0;\n  margin-right: 30px;\n}\n._boxContainer_1vhs4_1 {\n  border: 1px solid;\n  padding: 15px;\n\n  h4 {\n    margin: 0;\n  }\n\n  ._mt10_1vhs4_9 {\n    margin-top: 10px;\n  }\n\n  ._uppercase_1vhs4_13 {\n    text-transform: uppercase;\n  }\n}\n\n._title_1vhs4_18 {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  p {\n    margin: 0;\n    margin-right: 30px;\n  }\n}\n\n._titleContent_1vhs4_28 {\n  display: flex;\n  align-items: center;\n}\n\n._standardError_1vhs4_33 {\n  display: flex;\n  align-items: center;\n  margin-bottom: 10px;\n\n  p {\n    margin: 0;\n    margin-right: 30px;\n  }\n}\n\n._errorWrapper_1vhs4_44 {\n  display: flex;\n}\n\n._errorLabelWrapper_1vhs4_48 {\n  margin-right: 10px;\n}\n\n._errorItem_1vhs4_52 {\n  display: flex;\n  align-items: center;\n  margin-bottom: 5px;\n  min-height: 30px;\n}\n._errorItemContainer_1vhs4_58 {\n  width: 100%;\n}\n._valueValidationItems_1hupk_1 {\n  display: flex;\n  align-items: center;\n}\n\n._valueValidationItemsContainer_1hupk_6 {\n  display: flex;\n  align-items: center;\n}\n\n._valueValidationItemsContainer_1hupk_6 ._error_1hupk_11 {\n  color: red;\n}\n._toggleValue_1d9zg_1 {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  width: 100%;\n}\n\n._inputValue_1d9zg_8 {\n  max-width: 80%;\n}\n._selectValue_9m4tq_1 {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  width: 100%;\n}\n._selectDate_1qp3e_1 {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  width: 100%;\n}\n\n._selectDateField_1qp3e_8 {\n  max-width: 50%;\n}\n._theming_5qk2m_1 {\n  padding-right: 5px;\n}\n\n._theming_5qk2m_1 hr {\n  margin: 25px 0 0;\n}\n._color_1xjz4_1 {\n  width: 36px;\n  height: 14px;\n  border-radius: 2px;\n}\n._swatch_1xjz4_6 {\n  padding: 5px;\n  border-radius: 4px;\n  border: 1px solid gray;\n  display: inline-block;\n  cursor: pointer;\n}\n._popover_1xjz4_13 {\n  position: absolute;\n  z-index: 2;\n}\n._cover_1xjz4_17 {\n  position: fixed;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n}\n._themingItem_1o98o_1 h6 {\n  margin-top: 15px;\n  margin-bottom: 10px;\n}\n\n._themingItem_1o98o_1 ._themingItemBody_1o98o_6 {\n  display: flex;\n}\n\n._themingItem_1o98o_1 ._themingItemBody_1o98o_6 div:nth-child(1) {\n  flex-grow: 1;\n}\n/******************************************************************************/\n/** MAIN ********************************************************************/\n/******************************************************************************/\n.qb-drag-handler, .qb-draggable, .query-builder {\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.rule--header:after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n\n.query-builder {\n  overflow: hidden;\n  font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n  font-size: 14px;\n  line-height: 1.25;\n  margin: 1rem;\n}\n\n.group {\n  background: rgba(250, 240, 210, 0.5);\n  border: 1px solid #DCC896;\n}\n\n.rule {\n  background-color: white;\n  border: 1px solid transparent;\n  padding: 10px;\n}\n\n.rule-with-error .rule {\n  border: 1px solid #e0a1a1;\n}\n\n.rule--body {\n  display: flex;\n  flex-wrap: wrap;\n  text-align: center;\n}\n\n.rule--body--wrapper {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n}\n\n.rule--error {\n  color: red;\n  margin-bottom: -5px;\n  margin-top: 5px;\n}\n\n.group-or-rule {\n  border-radius: 5px;\n  position: relative;\n}\n\n.rule_group {\n  background: rgba(255, 252, 242, 0.5);\n  border: 1px solid #f9f1dd;\n}\n\n.locked {\n  border: 1px dashed red;\n}\n\n.qb-placeholder {\n  border: 1px dashed gray;\n}\n\n/******************************************************************************/\n/** DRAG *********************************************************************/\n/******************************************************************************/\n.query-builder.qb-dragging {\n  cursor: -webkit-grabbing !important;\n  cursor: grabbing !important;\n}\n.query-builder.qb-dragging button {\n  pointer-events: none;\n}\n\n.qb-draggable {\n  pointer-events: none;\n  position: absolute;\n  opacity: 0.7;\n  z-index: 1000;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n}\n\n.qb-drag-handler {\n  cursor: -webkit-grabbing;\n  cursor: grabbing;\n}\n\n/******************************************************************************/\n/** TREE LINES *********************************************************************/\n/******************************************************************************/\n.group--header:not(.no--children):not(.hide--conjs) {\n  position: relative;\n}\n.group--header:not(.no--children):not(.hide--conjs)::before {\n  z-index: 0;\n  content: \"\";\n  position: absolute;\n  border-width: 0 0 0 2px;\n  border-color: #ccc;\n  border-style: solid;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n}\n.group--header:not(.no--children):not(.hide--conjs).hide--line::before {\n  border-color: rgba(128, 128, 128, 0.1);\n}\n.group--header:not(.no--children):not(.hide--conjs)::before {\n  top: 20px;\n  height: calc(100% + 10px - 20px);\n  left: 11px;\n  width: 13px;\n}\n\n.group--children > .group-or-rule-container > .group-or-rule::before {\n  border-width: 0 0 2px 2px;\n}\n.group--children > .group-or-rule-container > .group-or-rule::after {\n  border-width: 0 0 0 2px;\n}\n.group--children > .group-or-rule-container > .group-or-rule::before, .group--children > .group-or-rule-container > .group-or-rule::after {\n  content: \"\";\n  position: absolute;\n  border-color: #ccc;\n  border-style: solid;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n}\n.group--children > .group-or-rule-container > .group-or-rule::before {\n  top: -1px;\n  height: calc(50% + 1px + 1px);\n}\n.group--children > .group-or-rule-container > .group-or-rule::after {\n  top: calc(50% + 1px);\n  height: calc(50% - 1px + 10px + 2px);\n}\n.group--children > .group-or-rule-container > .group-or-rule::before, .group--children > .group-or-rule-container > .group-or-rule::after {\n  left: -14px;\n  width: 13px;\n}\n.group--children > .group-or-rule-container:last-child > .group-or-rule::before {\n  border-radius: 0 0 0 4px;\n}\n.group--children > .group-or-rule-container:last-child > .group-or-rule::after {\n  display: none;\n}\n.group--children.hide--conjs > .group-or-rule-container:first-child > .group-or-rule::before {\n  display: none;\n}\n.group--children.hide--conjs > .group-or-rule-container:first-child > .group-or-rule::after {\n  border-radius: 4px 0 0 0;\n  border-width: 2px 0 0 2px;\n}\n.group--children.hide--conjs > .group-or-rule-container:first-child > .group-or-rule::after {\n  top: calc(50% - 1px);\n  height: calc(50% + 1px + 10px + 2px);\n}\n.group--children.hide--line > .group-or-rule-container > .group-or-rule::before, .group--children.hide--line > .group-or-rule-container > .group-or-rule::after {\n  border-color: rgba(128, 128, 128, 0.1);\n}\n\n.rule_group--children > .group-or-rule-container:first-child > .group-or-rule::before {\n  display: none;\n}\n.rule_group--children > .group-or-rule-container:first-child > .group-or-rule::after {\n  border-radius: 4px 0 0 0;\n  border-width: 2px 0 0 2px;\n}\n.rule_group--children > .group-or-rule-container:first-child > .group-or-rule::after {\n  top: calc(50% - 1px);\n  height: calc(50% + 1px + 5px + 2px);\n}\n.rule_group--children > .group-or-rule-container > .group-or-rule::before {\n  top: -1px;\n  height: calc(50% + 1px + 1px);\n}\n.rule_group--children > .group-or-rule-container > .group-or-rule::after {\n  top: calc(50% + 1px);\n  height: calc(50% - 1px + 5px + 2px);\n}\n.rule_group--children > .group-or-rule-container > .group-or-rule::before, .rule_group--children > .group-or-rule-container > .group-or-rule::after {\n  left: -11px;\n  width: 10px;\n}\n\n.switch_group > .group--children > .group-or-rule-container > .group-or-rule::before {\n  top: -2px;\n  height: calc(50% + 1px + 2px);\n}\n.switch_group > .group--children > .group-or-rule-container > .group-or-rule::after {\n  top: calc(50% + 1px);\n  height: calc(50% - 1px + 10px + 4px);\n}\n.switch_group > .group--children > .group-or-rule-container > .group-or-rule::before, .switch_group > .group--children > .group-or-rule-container > .group-or-rule::after {\n  left: -15px;\n  width: 13px;\n}\n.switch_group > .group--header:not(.no--children):not(.hide--conjs)::before {\n  top: 20px;\n  height: calc(100% + 10px - 20px);\n  left: 11px;\n  width: 13px;\n}\n\n.qb-draggable::before, .qb-draggable::after {\n  display: none;\n}\n\n/******************************************************************************/\n/** GROUP *********************************************************************/\n/******************************************************************************/\n.group--header,\n.group--footer {\n  display: flex;\n  align-items: stretch;\n  padding-left: 10px;\n  padding-right: 10px;\n  margin-top: 10px;\n  margin-bottom: 10px;\n}\n\n.group-or-rule-container {\n  margin-top: 10px;\n  margin-bottom: 10px;\n  padding-right: 10px;\n}\n.group-or-rule-container:first-child {\n  margin-top: 0px !important;\n}\n.group-or-rule-container:last-child {\n  margin-bottom: 0px !important;\n}\n\n.group--drag-handler {\n  margin-right: 8px;\n  margin-top: 3px;\n  position: relative;\n  align-self: center;\n}\n\n.group--conjunctions {\n  flex-shrink: 0;\n  display: flex;\n}\n.group--conjunctions .group--drag-handler {\n  margin-left: 10px;\n}\n\n.group--children {\n  padding-left: 24px;\n  margin-top: 10px;\n  margin-bottom: 10px;\n}\n.group--children .group--field--count--rule {\n  display: flex;\n  flex-wrap: wrap;\n  flex: 1;\n}\n\n.group--conjunctions.hide--conj {\n  opacity: 0.3;\n}\n\n.group--actions {\n  margin-left: 10px;\n  flex: 1;\n  display: flex;\n}\n.group--actions--tl, .group--actions--bl {\n  justify-content: flex-start;\n}\n.group--actions--tl {\n  margin-left: 20px;\n}\n.group--actions--tc, .group--actions--bc {\n  justify-content: center;\n}\n.group--actions--tr, .group--actions--br {\n  justify-content: flex-end;\n}\n\n/******************************************************************************/\n/** CASE_GROUP *********************************************************************/\n/******************************************************************************/\n.case_group {\n  border-width: 2px;\n}\n\n.case_group--body {\n  display: flex;\n  flex-direction: row;\n  margin-top: 10px;\n  margin-bottom: 10px;\n}\n.case_group--body .case_group--children {\n  flex: auto;\n  margin-top: 0 !important;\n  margin-bottom: 0 !important;\n}\n.case_group--body .case_group--value {\n  margin-top: 0;\n  margin-bottom: 0;\n  margin-right: 10px;\n}\n\n/******************************************************************************/\n/** RULE_GROUP *********************************************************************/\n/******************************************************************************/\n.rule_group {\n  display: flex;\n  flex-wrap: wrap;\n  padding-left: 10px;\n}\n.rule_group .group--field {\n  margin-top: 10px;\n  margin-bottom: 10px;\n  align-self: center;\n}\n.rule_group .group--actions {\n  margin-left: 10px;\n  align-self: center;\n  flex: 0;\n}\n.rule_group .rule_group--children {\n  flex: 1;\n  margin-top: 5px;\n  margin-bottom: 5px;\n  padding-left: 18px;\n}\n.rule_group .rule_group--children .group-or-rule-container {\n  margin-bottom: 5px;\n  margin-top: 5px;\n  padding-right: 5px;\n}\n.rule_group .rule_group--children.one--child {\n  padding-left: 9px;\n}\n\n/******************************************************************************/\n/** RULE_GROUP_EXT *********************************************************************/\n/******************************************************************************/\n.rule_group_ext .group--actions {\n  flex: none;\n}\n\n.group--header.hide--drag.with--conjs > .group--field--count--rule {\n  margin-left: 20px;\n}\n\n/******************************************************************************/\n/** RULE **********************************************************************/\n/******************************************************************************/\n.rule {\n  flex: 1;\n  display: flex;\n}\n\n.rule--header {\n  margin-left: auto;\n  display: flex;\n  align-items: center;\n  padding-left: 10px;\n}\n\n.rule--drag-handler {\n  display: flex;\n  align-items: center;\n  margin-right: 8px;\n}\n\n.rule--field, .group--field, .rule--operator, .rule--value, .rule--operator-options, .rule--widget, .widget--widget, .widget--valuesrc, .widget--sep, .operator--options--sep, .rule--before-widget, .rule--after-widget {\n  display: inline-block;\n}\n\n.widget--sep, .operator--options--sep, .rule--func--bracket-before, .rule--func--bracket-after, .rule--func--arg-sep {\n  vertical-align: bottom;\n  align-self: flex-end;\n  margin-bottom: 8px;\n}\n\n.operator--options {\n  display: flex;\n}\n\n.rule--value {\n  display: flex;\n}\n\n.rule--widget {\n  display: flex;\n  flex-wrap: wrap;\n}\n\n.rule--operator, .widget--widget, .widget--valuesrc, .widget--sep {\n  margin-left: 10px;\n}\n\n.widget--valuesrc {\n  vertical-align: top;\n  margin-right: -8px;\n}\n\n.operator--options--sep {\n  margin-right: 10px;\n}\n\n.rule--operator-wrapper {\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n}\n\n.rule--operator-text-wrapper {\n  flex: 1;\n  display: flex;\n  align-items: center;\n}\n\ndiv.tooltip-inner {\n  max-width: 500px;\n}\n\n.rule--field label, .group--field label, .rule--operator label, .widget--widget label {\n  display: block;\n  font-weight: bold;\n}\n\n/******************************************************************************/\n/** FUNC **********************************************************************/\n/******************************************************************************/\n.rule--func--wrapper, .rule--func, .rule--func--args, .rule--func--arg, .rule--func--arg-value, .rule--func--bracket-before, .rule--func--bracket-after, .rule--func--arg-sep, .rule--func--arg-label, .rule--func--arg-label-sep {\n  display: inline-block;\n}\n\n.rule--func--wrapper {\n  display: flex;\n  flex-wrap: wrap;\n}\n\n.rule--func--args {\n  display: flex;\n  flex-wrap: wrap;\n}\n\n.rule--func--arg {\n  display: flex;\n}\n\n.rule--func--bracket-before, .rule--func--bracket-after {\n  margin-left: 3px;\n  margin-right: 3px;\n}\n\n.rule--func--bracket-before {\n  margin-left: 5px;\n}\n\n.rule--func--arg-value > .rule--widget {\n  margin-left: -10px;\n}\n\n.rule--func--arg-sep {\n  margin-left: 3px;\n  margin-right: 6px;\n}\n\n.rule--func--arg-label-sep {\n  margin-left: 1px;\n  margin-right: 6px;\n}\n\n/******************************************************************************/\n/** Minimalism ****************************************************************/\n/******************************************************************************/\n.qb-lite .group--drag-handler, .qb-lite .group--actions {\n  transition: opacity 0.2s;\n}\n.qb-lite .group--header:hover .group--header .group--drag-handler, .qb-lite .group--header:hover .group--header .group--actions,\n.qb-lite .group--header:not(:hover) .group--drag-handler,\n.qb-lite .group--header:not(:hover) .group--actions,\n.qb-lite .rule_group:not(:hover) .group--drag-handler,\n.qb-lite .rule_group:not(:hover) .group--actions {\n  opacity: 0;\n}\n.qb-lite .widget--valuesrc, .qb-lite .rule--drag-handler, .qb-lite .rule--header {\n  transition: opacity 0.2s;\n}\n.qb-lite .rule:hover .rule .widget--valuesrc, .qb-lite .rule:hover .rule .rule--drag-handler, .qb-lite .rule:hover .rule .rule--header,\n.qb-lite .rule:not(:hover) .widget--valuesrc,\n.qb-lite .rule:not(:hover) .rule--drag-handler,\n.qb-lite .rule:not(:hover) .rule--header {\n  opacity: 0;\n}\n.qb-lite.qb-dragging .widget--valuesrc, .qb-lite.qb-dragging .rule--drag-handler, .qb-lite.qb-dragging .rule--header, .qb-lite.qb-dragging .group--drag-handler, .qb-lite.qb-dragging .group--actions {\n  opacity: 0 !important;\n}\n\n/******************************************************************************/\n/** Shrink textarea ***********************************************************/\n/******************************************************************************/\n.rule--body.can--shrink--value {\n  align-items: center;\n}\n.rule--body.can--shrink--value .rule--value {\n  flex: 1;\n}\n.rule--body.can--shrink--value .rule--value > .rule--widget {\n  flex: 1;\n}\n.rule--body.can--shrink--value .rule--value > .rule--widget > .widget--valuesrc {\n  display: flex;\n  align-items: center;\n}\n.rule--body.can--shrink--value .rule--value > .rule--widget .widget--widget {\n  flex: 1;\n}\n\n.MuiIconButton-sizeSmall {\n  padding: 3px;\n}\n.group--children.hide--line > .group-or-rule-container > .group-or-rule::before,\n.group--children.hide--line > .group-or-rule-container > .group-or-rule::after {\n  border-color: transparent;\n}\n\n.MuiAutocomplete-fullWidth {\n  width: 320px !important;\n}\n\n.query-builder-container {\n  padding: 0 !important;\n}\n\n.query-builder {\n  margin: 0 !important;\n}\n\n.logicField {\n  color: blue;\n}\n\n.logicOp {\n  font-weight: bold;\n}\n\n.logicValue {\n  color: green;\n}\n\n.condition-human-text {\n  width: 100%;\n  white-space: pre-wrap;\n}\n\n.query-builder-result {\n  margin-top: 9px;\n  display: flex;\n  background-color: #ddd;\n}\n._relevance_1j5a5_1 {\n  display: inline-block;\n}\n\n._relevanceError_1j5a5_5 {\n  background-color: #ff000022;\n}\n\n._errorContainer_1j5a5_9 {\n  display: flex;\n}\n._skipItem_1n8m2_1 {\n  margin-top: 24px;\n  margin-bottom: 24px;\n}\n\n._toEnd_1n8m2_6 {\n  display: flex;\n  justify-content: space-between;\n  width: 100%;\n  align-items: center;\n  padding: 4dp;\n}\n._sectionTitle_1aw08_1 {\n  font-size: 18px;\n  font-weight: bold;\n}\n._errorDisplay_1avr2_1 {\n  margin-bottom: 15px;\n  border: 1px solid orange;\n  background-color: rgba(255, 166, 0, 0.13);\n  border-radius: 4px;\n  margin: 8px;\n  padding: 8px;\n}\n._errorDisplay_1avr2_1 {\n  margin-bottom: 15px;\n  border: 1px solid orange;\n  background-color: rgba(255, 166, 0, 0.13);\n  border-radius: 4px;\n  margin: 8px;\n  padding: 8px;\n}\n._randomHeader_1pjix_1 {\n  display: flex;\n  justify-content: space-between;\n}\n\n._randomHeader_1pjix_1 ._title_1pjix_6 {\n  margin: 0;\n  line-height: 40px;\n}\n\n._randomHeader_1pjix_1 ._action_1pjix_11 {\n  float: right;\n}\n\n._randomHeader_1pjix_1 ._settingIcon_1pjix_15 {\n  font-size: 20px;\n}\n\n._randomBody_1pjix_19 ._list_1pjix_19 {\n  padding-left: 7px;\n  margin-top: 4px;\n  list-style-type: \"-\";\n}\n\n._randomBody_1pjix_19 ._list_1pjix_19 li {\n  line-height: 24px;\n  margin-bottom: 6px;\n}\n\n._randomBody_1pjix_19 ._list_1pjix_19 li ._weight_1pjix_30 {\n  float: right;\n  padding-top: 2px;\n  min-width: 100px;\n  text-align: right;\n}\n\n._randomBody_1pjix_19 ._list_1pjix_19 li ._weight_1pjix_30 > span {\n  display: inline-block;\n  padding: 0 4px;\n  line-height: 22px;\n  background-color: white;\n  border: 1px solid black;\n  min-width: 20px;\n  text-align: center;\n}\n\n._randomAction_1pjix_47 {\n  margin-top: 15px;\n  text-align: right;\n  padding-right: 4px;\n}\n\n._listItem_1pjix_53 {\n  display: flex;\n  align-items: center;\n}\n\n._listItem_1pjix_53 ._label_1pjix_58 {\n  display: flex;\n  align-items: center;\n  width: 100%;\n}\n\n._listItem_1pjix_53 ._input_1pjix_64 {\n  width: 50px;\n}\n\n._listItemError_1pjix_68 {\n  color: red;\n  display: flex;\n  align-items: center;\n}\n\n._listItemError_1pjix_68 ._label_1pjix_58 {\n  display: flex;\n  align-items: center;\n  width: 100%;\n}\n\n._listItemError_1pjix_68 ._input_1pjix_64 {\n  width: 50px;\n}\n\n._randomItem_1pjix_84 {\n  margin-bottom: 10px;\n  padding: 8px;\n}\n\n._highlighted_1pjix_89 {\n  border: 2px solid;\n  border-radius: 4px;\n}\n._title_5cg20_1 {\n  margin: 0;\n  line-height: 40px;\n}\n\n._randomBody_5cg20_6 ._list_5cg20_6 {\n  padding-left: 0;\n  margin: 0 0 10px;\n  list-style-type: \"-\";\n}\n\n._randomBody_5cg20_6 ._list_5cg20_6 li {\n  padding-left: 0;\n  line-height: 24px;\n  margin-bottom: 6px;\n}\n\n._randomBody_5cg20_6 ._list_5cg20_6 li ._weight_5cg20_18 {\n  float: right;\n  padding-top: 2px;\n  min-width: 100px;\n  text-align: right;\n}\n\n._randomBody_5cg20_6 ._list_5cg20_6 li ._weight_5cg20_18 > span {\n  display: inline-block;\n  padding: 0 4px;\n  line-height: 22px;\n  background-color: white;\n  border: 1px solid black;\n  min-width: 20px;\n  text-align: center;\n}\n\n._label_5cg20_35 {\n  width: 100%;\n}\n\n._randomAction_5cg20_39 {\n  margin-top: 15px;\n  text-align: right;\n  padding-right: 4px;\n}\n\n._listItem_5cg20_45 {\n  display: flex;\n  align-items: center;\n}\n\n._listItem_5cg20_45 ._input_5cg20_50 {\n  width: 50px;\n}\n\n._randomItem_5cg20_54 {\n  margin-top: 10px;\n  margin-bottom: 10px;\n  padding: 8px;\n}\n._selectValue_14l81_1 {\n  margin-bottom: 20px !important;\n}\n._errorDisplay_1vtlj_1 {\n  margin-bottom: 15px;\n  border: 1px solid orange;\n  background-color: rgba(255, 166, 0, 0.13);\n  border-radius: 4px;\n  margin: 8px;\n  padding: 8px;\n}\n\n._addNew_1vtlj_10 {\n  margin-top: 8px;\n}\n._title_1p7e9_1 {\n  margin: 0;\n  line-height: 40px;\n}\n\n._list_1p7e9_6 {\n  padding-left: 7px;\n  margin: 0 0 10px;\n  list-style-type: none;\n}\n\n._list_1p7e9_6 li {\n  line-height: 24px;\n  margin-bottom: 6px;\n  padding-left: 0;\n  margin-left: -12px;\n}\n\n._randomAction_1p7e9_19 {\n  margin-top: 15px;\n  text-align: right;\n  padding-right: 4px;\n}\n\n._listItem_1p7e9_25 {\n  display: flex;\n  align-items: center;\n}\n\n._listItem_1p7e9_25 ._input_1p7e9_30 {\n  width: 50px;\n}\n\n._randomItem_1p7e9_34 {\n  margin-top: 10px;\n  margin-bottom: 10px;\n  padding: 8px;\n}\n._randomHeader_10d2m_1 {\n  display: flex;\n  justify-content: space-between;\n}\n\n._randomHeader_10d2m_1 ._title_10d2m_6 {\n  margin: 0;\n  line-height: 40px;\n}\n\n._randomHeader_10d2m_1 ._action_10d2m_11 {\n  float: right;\n}\n\n._randomHeader_10d2m_1 ._settingIcon_10d2m_15 {\n  font-size: 20px;\n}\n\n._list_10d2m_19 {\n  padding-left: 7px;\n  margin: 0 0 10px;\n  list-style-type: \"-\";\n}\n\n._list_10d2m_19 li {\n  line-height: 24px;\n  margin-bottom: 6px;\n}\n\n._randomAction_10d2m_30 {\n  margin-top: 15px;\n  text-align: right;\n  padding-right: 4px;\n}\n\n._listItem_10d2m_36 {\n  display: flex;\n  align-items: center;\n}\n\n._listItem_10d2m_36 ._label_10d2m_41 {\n  display: flex;\n  align-items: center;\n  width: 100%;\n}\n\n._listItem_10d2m_36 ._input_10d2m_47 {\n  width: 50px;\n}\n\n._listItemError_10d2m_51 {\n  color: red;\n  display: flex;\n  align-items: center;\n}\n\n._listItemError_10d2m_51 ._label_10d2m_41 {\n  display: flex;\n  align-items: center;\n  width: 100%;\n}\n\n._randomItem_10d2m_63 {\n  margin-bottom: 10px;\n  padding: 8px;\n}\n\n._highlighted_10d2m_68 {\n  border: 2px solid;\n  border-radius: 4px;\n}\n._savingProgress_zztu3_1 {\n  margin: 0px 8px !important;\n  width: 16px !important;\n  height: 16px !important;\n}\n";
    document.head.appendChild(__vite_style__);
    var _objectWithoutPropertiesLoose, getDefaultExportFromCjs, reactExports, I18nContext, getDefaults, _defineProperty$4, _typeof$2, getI18n, useControlled, useIsFocusVisible, useForkRef, useEnhancedEffect, useEventCallback, ownerDocument, _extends$h, useId, setRef, generateUtilityClass, generateUtilityClasses, styled, capitalize, useThemeProps, jsxRuntimeExports, clsx, composeClasses, createSvgIcon, alpha, rootShouldForwardProp, lighten, darken, slotShouldForwardProp, requireCreateSvgIcon, interopRequireDefaultExports, useSelector, commonjsGlobal, reactDomExports, isGroup, isQuestion, stripTags, React, designStore, changeContent, PublicDraggable, grey, setup, setupOptions, removeAnswer, ConnectedDroppable, default_1$p, serveyRandomSetup, default_1$r, DesignService, changeResources, onDrag, default_1$s, useTheme$1, cloneQuestion, deleteQuestion, toggleComponentCollapse, nextId$1, addNewAnswer, deleteGroup, iconByType, collapseAllGroups, buildIndex, isEquivalent, changeAttribute, changeValidationValue, defaultSurveyTheme, _arrayLikeToArray$8, _iterableToArray, _unsupportedIterableToArray$8, _toArray, hoistStatics, _inherits$b, _classCallCheck$b, _assertThisInitialized$1, _createClass$9, _getPrototypeOf$1, _possibleConstructorReturn$b, createStore, CircularProgress, default_1$t, createTheme, changeRelevance, removeSkipDestination, editSkipDestination, editSkipToEnd, instructionByCode, updatePriorityByType, updatePriority, updateRandomByType, updateRandom, setupToggleExpand, useNavigate, changeLang, resetSetup, NewComponentsPanel, newVersionReceived, onErrorSeen, setFetching, GetData, createCache, defualtTheme, CacheProvider, DragDropContext, prefixer, stylisRTLPlugin, designStateReceived, onError, ReactPlayer, CardMedia, PropTypes, DateTimePicker, TimePicker, RadioGroup, Radio, ThemeProvider, ErrorOutlineOutlined, Layout, warnOnce, warn$1, ButtonBase, inputClasses, inputBaseClasses, outlinedInputClasses, filledInputClasses, IconButton, Paper, ClearIcon, ArrowDropDownIcon, ButtonGroupContext, Typography, listItemTextClasses, ListContext, getListItemTextUtilityClass, isHostComponent, useTheme, useSlotProps, Grow, appendOwnerState, TextareaAutosize, Box, rtlLanguage, Button, useTranslation, Dialog, DialogActions, Select, MenuItem, DialogContent, _slicedToArray$1, Popover, Snackbar, Alert, TextField, useDispatch, default_1$q, Collapse, classNames, Accordion, AccordionSummary, default_1$v, AccordionDetails, Popper, DatePicker, Grid, LocalizationProvider, buildResourceUrl, Card, DialogTitle, AuthService, Switch, default_1$u, FormControl, FormLabel, Checkbox, FormControlLabel, default_1$w, LogoutOutlined;
    return {
      setters: [module => {
        _objectWithoutPropertiesLoose = module._;
        getDefaultExportFromCjs = module.A;
        reactExports = module.r;
        I18nContext = module.ax;
        getDefaults = module.ay;
        _defineProperty$4 = module.az;
        _typeof$2 = module.aA;
        getI18n = module.aB;
        useControlled = module.aC;
        useIsFocusVisible = module.au;
        useForkRef = module.X;
        useEnhancedEffect = module.aD;
        useEventCallback = module.aE;
        ownerDocument = module.aF;
        _extends$h = module.m;
        useId = module.w;
        setRef = module.aG;
        generateUtilityClass = module.q;
        generateUtilityClasses = module.n;
        styled = module.t;
        capitalize = module.W;
        useThemeProps = module.v;
        jsxRuntimeExports = module.j;
        clsx = module.x;
        composeClasses = module.y;
        createSvgIcon = module.c;
        alpha = module.at;
        rootShouldForwardProp = module.$;
        lighten = module.av;
        darken = module.aw;
        slotShouldForwardProp = module.aH;
        requireCreateSvgIcon = module.g;
        interopRequireDefaultExports = module.i;
        useSelector = module.b;
        commonjsGlobal = module.z;
        reactDomExports = module.aI;
        isGroup = module.aJ;
        isQuestion = module.aK;
        stripTags = module.a1;
        React = module.R;
        designStore = module.aL;
        changeContent = module.aM;
        PublicDraggable = module.ab;
        grey = module.aN;
        setup = module.aO;
        setupOptions = module.aP;
        removeAnswer = module.aQ;
        ConnectedDroppable = module.aa;
        default_1$p = module.aR;
        serveyRandomSetup = module.aS;
        default_1$r = module.aT;
        DesignService = module.aU;
        changeResources = module.aV;
        onDrag = module.aW;
        default_1$s = module.aX;
        useTheme$1 = module.a0;
        cloneQuestion = module.aY;
        deleteQuestion = module.aZ;
        toggleComponentCollapse = module.a_;
        nextId$1 = module.a$;
        addNewAnswer = module.b0;
        deleteGroup = module.b1;
        iconByType = module.b2;
        collapseAllGroups = module.b3;
        buildIndex = module.b4;
        isEquivalent = module.b5;
        changeAttribute = module.b6;
        changeValidationValue = module.b7;
        defaultSurveyTheme = module.b8;
        _arrayLikeToArray$8 = module.b9;
        _iterableToArray = module.ba;
        _unsupportedIterableToArray$8 = module.bb;
        _toArray = module.bc;
        hoistStatics = module.bd;
        _inherits$b = module.be;
        _classCallCheck$b = module.bf;
        _assertThisInitialized$1 = module.bg;
        _createClass$9 = module.bh;
        _getPrototypeOf$1 = module.bi;
        _possibleConstructorReturn$b = module.bj;
        createStore = module.bk;
        CircularProgress = module.C;
        default_1$t = module.bl;
        createTheme = module.al;
        changeRelevance = module.bm;
        removeSkipDestination = module.bn;
        editSkipDestination = module.bo;
        editSkipToEnd = module.bp;
        instructionByCode = module.bq;
        updatePriorityByType = module.br;
        updatePriority = module.bs;
        updateRandomByType = module.bt;
        updateRandom = module.bu;
        setupToggleExpand = module.bv;
        useNavigate = module.u;
        changeLang = module.bw;
        resetSetup = module.bx;
        NewComponentsPanel = module.by;
        newVersionReceived = module.bz;
        onErrorSeen = module.bA;
        setFetching = module.aj;
        GetData = module.bB;
        createCache = module.an;
        defualtTheme = module.am;
        CacheProvider = module.aq;
        DragDropContext = module.a9;
        prefixer = module.ao;
        stylisRTLPlugin = module.ap;
        designStateReceived = module.bC;
        onError = module.bD;
      }, module => {
        ReactPlayer = module.b;
        CardMedia = module.C;
        PropTypes = module.P;
        DateTimePicker = module.D;
        TimePicker = module.T;
        RadioGroup = module.R;
        Radio = module.a;
        ThemeProvider = module.c;
        ErrorOutlineOutlined = module.E;
        Layout = module.L;
      }, module => {
        warnOnce = module.w;
        warn$1 = module.q;
        ButtonBase = module.t;
        inputClasses = module.v;
        inputBaseClasses = module.x;
        outlinedInputClasses = module.y;
        filledInputClasses = module.z;
        IconButton = module.a;
        Paper = module.P;
        ClearIcon = module.C;
        ArrowDropDownIcon = module.E;
        ButtonGroupContext = module.F;
        Typography = module.T;
        listItemTextClasses = module.G;
        ListContext = module.L;
        getListItemTextUtilityClass = module.H;
        isHostComponent = module.i;
        useTheme = module.f;
        useSlotProps = module.J;
        Grow = module.K;
        appendOwnerState = module.N;
        TextareaAutosize = module.p;
        Box = module.B;
        rtlLanguage = module.r;
        Button = module.b;
        useTranslation = module.u;
        Dialog = module.D;
        DialogActions = module.k;
        Select = module.c;
        MenuItem = module.d;
        DialogContent = module.j;
        _slicedToArray$1 = module._;
        Popover = module.O;
        Snackbar = module.S;
        Alert = module.A;
      }, module => {
        TextField = module.T;
      }, module => {
        useDispatch = module.u;
      }, module => {
        default_1$q = module.d;
        Collapse = module.C;
        classNames = module.c;
        Accordion = module.A;
        AccordionSummary = module.a;
        default_1$v = module.b;
        AccordionDetails = module.e;
      }, module => {
        Popper = module.P;
        DatePicker = module.D;
        Grid = module.G;
        LocalizationProvider = module.L;
      }, module => {
        buildResourceUrl = module.b;
      }, module => {
        Card = module.C;
      }, module => {
        DialogTitle = module.D;
        AuthService = module.A;
      }, module => {
        Switch = module.S;
        default_1$u = module.d;
      }, module => {
        FormControl = module.F;
        FormLabel = module.b;
      }, module => {
        Checkbox = module.C;
      }, module => {
        FormControlLabel = module.F;
      }, module => {
        default_1$w = module.d;
      }, module => {
        LogoutOutlined = module.L;
      }, null, null, null],
      execute: function () {
        exports('default', DesignSurvey);
        function _objectWithoutProperties$2(source, excluded) {
          if (source == null) return {};
          var target = _objectWithoutPropertiesLoose(source, excluded);
          var key, i;
          if (Object.getOwnPropertySymbols) {
            var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
            for (i = 0; i < sourceSymbolKeys.length; i++) {
              key = sourceSymbolKeys[i];
              if (excluded.indexOf(key) >= 0) continue;
              if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
              target[key] = source[key];
            }
          }
          return target;
        }

        /**
         * This file automatically generated from `pre-publish.js`.
         * Do not manually edit.
         */

        var voidElements = {
          "area": true,
          "base": true,
          "br": true,
          "col": true,
          "embed": true,
          "hr": true,
          "img": true,
          "input": true,
          "link": true,
          "meta": true,
          "param": true,
          "source": true,
          "track": true,
          "wbr": true
        };
        const e$1 = /*@__PURE__*/getDefaultExportFromCjs(voidElements);
        var t = /\s([^'"/\s><]+?)[\s/>]|([^\s=]+)=\s?(".*?"|'.*?')/g;
        function n$1(n) {
          var r = {
              type: "tag",
              name: "",
              voidElement: !1,
              attrs: {},
              children: []
            },
            i = n.match(/<\/?([^\s]+?)[/\s>]/);
          if (i && (r.name = i[1], (e$1[i[1]] || "/" === n.charAt(n.length - 2)) && (r.voidElement = !0), r.name.startsWith("!--"))) {
            var s = n.indexOf("--\x3e");
            return {
              type: "comment",
              comment: -1 !== s ? n.slice(4, s) : ""
            };
          }
          for (var a = new RegExp(t), c = null; null !== (c = a.exec(n));) if (c[0].trim()) if (c[1]) {
            var o = c[1].trim(),
              l = [o, ""];
            o.indexOf("=") > -1 && (l = o.split("=")), r.attrs[l[0]] = l[1], a.lastIndex--;
          } else c[2] && (r.attrs[c[2]] = c[3].trim().substring(1, c[3].length - 1));
          return r;
        }
        var r$1 = /<[a-zA-Z0-9\-\!\/](?:"[^"]*"|'[^']*'|[^'">])*>/g,
          i = /^\s*$/,
          s = Object.create(null);
        function a(e, t) {
          switch (t.type) {
            case "text":
              return e + t.content;
            case "tag":
              return e += "<" + t.name + (t.attrs ? function (e) {
                var t = [];
                for (var n in e) t.push(n + '="' + e[n] + '"');
                return t.length ? " " + t.join(" ") : "";
              }(t.attrs) : "") + (t.voidElement ? "/>" : ">"), t.voidElement ? e : e + t.children.reduce(a, "") + "</" + t.name + ">";
            case "comment":
              return e + "\x3c!--" + t.comment + "--\x3e";
          }
        }
        var c$1 = {
          parse: function (e, t) {
            t || (t = {}), t.components || (t.components = s);
            var a,
              c = [],
              o = [],
              l = -1,
              m = !1;
            if (0 !== e.indexOf("<")) {
              var u = e.indexOf("<");
              c.push({
                type: "text",
                content: -1 === u ? e : e.substring(0, u)
              });
            }
            return e.replace(r$1, function (r, s) {
              if (m) {
                if (r !== "</" + a.name + ">") return;
                m = !1;
              }
              var u,
                f = "/" !== r.charAt(1),
                h = r.startsWith("\x3c!--"),
                p = s + r.length,
                d = e.charAt(p);
              if (h) {
                var v = n$1(r);
                return l < 0 ? (c.push(v), c) : ((u = o[l]).children.push(v), c);
              }
              if (f && (l++, "tag" === (a = n$1(r)).type && t.components[a.name] && (a.type = "component", m = !0), a.voidElement || m || !d || "<" === d || a.children.push({
                type: "text",
                content: e.slice(p, e.indexOf("<", p))
              }), 0 === l && c.push(a), (u = o[l - 1]) && u.children.push(a), o[l] = a), (!f || a.voidElement) && (l > -1 && (a.voidElement || a.name === r.slice(2, -1)) && (l--, a = -1 === l ? c : o[l]), !m && "<" !== d && d)) {
                u = -1 === l ? c : o[l].children;
                var x = e.indexOf("<", p),
                  g = e.slice(p, -1 === x ? void 0 : x);
                i.test(g) && (g = " "), (x > -1 && l + u.length >= 0 || " " !== g) && u.push({
                  type: "text",
                  content: g
                });
              }
            }), c;
          },
          stringify: function (e) {
            return e.reduce(function (e, t) {
              return e + a("", t);
            }, "");
          }
        };
        var _excluded$k = ["format"],
          _excluded2$1 = ["children", "count", "parent", "i18nKey", "context", "tOptions", "values", "defaults", "components", "ns", "i18n", "t", "shouldUnescape"];
        function ownKeys$x(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly) {
              symbols = symbols.filter(function (sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
            }
            keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$w(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            if (i % 2) {
              ownKeys$x(Object(source), true).forEach(function (key) {
                _defineProperty$4(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              ownKeys$x(Object(source)).forEach(function (key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target;
        }
        function hasChildren$1(node, checkLength) {
          if (!node) return false;
          var base = node.props ? node.props.children : node.children;
          if (checkLength) return base.length > 0;
          return !!base;
        }
        function getChildren(node) {
          if (!node) return [];
          return node.props ? node.props.children : node.children;
        }
        function hasValidReactChildren(children) {
          if (Object.prototype.toString.call(children) !== '[object Array]') return false;
          return children.every(function (child) {
            return reactExports.isValidElement(child);
          });
        }
        function getAsArray(data) {
          return Array.isArray(data) ? data : [data];
        }
        function mergeProps(source, target) {
          var newTarget = _objectSpread$w({}, target);
          newTarget.props = Object.assign(source.props, target.props);
          return newTarget;
        }
        function nodesToString(children, i18nOptions) {
          if (!children) return '';
          var stringNode = '';
          var childrenArray = getAsArray(children);
          var keepArray = i18nOptions.transSupportBasicHtmlNodes && i18nOptions.transKeepBasicHtmlNodesFor ? i18nOptions.transKeepBasicHtmlNodesFor : [];
          childrenArray.forEach(function (child, childIndex) {
            if (typeof child === 'string') {
              stringNode += "".concat(child);
            } else if (reactExports.isValidElement(child)) {
              var childPropsCount = Object.keys(child.props).length;
              var shouldKeepChild = keepArray.indexOf(child.type) > -1;
              var childChildren = child.props.children;
              if (!childChildren && shouldKeepChild && childPropsCount === 0) {
                stringNode += "<".concat(child.type, "/>");
              } else if (!childChildren && (!shouldKeepChild || childPropsCount !== 0)) {
                stringNode += "<".concat(childIndex, "></").concat(childIndex, ">");
              } else if (child.props.i18nIsDynamicList) {
                stringNode += "<".concat(childIndex, "></").concat(childIndex, ">");
              } else if (shouldKeepChild && childPropsCount === 1 && typeof childChildren === 'string') {
                stringNode += "<".concat(child.type, ">").concat(childChildren, "</").concat(child.type, ">");
              } else {
                var content = nodesToString(childChildren, i18nOptions);
                stringNode += "<".concat(childIndex, ">").concat(content, "</").concat(childIndex, ">");
              }
            } else if (child === null) {
              warn$1("Trans: the passed in value is invalid - seems you passed in a null child.");
            } else if (_typeof$2(child) === 'object') {
              var format = child.format,
                clone = _objectWithoutProperties$2(child, _excluded$k);
              var keys = Object.keys(clone);
              if (keys.length === 1) {
                var value = format ? "".concat(keys[0], ", ").concat(format) : keys[0];
                stringNode += "{{".concat(value, "}}");
              } else {
                warn$1("react-i18next: the passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.", child);
              }
            } else {
              warn$1("Trans: the passed in value is invalid - seems you passed in a variable like {number} - please pass in variables for interpolation as full objects like {{number}}.", child);
            }
          });
          return stringNode;
        }
        function renderNodes(children, targetString, i18n, i18nOptions, combinedTOpts, shouldUnescape) {
          if (targetString === '') return [];
          var keepArray = i18nOptions.transKeepBasicHtmlNodesFor || [];
          var emptyChildrenButNeedsHandling = targetString && new RegExp(keepArray.join('|')).test(targetString);
          if (!children && !emptyChildrenButNeedsHandling) return [targetString];
          var data = {};
          function getData(childs) {
            var childrenArray = getAsArray(childs);
            childrenArray.forEach(function (child) {
              if (typeof child === 'string') return;
              if (hasChildren$1(child)) getData(getChildren(child));else if (_typeof$2(child) === 'object' && !reactExports.isValidElement(child)) Object.assign(data, child);
            });
          }
          getData(children);
          var ast = c$1.parse("<0>".concat(targetString, "</0>"));
          var opts = _objectSpread$w(_objectSpread$w({}, data), combinedTOpts);
          function renderInner(child, node, rootReactNode) {
            var childs = getChildren(child);
            var mappedChildren = mapAST(childs, node.children, rootReactNode);
            return hasValidReactChildren(childs) && mappedChildren.length === 0 ? childs : mappedChildren;
          }
          function pushTranslatedJSX(child, inner, mem, i, isVoid) {
            if (child.dummy) child.children = inner;
            mem.push(reactExports.cloneElement(child, _objectSpread$w(_objectSpread$w({}, child.props), {}, {
              key: i
            }), isVoid ? undefined : inner));
          }
          function mapAST(reactNode, astNode, rootReactNode) {
            var reactNodes = getAsArray(reactNode);
            var astNodes = getAsArray(astNode);
            return astNodes.reduce(function (mem, node, i) {
              var translationContent = node.children && node.children[0] && node.children[0].content && i18n.services.interpolator.interpolate(node.children[0].content, opts, i18n.language);
              if (node.type === 'tag') {
                var tmp = reactNodes[parseInt(node.name, 10)];
                if (!tmp && rootReactNode.length === 1 && rootReactNode[0][node.name]) tmp = rootReactNode[0][node.name];
                if (!tmp) tmp = {};
                var child = Object.keys(node.attrs).length !== 0 ? mergeProps({
                  props: node.attrs
                }, tmp) : tmp;
                var isElement = reactExports.isValidElement(child);
                var isValidTranslationWithChildren = isElement && hasChildren$1(node, true) && !node.voidElement;
                var isEmptyTransWithHTML = emptyChildrenButNeedsHandling && _typeof$2(child) === 'object' && child.dummy && !isElement;
                var isKnownComponent = _typeof$2(children) === 'object' && children !== null && Object.hasOwnProperty.call(children, node.name);
                if (typeof child === 'string') {
                  var value = i18n.services.interpolator.interpolate(child, opts, i18n.language);
                  mem.push(value);
                } else if (hasChildren$1(child) || isValidTranslationWithChildren) {
                  var inner = renderInner(child, node, rootReactNode);
                  pushTranslatedJSX(child, inner, mem, i);
                } else if (isEmptyTransWithHTML) {
                  var _inner = mapAST(reactNodes, node.children, rootReactNode);
                  mem.push(reactExports.cloneElement(child, _objectSpread$w(_objectSpread$w({}, child.props), {}, {
                    key: i
                  }), _inner));
                } else if (Number.isNaN(parseFloat(node.name))) {
                  if (isKnownComponent) {
                    var _inner2 = renderInner(child, node, rootReactNode);
                    pushTranslatedJSX(child, _inner2, mem, i, node.voidElement);
                  } else if (i18nOptions.transSupportBasicHtmlNodes && keepArray.indexOf(node.name) > -1) {
                    if (node.voidElement) {
                      mem.push(reactExports.createElement(node.name, {
                        key: "".concat(node.name, "-").concat(i)
                      }));
                    } else {
                      var _inner3 = mapAST(reactNodes, node.children, rootReactNode);
                      mem.push(reactExports.createElement(node.name, {
                        key: "".concat(node.name, "-").concat(i)
                      }, _inner3));
                    }
                  } else if (node.voidElement) {
                    mem.push("<".concat(node.name, " />"));
                  } else {
                    var _inner4 = mapAST(reactNodes, node.children, rootReactNode);
                    mem.push("<".concat(node.name, ">").concat(_inner4, "</").concat(node.name, ">"));
                  }
                } else if (_typeof$2(child) === 'object' && !isElement) {
                  var content = node.children[0] ? translationContent : null;
                  if (content) mem.push(content);
                } else if (node.children.length === 1 && translationContent) {
                  mem.push(reactExports.cloneElement(child, _objectSpread$w(_objectSpread$w({}, child.props), {}, {
                    key: i
                  }), translationContent));
                } else {
                  mem.push(reactExports.cloneElement(child, _objectSpread$w(_objectSpread$w({}, child.props), {}, {
                    key: i
                  })));
                }
              } else if (node.type === 'text') {
                var wrapTextNodes = i18nOptions.transWrapTextNodes;
                var _content = shouldUnescape ? i18nOptions.unescape(i18n.services.interpolator.interpolate(node.content, opts, i18n.language)) : i18n.services.interpolator.interpolate(node.content, opts, i18n.language);
                if (wrapTextNodes) {
                  mem.push(reactExports.createElement(wrapTextNodes, {
                    key: "".concat(node.name, "-").concat(i)
                  }, _content));
                } else {
                  mem.push(_content);
                }
              }
              return mem;
            }, []);
          }
          var result = mapAST([{
            dummy: true,
            children: children || []
          }], ast, getAsArray(children || []));
          return getChildren(result[0]);
        }
        function Trans(_ref) {
          var children = _ref.children,
            count = _ref.count,
            parent = _ref.parent,
            i18nKey = _ref.i18nKey,
            context = _ref.context,
            _ref$tOptions = _ref.tOptions,
            tOptions = _ref$tOptions === void 0 ? {} : _ref$tOptions,
            values = _ref.values,
            defaults = _ref.defaults,
            components = _ref.components,
            ns = _ref.ns,
            i18nFromProps = _ref.i18n,
            tFromProps = _ref.t,
            shouldUnescape = _ref.shouldUnescape,
            additionalProps = _objectWithoutProperties$2(_ref, _excluded2$1);
          var _ref2 = reactExports.useContext(I18nContext) || {},
            i18nFromContext = _ref2.i18n,
            defaultNSFromContext = _ref2.defaultNS;
          var i18n = i18nFromProps || i18nFromContext || getI18n();
          if (!i18n) {
            warnOnce('You will need to pass in an i18next instance by using i18nextReactModule');
            return children;
          }
          var t = tFromProps || i18n.t.bind(i18n) || function (k) {
            return k;
          };
          if (context) tOptions.context = context;
          var reactI18nextOptions = _objectSpread$w(_objectSpread$w({}, getDefaults()), i18n.options && i18n.options.react);
          var namespaces = ns || t.ns || defaultNSFromContext || i18n.options && i18n.options.defaultNS;
          namespaces = typeof namespaces === 'string' ? [namespaces] : namespaces || ['translation'];
          var defaultValue = defaults || nodesToString(children, reactI18nextOptions) || reactI18nextOptions.transEmptyNodeValue || i18nKey;
          var hashTransKey = reactI18nextOptions.hashTransKey;
          var key = i18nKey || (hashTransKey ? hashTransKey(defaultValue) : defaultValue);
          var interpolationOverride = values ? tOptions.interpolation : {
            interpolation: _objectSpread$w(_objectSpread$w({}, tOptions.interpolation), {}, {
              prefix: '#$?',
              suffix: '?$#'
            })
          };
          var combinedTOpts = _objectSpread$w(_objectSpread$w(_objectSpread$w(_objectSpread$w({}, tOptions), {}, {
            count: count
          }, values), interpolationOverride), {}, {
            defaultValue: defaultValue,
            ns: namespaces
          });
          var translation = key ? t(key, combinedTOpts) : defaultValue;
          var content = renderNodes(components || children, translation, i18n, reactI18nextOptions, combinedTOpts, shouldUnescape);
          var useAsParent = parent !== undefined ? parent : reactI18nextOptions.defaultTransParent;
          return useAsParent ? reactExports.createElement(useAsParent, additionalProps, content) : content;
        }
        const usePreviousProps = value => {
          const ref = reactExports.useRef({});
          reactExports.useEffect(() => {
            ref.current = value;
          });
          return ref.current;
        };
        const usePreviousProps$1 = usePreviousProps;
        const visuallyHidden = {
          border: 0,
          clip: 'rect(0 0 0 0)',
          height: '1px',
          margin: -1,
          overflow: 'hidden',
          padding: 0,
          position: 'absolute',
          whiteSpace: 'nowrap',
          width: '1px'
        };
        const visuallyHidden$1 = visuallyHidden;
        function areArraysEqual(array1, array2, itemComparer = (a, b) => a === b) {
          return array1.length === array2.length && array1.every((value, index) => itemComparer(value, array2[index]));
        }
        const INTENTIONAL_DRAG_COUNT_THRESHOLD = 2;
        function asc(a, b) {
          return a - b;
        }
        function clamp(value, min, max) {
          if (value == null) {
            return min;
          }
          return Math.min(Math.max(min, value), max);
        }
        function findClosest(values, currentValue) {
          var _values$reduce;
          const {
            index: closestIndex
          } = (_values$reduce = values.reduce((acc, value, index) => {
            const distance = Math.abs(currentValue - value);
            if (acc === null || distance < acc.distance || distance === acc.distance) {
              return {
                distance,
                index
              };
            }
            return acc;
          }, null)) != null ? _values$reduce : {};
          return closestIndex;
        }
        function trackFinger(event, touchId) {
          // The event is TouchEvent
          if (touchId.current !== undefined && event.changedTouches) {
            const touchEvent = event;
            for (let i = 0; i < touchEvent.changedTouches.length; i += 1) {
              const touch = touchEvent.changedTouches[i];
              if (touch.identifier === touchId.current) {
                return {
                  x: touch.clientX,
                  y: touch.clientY
                };
              }
            }
            return false;
          }

          // The event is MouseEvent
          return {
            x: event.clientX,
            y: event.clientY
          };
        }
        function valueToPercent(value, min, max) {
          return (value - min) * 100 / (max - min);
        }
        function percentToValue(percent, min, max) {
          return (max - min) * percent + min;
        }
        function getDecimalPrecision(num) {
          // This handles the case when num is very small (0.00000001), js will turn this into 1e-8.
          // When num is bigger than 1 or less than -1 it won't get converted to this notation so it's fine.
          if (Math.abs(num) < 1) {
            const parts = num.toExponential().split('e-');
            const matissaDecimalPart = parts[0].split('.')[1];
            return (matissaDecimalPart ? matissaDecimalPart.length : 0) + parseInt(parts[1], 10);
          }
          const decimalPart = num.toString().split('.')[1];
          return decimalPart ? decimalPart.length : 0;
        }
        function roundValueToStep(value, step, min) {
          const nearest = Math.round((value - min) / step) * step + min;
          return Number(nearest.toFixed(getDecimalPrecision(step)));
        }
        function setValueIndex({
          values,
          newValue,
          index
        }) {
          const output = values.slice();
          output[index] = newValue;
          return output.sort(asc);
        }
        function focusThumb({
          sliderRef,
          activeIndex,
          setActive
        }) {
          var _sliderRef$current, _doc$activeElement;
          const doc = ownerDocument(sliderRef.current);
          if (!((_sliderRef$current = sliderRef.current) != null && _sliderRef$current.contains(doc.activeElement)) || Number(doc == null ? void 0 : (_doc$activeElement = doc.activeElement) == null ? void 0 : _doc$activeElement.getAttribute('data-index')) !== activeIndex) {
            var _sliderRef$current2;
            (_sliderRef$current2 = sliderRef.current) == null ? void 0 : _sliderRef$current2.querySelector(`[type="range"][data-index="${activeIndex}"]`).focus();
          }
          if (setActive) {
            setActive(activeIndex);
          }
        }
        function areValuesEqual(newValue, oldValue) {
          if (typeof newValue === 'number' && typeof oldValue === 'number') {
            return newValue === oldValue;
          }
          if (typeof newValue === 'object' && typeof oldValue === 'object') {
            return areArraysEqual(newValue, oldValue);
          }
          return false;
        }
        const axisProps = {
          horizontal: {
            offset: percent => ({
              left: `${percent}%`
            }),
            leap: percent => ({
              width: `${percent}%`
            })
          },
          'horizontal-reverse': {
            offset: percent => ({
              right: `${percent}%`
            }),
            leap: percent => ({
              width: `${percent}%`
            })
          },
          vertical: {
            offset: percent => ({
              bottom: `${percent}%`
            }),
            leap: percent => ({
              height: `${percent}%`
            })
          }
        };
        const Identity$1 = x => x;

        // TODO: remove support for Safari < 13.
        // https://caniuse.com/#search=touch-action
        //
        // Safari, on iOS, supports touch action since v13.
        // Over 80% of the iOS phones are compatible
        // in August 2020.
        // Utilizing the CSS.supports method to check if touch-action is supported.
        // Since CSS.supports is supported on all but Edge@12 and IE and touch-action
        // is supported on both Edge@12 and IE if CSS.supports is not available that means that
        // touch-action will be supported
        let cachedSupportsTouchActionNone;
        function doesSupportTouchActionNone() {
          if (cachedSupportsTouchActionNone === undefined) {
            if (typeof CSS !== 'undefined' && typeof CSS.supports === 'function') {
              cachedSupportsTouchActionNone = CSS.supports('touch-action', 'none');
            } else {
              cachedSupportsTouchActionNone = true;
            }
          }
          return cachedSupportsTouchActionNone;
        }
        /**
         *
         * Demos:
         *
         * - [Slider](https://mui.com/base/react-slider/#hook)
         *
         * API:
         *
         * - [useSlider API](https://mui.com/base/react-slider/hooks-api/#use-slider)
         */
        function useSlider(parameters) {
          const {
            'aria-labelledby': ariaLabelledby,
            defaultValue,
            disabled = false,
            disableSwap = false,
            isRtl = false,
            marks: marksProp = false,
            max = 100,
            min = 0,
            name,
            onChange,
            onChangeCommitted,
            orientation = 'horizontal',
            ref,
            scale = Identity$1,
            step = 1,
            tabIndex,
            value: valueProp
          } = parameters;
          const touchId = reactExports.useRef();
          // We can't use the :active browser pseudo-classes.
          // - The active state isn't triggered when clicking on the rail.
          // - The active state isn't transferred when inversing a range slider.
          const [active, setActive] = reactExports.useState(-1);
          const [open, setOpen] = reactExports.useState(-1);
          const [dragging, setDragging] = reactExports.useState(false);
          const moveCount = reactExports.useRef(0);
          const [valueDerived, setValueState] = useControlled({
            controlled: valueProp,
            default: defaultValue != null ? defaultValue : min,
            name: 'Slider'
          });
          const handleChange = onChange && ((event, value, thumbIndex) => {
            // Redefine target to allow name and value to be read.
            // This allows seamless integration with the most popular form libraries.
            // https://github.com/mui/material-ui/issues/13485#issuecomment-676048492
            // Clone the event to not override `target` of the original event.
            const nativeEvent = event.nativeEvent || event;
            // @ts-ignore The nativeEvent is function, not object
            const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
            Object.defineProperty(clonedEvent, 'target', {
              writable: true,
              value: {
                value,
                name
              }
            });
            onChange(clonedEvent, value, thumbIndex);
          });
          const range = Array.isArray(valueDerived);
          let values = range ? valueDerived.slice().sort(asc) : [valueDerived];
          values = values.map(value => clamp(value, min, max));
          const marks = marksProp === true && step !== null ? [...Array(Math.floor((max - min) / step) + 1)].map((_, index) => ({
            value: min + step * index
          })) : marksProp || [];
          const marksValues = marks.map(mark => mark.value);
          const {
            isFocusVisibleRef,
            onBlur: handleBlurVisible,
            onFocus: handleFocusVisible,
            ref: focusVisibleRef
          } = useIsFocusVisible();
          const [focusedThumbIndex, setFocusedThumbIndex] = reactExports.useState(-1);
          const sliderRef = reactExports.useRef();
          const handleFocusRef = useForkRef(focusVisibleRef, sliderRef);
          const handleRef = useForkRef(ref, handleFocusRef);
          const createHandleHiddenInputFocus = otherHandlers => event => {
            var _otherHandlers$onFocu;
            const index = Number(event.currentTarget.getAttribute('data-index'));
            handleFocusVisible(event);
            if (isFocusVisibleRef.current === true) {
              setFocusedThumbIndex(index);
            }
            setOpen(index);
            otherHandlers == null ? void 0 : (_otherHandlers$onFocu = otherHandlers.onFocus) == null ? void 0 : _otherHandlers$onFocu.call(otherHandlers, event);
          };
          const createHandleHiddenInputBlur = otherHandlers => event => {
            var _otherHandlers$onBlur;
            handleBlurVisible(event);
            if (isFocusVisibleRef.current === false) {
              setFocusedThumbIndex(-1);
            }
            setOpen(-1);
            otherHandlers == null ? void 0 : (_otherHandlers$onBlur = otherHandlers.onBlur) == null ? void 0 : _otherHandlers$onBlur.call(otherHandlers, event);
          };
          useEnhancedEffect(() => {
            if (disabled && sliderRef.current.contains(document.activeElement)) {
              var _document$activeEleme;
              // This is necessary because Firefox and Safari will keep focus
              // on a disabled element:
              // https://codesandbox.io/s/mui-pr-22247-forked-h151h?file=/src/App.js
              // @ts-ignore
              (_document$activeEleme = document.activeElement) == null ? void 0 : _document$activeEleme.blur();
            }
          }, [disabled]);
          if (disabled && active !== -1) {
            setActive(-1);
          }
          if (disabled && focusedThumbIndex !== -1) {
            setFocusedThumbIndex(-1);
          }
          const createHandleHiddenInputChange = otherHandlers => event => {
            var _otherHandlers$onChan;
            (_otherHandlers$onChan = otherHandlers.onChange) == null ? void 0 : _otherHandlers$onChan.call(otherHandlers, event);
            const index = Number(event.currentTarget.getAttribute('data-index'));
            const value = values[index];
            const marksIndex = marksValues.indexOf(value);

            // @ts-ignore
            let newValue = event.target.valueAsNumber;
            if (marks && step == null) {
              newValue = newValue < value ? marksValues[marksIndex - 1] : marksValues[marksIndex + 1];
            }
            newValue = clamp(newValue, min, max);
            if (marks && step == null) {
              const currentMarkIndex = marksValues.indexOf(values[index]);
              newValue = newValue < values[index] ? marksValues[currentMarkIndex - 1] : marksValues[currentMarkIndex + 1];
            }
            if (range) {
              // Bound the new value to the thumb's neighbours.
              if (disableSwap) {
                newValue = clamp(newValue, values[index - 1] || -Infinity, values[index + 1] || Infinity);
              }
              const previousValue = newValue;
              newValue = setValueIndex({
                values,
                newValue,
                index
              });
              let activeIndex = index;

              // Potentially swap the index if needed.
              if (!disableSwap) {
                activeIndex = newValue.indexOf(previousValue);
              }
              focusThumb({
                sliderRef,
                activeIndex
              });
            }
            setValueState(newValue);
            setFocusedThumbIndex(index);
            if (handleChange && !areValuesEqual(newValue, valueDerived)) {
              handleChange(event, newValue, index);
            }
            if (onChangeCommitted) {
              onChangeCommitted(event, newValue);
            }
          };
          const previousIndex = reactExports.useRef();
          let axis = orientation;
          if (isRtl && orientation === 'horizontal') {
            axis += '-reverse';
          }
          const getFingerNewValue = ({
            finger,
            move = false
          }) => {
            const {
              current: slider
            } = sliderRef;
            const {
              width,
              height,
              bottom,
              left
            } = slider.getBoundingClientRect();
            let percent;
            if (axis.indexOf('vertical') === 0) {
              percent = (bottom - finger.y) / height;
            } else {
              percent = (finger.x - left) / width;
            }
            if (axis.indexOf('-reverse') !== -1) {
              percent = 1 - percent;
            }
            let newValue;
            newValue = percentToValue(percent, min, max);
            if (step) {
              newValue = roundValueToStep(newValue, step, min);
            } else {
              const closestIndex = findClosest(marksValues, newValue);
              newValue = marksValues[closestIndex];
            }
            newValue = clamp(newValue, min, max);
            let activeIndex = 0;
            if (range) {
              if (!move) {
                activeIndex = findClosest(values, newValue);
              } else {
                activeIndex = previousIndex.current;
              }

              // Bound the new value to the thumb's neighbours.
              if (disableSwap) {
                newValue = clamp(newValue, values[activeIndex - 1] || -Infinity, values[activeIndex + 1] || Infinity);
              }
              const previousValue = newValue;
              newValue = setValueIndex({
                values,
                newValue,
                index: activeIndex
              });

              // Potentially swap the index if needed.
              if (!(disableSwap && move)) {
                activeIndex = newValue.indexOf(previousValue);
                previousIndex.current = activeIndex;
              }
            }
            return {
              newValue,
              activeIndex
            };
          };
          const handleTouchMove = useEventCallback(nativeEvent => {
            const finger = trackFinger(nativeEvent, touchId);
            if (!finger) {
              return;
            }
            moveCount.current += 1;

            // Cancel move in case some other element consumed a mouseup event and it was not fired.
            // @ts-ignore buttons doesn't not exists on touch event
            if (nativeEvent.type === 'mousemove' && nativeEvent.buttons === 0) {
              // eslint-disable-next-line @typescript-eslint/no-use-before-define
              handleTouchEnd(nativeEvent);
              return;
            }
            const {
              newValue,
              activeIndex
            } = getFingerNewValue({
              finger,
              move: true
            });
            focusThumb({
              sliderRef,
              activeIndex,
              setActive
            });
            setValueState(newValue);
            if (!dragging && moveCount.current > INTENTIONAL_DRAG_COUNT_THRESHOLD) {
              setDragging(true);
            }
            if (handleChange && !areValuesEqual(newValue, valueDerived)) {
              handleChange(nativeEvent, newValue, activeIndex);
            }
          });
          const handleTouchEnd = useEventCallback(nativeEvent => {
            const finger = trackFinger(nativeEvent, touchId);
            setDragging(false);
            if (!finger) {
              return;
            }
            const {
              newValue
            } = getFingerNewValue({
              finger,
              move: true
            });
            setActive(-1);
            if (nativeEvent.type === 'touchend') {
              setOpen(-1);
            }
            if (onChangeCommitted) {
              onChangeCommitted(nativeEvent, newValue);
            }
            touchId.current = undefined;

            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            stopListening();
          });
          const handleTouchStart = useEventCallback(nativeEvent => {
            if (disabled) {
              return;
            }
            // If touch-action: none; is not supported we need to prevent the scroll manually.
            if (!doesSupportTouchActionNone()) {
              nativeEvent.preventDefault();
            }
            const touch = nativeEvent.changedTouches[0];
            if (touch != null) {
              // A number that uniquely identifies the current finger in the touch session.
              touchId.current = touch.identifier;
            }
            const finger = trackFinger(nativeEvent, touchId);
            if (finger !== false) {
              const {
                newValue,
                activeIndex
              } = getFingerNewValue({
                finger
              });
              focusThumb({
                sliderRef,
                activeIndex,
                setActive
              });
              setValueState(newValue);
              if (handleChange && !areValuesEqual(newValue, valueDerived)) {
                handleChange(nativeEvent, newValue, activeIndex);
              }
            }
            moveCount.current = 0;
            const doc = ownerDocument(sliderRef.current);
            doc.addEventListener('touchmove', handleTouchMove);
            doc.addEventListener('touchend', handleTouchEnd);
          });
          const stopListening = reactExports.useCallback(() => {
            const doc = ownerDocument(sliderRef.current);
            doc.removeEventListener('mousemove', handleTouchMove);
            doc.removeEventListener('mouseup', handleTouchEnd);
            doc.removeEventListener('touchmove', handleTouchMove);
            doc.removeEventListener('touchend', handleTouchEnd);
          }, [handleTouchEnd, handleTouchMove]);
          reactExports.useEffect(() => {
            const {
              current: slider
            } = sliderRef;
            slider.addEventListener('touchstart', handleTouchStart, {
              passive: doesSupportTouchActionNone()
            });
            return () => {
              // @ts-ignore
              slider.removeEventListener('touchstart', handleTouchStart, {
                passive: doesSupportTouchActionNone()
              });
              stopListening();
            };
          }, [stopListening, handleTouchStart]);
          reactExports.useEffect(() => {
            if (disabled) {
              stopListening();
            }
          }, [disabled, stopListening]);
          const createHandleMouseDown = otherHandlers => event => {
            var _otherHandlers$onMous;
            (_otherHandlers$onMous = otherHandlers.onMouseDown) == null ? void 0 : _otherHandlers$onMous.call(otherHandlers, event);
            if (disabled) {
              return;
            }
            if (event.defaultPrevented) {
              return;
            }

            // Only handle left clicks
            if (event.button !== 0) {
              return;
            }

            // Avoid text selection
            event.preventDefault();
            const finger = trackFinger(event, touchId);
            if (finger !== false) {
              const {
                newValue,
                activeIndex
              } = getFingerNewValue({
                finger
              });
              focusThumb({
                sliderRef,
                activeIndex,
                setActive
              });
              setValueState(newValue);
              if (handleChange && !areValuesEqual(newValue, valueDerived)) {
                handleChange(event, newValue, activeIndex);
              }
            }
            moveCount.current = 0;
            const doc = ownerDocument(sliderRef.current);
            doc.addEventListener('mousemove', handleTouchMove);
            doc.addEventListener('mouseup', handleTouchEnd);
          };
          const trackOffset = valueToPercent(range ? values[0] : min, min, max);
          const trackLeap = valueToPercent(values[values.length - 1], min, max) - trackOffset;
          const getRootProps = (otherHandlers = {}) => {
            const ownEventHandlers = {
              onMouseDown: createHandleMouseDown(otherHandlers || {})
            };
            const mergedEventHandlers = _extends$h({}, otherHandlers, ownEventHandlers);
            return _extends$h({
              ref: handleRef
            }, mergedEventHandlers);
          };
          const createHandleMouseOver = otherHandlers => event => {
            var _otherHandlers$onMous2;
            (_otherHandlers$onMous2 = otherHandlers.onMouseOver) == null ? void 0 : _otherHandlers$onMous2.call(otherHandlers, event);
            const index = Number(event.currentTarget.getAttribute('data-index'));
            setOpen(index);
          };
          const createHandleMouseLeave = otherHandlers => event => {
            var _otherHandlers$onMous3;
            (_otherHandlers$onMous3 = otherHandlers.onMouseLeave) == null ? void 0 : _otherHandlers$onMous3.call(otherHandlers, event);
            setOpen(-1);
          };
          const getThumbProps = (otherHandlers = {}) => {
            const ownEventHandlers = {
              onMouseOver: createHandleMouseOver(otherHandlers || {}),
              onMouseLeave: createHandleMouseLeave(otherHandlers || {})
            };
            return _extends$h({}, otherHandlers, ownEventHandlers);
          };
          const getHiddenInputProps = (otherHandlers = {}) => {
            var _parameters$step;
            const ownEventHandlers = {
              onChange: createHandleHiddenInputChange(otherHandlers || {}),
              onFocus: createHandleHiddenInputFocus(otherHandlers || {}),
              onBlur: createHandleHiddenInputBlur(otherHandlers || {})
            };
            const mergedEventHandlers = _extends$h({}, otherHandlers, ownEventHandlers);
            return _extends$h({
              tabIndex,
              'aria-labelledby': ariaLabelledby,
              'aria-orientation': orientation,
              'aria-valuemax': scale(max),
              'aria-valuemin': scale(min),
              name,
              type: 'range',
              min: parameters.min,
              max: parameters.max,
              step: (_parameters$step = parameters.step) != null ? _parameters$step : undefined,
              disabled
            }, mergedEventHandlers, {
              style: _extends$h({}, visuallyHidden$1, {
                direction: isRtl ? 'rtl' : 'ltr',
                // So that VoiceOver's focus indicator matches the thumb's dimensions
                width: '100%',
                height: '100%'
              })
            });
          };
          return {
            active,
            axis: axis,
            axisProps,
            dragging,
            focusedThumbIndex,
            getHiddenInputProps,
            getRootProps,
            getThumbProps,
            marks: marks,
            open,
            range,
            trackLeap,
            trackOffset,
            values
          };
        }

        // https://stackoverflow.com/questions/990904/remove-accents-diacritics-in-a-string-in-javascript
        // Give up on IE11 support for this feature
        function stripDiacritics(string) {
          return typeof string.normalize !== 'undefined' ? string.normalize('NFD').replace(/[\u0300-\u036f]/g, '') : string;
        }
        function createFilterOptions(config = {}) {
          const {
            ignoreAccents = true,
            ignoreCase = true,
            limit,
            matchFrom = 'any',
            stringify,
            trim = false
          } = config;
          return (options, {
            inputValue,
            getOptionLabel
          }) => {
            let input = trim ? inputValue.trim() : inputValue;
            if (ignoreCase) {
              input = input.toLowerCase();
            }
            if (ignoreAccents) {
              input = stripDiacritics(input);
            }
            const filteredOptions = !input ? options : options.filter(option => {
              let candidate = (stringify || getOptionLabel)(option);
              if (ignoreCase) {
                candidate = candidate.toLowerCase();
              }
              if (ignoreAccents) {
                candidate = stripDiacritics(candidate);
              }
              return matchFrom === 'start' ? candidate.indexOf(input) === 0 : candidate.indexOf(input) > -1;
            });
            return typeof limit === 'number' ? filteredOptions.slice(0, limit) : filteredOptions;
          };
        }

        // To replace with .findIndex() once we stop IE11 support.
        function findIndex(array, comp) {
          for (let i = 0; i < array.length; i += 1) {
            if (comp(array[i])) {
              return i;
            }
          }
          return -1;
        }
        const defaultFilterOptions$1 = createFilterOptions();

        // Number of options to jump in list box when `Page Up` and `Page Down` keys are used.
        const pageSize = 5;
        const defaultIsActiveElementInListbox = listboxRef => {
          var _listboxRef$current$p;
          return listboxRef.current !== null && ((_listboxRef$current$p = listboxRef.current.parentElement) == null ? void 0 : _listboxRef$current$p.contains(document.activeElement));
        };
        function useAutocomplete(props) {
          const {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            unstable_isActiveElementInListbox = defaultIsActiveElementInListbox,
            // eslint-disable-next-line @typescript-eslint/naming-convention
            unstable_classNamePrefix = 'Mui',
            autoComplete = false,
            autoHighlight = false,
            autoSelect = false,
            blurOnSelect = false,
            clearOnBlur = !props.freeSolo,
            clearOnEscape = false,
            componentName = 'useAutocomplete',
            defaultValue = props.multiple ? [] : null,
            disableClearable = false,
            disableCloseOnSelect = false,
            disabled: disabledProp,
            disabledItemsFocusable = false,
            disableListWrap = false,
            filterOptions = defaultFilterOptions$1,
            filterSelectedOptions = false,
            freeSolo = false,
            getOptionDisabled,
            getOptionLabel: getOptionLabelProp = option => {
              var _option$label;
              return (_option$label = option.label) != null ? _option$label : option;
            },
            groupBy,
            handleHomeEndKeys = !props.freeSolo,
            id: idProp,
            includeInputInList = false,
            inputValue: inputValueProp,
            isOptionEqualToValue = (option, value) => option === value,
            multiple = false,
            onChange,
            onClose,
            onHighlightChange,
            onInputChange,
            onOpen,
            open: openProp,
            openOnFocus = false,
            options,
            readOnly = false,
            selectOnFocus = !props.freeSolo,
            value: valueProp
          } = props;
          const id = useId(idProp);
          let getOptionLabel = getOptionLabelProp;
          getOptionLabel = option => {
            const optionLabel = getOptionLabelProp(option);
            if (typeof optionLabel !== 'string') {
              return String(optionLabel);
            }
            return optionLabel;
          };
          const ignoreFocus = reactExports.useRef(false);
          const firstFocus = reactExports.useRef(true);
          const inputRef = reactExports.useRef(null);
          const listboxRef = reactExports.useRef(null);
          const [anchorEl, setAnchorEl] = reactExports.useState(null);
          const [focusedTag, setFocusedTag] = reactExports.useState(-1);
          const defaultHighlighted = autoHighlight ? 0 : -1;
          const highlightedIndexRef = reactExports.useRef(defaultHighlighted);
          const [value, setValueState] = useControlled({
            controlled: valueProp,
            default: defaultValue,
            name: componentName
          });
          const [inputValue, setInputValueState] = useControlled({
            controlled: inputValueProp,
            default: '',
            name: componentName,
            state: 'inputValue'
          });
          const [focused, setFocused] = reactExports.useState(false);
          const resetInputValue = reactExports.useCallback((event, newValue) => {
            // retain current `inputValue` if new option isn't selected and `clearOnBlur` is false
            // When `multiple` is enabled, `newValue` is an array of all selected items including the newly selected item
            const isOptionSelected = multiple ? value.length < newValue.length : newValue !== null;
            if (!isOptionSelected && !clearOnBlur) {
              return;
            }
            let newInputValue;
            if (multiple) {
              newInputValue = '';
            } else if (newValue == null) {
              newInputValue = '';
            } else {
              const optionLabel = getOptionLabel(newValue);
              newInputValue = typeof optionLabel === 'string' ? optionLabel : '';
            }
            if (inputValue === newInputValue) {
              return;
            }
            setInputValueState(newInputValue);
            if (onInputChange) {
              onInputChange(event, newInputValue, 'reset');
            }
          }, [getOptionLabel, inputValue, multiple, onInputChange, setInputValueState, clearOnBlur, value]);
          const [open, setOpenState] = useControlled({
            controlled: openProp,
            default: false,
            name: componentName,
            state: 'open'
          });
          const [inputPristine, setInputPristine] = reactExports.useState(true);
          const inputValueIsSelectedValue = !multiple && value != null && inputValue === getOptionLabel(value);
          const popupOpen = open && !readOnly;
          const filteredOptions = popupOpen ? filterOptions(options.filter(option => {
            if (filterSelectedOptions && (multiple ? value : [value]).some(value2 => value2 !== null && isOptionEqualToValue(option, value2))) {
              return false;
            }
            return true;
          }),
          // we use the empty string to manipulate `filterOptions` to not filter any options
          // i.e. the filter predicate always returns true
          {
            inputValue: inputValueIsSelectedValue && inputPristine ? '' : inputValue,
            getOptionLabel
          }) : [];
          const previousProps = usePreviousProps$1({
            filteredOptions,
            value
          });
          reactExports.useEffect(() => {
            const valueChange = value !== previousProps.value;
            if (focused && !valueChange) {
              return;
            }

            // Only reset the input's value when freeSolo if the component's value changes.
            if (freeSolo && !valueChange) {
              return;
            }
            resetInputValue(null, value);
          }, [value, resetInputValue, focused, previousProps.value, freeSolo]);
          const listboxAvailable = open && filteredOptions.length > 0 && !readOnly;
          const focusTag = useEventCallback(tagToFocus => {
            if (tagToFocus === -1) {
              inputRef.current.focus();
            } else {
              anchorEl.querySelector(`[data-tag-index="${tagToFocus}"]`).focus();
            }
          });

          // Ensure the focusedTag is never inconsistent
          reactExports.useEffect(() => {
            if (multiple && focusedTag > value.length - 1) {
              setFocusedTag(-1);
              focusTag(-1);
            }
          }, [value, multiple, focusedTag, focusTag]);
          function validOptionIndex(index, direction) {
            if (!listboxRef.current || index === -1) {
              return -1;
            }
            let nextFocus = index;
            while (true) {
              // Out of range
              if (direction === 'next' && nextFocus === filteredOptions.length || direction === 'previous' && nextFocus === -1) {
                return -1;
              }
              const option = listboxRef.current.querySelector(`[data-option-index="${nextFocus}"]`);

              // Same logic as MenuList.js
              const nextFocusDisabled = disabledItemsFocusable ? false : !option || option.disabled || option.getAttribute('aria-disabled') === 'true';
              if (option && !option.hasAttribute('tabindex') || nextFocusDisabled) {
                // Move to the next element.
                nextFocus += direction === 'next' ? 1 : -1;
              } else {
                return nextFocus;
              }
            }
          }
          const setHighlightedIndex = useEventCallback(({
            event,
            index,
            reason = 'auto'
          }) => {
            highlightedIndexRef.current = index;

            // does the index exist?
            if (index === -1) {
              inputRef.current.removeAttribute('aria-activedescendant');
            } else {
              inputRef.current.setAttribute('aria-activedescendant', `${id}-option-${index}`);
            }
            if (onHighlightChange) {
              onHighlightChange(event, index === -1 ? null : filteredOptions[index], reason);
            }
            if (!listboxRef.current) {
              return;
            }
            const prev = listboxRef.current.querySelector(`[role="option"].${unstable_classNamePrefix}-focused`);
            if (prev) {
              prev.classList.remove(`${unstable_classNamePrefix}-focused`);
              prev.classList.remove(`${unstable_classNamePrefix}-focusVisible`);
            }
            const listboxNode = listboxRef.current.parentElement.querySelector('[role="listbox"]');

            // "No results"
            if (!listboxNode) {
              return;
            }
            if (index === -1) {
              listboxNode.scrollTop = 0;
              return;
            }
            const option = listboxRef.current.querySelector(`[data-option-index="${index}"]`);
            if (!option) {
              return;
            }
            option.classList.add(`${unstable_classNamePrefix}-focused`);
            if (reason === 'keyboard') {
              option.classList.add(`${unstable_classNamePrefix}-focusVisible`);
            }

            // Scroll active descendant into view.
            // Logic copied from https://www.w3.org/WAI/content-assets/wai-aria-practices/patterns/combobox/examples/js/select-only.js
            //
            // Consider this API instead once it has a better browser support:
            // .scrollIntoView({ scrollMode: 'if-needed', block: 'nearest' });
            if (listboxNode.scrollHeight > listboxNode.clientHeight && reason !== 'mouse') {
              const element = option;
              const scrollBottom = listboxNode.clientHeight + listboxNode.scrollTop;
              const elementBottom = element.offsetTop + element.offsetHeight;
              if (elementBottom > scrollBottom) {
                listboxNode.scrollTop = elementBottom - listboxNode.clientHeight;
              } else if (element.offsetTop - element.offsetHeight * (groupBy ? 1.3 : 0) < listboxNode.scrollTop) {
                listboxNode.scrollTop = element.offsetTop - element.offsetHeight * (groupBy ? 1.3 : 0);
              }
            }
          });
          const changeHighlightedIndex = useEventCallback(({
            event,
            diff,
            direction = 'next',
            reason = 'auto'
          }) => {
            if (!popupOpen) {
              return;
            }
            const getNextIndex = () => {
              const maxIndex = filteredOptions.length - 1;
              if (diff === 'reset') {
                return defaultHighlighted;
              }
              if (diff === 'start') {
                return 0;
              }
              if (diff === 'end') {
                return maxIndex;
              }
              const newIndex = highlightedIndexRef.current + diff;
              if (newIndex < 0) {
                if (newIndex === -1 && includeInputInList) {
                  return -1;
                }
                if (disableListWrap && highlightedIndexRef.current !== -1 || Math.abs(diff) > 1) {
                  return 0;
                }
                return maxIndex;
              }
              if (newIndex > maxIndex) {
                if (newIndex === maxIndex + 1 && includeInputInList) {
                  return -1;
                }
                if (disableListWrap || Math.abs(diff) > 1) {
                  return maxIndex;
                }
                return 0;
              }
              return newIndex;
            };
            const nextIndex = validOptionIndex(getNextIndex(), direction);
            setHighlightedIndex({
              index: nextIndex,
              reason,
              event
            });

            // Sync the content of the input with the highlighted option.
            if (autoComplete && diff !== 'reset') {
              if (nextIndex === -1) {
                inputRef.current.value = inputValue;
              } else {
                const option = getOptionLabel(filteredOptions[nextIndex]);
                inputRef.current.value = option;

                // The portion of the selected suggestion that has not been typed by the user,
                // a completion string, appears inline after the input cursor in the textbox.
                const index = option.toLowerCase().indexOf(inputValue.toLowerCase());
                if (index === 0 && inputValue.length > 0) {
                  inputRef.current.setSelectionRange(inputValue.length, option.length);
                }
              }
            }
          });
          const checkHighlightedOptionExists = () => {
            const isSameValue = (value1, value2) => {
              const label1 = value1 ? getOptionLabel(value1) : '';
              const label2 = value2 ? getOptionLabel(value2) : '';
              return label1 === label2;
            };
            if (highlightedIndexRef.current !== -1 && previousProps.filteredOptions && previousProps.filteredOptions.length !== filteredOptions.length && (multiple ? value.length === previousProps.value.length && previousProps.value.every((val, i) => getOptionLabel(value[i]) === getOptionLabel(val)) : isSameValue(previousProps.value, value))) {
              const previousHighlightedOption = previousProps.filteredOptions[highlightedIndexRef.current];
              if (previousHighlightedOption) {
                const previousHighlightedOptionExists = filteredOptions.some(option => {
                  return getOptionLabel(option) === getOptionLabel(previousHighlightedOption);
                });
                if (previousHighlightedOptionExists) {
                  return true;
                }
              }
            }
            return false;
          };
          const syncHighlightedIndex = reactExports.useCallback(() => {
            if (!popupOpen) {
              return;
            }

            // Check if the previously highlighted option still exists in the updated filtered options list and if the value hasn't changed
            // If it exists and the value hasn't changed, return, otherwise continue execution
            if (checkHighlightedOptionExists()) {
              return;
            }
            const valueItem = multiple ? value[0] : value;

            // The popup is empty, reset
            if (filteredOptions.length === 0 || valueItem == null) {
              changeHighlightedIndex({
                diff: 'reset'
              });
              return;
            }
            if (!listboxRef.current) {
              return;
            }

            // Synchronize the value with the highlighted index
            if (valueItem != null) {
              const currentOption = filteredOptions[highlightedIndexRef.current];

              // Keep the current highlighted index if possible
              if (multiple && currentOption && findIndex(value, val => isOptionEqualToValue(currentOption, val)) !== -1) {
                return;
              }
              const itemIndex = findIndex(filteredOptions, optionItem => isOptionEqualToValue(optionItem, valueItem));
              if (itemIndex === -1) {
                changeHighlightedIndex({
                  diff: 'reset'
                });
              } else {
                setHighlightedIndex({
                  index: itemIndex
                });
              }
              return;
            }

            // Prevent the highlighted index to leak outside the boundaries.
            if (highlightedIndexRef.current >= filteredOptions.length - 1) {
              setHighlightedIndex({
                index: filteredOptions.length - 1
              });
              return;
            }

            // Restore the focus to the previous index.
            setHighlightedIndex({
              index: highlightedIndexRef.current
            });
            // Ignore filteredOptions (and options, isOptionEqualToValue, getOptionLabel) not to break the scroll position
            // eslint-disable-next-line react-hooks/exhaustive-deps
          }, [
          // Only sync the highlighted index when the option switch between empty and not
          filteredOptions.length,
          // Don't sync the highlighted index with the value when multiple
          // eslint-disable-next-line react-hooks/exhaustive-deps
          multiple ? false : value, filterSelectedOptions, changeHighlightedIndex, setHighlightedIndex, popupOpen, inputValue, multiple]);
          const handleListboxRef = useEventCallback(node => {
            setRef(listboxRef, node);
            if (!node) {
              return;
            }
            syncHighlightedIndex();
          });
          reactExports.useEffect(() => {
            syncHighlightedIndex();
          }, [syncHighlightedIndex]);
          const handleOpen = event => {
            if (open) {
              return;
            }
            setOpenState(true);
            setInputPristine(true);
            if (onOpen) {
              onOpen(event);
            }
          };
          const handleClose = (event, reason) => {
            if (!open) {
              return;
            }
            setOpenState(false);
            if (onClose) {
              onClose(event, reason);
            }
          };
          const handleValue = (event, newValue, reason, details) => {
            if (multiple) {
              if (value.length === newValue.length && value.every((val, i) => val === newValue[i])) {
                return;
              }
            } else if (value === newValue) {
              return;
            }
            if (onChange) {
              onChange(event, newValue, reason, details);
            }
            setValueState(newValue);
          };
          const isTouch = reactExports.useRef(false);
          const selectNewValue = (event, option, reasonProp = 'selectOption', origin = 'options') => {
            let reason = reasonProp;
            let newValue = option;
            if (multiple) {
              newValue = Array.isArray(value) ? value.slice() : [];
              const itemIndex = findIndex(newValue, valueItem => isOptionEqualToValue(option, valueItem));
              if (itemIndex === -1) {
                newValue.push(option);
              } else if (origin !== 'freeSolo') {
                newValue.splice(itemIndex, 1);
                reason = 'removeOption';
              }
            }
            resetInputValue(event, newValue);
            handleValue(event, newValue, reason, {
              option
            });
            if (!disableCloseOnSelect && (!event || !event.ctrlKey && !event.metaKey)) {
              handleClose(event, reason);
            }
            if (blurOnSelect === true || blurOnSelect === 'touch' && isTouch.current || blurOnSelect === 'mouse' && !isTouch.current) {
              inputRef.current.blur();
            }
          };
          function validTagIndex(index, direction) {
            if (index === -1) {
              return -1;
            }
            let nextFocus = index;
            while (true) {
              // Out of range
              if (direction === 'next' && nextFocus === value.length || direction === 'previous' && nextFocus === -1) {
                return -1;
              }
              const option = anchorEl.querySelector(`[data-tag-index="${nextFocus}"]`);

              // Same logic as MenuList.js
              if (!option || !option.hasAttribute('tabindex') || option.disabled || option.getAttribute('aria-disabled') === 'true') {
                nextFocus += direction === 'next' ? 1 : -1;
              } else {
                return nextFocus;
              }
            }
          }
          const handleFocusTag = (event, direction) => {
            if (!multiple) {
              return;
            }
            if (inputValue === '') {
              handleClose(event, 'toggleInput');
            }
            let nextTag = focusedTag;
            if (focusedTag === -1) {
              if (inputValue === '' && direction === 'previous') {
                nextTag = value.length - 1;
              }
            } else {
              nextTag += direction === 'next' ? 1 : -1;
              if (nextTag < 0) {
                nextTag = 0;
              }
              if (nextTag === value.length) {
                nextTag = -1;
              }
            }
            nextTag = validTagIndex(nextTag, direction);
            setFocusedTag(nextTag);
            focusTag(nextTag);
          };
          const handleClear = event => {
            ignoreFocus.current = true;
            setInputValueState('');
            if (onInputChange) {
              onInputChange(event, '', 'clear');
            }
            handleValue(event, multiple ? [] : null, 'clear');
          };
          const handleKeyDown = other => event => {
            if (other.onKeyDown) {
              other.onKeyDown(event);
            }
            if (event.defaultMuiPrevented) {
              return;
            }
            if (focusedTag !== -1 && ['ArrowLeft', 'ArrowRight'].indexOf(event.key) === -1) {
              setFocusedTag(-1);
              focusTag(-1);
            }

            // Wait until IME is settled.
            if (event.which !== 229) {
              switch (event.key) {
                case 'Home':
                  if (popupOpen && handleHomeEndKeys) {
                    // Prevent scroll of the page
                    event.preventDefault();
                    changeHighlightedIndex({
                      diff: 'start',
                      direction: 'next',
                      reason: 'keyboard',
                      event
                    });
                  }
                  break;
                case 'End':
                  if (popupOpen && handleHomeEndKeys) {
                    // Prevent scroll of the page
                    event.preventDefault();
                    changeHighlightedIndex({
                      diff: 'end',
                      direction: 'previous',
                      reason: 'keyboard',
                      event
                    });
                  }
                  break;
                case 'PageUp':
                  // Prevent scroll of the page
                  event.preventDefault();
                  changeHighlightedIndex({
                    diff: -pageSize,
                    direction: 'previous',
                    reason: 'keyboard',
                    event
                  });
                  handleOpen(event);
                  break;
                case 'PageDown':
                  // Prevent scroll of the page
                  event.preventDefault();
                  changeHighlightedIndex({
                    diff: pageSize,
                    direction: 'next',
                    reason: 'keyboard',
                    event
                  });
                  handleOpen(event);
                  break;
                case 'ArrowDown':
                  // Prevent cursor move
                  event.preventDefault();
                  changeHighlightedIndex({
                    diff: 1,
                    direction: 'next',
                    reason: 'keyboard',
                    event
                  });
                  handleOpen(event);
                  break;
                case 'ArrowUp':
                  // Prevent cursor move
                  event.preventDefault();
                  changeHighlightedIndex({
                    diff: -1,
                    direction: 'previous',
                    reason: 'keyboard',
                    event
                  });
                  handleOpen(event);
                  break;
                case 'ArrowLeft':
                  handleFocusTag(event, 'previous');
                  break;
                case 'ArrowRight':
                  handleFocusTag(event, 'next');
                  break;
                case 'Enter':
                  if (highlightedIndexRef.current !== -1 && popupOpen) {
                    const option = filteredOptions[highlightedIndexRef.current];
                    const disabled = getOptionDisabled ? getOptionDisabled(option) : false;

                    // Avoid early form validation, let the end-users continue filling the form.
                    event.preventDefault();
                    if (disabled) {
                      return;
                    }
                    selectNewValue(event, option, 'selectOption');

                    // Move the selection to the end.
                    if (autoComplete) {
                      inputRef.current.setSelectionRange(inputRef.current.value.length, inputRef.current.value.length);
                    }
                  } else if (freeSolo && inputValue !== '' && inputValueIsSelectedValue === false) {
                    if (multiple) {
                      // Allow people to add new values before they submit the form.
                      event.preventDefault();
                    }
                    selectNewValue(event, inputValue, 'createOption', 'freeSolo');
                  }
                  break;
                case 'Escape':
                  if (popupOpen) {
                    // Avoid Opera to exit fullscreen mode.
                    event.preventDefault();
                    // Avoid the Modal to handle the event.
                    event.stopPropagation();
                    handleClose(event, 'escape');
                  } else if (clearOnEscape && (inputValue !== '' || multiple && value.length > 0)) {
                    // Avoid Opera to exit fullscreen mode.
                    event.preventDefault();
                    // Avoid the Modal to handle the event.
                    event.stopPropagation();
                    handleClear(event);
                  }
                  break;
                case 'Backspace':
                  if (multiple && !readOnly && inputValue === '' && value.length > 0) {
                    const index = focusedTag === -1 ? value.length - 1 : focusedTag;
                    const newValue = value.slice();
                    newValue.splice(index, 1);
                    handleValue(event, newValue, 'removeOption', {
                      option: value[index]
                    });
                  }
                  break;
                case 'Delete':
                  if (multiple && !readOnly && inputValue === '' && value.length > 0 && focusedTag !== -1) {
                    const index = focusedTag;
                    const newValue = value.slice();
                    newValue.splice(index, 1);
                    handleValue(event, newValue, 'removeOption', {
                      option: value[index]
                    });
                  }
                  break;
              }
            }
          };
          const handleFocus = event => {
            setFocused(true);
            if (openOnFocus && !ignoreFocus.current) {
              handleOpen(event);
            }
          };
          const handleBlur = event => {
            // Ignore the event when using the scrollbar with IE11
            if (unstable_isActiveElementInListbox(listboxRef)) {
              inputRef.current.focus();
              return;
            }
            setFocused(false);
            firstFocus.current = true;
            ignoreFocus.current = false;
            if (autoSelect && highlightedIndexRef.current !== -1 && popupOpen) {
              selectNewValue(event, filteredOptions[highlightedIndexRef.current], 'blur');
            } else if (autoSelect && freeSolo && inputValue !== '') {
              selectNewValue(event, inputValue, 'blur', 'freeSolo');
            } else if (clearOnBlur) {
              resetInputValue(event, value);
            }
            handleClose(event, 'blur');
          };
          const handleInputChange = event => {
            const newValue = event.target.value;
            if (inputValue !== newValue) {
              setInputValueState(newValue);
              setInputPristine(false);
              if (onInputChange) {
                onInputChange(event, newValue, 'input');
              }
            }
            if (newValue === '') {
              if (!disableClearable && !multiple) {
                handleValue(event, null, 'clear');
              }
            } else {
              handleOpen(event);
            }
          };
          const handleOptionMouseMove = event => {
            const index = Number(event.currentTarget.getAttribute('data-option-index'));
            if (highlightedIndexRef.current !== index) {
              setHighlightedIndex({
                event,
                index,
                reason: 'mouse'
              });
            }
          };
          const handleOptionTouchStart = event => {
            setHighlightedIndex({
              event,
              index: Number(event.currentTarget.getAttribute('data-option-index')),
              reason: 'touch'
            });
            isTouch.current = true;
          };
          const handleOptionClick = event => {
            const index = Number(event.currentTarget.getAttribute('data-option-index'));
            selectNewValue(event, filteredOptions[index], 'selectOption');
            isTouch.current = false;
          };
          const handleTagDelete = index => event => {
            const newValue = value.slice();
            newValue.splice(index, 1);
            handleValue(event, newValue, 'removeOption', {
              option: value[index]
            });
          };
          const handlePopupIndicator = event => {
            if (open) {
              handleClose(event, 'toggleInput');
            } else {
              handleOpen(event);
            }
          };

          // Prevent input blur when interacting with the combobox
          const handleMouseDown = event => {
            if (event.target.getAttribute('id') !== id) {
              event.preventDefault();
            }
          };

          // Focus the input when interacting with the combobox
          const handleClick = () => {
            inputRef.current.focus();
            if (selectOnFocus && firstFocus.current && inputRef.current.selectionEnd - inputRef.current.selectionStart === 0) {
              inputRef.current.select();
            }
            firstFocus.current = false;
          };
          const handleInputMouseDown = event => {
            if (inputValue === '' || !open) {
              handlePopupIndicator(event);
            }
          };
          let dirty = freeSolo && inputValue.length > 0;
          dirty = dirty || (multiple ? value.length > 0 : value !== null);
          let groupedOptions = filteredOptions;
          if (groupBy) {
            // used to keep track of key and indexes in the result array
            new Map();
            groupedOptions = filteredOptions.reduce((acc, option, index) => {
              const group = groupBy(option);
              if (acc.length > 0 && acc[acc.length - 1].group === group) {
                acc[acc.length - 1].options.push(option);
              } else {
                acc.push({
                  key: index,
                  index,
                  group,
                  options: [option]
                });
              }
              return acc;
            }, []);
          }
          if (disabledProp && focused) {
            handleBlur();
          }
          return {
            getRootProps: (other = {}) => _extends$h({
              'aria-owns': listboxAvailable ? `${id}-listbox` : null
            }, other, {
              onKeyDown: handleKeyDown(other),
              onMouseDown: handleMouseDown,
              onClick: handleClick
            }),
            getInputLabelProps: () => ({
              id: `${id}-label`,
              htmlFor: id
            }),
            getInputProps: () => ({
              id,
              value: inputValue,
              onBlur: handleBlur,
              onFocus: handleFocus,
              onChange: handleInputChange,
              onMouseDown: handleInputMouseDown,
              // if open then this is handled imperatively so don't let react override
              // only have an opinion about this when closed
              'aria-activedescendant': popupOpen ? '' : null,
              'aria-autocomplete': autoComplete ? 'both' : 'list',
              'aria-controls': listboxAvailable ? `${id}-listbox` : undefined,
              'aria-expanded': listboxAvailable,
              // Disable browser's suggestion that might overlap with the popup.
              // Handle autocomplete but not autofill.
              autoComplete: 'off',
              ref: inputRef,
              autoCapitalize: 'none',
              spellCheck: 'false',
              role: 'combobox',
              disabled: disabledProp
            }),
            getClearProps: () => ({
              tabIndex: -1,
              onClick: handleClear
            }),
            getPopupIndicatorProps: () => ({
              tabIndex: -1,
              onClick: handlePopupIndicator
            }),
            getTagProps: ({
              index
            }) => _extends$h({
              key: index,
              'data-tag-index': index,
              tabIndex: -1
            }, !readOnly && {
              onDelete: handleTagDelete(index)
            }),
            getListboxProps: () => ({
              role: 'listbox',
              id: `${id}-listbox`,
              'aria-labelledby': `${id}-label`,
              ref: handleListboxRef,
              onMouseDown: event => {
                // Prevent blur
                event.preventDefault();
              }
            }),
            getOptionProps: ({
              index,
              option
            }) => {
              const selected = (multiple ? value : [value]).some(value2 => value2 != null && isOptionEqualToValue(option, value2));
              const disabled = getOptionDisabled ? getOptionDisabled(option) : false;
              return {
                key: getOptionLabel(option),
                tabIndex: -1,
                role: 'option',
                id: `${id}-option-${index}`,
                onMouseMove: handleOptionMouseMove,
                onClick: handleOptionClick,
                onTouchStart: handleOptionTouchStart,
                'data-option-index': index,
                'aria-disabled': disabled,
                'aria-selected': selected
              };
            },
            id,
            inputValue,
            value,
            dirty,
            expanded: popupOpen && anchorEl,
            popupOpen,
            focused: focused || focusedTag !== -1,
            anchorEl,
            setAnchorEl,
            focusedTag,
            groupedOptions
          };
        }
        function getListSubheaderUtilityClass(slot) {
          return generateUtilityClass('MuiListSubheader', slot);
        }
        generateUtilityClasses('MuiListSubheader', ['root', 'colorPrimary', 'colorInherit', 'gutters', 'inset', 'sticky']);
        const _excluded$j = ["className", "color", "component", "disableGutters", "disableSticky", "inset"];
        const useUtilityClasses$7 = ownerState => {
          const {
            classes,
            color,
            disableGutters,
            inset,
            disableSticky
          } = ownerState;
          const slots = {
            root: ['root', color !== 'default' && `color${capitalize(color)}`, !disableGutters && 'gutters', inset && 'inset', !disableSticky && 'sticky']
          };
          return composeClasses(slots, getListSubheaderUtilityClass, classes);
        };
        const ListSubheaderRoot = styled('li', {
          name: 'MuiListSubheader',
          slot: 'Root',
          overridesResolver: (props, styles) => {
            const {
              ownerState
            } = props;
            return [styles.root, ownerState.color !== 'default' && styles[`color${capitalize(ownerState.color)}`], !ownerState.disableGutters && styles.gutters, ownerState.inset && styles.inset, !ownerState.disableSticky && styles.sticky];
          }
        })(({
          theme,
          ownerState
        }) => _extends$h({
          boxSizing: 'border-box',
          lineHeight: '48px',
          listStyle: 'none',
          color: (theme.vars || theme).palette.text.secondary,
          fontFamily: theme.typography.fontFamily,
          fontWeight: theme.typography.fontWeightMedium,
          fontSize: theme.typography.pxToRem(14)
        }, ownerState.color === 'primary' && {
          color: (theme.vars || theme).palette.primary.main
        }, ownerState.color === 'inherit' && {
          color: 'inherit'
        }, !ownerState.disableGutters && {
          paddingLeft: 16,
          paddingRight: 16
        }, ownerState.inset && {
          paddingLeft: 72
        }, !ownerState.disableSticky && {
          position: 'sticky',
          top: 0,
          zIndex: 1,
          backgroundColor: (theme.vars || theme).palette.background.paper
        }));
        const ListSubheader = /*#__PURE__*/reactExports.forwardRef(function ListSubheader(inProps, ref) {
          const props = useThemeProps({
            props: inProps,
            name: 'MuiListSubheader'
          });
          const {
              className,
              color = 'default',
              component = 'li',
              disableGutters = false,
              disableSticky = false,
              inset = false
            } = props,
            other = _objectWithoutPropertiesLoose(props, _excluded$j);
          const ownerState = _extends$h({}, props, {
            color,
            component,
            disableGutters,
            disableSticky,
            inset
          });
          const classes = useUtilityClasses$7(ownerState);
          return /*#__PURE__*/jsxRuntimeExports.jsx(ListSubheaderRoot, _extends$h({
            as: component,
            className: clsx(classes.root, className),
            ref: ref,
            ownerState: ownerState
          }, other));
        });
        ListSubheader.muiSkipListHighlight = true;
        const ListSubheader$1 = ListSubheader;
        const CancelIcon = createSvgIcon( /*#__PURE__*/jsxRuntimeExports.jsx("path", {
          d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"
        }), 'Cancel');
        function getChipUtilityClass(slot) {
          return generateUtilityClass('MuiChip', slot);
        }
        const chipClasses = generateUtilityClasses('MuiChip', ['root', 'sizeSmall', 'sizeMedium', 'colorError', 'colorInfo', 'colorPrimary', 'colorSecondary', 'colorSuccess', 'colorWarning', 'disabled', 'clickable', 'clickableColorPrimary', 'clickableColorSecondary', 'deletable', 'deletableColorPrimary', 'deletableColorSecondary', 'outlined', 'filled', 'outlinedPrimary', 'outlinedSecondary', 'filledPrimary', 'filledSecondary', 'avatar', 'avatarSmall', 'avatarMedium', 'avatarColorPrimary', 'avatarColorSecondary', 'icon', 'iconSmall', 'iconMedium', 'iconColorPrimary', 'iconColorSecondary', 'label', 'labelSmall', 'labelMedium', 'deleteIcon', 'deleteIconSmall', 'deleteIconMedium', 'deleteIconColorPrimary', 'deleteIconColorSecondary', 'deleteIconOutlinedColorPrimary', 'deleteIconOutlinedColorSecondary', 'deleteIconFilledColorPrimary', 'deleteIconFilledColorSecondary', 'focusVisible']);
        const chipClasses$1 = chipClasses;
        const _excluded$i = ["avatar", "className", "clickable", "color", "component", "deleteIcon", "disabled", "icon", "label", "onClick", "onDelete", "onKeyDown", "onKeyUp", "size", "variant", "tabIndex", "skipFocusWhenDisabled"];
        const useUtilityClasses$6 = ownerState => {
          const {
            classes,
            disabled,
            size,
            color,
            iconColor,
            onDelete,
            clickable,
            variant
          } = ownerState;
          const slots = {
            root: ['root', variant, disabled && 'disabled', `size${capitalize(size)}`, `color${capitalize(color)}`, clickable && 'clickable', clickable && `clickableColor${capitalize(color)}`, onDelete && 'deletable', onDelete && `deletableColor${capitalize(color)}`, `${variant}${capitalize(color)}`],
            label: ['label', `label${capitalize(size)}`],
            avatar: ['avatar', `avatar${capitalize(size)}`, `avatarColor${capitalize(color)}`],
            icon: ['icon', `icon${capitalize(size)}`, `iconColor${capitalize(iconColor)}`],
            deleteIcon: ['deleteIcon', `deleteIcon${capitalize(size)}`, `deleteIconColor${capitalize(color)}`, `deleteIcon${capitalize(variant)}Color${capitalize(color)}`]
          };
          return composeClasses(slots, getChipUtilityClass, classes);
        };
        const ChipRoot = styled('div', {
          name: 'MuiChip',
          slot: 'Root',
          overridesResolver: (props, styles) => {
            const {
              ownerState
            } = props;
            const {
              color,
              iconColor,
              clickable,
              onDelete,
              size,
              variant
            } = ownerState;
            return [{
              [`& .${chipClasses$1.avatar}`]: styles.avatar
            }, {
              [`& .${chipClasses$1.avatar}`]: styles[`avatar${capitalize(size)}`]
            }, {
              [`& .${chipClasses$1.avatar}`]: styles[`avatarColor${capitalize(color)}`]
            }, {
              [`& .${chipClasses$1.icon}`]: styles.icon
            }, {
              [`& .${chipClasses$1.icon}`]: styles[`icon${capitalize(size)}`]
            }, {
              [`& .${chipClasses$1.icon}`]: styles[`iconColor${capitalize(iconColor)}`]
            }, {
              [`& .${chipClasses$1.deleteIcon}`]: styles.deleteIcon
            }, {
              [`& .${chipClasses$1.deleteIcon}`]: styles[`deleteIcon${capitalize(size)}`]
            }, {
              [`& .${chipClasses$1.deleteIcon}`]: styles[`deleteIconColor${capitalize(color)}`]
            }, {
              [`& .${chipClasses$1.deleteIcon}`]: styles[`deleteIcon${capitalize(variant)}Color${capitalize(color)}`]
            }, styles.root, styles[`size${capitalize(size)}`], styles[`color${capitalize(color)}`], clickable && styles.clickable, clickable && color !== 'default' && styles[`clickableColor${capitalize(color)})`], onDelete && styles.deletable, onDelete && color !== 'default' && styles[`deletableColor${capitalize(color)}`], styles[variant], styles[`${variant}${capitalize(color)}`]];
          }
        })(({
          theme,
          ownerState
        }) => {
          const textColor = theme.palette.mode === 'light' ? theme.palette.grey[700] : theme.palette.grey[300];
          return _extends$h({
            maxWidth: '100%',
            fontFamily: theme.typography.fontFamily,
            fontSize: theme.typography.pxToRem(13),
            display: 'inline-flex',
            alignItems: 'center',
            justifyContent: 'center',
            height: 32,
            color: (theme.vars || theme).palette.text.primary,
            backgroundColor: (theme.vars || theme).palette.action.selected,
            borderRadius: 32 / 2,
            whiteSpace: 'nowrap',
            transition: theme.transitions.create(['background-color', 'box-shadow']),
            // label will inherit this from root, then `clickable` class overrides this for both
            cursor: 'default',
            // We disable the focus ring for mouse, touch and keyboard users.
            outline: 0,
            textDecoration: 'none',
            border: 0,
            // Remove `button` border
            padding: 0,
            // Remove `button` padding
            verticalAlign: 'middle',
            boxSizing: 'border-box',
            [`&.${chipClasses$1.disabled}`]: {
              opacity: (theme.vars || theme).palette.action.disabledOpacity,
              pointerEvents: 'none'
            },
            [`& .${chipClasses$1.avatar}`]: {
              marginLeft: 5,
              marginRight: -6,
              width: 24,
              height: 24,
              color: theme.vars ? theme.vars.palette.Chip.defaultAvatarColor : textColor,
              fontSize: theme.typography.pxToRem(12)
            },
            [`& .${chipClasses$1.avatarColorPrimary}`]: {
              color: (theme.vars || theme).palette.primary.contrastText,
              backgroundColor: (theme.vars || theme).palette.primary.dark
            },
            [`& .${chipClasses$1.avatarColorSecondary}`]: {
              color: (theme.vars || theme).palette.secondary.contrastText,
              backgroundColor: (theme.vars || theme).palette.secondary.dark
            },
            [`& .${chipClasses$1.avatarSmall}`]: {
              marginLeft: 4,
              marginRight: -4,
              width: 18,
              height: 18,
              fontSize: theme.typography.pxToRem(10)
            },
            [`& .${chipClasses$1.icon}`]: _extends$h({
              marginLeft: 5,
              marginRight: -6
            }, ownerState.size === 'small' && {
              fontSize: 18,
              marginLeft: 4,
              marginRight: -4
            }, ownerState.iconColor === ownerState.color && _extends$h({
              color: theme.vars ? theme.vars.palette.Chip.defaultIconColor : textColor
            }, ownerState.color !== 'default' && {
              color: 'inherit'
            })),
            [`& .${chipClasses$1.deleteIcon}`]: _extends$h({
              WebkitTapHighlightColor: 'transparent',
              color: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / 0.26)` : alpha(theme.palette.text.primary, 0.26),
              fontSize: 22,
              cursor: 'pointer',
              margin: '0 5px 0 -6px',
              '&:hover': {
                color: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / 0.4)` : alpha(theme.palette.text.primary, 0.4)
              }
            }, ownerState.size === 'small' && {
              fontSize: 16,
              marginRight: 4,
              marginLeft: -4
            }, ownerState.color !== 'default' && {
              color: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].contrastTextChannel} / 0.7)` : alpha(theme.palette[ownerState.color].contrastText, 0.7),
              '&:hover, &:active': {
                color: (theme.vars || theme).palette[ownerState.color].contrastText
              }
            })
          }, ownerState.size === 'small' && {
            height: 24
          }, ownerState.color !== 'default' && {
            backgroundColor: (theme.vars || theme).palette[ownerState.color].main,
            color: (theme.vars || theme).palette[ownerState.color].contrastText
          }, ownerState.onDelete && {
            [`&.${chipClasses$1.focusVisible}`]: {
              backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
            }
          }, ownerState.onDelete && ownerState.color !== 'default' && {
            [`&.${chipClasses$1.focusVisible}`]: {
              backgroundColor: (theme.vars || theme).palette[ownerState.color].dark
            }
          });
        }, ({
          theme,
          ownerState
        }) => _extends$h({}, ownerState.clickable && {
          userSelect: 'none',
          WebkitTapHighlightColor: 'transparent',
          cursor: 'pointer',
          '&:hover': {
            backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity)
          },
          [`&.${chipClasses$1.focusVisible}`]: {
            backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
          },
          '&:active': {
            boxShadow: (theme.vars || theme).shadows[1]
          }
        }, ownerState.clickable && ownerState.color !== 'default' && {
          [`&:hover, &.${chipClasses$1.focusVisible}`]: {
            backgroundColor: (theme.vars || theme).palette[ownerState.color].dark
          }
        }), ({
          theme,
          ownerState
        }) => _extends$h({}, ownerState.variant === 'outlined' && {
          backgroundColor: 'transparent',
          border: theme.vars ? `1px solid ${theme.vars.palette.Chip.defaultBorder}` : `1px solid ${theme.palette.mode === 'light' ? theme.palette.grey[400] : theme.palette.grey[700]}`,
          [`&.${chipClasses$1.clickable}:hover`]: {
            backgroundColor: (theme.vars || theme).palette.action.hover
          },
          [`&.${chipClasses$1.focusVisible}`]: {
            backgroundColor: (theme.vars || theme).palette.action.focus
          },
          [`& .${chipClasses$1.avatar}`]: {
            marginLeft: 4
          },
          [`& .${chipClasses$1.avatarSmall}`]: {
            marginLeft: 2
          },
          [`& .${chipClasses$1.icon}`]: {
            marginLeft: 4
          },
          [`& .${chipClasses$1.iconSmall}`]: {
            marginLeft: 2
          },
          [`& .${chipClasses$1.deleteIcon}`]: {
            marginRight: 5
          },
          [`& .${chipClasses$1.deleteIconSmall}`]: {
            marginRight: 3
          }
        }, ownerState.variant === 'outlined' && ownerState.color !== 'default' && {
          color: (theme.vars || theme).palette[ownerState.color].main,
          border: `1px solid ${theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.7)` : alpha(theme.palette[ownerState.color].main, 0.7)}`,
          [`&.${chipClasses$1.clickable}:hover`]: {
            backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity)
          },
          [`&.${chipClasses$1.focusVisible}`]: {
            backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette[ownerState.color].main, theme.palette.action.focusOpacity)
          },
          [`& .${chipClasses$1.deleteIcon}`]: {
            color: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.7)` : alpha(theme.palette[ownerState.color].main, 0.7),
            '&:hover, &:active': {
              color: (theme.vars || theme).palette[ownerState.color].main
            }
          }
        }));
        const ChipLabel = styled('span', {
          name: 'MuiChip',
          slot: 'Label',
          overridesResolver: (props, styles) => {
            const {
              ownerState
            } = props;
            const {
              size
            } = ownerState;
            return [styles.label, styles[`label${capitalize(size)}`]];
          }
        })(({
          ownerState
        }) => _extends$h({
          overflow: 'hidden',
          textOverflow: 'ellipsis',
          paddingLeft: 12,
          paddingRight: 12,
          whiteSpace: 'nowrap'
        }, ownerState.size === 'small' && {
          paddingLeft: 8,
          paddingRight: 8
        }));
        function isDeleteKeyboardEvent(keyboardEvent) {
          return keyboardEvent.key === 'Backspace' || keyboardEvent.key === 'Delete';
        }

        /**
         * Chips represent complex entities in small blocks, such as a contact.
         */
        const Chip = /*#__PURE__*/reactExports.forwardRef(function Chip(inProps, ref) {
          const props = useThemeProps({
            props: inProps,
            name: 'MuiChip'
          });
          const {
              avatar: avatarProp,
              className,
              clickable: clickableProp,
              color = 'default',
              component: ComponentProp,
              deleteIcon: deleteIconProp,
              disabled = false,
              icon: iconProp,
              label,
              onClick,
              onDelete,
              onKeyDown,
              onKeyUp,
              size = 'medium',
              variant = 'filled',
              tabIndex,
              skipFocusWhenDisabled = false
            } = props,
            other = _objectWithoutPropertiesLoose(props, _excluded$i);
          const chipRef = reactExports.useRef(null);
          const handleRef = useForkRef(chipRef, ref);
          const handleDeleteIconClick = event => {
            // Stop the event from bubbling up to the `Chip`
            event.stopPropagation();
            if (onDelete) {
              onDelete(event);
            }
          };
          const handleKeyDown = event => {
            // Ignore events from children of `Chip`.
            if (event.currentTarget === event.target && isDeleteKeyboardEvent(event)) {
              // Will be handled in keyUp, otherwise some browsers
              // might init navigation
              event.preventDefault();
            }
            if (onKeyDown) {
              onKeyDown(event);
            }
          };
          const handleKeyUp = event => {
            // Ignore events from children of `Chip`.
            if (event.currentTarget === event.target) {
              if (onDelete && isDeleteKeyboardEvent(event)) {
                onDelete(event);
              } else if (event.key === 'Escape' && chipRef.current) {
                chipRef.current.blur();
              }
            }
            if (onKeyUp) {
              onKeyUp(event);
            }
          };
          const clickable = clickableProp !== false && onClick ? true : clickableProp;
          const component = clickable || onDelete ? ButtonBase : ComponentProp || 'div';
          const ownerState = _extends$h({}, props, {
            component,
            disabled,
            size,
            color,
            iconColor: /*#__PURE__*/reactExports.isValidElement(iconProp) ? iconProp.props.color || color : color,
            onDelete: !!onDelete,
            clickable,
            variant
          });
          const classes = useUtilityClasses$6(ownerState);
          const moreProps = component === ButtonBase ? _extends$h({
            component: ComponentProp || 'div',
            focusVisibleClassName: classes.focusVisible
          }, onDelete && {
            disableRipple: true
          }) : {};
          let deleteIcon = null;
          if (onDelete) {
            deleteIcon = deleteIconProp && /*#__PURE__*/reactExports.isValidElement(deleteIconProp) ? /*#__PURE__*/reactExports.cloneElement(deleteIconProp, {
              className: clsx(deleteIconProp.props.className, classes.deleteIcon),
              onClick: handleDeleteIconClick
            }) : /*#__PURE__*/jsxRuntimeExports.jsx(CancelIcon, {
              className: clsx(classes.deleteIcon),
              onClick: handleDeleteIconClick
            });
          }
          let avatar = null;
          if (avatarProp && /*#__PURE__*/reactExports.isValidElement(avatarProp)) {
            avatar = /*#__PURE__*/reactExports.cloneElement(avatarProp, {
              className: clsx(classes.avatar, avatarProp.props.className)
            });
          }
          let icon = null;
          if (iconProp && /*#__PURE__*/reactExports.isValidElement(iconProp)) {
            icon = /*#__PURE__*/reactExports.cloneElement(iconProp, {
              className: clsx(classes.icon, iconProp.props.className)
            });
          }
          return /*#__PURE__*/jsxRuntimeExports.jsxs(ChipRoot, _extends$h({
            as: component,
            className: clsx(classes.root, className),
            disabled: clickable && disabled ? true : undefined,
            onClick: onClick,
            onKeyDown: handleKeyDown,
            onKeyUp: handleKeyUp,
            ref: handleRef,
            tabIndex: skipFocusWhenDisabled && disabled ? -1 : tabIndex,
            ownerState: ownerState
          }, moreProps, other, {
            children: [avatar || icon, /*#__PURE__*/jsxRuntimeExports.jsx(ChipLabel, {
              className: clsx(classes.label),
              ownerState: ownerState,
              children: label
            }), deleteIcon]
          }));
        });
        const Chip$1 = Chip;
        function getAutocompleteUtilityClass(slot) {
          return generateUtilityClass('MuiAutocomplete', slot);
        }
        const autocompleteClasses = generateUtilityClasses('MuiAutocomplete', ['root', 'expanded', 'fullWidth', 'focused', 'focusVisible', 'tag', 'tagSizeSmall', 'tagSizeMedium', 'hasPopupIcon', 'hasClearIcon', 'inputRoot', 'input', 'inputFocused', 'endAdornment', 'clearIndicator', 'popupIndicator', 'popupIndicatorOpen', 'popper', 'popperDisablePortal', 'paper', 'listbox', 'loading', 'noOptions', 'option', 'groupLabel', 'groupUl']);
        const autocompleteClasses$1 = autocompleteClasses;
        var _ClearIcon, _ArrowDropDownIcon;
        const _excluded$h = ["autoComplete", "autoHighlight", "autoSelect", "blurOnSelect", "ChipProps", "className", "clearIcon", "clearOnBlur", "clearOnEscape", "clearText", "closeText", "componentsProps", "defaultValue", "disableClearable", "disableCloseOnSelect", "disabled", "disabledItemsFocusable", "disableListWrap", "disablePortal", "filterOptions", "filterSelectedOptions", "forcePopupIcon", "freeSolo", "fullWidth", "getLimitTagsText", "getOptionDisabled", "getOptionLabel", "isOptionEqualToValue", "groupBy", "handleHomeEndKeys", "id", "includeInputInList", "inputValue", "limitTags", "ListboxComponent", "ListboxProps", "loading", "loadingText", "multiple", "noOptionsText", "onChange", "onClose", "onHighlightChange", "onInputChange", "onOpen", "open", "openOnFocus", "openText", "options", "PaperComponent", "PopperComponent", "popupIcon", "readOnly", "renderGroup", "renderInput", "renderOption", "renderTags", "selectOnFocus", "size", "slotProps", "value"];
        const useUtilityClasses$5 = ownerState => {
          const {
            classes,
            disablePortal,
            expanded,
            focused,
            fullWidth,
            hasClearIcon,
            hasPopupIcon,
            inputFocused,
            popupOpen,
            size
          } = ownerState;
          const slots = {
            root: ['root', expanded && 'expanded', focused && 'focused', fullWidth && 'fullWidth', hasClearIcon && 'hasClearIcon', hasPopupIcon && 'hasPopupIcon'],
            inputRoot: ['inputRoot'],
            input: ['input', inputFocused && 'inputFocused'],
            tag: ['tag', `tagSize${capitalize(size)}`],
            endAdornment: ['endAdornment'],
            clearIndicator: ['clearIndicator'],
            popupIndicator: ['popupIndicator', popupOpen && 'popupIndicatorOpen'],
            popper: ['popper', disablePortal && 'popperDisablePortal'],
            paper: ['paper'],
            listbox: ['listbox'],
            loading: ['loading'],
            noOptions: ['noOptions'],
            option: ['option'],
            groupLabel: ['groupLabel'],
            groupUl: ['groupUl']
          };
          return composeClasses(slots, getAutocompleteUtilityClass, classes);
        };
        const AutocompleteRoot = styled('div', {
          name: 'MuiAutocomplete',
          slot: 'Root',
          overridesResolver: (props, styles) => {
            const {
              ownerState
            } = props;
            const {
              fullWidth,
              hasClearIcon,
              hasPopupIcon,
              inputFocused,
              size
            } = ownerState;
            return [{
              [`& .${autocompleteClasses$1.tag}`]: styles.tag
            }, {
              [`& .${autocompleteClasses$1.tag}`]: styles[`tagSize${capitalize(size)}`]
            }, {
              [`& .${autocompleteClasses$1.inputRoot}`]: styles.inputRoot
            }, {
              [`& .${autocompleteClasses$1.input}`]: styles.input
            }, {
              [`& .${autocompleteClasses$1.input}`]: inputFocused && styles.inputFocused
            }, styles.root, fullWidth && styles.fullWidth, hasPopupIcon && styles.hasPopupIcon, hasClearIcon && styles.hasClearIcon];
          }
        })(({
          ownerState
        }) => _extends$h({
          [`&.${autocompleteClasses$1.focused} .${autocompleteClasses$1.clearIndicator}`]: {
            visibility: 'visible'
          },
          /* Avoid double tap issue on iOS */
          '@media (pointer: fine)': {
            [`&:hover .${autocompleteClasses$1.clearIndicator}`]: {
              visibility: 'visible'
            }
          }
        }, ownerState.fullWidth && {
          width: '100%'
        }, {
          [`& .${autocompleteClasses$1.tag}`]: _extends$h({
            margin: 3,
            maxWidth: 'calc(100% - 6px)'
          }, ownerState.size === 'small' && {
            margin: 2,
            maxWidth: 'calc(100% - 4px)'
          }),
          [`& .${autocompleteClasses$1.inputRoot}`]: {
            flexWrap: 'wrap',
            [`.${autocompleteClasses$1.hasPopupIcon}&, .${autocompleteClasses$1.hasClearIcon}&`]: {
              paddingRight: 26 + 4
            },
            [`.${autocompleteClasses$1.hasPopupIcon}.${autocompleteClasses$1.hasClearIcon}&`]: {
              paddingRight: 52 + 4
            },
            [`& .${autocompleteClasses$1.input}`]: {
              width: 0,
              minWidth: 30
            }
          },
          [`& .${inputClasses.root}`]: {
            paddingBottom: 1,
            '& .MuiInput-input': {
              padding: '4px 4px 4px 0px'
            }
          },
          [`& .${inputClasses.root}.${inputBaseClasses.sizeSmall}`]: {
            [`& .${inputClasses.input}`]: {
              padding: '2px 4px 3px 0'
            }
          },
          [`& .${outlinedInputClasses.root}`]: {
            padding: 9,
            [`.${autocompleteClasses$1.hasPopupIcon}&, .${autocompleteClasses$1.hasClearIcon}&`]: {
              paddingRight: 26 + 4 + 9
            },
            [`.${autocompleteClasses$1.hasPopupIcon}.${autocompleteClasses$1.hasClearIcon}&`]: {
              paddingRight: 52 + 4 + 9
            },
            [`& .${autocompleteClasses$1.input}`]: {
              padding: '7.5px 4px 7.5px 5px'
            },
            [`& .${autocompleteClasses$1.endAdornment}`]: {
              right: 9
            }
          },
          [`& .${outlinedInputClasses.root}.${inputBaseClasses.sizeSmall}`]: {
            // Don't specify paddingRight, as it overrides the default value set when there is only
            // one of the popup or clear icon as the specificity is equal so the latter one wins
            paddingTop: 6,
            paddingBottom: 6,
            paddingLeft: 6,
            [`& .${autocompleteClasses$1.input}`]: {
              padding: '2.5px 4px 2.5px 8px'
            }
          },
          [`& .${filledInputClasses.root}`]: {
            paddingTop: 19,
            paddingLeft: 8,
            [`.${autocompleteClasses$1.hasPopupIcon}&, .${autocompleteClasses$1.hasClearIcon}&`]: {
              paddingRight: 26 + 4 + 9
            },
            [`.${autocompleteClasses$1.hasPopupIcon}.${autocompleteClasses$1.hasClearIcon}&`]: {
              paddingRight: 52 + 4 + 9
            },
            [`& .${filledInputClasses.input}`]: {
              padding: '7px 4px'
            },
            [`& .${autocompleteClasses$1.endAdornment}`]: {
              right: 9
            }
          },
          [`& .${filledInputClasses.root}.${inputBaseClasses.sizeSmall}`]: {
            paddingBottom: 1,
            [`& .${filledInputClasses.input}`]: {
              padding: '2.5px 4px'
            }
          },
          [`& .${inputBaseClasses.hiddenLabel}`]: {
            paddingTop: 8
          },
          [`& .${filledInputClasses.root}.${inputBaseClasses.hiddenLabel}`]: {
            paddingTop: 0,
            paddingBottom: 0,
            [`& .${autocompleteClasses$1.input}`]: {
              paddingTop: 16,
              paddingBottom: 17
            }
          },
          [`& .${filledInputClasses.root}.${inputBaseClasses.hiddenLabel}.${inputBaseClasses.sizeSmall}`]: {
            [`& .${autocompleteClasses$1.input}`]: {
              paddingTop: 8,
              paddingBottom: 9
            }
          },
          [`& .${autocompleteClasses$1.input}`]: _extends$h({
            flexGrow: 1,
            textOverflow: 'ellipsis',
            opacity: 0
          }, ownerState.inputFocused && {
            opacity: 1
          })
        }));
        const AutocompleteEndAdornment = styled('div', {
          name: 'MuiAutocomplete',
          slot: 'EndAdornment',
          overridesResolver: (props, styles) => styles.endAdornment
        })({
          // We use a position absolute to support wrapping tags.
          position: 'absolute',
          right: 0,
          top: 'calc(50% - 14px)' // Center vertically
        });

        const AutocompleteClearIndicator = styled(IconButton, {
          name: 'MuiAutocomplete',
          slot: 'ClearIndicator',
          overridesResolver: (props, styles) => styles.clearIndicator
        })({
          marginRight: -2,
          padding: 4,
          visibility: 'hidden'
        });
        const AutocompletePopupIndicator = styled(IconButton, {
          name: 'MuiAutocomplete',
          slot: 'PopupIndicator',
          overridesResolver: ({
            ownerState
          }, styles) => _extends$h({}, styles.popupIndicator, ownerState.popupOpen && styles.popupIndicatorOpen)
        })(({
          ownerState
        }) => _extends$h({
          padding: 2,
          marginRight: -2
        }, ownerState.popupOpen && {
          transform: 'rotate(180deg)'
        }));
        const AutocompletePopper = styled(Popper, {
          name: 'MuiAutocomplete',
          slot: 'Popper',
          overridesResolver: (props, styles) => {
            const {
              ownerState
            } = props;
            return [{
              [`& .${autocompleteClasses$1.option}`]: styles.option
            }, styles.popper, ownerState.disablePortal && styles.popperDisablePortal];
          }
        })(({
          theme,
          ownerState
        }) => _extends$h({
          zIndex: (theme.vars || theme).zIndex.modal
        }, ownerState.disablePortal && {
          position: 'absolute'
        }));
        const AutocompletePaper = styled(Paper, {
          name: 'MuiAutocomplete',
          slot: 'Paper',
          overridesResolver: (props, styles) => styles.paper
        })(({
          theme
        }) => _extends$h({}, theme.typography.body1, {
          overflow: 'auto'
        }));
        const AutocompleteLoading = styled('div', {
          name: 'MuiAutocomplete',
          slot: 'Loading',
          overridesResolver: (props, styles) => styles.loading
        })(({
          theme
        }) => ({
          color: (theme.vars || theme).palette.text.secondary,
          padding: '14px 16px'
        }));
        const AutocompleteNoOptions = styled('div', {
          name: 'MuiAutocomplete',
          slot: 'NoOptions',
          overridesResolver: (props, styles) => styles.noOptions
        })(({
          theme
        }) => ({
          color: (theme.vars || theme).palette.text.secondary,
          padding: '14px 16px'
        }));
        const AutocompleteListbox = styled('div', {
          name: 'MuiAutocomplete',
          slot: 'Listbox',
          overridesResolver: (props, styles) => styles.listbox
        })(({
          theme
        }) => ({
          listStyle: 'none',
          margin: 0,
          padding: '8px 0',
          maxHeight: '40vh',
          overflow: 'auto',
          position: 'relative',
          [`& .${autocompleteClasses$1.option}`]: {
            minHeight: 48,
            display: 'flex',
            overflow: 'hidden',
            justifyContent: 'flex-start',
            alignItems: 'center',
            cursor: 'pointer',
            paddingTop: 6,
            boxSizing: 'border-box',
            outline: '0',
            WebkitTapHighlightColor: 'transparent',
            paddingBottom: 6,
            paddingLeft: 16,
            paddingRight: 16,
            [theme.breakpoints.up('sm')]: {
              minHeight: 'auto'
            },
            [`&.${autocompleteClasses$1.focused}`]: {
              backgroundColor: (theme.vars || theme).palette.action.hover,
              // Reset on touch devices, it doesn't add specificity
              '@media (hover: none)': {
                backgroundColor: 'transparent'
              }
            },
            '&[aria-disabled="true"]': {
              opacity: (theme.vars || theme).palette.action.disabledOpacity,
              pointerEvents: 'none'
            },
            [`&.${autocompleteClasses$1.focusVisible}`]: {
              backgroundColor: (theme.vars || theme).palette.action.focus
            },
            '&[aria-selected="true"]': {
              backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
              [`&.${autocompleteClasses$1.focused}`]: {
                backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
                // Reset on touch devices, it doesn't add specificity
                '@media (hover: none)': {
                  backgroundColor: (theme.vars || theme).palette.action.selected
                }
              },
              [`&.${autocompleteClasses$1.focusVisible}`]: {
                backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
              }
            }
          }
        }));
        const AutocompleteGroupLabel = styled(ListSubheader$1, {
          name: 'MuiAutocomplete',
          slot: 'GroupLabel',
          overridesResolver: (props, styles) => styles.groupLabel
        })(({
          theme
        }) => ({
          backgroundColor: (theme.vars || theme).palette.background.paper,
          top: -8
        }));
        const AutocompleteGroupUl = styled('ul', {
          name: 'MuiAutocomplete',
          slot: 'GroupUl',
          overridesResolver: (props, styles) => styles.groupUl
        })({
          padding: 0,
          [`& .${autocompleteClasses$1.option}`]: {
            paddingLeft: 24
          }
        });
        const Autocomplete = /*#__PURE__*/reactExports.forwardRef(function Autocomplete(inProps, ref) {
          var _slotProps$clearIndic, _slotProps$paper, _slotProps$popper, _slotProps$popupIndic;
          const props = useThemeProps({
            props: inProps,
            name: 'MuiAutocomplete'
          });
          /* eslint-disable @typescript-eslint/no-unused-vars */
          const {
              autoComplete = false,
              autoHighlight = false,
              autoSelect = false,
              blurOnSelect = false,
              ChipProps,
              className,
              clearIcon = _ClearIcon || (_ClearIcon = /*#__PURE__*/jsxRuntimeExports.jsx(ClearIcon, {
                fontSize: "small"
              })),
              clearOnBlur = !props.freeSolo,
              clearOnEscape = false,
              clearText = 'Clear',
              closeText = 'Close',
              componentsProps = {},
              defaultValue = props.multiple ? [] : null,
              disableClearable = false,
              disableCloseOnSelect = false,
              disabled = false,
              disabledItemsFocusable = false,
              disableListWrap = false,
              disablePortal = false,
              filterSelectedOptions = false,
              forcePopupIcon = 'auto',
              freeSolo = false,
              fullWidth = false,
              getLimitTagsText = more => `+${more}`,
              getOptionLabel = option => {
                var _option$label;
                return (_option$label = option.label) != null ? _option$label : option;
              },
              groupBy,
              handleHomeEndKeys = !props.freeSolo,
              includeInputInList = false,
              limitTags = -1,
              ListboxComponent = 'ul',
              ListboxProps,
              loading = false,
              loadingText = 'Loading…',
              multiple = false,
              noOptionsText = 'No options',
              openOnFocus = false,
              openText = 'Open',
              PaperComponent = Paper,
              PopperComponent = Popper,
              popupIcon = _ArrowDropDownIcon || (_ArrowDropDownIcon = /*#__PURE__*/jsxRuntimeExports.jsx(ArrowDropDownIcon, {})),
              readOnly = false,
              renderGroup: renderGroupProp,
              renderInput,
              renderOption: renderOptionProp,
              renderTags,
              selectOnFocus = !props.freeSolo,
              size = 'medium',
              slotProps = {}
            } = props,
            other = _objectWithoutPropertiesLoose(props, _excluded$h);
          /* eslint-enable @typescript-eslint/no-unused-vars */

          const {
            getRootProps,
            getInputProps,
            getInputLabelProps,
            getPopupIndicatorProps,
            getClearProps,
            getTagProps,
            getListboxProps,
            getOptionProps,
            value,
            dirty,
            expanded,
            id,
            popupOpen,
            focused,
            focusedTag,
            anchorEl,
            setAnchorEl,
            inputValue,
            groupedOptions
          } = useAutocomplete(_extends$h({}, props, {
            componentName: 'Autocomplete'
          }));
          const hasClearIcon = !disableClearable && !disabled && dirty && !readOnly;
          const hasPopupIcon = (!freeSolo || forcePopupIcon === true) && forcePopupIcon !== false;
          const {
            onMouseDown: handleInputMouseDown
          } = getInputProps();

          // If you modify this, make sure to keep the `AutocompleteOwnerState` type in sync.
          const ownerState = _extends$h({}, props, {
            disablePortal,
            expanded,
            focused,
            fullWidth,
            hasClearIcon,
            hasPopupIcon,
            inputFocused: focusedTag === -1,
            popupOpen,
            size
          });
          const classes = useUtilityClasses$5(ownerState);
          let startAdornment;
          if (multiple && value.length > 0) {
            const getCustomizedTagProps = params => _extends$h({
              className: classes.tag,
              disabled
            }, getTagProps(params));
            if (renderTags) {
              startAdornment = renderTags(value, getCustomizedTagProps, ownerState);
            } else {
              startAdornment = value.map((option, index) => /*#__PURE__*/jsxRuntimeExports.jsx(Chip$1, _extends$h({
                label: getOptionLabel(option),
                size: size
              }, getCustomizedTagProps({
                index
              }), ChipProps)));
            }
          }
          if (limitTags > -1 && Array.isArray(startAdornment)) {
            const more = startAdornment.length - limitTags;
            if (!focused && more > 0) {
              startAdornment = startAdornment.splice(0, limitTags);
              startAdornment.push( /*#__PURE__*/jsxRuntimeExports.jsx("span", {
                className: classes.tag,
                children: getLimitTagsText(more)
              }, startAdornment.length));
            }
          }
          const defaultRenderGroup = params => /*#__PURE__*/jsxRuntimeExports.jsxs("li", {
            children: [/*#__PURE__*/jsxRuntimeExports.jsx(AutocompleteGroupLabel, {
              className: classes.groupLabel,
              ownerState: ownerState,
              component: "div",
              children: params.group
            }), /*#__PURE__*/jsxRuntimeExports.jsx(AutocompleteGroupUl, {
              className: classes.groupUl,
              ownerState: ownerState,
              children: params.children
            })]
          }, params.key);
          const renderGroup = renderGroupProp || defaultRenderGroup;
          const defaultRenderOption = (props2, option) => /*#__PURE__*/jsxRuntimeExports.jsx("li", _extends$h({}, props2, {
            children: getOptionLabel(option)
          }));
          const renderOption = renderOptionProp || defaultRenderOption;
          const renderListOption = (option, index) => {
            const optionProps = getOptionProps({
              option,
              index
            });
            return renderOption(_extends$h({}, optionProps, {
              className: classes.option
            }), option, {
              selected: optionProps['aria-selected'],
              index,
              inputValue
            });
          };
          const clearIndicatorSlotProps = (_slotProps$clearIndic = slotProps.clearIndicator) != null ? _slotProps$clearIndic : componentsProps.clearIndicator;
          const paperSlotProps = (_slotProps$paper = slotProps.paper) != null ? _slotProps$paper : componentsProps.paper;
          const popperSlotProps = (_slotProps$popper = slotProps.popper) != null ? _slotProps$popper : componentsProps.popper;
          const popupIndicatorSlotProps = (_slotProps$popupIndic = slotProps.popupIndicator) != null ? _slotProps$popupIndic : componentsProps.popupIndicator;
          return /*#__PURE__*/jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [/*#__PURE__*/jsxRuntimeExports.jsx(AutocompleteRoot, _extends$h({
              ref: ref,
              className: clsx(classes.root, className),
              ownerState: ownerState
            }, getRootProps(other), {
              children: renderInput({
                id,
                disabled,
                fullWidth: true,
                size: size === 'small' ? 'small' : undefined,
                InputLabelProps: getInputLabelProps(),
                InputProps: _extends$h({
                  ref: setAnchorEl,
                  className: classes.inputRoot,
                  startAdornment,
                  onClick: event => {
                    if (event.target === event.currentTarget) {
                      handleInputMouseDown(event);
                    }
                  }
                }, (hasClearIcon || hasPopupIcon) && {
                  endAdornment: /*#__PURE__*/jsxRuntimeExports.jsxs(AutocompleteEndAdornment, {
                    className: classes.endAdornment,
                    ownerState: ownerState,
                    children: [hasClearIcon ? /*#__PURE__*/jsxRuntimeExports.jsx(AutocompleteClearIndicator, _extends$h({}, getClearProps(), {
                      "aria-label": clearText,
                      title: clearText,
                      ownerState: ownerState
                    }, clearIndicatorSlotProps, {
                      className: clsx(classes.clearIndicator, clearIndicatorSlotProps == null ? void 0 : clearIndicatorSlotProps.className),
                      children: clearIcon
                    })) : null, hasPopupIcon ? /*#__PURE__*/jsxRuntimeExports.jsx(AutocompletePopupIndicator, _extends$h({}, getPopupIndicatorProps(), {
                      disabled: disabled,
                      "aria-label": popupOpen ? closeText : openText,
                      title: popupOpen ? closeText : openText,
                      ownerState: ownerState
                    }, popupIndicatorSlotProps, {
                      className: clsx(classes.popupIndicator, popupIndicatorSlotProps == null ? void 0 : popupIndicatorSlotProps.className),
                      children: popupIcon
                    })) : null]
                  })
                }),
                inputProps: _extends$h({
                  className: classes.input,
                  disabled,
                  readOnly
                }, getInputProps())
              })
            })), anchorEl ? /*#__PURE__*/jsxRuntimeExports.jsx(AutocompletePopper, _extends$h({
              as: PopperComponent,
              disablePortal: disablePortal,
              style: {
                width: anchorEl ? anchorEl.clientWidth : null
              },
              ownerState: ownerState,
              role: "presentation",
              anchorEl: anchorEl,
              open: popupOpen
            }, popperSlotProps, {
              className: clsx(classes.popper, popperSlotProps == null ? void 0 : popperSlotProps.className),
              children: /*#__PURE__*/jsxRuntimeExports.jsxs(AutocompletePaper, _extends$h({
                ownerState: ownerState,
                as: PaperComponent
              }, paperSlotProps, {
                className: clsx(classes.paper, paperSlotProps == null ? void 0 : paperSlotProps.className),
                children: [loading && groupedOptions.length === 0 ? /*#__PURE__*/jsxRuntimeExports.jsx(AutocompleteLoading, {
                  className: classes.loading,
                  ownerState: ownerState,
                  children: loadingText
                }) : null, groupedOptions.length === 0 && !freeSolo && !loading ? /*#__PURE__*/jsxRuntimeExports.jsx(AutocompleteNoOptions, {
                  className: classes.noOptions,
                  ownerState: ownerState,
                  role: "presentation",
                  onMouseDown: event => {
                    // Prevent input blur when interacting with the "no options" content
                    event.preventDefault();
                  },
                  children: noOptionsText
                }) : null, groupedOptions.length > 0 ? /*#__PURE__*/jsxRuntimeExports.jsx(AutocompleteListbox, _extends$h({
                  as: ListboxComponent,
                  className: classes.listbox,
                  ownerState: ownerState
                }, getListboxProps(), ListboxProps, {
                  children: groupedOptions.map((option, index) => {
                    if (groupBy) {
                      return renderGroup({
                        key: option.key,
                        group: option.group,
                        children: option.options.map((option2, index2) => renderListOption(option2, option.index + index2))
                      });
                    }
                    return renderListOption(option, index);
                  })
                })) : null]
              }))
            })) : null]
          });
        });
        const Autocomplete$1 = Autocomplete;
        function getButtonGroupUtilityClass(slot) {
          return generateUtilityClass('MuiButtonGroup', slot);
        }
        const buttonGroupClasses = generateUtilityClasses('MuiButtonGroup', ['root', 'contained', 'outlined', 'text', 'disableElevation', 'disabled', 'fullWidth', 'vertical', 'grouped', 'groupedHorizontal', 'groupedVertical', 'groupedText', 'groupedTextHorizontal', 'groupedTextVertical', 'groupedTextPrimary', 'groupedTextSecondary', 'groupedOutlined', 'groupedOutlinedHorizontal', 'groupedOutlinedVertical', 'groupedOutlinedPrimary', 'groupedOutlinedSecondary', 'groupedContained', 'groupedContainedHorizontal', 'groupedContainedVertical', 'groupedContainedPrimary', 'groupedContainedSecondary']);
        const buttonGroupClasses$1 = buttonGroupClasses;
        const _excluded$g = ["children", "className", "color", "component", "disabled", "disableElevation", "disableFocusRipple", "disableRipple", "fullWidth", "orientation", "size", "variant"];
        const overridesResolver = (props, styles) => {
          const {
            ownerState
          } = props;
          return [{
            [`& .${buttonGroupClasses$1.grouped}`]: styles.grouped
          }, {
            [`& .${buttonGroupClasses$1.grouped}`]: styles[`grouped${capitalize(ownerState.orientation)}`]
          }, {
            [`& .${buttonGroupClasses$1.grouped}`]: styles[`grouped${capitalize(ownerState.variant)}`]
          }, {
            [`& .${buttonGroupClasses$1.grouped}`]: styles[`grouped${capitalize(ownerState.variant)}${capitalize(ownerState.orientation)}`]
          }, {
            [`& .${buttonGroupClasses$1.grouped}`]: styles[`grouped${capitalize(ownerState.variant)}${capitalize(ownerState.color)}`]
          }, styles.root, styles[ownerState.variant], ownerState.disableElevation === true && styles.disableElevation, ownerState.fullWidth && styles.fullWidth, ownerState.orientation === 'vertical' && styles.vertical];
        };
        const useUtilityClasses$4 = ownerState => {
          const {
            classes,
            color,
            disabled,
            disableElevation,
            fullWidth,
            orientation,
            variant
          } = ownerState;
          const slots = {
            root: ['root', variant, orientation === 'vertical' && 'vertical', fullWidth && 'fullWidth', disableElevation && 'disableElevation'],
            grouped: ['grouped', `grouped${capitalize(orientation)}`, `grouped${capitalize(variant)}`, `grouped${capitalize(variant)}${capitalize(orientation)}`, `grouped${capitalize(variant)}${capitalize(color)}`, disabled && 'disabled']
          };
          return composeClasses(slots, getButtonGroupUtilityClass, classes);
        };
        const ButtonGroupRoot = styled('div', {
          name: 'MuiButtonGroup',
          slot: 'Root',
          overridesResolver
        })(({
          theme,
          ownerState
        }) => _extends$h({
          display: 'inline-flex',
          borderRadius: (theme.vars || theme).shape.borderRadius
        }, ownerState.variant === 'contained' && {
          boxShadow: (theme.vars || theme).shadows[2]
        }, ownerState.disableElevation && {
          boxShadow: 'none'
        }, ownerState.fullWidth && {
          width: '100%'
        }, ownerState.orientation === 'vertical' && {
          flexDirection: 'column'
        }, {
          [`& .${buttonGroupClasses$1.grouped}`]: _extends$h({
            minWidth: 40,
            '&:not(:first-of-type)': _extends$h({}, ownerState.orientation === 'horizontal' && {
              borderTopLeftRadius: 0,
              borderBottomLeftRadius: 0
            }, ownerState.orientation === 'vertical' && {
              borderTopRightRadius: 0,
              borderTopLeftRadius: 0
            }, ownerState.variant === 'outlined' && ownerState.orientation === 'horizontal' && {
              marginLeft: -1
            }, ownerState.variant === 'outlined' && ownerState.orientation === 'vertical' && {
              marginTop: -1
            }),
            '&:not(:last-of-type)': _extends$h({}, ownerState.orientation === 'horizontal' && {
              borderTopRightRadius: 0,
              borderBottomRightRadius: 0
            }, ownerState.orientation === 'vertical' && {
              borderBottomRightRadius: 0,
              borderBottomLeftRadius: 0
            }, ownerState.variant === 'text' && ownerState.orientation === 'horizontal' && {
              borderRight: theme.vars ? `1px solid rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : `1px solid ${theme.palette.mode === 'light' ? 'rgba(0, 0, 0, 0.23)' : 'rgba(255, 255, 255, 0.23)'}`
            }, ownerState.variant === 'text' && ownerState.orientation === 'vertical' && {
              borderBottom: theme.vars ? `1px solid rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : `1px solid ${theme.palette.mode === 'light' ? 'rgba(0, 0, 0, 0.23)' : 'rgba(255, 255, 255, 0.23)'}`
            }, ownerState.variant === 'text' && ownerState.color !== 'inherit' && {
              borderColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.5)` : alpha(theme.palette[ownerState.color].main, 0.5)
            }, ownerState.variant === 'outlined' && ownerState.orientation === 'horizontal' && {
              borderRightColor: 'transparent'
            }, ownerState.variant === 'outlined' && ownerState.orientation === 'vertical' && {
              borderBottomColor: 'transparent'
            }, ownerState.variant === 'contained' && ownerState.orientation === 'horizontal' && {
              borderRight: `1px solid ${(theme.vars || theme).palette.grey[400]}`,
              [`&.${buttonGroupClasses$1.disabled}`]: {
                borderRight: `1px solid ${(theme.vars || theme).palette.action.disabled}`
              }
            }, ownerState.variant === 'contained' && ownerState.orientation === 'vertical' && {
              borderBottom: `1px solid ${(theme.vars || theme).palette.grey[400]}`,
              [`&.${buttonGroupClasses$1.disabled}`]: {
                borderBottom: `1px solid ${(theme.vars || theme).palette.action.disabled}`
              }
            }, ownerState.variant === 'contained' && ownerState.color !== 'inherit' && {
              borderColor: (theme.vars || theme).palette[ownerState.color].dark
            }, {
              '&:hover': _extends$h({}, ownerState.variant === 'outlined' && ownerState.orientation === 'horizontal' && {
                borderRightColor: 'currentColor'
              }, ownerState.variant === 'outlined' && ownerState.orientation === 'vertical' && {
                borderBottomColor: 'currentColor'
              })
            }),
            '&:hover': _extends$h({}, ownerState.variant === 'contained' && {
              boxShadow: 'none'
            })
          }, ownerState.variant === 'contained' && {
            boxShadow: 'none'
          })
        }));
        const ButtonGroup = /*#__PURE__*/reactExports.forwardRef(function ButtonGroup(inProps, ref) {
          const props = useThemeProps({
            props: inProps,
            name: 'MuiButtonGroup'
          });
          const {
              children,
              className,
              color = 'primary',
              component = 'div',
              disabled = false,
              disableElevation = false,
              disableFocusRipple = false,
              disableRipple = false,
              fullWidth = false,
              orientation = 'horizontal',
              size = 'medium',
              variant = 'outlined'
            } = props,
            other = _objectWithoutPropertiesLoose(props, _excluded$g);
          const ownerState = _extends$h({}, props, {
            color,
            component,
            disabled,
            disableElevation,
            disableFocusRipple,
            disableRipple,
            fullWidth,
            orientation,
            size,
            variant
          });
          const classes = useUtilityClasses$4(ownerState);
          const context = reactExports.useMemo(() => ({
            className: classes.grouped,
            color,
            disabled,
            disableElevation,
            disableFocusRipple,
            disableRipple,
            fullWidth,
            size,
            variant
          }), [color, disabled, disableElevation, disableFocusRipple, disableRipple, fullWidth, size, variant, classes.grouped]);
          return /*#__PURE__*/jsxRuntimeExports.jsx(ButtonGroupRoot, _extends$h({
            as: component,
            role: "group",
            className: clsx(classes.root, className),
            ref: ref,
            ownerState: ownerState
          }, other, {
            children: /*#__PURE__*/jsxRuntimeExports.jsx(ButtonGroupContext.Provider, {
              value: context,
              children: children
            })
          }));
        });
        const ButtonGroup$1 = ButtonGroup;
        function getDialogContentTextUtilityClass(slot) {
          return generateUtilityClass('MuiDialogContentText', slot);
        }
        generateUtilityClasses('MuiDialogContentText', ['root']);
        const _excluded$f = ["children", "className"];
        const useUtilityClasses$3 = ownerState => {
          const {
            classes
          } = ownerState;
          const slots = {
            root: ['root']
          };
          const composedClasses = composeClasses(slots, getDialogContentTextUtilityClass, classes);
          return _extends$h({}, classes, composedClasses);
        };
        const DialogContentTextRoot = styled(Typography, {
          shouldForwardProp: prop => rootShouldForwardProp(prop) || prop === 'classes',
          name: 'MuiDialogContentText',
          slot: 'Root',
          overridesResolver: (props, styles) => styles.root
        })({});
        const DialogContentText = /*#__PURE__*/reactExports.forwardRef(function DialogContentText(inProps, ref) {
          const props = useThemeProps({
            props: inProps,
            name: 'MuiDialogContentText'
          });
          const {
              className
            } = props,
            ownerState = _objectWithoutPropertiesLoose(props, _excluded$f);
          const classes = useUtilityClasses$3(ownerState);
          return /*#__PURE__*/jsxRuntimeExports.jsx(DialogContentTextRoot, _extends$h({
            component: "p",
            variant: "body1",
            color: "text.secondary",
            ref: ref,
            ownerState: ownerState,
            className: clsx(classes.root, className)
          }, props, {
            classes: classes
          }));
        });
        const DialogContentText$1 = DialogContentText;
        const _excluded$e = ["children", "className", "disableTypography", "inset", "primary", "primaryTypographyProps", "secondary", "secondaryTypographyProps"];
        const useUtilityClasses$2 = ownerState => {
          const {
            classes,
            inset,
            primary,
            secondary,
            dense
          } = ownerState;
          const slots = {
            root: ['root', inset && 'inset', dense && 'dense', primary && secondary && 'multiline'],
            primary: ['primary'],
            secondary: ['secondary']
          };
          return composeClasses(slots, getListItemTextUtilityClass, classes);
        };
        const ListItemTextRoot = styled('div', {
          name: 'MuiListItemText',
          slot: 'Root',
          overridesResolver: (props, styles) => {
            const {
              ownerState
            } = props;
            return [{
              [`& .${listItemTextClasses.primary}`]: styles.primary
            }, {
              [`& .${listItemTextClasses.secondary}`]: styles.secondary
            }, styles.root, ownerState.inset && styles.inset, ownerState.primary && ownerState.secondary && styles.multiline, ownerState.dense && styles.dense];
          }
        })(({
          ownerState
        }) => _extends$h({
          flex: '1 1 auto',
          minWidth: 0,
          marginTop: 4,
          marginBottom: 4
        }, ownerState.primary && ownerState.secondary && {
          marginTop: 6,
          marginBottom: 6
        }, ownerState.inset && {
          paddingLeft: 56
        }));
        const ListItemText = /*#__PURE__*/reactExports.forwardRef(function ListItemText(inProps, ref) {
          const props = useThemeProps({
            props: inProps,
            name: 'MuiListItemText'
          });
          const {
              children,
              className,
              disableTypography = false,
              inset = false,
              primary: primaryProp,
              primaryTypographyProps,
              secondary: secondaryProp,
              secondaryTypographyProps
            } = props,
            other = _objectWithoutPropertiesLoose(props, _excluded$e);
          const {
            dense
          } = reactExports.useContext(ListContext);
          let primary = primaryProp != null ? primaryProp : children;
          let secondary = secondaryProp;
          const ownerState = _extends$h({}, props, {
            disableTypography,
            inset,
            primary: !!primary,
            secondary: !!secondary,
            dense
          });
          const classes = useUtilityClasses$2(ownerState);
          if (primary != null && primary.type !== Typography && !disableTypography) {
            primary = /*#__PURE__*/jsxRuntimeExports.jsx(Typography, _extends$h({
              variant: dense ? 'body2' : 'body1',
              className: classes.primary,
              component: primaryTypographyProps != null && primaryTypographyProps.variant ? undefined : 'span',
              display: "block"
            }, primaryTypographyProps, {
              children: primary
            }));
          }
          if (secondary != null && secondary.type !== Typography && !disableTypography) {
            secondary = /*#__PURE__*/jsxRuntimeExports.jsx(Typography, _extends$h({
              variant: "body2",
              className: classes.secondary,
              color: "text.secondary",
              display: "block"
            }, secondaryTypographyProps, {
              children: secondary
            }));
          }
          return /*#__PURE__*/jsxRuntimeExports.jsxs(ListItemTextRoot, _extends$h({
            className: clsx(classes.root, className),
            ownerState: ownerState,
            ref: ref
          }, other, {
            children: [primary, secondary]
          }));
        });
        const ListItemText$1 = ListItemText;
        const shouldSpreadAdditionalProps = Slot => {
          return !Slot || !isHostComponent(Slot);
        };
        const shouldSpreadAdditionalProps$1 = shouldSpreadAdditionalProps;
        function getSliderUtilityClass(slot) {
          return generateUtilityClass('MuiSlider', slot);
        }
        const sliderClasses = generateUtilityClasses('MuiSlider', ['root', 'active', 'colorPrimary', 'colorSecondary', 'disabled', 'dragging', 'focusVisible', 'mark', 'markActive', 'marked', 'markLabel', 'markLabelActive', 'rail', 'sizeSmall', 'thumb', 'thumbColorPrimary', 'thumbColorSecondary', 'track', 'trackInverted', 'trackFalse', 'thumbSizeSmall', 'valueLabel', 'valueLabelOpen', 'valueLabelCircle', 'valueLabelLabel', 'vertical']);
        const sliderClasses$1 = sliderClasses;
        const useValueLabelClasses = props => {
          const {
            open
          } = props;
          const utilityClasses = {
            offset: clsx(open && sliderClasses$1.valueLabelOpen),
            circle: sliderClasses$1.valueLabelCircle,
            label: sliderClasses$1.valueLabelLabel
          };
          return utilityClasses;
        };

        /**
         * @ignore - internal component.
         */
        function SliderValueLabel(props) {
          const {
            children,
            className,
            value
          } = props;
          const classes = useValueLabelClasses(props);
          if (!children) {
            return null;
          }
          return /*#__PURE__*/reactExports.cloneElement(children, {
            className: clsx(children.props.className)
          }, /*#__PURE__*/jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [children.props.children, /*#__PURE__*/jsxRuntimeExports.jsx("span", {
              className: clsx(classes.offset, className),
              "aria-hidden": true,
              children: /*#__PURE__*/jsxRuntimeExports.jsx("span", {
                className: classes.circle,
                children: /*#__PURE__*/jsxRuntimeExports.jsx("span", {
                  className: classes.label,
                  children: value
                })
              })
            })]
          }));
        }
        const _excluded$d = ["aria-label", "aria-valuetext", "aria-labelledby", "component", "components", "componentsProps", "color", "classes", "className", "disableSwap", "disabled", "getAriaLabel", "getAriaValueText", "marks", "max", "min", "name", "onChange", "onChangeCommitted", "orientation", "size", "step", "scale", "slotProps", "slots", "tabIndex", "track", "value", "valueLabelDisplay", "valueLabelFormat"];
        function Identity(x) {
          return x;
        }
        const SliderRoot = styled('span', {
          name: 'MuiSlider',
          slot: 'Root',
          overridesResolver: (props, styles) => {
            const {
              ownerState
            } = props;
            return [styles.root, styles[`color${capitalize(ownerState.color)}`], ownerState.size !== 'medium' && styles[`size${capitalize(ownerState.size)}`], ownerState.marked && styles.marked, ownerState.orientation === 'vertical' && styles.vertical, ownerState.track === 'inverted' && styles.trackInverted, ownerState.track === false && styles.trackFalse];
          }
        })(({
          theme,
          ownerState
        }) => _extends$h({
          borderRadius: 12,
          boxSizing: 'content-box',
          display: 'inline-block',
          position: 'relative',
          cursor: 'pointer',
          touchAction: 'none',
          color: (theme.vars || theme).palette[ownerState.color].main,
          WebkitTapHighlightColor: 'transparent'
        }, ownerState.orientation === 'horizontal' && _extends$h({
          height: 4,
          width: '100%',
          padding: '13px 0',
          // The primary input mechanism of the device includes a pointing device of limited accuracy.
          '@media (pointer: coarse)': {
            // Reach 42px touch target, about ~8mm on screen.
            padding: '20px 0'
          }
        }, ownerState.size === 'small' && {
          height: 2
        }, ownerState.marked && {
          marginBottom: 20
        }), ownerState.orientation === 'vertical' && _extends$h({
          height: '100%',
          width: 4,
          padding: '0 13px',
          // The primary input mechanism of the device includes a pointing device of limited accuracy.
          '@media (pointer: coarse)': {
            // Reach 42px touch target, about ~8mm on screen.
            padding: '0 20px'
          }
        }, ownerState.size === 'small' && {
          width: 2
        }, ownerState.marked && {
          marginRight: 44
        }), {
          '@media print': {
            colorAdjust: 'exact'
          },
          [`&.${sliderClasses$1.disabled}`]: {
            pointerEvents: 'none',
            cursor: 'default',
            color: (theme.vars || theme).palette.grey[400]
          },
          [`&.${sliderClasses$1.dragging}`]: {
            [`& .${sliderClasses$1.thumb}, & .${sliderClasses$1.track}`]: {
              transition: 'none'
            }
          }
        }));
        const SliderRail = styled('span', {
          name: 'MuiSlider',
          slot: 'Rail',
          overridesResolver: (props, styles) => styles.rail
        })(({
          ownerState
        }) => _extends$h({
          display: 'block',
          position: 'absolute',
          borderRadius: 'inherit',
          backgroundColor: 'currentColor',
          opacity: 0.38
        }, ownerState.orientation === 'horizontal' && {
          width: '100%',
          height: 'inherit',
          top: '50%',
          transform: 'translateY(-50%)'
        }, ownerState.orientation === 'vertical' && {
          height: '100%',
          width: 'inherit',
          left: '50%',
          transform: 'translateX(-50%)'
        }, ownerState.track === 'inverted' && {
          opacity: 1
        }));
        const SliderTrack = styled('span', {
          name: 'MuiSlider',
          slot: 'Track',
          overridesResolver: (props, styles) => styles.track
        })(({
          theme,
          ownerState
        }) => {
          const color =
          // Same logic as the LinearProgress track color
          theme.palette.mode === 'light' ? lighten(theme.palette[ownerState.color].main, 0.62) : darken(theme.palette[ownerState.color].main, 0.5);
          return _extends$h({
            display: 'block',
            position: 'absolute',
            borderRadius: 'inherit',
            border: '1px solid currentColor',
            backgroundColor: 'currentColor',
            transition: theme.transitions.create(['left', 'width', 'bottom', 'height'], {
              duration: theme.transitions.duration.shortest
            })
          }, ownerState.size === 'small' && {
            border: 'none'
          }, ownerState.orientation === 'horizontal' && {
            height: 'inherit',
            top: '50%',
            transform: 'translateY(-50%)'
          }, ownerState.orientation === 'vertical' && {
            width: 'inherit',
            left: '50%',
            transform: 'translateX(-50%)'
          }, ownerState.track === false && {
            display: 'none'
          }, ownerState.track === 'inverted' && {
            backgroundColor: theme.vars ? theme.vars.palette.Slider[`${ownerState.color}Track`] : color,
            borderColor: theme.vars ? theme.vars.palette.Slider[`${ownerState.color}Track`] : color
          });
        });
        const SliderThumb = styled('span', {
          name: 'MuiSlider',
          slot: 'Thumb',
          overridesResolver: (props, styles) => {
            const {
              ownerState
            } = props;
            return [styles.thumb, styles[`thumbColor${capitalize(ownerState.color)}`], ownerState.size !== 'medium' && styles[`thumbSize${capitalize(ownerState.size)}`]];
          }
        })(({
          theme,
          ownerState
        }) => _extends$h({
          position: 'absolute',
          width: 20,
          height: 20,
          boxSizing: 'border-box',
          borderRadius: '50%',
          outline: 0,
          backgroundColor: 'currentColor',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          transition: theme.transitions.create(['box-shadow', 'left', 'bottom'], {
            duration: theme.transitions.duration.shortest
          })
        }, ownerState.size === 'small' && {
          width: 12,
          height: 12
        }, ownerState.orientation === 'horizontal' && {
          top: '50%',
          transform: 'translate(-50%, -50%)'
        }, ownerState.orientation === 'vertical' && {
          left: '50%',
          transform: 'translate(-50%, 50%)'
        }, {
          '&:before': _extends$h({
            position: 'absolute',
            content: '""',
            borderRadius: 'inherit',
            width: '100%',
            height: '100%',
            boxShadow: (theme.vars || theme).shadows[2]
          }, ownerState.size === 'small' && {
            boxShadow: 'none'
          }),
          '&::after': {
            position: 'absolute',
            content: '""',
            borderRadius: '50%',
            // 42px is the hit target
            width: 42,
            height: 42,
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)'
          },
          [`&:hover, &.${sliderClasses$1.focusVisible}`]: {
            boxShadow: `0px 0px 0px 8px ${theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.16)` : alpha(theme.palette[ownerState.color].main, 0.16)}`,
            '@media (hover: none)': {
              boxShadow: 'none'
            }
          },
          [`&.${sliderClasses$1.active}`]: {
            boxShadow: `0px 0px 0px 14px ${theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.16)` : alpha(theme.palette[ownerState.color].main, 0.16)}`
          },
          [`&.${sliderClasses$1.disabled}`]: {
            '&:hover': {
              boxShadow: 'none'
            }
          }
        }));
        const StyledSliderValueLabel = styled(SliderValueLabel, {
          name: 'MuiSlider',
          slot: 'ValueLabel',
          overridesResolver: (props, styles) => styles.valueLabel
        })(({
          theme,
          ownerState
        }) => _extends$h({
          [`&.${sliderClasses$1.valueLabelOpen}`]: {
            transform: `${ownerState.orientation === 'vertical' ? 'translateY(-50%)' : 'translateY(-100%)'} scale(1)`
          },
          zIndex: 1,
          whiteSpace: 'nowrap'
        }, theme.typography.body2, {
          fontWeight: 500,
          transition: theme.transitions.create(['transform'], {
            duration: theme.transitions.duration.shortest
          }),
          transform: `${ownerState.orientation === 'vertical' ? 'translateY(-50%)' : 'translateY(-100%)'} scale(0)`,
          position: 'absolute',
          backgroundColor: (theme.vars || theme).palette.grey[600],
          borderRadius: 2,
          color: (theme.vars || theme).palette.common.white,
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          padding: '0.25rem 0.75rem'
        }, ownerState.orientation === 'horizontal' && {
          top: '-10px',
          transformOrigin: 'bottom center',
          '&:before': {
            position: 'absolute',
            content: '""',
            width: 8,
            height: 8,
            transform: 'translate(-50%, 50%) rotate(45deg)',
            backgroundColor: 'inherit',
            bottom: 0,
            left: '50%'
          }
        }, ownerState.orientation === 'vertical' && {
          right: ownerState.size === 'small' ? '20px' : '30px',
          top: '50%',
          transformOrigin: 'right center',
          '&:before': {
            position: 'absolute',
            content: '""',
            width: 8,
            height: 8,
            transform: 'translate(-50%, -50%) rotate(45deg)',
            backgroundColor: 'inherit',
            right: '-20%',
            top: '50%'
          }
        }, ownerState.size === 'small' && {
          fontSize: theme.typography.pxToRem(12),
          padding: '0.25rem 0.5rem'
        }));
        const SliderMark = styled('span', {
          name: 'MuiSlider',
          slot: 'Mark',
          shouldForwardProp: prop => slotShouldForwardProp(prop) && prop !== 'markActive',
          overridesResolver: (props, styles) => {
            const {
              markActive
            } = props;
            return [styles.mark, markActive && styles.markActive];
          }
        })(({
          theme,
          ownerState,
          markActive
        }) => _extends$h({
          position: 'absolute',
          width: 2,
          height: 2,
          borderRadius: 1,
          backgroundColor: 'currentColor'
        }, ownerState.orientation === 'horizontal' && {
          top: '50%',
          transform: 'translate(-1px, -50%)'
        }, ownerState.orientation === 'vertical' && {
          left: '50%',
          transform: 'translate(-50%, 1px)'
        }, markActive && {
          backgroundColor: (theme.vars || theme).palette.background.paper,
          opacity: 0.8
        }));
        const SliderMarkLabel = styled('span', {
          name: 'MuiSlider',
          slot: 'MarkLabel',
          shouldForwardProp: prop => slotShouldForwardProp(prop) && prop !== 'markLabelActive',
          overridesResolver: (props, styles) => styles.markLabel
        })(({
          theme,
          ownerState,
          markLabelActive
        }) => _extends$h({}, theme.typography.body2, {
          color: (theme.vars || theme).palette.text.secondary,
          position: 'absolute',
          whiteSpace: 'nowrap'
        }, ownerState.orientation === 'horizontal' && {
          top: 30,
          transform: 'translateX(-50%)',
          '@media (pointer: coarse)': {
            top: 40
          }
        }, ownerState.orientation === 'vertical' && {
          left: 36,
          transform: 'translateY(50%)',
          '@media (pointer: coarse)': {
            left: 44
          }
        }, markLabelActive && {
          color: (theme.vars || theme).palette.text.primary
        }));
        const useUtilityClasses$1 = ownerState => {
          const {
            disabled,
            dragging,
            marked,
            orientation,
            track,
            classes,
            color,
            size
          } = ownerState;
          const slots = {
            root: ['root', disabled && 'disabled', dragging && 'dragging', marked && 'marked', orientation === 'vertical' && 'vertical', track === 'inverted' && 'trackInverted', track === false && 'trackFalse', color && `color${capitalize(color)}`, size && `size${capitalize(size)}`],
            rail: ['rail'],
            track: ['track'],
            mark: ['mark'],
            markActive: ['markActive'],
            markLabel: ['markLabel'],
            markLabelActive: ['markLabelActive'],
            valueLabel: ['valueLabel'],
            thumb: ['thumb', disabled && 'disabled', size && `thumbSize${capitalize(size)}`, color && `thumbColor${capitalize(color)}`],
            active: ['active'],
            disabled: ['disabled'],
            focusVisible: ['focusVisible']
          };
          return composeClasses(slots, getSliderUtilityClass, classes);
        };
        const Forward = ({
          children
        }) => children;
        const Slider$1 = /*#__PURE__*/reactExports.forwardRef(function Slider(inputProps, ref) {
          var _ref, _slots$root, _ref2, _slots$rail, _ref3, _slots$track, _ref4, _slots$thumb, _ref5, _slots$valueLabel, _ref6, _slots$mark, _ref7, _slots$markLabel, _ref8, _slots$input, _slotProps$root, _slotProps$rail, _slotProps$track, _slotProps$thumb, _slotProps$valueLabel, _slotProps$mark, _slotProps$markLabel, _slotProps$input;
          const props = useThemeProps({
            props: inputProps,
            name: 'MuiSlider'
          });
          const theme = useTheme();
          const isRtl = theme.direction === 'rtl';
          const {
              'aria-label': ariaLabel,
              'aria-valuetext': ariaValuetext,
              'aria-labelledby': ariaLabelledby,
              // eslint-disable-next-line react/prop-types
              component = 'span',
              components = {},
              componentsProps = {},
              color = 'primary',
              classes: classesProp,
              className,
              disableSwap = false,
              disabled = false,
              getAriaLabel,
              getAriaValueText,
              marks: marksProp = false,
              max = 100,
              min = 0,
              orientation = 'horizontal',
              size = 'medium',
              step = 1,
              scale = Identity,
              slotProps,
              slots,
              track = 'normal',
              valueLabelDisplay = 'off',
              valueLabelFormat = Identity
            } = props,
            other = _objectWithoutPropertiesLoose(props, _excluded$d);
          const ownerState = _extends$h({}, props, {
            isRtl,
            max,
            min,
            classes: classesProp,
            disabled,
            disableSwap,
            orientation,
            marks: marksProp,
            color,
            size,
            step,
            scale,
            track,
            valueLabelDisplay,
            valueLabelFormat
          });
          const {
            axisProps,
            getRootProps,
            getHiddenInputProps,
            getThumbProps,
            open,
            active,
            axis,
            focusedThumbIndex,
            range,
            dragging,
            marks,
            values,
            trackOffset,
            trackLeap
          } = useSlider(_extends$h({}, ownerState, {
            ref
          }));
          ownerState.marked = marks.length > 0 && marks.some(mark => mark.label);
          ownerState.dragging = dragging;
          ownerState.focusedThumbIndex = focusedThumbIndex;
          const classes = useUtilityClasses$1(ownerState);

          // support both `slots` and `components` for backward compatibility
          const RootSlot = (_ref = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components.Root) != null ? _ref : SliderRoot;
          const RailSlot = (_ref2 = (_slots$rail = slots == null ? void 0 : slots.rail) != null ? _slots$rail : components.Rail) != null ? _ref2 : SliderRail;
          const TrackSlot = (_ref3 = (_slots$track = slots == null ? void 0 : slots.track) != null ? _slots$track : components.Track) != null ? _ref3 : SliderTrack;
          const ThumbSlot = (_ref4 = (_slots$thumb = slots == null ? void 0 : slots.thumb) != null ? _slots$thumb : components.Thumb) != null ? _ref4 : SliderThumb;
          const ValueLabelSlot = (_ref5 = (_slots$valueLabel = slots == null ? void 0 : slots.valueLabel) != null ? _slots$valueLabel : components.ValueLabel) != null ? _ref5 : StyledSliderValueLabel;
          const MarkSlot = (_ref6 = (_slots$mark = slots == null ? void 0 : slots.mark) != null ? _slots$mark : components.Mark) != null ? _ref6 : SliderMark;
          const MarkLabelSlot = (_ref7 = (_slots$markLabel = slots == null ? void 0 : slots.markLabel) != null ? _slots$markLabel : components.MarkLabel) != null ? _ref7 : SliderMarkLabel;
          const InputSlot = (_ref8 = (_slots$input = slots == null ? void 0 : slots.input) != null ? _slots$input : components.Input) != null ? _ref8 : 'input';
          const rootSlotProps = (_slotProps$root = slotProps == null ? void 0 : slotProps.root) != null ? _slotProps$root : componentsProps.root;
          const railSlotProps = (_slotProps$rail = slotProps == null ? void 0 : slotProps.rail) != null ? _slotProps$rail : componentsProps.rail;
          const trackSlotProps = (_slotProps$track = slotProps == null ? void 0 : slotProps.track) != null ? _slotProps$track : componentsProps.track;
          const thumbSlotProps = (_slotProps$thumb = slotProps == null ? void 0 : slotProps.thumb) != null ? _slotProps$thumb : componentsProps.thumb;
          const valueLabelSlotProps = (_slotProps$valueLabel = slotProps == null ? void 0 : slotProps.valueLabel) != null ? _slotProps$valueLabel : componentsProps.valueLabel;
          const markSlotProps = (_slotProps$mark = slotProps == null ? void 0 : slotProps.mark) != null ? _slotProps$mark : componentsProps.mark;
          const markLabelSlotProps = (_slotProps$markLabel = slotProps == null ? void 0 : slotProps.markLabel) != null ? _slotProps$markLabel : componentsProps.markLabel;
          const inputSlotProps = (_slotProps$input = slotProps == null ? void 0 : slotProps.input) != null ? _slotProps$input : componentsProps.input;
          const rootProps = useSlotProps({
            elementType: RootSlot,
            getSlotProps: getRootProps,
            externalSlotProps: rootSlotProps,
            externalForwardedProps: other,
            additionalProps: _extends$h({}, shouldSpreadAdditionalProps$1(RootSlot) && {
              as: component
            }),
            ownerState: _extends$h({}, ownerState, rootSlotProps == null ? void 0 : rootSlotProps.ownerState),
            className: [classes.root, className]
          });
          const railProps = useSlotProps({
            elementType: RailSlot,
            externalSlotProps: railSlotProps,
            ownerState,
            className: classes.rail
          });
          const trackProps = useSlotProps({
            elementType: TrackSlot,
            externalSlotProps: trackSlotProps,
            additionalProps: {
              style: _extends$h({}, axisProps[axis].offset(trackOffset), axisProps[axis].leap(trackLeap))
            },
            ownerState: _extends$h({}, ownerState, trackSlotProps == null ? void 0 : trackSlotProps.ownerState),
            className: classes.track
          });
          const thumbProps = useSlotProps({
            elementType: ThumbSlot,
            getSlotProps: getThumbProps,
            externalSlotProps: thumbSlotProps,
            ownerState: _extends$h({}, ownerState, thumbSlotProps == null ? void 0 : thumbSlotProps.ownerState),
            className: classes.thumb
          });
          const valueLabelProps = useSlotProps({
            elementType: ValueLabelSlot,
            externalSlotProps: valueLabelSlotProps,
            ownerState: _extends$h({}, ownerState, valueLabelSlotProps == null ? void 0 : valueLabelSlotProps.ownerState),
            className: classes.valueLabel
          });
          const markProps = useSlotProps({
            elementType: MarkSlot,
            externalSlotProps: markSlotProps,
            ownerState,
            className: classes.mark
          });
          const markLabelProps = useSlotProps({
            elementType: MarkLabelSlot,
            externalSlotProps: markLabelSlotProps,
            ownerState,
            className: classes.markLabel
          });
          const inputSliderProps = useSlotProps({
            elementType: InputSlot,
            getSlotProps: getHiddenInputProps,
            externalSlotProps: inputSlotProps,
            ownerState
          });
          return /*#__PURE__*/jsxRuntimeExports.jsxs(RootSlot, _extends$h({}, rootProps, {
            children: [/*#__PURE__*/jsxRuntimeExports.jsx(RailSlot, _extends$h({}, railProps)), /*#__PURE__*/jsxRuntimeExports.jsx(TrackSlot, _extends$h({}, trackProps)), marks.filter(mark => mark.value >= min && mark.value <= max).map((mark, index) => {
              const percent = valueToPercent(mark.value, min, max);
              const style = axisProps[axis].offset(percent);
              let markActive;
              if (track === false) {
                markActive = values.indexOf(mark.value) !== -1;
              } else {
                markActive = track === 'normal' && (range ? mark.value >= values[0] && mark.value <= values[values.length - 1] : mark.value <= values[0]) || track === 'inverted' && (range ? mark.value <= values[0] || mark.value >= values[values.length - 1] : mark.value >= values[0]);
              }
              return /*#__PURE__*/jsxRuntimeExports.jsxs(reactExports.Fragment, {
                children: [/*#__PURE__*/jsxRuntimeExports.jsx(MarkSlot, _extends$h({
                  "data-index": index
                }, markProps, !isHostComponent(MarkSlot) && {
                  markActive
                }, {
                  style: _extends$h({}, style, markProps.style),
                  className: clsx(markProps.className, markActive && classes.markActive)
                })), mark.label != null ? /*#__PURE__*/jsxRuntimeExports.jsx(MarkLabelSlot, _extends$h({
                  "aria-hidden": true,
                  "data-index": index
                }, markLabelProps, !isHostComponent(MarkLabelSlot) && {
                  markLabelActive: markActive
                }, {
                  style: _extends$h({}, style, markLabelProps.style),
                  className: clsx(classes.markLabel, markLabelProps.className, markActive && classes.markLabelActive),
                  children: mark.label
                })) : null]
              }, index);
            }), values.map((value, index) => {
              const percent = valueToPercent(value, min, max);
              const style = axisProps[axis].offset(percent);
              const ValueLabelComponent = valueLabelDisplay === 'off' ? Forward : ValueLabelSlot;
              return /*#__PURE__*/(
                /* TODO v6: Change component structure. It will help in avoiding the complicated React.cloneElement API added in SliderValueLabel component. Should be: Thumb -> Input, ValueLabel. Follow Joy UI's Slider structure. */
                jsxRuntimeExports.jsx(ValueLabelComponent, _extends$h({}, !isHostComponent(ValueLabelComponent) && {
                  valueLabelFormat,
                  valueLabelDisplay,
                  value: typeof valueLabelFormat === 'function' ? valueLabelFormat(scale(value), index) : valueLabelFormat,
                  index,
                  open: open === index || active === index || valueLabelDisplay === 'on',
                  disabled
                }, valueLabelProps, {
                  children: /*#__PURE__*/jsxRuntimeExports.jsx(ThumbSlot, _extends$h({
                    "data-index": index
                  }, thumbProps, {
                    className: clsx(classes.thumb, thumbProps.className, active === index && classes.active, focusedThumbIndex === index && classes.focusVisible),
                    style: _extends$h({}, style, {
                      pointerEvents: disableSwap && active !== index ? 'none' : undefined
                    }, thumbProps.style),
                    children: /*#__PURE__*/jsxRuntimeExports.jsx(InputSlot, _extends$h({
                      "data-index": index,
                      "aria-label": getAriaLabel ? getAriaLabel(index) : ariaLabel,
                      "aria-valuenow": scale(value),
                      "aria-labelledby": ariaLabelledby,
                      "aria-valuetext": getAriaValueText ? getAriaValueText(scale(value), index) : ariaValuetext,
                      value: values[index]
                    }, inputSliderProps))
                  }))
                }), index)
              );
            })]
          }));
        });
        const Slider$2 = Slider$1;
        function getTooltipUtilityClass(slot) {
          return generateUtilityClass('MuiTooltip', slot);
        }
        const tooltipClasses = generateUtilityClasses('MuiTooltip', ['popper', 'popperInteractive', 'popperArrow', 'popperClose', 'tooltip', 'tooltipArrow', 'touch', 'tooltipPlacementLeft', 'tooltipPlacementRight', 'tooltipPlacementTop', 'tooltipPlacementBottom', 'arrow']);
        const tooltipClasses$1 = tooltipClasses;
        const _excluded$c = ["arrow", "children", "classes", "components", "componentsProps", "describeChild", "disableFocusListener", "disableHoverListener", "disableInteractive", "disableTouchListener", "enterDelay", "enterNextDelay", "enterTouchDelay", "followCursor", "id", "leaveDelay", "leaveTouchDelay", "onClose", "onOpen", "open", "placement", "PopperComponent", "PopperProps", "slotProps", "slots", "title", "TransitionComponent", "TransitionProps"];
        function round$1(value) {
          return Math.round(value * 1e5) / 1e5;
        }
        const useUtilityClasses = ownerState => {
          const {
            classes,
            disableInteractive,
            arrow,
            touch,
            placement
          } = ownerState;
          const slots = {
            popper: ['popper', !disableInteractive && 'popperInteractive', arrow && 'popperArrow'],
            tooltip: ['tooltip', arrow && 'tooltipArrow', touch && 'touch', `tooltipPlacement${capitalize(placement.split('-')[0])}`],
            arrow: ['arrow']
          };
          return composeClasses(slots, getTooltipUtilityClass, classes);
        };
        const TooltipPopper = styled(Popper, {
          name: 'MuiTooltip',
          slot: 'Popper',
          overridesResolver: (props, styles) => {
            const {
              ownerState
            } = props;
            return [styles.popper, !ownerState.disableInteractive && styles.popperInteractive, ownerState.arrow && styles.popperArrow, !ownerState.open && styles.popperClose];
          }
        })(({
          theme,
          ownerState,
          open
        }) => _extends$h({
          zIndex: (theme.vars || theme).zIndex.tooltip,
          pointerEvents: 'none'
        }, !ownerState.disableInteractive && {
          pointerEvents: 'auto'
        }, !open && {
          pointerEvents: 'none'
        }, ownerState.arrow && {
          [`&[data-popper-placement*="bottom"] .${tooltipClasses$1.arrow}`]: {
            top: 0,
            marginTop: '-0.71em',
            '&::before': {
              transformOrigin: '0 100%'
            }
          },
          [`&[data-popper-placement*="top"] .${tooltipClasses$1.arrow}`]: {
            bottom: 0,
            marginBottom: '-0.71em',
            '&::before': {
              transformOrigin: '100% 0'
            }
          },
          [`&[data-popper-placement*="right"] .${tooltipClasses$1.arrow}`]: _extends$h({}, !ownerState.isRtl ? {
            left: 0,
            marginLeft: '-0.71em'
          } : {
            right: 0,
            marginRight: '-0.71em'
          }, {
            height: '1em',
            width: '0.71em',
            '&::before': {
              transformOrigin: '100% 100%'
            }
          }),
          [`&[data-popper-placement*="left"] .${tooltipClasses$1.arrow}`]: _extends$h({}, !ownerState.isRtl ? {
            right: 0,
            marginRight: '-0.71em'
          } : {
            left: 0,
            marginLeft: '-0.71em'
          }, {
            height: '1em',
            width: '0.71em',
            '&::before': {
              transformOrigin: '0 0'
            }
          })
        }));
        const TooltipTooltip = styled('div', {
          name: 'MuiTooltip',
          slot: 'Tooltip',
          overridesResolver: (props, styles) => {
            const {
              ownerState
            } = props;
            return [styles.tooltip, ownerState.touch && styles.touch, ownerState.arrow && styles.tooltipArrow, styles[`tooltipPlacement${capitalize(ownerState.placement.split('-')[0])}`]];
          }
        })(({
          theme,
          ownerState
        }) => _extends$h({
          backgroundColor: theme.vars ? theme.vars.palette.Tooltip.bg : alpha(theme.palette.grey[700], 0.92),
          borderRadius: (theme.vars || theme).shape.borderRadius,
          color: (theme.vars || theme).palette.common.white,
          fontFamily: theme.typography.fontFamily,
          padding: '4px 8px',
          fontSize: theme.typography.pxToRem(11),
          maxWidth: 300,
          margin: 2,
          wordWrap: 'break-word',
          fontWeight: theme.typography.fontWeightMedium
        }, ownerState.arrow && {
          position: 'relative',
          margin: 0
        }, ownerState.touch && {
          padding: '8px 16px',
          fontSize: theme.typography.pxToRem(14),
          lineHeight: `${round$1(16 / 14)}em`,
          fontWeight: theme.typography.fontWeightRegular
        }, {
          [`.${tooltipClasses$1.popper}[data-popper-placement*="left"] &`]: _extends$h({
            transformOrigin: 'right center'
          }, !ownerState.isRtl ? _extends$h({
            marginRight: '14px'
          }, ownerState.touch && {
            marginRight: '24px'
          }) : _extends$h({
            marginLeft: '14px'
          }, ownerState.touch && {
            marginLeft: '24px'
          })),
          [`.${tooltipClasses$1.popper}[data-popper-placement*="right"] &`]: _extends$h({
            transformOrigin: 'left center'
          }, !ownerState.isRtl ? _extends$h({
            marginLeft: '14px'
          }, ownerState.touch && {
            marginLeft: '24px'
          }) : _extends$h({
            marginRight: '14px'
          }, ownerState.touch && {
            marginRight: '24px'
          })),
          [`.${tooltipClasses$1.popper}[data-popper-placement*="top"] &`]: _extends$h({
            transformOrigin: 'center bottom',
            marginBottom: '14px'
          }, ownerState.touch && {
            marginBottom: '24px'
          }),
          [`.${tooltipClasses$1.popper}[data-popper-placement*="bottom"] &`]: _extends$h({
            transformOrigin: 'center top',
            marginTop: '14px'
          }, ownerState.touch && {
            marginTop: '24px'
          })
        }));
        const TooltipArrow = styled('span', {
          name: 'MuiTooltip',
          slot: 'Arrow',
          overridesResolver: (props, styles) => styles.arrow
        })(({
          theme
        }) => ({
          overflow: 'hidden',
          position: 'absolute',
          width: '1em',
          height: '0.71em' /* = width / sqrt(2) = (length of the hypotenuse) */,
          boxSizing: 'border-box',
          color: theme.vars ? theme.vars.palette.Tooltip.bg : alpha(theme.palette.grey[700], 0.9),
          '&::before': {
            content: '""',
            margin: 'auto',
            display: 'block',
            width: '100%',
            height: '100%',
            backgroundColor: 'currentColor',
            transform: 'rotate(45deg)'
          }
        }));
        let hystersisOpen = false;
        let hystersisTimer = null;
        let cursorPosition = {
          x: 0,
          y: 0
        };
        function composeEventHandler(handler, eventHandler) {
          return event => {
            if (eventHandler) {
              eventHandler(event);
            }
            handler(event);
          };
        }

        // TODO v6: Remove PopperComponent, PopperProps, TransitionComponent and TransitionProps.
        const Tooltip = /*#__PURE__*/reactExports.forwardRef(function Tooltip(inProps, ref) {
          var _ref, _slots$popper, _ref2, _ref3, _slots$transition, _ref4, _slots$tooltip, _ref5, _slots$arrow, _slotProps$popper, _ref6, _slotProps$popper2, _slotProps$transition, _slotProps$tooltip, _ref7, _slotProps$tooltip2, _slotProps$arrow, _ref8, _slotProps$arrow2;
          const props = useThemeProps({
            props: inProps,
            name: 'MuiTooltip'
          });
          const {
              arrow = false,
              children,
              components = {},
              componentsProps = {},
              describeChild = false,
              disableFocusListener = false,
              disableHoverListener = false,
              disableInteractive: disableInteractiveProp = false,
              disableTouchListener = false,
              enterDelay = 100,
              enterNextDelay = 0,
              enterTouchDelay = 700,
              followCursor = false,
              id: idProp,
              leaveDelay = 0,
              leaveTouchDelay = 1500,
              onClose,
              onOpen,
              open: openProp,
              placement = 'bottom',
              PopperComponent: PopperComponentProp,
              PopperProps = {},
              slotProps = {},
              slots = {},
              title,
              TransitionComponent: TransitionComponentProp = Grow,
              TransitionProps
            } = props,
            other = _objectWithoutPropertiesLoose(props, _excluded$c);
          const theme = useTheme();
          const isRtl = theme.direction === 'rtl';
          const [childNode, setChildNode] = reactExports.useState();
          const [arrowRef, setArrowRef] = reactExports.useState(null);
          const ignoreNonTouchEvents = reactExports.useRef(false);
          const disableInteractive = disableInteractiveProp || followCursor;
          const closeTimer = reactExports.useRef();
          const enterTimer = reactExports.useRef();
          const leaveTimer = reactExports.useRef();
          const touchTimer = reactExports.useRef();
          const [openState, setOpenState] = useControlled({
            controlled: openProp,
            default: false,
            name: 'Tooltip',
            state: 'open'
          });
          let open = openState;
          const id = useId(idProp);
          const prevUserSelect = reactExports.useRef();
          const stopTouchInteraction = reactExports.useCallback(() => {
            if (prevUserSelect.current !== undefined) {
              document.body.style.WebkitUserSelect = prevUserSelect.current;
              prevUserSelect.current = undefined;
            }
            clearTimeout(touchTimer.current);
          }, []);
          reactExports.useEffect(() => {
            return () => {
              clearTimeout(closeTimer.current);
              clearTimeout(enterTimer.current);
              clearTimeout(leaveTimer.current);
              stopTouchInteraction();
            };
          }, [stopTouchInteraction]);
          const handleOpen = event => {
            clearTimeout(hystersisTimer);
            hystersisOpen = true;

            // The mouseover event will trigger for every nested element in the tooltip.
            // We can skip rerendering when the tooltip is already open.
            // We are using the mouseover event instead of the mouseenter event to fix a hide/show issue.
            setOpenState(true);
            if (onOpen && !open) {
              onOpen(event);
            }
          };
          const handleClose = useEventCallback(
          /**
           * @param {React.SyntheticEvent | Event} event
           */
          event => {
            clearTimeout(hystersisTimer);
            hystersisTimer = setTimeout(() => {
              hystersisOpen = false;
            }, 800 + leaveDelay);
            setOpenState(false);
            if (onClose && open) {
              onClose(event);
            }
            clearTimeout(closeTimer.current);
            closeTimer.current = setTimeout(() => {
              ignoreNonTouchEvents.current = false;
            }, theme.transitions.duration.shortest);
          });
          const handleEnter = event => {
            if (ignoreNonTouchEvents.current && event.type !== 'touchstart') {
              return;
            }

            // Remove the title ahead of time.
            // We don't want to wait for the next render commit.
            // We would risk displaying two tooltips at the same time (native + this one).
            if (childNode) {
              childNode.removeAttribute('title');
            }
            clearTimeout(enterTimer.current);
            clearTimeout(leaveTimer.current);
            if (enterDelay || hystersisOpen && enterNextDelay) {
              enterTimer.current = setTimeout(() => {
                handleOpen(event);
              }, hystersisOpen ? enterNextDelay : enterDelay);
            } else {
              handleOpen(event);
            }
          };
          const handleLeave = event => {
            clearTimeout(enterTimer.current);
            clearTimeout(leaveTimer.current);
            leaveTimer.current = setTimeout(() => {
              handleClose(event);
            }, leaveDelay);
          };
          const {
            isFocusVisibleRef,
            onBlur: handleBlurVisible,
            onFocus: handleFocusVisible,
            ref: focusVisibleRef
          } = useIsFocusVisible();
          // We don't necessarily care about the focusVisible state (which is safe to access via ref anyway).
          // We just need to re-render the Tooltip if the focus-visible state changes.
          const [, setChildIsFocusVisible] = reactExports.useState(false);
          const handleBlur = event => {
            handleBlurVisible(event);
            if (isFocusVisibleRef.current === false) {
              setChildIsFocusVisible(false);
              handleLeave(event);
            }
          };
          const handleFocus = event => {
            // Workaround for https://github.com/facebook/react/issues/7769
            // The autoFocus of React might trigger the event before the componentDidMount.
            // We need to account for this eventuality.
            if (!childNode) {
              setChildNode(event.currentTarget);
            }
            handleFocusVisible(event);
            if (isFocusVisibleRef.current === true) {
              setChildIsFocusVisible(true);
              handleEnter(event);
            }
          };
          const detectTouchStart = event => {
            ignoreNonTouchEvents.current = true;
            const childrenProps = children.props;
            if (childrenProps.onTouchStart) {
              childrenProps.onTouchStart(event);
            }
          };
          const handleMouseOver = handleEnter;
          const handleMouseLeave = handleLeave;
          const handleTouchStart = event => {
            detectTouchStart(event);
            clearTimeout(leaveTimer.current);
            clearTimeout(closeTimer.current);
            stopTouchInteraction();
            prevUserSelect.current = document.body.style.WebkitUserSelect;
            // Prevent iOS text selection on long-tap.
            document.body.style.WebkitUserSelect = 'none';
            touchTimer.current = setTimeout(() => {
              document.body.style.WebkitUserSelect = prevUserSelect.current;
              handleEnter(event);
            }, enterTouchDelay);
          };
          const handleTouchEnd = event => {
            if (children.props.onTouchEnd) {
              children.props.onTouchEnd(event);
            }
            stopTouchInteraction();
            clearTimeout(leaveTimer.current);
            leaveTimer.current = setTimeout(() => {
              handleClose(event);
            }, leaveTouchDelay);
          };
          reactExports.useEffect(() => {
            if (!open) {
              return undefined;
            }

            /**
             * @param {KeyboardEvent} nativeEvent
             */
            function handleKeyDown(nativeEvent) {
              // IE11, Edge (prior to using Bink?) use 'Esc'
              if (nativeEvent.key === 'Escape' || nativeEvent.key === 'Esc') {
                handleClose(nativeEvent);
              }
            }
            document.addEventListener('keydown', handleKeyDown);
            return () => {
              document.removeEventListener('keydown', handleKeyDown);
            };
          }, [handleClose, open]);
          const handleRef = useForkRef(children.ref, focusVisibleRef, setChildNode, ref);

          // There is no point in displaying an empty tooltip.
          if (!title && title !== 0) {
            open = false;
          }
          const popperRef = reactExports.useRef();
          const handleMouseMove = event => {
            const childrenProps = children.props;
            if (childrenProps.onMouseMove) {
              childrenProps.onMouseMove(event);
            }
            cursorPosition = {
              x: event.clientX,
              y: event.clientY
            };
            if (popperRef.current) {
              popperRef.current.update();
            }
          };
          const nameOrDescProps = {};
          const titleIsString = typeof title === 'string';
          if (describeChild) {
            nameOrDescProps.title = !open && titleIsString && !disableHoverListener ? title : null;
            nameOrDescProps['aria-describedby'] = open ? id : null;
          } else {
            nameOrDescProps['aria-label'] = titleIsString ? title : null;
            nameOrDescProps['aria-labelledby'] = open && !titleIsString ? id : null;
          }
          const childrenProps = _extends$h({}, nameOrDescProps, other, children.props, {
            className: clsx(other.className, children.props.className),
            onTouchStart: detectTouchStart,
            ref: handleRef
          }, followCursor ? {
            onMouseMove: handleMouseMove
          } : {});
          const interactiveWrapperListeners = {};
          if (!disableTouchListener) {
            childrenProps.onTouchStart = handleTouchStart;
            childrenProps.onTouchEnd = handleTouchEnd;
          }
          if (!disableHoverListener) {
            childrenProps.onMouseOver = composeEventHandler(handleMouseOver, childrenProps.onMouseOver);
            childrenProps.onMouseLeave = composeEventHandler(handleMouseLeave, childrenProps.onMouseLeave);
            if (!disableInteractive) {
              interactiveWrapperListeners.onMouseOver = handleMouseOver;
              interactiveWrapperListeners.onMouseLeave = handleMouseLeave;
            }
          }
          if (!disableFocusListener) {
            childrenProps.onFocus = composeEventHandler(handleFocus, childrenProps.onFocus);
            childrenProps.onBlur = composeEventHandler(handleBlur, childrenProps.onBlur);
            if (!disableInteractive) {
              interactiveWrapperListeners.onFocus = handleFocus;
              interactiveWrapperListeners.onBlur = handleBlur;
            }
          }
          const popperOptions = reactExports.useMemo(() => {
            var _PopperProps$popperOp;
            let tooltipModifiers = [{
              name: 'arrow',
              enabled: Boolean(arrowRef),
              options: {
                element: arrowRef,
                padding: 4
              }
            }];
            if ((_PopperProps$popperOp = PopperProps.popperOptions) != null && _PopperProps$popperOp.modifiers) {
              tooltipModifiers = tooltipModifiers.concat(PopperProps.popperOptions.modifiers);
            }
            return _extends$h({}, PopperProps.popperOptions, {
              modifiers: tooltipModifiers
            });
          }, [arrowRef, PopperProps]);
          const ownerState = _extends$h({}, props, {
            isRtl,
            arrow,
            disableInteractive,
            placement,
            PopperComponentProp,
            touch: ignoreNonTouchEvents.current
          });
          const classes = useUtilityClasses(ownerState);
          const PopperComponent = (_ref = (_slots$popper = slots.popper) != null ? _slots$popper : components.Popper) != null ? _ref : TooltipPopper;
          const TransitionComponent = (_ref2 = (_ref3 = (_slots$transition = slots.transition) != null ? _slots$transition : components.Transition) != null ? _ref3 : TransitionComponentProp) != null ? _ref2 : Grow;
          const TooltipComponent = (_ref4 = (_slots$tooltip = slots.tooltip) != null ? _slots$tooltip : components.Tooltip) != null ? _ref4 : TooltipTooltip;
          const ArrowComponent = (_ref5 = (_slots$arrow = slots.arrow) != null ? _slots$arrow : components.Arrow) != null ? _ref5 : TooltipArrow;
          const popperProps = appendOwnerState(PopperComponent, _extends$h({}, PopperProps, (_slotProps$popper = slotProps.popper) != null ? _slotProps$popper : componentsProps.popper, {
            className: clsx(classes.popper, PopperProps == null ? void 0 : PopperProps.className, (_ref6 = (_slotProps$popper2 = slotProps.popper) != null ? _slotProps$popper2 : componentsProps.popper) == null ? void 0 : _ref6.className)
          }), ownerState);
          const transitionProps = appendOwnerState(TransitionComponent, _extends$h({}, TransitionProps, (_slotProps$transition = slotProps.transition) != null ? _slotProps$transition : componentsProps.transition), ownerState);
          const tooltipProps = appendOwnerState(TooltipComponent, _extends$h({}, (_slotProps$tooltip = slotProps.tooltip) != null ? _slotProps$tooltip : componentsProps.tooltip, {
            className: clsx(classes.tooltip, (_ref7 = (_slotProps$tooltip2 = slotProps.tooltip) != null ? _slotProps$tooltip2 : componentsProps.tooltip) == null ? void 0 : _ref7.className)
          }), ownerState);
          const tooltipArrowProps = appendOwnerState(ArrowComponent, _extends$h({}, (_slotProps$arrow = slotProps.arrow) != null ? _slotProps$arrow : componentsProps.arrow, {
            className: clsx(classes.arrow, (_ref8 = (_slotProps$arrow2 = slotProps.arrow) != null ? _slotProps$arrow2 : componentsProps.arrow) == null ? void 0 : _ref8.className)
          }), ownerState);
          return /*#__PURE__*/jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [/*#__PURE__*/reactExports.cloneElement(children, childrenProps), /*#__PURE__*/jsxRuntimeExports.jsx(PopperComponent, _extends$h({
              as: PopperComponentProp != null ? PopperComponentProp : Popper,
              placement: placement,
              anchorEl: followCursor ? {
                getBoundingClientRect: () => ({
                  top: cursorPosition.y,
                  left: cursorPosition.x,
                  right: cursorPosition.x,
                  bottom: cursorPosition.y,
                  width: 0,
                  height: 0
                })
              } : childNode,
              popperRef: popperRef,
              open: childNode ? open : false,
              id: id,
              transition: true
            }, interactiveWrapperListeners, popperProps, {
              popperOptions: popperOptions,
              children: ({
                TransitionProps: TransitionPropsInner
              }) => /*#__PURE__*/jsxRuntimeExports.jsx(TransitionComponent, _extends$h({
                timeout: theme.transitions.duration.shorter
              }, TransitionPropsInner, transitionProps, {
                children: /*#__PURE__*/jsxRuntimeExports.jsxs(TooltipComponent, _extends$h({}, tooltipProps, {
                  children: [title, arrow ? /*#__PURE__*/jsxRuntimeExports.jsx(ArrowComponent, _extends$h({}, tooltipArrowProps, {
                    ref: setArrowRef
                  })) : null]
                }))
              }))
            }))]
          });
        });
        const Tooltip$1 = Tooltip;
        const EditOutlined = createSvgIcon( /*#__PURE__*/jsxRuntimeExports.jsx("path", {
          d: "m14.06 9.02.92.92L5.92 19H5v-.92l9.06-9.06M17.66 3c-.25 0-.51.1-.7.29l-1.83 1.83 3.75 3.75 1.83-1.83c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.2-.2-.45-.29-.71-.29zm-3.6 3.19L3 17.25V21h3.75L17.81 9.94l-3.75-3.75z"
        }), 'EditOutlined');
        const PreviewOutlined = createSvgIcon( /*#__PURE__*/jsxRuntimeExports.jsx("path", {
          d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm0 16H5V7h14v12zm-7-8.5c1.84 0 3.48.96 4.34 2.5-.86 1.54-2.5 2.5-4.34 2.5s-3.48-.96-4.34-2.5c.86-1.54 2.5-2.5 4.34-2.5M12 9c-2.73 0-5.06 1.66-6 4 .94 2.34 3.27 4 6 4s5.06-1.66 6-4c-.94-2.34-3.27-4-6-4zm0 5.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"
        }), 'PreviewOutlined');
        const mainContainer = "_mainContainer_1qlrg_1";
        const updateButtons = "_updateButtons_1qlrg_9";
        const save = "_save_1qlrg_18";
        const styles$L = {
          mainContainer: mainContainer,
          updateButtons: updateButtons,
          save: save
        };
        var ViewCompact = {};
        var _interopRequireDefault$w = interopRequireDefaultExports;
        Object.defineProperty(ViewCompact, "__esModule", {
          value: true
        });
        var default_1$o = ViewCompact.default = void 0;
        var _createSvgIcon$o = _interopRequireDefault$w(requireCreateSvgIcon());
        var _jsxRuntime$o = jsxRuntimeExports;
        var _default$r = (0, _createSvgIcon$o.default)( /*#__PURE__*/(0, _jsxRuntime$o.jsx)("path", {
          d: "M4 18h2.5v-2.5H4V18zm0-4.75h2.5v-2.5H4v2.5zM4 8.5h2.5V6H4v2.5zM17.5 6v2.5H20V6h-2.5zM13 8.5h2.5V6H13v2.5zm4.5 9.5H20v-2.5h-2.5V18zm0-4.75H20v-2.5h-2.5v2.5zM8.5 18H11v-2.5H8.5V18zm4.5 0h2.5v-2.5H13V18zM8.5 8.5H11V6H8.5v2.5zm4.5 4.75h2.5v-2.5H13v2.5zm-4.5 0H11v-2.5H8.5v2.5z"
        }), 'ViewCompact');
        default_1$o = ViewCompact.default = _default$r;
        const questionItem$6 = "_questionItem_wb37f_1";
        const styles$K = {
          questionItem: questionItem$6
        };
        function TextQuestionDesign({
          code
        }) {
          var _state$validation, _state$validation$val, _state$content, _state$content$hint;
          const theme = useTheme();
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const lang = useSelector(state2 => {
            return state2.designState.langInfo.lang;
          });
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            className: styles$K.questionItem,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
              disabled: true,
              variant: "standard",
              required: (_state$validation = state.validation) !== null && _state$validation !== void 0 && (_state$validation$val = _state$validation.validation_required) !== null && _state$validation$val !== void 0 && _state$validation$val.isActive ? true : false,
              label: state.showHint && (((_state$content = state.content) === null || _state$content === void 0 ? void 0 : (_state$content$hint = _state$content.hint) === null || _state$content$hint === void 0 ? void 0 : _state$content$hint[lang]) || ""),
              value: "",
              InputProps: {
                sx: {
                  fontFamily: theme.textStyles.text.font,
                  color: theme.textStyles.text.color,
                  fontSize: theme.textStyles.text.size
                }
              }
            })
          });
        }
        const questionItem$5 = "_questionItem_1sx0f_1";
        const styles$J = {
          questionItem: questionItem$5
        };
        function EmailQuestionDesign({
          code
        }) {
          var _state$validation2, _state$validation2$va, _state$content2, _state$content2$hint;
          const theme = useTheme();
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const lang = useSelector(state2 => {
            return state2.designState.langInfo.lang;
          });
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            className: styles$J.questionItem,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
              disabled: true,
              variant: "standard",
              required: (_state$validation2 = state.validation) !== null && _state$validation2 !== void 0 && (_state$validation2$va = _state$validation2.validation_required) !== null && _state$validation2$va !== void 0 && _state$validation2$va.isActive ? true : false,
              label: state.showHint && (((_state$content2 = state.content) === null || _state$content2 === void 0 ? void 0 : (_state$content2$hint = _state$content2.hint) === null || _state$content2$hint === void 0 ? void 0 : _state$content2$hint[lang]) || ""),
              InputProps: {
                sx: {
                  fontFamily: theme.textStyles.text.font,
                  color: theme.textStyles.text.color,
                  fontSize: theme.textStyles.text.size
                }
              },
              value: ""
            })
          });
        }
        const questionItem$4 = "_questionItem_169qj_1";
        const styles$I = {
          questionItem: questionItem$4
        };
        function NumberQuestionDesign({
          code
        }) {
          var _state$validation3, _state$validation3$va, _state$content3, _state$content3$hint;
          const theme = useTheme();
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const lang = useSelector(state2 => {
            return state2.designState.langInfo.lang;
          });
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            className: styles$I.questionItem,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
              disabled: true,
              variant: "standard",
              required: (_state$validation3 = state.validation) !== null && _state$validation3 !== void 0 && (_state$validation3$va = _state$validation3.validation_required) !== null && _state$validation3$va !== void 0 && _state$validation3$va.isActive ? true : false,
              label: state.showHint && (((_state$content3 = state.content) === null || _state$content3 === void 0 ? void 0 : (_state$content3$hint = _state$content3.hint) === null || _state$content3$hint === void 0 ? void 0 : _state$content3$hint[lang]) || ""),
              value: "",
              InputProps: {
                sx: {
                  fontFamily: theme.textStyles.text.font,
                  color: theme.textStyles.text.color,
                  fontSize: theme.textStyles.text.size
                }
              }
            })
          });
        }
        const questionItem$3 = "_questionItem_13fbu_1";
        const paragraph = "_paragraph_13fbu_15";
        const wordCount = "_wordCount_13fbu_19";
        const styles$H = {
          questionItem: questionItem$3,
          paragraph: paragraph,
          wordCount: wordCount
        };
        function ParagraphQuestionDesign({
          code,
          t
        }) {
          var _state$validation4, _state$validation4$va, _state$content4, _state$content4$hint;
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const lang = useSelector(state2 => {
            return state2.designState.langInfo.lang;
          });
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            className: styles$H.questionItem,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(TextareaAutosize, {
              disabled: true,
              className: styles$H.paragraph,
              required: (_state$validation4 = state.validation) !== null && _state$validation4 !== void 0 && (_state$validation4$va = _state$validation4.validation_required) !== null && _state$validation4$va !== void 0 && _state$validation4$va.isActive ? true : false,
              placeholder: state.showHint && (((_state$content4 = state.content) === null || _state$content4 === void 0 ? void 0 : (_state$content4$hint = _state$content4.hint) === null || _state$content4$hint === void 0 ? void 0 : _state$content4$hint[lang]) || ""),
              minRows: state.minRows || 2,
              value: ""
            }), state.showWordCount ? /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: styles$H.wordCount,
              children: /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                children: t("word_count", {
                  lng: lang,
                  count: 0
                })
              })
            }) : ""]
          });
        }
        const textDescriptionContent = "_textDescriptionContent_meegl_1";
        const groupQuestion = "_groupQuestion_meegl_7";
        const titleQuestion = "_titleQuestion_meegl_19";
        const questionWrapper = "_questionWrapper_meegl_28";
        const inputQuestionTitle = "_inputQuestionTitle_meegl_32";
        const inputQuestionDescription = "_inputQuestionDescription_meegl_38";
        const moveBox$1 = "_moveBox_meegl_42";
        const styles$G = {
          textDescriptionContent: textDescriptionContent,
          groupQuestion: groupQuestion,
          titleQuestion: titleQuestion,
          questionWrapper: questionWrapper,
          inputQuestionTitle: inputQuestionTitle,
          inputQuestionDescription: inputQuestionDescription,
          moveBox: moveBox$1
        };
        const fullWidth = "_fullWidth_1dvff_1";
        const toolbarClass = "_toolbarClass_1dvff_6";
        const noPadding = "_noPadding_1dvff_12";
        const placeholder$2 = "_placeholder_1dvff_25";
        const styles$F = {
          fullWidth: fullWidth,
          toolbarClass: toolbarClass,
          "rdw-editor-toolbar": "_rdw-editor-toolbar_1dvff_6",
          noPadding: noPadding,
          placeholder: placeholder$2
        };
        const ContentEditor$3 = '';
        const quill_snow = '';

        /**
         * Removes all key-value entries from the list cache.
         *
         * @private
         * @name clear
         * @memberOf ListCache
         */

        function listCacheClear$2() {
          this.__data__ = [];
          this.size = 0;
        }
        var _listCacheClear = listCacheClear$2;

        /**
         * Performs a
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * comparison between two values to determine if they are equivalent.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'a': 1 };
         * var other = { 'a': 1 };
         *
         * _.eq(object, object);
         * // => true
         *
         * _.eq(object, other);
         * // => false
         *
         * _.eq('a', 'a');
         * // => true
         *
         * _.eq('a', Object('a'));
         * // => false
         *
         * _.eq(NaN, NaN);
         * // => true
         */

        function eq$6(value, other) {
          return value === other || value !== value && other !== other;
        }
        var eq_1 = eq$6;
        var eq$5 = eq_1;

        /**
         * Gets the index at which the `key` is found in `array` of key-value pairs.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} key The key to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function assocIndexOf$5(array, key) {
          var length = array.length;
          while (length--) {
            if (eq$5(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        var _assocIndexOf = assocIndexOf$5;
        var assocIndexOf$4 = _assocIndexOf;

        /** Used for built-in method references. */
        var arrayProto$1 = Array.prototype;

        /** Built-in value references. */
        var splice$1 = arrayProto$1.splice;

        /**
         * Removes `key` and its value from the list cache.
         *
         * @private
         * @name delete
         * @memberOf ListCache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function listCacheDelete$2(key) {
          var data = this.__data__,
            index = assocIndexOf$4(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice$1.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        var _listCacheDelete = listCacheDelete$2;
        var assocIndexOf$3 = _assocIndexOf;

        /**
         * Gets the list cache value for `key`.
         *
         * @private
         * @name get
         * @memberOf ListCache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function listCacheGet$2(key) {
          var data = this.__data__,
            index = assocIndexOf$3(data, key);
          return index < 0 ? undefined : data[index][1];
        }
        var _listCacheGet = listCacheGet$2;
        var assocIndexOf$2 = _assocIndexOf;

        /**
         * Checks if a list cache value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf ListCache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function listCacheHas$2(key) {
          return assocIndexOf$2(this.__data__, key) > -1;
        }
        var _listCacheHas = listCacheHas$2;
        var assocIndexOf$1 = _assocIndexOf;

        /**
         * Sets the list cache `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf ListCache
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the list cache instance.
         */
        function listCacheSet$2(key, value) {
          var data = this.__data__,
            index = assocIndexOf$1(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        var _listCacheSet = listCacheSet$2;
        var listCacheClear$1 = _listCacheClear,
          listCacheDelete$1 = _listCacheDelete,
          listCacheGet$1 = _listCacheGet,
          listCacheHas$1 = _listCacheHas,
          listCacheSet$1 = _listCacheSet;

        /**
         * Creates an list cache object.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function ListCache$5(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        // Add methods to `ListCache`.
        ListCache$5.prototype.clear = listCacheClear$1;
        ListCache$5.prototype['delete'] = listCacheDelete$1;
        ListCache$5.prototype.get = listCacheGet$1;
        ListCache$5.prototype.has = listCacheHas$1;
        ListCache$5.prototype.set = listCacheSet$1;
        var _ListCache = ListCache$5;
        var ListCache$4 = _ListCache;

        /**
         * Removes all key-value entries from the stack.
         *
         * @private
         * @name clear
         * @memberOf Stack
         */
        function stackClear$2() {
          this.__data__ = new ListCache$4();
          this.size = 0;
        }
        var _stackClear = stackClear$2;

        /**
         * Removes `key` and its value from the stack.
         *
         * @private
         * @name delete
         * @memberOf Stack
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */

        function stackDelete$2(key) {
          var data = this.__data__,
            result = data['delete'](key);
          this.size = data.size;
          return result;
        }
        var _stackDelete = stackDelete$2;

        /**
         * Gets the stack value for `key`.
         *
         * @private
         * @name get
         * @memberOf Stack
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */

        function stackGet$2(key) {
          return this.__data__.get(key);
        }
        var _stackGet = stackGet$2;

        /**
         * Checks if a stack value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf Stack
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */

        function stackHas$2(key) {
          return this.__data__.has(key);
        }
        var _stackHas = stackHas$2;

        /** Detect free variable `global` from Node.js. */

        var freeGlobal$3 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
        var _freeGlobal = freeGlobal$3;
        var freeGlobal$2 = _freeGlobal;

        /** Detect free variable `self`. */
        var freeSelf$1 = typeof self == 'object' && self && self.Object === Object && self;

        /** Used as a reference to the global object. */
        var root$b = freeGlobal$2 || freeSelf$1 || Function('return this')();
        var _root = root$b;
        var root$a = _root;

        /** Built-in value references. */
        var Symbol$9 = root$a.Symbol;
        var _Symbol = Symbol$9;
        var Symbol$8 = _Symbol;

        /** Used for built-in method references. */
        var objectProto$u = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$o = objectProto$u.hasOwnProperty;

        /**
         * Used to resolve the
         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
         * of values.
         */
        var nativeObjectToString$3 = objectProto$u.toString;

        /** Built-in value references. */
        var symToStringTag$3 = Symbol$8 ? Symbol$8.toStringTag : undefined;

        /**
         * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the raw `toStringTag`.
         */
        function getRawTag$2(value) {
          var isOwn = hasOwnProperty$o.call(value, symToStringTag$3),
            tag = value[symToStringTag$3];
          try {
            value[symToStringTag$3] = undefined;
            var unmasked = true;
          } catch (e) {}
          var result = nativeObjectToString$3.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag$3] = tag;
            } else {
              delete value[symToStringTag$3];
            }
          }
          return result;
        }
        var _getRawTag = getRawTag$2;

        /** Used for built-in method references. */

        var objectProto$t = Object.prototype;

        /**
         * Used to resolve the
         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
         * of values.
         */
        var nativeObjectToString$2 = objectProto$t.toString;

        /**
         * Converts `value` to a string using `Object.prototype.toString`.
         *
         * @private
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         */
        function objectToString$2(value) {
          return nativeObjectToString$2.call(value);
        }
        var _objectToString = objectToString$2;
        var Symbol$7 = _Symbol,
          getRawTag$1 = _getRawTag,
          objectToString$1 = _objectToString;

        /** `Object#toString` result references. */
        var nullTag$1 = '[object Null]',
          undefinedTag$1 = '[object Undefined]';

        /** Built-in value references. */
        var symToStringTag$2 = Symbol$7 ? Symbol$7.toStringTag : undefined;

        /**
         * The base implementation of `getTag` without fallbacks for buggy environments.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */
        function baseGetTag$8(value) {
          if (value == null) {
            return value === undefined ? undefinedTag$1 : nullTag$1;
          }
          return symToStringTag$2 && symToStringTag$2 in Object(value) ? getRawTag$1(value) : objectToString$1(value);
        }
        var _baseGetTag = baseGetTag$8;

        /**
         * Checks if `value` is the
         * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
         * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
         * @example
         *
         * _.isObject({});
         * // => true
         *
         * _.isObject([1, 2, 3]);
         * // => true
         *
         * _.isObject(_.noop);
         * // => true
         *
         * _.isObject(null);
         * // => false
         */

        function isObject$h(value) {
          var type = typeof value;
          return value != null && (type == 'object' || type == 'function');
        }
        var isObject_1 = isObject$h;
        var baseGetTag$7 = _baseGetTag,
          isObject$g = isObject_1;

        /** `Object#toString` result references. */
        var asyncTag$1 = '[object AsyncFunction]',
          funcTag$4 = '[object Function]',
          genTag$2 = '[object GeneratorFunction]',
          proxyTag$1 = '[object Proxy]';

        /**
         * Checks if `value` is classified as a `Function` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a function, else `false`.
         * @example
         *
         * _.isFunction(_);
         * // => true
         *
         * _.isFunction(/abc/);
         * // => false
         */
        function isFunction$5(value) {
          if (!isObject$g(value)) {
            return false;
          }
          // The use of `Object#toString` avoids issues with the `typeof` operator
          // in Safari 9 which returns 'object' for typed arrays and other constructors.
          var tag = baseGetTag$7(value);
          return tag == funcTag$4 || tag == genTag$2 || tag == asyncTag$1 || tag == proxyTag$1;
        }
        var isFunction_1 = isFunction$5;
        var root$9 = _root;

        /** Used to detect overreaching core-js shims. */
        var coreJsData$3 = root$9['__core-js_shared__'];
        var _coreJsData = coreJsData$3;
        var coreJsData$2 = _coreJsData;

        /** Used to detect methods masquerading as native. */
        var maskSrcKey$1 = function () {
          var uid = /[^.]+$/.exec(coreJsData$2 && coreJsData$2.keys && coreJsData$2.keys.IE_PROTO || '');
          return uid ? 'Symbol(src)_1.' + uid : '';
        }();

        /**
         * Checks if `func` has its source masked.
         *
         * @private
         * @param {Function} func The function to check.
         * @returns {boolean} Returns `true` if `func` is masked, else `false`.
         */
        function isMasked$2(func) {
          return !!maskSrcKey$1 && maskSrcKey$1 in func;
        }
        var _isMasked = isMasked$2;

        /** Used for built-in method references. */

        var funcProto$5 = Function.prototype;

        /** Used to resolve the decompiled source of functions. */
        var funcToString$5 = funcProto$5.toString;

        /**
         * Converts `func` to its source code.
         *
         * @private
         * @param {Function} func The function to convert.
         * @returns {string} Returns the source code.
         */
        function toSource$3(func) {
          if (func != null) {
            try {
              return funcToString$5.call(func);
            } catch (e) {}
            try {
              return func + '';
            } catch (e) {}
          }
          return '';
        }
        var _toSource = toSource$3;
        var isFunction$4 = isFunction_1,
          isMasked$1 = _isMasked,
          isObject$f = isObject_1,
          toSource$2 = _toSource;

        /**
         * Used to match `RegExp`
         * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
         */
        var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;

        /** Used to detect host constructors (Safari). */
        var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;

        /** Used for built-in method references. */
        var funcProto$4 = Function.prototype,
          objectProto$s = Object.prototype;

        /** Used to resolve the decompiled source of functions. */
        var funcToString$4 = funcProto$4.toString;

        /** Used to check objects for own properties. */
        var hasOwnProperty$n = objectProto$s.hasOwnProperty;

        /** Used to detect if a method is native. */
        var reIsNative$1 = RegExp('^' + funcToString$4.call(hasOwnProperty$n).replace(reRegExpChar$1, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

        /**
         * The base implementation of `_.isNative` without bad shim checks.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a native function,
         *  else `false`.
         */
        function baseIsNative$2(value) {
          if (!isObject$f(value) || isMasked$1(value)) {
            return false;
          }
          var pattern = isFunction$4(value) ? reIsNative$1 : reIsHostCtor$1;
          return pattern.test(toSource$2(value));
        }
        var _baseIsNative = baseIsNative$2;

        /**
         * Gets the value at `key` of `object`.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {string} key The key of the property to get.
         * @returns {*} Returns the property value.
         */

        function getValue$2(object, key) {
          return object == null ? undefined : object[key];
        }
        var _getValue = getValue$2;
        var baseIsNative$1 = _baseIsNative,
          getValue$1 = _getValue;

        /**
         * Gets the native function at `key` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the method to get.
         * @returns {*} Returns the function if it's native, else `undefined`.
         */
        function getNative$8(object, key) {
          var value = getValue$1(object, key);
          return baseIsNative$1(value) ? value : undefined;
        }
        var _getNative = getNative$8;
        var getNative$7 = _getNative,
          root$8 = _root;

        /* Built-in method references that are verified to be native. */
        var Map$6 = getNative$7(root$8, 'Map');
        var _Map = Map$6;
        var getNative$6 = _getNative;

        /* Built-in method references that are verified to be native. */
        var nativeCreate$6 = getNative$6(Object, 'create');
        var _nativeCreate = nativeCreate$6;
        var nativeCreate$5 = _nativeCreate;

        /**
         * Removes all key-value entries from the hash.
         *
         * @private
         * @name clear
         * @memberOf Hash
         */
        function hashClear$2() {
          this.__data__ = nativeCreate$5 ? nativeCreate$5(null) : {};
          this.size = 0;
        }
        var _hashClear = hashClear$2;

        /**
         * Removes `key` and its value from the hash.
         *
         * @private
         * @name delete
         * @memberOf Hash
         * @param {Object} hash The hash to modify.
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */

        function hashDelete$2(key) {
          var result = this.has(key) && delete this.__data__[key];
          this.size -= result ? 1 : 0;
          return result;
        }
        var _hashDelete = hashDelete$2;
        var nativeCreate$4 = _nativeCreate;

        /** Used to stand-in for `undefined` hash values. */
        var HASH_UNDEFINED$5 = '__lodash_hash_undefined__';

        /** Used for built-in method references. */
        var objectProto$r = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$m = objectProto$r.hasOwnProperty;

        /**
         * Gets the hash value for `key`.
         *
         * @private
         * @name get
         * @memberOf Hash
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function hashGet$2(key) {
          var data = this.__data__;
          if (nativeCreate$4) {
            var result = data[key];
            return result === HASH_UNDEFINED$5 ? undefined : result;
          }
          return hasOwnProperty$m.call(data, key) ? data[key] : undefined;
        }
        var _hashGet = hashGet$2;
        var nativeCreate$3 = _nativeCreate;

        /** Used for built-in method references. */
        var objectProto$q = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$l = objectProto$q.hasOwnProperty;

        /**
         * Checks if a hash value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf Hash
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function hashHas$2(key) {
          var data = this.__data__;
          return nativeCreate$3 ? data[key] !== undefined : hasOwnProperty$l.call(data, key);
        }
        var _hashHas = hashHas$2;
        var nativeCreate$2 = _nativeCreate;

        /** Used to stand-in for `undefined` hash values. */
        var HASH_UNDEFINED$4 = '__lodash_hash_undefined__';

        /**
         * Sets the hash `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf Hash
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the hash instance.
         */
        function hashSet$2(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate$2 && value === undefined ? HASH_UNDEFINED$4 : value;
          return this;
        }
        var _hashSet = hashSet$2;
        var hashClear$1 = _hashClear,
          hashDelete$1 = _hashDelete,
          hashGet$1 = _hashGet,
          hashHas$1 = _hashHas,
          hashSet$1 = _hashSet;

        /**
         * Creates a hash object.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function Hash$2(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        // Add methods to `Hash`.
        Hash$2.prototype.clear = hashClear$1;
        Hash$2.prototype['delete'] = hashDelete$1;
        Hash$2.prototype.get = hashGet$1;
        Hash$2.prototype.has = hashHas$1;
        Hash$2.prototype.set = hashSet$1;
        var _Hash = Hash$2;
        var Hash$1 = _Hash,
          ListCache$3 = _ListCache,
          Map$5 = _Map;

        /**
         * Removes all key-value entries from the map.
         *
         * @private
         * @name clear
         * @memberOf MapCache
         */
        function mapCacheClear$2() {
          this.size = 0;
          this.__data__ = {
            'hash': new Hash$1(),
            'map': new (Map$5 || ListCache$3)(),
            'string': new Hash$1()
          };
        }
        var _mapCacheClear = mapCacheClear$2;

        /**
         * Checks if `value` is suitable for use as unique object key.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
         */

        function isKeyable$2(value) {
          var type = typeof value;
          return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
        }
        var _isKeyable = isKeyable$2;
        var isKeyable$1 = _isKeyable;

        /**
         * Gets the data for `map`.
         *
         * @private
         * @param {Object} map The map to query.
         * @param {string} key The reference key.
         * @returns {*} Returns the map data.
         */
        function getMapData$5(map, key) {
          var data = map.__data__;
          return isKeyable$1(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
        }
        var _getMapData = getMapData$5;
        var getMapData$4 = _getMapData;

        /**
         * Removes `key` and its value from the map.
         *
         * @private
         * @name delete
         * @memberOf MapCache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function mapCacheDelete$2(key) {
          var result = getMapData$4(this, key)['delete'](key);
          this.size -= result ? 1 : 0;
          return result;
        }
        var _mapCacheDelete = mapCacheDelete$2;
        var getMapData$3 = _getMapData;

        /**
         * Gets the map value for `key`.
         *
         * @private
         * @name get
         * @memberOf MapCache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function mapCacheGet$2(key) {
          return getMapData$3(this, key).get(key);
        }
        var _mapCacheGet = mapCacheGet$2;
        var getMapData$2 = _getMapData;

        /**
         * Checks if a map value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf MapCache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function mapCacheHas$2(key) {
          return getMapData$2(this, key).has(key);
        }
        var _mapCacheHas = mapCacheHas$2;
        var getMapData$1 = _getMapData;

        /**
         * Sets the map `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf MapCache
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the map cache instance.
         */
        function mapCacheSet$2(key, value) {
          var data = getMapData$1(this, key),
            size = data.size;
          data.set(key, value);
          this.size += data.size == size ? 0 : 1;
          return this;
        }
        var _mapCacheSet = mapCacheSet$2;
        var mapCacheClear$1 = _mapCacheClear,
          mapCacheDelete$1 = _mapCacheDelete,
          mapCacheGet$1 = _mapCacheGet,
          mapCacheHas$1 = _mapCacheHas,
          mapCacheSet$1 = _mapCacheSet;

        /**
         * Creates a map cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function MapCache$4(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        // Add methods to `MapCache`.
        MapCache$4.prototype.clear = mapCacheClear$1;
        MapCache$4.prototype['delete'] = mapCacheDelete$1;
        MapCache$4.prototype.get = mapCacheGet$1;
        MapCache$4.prototype.has = mapCacheHas$1;
        MapCache$4.prototype.set = mapCacheSet$1;
        var _MapCache = MapCache$4;
        var ListCache$2 = _ListCache,
          Map$4 = _Map,
          MapCache$3 = _MapCache;

        /** Used as the size to enable large array optimizations. */
        var LARGE_ARRAY_SIZE$1 = 200;

        /**
         * Sets the stack `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf Stack
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the stack cache instance.
         */
        function stackSet$2(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache$2) {
            var pairs = data.__data__;
            if (!Map$4 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache$3(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        var _stackSet = stackSet$2;
        var ListCache$1 = _ListCache,
          stackClear$1 = _stackClear,
          stackDelete$1 = _stackDelete,
          stackGet$1 = _stackGet,
          stackHas$1 = _stackHas,
          stackSet$1 = _stackSet;

        /**
         * Creates a stack cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function Stack$5(entries) {
          var data = this.__data__ = new ListCache$1(entries);
          this.size = data.size;
        }

        // Add methods to `Stack`.
        Stack$5.prototype.clear = stackClear$1;
        Stack$5.prototype['delete'] = stackDelete$1;
        Stack$5.prototype.get = stackGet$1;
        Stack$5.prototype.has = stackHas$1;
        Stack$5.prototype.set = stackSet$1;
        var _Stack = Stack$5;

        /** Used to stand-in for `undefined` hash values. */

        var HASH_UNDEFINED$3 = '__lodash_hash_undefined__';

        /**
         * Adds `value` to the array cache.
         *
         * @private
         * @name add
         * @memberOf SetCache
         * @alias push
         * @param {*} value The value to cache.
         * @returns {Object} Returns the cache instance.
         */
        function setCacheAdd$2(value) {
          this.__data__.set(value, HASH_UNDEFINED$3);
          return this;
        }
        var _setCacheAdd = setCacheAdd$2;

        /**
         * Checks if `value` is in the array cache.
         *
         * @private
         * @name has
         * @memberOf SetCache
         * @param {*} value The value to search for.
         * @returns {number} Returns `true` if `value` is found, else `false`.
         */

        function setCacheHas$2(value) {
          return this.__data__.has(value);
        }
        var _setCacheHas = setCacheHas$2;
        var MapCache$2 = _MapCache,
          setCacheAdd$1 = _setCacheAdd,
          setCacheHas$1 = _setCacheHas;

        /**
         *
         * Creates an array cache object to store unique values.
         *
         * @private
         * @constructor
         * @param {Array} [values] The values to cache.
         */
        function SetCache$2(values) {
          var index = -1,
            length = values == null ? 0 : values.length;
          this.__data__ = new MapCache$2();
          while (++index < length) {
            this.add(values[index]);
          }
        }

        // Add methods to `SetCache`.
        SetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd$1;
        SetCache$2.prototype.has = setCacheHas$1;
        var _SetCache = SetCache$2;

        /**
         * A specialized version of `_.some` for arrays without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         */

        function arraySome$2(array, predicate) {
          var index = -1,
            length = array == null ? 0 : array.length;
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
        var _arraySome = arraySome$2;

        /**
         * Checks if a `cache` value for `key` exists.
         *
         * @private
         * @param {Object} cache The cache to query.
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */

        function cacheHas$2(cache, key) {
          return cache.has(key);
        }
        var _cacheHas = cacheHas$2;
        var SetCache$1 = _SetCache,
          arraySome$1 = _arraySome,
          cacheHas$1 = _cacheHas;

        /** Used to compose bitmasks for value comparisons. */
        var COMPARE_PARTIAL_FLAG$b = 1,
          COMPARE_UNORDERED_FLAG$7 = 2;

        /**
         * A specialized version of `baseIsEqualDeep` for arrays with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Array} array The array to compare.
         * @param {Array} other The other array to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `array` and `other` objects.
         * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
         */
        function equalArrays$3(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$b,
            arrLength = array.length,
            othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          // Check that cyclic values are equal.
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1,
            result = true,
            seen = bitmask & COMPARE_UNORDERED_FLAG$7 ? new SetCache$1() : undefined;
          stack.set(array, other);
          stack.set(other, array);

          // Ignore non-index properties.
          while (++index < arrLength) {
            var arrValue = array[index],
              othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined) {
              if (compared) {
                continue;
              }
              result = false;
              break;
            }
            // Recursively compare arrays (susceptible to call stack limits).
            if (seen) {
              if (!arraySome$1(other, function (othValue, othIndex) {
                if (!cacheHas$1(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result = false;
              break;
            }
          }
          stack['delete'](array);
          stack['delete'](other);
          return result;
        }
        var _equalArrays = equalArrays$3;
        var root$7 = _root;

        /** Built-in value references. */
        var Uint8Array$4 = root$7.Uint8Array;
        var _Uint8Array = Uint8Array$4;

        /**
         * Converts `map` to its key-value pairs.
         *
         * @private
         * @param {Object} map The map to convert.
         * @returns {Array} Returns the key-value pairs.
         */

        function mapToArray$2(map) {
          var index = -1,
            result = Array(map.size);
          map.forEach(function (value, key) {
            result[++index] = [key, value];
          });
          return result;
        }
        var _mapToArray = mapToArray$2;

        /**
         * Converts `set` to an array of its values.
         *
         * @private
         * @param {Object} set The set to convert.
         * @returns {Array} Returns the values.
         */

        function setToArray$2(set) {
          var index = -1,
            result = Array(set.size);
          set.forEach(function (value) {
            result[++index] = value;
          });
          return result;
        }
        var _setToArray = setToArray$2;
        var Symbol$6 = _Symbol,
          Uint8Array$3 = _Uint8Array,
          eq$4 = eq_1,
          equalArrays$2 = _equalArrays,
          mapToArray$1 = _mapToArray,
          setToArray$1 = _setToArray;

        /** Used to compose bitmasks for value comparisons. */
        var COMPARE_PARTIAL_FLAG$a = 1,
          COMPARE_UNORDERED_FLAG$6 = 2;

        /** `Object#toString` result references. */
        var boolTag$5 = '[object Boolean]',
          dateTag$5 = '[object Date]',
          errorTag$4 = '[object Error]',
          mapTag$8 = '[object Map]',
          numberTag$5 = '[object Number]',
          regexpTag$5 = '[object RegExp]',
          setTag$8 = '[object Set]',
          stringTag$6 = '[object String]',
          symbolTag$5 = '[object Symbol]';
        var arrayBufferTag$5 = '[object ArrayBuffer]',
          dataViewTag$7 = '[object DataView]';

        /** Used to convert symbols to primitives and strings. */
        var symbolProto$4 = Symbol$6 ? Symbol$6.prototype : undefined,
          symbolValueOf$2 = symbolProto$4 ? symbolProto$4.valueOf : undefined;

        /**
         * A specialized version of `baseIsEqualDeep` for comparing objects of
         * the same `toStringTag`.
         *
         * **Note:** This function only supports comparing values with tags of
         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {string} tag The `toStringTag` of the objects to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalByTag$2(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag$7:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag$5:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$3(object), new Uint8Array$3(other))) {
                return false;
              }
              return true;
            case boolTag$5:
            case dateTag$5:
            case numberTag$5:
              // Coerce booleans to `1` or `0` and dates to milliseconds.
              // Invalid dates are coerced to `NaN`.
              return eq$4(+object, +other);
            case errorTag$4:
              return object.name == other.name && object.message == other.message;
            case regexpTag$5:
            case stringTag$6:
              // Coerce regexes to strings and treat strings, primitives and objects,
              // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
              // for more details.
              return object == other + '';
            case mapTag$8:
              var convert = mapToArray$1;
            case setTag$8:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG$a;
              convert || (convert = setToArray$1);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              // Assume cyclic values are equal.
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG$6;

              // Recursively compare objects (susceptible to call stack limits).
              stack.set(object, other);
              var result = equalArrays$2(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack['delete'](object);
              return result;
            case symbolTag$5:
              if (symbolValueOf$2) {
                return symbolValueOf$2.call(object) == symbolValueOf$2.call(other);
              }
          }
          return false;
        }
        var _equalByTag = equalByTag$2;

        /**
         * Appends the elements of `values` to `array`.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {Array} values The values to append.
         * @returns {Array} Returns `array`.
         */

        function arrayPush$4(array, values) {
          var index = -1,
            length = values.length,
            offset = array.length;
          while (++index < length) {
            array[offset + index] = values[index];
          }
          return array;
        }
        var _arrayPush = arrayPush$4;

        /**
         * Checks if `value` is classified as an `Array` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array, else `false`.
         * @example
         *
         * _.isArray([1, 2, 3]);
         * // => true
         *
         * _.isArray(document.body.children);
         * // => false
         *
         * _.isArray('abc');
         * // => false
         *
         * _.isArray(_.noop);
         * // => false
         */

        var isArray$g = Array.isArray;
        var isArray_1 = isArray$g;
        var arrayPush$3 = _arrayPush,
          isArray$f = isArray_1;

        /**
         * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
         * `keysFunc` and `symbolsFunc` to get the enumerable property names and
         * symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @param {Function} symbolsFunc The function to get the symbols of `object`.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function baseGetAllKeys$3(object, keysFunc, symbolsFunc) {
          var result = keysFunc(object);
          return isArray$f(object) ? result : arrayPush$3(result, symbolsFunc(object));
        }
        var _baseGetAllKeys = baseGetAllKeys$3;

        /**
         * A specialized version of `_.filter` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         */

        function arrayFilter$2(array, predicate) {
          var index = -1,
            length = array == null ? 0 : array.length,
            resIndex = 0,
            result = [];
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        var _arrayFilter = arrayFilter$2;

        /**
         * This method returns a new empty array.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {Array} Returns the new empty array.
         * @example
         *
         * var arrays = _.times(2, _.stubArray);
         *
         * console.log(arrays);
         * // => [[], []]
         *
         * console.log(arrays[0] === arrays[1]);
         * // => false
         */

        function stubArray$3() {
          return [];
        }
        var stubArray_1 = stubArray$3;
        var arrayFilter$1 = _arrayFilter,
          stubArray$2 = stubArray_1;

        /** Used for built-in method references. */
        var objectProto$p = Object.prototype;

        /** Built-in value references. */
        var propertyIsEnumerable$3 = objectProto$p.propertyIsEnumerable;

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeGetSymbols$2 = Object.getOwnPropertySymbols;

        /**
         * Creates an array of the own enumerable symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of symbols.
         */
        var getSymbols$5 = !nativeGetSymbols$2 ? stubArray$2 : function (object) {
          if (object == null) {
            return [];
          }
          object = Object(object);
          return arrayFilter$1(nativeGetSymbols$2(object), function (symbol) {
            return propertyIsEnumerable$3.call(object, symbol);
          });
        };
        var _getSymbols = getSymbols$5;

        /**
         * The base implementation of `_.times` without support for iteratee shorthands
         * or max array length checks.
         *
         * @private
         * @param {number} n The number of times to invoke `iteratee`.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the array of results.
         */

        function baseTimes$2(n, iteratee) {
          var index = -1,
            result = Array(n);
          while (++index < n) {
            result[index] = iteratee(index);
          }
          return result;
        }
        var _baseTimes = baseTimes$2;

        /**
         * Checks if `value` is object-like. A value is object-like if it's not `null`
         * and has a `typeof` result of "object".
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
         * @example
         *
         * _.isObjectLike({});
         * // => true
         *
         * _.isObjectLike([1, 2, 3]);
         * // => true
         *
         * _.isObjectLike(_.noop);
         * // => false
         *
         * _.isObjectLike(null);
         * // => false
         */

        function isObjectLike$b(value) {
          return value != null && typeof value == 'object';
        }
        var isObjectLike_1 = isObjectLike$b;
        var baseGetTag$6 = _baseGetTag,
          isObjectLike$a = isObjectLike_1;

        /** `Object#toString` result references. */
        var argsTag$6 = '[object Arguments]';

        /**
         * The base implementation of `_.isArguments`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         */
        function baseIsArguments$2(value) {
          return isObjectLike$a(value) && baseGetTag$6(value) == argsTag$6;
        }
        var _baseIsArguments = baseIsArguments$2;
        var baseIsArguments$1 = _baseIsArguments,
          isObjectLike$9 = isObjectLike_1;

        /** Used for built-in method references. */
        var objectProto$o = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$k = objectProto$o.hasOwnProperty;

        /** Built-in value references. */
        var propertyIsEnumerable$2 = objectProto$o.propertyIsEnumerable;

        /**
         * Checks if `value` is likely an `arguments` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         *  else `false`.
         * @example
         *
         * _.isArguments(function() { return arguments; }());
         * // => true
         *
         * _.isArguments([1, 2, 3]);
         * // => false
         */
        var isArguments$6 = baseIsArguments$1(function () {
          return arguments;
        }()) ? baseIsArguments$1 : function (value) {
          return isObjectLike$9(value) && hasOwnProperty$k.call(value, 'callee') && !propertyIsEnumerable$2.call(value, 'callee');
        };
        var isArguments_1 = isArguments$6;
        var isBuffer$6 = {
          exports: {}
        };

        /**
         * This method returns `false`.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {boolean} Returns `false`.
         * @example
         *
         * _.times(2, _.stubFalse);
         * // => [false, false]
         */

        function stubFalse$1() {
          return false;
        }
        var stubFalse_1 = stubFalse$1;
        isBuffer$6.exports;
        (function (module, exports) {
          var root = _root,
            stubFalse = stubFalse_1;

          /** Detect free variable `exports`. */
          var freeExports = exports && !exports.nodeType && exports;

          /** Detect free variable `module`. */
          var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

          /** Detect the popular CommonJS extension `module.exports`. */
          var moduleExports = freeModule && freeModule.exports === freeExports;

          /** Built-in value references. */
          var Buffer = moduleExports ? root.Buffer : undefined;

          /* Built-in method references for those with the same name as other `lodash` methods. */
          var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

          /**
           * Checks if `value` is a buffer.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
           * @example
           *
           * _.isBuffer(new Buffer(2));
           * // => true
           *
           * _.isBuffer(new Uint8Array(2));
           * // => false
           */
          var isBuffer = nativeIsBuffer || stubFalse;
          module.exports = isBuffer;
        })(isBuffer$6, isBuffer$6.exports);
        var isBufferExports = isBuffer$6.exports;

        /** Used as references for various `Number` constants. */

        var MAX_SAFE_INTEGER$3 = 9007199254740991;

        /** Used to detect unsigned integer values. */
        var reIsUint$1 = /^(?:0|[1-9]\d*)$/;

        /**
         * Checks if `value` is a valid array-like index.
         *
         * @private
         * @param {*} value The value to check.
         * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
         * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
         */
        function isIndex$5(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER$3 : length;
          return !!length && (type == 'number' || type != 'symbol' && reIsUint$1.test(value)) && value > -1 && value % 1 == 0 && value < length;
        }
        var _isIndex = isIndex$5;

        /** Used as references for various `Number` constants. */

        var MAX_SAFE_INTEGER$2 = 9007199254740991;

        /**
         * Checks if `value` is a valid array-like length.
         *
         * **Note:** This method is loosely based on
         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
         * @example
         *
         * _.isLength(3);
         * // => true
         *
         * _.isLength(Number.MIN_VALUE);
         * // => false
         *
         * _.isLength(Infinity);
         * // => false
         *
         * _.isLength('3');
         * // => false
         */
        function isLength$4(value) {
          return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$2;
        }
        var isLength_1 = isLength$4;
        var baseGetTag$5 = _baseGetTag,
          isLength$3 = isLength_1,
          isObjectLike$8 = isObjectLike_1;

        /** `Object#toString` result references. */
        var argsTag$5 = '[object Arguments]',
          arrayTag$4 = '[object Array]',
          boolTag$4 = '[object Boolean]',
          dateTag$4 = '[object Date]',
          errorTag$3 = '[object Error]',
          funcTag$3 = '[object Function]',
          mapTag$7 = '[object Map]',
          numberTag$4 = '[object Number]',
          objectTag$8 = '[object Object]',
          regexpTag$4 = '[object RegExp]',
          setTag$7 = '[object Set]',
          stringTag$5 = '[object String]',
          weakMapTag$4 = '[object WeakMap]';
        var arrayBufferTag$4 = '[object ArrayBuffer]',
          dataViewTag$6 = '[object DataView]',
          float32Tag$3 = '[object Float32Array]',
          float64Tag$3 = '[object Float64Array]',
          int8Tag$3 = '[object Int8Array]',
          int16Tag$3 = '[object Int16Array]',
          int32Tag$3 = '[object Int32Array]',
          uint8Tag$3 = '[object Uint8Array]',
          uint8ClampedTag$3 = '[object Uint8ClampedArray]',
          uint16Tag$3 = '[object Uint16Array]',
          uint32Tag$3 = '[object Uint32Array]';

        /** Used to identify `toStringTag` values of typed arrays. */
        var typedArrayTags$1 = {};
        typedArrayTags$1[float32Tag$3] = typedArrayTags$1[float64Tag$3] = typedArrayTags$1[int8Tag$3] = typedArrayTags$1[int16Tag$3] = typedArrayTags$1[int32Tag$3] = typedArrayTags$1[uint8Tag$3] = typedArrayTags$1[uint8ClampedTag$3] = typedArrayTags$1[uint16Tag$3] = typedArrayTags$1[uint32Tag$3] = true;
        typedArrayTags$1[argsTag$5] = typedArrayTags$1[arrayTag$4] = typedArrayTags$1[arrayBufferTag$4] = typedArrayTags$1[boolTag$4] = typedArrayTags$1[dataViewTag$6] = typedArrayTags$1[dateTag$4] = typedArrayTags$1[errorTag$3] = typedArrayTags$1[funcTag$3] = typedArrayTags$1[mapTag$7] = typedArrayTags$1[numberTag$4] = typedArrayTags$1[objectTag$8] = typedArrayTags$1[regexpTag$4] = typedArrayTags$1[setTag$7] = typedArrayTags$1[stringTag$5] = typedArrayTags$1[weakMapTag$4] = false;

        /**
         * The base implementation of `_.isTypedArray` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         */
        function baseIsTypedArray$2(value) {
          return isObjectLike$8(value) && isLength$3(value.length) && !!typedArrayTags$1[baseGetTag$5(value)];
        }
        var _baseIsTypedArray = baseIsTypedArray$2;

        /**
         * The base implementation of `_.unary` without support for storing metadata.
         *
         * @private
         * @param {Function} func The function to cap arguments for.
         * @returns {Function} Returns the new capped function.
         */

        function baseUnary$4(func) {
          return function (value) {
            return func(value);
          };
        }
        var _baseUnary = baseUnary$4;
        var _nodeUtil = {
          exports: {}
        };
        _nodeUtil.exports;
        (function (module, exports) {
          var freeGlobal = _freeGlobal;

          /** Detect free variable `exports`. */
          var freeExports = exports && !exports.nodeType && exports;

          /** Detect free variable `module`. */
          var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

          /** Detect the popular CommonJS extension `module.exports`. */
          var moduleExports = freeModule && freeModule.exports === freeExports;

          /** Detect free variable `process` from Node.js. */
          var freeProcess = moduleExports && freeGlobal.process;

          /** Used to access faster Node.js helpers. */
          var nodeUtil = function () {
            try {
              // Use `util.types` for Node.js 10+.
              var types = freeModule && freeModule.require && freeModule.require('util').types;
              if (types) {
                return types;
              }

              // Legacy `process.binding('util')` for Node.js < 10.
              return freeProcess && freeProcess.binding && freeProcess.binding('util');
            } catch (e) {}
          }();
          module.exports = nodeUtil;
        })(_nodeUtil, _nodeUtil.exports);
        var _nodeUtilExports = _nodeUtil.exports;
        var baseIsTypedArray$1 = _baseIsTypedArray,
          baseUnary$3 = _baseUnary,
          nodeUtil$4 = _nodeUtilExports;

        /* Node.js helper references. */
        var nodeIsTypedArray$1 = nodeUtil$4 && nodeUtil$4.isTypedArray;

        /**
         * Checks if `value` is classified as a typed array.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         * @example
         *
         * _.isTypedArray(new Uint8Array);
         * // => true
         *
         * _.isTypedArray([]);
         * // => false
         */
        var isTypedArray$5 = nodeIsTypedArray$1 ? baseUnary$3(nodeIsTypedArray$1) : baseIsTypedArray$1;
        var isTypedArray_1 = isTypedArray$5;
        var baseTimes$1 = _baseTimes,
          isArguments$5 = isArguments_1,
          isArray$e = isArray_1,
          isBuffer$5 = isBufferExports,
          isIndex$4 = _isIndex,
          isTypedArray$4 = isTypedArray_1;

        /** Used for built-in method references. */
        var objectProto$n = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$j = objectProto$n.hasOwnProperty;

        /**
         * Creates an array of the enumerable property names of the array-like `value`.
         *
         * @private
         * @param {*} value The value to query.
         * @param {boolean} inherited Specify returning inherited property names.
         * @returns {Array} Returns the array of property names.
         */
        function arrayLikeKeys$3(value, inherited) {
          var isArr = isArray$e(value),
            isArg = !isArr && isArguments$5(value),
            isBuff = !isArr && !isArg && isBuffer$5(value),
            isType = !isArr && !isArg && !isBuff && isTypedArray$4(value),
            skipIndexes = isArr || isArg || isBuff || isType,
            result = skipIndexes ? baseTimes$1(value.length, String) : [],
            length = result.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty$j.call(value, key)) && !(skipIndexes && (
            // Safari 9 has enumerable `arguments.length` in strict mode.
            key == 'length' ||
            // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == 'offset' || key == 'parent') ||
            // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
            // Skip index properties.
            isIndex$4(key, length)))) {
              result.push(key);
            }
          }
          return result;
        }
        var _arrayLikeKeys = arrayLikeKeys$3;

        /** Used for built-in method references. */

        var objectProto$m = Object.prototype;

        /**
         * Checks if `value` is likely a prototype object.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
         */
        function isPrototype$4(value) {
          var Ctor = value && value.constructor,
            proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$m;
          return value === proto;
        }
        var _isPrototype = isPrototype$4;

        /**
         * Creates a unary function that invokes `func` with its argument transformed.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {Function} transform The argument transform.
         * @returns {Function} Returns the new function.
         */

        function overArg$3(func, transform) {
          return function (arg) {
            return func(transform(arg));
          };
        }
        var _overArg = overArg$3;
        var overArg$2 = _overArg;

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeKeys$3 = overArg$2(Object.keys, Object);
        var _nativeKeys = nativeKeys$3;
        var isPrototype$3 = _isPrototype,
          nativeKeys$2 = _nativeKeys;

        /** Used for built-in method references. */
        var objectProto$l = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$i = objectProto$l.hasOwnProperty;

        /**
         * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function baseKeys$2(object) {
          if (!isPrototype$3(object)) {
            return nativeKeys$2(object);
          }
          var result = [];
          for (var key in Object(object)) {
            if (hasOwnProperty$i.call(object, key) && key != 'constructor') {
              result.push(key);
            }
          }
          return result;
        }
        var _baseKeys = baseKeys$2;
        var isFunction$3 = isFunction_1,
          isLength$2 = isLength_1;

        /**
         * Checks if `value` is array-like. A value is considered array-like if it's
         * not a function and has a `value.length` that's an integer greater than or
         * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
         * @example
         *
         * _.isArrayLike([1, 2, 3]);
         * // => true
         *
         * _.isArrayLike(document.body.children);
         * // => true
         *
         * _.isArrayLike('abc');
         * // => true
         *
         * _.isArrayLike(_.noop);
         * // => false
         */
        function isArrayLike$7(value) {
          return value != null && isLength$2(value.length) && !isFunction$3(value);
        }
        var isArrayLike_1 = isArrayLike$7;
        var arrayLikeKeys$2 = _arrayLikeKeys,
          baseKeys$1 = _baseKeys,
          isArrayLike$6 = isArrayLike_1;

        /**
         * Creates an array of the own enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects. See the
         * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
         * for more details.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keys(new Foo);
         * // => ['a', 'b'] (iteration order is not guaranteed)
         *
         * _.keys('hi');
         * // => ['0', '1']
         */
        function keys$7(object) {
          return isArrayLike$6(object) ? arrayLikeKeys$2(object) : baseKeys$1(object);
        }
        var keys_1 = keys$7;
        const keys$8 = /*@__PURE__*/getDefaultExportFromCjs(keys_1);
        var baseGetAllKeys$2 = _baseGetAllKeys,
          getSymbols$4 = _getSymbols,
          keys$6 = keys_1;

        /**
         * Creates an array of own enumerable property names and symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function getAllKeys$3(object) {
          return baseGetAllKeys$2(object, keys$6, getSymbols$4);
        }
        var _getAllKeys = getAllKeys$3;
        var getAllKeys$2 = _getAllKeys;

        /** Used to compose bitmasks for value comparisons. */
        var COMPARE_PARTIAL_FLAG$9 = 1;

        /** Used for built-in method references. */
        var objectProto$k = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$h = objectProto$k.hasOwnProperty;

        /**
         * A specialized version of `baseIsEqualDeep` for objects with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalObjects$2(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$9,
            objProps = getAllKeys$2(object),
            objLength = objProps.length,
            othProps = getAllKeys$2(other),
            othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty$h.call(other, key))) {
              return false;
            }
          }
          // Check that cyclic values are equal.
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key],
              othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            // Recursively compare objects (susceptible to call stack limits).
            if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result = false;
              break;
            }
            skipCtor || (skipCtor = key == 'constructor');
          }
          if (result && !skipCtor) {
            var objCtor = object.constructor,
              othCtor = other.constructor;

            // Non `Object` object instances with different constructors are not equal.
            if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
              result = false;
            }
          }
          stack['delete'](object);
          stack['delete'](other);
          return result;
        }
        var _equalObjects = equalObjects$2;
        var getNative$5 = _getNative,
          root$6 = _root;

        /* Built-in method references that are verified to be native. */
        var DataView$3 = getNative$5(root$6, 'DataView');
        var _DataView = DataView$3;
        var getNative$4 = _getNative,
          root$5 = _root;

        /* Built-in method references that are verified to be native. */
        var Promise$4 = getNative$4(root$5, 'Promise');
        var _Promise = Promise$4;
        var getNative$3 = _getNative,
          root$4 = _root;

        /* Built-in method references that are verified to be native. */
        var Set$4 = getNative$3(root$4, 'Set');
        var _Set = Set$4;
        var getNative$2 = _getNative,
          root$3 = _root;

        /* Built-in method references that are verified to be native. */
        var WeakMap$4 = getNative$2(root$3, 'WeakMap');
        var _WeakMap = WeakMap$4;
        var DataView$2 = _DataView,
          Map$3 = _Map,
          Promise$3 = _Promise,
          Set$3 = _Set,
          WeakMap$3 = _WeakMap,
          baseGetTag$4 = _baseGetTag,
          toSource$1 = _toSource;

        /** `Object#toString` result references. */
        var mapTag$6 = '[object Map]',
          objectTag$7 = '[object Object]',
          promiseTag$1 = '[object Promise]',
          setTag$6 = '[object Set]',
          weakMapTag$3 = '[object WeakMap]';
        var dataViewTag$5 = '[object DataView]';

        /** Used to detect maps, sets, and weakmaps. */
        var dataViewCtorString$1 = toSource$1(DataView$2),
          mapCtorString$1 = toSource$1(Map$3),
          promiseCtorString$1 = toSource$1(Promise$3),
          setCtorString$1 = toSource$1(Set$3),
          weakMapCtorString$1 = toSource$1(WeakMap$3);

        /**
         * Gets the `toStringTag` of `value`.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */
        var getTag$6 = baseGetTag$4;

        // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
        if (DataView$2 && getTag$6(new DataView$2(new ArrayBuffer(1))) != dataViewTag$5 || Map$3 && getTag$6(new Map$3()) != mapTag$6 || Promise$3 && getTag$6(Promise$3.resolve()) != promiseTag$1 || Set$3 && getTag$6(new Set$3()) != setTag$6 || WeakMap$3 && getTag$6(new WeakMap$3()) != weakMapTag$3) {
          getTag$6 = function (value) {
            var result = baseGetTag$4(value),
              Ctor = result == objectTag$7 ? value.constructor : undefined,
              ctorString = Ctor ? toSource$1(Ctor) : '';
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString$1:
                  return dataViewTag$5;
                case mapCtorString$1:
                  return mapTag$6;
                case promiseCtorString$1:
                  return promiseTag$1;
                case setCtorString$1:
                  return setTag$6;
                case weakMapCtorString$1:
                  return weakMapTag$3;
              }
            }
            return result;
          };
        }
        var _getTag = getTag$6;
        var Stack$4 = _Stack,
          equalArrays$1 = _equalArrays,
          equalByTag$1 = _equalByTag,
          equalObjects$1 = _equalObjects,
          getTag$5 = _getTag,
          isArray$d = isArray_1,
          isBuffer$4 = isBufferExports,
          isTypedArray$3 = isTypedArray_1;

        /** Used to compose bitmasks for value comparisons. */
        var COMPARE_PARTIAL_FLAG$8 = 1;

        /** `Object#toString` result references. */
        var argsTag$4 = '[object Arguments]',
          arrayTag$3 = '[object Array]',
          objectTag$6 = '[object Object]';

        /** Used for built-in method references. */
        var objectProto$j = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$g = objectProto$j.hasOwnProperty;

        /**
         * A specialized version of `baseIsEqual` for arrays and objects which performs
         * deep comparisons and tracks traversed objects enabling objects with circular
         * references to be compared.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} [stack] Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function baseIsEqualDeep$2(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray$d(object),
            othIsArr = isArray$d(other),
            objTag = objIsArr ? arrayTag$3 : getTag$5(object),
            othTag = othIsArr ? arrayTag$3 : getTag$5(other);
          objTag = objTag == argsTag$4 ? objectTag$6 : objTag;
          othTag = othTag == argsTag$4 ? objectTag$6 : othTag;
          var objIsObj = objTag == objectTag$6,
            othIsObj = othTag == objectTag$6,
            isSameTag = objTag == othTag;
          if (isSameTag && isBuffer$4(object)) {
            if (!isBuffer$4(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack$4());
            return objIsArr || isTypedArray$3(object) ? equalArrays$1(object, other, bitmask, customizer, equalFunc, stack) : equalByTag$1(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG$8)) {
            var objIsWrapped = objIsObj && hasOwnProperty$g.call(object, '__wrapped__'),
              othIsWrapped = othIsObj && hasOwnProperty$g.call(other, '__wrapped__');
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object,
                othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack$4());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack$4());
          return equalObjects$1(object, other, bitmask, customizer, equalFunc, stack);
        }
        var _baseIsEqualDeep = baseIsEqualDeep$2;
        var baseIsEqualDeep$1 = _baseIsEqualDeep,
          isObjectLike$7 = isObjectLike_1;

        /**
         * The base implementation of `_.isEqual` which supports partial comparisons
         * and tracks traversed objects.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @param {boolean} bitmask The bitmask flags.
         *  1 - Unordered comparison
         *  2 - Partial comparison
         * @param {Function} [customizer] The function to customize comparisons.
         * @param {Object} [stack] Tracks traversed `value` and `other` objects.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         */
        function baseIsEqual$4(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike$7(value) && !isObjectLike$7(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep$1(value, other, bitmask, customizer, baseIsEqual$4, stack);
        }
        var _baseIsEqual = baseIsEqual$4;
        var baseIsEqual$3 = _baseIsEqual;

        /**
         * Performs a deep comparison between two values to determine if they are
         * equivalent.
         *
         * **Note:** This method supports comparing arrays, array buffers, booleans,
         * date objects, error objects, maps, numbers, `Object` objects, regexes,
         * sets, strings, symbols, and typed arrays. `Object` objects are compared
         * by their own, not inherited, enumerable properties. Functions and DOM
         * nodes are compared by strict equality, i.e. `===`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'a': 1 };
         * var other = { 'a': 1 };
         *
         * _.isEqual(object, other);
         * // => true
         *
         * object === other;
         * // => false
         */
        function isEqual$1(value, other) {
          return baseIsEqual$3(value, other);
        }
        var isEqual_1$1 = isEqual$1;
        var quill = {
          exports: {}
        };

        /*!
         * Quill Editor v1.3.7
         * https://quilljs.com/
         * Copyright (c) 2014, Jason Chen
         * Copyright (c) 2013, salesforce.com
         */

        (function (module, exports) {
          (function webpackUniversalModuleDefinition(root, factory) {
            module.exports = factory();
          })(typeof self !== 'undefined' ? self : commonjsGlobal, function () {
            return (/******/function (modules) {
                // webpackBootstrap
                /******/ // The module cache
                /******/
                var installedModules = {};
                /******/
                /******/ // The require function
                /******/
                function __webpack_require__(moduleId) {
                  /******/
                  /******/ // Check if module is in cache
                  /******/if (installedModules[moduleId]) {
                    /******/return installedModules[moduleId].exports;
                    /******/
                  }
                  /******/ // Create a new module (and put it into the cache)
                  /******/
                  var module = installedModules[moduleId] = {
                    /******/i: moduleId,
                    /******/l: false,
                    /******/exports: {}
                    /******/
                  };
                  /******/
                  /******/ // Execute the module function
                  /******/
                  modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
                  /******/
                  /******/ // Flag the module as loaded
                  /******/
                  module.l = true;
                  /******/
                  /******/ // Return the exports of the module
                  /******/
                  return module.exports;
                  /******/
                }
                /******/
                /******/
                /******/ // expose the modules object (__webpack_modules__)
                /******/
                __webpack_require__.m = modules;
                /******/
                /******/ // expose the module cache
                /******/
                __webpack_require__.c = installedModules;
                /******/
                /******/ // define getter function for harmony exports
                /******/
                __webpack_require__.d = function (exports, name, getter) {
                  /******/if (!__webpack_require__.o(exports, name)) {
                    /******/Object.defineProperty(exports, name, {
                      /******/configurable: false,
                      /******/enumerable: true,
                      /******/get: getter
                      /******/
                    });
                    /******/
                  }
                  /******/
                };
                /******/
                /******/ // getDefaultExport function for compatibility with non-harmony modules
                /******/
                __webpack_require__.n = function (module) {
                  /******/var getter = module && module.__esModule ? /******/function getDefault() {
                    return module['default'];
                  } : /******/function getModuleExports() {
                    return module;
                  };
                  /******/
                  __webpack_require__.d(getter, 'a', getter);
                  /******/
                  return getter;
                  /******/
                };
                /******/
                /******/ // Object.prototype.hasOwnProperty.call
                /******/
                __webpack_require__.o = function (object, property) {
                  return Object.prototype.hasOwnProperty.call(object, property);
                };
                /******/
                /******/ // __webpack_public_path__
                /******/
                __webpack_require__.p = "";
                /******/
                /******/ // Load entry module and return exports
                /******/
                return __webpack_require__(__webpack_require__.s = 109);
                /******/
              }
              /************************************************************************/
              /******/([/* 0 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var container_1 = __webpack_require__(17);
                var format_1 = __webpack_require__(18);
                var leaf_1 = __webpack_require__(19);
                var scroll_1 = __webpack_require__(45);
                var inline_1 = __webpack_require__(46);
                var block_1 = __webpack_require__(47);
                var embed_1 = __webpack_require__(48);
                var text_1 = __webpack_require__(49);
                var attributor_1 = __webpack_require__(12);
                var class_1 = __webpack_require__(32);
                var style_1 = __webpack_require__(33);
                var store_1 = __webpack_require__(31);
                var Registry = __webpack_require__(1);
                var Parchment = {
                  Scope: Registry.Scope,
                  create: Registry.create,
                  find: Registry.find,
                  query: Registry.query,
                  register: Registry.register,
                  Container: container_1.default,
                  Format: format_1.default,
                  Leaf: leaf_1.default,
                  Embed: embed_1.default,
                  Scroll: scroll_1.default,
                  Block: block_1.default,
                  Inline: inline_1.default,
                  Text: text_1.default,
                  Attributor: {
                    Attribute: attributor_1.default,
                    Class: class_1.default,
                    Style: style_1.default,
                    Store: store_1.default
                  }
                };
                exports.default = Parchment;

                /***/
              }, /* 1 */
              /***/function (module, exports, __webpack_require__) {
                var __extends = this && this.__extends || function () {
                  var extendStatics = Object.setPrototypeOf || {
                    __proto__: []
                  } instanceof Array && function (d, b) {
                    d.__proto__ = b;
                  } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                  };
                  return function (d, b) {
                    extendStatics(d, b);
                    function __() {
                      this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                  };
                }();
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var ParchmentError = /** @class */function (_super) {
                  __extends(ParchmentError, _super);
                  function ParchmentError(message) {
                    var _this = this;
                    message = '[Parchment] ' + message;
                    _this = _super.call(this, message) || this;
                    _this.message = message;
                    _this.name = _this.constructor.name;
                    return _this;
                  }
                  return ParchmentError;
                }(Error);
                exports.ParchmentError = ParchmentError;
                var attributes = {};
                var classes = {};
                var tags = {};
                var types = {};
                exports.DATA_KEY = '__blot';
                var Scope;
                (function (Scope) {
                  Scope[Scope["TYPE"] = 3] = "TYPE";
                  Scope[Scope["LEVEL"] = 12] = "LEVEL";
                  Scope[Scope["ATTRIBUTE"] = 13] = "ATTRIBUTE";
                  Scope[Scope["BLOT"] = 14] = "BLOT";
                  Scope[Scope["INLINE"] = 7] = "INLINE";
                  Scope[Scope["BLOCK"] = 11] = "BLOCK";
                  Scope[Scope["BLOCK_BLOT"] = 10] = "BLOCK_BLOT";
                  Scope[Scope["INLINE_BLOT"] = 6] = "INLINE_BLOT";
                  Scope[Scope["BLOCK_ATTRIBUTE"] = 9] = "BLOCK_ATTRIBUTE";
                  Scope[Scope["INLINE_ATTRIBUTE"] = 5] = "INLINE_ATTRIBUTE";
                  Scope[Scope["ANY"] = 15] = "ANY";
                })(Scope = exports.Scope || (exports.Scope = {}));
                function create(input, value) {
                  var match = query(input);
                  if (match == null) {
                    throw new ParchmentError("Unable to create " + input + " blot");
                  }
                  var BlotClass = match;
                  var node =
                  // @ts-ignore
                  input instanceof Node || input['nodeType'] === Node.TEXT_NODE ? input : BlotClass.create(value);
                  return new BlotClass(node, value);
                }
                exports.create = create;
                function find(node, bubble) {
                  if (bubble === void 0) {
                    bubble = false;
                  }
                  if (node == null) return null;
                  // @ts-ignore
                  if (node[exports.DATA_KEY] != null) return node[exports.DATA_KEY].blot;
                  if (bubble) return find(node.parentNode, bubble);
                  return null;
                }
                exports.find = find;
                function query(query, scope) {
                  if (scope === void 0) {
                    scope = Scope.ANY;
                  }
                  var match;
                  if (typeof query === 'string') {
                    match = types[query] || attributes[query];
                    // @ts-ignore
                  } else if (query instanceof Text || query['nodeType'] === Node.TEXT_NODE) {
                    match = types['text'];
                  } else if (typeof query === 'number') {
                    if (query & Scope.LEVEL & Scope.BLOCK) {
                      match = types['block'];
                    } else if (query & Scope.LEVEL & Scope.INLINE) {
                      match = types['inline'];
                    }
                  } else if (query instanceof HTMLElement) {
                    var names = (query.getAttribute('class') || '').split(/\s+/);
                    for (var i in names) {
                      match = classes[names[i]];
                      if (match) break;
                    }
                    match = match || tags[query.tagName];
                  }
                  if (match == null) return null;
                  // @ts-ignore
                  if (scope & Scope.LEVEL & match.scope && scope & Scope.TYPE & match.scope) return match;
                  return null;
                }
                exports.query = query;
                function register() {
                  var Definitions = [];
                  for (var _i = 0; _i < arguments.length; _i++) {
                    Definitions[_i] = arguments[_i];
                  }
                  if (Definitions.length > 1) {
                    return Definitions.map(function (d) {
                      return register(d);
                    });
                  }
                  var Definition = Definitions[0];
                  if (typeof Definition.blotName !== 'string' && typeof Definition.attrName !== 'string') {
                    throw new ParchmentError('Invalid definition');
                  } else if (Definition.blotName === 'abstract') {
                    throw new ParchmentError('Cannot register abstract class');
                  }
                  types[Definition.blotName || Definition.attrName] = Definition;
                  if (typeof Definition.keyName === 'string') {
                    attributes[Definition.keyName] = Definition;
                  } else {
                    if (Definition.className != null) {
                      classes[Definition.className] = Definition;
                    }
                    if (Definition.tagName != null) {
                      if (Array.isArray(Definition.tagName)) {
                        Definition.tagName = Definition.tagName.map(function (tagName) {
                          return tagName.toUpperCase();
                        });
                      } else {
                        Definition.tagName = Definition.tagName.toUpperCase();
                      }
                      var tagNames = Array.isArray(Definition.tagName) ? Definition.tagName : [Definition.tagName];
                      tagNames.forEach(function (tag) {
                        if (tags[tag] == null || Definition.className == null) {
                          tags[tag] = Definition;
                        }
                      });
                    }
                  }
                  return Definition;
                }
                exports.register = register;

                /***/
              }, /* 2 */
              /***/function (module, exports, __webpack_require__) {
                var diff = __webpack_require__(51);
                var equal = __webpack_require__(11);
                var extend = __webpack_require__(3);
                var op = __webpack_require__(20);
                var NULL_CHARACTER = String.fromCharCode(0); // Placeholder char for embed in diff()

                var Delta = function (ops) {
                  // Assume we are given a well formed ops
                  if (Array.isArray(ops)) {
                    this.ops = ops;
                  } else if (ops != null && Array.isArray(ops.ops)) {
                    this.ops = ops.ops;
                  } else {
                    this.ops = [];
                  }
                };
                Delta.prototype.insert = function (text, attributes) {
                  var newOp = {};
                  if (text.length === 0) return this;
                  newOp.insert = text;
                  if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
                    newOp.attributes = attributes;
                  }
                  return this.push(newOp);
                };
                Delta.prototype['delete'] = function (length) {
                  if (length <= 0) return this;
                  return this.push({
                    'delete': length
                  });
                };
                Delta.prototype.retain = function (length, attributes) {
                  if (length <= 0) return this;
                  var newOp = {
                    retain: length
                  };
                  if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
                    newOp.attributes = attributes;
                  }
                  return this.push(newOp);
                };
                Delta.prototype.push = function (newOp) {
                  var index = this.ops.length;
                  var lastOp = this.ops[index - 1];
                  newOp = extend(true, {}, newOp);
                  if (typeof lastOp === 'object') {
                    if (typeof newOp['delete'] === 'number' && typeof lastOp['delete'] === 'number') {
                      this.ops[index - 1] = {
                        'delete': lastOp['delete'] + newOp['delete']
                      };
                      return this;
                    }
                    // Since it does not matter if we insert before or after deleting at the same index,
                    // always prefer to insert first
                    if (typeof lastOp['delete'] === 'number' && newOp.insert != null) {
                      index -= 1;
                      lastOp = this.ops[index - 1];
                      if (typeof lastOp !== 'object') {
                        this.ops.unshift(newOp);
                        return this;
                      }
                    }
                    if (equal(newOp.attributes, lastOp.attributes)) {
                      if (typeof newOp.insert === 'string' && typeof lastOp.insert === 'string') {
                        this.ops[index - 1] = {
                          insert: lastOp.insert + newOp.insert
                        };
                        if (typeof newOp.attributes === 'object') this.ops[index - 1].attributes = newOp.attributes;
                        return this;
                      } else if (typeof newOp.retain === 'number' && typeof lastOp.retain === 'number') {
                        this.ops[index - 1] = {
                          retain: lastOp.retain + newOp.retain
                        };
                        if (typeof newOp.attributes === 'object') this.ops[index - 1].attributes = newOp.attributes;
                        return this;
                      }
                    }
                  }
                  if (index === this.ops.length) {
                    this.ops.push(newOp);
                  } else {
                    this.ops.splice(index, 0, newOp);
                  }
                  return this;
                };
                Delta.prototype.chop = function () {
                  var lastOp = this.ops[this.ops.length - 1];
                  if (lastOp && lastOp.retain && !lastOp.attributes) {
                    this.ops.pop();
                  }
                  return this;
                };
                Delta.prototype.filter = function (predicate) {
                  return this.ops.filter(predicate);
                };
                Delta.prototype.forEach = function (predicate) {
                  this.ops.forEach(predicate);
                };
                Delta.prototype.map = function (predicate) {
                  return this.ops.map(predicate);
                };
                Delta.prototype.partition = function (predicate) {
                  var passed = [],
                    failed = [];
                  this.forEach(function (op) {
                    var target = predicate(op) ? passed : failed;
                    target.push(op);
                  });
                  return [passed, failed];
                };
                Delta.prototype.reduce = function (predicate, initial) {
                  return this.ops.reduce(predicate, initial);
                };
                Delta.prototype.changeLength = function () {
                  return this.reduce(function (length, elem) {
                    if (elem.insert) {
                      return length + op.length(elem);
                    } else if (elem.delete) {
                      return length - elem.delete;
                    }
                    return length;
                  }, 0);
                };
                Delta.prototype.length = function () {
                  return this.reduce(function (length, elem) {
                    return length + op.length(elem);
                  }, 0);
                };
                Delta.prototype.slice = function (start, end) {
                  start = start || 0;
                  if (typeof end !== 'number') end = Infinity;
                  var ops = [];
                  var iter = op.iterator(this.ops);
                  var index = 0;
                  while (index < end && iter.hasNext()) {
                    var nextOp;
                    if (index < start) {
                      nextOp = iter.next(start - index);
                    } else {
                      nextOp = iter.next(end - index);
                      ops.push(nextOp);
                    }
                    index += op.length(nextOp);
                  }
                  return new Delta(ops);
                };
                Delta.prototype.compose = function (other) {
                  var thisIter = op.iterator(this.ops);
                  var otherIter = op.iterator(other.ops);
                  var ops = [];
                  var firstOther = otherIter.peek();
                  if (firstOther != null && typeof firstOther.retain === 'number' && firstOther.attributes == null) {
                    var firstLeft = firstOther.retain;
                    while (thisIter.peekType() === 'insert' && thisIter.peekLength() <= firstLeft) {
                      firstLeft -= thisIter.peekLength();
                      ops.push(thisIter.next());
                    }
                    if (firstOther.retain - firstLeft > 0) {
                      otherIter.next(firstOther.retain - firstLeft);
                    }
                  }
                  var delta = new Delta(ops);
                  while (thisIter.hasNext() || otherIter.hasNext()) {
                    if (otherIter.peekType() === 'insert') {
                      delta.push(otherIter.next());
                    } else if (thisIter.peekType() === 'delete') {
                      delta.push(thisIter.next());
                    } else {
                      var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
                      var thisOp = thisIter.next(length);
                      var otherOp = otherIter.next(length);
                      if (typeof otherOp.retain === 'number') {
                        var newOp = {};
                        if (typeof thisOp.retain === 'number') {
                          newOp.retain = length;
                        } else {
                          newOp.insert = thisOp.insert;
                        }
                        // Preserve null when composing with a retain, otherwise remove it for inserts
                        var attributes = op.attributes.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');
                        if (attributes) newOp.attributes = attributes;
                        delta.push(newOp);

                        // Optimization if rest of other is just retain
                        if (!otherIter.hasNext() && equal(delta.ops[delta.ops.length - 1], newOp)) {
                          var rest = new Delta(thisIter.rest());
                          return delta.concat(rest).chop();
                        }

                        // Other op should be delete, we could be an insert or retain
                        // Insert + delete cancels out
                      } else if (typeof otherOp['delete'] === 'number' && typeof thisOp.retain === 'number') {
                        delta.push(otherOp);
                      }
                    }
                  }
                  return delta.chop();
                };
                Delta.prototype.concat = function (other) {
                  var delta = new Delta(this.ops.slice());
                  if (other.ops.length > 0) {
                    delta.push(other.ops[0]);
                    delta.ops = delta.ops.concat(other.ops.slice(1));
                  }
                  return delta;
                };
                Delta.prototype.diff = function (other, index) {
                  if (this.ops === other.ops) {
                    return new Delta();
                  }
                  var strings = [this, other].map(function (delta) {
                    return delta.map(function (op) {
                      if (op.insert != null) {
                        return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER;
                      }
                      var prep = delta === other ? 'on' : 'with';
                      throw new Error('diff() called ' + prep + ' non-document');
                    }).join('');
                  });
                  var delta = new Delta();
                  var diffResult = diff(strings[0], strings[1], index);
                  var thisIter = op.iterator(this.ops);
                  var otherIter = op.iterator(other.ops);
                  diffResult.forEach(function (component) {
                    var length = component[1].length;
                    while (length > 0) {
                      var opLength = 0;
                      switch (component[0]) {
                        case diff.INSERT:
                          opLength = Math.min(otherIter.peekLength(), length);
                          delta.push(otherIter.next(opLength));
                          break;
                        case diff.DELETE:
                          opLength = Math.min(length, thisIter.peekLength());
                          thisIter.next(opLength);
                          delta['delete'](opLength);
                          break;
                        case diff.EQUAL:
                          opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
                          var thisOp = thisIter.next(opLength);
                          var otherOp = otherIter.next(opLength);
                          if (equal(thisOp.insert, otherOp.insert)) {
                            delta.retain(opLength, op.attributes.diff(thisOp.attributes, otherOp.attributes));
                          } else {
                            delta.push(otherOp)['delete'](opLength);
                          }
                          break;
                      }
                      length -= opLength;
                    }
                  });
                  return delta.chop();
                };
                Delta.prototype.eachLine = function (predicate, newline) {
                  newline = newline || '\n';
                  var iter = op.iterator(this.ops);
                  var line = new Delta();
                  var i = 0;
                  while (iter.hasNext()) {
                    if (iter.peekType() !== 'insert') return;
                    var thisOp = iter.peek();
                    var start = op.length(thisOp) - iter.peekLength();
                    var index = typeof thisOp.insert === 'string' ? thisOp.insert.indexOf(newline, start) - start : -1;
                    if (index < 0) {
                      line.push(iter.next());
                    } else if (index > 0) {
                      line.push(iter.next(index));
                    } else {
                      if (predicate(line, iter.next(1).attributes || {}, i) === false) {
                        return;
                      }
                      i += 1;
                      line = new Delta();
                    }
                  }
                  if (line.length() > 0) {
                    predicate(line, {}, i);
                  }
                };
                Delta.prototype.transform = function (other, priority) {
                  priority = !!priority;
                  if (typeof other === 'number') {
                    return this.transformPosition(other, priority);
                  }
                  var thisIter = op.iterator(this.ops);
                  var otherIter = op.iterator(other.ops);
                  var delta = new Delta();
                  while (thisIter.hasNext() || otherIter.hasNext()) {
                    if (thisIter.peekType() === 'insert' && (priority || otherIter.peekType() !== 'insert')) {
                      delta.retain(op.length(thisIter.next()));
                    } else if (otherIter.peekType() === 'insert') {
                      delta.push(otherIter.next());
                    } else {
                      var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
                      var thisOp = thisIter.next(length);
                      var otherOp = otherIter.next(length);
                      if (thisOp['delete']) {
                        // Our delete either makes their delete redundant or removes their retain
                        continue;
                      } else if (otherOp['delete']) {
                        delta.push(otherOp);
                      } else {
                        // We retain either their retain or insert
                        delta.retain(length, op.attributes.transform(thisOp.attributes, otherOp.attributes, priority));
                      }
                    }
                  }
                  return delta.chop();
                };
                Delta.prototype.transformPosition = function (index, priority) {
                  priority = !!priority;
                  var thisIter = op.iterator(this.ops);
                  var offset = 0;
                  while (thisIter.hasNext() && offset <= index) {
                    var length = thisIter.peekLength();
                    var nextType = thisIter.peekType();
                    thisIter.next();
                    if (nextType === 'delete') {
                      index -= Math.min(length, index - offset);
                      continue;
                    } else if (nextType === 'insert' && (offset < index || !priority)) {
                      index += length;
                    }
                    offset += length;
                  }
                  return index;
                };
                module.exports = Delta;

                /***/
              }, /* 3 */
              /***/function (module, exports) {
                var hasOwn = Object.prototype.hasOwnProperty;
                var toStr = Object.prototype.toString;
                var defineProperty = Object.defineProperty;
                var gOPD = Object.getOwnPropertyDescriptor;
                var isArray = function isArray(arr) {
                  if (typeof Array.isArray === 'function') {
                    return Array.isArray(arr);
                  }
                  return toStr.call(arr) === '[object Array]';
                };
                var isPlainObject = function isPlainObject(obj) {
                  if (!obj || toStr.call(obj) !== '[object Object]') {
                    return false;
                  }
                  var hasOwnConstructor = hasOwn.call(obj, 'constructor');
                  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
                  // Not own constructor property must be Object
                  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
                    return false;
                  }

                  // Own properties are enumerated firstly, so to speed up,
                  // if last one is own, then all properties are own.
                  var key;
                  for (key in obj) {/**/}
                  return typeof key === 'undefined' || hasOwn.call(obj, key);
                };

                // If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
                var setProperty = function setProperty(target, options) {
                  if (defineProperty && options.name === '__proto__') {
                    defineProperty(target, options.name, {
                      enumerable: true,
                      configurable: true,
                      value: options.newValue,
                      writable: true
                    });
                  } else {
                    target[options.name] = options.newValue;
                  }
                };

                // Return undefined instead of __proto__ if '__proto__' is not an own property
                var getProperty = function getProperty(obj, name) {
                  if (name === '__proto__') {
                    if (!hasOwn.call(obj, name)) {
                      return void 0;
                    } else if (gOPD) {
                      // In early versions of node, obj['__proto__'] is buggy when obj has
                      // __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
                      return gOPD(obj, name).value;
                    }
                  }
                  return obj[name];
                };
                module.exports = function extend() {
                  var options, name, src, copy, copyIsArray, clone;
                  var target = arguments[0];
                  var i = 1;
                  var length = arguments.length;
                  var deep = false;

                  // Handle a deep copy situation
                  if (typeof target === 'boolean') {
                    deep = target;
                    target = arguments[1] || {};
                    // skip the boolean and the target
                    i = 2;
                  }
                  if (target == null || typeof target !== 'object' && typeof target !== 'function') {
                    target = {};
                  }
                  for (; i < length; ++i) {
                    options = arguments[i];
                    // Only deal with non-null/undefined values
                    if (options != null) {
                      // Extend the base object
                      for (name in options) {
                        src = getProperty(target, name);
                        copy = getProperty(options, name);

                        // Prevent never-ending loop
                        if (target !== copy) {
                          // Recurse if we're merging plain objects or arrays
                          if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
                            if (copyIsArray) {
                              copyIsArray = false;
                              clone = src && isArray(src) ? src : [];
                            } else {
                              clone = src && isPlainObject(src) ? src : {};
                            }

                            // Never move original objects, clone them
                            setProperty(target, {
                              name: name,
                              newValue: extend(deep, clone, copy)
                            });

                            // Don't bring in undefined values
                          } else if (typeof copy !== 'undefined') {
                            setProperty(target, {
                              name: name,
                              newValue: copy
                            });
                          }
                        }
                      }
                    }
                  }

                  // Return the modified object
                  return target;
                };

                /***/
              }, /* 4 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.default = exports.BlockEmbed = exports.bubbleFormats = undefined;
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _get = function get(object, property, receiver) {
                  if (object === null) object = Function.prototype;
                  var desc = Object.getOwnPropertyDescriptor(object, property);
                  if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                      return undefined;
                    } else {
                      return get(parent, property, receiver);
                    }
                  } else if ("value" in desc) {
                    return desc.value;
                  } else {
                    var getter = desc.get;
                    if (getter === undefined) {
                      return undefined;
                    }
                    return getter.call(receiver);
                  }
                };
                var _extend = __webpack_require__(3);
                var _extend2 = _interopRequireDefault(_extend);
                var _quillDelta = __webpack_require__(2);
                var _quillDelta2 = _interopRequireDefault(_quillDelta);
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _break = __webpack_require__(16);
                var _break2 = _interopRequireDefault(_break);
                var _inline = __webpack_require__(6);
                var _inline2 = _interopRequireDefault(_inline);
                var _text = __webpack_require__(7);
                var _text2 = _interopRequireDefault(_text);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var NEWLINE_LENGTH = 1;
                var BlockEmbed = function (_Parchment$Embed) {
                  _inherits(BlockEmbed, _Parchment$Embed);
                  function BlockEmbed() {
                    _classCallCheck(this, BlockEmbed);
                    return _possibleConstructorReturn(this, (BlockEmbed.__proto__ || Object.getPrototypeOf(BlockEmbed)).apply(this, arguments));
                  }
                  _createClass(BlockEmbed, [{
                    key: 'attach',
                    value: function attach() {
                      _get(BlockEmbed.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed.prototype), 'attach', this).call(this);
                      this.attributes = new _parchment2.default.Attributor.Store(this.domNode);
                    }
                  }, {
                    key: 'delta',
                    value: function delta() {
                      return new _quillDelta2.default().insert(this.value(), (0, _extend2.default)(this.formats(), this.attributes.values()));
                    }
                  }, {
                    key: 'format',
                    value: function format(name, value) {
                      var attribute = _parchment2.default.query(name, _parchment2.default.Scope.BLOCK_ATTRIBUTE);
                      if (attribute != null) {
                        this.attributes.attribute(attribute, value);
                      }
                    }
                  }, {
                    key: 'formatAt',
                    value: function formatAt(index, length, name, value) {
                      this.format(name, value);
                    }
                  }, {
                    key: 'insertAt',
                    value: function insertAt(index, value, def) {
                      if (typeof value === 'string' && value.endsWith('\n')) {
                        var block = _parchment2.default.create(Block.blotName);
                        this.parent.insertBefore(block, index === 0 ? this : this.next);
                        block.insertAt(0, value.slice(0, -1));
                      } else {
                        _get(BlockEmbed.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed.prototype), 'insertAt', this).call(this, index, value, def);
                      }
                    }
                  }]);
                  return BlockEmbed;
                }(_parchment2.default.Embed);
                BlockEmbed.scope = _parchment2.default.Scope.BLOCK_BLOT;
                // It is important for cursor behavior BlockEmbeds use tags that are block level elements

                var Block = function (_Parchment$Block) {
                  _inherits(Block, _Parchment$Block);
                  function Block(domNode) {
                    _classCallCheck(this, Block);
                    var _this2 = _possibleConstructorReturn(this, (Block.__proto__ || Object.getPrototypeOf(Block)).call(this, domNode));
                    _this2.cache = {};
                    return _this2;
                  }
                  _createClass(Block, [{
                    key: 'delta',
                    value: function delta() {
                      if (this.cache.delta == null) {
                        this.cache.delta = this.descendants(_parchment2.default.Leaf).reduce(function (delta, leaf) {
                          if (leaf.length() === 0) {
                            return delta;
                          } else {
                            return delta.insert(leaf.value(), bubbleFormats(leaf));
                          }
                        }, new _quillDelta2.default()).insert('\n', bubbleFormats(this));
                      }
                      return this.cache.delta;
                    }
                  }, {
                    key: 'deleteAt',
                    value: function deleteAt(index, length) {
                      _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'deleteAt', this).call(this, index, length);
                      this.cache = {};
                    }
                  }, {
                    key: 'formatAt',
                    value: function formatAt(index, length, name, value) {
                      if (length <= 0) return;
                      if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {
                        if (index + length === this.length()) {
                          this.format(name, value);
                        }
                      } else {
                        _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'formatAt', this).call(this, index, Math.min(length, this.length() - index - 1), name, value);
                      }
                      this.cache = {};
                    }
                  }, {
                    key: 'insertAt',
                    value: function insertAt(index, value, def) {
                      if (def != null) return _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'insertAt', this).call(this, index, value, def);
                      if (value.length === 0) return;
                      var lines = value.split('\n');
                      var text = lines.shift();
                      if (text.length > 0) {
                        if (index < this.length() - 1 || this.children.tail == null) {
                          _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'insertAt', this).call(this, Math.min(index, this.length() - 1), text);
                        } else {
                          this.children.tail.insertAt(this.children.tail.length(), text);
                        }
                        this.cache = {};
                      }
                      var block = this;
                      lines.reduce(function (index, line) {
                        block = block.split(index, true);
                        block.insertAt(0, line);
                        return line.length;
                      }, index + text.length);
                    }
                  }, {
                    key: 'insertBefore',
                    value: function insertBefore(blot, ref) {
                      var head = this.children.head;
                      _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'insertBefore', this).call(this, blot, ref);
                      if (head instanceof _break2.default) {
                        head.remove();
                      }
                      this.cache = {};
                    }
                  }, {
                    key: 'length',
                    value: function length() {
                      if (this.cache.length == null) {
                        this.cache.length = _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'length', this).call(this) + NEWLINE_LENGTH;
                      }
                      return this.cache.length;
                    }
                  }, {
                    key: 'moveChildren',
                    value: function moveChildren(target, ref) {
                      _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'moveChildren', this).call(this, target, ref);
                      this.cache = {};
                    }
                  }, {
                    key: 'optimize',
                    value: function optimize(context) {
                      _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'optimize', this).call(this, context);
                      this.cache = {};
                    }
                  }, {
                    key: 'path',
                    value: function path(index) {
                      return _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'path', this).call(this, index, true);
                    }
                  }, {
                    key: 'removeChild',
                    value: function removeChild(child) {
                      _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'removeChild', this).call(this, child);
                      this.cache = {};
                    }
                  }, {
                    key: 'split',
                    value: function split(index) {
                      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                      if (force && (index === 0 || index >= this.length() - NEWLINE_LENGTH)) {
                        var clone = this.clone();
                        if (index === 0) {
                          this.parent.insertBefore(clone, this);
                          return this;
                        } else {
                          this.parent.insertBefore(clone, this.next);
                          return clone;
                        }
                      } else {
                        var next = _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'split', this).call(this, index, force);
                        this.cache = {};
                        return next;
                      }
                    }
                  }]);
                  return Block;
                }(_parchment2.default.Block);
                Block.blotName = 'block';
                Block.tagName = 'P';
                Block.defaultChild = 'break';
                Block.allowedChildren = [_inline2.default, _parchment2.default.Embed, _text2.default];
                function bubbleFormats(blot) {
                  var formats = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                  if (blot == null) return formats;
                  if (typeof blot.formats === 'function') {
                    formats = (0, _extend2.default)(formats, blot.formats());
                  }
                  if (blot.parent == null || blot.parent.blotName == 'scroll' || blot.parent.statics.scope !== blot.statics.scope) {
                    return formats;
                  }
                  return bubbleFormats(blot.parent, formats);
                }
                exports.bubbleFormats = bubbleFormats;
                exports.BlockEmbed = BlockEmbed;
                exports.default = Block;

                /***/
              }, /* 5 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.default = exports.overload = exports.expandConfig = undefined;
                var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
                  return typeof obj;
                } : function (obj) {
                  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
                var _slicedToArray = function () {
                  function sliceIterator(arr, i) {
                    var _arr = [];
                    var _n = true;
                    var _d = false;
                    var _e = undefined;
                    try {
                      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                        _arr.push(_s.value);
                        if (i && _arr.length === i) break;
                      }
                    } catch (err) {
                      _d = true;
                      _e = err;
                    } finally {
                      try {
                        if (!_n && _i["return"]) _i["return"]();
                      } finally {
                        if (_d) throw _e;
                      }
                    }
                    return _arr;
                  }
                  return function (arr, i) {
                    if (Array.isArray(arr)) {
                      return arr;
                    } else if (Symbol.iterator in Object(arr)) {
                      return sliceIterator(arr, i);
                    } else {
                      throw new TypeError("Invalid attempt to destructure non-iterable instance");
                    }
                  };
                }();
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                __webpack_require__(50);
                var _quillDelta = __webpack_require__(2);
                var _quillDelta2 = _interopRequireDefault(_quillDelta);
                var _editor = __webpack_require__(14);
                var _editor2 = _interopRequireDefault(_editor);
                var _emitter3 = __webpack_require__(8);
                var _emitter4 = _interopRequireDefault(_emitter3);
                var _module = __webpack_require__(9);
                var _module2 = _interopRequireDefault(_module);
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _selection = __webpack_require__(15);
                var _selection2 = _interopRequireDefault(_selection);
                var _extend = __webpack_require__(3);
                var _extend2 = _interopRequireDefault(_extend);
                var _logger = __webpack_require__(10);
                var _logger2 = _interopRequireDefault(_logger);
                var _theme = __webpack_require__(34);
                var _theme2 = _interopRequireDefault(_theme);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _defineProperty(obj, key, value) {
                  if (key in obj) {
                    Object.defineProperty(obj, key, {
                      value: value,
                      enumerable: true,
                      configurable: true,
                      writable: true
                    });
                  } else {
                    obj[key] = value;
                  }
                  return obj;
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                var debug = (0, _logger2.default)('quill');
                var Quill = function () {
                  _createClass(Quill, null, [{
                    key: 'debug',
                    value: function debug(limit) {
                      if (limit === true) {
                        limit = 'log';
                      }
                      _logger2.default.level(limit);
                    }
                  }, {
                    key: 'find',
                    value: function find(node) {
                      return node.__quill || _parchment2.default.find(node);
                    }
                  }, {
                    key: 'import',
                    value: function _import(name) {
                      if (this.imports[name] == null) {
                        debug.error('Cannot import ' + name + '. Are you sure it was registered?');
                      }
                      return this.imports[name];
                    }
                  }, {
                    key: 'register',
                    value: function register(path, target) {
                      var _this = this;
                      var overwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                      if (typeof path !== 'string') {
                        var name = path.attrName || path.blotName;
                        if (typeof name === 'string') {
                          // register(Blot | Attributor, overwrite)
                          this.register('formats/' + name, path, target);
                        } else {
                          Object.keys(path).forEach(function (key) {
                            _this.register(key, path[key], target);
                          });
                        }
                      } else {
                        if (this.imports[path] != null && !overwrite) {
                          debug.warn('Overwriting ' + path + ' with', target);
                        }
                        this.imports[path] = target;
                        if ((path.startsWith('blots/') || path.startsWith('formats/')) && target.blotName !== 'abstract') {
                          _parchment2.default.register(target);
                        } else if (path.startsWith('modules') && typeof target.register === 'function') {
                          target.register();
                        }
                      }
                    }
                  }]);
                  function Quill(container) {
                    var _this2 = this;
                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                    _classCallCheck(this, Quill);
                    this.options = expandConfig(container, options);
                    this.container = this.options.container;
                    if (this.container == null) {
                      return debug.error('Invalid Quill container', container);
                    }
                    if (this.options.debug) {
                      Quill.debug(this.options.debug);
                    }
                    var html = this.container.innerHTML.trim();
                    this.container.classList.add('ql-container');
                    this.container.innerHTML = '';
                    this.container.__quill = this;
                    this.root = this.addContainer('ql-editor');
                    this.root.classList.add('ql-blank');
                    this.root.setAttribute('data-gramm', false);
                    this.scrollingContainer = this.options.scrollingContainer || this.root;
                    this.emitter = new _emitter4.default();
                    this.scroll = _parchment2.default.create(this.root, {
                      emitter: this.emitter,
                      whitelist: this.options.formats
                    });
                    this.editor = new _editor2.default(this.scroll);
                    this.selection = new _selection2.default(this.scroll, this.emitter);
                    this.theme = new this.options.theme(this, this.options);
                    this.keyboard = this.theme.addModule('keyboard');
                    this.clipboard = this.theme.addModule('clipboard');
                    this.history = this.theme.addModule('history');
                    this.theme.init();
                    this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function (type) {
                      if (type === _emitter4.default.events.TEXT_CHANGE) {
                        _this2.root.classList.toggle('ql-blank', _this2.editor.isBlank());
                      }
                    });
                    this.emitter.on(_emitter4.default.events.SCROLL_UPDATE, function (source, mutations) {
                      var range = _this2.selection.lastRange;
                      var index = range && range.length === 0 ? range.index : undefined;
                      modify.call(_this2, function () {
                        return _this2.editor.update(null, mutations, index);
                      }, source);
                    });
                    var contents = this.clipboard.convert('<div class=\'ql-editor\' style="white-space: normal;">' + html + '<p><br></p></div>');
                    this.setContents(contents);
                    this.history.clear();
                    if (this.options.placeholder) {
                      this.root.setAttribute('data-placeholder', this.options.placeholder);
                    }
                    if (this.options.readOnly) {
                      this.disable();
                    }
                  }
                  _createClass(Quill, [{
                    key: 'addContainer',
                    value: function addContainer(container) {
                      var refNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                      if (typeof container === 'string') {
                        var className = container;
                        container = document.createElement('div');
                        container.classList.add(className);
                      }
                      this.container.insertBefore(container, refNode);
                      return container;
                    }
                  }, {
                    key: 'blur',
                    value: function blur() {
                      this.selection.setRange(null);
                    }
                  }, {
                    key: 'deleteText',
                    value: function deleteText(index, length, source) {
                      var _this3 = this;
                      var _overload = overload(index, length, source);
                      var _overload2 = _slicedToArray(_overload, 4);
                      index = _overload2[0];
                      length = _overload2[1];
                      source = _overload2[3];
                      return modify.call(this, function () {
                        return _this3.editor.deleteText(index, length);
                      }, source, index, -1 * length);
                    }
                  }, {
                    key: 'disable',
                    value: function disable() {
                      this.enable(false);
                    }
                  }, {
                    key: 'enable',
                    value: function enable() {
                      var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
                      this.scroll.enable(enabled);
                      this.container.classList.toggle('ql-disabled', !enabled);
                    }
                  }, {
                    key: 'focus',
                    value: function focus() {
                      var scrollTop = this.scrollingContainer.scrollTop;
                      this.selection.focus();
                      this.scrollingContainer.scrollTop = scrollTop;
                      this.scrollIntoView();
                    }
                  }, {
                    key: 'format',
                    value: function format(name, value) {
                      var _this4 = this;
                      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _emitter4.default.sources.API;
                      return modify.call(this, function () {
                        var range = _this4.getSelection(true);
                        var change = new _quillDelta2.default();
                        if (range == null) {
                          return change;
                        } else if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {
                          change = _this4.editor.formatLine(range.index, range.length, _defineProperty({}, name, value));
                        } else if (range.length === 0) {
                          _this4.selection.format(name, value);
                          return change;
                        } else {
                          change = _this4.editor.formatText(range.index, range.length, _defineProperty({}, name, value));
                        }
                        _this4.setSelection(range, _emitter4.default.sources.SILENT);
                        return change;
                      }, source);
                    }
                  }, {
                    key: 'formatLine',
                    value: function formatLine(index, length, name, value, source) {
                      var _this5 = this;
                      var formats = void 0;
                      var _overload3 = overload(index, length, name, value, source);
                      var _overload4 = _slicedToArray(_overload3, 4);
                      index = _overload4[0];
                      length = _overload4[1];
                      formats = _overload4[2];
                      source = _overload4[3];
                      return modify.call(this, function () {
                        return _this5.editor.formatLine(index, length, formats);
                      }, source, index, 0);
                    }
                  }, {
                    key: 'formatText',
                    value: function formatText(index, length, name, value, source) {
                      var _this6 = this;
                      var formats = void 0;
                      var _overload5 = overload(index, length, name, value, source);
                      var _overload6 = _slicedToArray(_overload5, 4);
                      index = _overload6[0];
                      length = _overload6[1];
                      formats = _overload6[2];
                      source = _overload6[3];
                      return modify.call(this, function () {
                        return _this6.editor.formatText(index, length, formats);
                      }, source, index, 0);
                    }
                  }, {
                    key: 'getBounds',
                    value: function getBounds(index) {
                      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                      var bounds = void 0;
                      if (typeof index === 'number') {
                        bounds = this.selection.getBounds(index, length);
                      } else {
                        bounds = this.selection.getBounds(index.index, index.length);
                      }
                      var containerBounds = this.container.getBoundingClientRect();
                      return {
                        bottom: bounds.bottom - containerBounds.top,
                        height: bounds.height,
                        left: bounds.left - containerBounds.left,
                        right: bounds.right - containerBounds.left,
                        top: bounds.top - containerBounds.top,
                        width: bounds.width
                      };
                    }
                  }, {
                    key: 'getContents',
                    value: function getContents() {
                      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - index;
                      var _overload7 = overload(index, length);
                      var _overload8 = _slicedToArray(_overload7, 2);
                      index = _overload8[0];
                      length = _overload8[1];
                      return this.editor.getContents(index, length);
                    }
                  }, {
                    key: 'getFormat',
                    value: function getFormat() {
                      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getSelection(true);
                      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                      if (typeof index === 'number') {
                        return this.editor.getFormat(index, length);
                      } else {
                        return this.editor.getFormat(index.index, index.length);
                      }
                    }
                  }, {
                    key: 'getIndex',
                    value: function getIndex(blot) {
                      return blot.offset(this.scroll);
                    }
                  }, {
                    key: 'getLength',
                    value: function getLength() {
                      return this.scroll.length();
                    }
                  }, {
                    key: 'getLeaf',
                    value: function getLeaf(index) {
                      return this.scroll.leaf(index);
                    }
                  }, {
                    key: 'getLine',
                    value: function getLine(index) {
                      return this.scroll.line(index);
                    }
                  }, {
                    key: 'getLines',
                    value: function getLines() {
                      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;
                      if (typeof index !== 'number') {
                        return this.scroll.lines(index.index, index.length);
                      } else {
                        return this.scroll.lines(index, length);
                      }
                    }
                  }, {
                    key: 'getModule',
                    value: function getModule(name) {
                      return this.theme.modules[name];
                    }
                  }, {
                    key: 'getSelection',
                    value: function getSelection() {
                      var focus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                      if (focus) this.focus();
                      this.update(); // Make sure we access getRange with editor in consistent state
                      return this.selection.getRange()[0];
                    }
                  }, {
                    key: 'getText',
                    value: function getText() {
                      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - index;
                      var _overload9 = overload(index, length);
                      var _overload10 = _slicedToArray(_overload9, 2);
                      index = _overload10[0];
                      length = _overload10[1];
                      return this.editor.getText(index, length);
                    }
                  }, {
                    key: 'hasFocus',
                    value: function hasFocus() {
                      return this.selection.hasFocus();
                    }
                  }, {
                    key: 'insertEmbed',
                    value: function insertEmbed(index, embed, value) {
                      var _this7 = this;
                      var source = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Quill.sources.API;
                      return modify.call(this, function () {
                        return _this7.editor.insertEmbed(index, embed, value);
                      }, source, index);
                    }
                  }, {
                    key: 'insertText',
                    value: function insertText(index, text, name, value, source) {
                      var _this8 = this;
                      var formats = void 0;
                      var _overload11 = overload(index, 0, name, value, source);
                      var _overload12 = _slicedToArray(_overload11, 4);
                      index = _overload12[0];
                      formats = _overload12[2];
                      source = _overload12[3];
                      return modify.call(this, function () {
                        return _this8.editor.insertText(index, text, formats);
                      }, source, index, text.length);
                    }
                  }, {
                    key: 'isEnabled',
                    value: function isEnabled() {
                      return !this.container.classList.contains('ql-disabled');
                    }
                  }, {
                    key: 'off',
                    value: function off() {
                      return this.emitter.off.apply(this.emitter, arguments);
                    }
                  }, {
                    key: 'on',
                    value: function on() {
                      return this.emitter.on.apply(this.emitter, arguments);
                    }
                  }, {
                    key: 'once',
                    value: function once() {
                      return this.emitter.once.apply(this.emitter, arguments);
                    }
                  }, {
                    key: 'pasteHTML',
                    value: function pasteHTML(index, html, source) {
                      this.clipboard.dangerouslyPasteHTML(index, html, source);
                    }
                  }, {
                    key: 'removeFormat',
                    value: function removeFormat(index, length, source) {
                      var _this9 = this;
                      var _overload13 = overload(index, length, source);
                      var _overload14 = _slicedToArray(_overload13, 4);
                      index = _overload14[0];
                      length = _overload14[1];
                      source = _overload14[3];
                      return modify.call(this, function () {
                        return _this9.editor.removeFormat(index, length);
                      }, source, index);
                    }
                  }, {
                    key: 'scrollIntoView',
                    value: function scrollIntoView() {
                      this.selection.scrollIntoView(this.scrollingContainer);
                    }
                  }, {
                    key: 'setContents',
                    value: function setContents(delta) {
                      var _this10 = this;
                      var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;
                      return modify.call(this, function () {
                        delta = new _quillDelta2.default(delta);
                        var length = _this10.getLength();
                        var deleted = _this10.editor.deleteText(0, length);
                        var applied = _this10.editor.applyDelta(delta);
                        var lastOp = applied.ops[applied.ops.length - 1];
                        if (lastOp != null && typeof lastOp.insert === 'string' && lastOp.insert[lastOp.insert.length - 1] === '\n') {
                          _this10.editor.deleteText(_this10.getLength() - 1, 1);
                          applied.delete(1);
                        }
                        var ret = deleted.compose(applied);
                        return ret;
                      }, source);
                    }
                  }, {
                    key: 'setSelection',
                    value: function setSelection(index, length, source) {
                      if (index == null) {
                        this.selection.setRange(null, length || Quill.sources.API);
                      } else {
                        var _overload15 = overload(index, length, source);
                        var _overload16 = _slicedToArray(_overload15, 4);
                        index = _overload16[0];
                        length = _overload16[1];
                        source = _overload16[3];
                        this.selection.setRange(new _selection.Range(index, length), source);
                        if (source !== _emitter4.default.sources.SILENT) {
                          this.selection.scrollIntoView(this.scrollingContainer);
                        }
                      }
                    }
                  }, {
                    key: 'setText',
                    value: function setText(text) {
                      var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;
                      var delta = new _quillDelta2.default().insert(text);
                      return this.setContents(delta, source);
                    }
                  }, {
                    key: 'update',
                    value: function update() {
                      var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emitter4.default.sources.USER;
                      var change = this.scroll.update(source); // Will update selection before selection.update() does if text changes
                      this.selection.update(source);
                      return change;
                    }
                  }, {
                    key: 'updateContents',
                    value: function updateContents(delta) {
                      var _this11 = this;
                      var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;
                      return modify.call(this, function () {
                        delta = new _quillDelta2.default(delta);
                        return _this11.editor.applyDelta(delta, source);
                      }, source, true);
                    }
                  }]);
                  return Quill;
                }();
                Quill.DEFAULTS = {
                  bounds: null,
                  formats: null,
                  modules: {},
                  placeholder: '',
                  readOnly: false,
                  scrollingContainer: null,
                  strict: true,
                  theme: 'default'
                };
                Quill.events = _emitter4.default.events;
                Quill.sources = _emitter4.default.sources;
                // eslint-disable-next-line no-undef
                Quill.version = "1.3.7";
                Quill.imports = {
                  'delta': _quillDelta2.default,
                  'parchment': _parchment2.default,
                  'core/module': _module2.default,
                  'core/theme': _theme2.default
                };
                function expandConfig(container, userConfig) {
                  userConfig = (0, _extend2.default)(true, {
                    container: container,
                    modules: {
                      clipboard: true,
                      keyboard: true,
                      history: true
                    }
                  }, userConfig);
                  if (!userConfig.theme || userConfig.theme === Quill.DEFAULTS.theme) {
                    userConfig.theme = _theme2.default;
                  } else {
                    userConfig.theme = Quill.import('themes/' + userConfig.theme);
                    if (userConfig.theme == null) {
                      throw new Error('Invalid theme ' + userConfig.theme + '. Did you register it?');
                    }
                  }
                  var themeConfig = (0, _extend2.default)(true, {}, userConfig.theme.DEFAULTS);
                  [themeConfig, userConfig].forEach(function (config) {
                    config.modules = config.modules || {};
                    Object.keys(config.modules).forEach(function (module) {
                      if (config.modules[module] === true) {
                        config.modules[module] = {};
                      }
                    });
                  });
                  var moduleNames = Object.keys(themeConfig.modules).concat(Object.keys(userConfig.modules));
                  var moduleConfig = moduleNames.reduce(function (config, name) {
                    var moduleClass = Quill.import('modules/' + name);
                    if (moduleClass == null) {
                      debug.error('Cannot load ' + name + ' module. Are you sure you registered it?');
                    } else {
                      config[name] = moduleClass.DEFAULTS || {};
                    }
                    return config;
                  }, {});
                  // Special case toolbar shorthand
                  if (userConfig.modules != null && userConfig.modules.toolbar && userConfig.modules.toolbar.constructor !== Object) {
                    userConfig.modules.toolbar = {
                      container: userConfig.modules.toolbar
                    };
                  }
                  userConfig = (0, _extend2.default)(true, {}, Quill.DEFAULTS, {
                    modules: moduleConfig
                  }, themeConfig, userConfig);
                  ['bounds', 'container', 'scrollingContainer'].forEach(function (key) {
                    if (typeof userConfig[key] === 'string') {
                      userConfig[key] = document.querySelector(userConfig[key]);
                    }
                  });
                  userConfig.modules = Object.keys(userConfig.modules).reduce(function (config, name) {
                    if (userConfig.modules[name]) {
                      config[name] = userConfig.modules[name];
                    }
                    return config;
                  }, {});
                  return userConfig;
                }

                // Handle selection preservation and TEXT_CHANGE emission
                // common to modification APIs
                function modify(modifier, source, index, shift) {
                  if (this.options.strict && !this.isEnabled() && source === _emitter4.default.sources.USER) {
                    return new _quillDelta2.default();
                  }
                  var range = index == null ? null : this.getSelection();
                  var oldDelta = this.editor.delta;
                  var change = modifier();
                  if (range != null) {
                    if (index === true) index = range.index;
                    if (shift == null) {
                      range = shiftRange(range, change, source);
                    } else if (shift !== 0) {
                      range = shiftRange(range, index, shift, source);
                    }
                    this.setSelection(range, _emitter4.default.sources.SILENT);
                  }
                  if (change.length() > 0) {
                    var _emitter;
                    var args = [_emitter4.default.events.TEXT_CHANGE, change, oldDelta, source];
                    (_emitter = this.emitter).emit.apply(_emitter, [_emitter4.default.events.EDITOR_CHANGE].concat(args));
                    if (source !== _emitter4.default.sources.SILENT) {
                      var _emitter2;
                      (_emitter2 = this.emitter).emit.apply(_emitter2, args);
                    }
                  }
                  return change;
                }
                function overload(index, length, name, value, source) {
                  var formats = {};
                  if (typeof index.index === 'number' && typeof index.length === 'number') {
                    // Allow for throwaway end (used by insertText/insertEmbed)
                    if (typeof length !== 'number') {
                      source = value, value = name, name = length, length = index.length, index = index.index;
                    } else {
                      length = index.length, index = index.index;
                    }
                  } else if (typeof length !== 'number') {
                    source = value, value = name, name = length, length = 0;
                  }
                  // Handle format being object, two format name/value strings or excluded
                  if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
                    formats = name;
                    source = value;
                  } else if (typeof name === 'string') {
                    if (value != null) {
                      formats[name] = value;
                    } else {
                      source = name;
                    }
                  }
                  // Handle optional source
                  source = source || _emitter4.default.sources.API;
                  return [index, length, formats, source];
                }
                function shiftRange(range, index, length, source) {
                  if (range == null) return null;
                  var start = void 0,
                    end = void 0;
                  if (index instanceof _quillDelta2.default) {
                    var _map = [range.index, range.index + range.length].map(function (pos) {
                      return index.transformPosition(pos, source !== _emitter4.default.sources.USER);
                    });
                    var _map2 = _slicedToArray(_map, 2);
                    start = _map2[0];
                    end = _map2[1];
                  } else {
                    var _map3 = [range.index, range.index + range.length].map(function (pos) {
                      if (pos < index || pos === index && source === _emitter4.default.sources.USER) return pos;
                      if (length >= 0) {
                        return pos + length;
                      } else {
                        return Math.max(index, pos + length);
                      }
                    });
                    var _map4 = _slicedToArray(_map3, 2);
                    start = _map4[0];
                    end = _map4[1];
                  }
                  return new _selection.Range(start, end - start);
                }
                exports.expandConfig = expandConfig;
                exports.overload = overload;
                exports.default = Quill;

                /***/
              }, /* 6 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _get = function get(object, property, receiver) {
                  if (object === null) object = Function.prototype;
                  var desc = Object.getOwnPropertyDescriptor(object, property);
                  if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                      return undefined;
                    } else {
                      return get(parent, property, receiver);
                    }
                  } else if ("value" in desc) {
                    return desc.value;
                  } else {
                    var getter = desc.get;
                    if (getter === undefined) {
                      return undefined;
                    }
                    return getter.call(receiver);
                  }
                };
                var _text = __webpack_require__(7);
                var _text2 = _interopRequireDefault(_text);
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var Inline = function (_Parchment$Inline) {
                  _inherits(Inline, _Parchment$Inline);
                  function Inline() {
                    _classCallCheck(this, Inline);
                    return _possibleConstructorReturn(this, (Inline.__proto__ || Object.getPrototypeOf(Inline)).apply(this, arguments));
                  }
                  _createClass(Inline, [{
                    key: 'formatAt',
                    value: function formatAt(index, length, name, value) {
                      if (Inline.compare(this.statics.blotName, name) < 0 && _parchment2.default.query(name, _parchment2.default.Scope.BLOT)) {
                        var blot = this.isolate(index, length);
                        if (value) {
                          blot.wrap(name, value);
                        }
                      } else {
                        _get(Inline.prototype.__proto__ || Object.getPrototypeOf(Inline.prototype), 'formatAt', this).call(this, index, length, name, value);
                      }
                    }
                  }, {
                    key: 'optimize',
                    value: function optimize(context) {
                      _get(Inline.prototype.__proto__ || Object.getPrototypeOf(Inline.prototype), 'optimize', this).call(this, context);
                      if (this.parent instanceof Inline && Inline.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {
                        var parent = this.parent.isolate(this.offset(), this.length());
                        this.moveChildren(parent);
                        parent.wrap(this);
                      }
                    }
                  }], [{
                    key: 'compare',
                    value: function compare(self, other) {
                      var selfIndex = Inline.order.indexOf(self);
                      var otherIndex = Inline.order.indexOf(other);
                      if (selfIndex >= 0 || otherIndex >= 0) {
                        return selfIndex - otherIndex;
                      } else if (self === other) {
                        return 0;
                      } else if (self < other) {
                        return -1;
                      } else {
                        return 1;
                      }
                    }
                  }]);
                  return Inline;
                }(_parchment2.default.Inline);
                Inline.allowedChildren = [Inline, _parchment2.default.Embed, _text2.default];
                // Lower index means deeper in the DOM tree, since not found (-1) is for embeds
                Inline.order = ['cursor', 'inline',
                // Must be lower
                'underline', 'strike', 'italic', 'bold', 'script', 'link', 'code' // Must be higher
                ];

                exports.default = Inline;

                /***/
              }, /* 7 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var TextBlot = function (_Parchment$Text) {
                  _inherits(TextBlot, _Parchment$Text);
                  function TextBlot() {
                    _classCallCheck(this, TextBlot);
                    return _possibleConstructorReturn(this, (TextBlot.__proto__ || Object.getPrototypeOf(TextBlot)).apply(this, arguments));
                  }
                  return TextBlot;
                }(_parchment2.default.Text);
                exports.default = TextBlot;

                /***/
              }, /* 8 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _get = function get(object, property, receiver) {
                  if (object === null) object = Function.prototype;
                  var desc = Object.getOwnPropertyDescriptor(object, property);
                  if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                      return undefined;
                    } else {
                      return get(parent, property, receiver);
                    }
                  } else if ("value" in desc) {
                    return desc.value;
                  } else {
                    var getter = desc.get;
                    if (getter === undefined) {
                      return undefined;
                    }
                    return getter.call(receiver);
                  }
                };
                var _eventemitter = __webpack_require__(54);
                var _eventemitter2 = _interopRequireDefault(_eventemitter);
                var _logger = __webpack_require__(10);
                var _logger2 = _interopRequireDefault(_logger);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var debug = (0, _logger2.default)('quill:events');
                var EVENTS = ['selectionchange', 'mousedown', 'mouseup', 'click'];
                EVENTS.forEach(function (eventName) {
                  document.addEventListener(eventName, function () {
                    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                      args[_key] = arguments[_key];
                    }
                    [].slice.call(document.querySelectorAll('.ql-container')).forEach(function (node) {
                      // TODO use WeakMap
                      if (node.__quill && node.__quill.emitter) {
                        var _node$__quill$emitter;
                        (_node$__quill$emitter = node.__quill.emitter).handleDOM.apply(_node$__quill$emitter, args);
                      }
                    });
                  });
                });
                var Emitter = function (_EventEmitter) {
                  _inherits(Emitter, _EventEmitter);
                  function Emitter() {
                    _classCallCheck(this, Emitter);
                    var _this = _possibleConstructorReturn(this, (Emitter.__proto__ || Object.getPrototypeOf(Emitter)).call(this));
                    _this.listeners = {};
                    _this.on('error', debug.error);
                    return _this;
                  }
                  _createClass(Emitter, [{
                    key: 'emit',
                    value: function emit() {
                      debug.log.apply(debug, arguments);
                      _get(Emitter.prototype.__proto__ || Object.getPrototypeOf(Emitter.prototype), 'emit', this).apply(this, arguments);
                    }
                  }, {
                    key: 'handleDOM',
                    value: function handleDOM(event) {
                      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                        args[_key2 - 1] = arguments[_key2];
                      }
                      (this.listeners[event.type] || []).forEach(function (_ref) {
                        var node = _ref.node,
                          handler = _ref.handler;
                        if (event.target === node || node.contains(event.target)) {
                          handler.apply(undefined, [event].concat(args));
                        }
                      });
                    }
                  }, {
                    key: 'listenDOM',
                    value: function listenDOM(eventName, node, handler) {
                      if (!this.listeners[eventName]) {
                        this.listeners[eventName] = [];
                      }
                      this.listeners[eventName].push({
                        node: node,
                        handler: handler
                      });
                    }
                  }]);
                  return Emitter;
                }(_eventemitter2.default);
                Emitter.events = {
                  EDITOR_CHANGE: 'editor-change',
                  SCROLL_BEFORE_UPDATE: 'scroll-before-update',
                  SCROLL_OPTIMIZE: 'scroll-optimize',
                  SCROLL_UPDATE: 'scroll-update',
                  SELECTION_CHANGE: 'selection-change',
                  TEXT_CHANGE: 'text-change'
                };
                Emitter.sources = {
                  API: 'api',
                  SILENT: 'silent',
                  USER: 'user'
                };
                exports.default = Emitter;

                /***/
              }, /* 9 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                var Module = function Module(quill) {
                  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                  _classCallCheck(this, Module);
                  this.quill = quill;
                  this.options = options;
                };
                Module.DEFAULTS = {};
                exports.default = Module;

                /***/
              }, /* 10 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var levels = ['error', 'warn', 'log', 'info'];
                var level = 'warn';
                function debug(method) {
                  if (levels.indexOf(method) <= levels.indexOf(level)) {
                    var _console;
                    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                      args[_key - 1] = arguments[_key];
                    }
                    (_console = console)[method].apply(_console, args); // eslint-disable-line no-console
                  }
                }

                function namespace(ns) {
                  return levels.reduce(function (logger, method) {
                    logger[method] = debug.bind(console, method, ns);
                    return logger;
                  }, {});
                }
                debug.level = namespace.level = function (newLevel) {
                  level = newLevel;
                };
                exports.default = namespace;

                /***/
              }, /* 11 */
              /***/function (module, exports, __webpack_require__) {
                var pSlice = Array.prototype.slice;
                var objectKeys = __webpack_require__(52);
                var isArguments = __webpack_require__(53);
                var deepEqual = module.exports = function (actual, expected, opts) {
                  if (!opts) opts = {};
                  // 7.1. All identical values are equivalent, as determined by ===.
                  if (actual === expected) {
                    return true;
                  } else if (actual instanceof Date && expected instanceof Date) {
                    return actual.getTime() === expected.getTime();

                    // 7.3. Other pairs that do not both pass typeof value == 'object',
                    // equivalence is determined by ==.
                  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
                    return opts.strict ? actual === expected : actual == expected;

                    // 7.4. For all other Object pairs, including Array objects, equivalence is
                    // determined by having the same number of owned properties (as verified
                    // with Object.prototype.hasOwnProperty.call), the same set of keys
                    // (although not necessarily the same order), equivalent values for every
                    // corresponding key, and an identical 'prototype' property. Note: this
                    // accounts for both named and indexed properties on Arrays.
                  } else {
                    return objEquiv(actual, expected, opts);
                  }
                };
                function isUndefinedOrNull(value) {
                  return value === null || value === undefined;
                }
                function isBuffer(x) {
                  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
                  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
                    return false;
                  }
                  if (x.length > 0 && typeof x[0] !== 'number') return false;
                  return true;
                }
                function objEquiv(a, b, opts) {
                  var i, key;
                  if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return false;
                  // an identical 'prototype' property.
                  if (a.prototype !== b.prototype) return false;
                  //~~~I've managed to break Object.keys through screwy arguments passing.
                  //   Converting to array solves the problem.
                  if (isArguments(a)) {
                    if (!isArguments(b)) {
                      return false;
                    }
                    a = pSlice.call(a);
                    b = pSlice.call(b);
                    return deepEqual(a, b, opts);
                  }
                  if (isBuffer(a)) {
                    if (!isBuffer(b)) {
                      return false;
                    }
                    if (a.length !== b.length) return false;
                    for (i = 0; i < a.length; i++) {
                      if (a[i] !== b[i]) return false;
                    }
                    return true;
                  }
                  try {
                    var ka = objectKeys(a),
                      kb = objectKeys(b);
                  } catch (e) {
                    //happens when one is a string literal and the other isn't
                    return false;
                  }
                  // having the same number of owned properties (keys incorporates
                  // hasOwnProperty)
                  if (ka.length != kb.length) return false;
                  //the same set of keys (although not necessarily the same order),
                  ka.sort();
                  kb.sort();
                  //~~~cheap key test
                  for (i = ka.length - 1; i >= 0; i--) {
                    if (ka[i] != kb[i]) return false;
                  }
                  //equivalent values for every corresponding key, and
                  //~~~possibly expensive deep test
                  for (i = ka.length - 1; i >= 0; i--) {
                    key = ka[i];
                    if (!deepEqual(a[key], b[key], opts)) return false;
                  }
                  return typeof a === typeof b;
                }

                /***/
              }, /* 12 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var Registry = __webpack_require__(1);
                var Attributor = /** @class */function () {
                  function Attributor(attrName, keyName, options) {
                    if (options === void 0) {
                      options = {};
                    }
                    this.attrName = attrName;
                    this.keyName = keyName;
                    var attributeBit = Registry.Scope.TYPE & Registry.Scope.ATTRIBUTE;
                    if (options.scope != null) {
                      // Ignore type bits, force attribute bit
                      this.scope = options.scope & Registry.Scope.LEVEL | attributeBit;
                    } else {
                      this.scope = Registry.Scope.ATTRIBUTE;
                    }
                    if (options.whitelist != null) this.whitelist = options.whitelist;
                  }
                  Attributor.keys = function (node) {
                    return [].map.call(node.attributes, function (item) {
                      return item.name;
                    });
                  };
                  Attributor.prototype.add = function (node, value) {
                    if (!this.canAdd(node, value)) return false;
                    node.setAttribute(this.keyName, value);
                    return true;
                  };
                  Attributor.prototype.canAdd = function (node, value) {
                    var match = Registry.query(node, Registry.Scope.BLOT & (this.scope | Registry.Scope.TYPE));
                    if (match == null) return false;
                    if (this.whitelist == null) return true;
                    if (typeof value === 'string') {
                      return this.whitelist.indexOf(value.replace(/["']/g, '')) > -1;
                    } else {
                      return this.whitelist.indexOf(value) > -1;
                    }
                  };
                  Attributor.prototype.remove = function (node) {
                    node.removeAttribute(this.keyName);
                  };
                  Attributor.prototype.value = function (node) {
                    var value = node.getAttribute(this.keyName);
                    if (this.canAdd(node, value) && value) {
                      return value;
                    }
                    return '';
                  };
                  return Attributor;
                }();
                exports.default = Attributor;

                /***/
              }, /* 13 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.default = exports.Code = undefined;
                var _slicedToArray = function () {
                  function sliceIterator(arr, i) {
                    var _arr = [];
                    var _n = true;
                    var _d = false;
                    var _e = undefined;
                    try {
                      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                        _arr.push(_s.value);
                        if (i && _arr.length === i) break;
                      }
                    } catch (err) {
                      _d = true;
                      _e = err;
                    } finally {
                      try {
                        if (!_n && _i["return"]) _i["return"]();
                      } finally {
                        if (_d) throw _e;
                      }
                    }
                    return _arr;
                  }
                  return function (arr, i) {
                    if (Array.isArray(arr)) {
                      return arr;
                    } else if (Symbol.iterator in Object(arr)) {
                      return sliceIterator(arr, i);
                    } else {
                      throw new TypeError("Invalid attempt to destructure non-iterable instance");
                    }
                  };
                }();
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _get = function get(object, property, receiver) {
                  if (object === null) object = Function.prototype;
                  var desc = Object.getOwnPropertyDescriptor(object, property);
                  if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                      return undefined;
                    } else {
                      return get(parent, property, receiver);
                    }
                  } else if ("value" in desc) {
                    return desc.value;
                  } else {
                    var getter = desc.get;
                    if (getter === undefined) {
                      return undefined;
                    }
                    return getter.call(receiver);
                  }
                };
                var _quillDelta = __webpack_require__(2);
                var _quillDelta2 = _interopRequireDefault(_quillDelta);
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _block = __webpack_require__(4);
                var _block2 = _interopRequireDefault(_block);
                var _inline = __webpack_require__(6);
                var _inline2 = _interopRequireDefault(_inline);
                var _text = __webpack_require__(7);
                var _text2 = _interopRequireDefault(_text);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var Code = function (_Inline) {
                  _inherits(Code, _Inline);
                  function Code() {
                    _classCallCheck(this, Code);
                    return _possibleConstructorReturn(this, (Code.__proto__ || Object.getPrototypeOf(Code)).apply(this, arguments));
                  }
                  return Code;
                }(_inline2.default);
                Code.blotName = 'code';
                Code.tagName = 'CODE';
                var CodeBlock = function (_Block) {
                  _inherits(CodeBlock, _Block);
                  function CodeBlock() {
                    _classCallCheck(this, CodeBlock);
                    return _possibleConstructorReturn(this, (CodeBlock.__proto__ || Object.getPrototypeOf(CodeBlock)).apply(this, arguments));
                  }
                  _createClass(CodeBlock, [{
                    key: 'delta',
                    value: function delta() {
                      var _this3 = this;
                      var text = this.domNode.textContent;
                      if (text.endsWith('\n')) {
                        // Should always be true
                        text = text.slice(0, -1);
                      }
                      return text.split('\n').reduce(function (delta, frag) {
                        return delta.insert(frag).insert('\n', _this3.formats());
                      }, new _quillDelta2.default());
                    }
                  }, {
                    key: 'format',
                    value: function format(name, value) {
                      if (name === this.statics.blotName && value) return;
                      var _descendant = this.descendant(_text2.default, this.length() - 1),
                        _descendant2 = _slicedToArray(_descendant, 1),
                        text = _descendant2[0];
                      if (text != null) {
                        text.deleteAt(text.length() - 1, 1);
                      }
                      _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), 'format', this).call(this, name, value);
                    }
                  }, {
                    key: 'formatAt',
                    value: function formatAt(index, length, name, value) {
                      if (length === 0) return;
                      if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK) == null || name === this.statics.blotName && value === this.statics.formats(this.domNode)) {
                        return;
                      }
                      var nextNewline = this.newlineIndex(index);
                      if (nextNewline < 0 || nextNewline >= index + length) return;
                      var prevNewline = this.newlineIndex(index, true) + 1;
                      var isolateLength = nextNewline - prevNewline + 1;
                      var blot = this.isolate(prevNewline, isolateLength);
                      var next = blot.next;
                      blot.format(name, value);
                      if (next instanceof CodeBlock) {
                        next.formatAt(0, index - prevNewline + length - isolateLength, name, value);
                      }
                    }
                  }, {
                    key: 'insertAt',
                    value: function insertAt(index, value, def) {
                      if (def != null) return;
                      var _descendant3 = this.descendant(_text2.default, index),
                        _descendant4 = _slicedToArray(_descendant3, 2),
                        text = _descendant4[0],
                        offset = _descendant4[1];
                      text.insertAt(offset, value);
                    }
                  }, {
                    key: 'length',
                    value: function length() {
                      var length = this.domNode.textContent.length;
                      if (!this.domNode.textContent.endsWith('\n')) {
                        return length + 1;
                      }
                      return length;
                    }
                  }, {
                    key: 'newlineIndex',
                    value: function newlineIndex(searchIndex) {
                      var reverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                      if (!reverse) {
                        var offset = this.domNode.textContent.slice(searchIndex).indexOf('\n');
                        return offset > -1 ? searchIndex + offset : -1;
                      } else {
                        return this.domNode.textContent.slice(0, searchIndex).lastIndexOf('\n');
                      }
                    }
                  }, {
                    key: 'optimize',
                    value: function optimize(context) {
                      if (!this.domNode.textContent.endsWith('\n')) {
                        this.appendChild(_parchment2.default.create('text', '\n'));
                      }
                      _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), 'optimize', this).call(this, context);
                      var next = this.next;
                      if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && this.statics.formats(this.domNode) === next.statics.formats(next.domNode)) {
                        next.optimize(context);
                        next.moveChildren(this);
                        next.remove();
                      }
                    }
                  }, {
                    key: 'replace',
                    value: function replace(target) {
                      _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), 'replace', this).call(this, target);
                      [].slice.call(this.domNode.querySelectorAll('*')).forEach(function (node) {
                        var blot = _parchment2.default.find(node);
                        if (blot == null) {
                          node.parentNode.removeChild(node);
                        } else if (blot instanceof _parchment2.default.Embed) {
                          blot.remove();
                        } else {
                          blot.unwrap();
                        }
                      });
                    }
                  }], [{
                    key: 'create',
                    value: function create(value) {
                      var domNode = _get(CodeBlock.__proto__ || Object.getPrototypeOf(CodeBlock), 'create', this).call(this, value);
                      domNode.setAttribute('spellcheck', false);
                      return domNode;
                    }
                  }, {
                    key: 'formats',
                    value: function formats() {
                      return true;
                    }
                  }]);
                  return CodeBlock;
                }(_block2.default);
                CodeBlock.blotName = 'code-block';
                CodeBlock.tagName = 'PRE';
                CodeBlock.TAB = '  ';
                exports.Code = Code;
                exports.default = CodeBlock;

                /***/
              }, /* 14 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
                  return typeof obj;
                } : function (obj) {
                  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
                var _slicedToArray = function () {
                  function sliceIterator(arr, i) {
                    var _arr = [];
                    var _n = true;
                    var _d = false;
                    var _e = undefined;
                    try {
                      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                        _arr.push(_s.value);
                        if (i && _arr.length === i) break;
                      }
                    } catch (err) {
                      _d = true;
                      _e = err;
                    } finally {
                      try {
                        if (!_n && _i["return"]) _i["return"]();
                      } finally {
                        if (_d) throw _e;
                      }
                    }
                    return _arr;
                  }
                  return function (arr, i) {
                    if (Array.isArray(arr)) {
                      return arr;
                    } else if (Symbol.iterator in Object(arr)) {
                      return sliceIterator(arr, i);
                    } else {
                      throw new TypeError("Invalid attempt to destructure non-iterable instance");
                    }
                  };
                }();
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _quillDelta = __webpack_require__(2);
                var _quillDelta2 = _interopRequireDefault(_quillDelta);
                var _op = __webpack_require__(20);
                var _op2 = _interopRequireDefault(_op);
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _code = __webpack_require__(13);
                var _code2 = _interopRequireDefault(_code);
                var _cursor = __webpack_require__(24);
                var _cursor2 = _interopRequireDefault(_cursor);
                var _block = __webpack_require__(4);
                var _block2 = _interopRequireDefault(_block);
                var _break = __webpack_require__(16);
                var _break2 = _interopRequireDefault(_break);
                var _clone = __webpack_require__(21);
                var _clone2 = _interopRequireDefault(_clone);
                var _deepEqual = __webpack_require__(11);
                var _deepEqual2 = _interopRequireDefault(_deepEqual);
                var _extend = __webpack_require__(3);
                var _extend2 = _interopRequireDefault(_extend);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _defineProperty(obj, key, value) {
                  if (key in obj) {
                    Object.defineProperty(obj, key, {
                      value: value,
                      enumerable: true,
                      configurable: true,
                      writable: true
                    });
                  } else {
                    obj[key] = value;
                  }
                  return obj;
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                var ASCII = /^[ -~]*$/;
                var Editor = function () {
                  function Editor(scroll) {
                    _classCallCheck(this, Editor);
                    this.scroll = scroll;
                    this.delta = this.getDelta();
                  }
                  _createClass(Editor, [{
                    key: 'applyDelta',
                    value: function applyDelta(delta) {
                      var _this = this;
                      var consumeNextNewline = false;
                      this.scroll.update();
                      var scrollLength = this.scroll.length();
                      this.scroll.batchStart();
                      delta = normalizeDelta(delta);
                      delta.reduce(function (index, op) {
                        var length = op.retain || op.delete || op.insert.length || 1;
                        var attributes = op.attributes || {};
                        if (op.insert != null) {
                          if (typeof op.insert === 'string') {
                            var text = op.insert;
                            if (text.endsWith('\n') && consumeNextNewline) {
                              consumeNextNewline = false;
                              text = text.slice(0, -1);
                            }
                            if (index >= scrollLength && !text.endsWith('\n')) {
                              consumeNextNewline = true;
                            }
                            _this.scroll.insertAt(index, text);
                            var _scroll$line = _this.scroll.line(index),
                              _scroll$line2 = _slicedToArray(_scroll$line, 2),
                              line = _scroll$line2[0],
                              offset = _scroll$line2[1];
                            var formats = (0, _extend2.default)({}, (0, _block.bubbleFormats)(line));
                            if (line instanceof _block2.default) {
                              var _line$descendant = line.descendant(_parchment2.default.Leaf, offset),
                                _line$descendant2 = _slicedToArray(_line$descendant, 1),
                                leaf = _line$descendant2[0];
                              formats = (0, _extend2.default)(formats, (0, _block.bubbleFormats)(leaf));
                            }
                            attributes = _op2.default.attributes.diff(formats, attributes) || {};
                          } else if (_typeof(op.insert) === 'object') {
                            var key = Object.keys(op.insert)[0]; // There should only be one key
                            if (key == null) return index;
                            _this.scroll.insertAt(index, key, op.insert[key]);
                          }
                          scrollLength += length;
                        }
                        Object.keys(attributes).forEach(function (name) {
                          _this.scroll.formatAt(index, length, name, attributes[name]);
                        });
                        return index + length;
                      }, 0);
                      delta.reduce(function (index, op) {
                        if (typeof op.delete === 'number') {
                          _this.scroll.deleteAt(index, op.delete);
                          return index;
                        }
                        return index + (op.retain || op.insert.length || 1);
                      }, 0);
                      this.scroll.batchEnd();
                      return this.update(delta);
                    }
                  }, {
                    key: 'deleteText',
                    value: function deleteText(index, length) {
                      this.scroll.deleteAt(index, length);
                      return this.update(new _quillDelta2.default().retain(index).delete(length));
                    }
                  }, {
                    key: 'formatLine',
                    value: function formatLine(index, length) {
                      var _this2 = this;
                      var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                      this.scroll.update();
                      Object.keys(formats).forEach(function (format) {
                        if (_this2.scroll.whitelist != null && !_this2.scroll.whitelist[format]) return;
                        var lines = _this2.scroll.lines(index, Math.max(length, 1));
                        var lengthRemaining = length;
                        lines.forEach(function (line) {
                          var lineLength = line.length();
                          if (!(line instanceof _code2.default)) {
                            line.format(format, formats[format]);
                          } else {
                            var codeIndex = index - line.offset(_this2.scroll);
                            var codeLength = line.newlineIndex(codeIndex + lengthRemaining) - codeIndex + 1;
                            line.formatAt(codeIndex, codeLength, format, formats[format]);
                          }
                          lengthRemaining -= lineLength;
                        });
                      });
                      this.scroll.optimize();
                      return this.update(new _quillDelta2.default().retain(index).retain(length, (0, _clone2.default)(formats)));
                    }
                  }, {
                    key: 'formatText',
                    value: function formatText(index, length) {
                      var _this3 = this;
                      var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                      Object.keys(formats).forEach(function (format) {
                        _this3.scroll.formatAt(index, length, format, formats[format]);
                      });
                      return this.update(new _quillDelta2.default().retain(index).retain(length, (0, _clone2.default)(formats)));
                    }
                  }, {
                    key: 'getContents',
                    value: function getContents(index, length) {
                      return this.delta.slice(index, index + length);
                    }
                  }, {
                    key: 'getDelta',
                    value: function getDelta() {
                      return this.scroll.lines().reduce(function (delta, line) {
                        return delta.concat(line.delta());
                      }, new _quillDelta2.default());
                    }
                  }, {
                    key: 'getFormat',
                    value: function getFormat(index) {
                      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                      var lines = [],
                        leaves = [];
                      if (length === 0) {
                        this.scroll.path(index).forEach(function (path) {
                          var _path = _slicedToArray(path, 1),
                            blot = _path[0];
                          if (blot instanceof _block2.default) {
                            lines.push(blot);
                          } else if (blot instanceof _parchment2.default.Leaf) {
                            leaves.push(blot);
                          }
                        });
                      } else {
                        lines = this.scroll.lines(index, length);
                        leaves = this.scroll.descendants(_parchment2.default.Leaf, index, length);
                      }
                      var formatsArr = [lines, leaves].map(function (blots) {
                        if (blots.length === 0) return {};
                        var formats = (0, _block.bubbleFormats)(blots.shift());
                        while (Object.keys(formats).length > 0) {
                          var blot = blots.shift();
                          if (blot == null) return formats;
                          formats = combineFormats((0, _block.bubbleFormats)(blot), formats);
                        }
                        return formats;
                      });
                      return _extend2.default.apply(_extend2.default, formatsArr);
                    }
                  }, {
                    key: 'getText',
                    value: function getText(index, length) {
                      return this.getContents(index, length).filter(function (op) {
                        return typeof op.insert === 'string';
                      }).map(function (op) {
                        return op.insert;
                      }).join('');
                    }
                  }, {
                    key: 'insertEmbed',
                    value: function insertEmbed(index, embed, value) {
                      this.scroll.insertAt(index, embed, value);
                      return this.update(new _quillDelta2.default().retain(index).insert(_defineProperty({}, embed, value)));
                    }
                  }, {
                    key: 'insertText',
                    value: function insertText(index, text) {
                      var _this4 = this;
                      var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                      text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                      this.scroll.insertAt(index, text);
                      Object.keys(formats).forEach(function (format) {
                        _this4.scroll.formatAt(index, text.length, format, formats[format]);
                      });
                      return this.update(new _quillDelta2.default().retain(index).insert(text, (0, _clone2.default)(formats)));
                    }
                  }, {
                    key: 'isBlank',
                    value: function isBlank() {
                      if (this.scroll.children.length == 0) return true;
                      if (this.scroll.children.length > 1) return false;
                      var block = this.scroll.children.head;
                      if (block.statics.blotName !== _block2.default.blotName) return false;
                      if (block.children.length > 1) return false;
                      return block.children.head instanceof _break2.default;
                    }
                  }, {
                    key: 'removeFormat',
                    value: function removeFormat(index, length) {
                      var text = this.getText(index, length);
                      var _scroll$line3 = this.scroll.line(index + length),
                        _scroll$line4 = _slicedToArray(_scroll$line3, 2),
                        line = _scroll$line4[0],
                        offset = _scroll$line4[1];
                      var suffixLength = 0,
                        suffix = new _quillDelta2.default();
                      if (line != null) {
                        if (!(line instanceof _code2.default)) {
                          suffixLength = line.length() - offset;
                        } else {
                          suffixLength = line.newlineIndex(offset) - offset + 1;
                        }
                        suffix = line.delta().slice(offset, offset + suffixLength - 1).insert('\n');
                      }
                      var contents = this.getContents(index, length + suffixLength);
                      var diff = contents.diff(new _quillDelta2.default().insert(text).concat(suffix));
                      var delta = new _quillDelta2.default().retain(index).concat(diff);
                      return this.applyDelta(delta);
                    }
                  }, {
                    key: 'update',
                    value: function update(change) {
                      var mutations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
                      var cursorIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
                      var oldDelta = this.delta;
                      if (mutations.length === 1 && mutations[0].type === 'characterData' && mutations[0].target.data.match(ASCII) && _parchment2.default.find(mutations[0].target)) {
                        // Optimization for character changes
                        var textBlot = _parchment2.default.find(mutations[0].target);
                        var formats = (0, _block.bubbleFormats)(textBlot);
                        var index = textBlot.offset(this.scroll);
                        var oldValue = mutations[0].oldValue.replace(_cursor2.default.CONTENTS, '');
                        var oldText = new _quillDelta2.default().insert(oldValue);
                        var newText = new _quillDelta2.default().insert(textBlot.value());
                        var diffDelta = new _quillDelta2.default().retain(index).concat(oldText.diff(newText, cursorIndex));
                        change = diffDelta.reduce(function (delta, op) {
                          if (op.insert) {
                            return delta.insert(op.insert, formats);
                          } else {
                            return delta.push(op);
                          }
                        }, new _quillDelta2.default());
                        this.delta = oldDelta.compose(change);
                      } else {
                        this.delta = this.getDelta();
                        if (!change || !(0, _deepEqual2.default)(oldDelta.compose(change), this.delta)) {
                          change = oldDelta.diff(this.delta, cursorIndex);
                        }
                      }
                      return change;
                    }
                  }]);
                  return Editor;
                }();
                function combineFormats(formats, combined) {
                  return Object.keys(combined).reduce(function (merged, name) {
                    if (formats[name] == null) return merged;
                    if (combined[name] === formats[name]) {
                      merged[name] = combined[name];
                    } else if (Array.isArray(combined[name])) {
                      if (combined[name].indexOf(formats[name]) < 0) {
                        merged[name] = combined[name].concat([formats[name]]);
                      }
                    } else {
                      merged[name] = [combined[name], formats[name]];
                    }
                    return merged;
                  }, {});
                }
                function normalizeDelta(delta) {
                  return delta.reduce(function (delta, op) {
                    if (op.insert === 1) {
                      var attributes = (0, _clone2.default)(op.attributes);
                      delete attributes['image'];
                      return delta.insert({
                        image: op.attributes.image
                      }, attributes);
                    }
                    if (op.attributes != null && (op.attributes.list === true || op.attributes.bullet === true)) {
                      op = (0, _clone2.default)(op);
                      if (op.attributes.list) {
                        op.attributes.list = 'ordered';
                      } else {
                        op.attributes.list = 'bullet';
                        delete op.attributes.bullet;
                      }
                    }
                    if (typeof op.insert === 'string') {
                      var text = op.insert.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                      return delta.insert(text, op.attributes);
                    }
                    return delta.push(op);
                  }, new _quillDelta2.default());
                }
                exports.default = Editor;

                /***/
              }, /* 15 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.default = exports.Range = undefined;
                var _slicedToArray = function () {
                  function sliceIterator(arr, i) {
                    var _arr = [];
                    var _n = true;
                    var _d = false;
                    var _e = undefined;
                    try {
                      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                        _arr.push(_s.value);
                        if (i && _arr.length === i) break;
                      }
                    } catch (err) {
                      _d = true;
                      _e = err;
                    } finally {
                      try {
                        if (!_n && _i["return"]) _i["return"]();
                      } finally {
                        if (_d) throw _e;
                      }
                    }
                    return _arr;
                  }
                  return function (arr, i) {
                    if (Array.isArray(arr)) {
                      return arr;
                    } else if (Symbol.iterator in Object(arr)) {
                      return sliceIterator(arr, i);
                    } else {
                      throw new TypeError("Invalid attempt to destructure non-iterable instance");
                    }
                  };
                }();
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _clone = __webpack_require__(21);
                var _clone2 = _interopRequireDefault(_clone);
                var _deepEqual = __webpack_require__(11);
                var _deepEqual2 = _interopRequireDefault(_deepEqual);
                var _emitter3 = __webpack_require__(8);
                var _emitter4 = _interopRequireDefault(_emitter3);
                var _logger = __webpack_require__(10);
                var _logger2 = _interopRequireDefault(_logger);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _toConsumableArray(arr) {
                  if (Array.isArray(arr)) {
                    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                      arr2[i] = arr[i];
                    }
                    return arr2;
                  } else {
                    return Array.from(arr);
                  }
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                var debug = (0, _logger2.default)('quill:selection');
                var Range = function Range(index) {
                  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                  _classCallCheck(this, Range);
                  this.index = index;
                  this.length = length;
                };
                var Selection = function () {
                  function Selection(scroll, emitter) {
                    var _this = this;
                    _classCallCheck(this, Selection);
                    this.emitter = emitter;
                    this.scroll = scroll;
                    this.composing = false;
                    this.mouseDown = false;
                    this.root = this.scroll.domNode;
                    this.cursor = _parchment2.default.create('cursor', this);
                    // savedRange is last non-null range
                    this.lastRange = this.savedRange = new Range(0, 0);
                    this.handleComposition();
                    this.handleDragging();
                    this.emitter.listenDOM('selectionchange', document, function () {
                      if (!_this.mouseDown) {
                        setTimeout(_this.update.bind(_this, _emitter4.default.sources.USER), 1);
                      }
                    });
                    this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function (type, delta) {
                      if (type === _emitter4.default.events.TEXT_CHANGE && delta.length() > 0) {
                        _this.update(_emitter4.default.sources.SILENT);
                      }
                    });
                    this.emitter.on(_emitter4.default.events.SCROLL_BEFORE_UPDATE, function () {
                      if (!_this.hasFocus()) return;
                      var native = _this.getNativeRange();
                      if (native == null) return;
                      if (native.start.node === _this.cursor.textNode) return; // cursor.restore() will handle
                      // TODO unclear if this has negative side effects
                      _this.emitter.once(_emitter4.default.events.SCROLL_UPDATE, function () {
                        try {
                          _this.setNativeRange(native.start.node, native.start.offset, native.end.node, native.end.offset);
                        } catch (ignored) {}
                      });
                    });
                    this.emitter.on(_emitter4.default.events.SCROLL_OPTIMIZE, function (mutations, context) {
                      if (context.range) {
                        var _context$range = context.range,
                          startNode = _context$range.startNode,
                          startOffset = _context$range.startOffset,
                          endNode = _context$range.endNode,
                          endOffset = _context$range.endOffset;
                        _this.setNativeRange(startNode, startOffset, endNode, endOffset);
                      }
                    });
                    this.update(_emitter4.default.sources.SILENT);
                  }
                  _createClass(Selection, [{
                    key: 'handleComposition',
                    value: function handleComposition() {
                      var _this2 = this;
                      this.root.addEventListener('compositionstart', function () {
                        _this2.composing = true;
                      });
                      this.root.addEventListener('compositionend', function () {
                        _this2.composing = false;
                        if (_this2.cursor.parent) {
                          var range = _this2.cursor.restore();
                          if (!range) return;
                          setTimeout(function () {
                            _this2.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);
                          }, 1);
                        }
                      });
                    }
                  }, {
                    key: 'handleDragging',
                    value: function handleDragging() {
                      var _this3 = this;
                      this.emitter.listenDOM('mousedown', document.body, function () {
                        _this3.mouseDown = true;
                      });
                      this.emitter.listenDOM('mouseup', document.body, function () {
                        _this3.mouseDown = false;
                        _this3.update(_emitter4.default.sources.USER);
                      });
                    }
                  }, {
                    key: 'focus',
                    value: function focus() {
                      if (this.hasFocus()) return;
                      this.root.focus();
                      this.setRange(this.savedRange);
                    }
                  }, {
                    key: 'format',
                    value: function format(_format, value) {
                      if (this.scroll.whitelist != null && !this.scroll.whitelist[_format]) return;
                      this.scroll.update();
                      var nativeRange = this.getNativeRange();
                      if (nativeRange == null || !nativeRange.native.collapsed || _parchment2.default.query(_format, _parchment2.default.Scope.BLOCK)) return;
                      if (nativeRange.start.node !== this.cursor.textNode) {
                        var blot = _parchment2.default.find(nativeRange.start.node, false);
                        if (blot == null) return;
                        // TODO Give blot ability to not split
                        if (blot instanceof _parchment2.default.Leaf) {
                          var after = blot.split(nativeRange.start.offset);
                          blot.parent.insertBefore(this.cursor, after);
                        } else {
                          blot.insertBefore(this.cursor, nativeRange.start.node); // Should never happen
                        }

                        this.cursor.attach();
                      }
                      this.cursor.format(_format, value);
                      this.scroll.optimize();
                      this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length);
                      this.update();
                    }
                  }, {
                    key: 'getBounds',
                    value: function getBounds(index) {
                      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                      var scrollLength = this.scroll.length();
                      index = Math.min(index, scrollLength - 1);
                      length = Math.min(index + length, scrollLength - 1) - index;
                      var node = void 0,
                        _scroll$leaf = this.scroll.leaf(index),
                        _scroll$leaf2 = _slicedToArray(_scroll$leaf, 2),
                        leaf = _scroll$leaf2[0],
                        offset = _scroll$leaf2[1];
                      if (leaf == null) return null;
                      var _leaf$position = leaf.position(offset, true);
                      var _leaf$position2 = _slicedToArray(_leaf$position, 2);
                      node = _leaf$position2[0];
                      offset = _leaf$position2[1];
                      var range = document.createRange();
                      if (length > 0) {
                        range.setStart(node, offset);
                        var _scroll$leaf3 = this.scroll.leaf(index + length);
                        var _scroll$leaf4 = _slicedToArray(_scroll$leaf3, 2);
                        leaf = _scroll$leaf4[0];
                        offset = _scroll$leaf4[1];
                        if (leaf == null) return null;
                        var _leaf$position3 = leaf.position(offset, true);
                        var _leaf$position4 = _slicedToArray(_leaf$position3, 2);
                        node = _leaf$position4[0];
                        offset = _leaf$position4[1];
                        range.setEnd(node, offset);
                        return range.getBoundingClientRect();
                      } else {
                        var side = 'left';
                        var rect = void 0;
                        if (node instanceof Text) {
                          if (offset < node.data.length) {
                            range.setStart(node, offset);
                            range.setEnd(node, offset + 1);
                          } else {
                            range.setStart(node, offset - 1);
                            range.setEnd(node, offset);
                            side = 'right';
                          }
                          rect = range.getBoundingClientRect();
                        } else {
                          rect = leaf.domNode.getBoundingClientRect();
                          if (offset > 0) side = 'right';
                        }
                        return {
                          bottom: rect.top + rect.height,
                          height: rect.height,
                          left: rect[side],
                          right: rect[side],
                          top: rect.top,
                          width: 0
                        };
                      }
                    }
                  }, {
                    key: 'getNativeRange',
                    value: function getNativeRange() {
                      var selection = document.getSelection();
                      if (selection == null || selection.rangeCount <= 0) return null;
                      var nativeRange = selection.getRangeAt(0);
                      if (nativeRange == null) return null;
                      var range = this.normalizeNative(nativeRange);
                      debug.info('getNativeRange', range);
                      return range;
                    }
                  }, {
                    key: 'getRange',
                    value: function getRange() {
                      var normalized = this.getNativeRange();
                      if (normalized == null) return [null, null];
                      var range = this.normalizedToRange(normalized);
                      return [range, normalized];
                    }
                  }, {
                    key: 'hasFocus',
                    value: function hasFocus() {
                      return document.activeElement === this.root;
                    }
                  }, {
                    key: 'normalizedToRange',
                    value: function normalizedToRange(range) {
                      var _this4 = this;
                      var positions = [[range.start.node, range.start.offset]];
                      if (!range.native.collapsed) {
                        positions.push([range.end.node, range.end.offset]);
                      }
                      var indexes = positions.map(function (position) {
                        var _position = _slicedToArray(position, 2),
                          node = _position[0],
                          offset = _position[1];
                        var blot = _parchment2.default.find(node, true);
                        var index = blot.offset(_this4.scroll);
                        if (offset === 0) {
                          return index;
                        } else if (blot instanceof _parchment2.default.Container) {
                          return index + blot.length();
                        } else {
                          return index + blot.index(node, offset);
                        }
                      });
                      var end = Math.min(Math.max.apply(Math, _toConsumableArray(indexes)), this.scroll.length() - 1);
                      var start = Math.min.apply(Math, [end].concat(_toConsumableArray(indexes)));
                      return new Range(start, end - start);
                    }
                  }, {
                    key: 'normalizeNative',
                    value: function normalizeNative(nativeRange) {
                      if (!contains(this.root, nativeRange.startContainer) || !nativeRange.collapsed && !contains(this.root, nativeRange.endContainer)) {
                        return null;
                      }
                      var range = {
                        start: {
                          node: nativeRange.startContainer,
                          offset: nativeRange.startOffset
                        },
                        end: {
                          node: nativeRange.endContainer,
                          offset: nativeRange.endOffset
                        },
                        native: nativeRange
                      };
                      [range.start, range.end].forEach(function (position) {
                        var node = position.node,
                          offset = position.offset;
                        while (!(node instanceof Text) && node.childNodes.length > 0) {
                          if (node.childNodes.length > offset) {
                            node = node.childNodes[offset];
                            offset = 0;
                          } else if (node.childNodes.length === offset) {
                            node = node.lastChild;
                            offset = node instanceof Text ? node.data.length : node.childNodes.length + 1;
                          } else {
                            break;
                          }
                        }
                        position.node = node, position.offset = offset;
                      });
                      return range;
                    }
                  }, {
                    key: 'rangeToNative',
                    value: function rangeToNative(range) {
                      var _this5 = this;
                      var indexes = range.collapsed ? [range.index] : [range.index, range.index + range.length];
                      var args = [];
                      var scrollLength = this.scroll.length();
                      indexes.forEach(function (index, i) {
                        index = Math.min(scrollLength - 1, index);
                        var node = void 0,
                          _scroll$leaf5 = _this5.scroll.leaf(index),
                          _scroll$leaf6 = _slicedToArray(_scroll$leaf5, 2),
                          leaf = _scroll$leaf6[0],
                          offset = _scroll$leaf6[1];
                        var _leaf$position5 = leaf.position(offset, i !== 0);
                        var _leaf$position6 = _slicedToArray(_leaf$position5, 2);
                        node = _leaf$position6[0];
                        offset = _leaf$position6[1];
                        args.push(node, offset);
                      });
                      if (args.length < 2) {
                        args = args.concat(args);
                      }
                      return args;
                    }
                  }, {
                    key: 'scrollIntoView',
                    value: function scrollIntoView(scrollingContainer) {
                      var range = this.lastRange;
                      if (range == null) return;
                      var bounds = this.getBounds(range.index, range.length);
                      if (bounds == null) return;
                      var limit = this.scroll.length() - 1;
                      var _scroll$line = this.scroll.line(Math.min(range.index, limit)),
                        _scroll$line2 = _slicedToArray(_scroll$line, 1),
                        first = _scroll$line2[0];
                      var last = first;
                      if (range.length > 0) {
                        var _scroll$line3 = this.scroll.line(Math.min(range.index + range.length, limit));
                        var _scroll$line4 = _slicedToArray(_scroll$line3, 1);
                        last = _scroll$line4[0];
                      }
                      if (first == null || last == null) return;
                      var scrollBounds = scrollingContainer.getBoundingClientRect();
                      if (bounds.top < scrollBounds.top) {
                        scrollingContainer.scrollTop -= scrollBounds.top - bounds.top;
                      } else if (bounds.bottom > scrollBounds.bottom) {
                        scrollingContainer.scrollTop += bounds.bottom - scrollBounds.bottom;
                      }
                    }
                  }, {
                    key: 'setNativeRange',
                    value: function setNativeRange(startNode, startOffset) {
                      var endNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : startNode;
                      var endOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : startOffset;
                      var force = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
                      debug.info('setNativeRange', startNode, startOffset, endNode, endOffset);
                      if (startNode != null && (this.root.parentNode == null || startNode.parentNode == null || endNode.parentNode == null)) {
                        return;
                      }
                      var selection = document.getSelection();
                      if (selection == null) return;
                      if (startNode != null) {
                        if (!this.hasFocus()) this.root.focus();
                        var native = (this.getNativeRange() || {}).native;
                        if (native == null || force || startNode !== native.startContainer || startOffset !== native.startOffset || endNode !== native.endContainer || endOffset !== native.endOffset) {
                          if (startNode.tagName == "BR") {
                            startOffset = [].indexOf.call(startNode.parentNode.childNodes, startNode);
                            startNode = startNode.parentNode;
                          }
                          if (endNode.tagName == "BR") {
                            endOffset = [].indexOf.call(endNode.parentNode.childNodes, endNode);
                            endNode = endNode.parentNode;
                          }
                          var range = document.createRange();
                          range.setStart(startNode, startOffset);
                          range.setEnd(endNode, endOffset);
                          selection.removeAllRanges();
                          selection.addRange(range);
                        }
                      } else {
                        selection.removeAllRanges();
                        this.root.blur();
                        document.body.focus(); // root.blur() not enough on IE11+Travis+SauceLabs (but not local VMs)
                      }
                    }
                  }, {
                    key: 'setRange',
                    value: function setRange(range) {
                      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _emitter4.default.sources.API;
                      if (typeof force === 'string') {
                        source = force;
                        force = false;
                      }
                      debug.info('setRange', range);
                      if (range != null) {
                        var args = this.rangeToNative(range);
                        this.setNativeRange.apply(this, _toConsumableArray(args).concat([force]));
                      } else {
                        this.setNativeRange(null);
                      }
                      this.update(source);
                    }
                  }, {
                    key: 'update',
                    value: function update() {
                      var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emitter4.default.sources.USER;
                      var oldRange = this.lastRange;
                      var _getRange = this.getRange(),
                        _getRange2 = _slicedToArray(_getRange, 2),
                        lastRange = _getRange2[0],
                        nativeRange = _getRange2[1];
                      this.lastRange = lastRange;
                      if (this.lastRange != null) {
                        this.savedRange = this.lastRange;
                      }
                      if (!(0, _deepEqual2.default)(oldRange, this.lastRange)) {
                        var _emitter;
                        if (!this.composing && nativeRange != null && nativeRange.native.collapsed && nativeRange.start.node !== this.cursor.textNode) {
                          this.cursor.restore();
                        }
                        var args = [_emitter4.default.events.SELECTION_CHANGE, (0, _clone2.default)(this.lastRange), (0, _clone2.default)(oldRange), source];
                        (_emitter = this.emitter).emit.apply(_emitter, [_emitter4.default.events.EDITOR_CHANGE].concat(args));
                        if (source !== _emitter4.default.sources.SILENT) {
                          var _emitter2;
                          (_emitter2 = this.emitter).emit.apply(_emitter2, args);
                        }
                      }
                    }
                  }]);
                  return Selection;
                }();
                function contains(parent, descendant) {
                  try {
                    // Firefox inserts inaccessible nodes around video elements
                    descendant.parentNode;
                  } catch (e) {
                    return false;
                  }
                  // IE11 has bug with Text nodes
                  // https://connect.microsoft.com/IE/feedback/details/780874/node-contains-is-incorrect
                  if (descendant instanceof Text) {
                    descendant = descendant.parentNode;
                  }
                  return parent.contains(descendant);
                }
                exports.Range = Range;
                exports.default = Selection;

                /***/
              }, /* 16 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _get = function get(object, property, receiver) {
                  if (object === null) object = Function.prototype;
                  var desc = Object.getOwnPropertyDescriptor(object, property);
                  if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                      return undefined;
                    } else {
                      return get(parent, property, receiver);
                    }
                  } else if ("value" in desc) {
                    return desc.value;
                  } else {
                    var getter = desc.get;
                    if (getter === undefined) {
                      return undefined;
                    }
                    return getter.call(receiver);
                  }
                };
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var Break = function (_Parchment$Embed) {
                  _inherits(Break, _Parchment$Embed);
                  function Break() {
                    _classCallCheck(this, Break);
                    return _possibleConstructorReturn(this, (Break.__proto__ || Object.getPrototypeOf(Break)).apply(this, arguments));
                  }
                  _createClass(Break, [{
                    key: 'insertInto',
                    value: function insertInto(parent, ref) {
                      if (parent.children.length === 0) {
                        _get(Break.prototype.__proto__ || Object.getPrototypeOf(Break.prototype), 'insertInto', this).call(this, parent, ref);
                      } else {
                        this.remove();
                      }
                    }
                  }, {
                    key: 'length',
                    value: function length() {
                      return 0;
                    }
                  }, {
                    key: 'value',
                    value: function value() {
                      return '';
                    }
                  }], [{
                    key: 'value',
                    value: function value() {
                      return undefined;
                    }
                  }]);
                  return Break;
                }(_parchment2.default.Embed);
                Break.blotName = 'break';
                Break.tagName = 'BR';
                exports.default = Break;

                /***/
              }, /* 17 */
              /***/function (module, exports, __webpack_require__) {
                var __extends = this && this.__extends || function () {
                  var extendStatics = Object.setPrototypeOf || {
                    __proto__: []
                  } instanceof Array && function (d, b) {
                    d.__proto__ = b;
                  } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                  };
                  return function (d, b) {
                    extendStatics(d, b);
                    function __() {
                      this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                  };
                }();
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var linked_list_1 = __webpack_require__(44);
                var shadow_1 = __webpack_require__(30);
                var Registry = __webpack_require__(1);
                var ContainerBlot = /** @class */function (_super) {
                  __extends(ContainerBlot, _super);
                  function ContainerBlot(domNode) {
                    var _this = _super.call(this, domNode) || this;
                    _this.build();
                    return _this;
                  }
                  ContainerBlot.prototype.appendChild = function (other) {
                    this.insertBefore(other);
                  };
                  ContainerBlot.prototype.attach = function () {
                    _super.prototype.attach.call(this);
                    this.children.forEach(function (child) {
                      child.attach();
                    });
                  };
                  ContainerBlot.prototype.build = function () {
                    var _this = this;
                    this.children = new linked_list_1.default();
                    // Need to be reversed for if DOM nodes already in order
                    [].slice.call(this.domNode.childNodes).reverse().forEach(function (node) {
                      try {
                        var child = makeBlot(node);
                        _this.insertBefore(child, _this.children.head || undefined);
                      } catch (err) {
                        if (err instanceof Registry.ParchmentError) return;else throw err;
                      }
                    });
                  };
                  ContainerBlot.prototype.deleteAt = function (index, length) {
                    if (index === 0 && length === this.length()) {
                      return this.remove();
                    }
                    this.children.forEachAt(index, length, function (child, offset, length) {
                      child.deleteAt(offset, length);
                    });
                  };
                  ContainerBlot.prototype.descendant = function (criteria, index) {
                    var _a = this.children.find(index),
                      child = _a[0],
                      offset = _a[1];
                    if (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) {
                      return [child, offset];
                    } else if (child instanceof ContainerBlot) {
                      return child.descendant(criteria, offset);
                    } else {
                      return [null, -1];
                    }
                  };
                  ContainerBlot.prototype.descendants = function (criteria, index, length) {
                    if (index === void 0) {
                      index = 0;
                    }
                    if (length === void 0) {
                      length = Number.MAX_VALUE;
                    }
                    var descendants = [];
                    var lengthLeft = length;
                    this.children.forEachAt(index, length, function (child, index, length) {
                      if (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) {
                        descendants.push(child);
                      }
                      if (child instanceof ContainerBlot) {
                        descendants = descendants.concat(child.descendants(criteria, index, lengthLeft));
                      }
                      lengthLeft -= length;
                    });
                    return descendants;
                  };
                  ContainerBlot.prototype.detach = function () {
                    this.children.forEach(function (child) {
                      child.detach();
                    });
                    _super.prototype.detach.call(this);
                  };
                  ContainerBlot.prototype.formatAt = function (index, length, name, value) {
                    this.children.forEachAt(index, length, function (child, offset, length) {
                      child.formatAt(offset, length, name, value);
                    });
                  };
                  ContainerBlot.prototype.insertAt = function (index, value, def) {
                    var _a = this.children.find(index),
                      child = _a[0],
                      offset = _a[1];
                    if (child) {
                      child.insertAt(offset, value, def);
                    } else {
                      var blot = def == null ? Registry.create('text', value) : Registry.create(value, def);
                      this.appendChild(blot);
                    }
                  };
                  ContainerBlot.prototype.insertBefore = function (childBlot, refBlot) {
                    if (this.statics.allowedChildren != null && !this.statics.allowedChildren.some(function (child) {
                      return childBlot instanceof child;
                    })) {
                      throw new Registry.ParchmentError("Cannot insert " + childBlot.statics.blotName + " into " + this.statics.blotName);
                    }
                    childBlot.insertInto(this, refBlot);
                  };
                  ContainerBlot.prototype.length = function () {
                    return this.children.reduce(function (memo, child) {
                      return memo + child.length();
                    }, 0);
                  };
                  ContainerBlot.prototype.moveChildren = function (targetParent, refNode) {
                    this.children.forEach(function (child) {
                      targetParent.insertBefore(child, refNode);
                    });
                  };
                  ContainerBlot.prototype.optimize = function (context) {
                    _super.prototype.optimize.call(this, context);
                    if (this.children.length === 0) {
                      if (this.statics.defaultChild != null) {
                        var child = Registry.create(this.statics.defaultChild);
                        this.appendChild(child);
                        child.optimize(context);
                      } else {
                        this.remove();
                      }
                    }
                  };
                  ContainerBlot.prototype.path = function (index, inclusive) {
                    if (inclusive === void 0) {
                      inclusive = false;
                    }
                    var _a = this.children.find(index, inclusive),
                      child = _a[0],
                      offset = _a[1];
                    var position = [[this, index]];
                    if (child instanceof ContainerBlot) {
                      return position.concat(child.path(offset, inclusive));
                    } else if (child != null) {
                      position.push([child, offset]);
                    }
                    return position;
                  };
                  ContainerBlot.prototype.removeChild = function (child) {
                    this.children.remove(child);
                  };
                  ContainerBlot.prototype.replace = function (target) {
                    if (target instanceof ContainerBlot) {
                      target.moveChildren(this);
                    }
                    _super.prototype.replace.call(this, target);
                  };
                  ContainerBlot.prototype.split = function (index, force) {
                    if (force === void 0) {
                      force = false;
                    }
                    if (!force) {
                      if (index === 0) return this;
                      if (index === this.length()) return this.next;
                    }
                    var after = this.clone();
                    this.parent.insertBefore(after, this.next);
                    this.children.forEachAt(index, this.length(), function (child, offset, length) {
                      child = child.split(offset, force);
                      after.appendChild(child);
                    });
                    return after;
                  };
                  ContainerBlot.prototype.unwrap = function () {
                    this.moveChildren(this.parent, this.next);
                    this.remove();
                  };
                  ContainerBlot.prototype.update = function (mutations, context) {
                    var _this = this;
                    var addedNodes = [];
                    var removedNodes = [];
                    mutations.forEach(function (mutation) {
                      if (mutation.target === _this.domNode && mutation.type === 'childList') {
                        addedNodes.push.apply(addedNodes, mutation.addedNodes);
                        removedNodes.push.apply(removedNodes, mutation.removedNodes);
                      }
                    });
                    removedNodes.forEach(function (node) {
                      // Check node has actually been removed
                      // One exception is Chrome does not immediately remove IFRAMEs
                      // from DOM but MutationRecord is correct in its reported removal
                      if (node.parentNode != null &&
                      // @ts-ignore
                      node.tagName !== 'IFRAME' && document.body.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
                        return;
                      }
                      var blot = Registry.find(node);
                      if (blot == null) return;
                      if (blot.domNode.parentNode == null || blot.domNode.parentNode === _this.domNode) {
                        blot.detach();
                      }
                    });
                    addedNodes.filter(function (node) {
                      return node.parentNode == _this.domNode;
                    }).sort(function (a, b) {
                      if (a === b) return 0;
                      if (a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) {
                        return 1;
                      }
                      return -1;
                    }).forEach(function (node) {
                      var refBlot = null;
                      if (node.nextSibling != null) {
                        refBlot = Registry.find(node.nextSibling);
                      }
                      var blot = makeBlot(node);
                      if (blot.next != refBlot || blot.next == null) {
                        if (blot.parent != null) {
                          blot.parent.removeChild(_this);
                        }
                        _this.insertBefore(blot, refBlot || undefined);
                      }
                    });
                  };
                  return ContainerBlot;
                }(shadow_1.default);
                function makeBlot(node) {
                  var blot = Registry.find(node);
                  if (blot == null) {
                    try {
                      blot = Registry.create(node);
                    } catch (e) {
                      blot = Registry.create(Registry.Scope.INLINE);
                      [].slice.call(node.childNodes).forEach(function (child) {
                        // @ts-ignore
                        blot.domNode.appendChild(child);
                      });
                      if (node.parentNode) {
                        node.parentNode.replaceChild(blot.domNode, node);
                      }
                      blot.attach();
                    }
                  }
                  return blot;
                }
                exports.default = ContainerBlot;

                /***/
              }, /* 18 */
              /***/function (module, exports, __webpack_require__) {
                var __extends = this && this.__extends || function () {
                  var extendStatics = Object.setPrototypeOf || {
                    __proto__: []
                  } instanceof Array && function (d, b) {
                    d.__proto__ = b;
                  } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                  };
                  return function (d, b) {
                    extendStatics(d, b);
                    function __() {
                      this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                  };
                }();
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var attributor_1 = __webpack_require__(12);
                var store_1 = __webpack_require__(31);
                var container_1 = __webpack_require__(17);
                var Registry = __webpack_require__(1);
                var FormatBlot = /** @class */function (_super) {
                  __extends(FormatBlot, _super);
                  function FormatBlot(domNode) {
                    var _this = _super.call(this, domNode) || this;
                    _this.attributes = new store_1.default(_this.domNode);
                    return _this;
                  }
                  FormatBlot.formats = function (domNode) {
                    if (typeof this.tagName === 'string') {
                      return true;
                    } else if (Array.isArray(this.tagName)) {
                      return domNode.tagName.toLowerCase();
                    }
                    return undefined;
                  };
                  FormatBlot.prototype.format = function (name, value) {
                    var format = Registry.query(name);
                    if (format instanceof attributor_1.default) {
                      this.attributes.attribute(format, value);
                    } else if (value) {
                      if (format != null && (name !== this.statics.blotName || this.formats()[name] !== value)) {
                        this.replaceWith(name, value);
                      }
                    }
                  };
                  FormatBlot.prototype.formats = function () {
                    var formats = this.attributes.values();
                    var format = this.statics.formats(this.domNode);
                    if (format != null) {
                      formats[this.statics.blotName] = format;
                    }
                    return formats;
                  };
                  FormatBlot.prototype.replaceWith = function (name, value) {
                    var replacement = _super.prototype.replaceWith.call(this, name, value);
                    this.attributes.copy(replacement);
                    return replacement;
                  };
                  FormatBlot.prototype.update = function (mutations, context) {
                    var _this = this;
                    _super.prototype.update.call(this, mutations, context);
                    if (mutations.some(function (mutation) {
                      return mutation.target === _this.domNode && mutation.type === 'attributes';
                    })) {
                      this.attributes.build();
                    }
                  };
                  FormatBlot.prototype.wrap = function (name, value) {
                    var wrapper = _super.prototype.wrap.call(this, name, value);
                    if (wrapper instanceof FormatBlot && wrapper.statics.scope === this.statics.scope) {
                      this.attributes.move(wrapper);
                    }
                    return wrapper;
                  };
                  return FormatBlot;
                }(container_1.default);
                exports.default = FormatBlot;

                /***/
              }, /* 19 */
              /***/function (module, exports, __webpack_require__) {
                var __extends = this && this.__extends || function () {
                  var extendStatics = Object.setPrototypeOf || {
                    __proto__: []
                  } instanceof Array && function (d, b) {
                    d.__proto__ = b;
                  } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                  };
                  return function (d, b) {
                    extendStatics(d, b);
                    function __() {
                      this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                  };
                }();
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var shadow_1 = __webpack_require__(30);
                var Registry = __webpack_require__(1);
                var LeafBlot = /** @class */function (_super) {
                  __extends(LeafBlot, _super);
                  function LeafBlot() {
                    return _super !== null && _super.apply(this, arguments) || this;
                  }
                  LeafBlot.value = function (domNode) {
                    return true;
                  };
                  LeafBlot.prototype.index = function (node, offset) {
                    if (this.domNode === node || this.domNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
                      return Math.min(offset, 1);
                    }
                    return -1;
                  };
                  LeafBlot.prototype.position = function (index, inclusive) {
                    var offset = [].indexOf.call(this.parent.domNode.childNodes, this.domNode);
                    if (index > 0) offset += 1;
                    return [this.parent.domNode, offset];
                  };
                  LeafBlot.prototype.value = function () {
                    var _a;
                    return _a = {}, _a[this.statics.blotName] = this.statics.value(this.domNode) || true, _a;
                  };
                  LeafBlot.scope = Registry.Scope.INLINE_BLOT;
                  return LeafBlot;
                }(shadow_1.default);
                exports.default = LeafBlot;

                /***/
              }, /* 20 */
              /***/function (module, exports, __webpack_require__) {
                var equal = __webpack_require__(11);
                var extend = __webpack_require__(3);
                var lib = {
                  attributes: {
                    compose: function (a, b, keepNull) {
                      if (typeof a !== 'object') a = {};
                      if (typeof b !== 'object') b = {};
                      var attributes = extend(true, {}, b);
                      if (!keepNull) {
                        attributes = Object.keys(attributes).reduce(function (copy, key) {
                          if (attributes[key] != null) {
                            copy[key] = attributes[key];
                          }
                          return copy;
                        }, {});
                      }
                      for (var key in a) {
                        if (a[key] !== undefined && b[key] === undefined) {
                          attributes[key] = a[key];
                        }
                      }
                      return Object.keys(attributes).length > 0 ? attributes : undefined;
                    },
                    diff: function (a, b) {
                      if (typeof a !== 'object') a = {};
                      if (typeof b !== 'object') b = {};
                      var attributes = Object.keys(a).concat(Object.keys(b)).reduce(function (attributes, key) {
                        if (!equal(a[key], b[key])) {
                          attributes[key] = b[key] === undefined ? null : b[key];
                        }
                        return attributes;
                      }, {});
                      return Object.keys(attributes).length > 0 ? attributes : undefined;
                    },
                    transform: function (a, b, priority) {
                      if (typeof a !== 'object') return b;
                      if (typeof b !== 'object') return undefined;
                      if (!priority) return b; // b simply overwrites us without priority
                      var attributes = Object.keys(b).reduce(function (attributes, key) {
                        if (a[key] === undefined) attributes[key] = b[key]; // null is a valid value
                        return attributes;
                      }, {});
                      return Object.keys(attributes).length > 0 ? attributes : undefined;
                    }
                  },
                  iterator: function (ops) {
                    return new Iterator(ops);
                  },
                  length: function (op) {
                    if (typeof op['delete'] === 'number') {
                      return op['delete'];
                    } else if (typeof op.retain === 'number') {
                      return op.retain;
                    } else {
                      return typeof op.insert === 'string' ? op.insert.length : 1;
                    }
                  }
                };
                function Iterator(ops) {
                  this.ops = ops;
                  this.index = 0;
                  this.offset = 0;
                }
                Iterator.prototype.hasNext = function () {
                  return this.peekLength() < Infinity;
                };
                Iterator.prototype.next = function (length) {
                  if (!length) length = Infinity;
                  var nextOp = this.ops[this.index];
                  if (nextOp) {
                    var offset = this.offset;
                    var opLength = lib.length(nextOp);
                    if (length >= opLength - offset) {
                      length = opLength - offset;
                      this.index += 1;
                      this.offset = 0;
                    } else {
                      this.offset += length;
                    }
                    if (typeof nextOp['delete'] === 'number') {
                      return {
                        'delete': length
                      };
                    } else {
                      var retOp = {};
                      if (nextOp.attributes) {
                        retOp.attributes = nextOp.attributes;
                      }
                      if (typeof nextOp.retain === 'number') {
                        retOp.retain = length;
                      } else if (typeof nextOp.insert === 'string') {
                        retOp.insert = nextOp.insert.substr(offset, length);
                      } else {
                        // offset should === 0, length should === 1
                        retOp.insert = nextOp.insert;
                      }
                      return retOp;
                    }
                  } else {
                    return {
                      retain: Infinity
                    };
                  }
                };
                Iterator.prototype.peek = function () {
                  return this.ops[this.index];
                };
                Iterator.prototype.peekLength = function () {
                  if (this.ops[this.index]) {
                    // Should never return 0 if our index is being managed correctly
                    return lib.length(this.ops[this.index]) - this.offset;
                  } else {
                    return Infinity;
                  }
                };
                Iterator.prototype.peekType = function () {
                  if (this.ops[this.index]) {
                    if (typeof this.ops[this.index]['delete'] === 'number') {
                      return 'delete';
                    } else if (typeof this.ops[this.index].retain === 'number') {
                      return 'retain';
                    } else {
                      return 'insert';
                    }
                  }
                  return 'retain';
                };
                Iterator.prototype.rest = function () {
                  if (!this.hasNext()) {
                    return [];
                  } else if (this.offset === 0) {
                    return this.ops.slice(this.index);
                  } else {
                    var offset = this.offset;
                    var index = this.index;
                    var next = this.next();
                    var rest = this.ops.slice(this.index);
                    this.offset = offset;
                    this.index = index;
                    return [next].concat(rest);
                  }
                };
                module.exports = lib;

                /***/
              }, /* 21 */
              /***/function (module, exports) {
                var clone = function () {
                  function _instanceof(obj, type) {
                    return type != null && obj instanceof type;
                  }
                  var nativeMap;
                  try {
                    nativeMap = Map;
                  } catch (_) {
                    // maybe a reference error because no `Map`. Give it a dummy value that no
                    // value will ever be an instanceof.
                    nativeMap = function () {};
                  }
                  var nativeSet;
                  try {
                    nativeSet = Set;
                  } catch (_) {
                    nativeSet = function () {};
                  }
                  var nativePromise;
                  try {
                    nativePromise = Promise;
                  } catch (_) {
                    nativePromise = function () {};
                  }

                  /**
                   * Clones (copies) an Object using deep copying.
                   *
                   * This function supports circular references by default, but if you are certain
                   * there are no circular references in your object, you can save some CPU time
                   * by calling clone(obj, false).
                   *
                   * Caution: if `circular` is false and `parent` contains circular references,
                   * your program may enter an infinite loop and crash.
                   *
                   * @param `parent` - the object to be cloned
                   * @param `circular` - set to true if the object to be cloned may contain
                   *    circular references. (optional - true by default)
                   * @param `depth` - set to a number if the object is only to be cloned to
                   *    a particular depth. (optional - defaults to Infinity)
                   * @param `prototype` - sets the prototype to be used when cloning an object.
                   *    (optional - defaults to parent prototype).
                   * @param `includeNonEnumerable` - set to true if the non-enumerable properties
                   *    should be cloned as well. Non-enumerable properties on the prototype
                   *    chain will be ignored. (optional - false by default)
                  */
                  function clone(parent, circular, depth, prototype, includeNonEnumerable) {
                    if (typeof circular === 'object') {
                      depth = circular.depth;
                      prototype = circular.prototype;
                      includeNonEnumerable = circular.includeNonEnumerable;
                      circular = circular.circular;
                    }
                    // maintain two arrays for circular references, where corresponding parents
                    // and children have the same index
                    var allParents = [];
                    var allChildren = [];
                    var useBuffer = typeof Buffer != 'undefined';
                    if (typeof circular == 'undefined') circular = true;
                    if (typeof depth == 'undefined') depth = Infinity;

                    // recurse this function so we don't reset allParents and allChildren
                    function _clone(parent, depth) {
                      // cloning null always returns null
                      if (parent === null) return null;
                      if (depth === 0) return parent;
                      var child;
                      var proto;
                      if (typeof parent != 'object') {
                        return parent;
                      }
                      if (_instanceof(parent, nativeMap)) {
                        child = new nativeMap();
                      } else if (_instanceof(parent, nativeSet)) {
                        child = new nativeSet();
                      } else if (_instanceof(parent, nativePromise)) {
                        child = new nativePromise(function (resolve, reject) {
                          parent.then(function (value) {
                            resolve(_clone(value, depth - 1));
                          }, function (err) {
                            reject(_clone(err, depth - 1));
                          });
                        });
                      } else if (clone.__isArray(parent)) {
                        child = [];
                      } else if (clone.__isRegExp(parent)) {
                        child = new RegExp(parent.source, __getRegExpFlags(parent));
                        if (parent.lastIndex) child.lastIndex = parent.lastIndex;
                      } else if (clone.__isDate(parent)) {
                        child = new Date(parent.getTime());
                      } else if (useBuffer && Buffer.isBuffer(parent)) {
                        if (Buffer.allocUnsafe) {
                          // Node.js >= 4.5.0
                          child = Buffer.allocUnsafe(parent.length);
                        } else {
                          // Older Node.js versions
                          child = new Buffer(parent.length);
                        }
                        parent.copy(child);
                        return child;
                      } else if (_instanceof(parent, Error)) {
                        child = Object.create(parent);
                      } else {
                        if (typeof prototype == 'undefined') {
                          proto = Object.getPrototypeOf(parent);
                          child = Object.create(proto);
                        } else {
                          child = Object.create(prototype);
                          proto = prototype;
                        }
                      }
                      if (circular) {
                        var index = allParents.indexOf(parent);
                        if (index != -1) {
                          return allChildren[index];
                        }
                        allParents.push(parent);
                        allChildren.push(child);
                      }
                      if (_instanceof(parent, nativeMap)) {
                        parent.forEach(function (value, key) {
                          var keyChild = _clone(key, depth - 1);
                          var valueChild = _clone(value, depth - 1);
                          child.set(keyChild, valueChild);
                        });
                      }
                      if (_instanceof(parent, nativeSet)) {
                        parent.forEach(function (value) {
                          var entryChild = _clone(value, depth - 1);
                          child.add(entryChild);
                        });
                      }
                      for (var i in parent) {
                        var attrs;
                        if (proto) {
                          attrs = Object.getOwnPropertyDescriptor(proto, i);
                        }
                        if (attrs && attrs.set == null) {
                          continue;
                        }
                        child[i] = _clone(parent[i], depth - 1);
                      }
                      if (Object.getOwnPropertySymbols) {
                        var symbols = Object.getOwnPropertySymbols(parent);
                        for (var i = 0; i < symbols.length; i++) {
                          // Don't need to worry about cloning a symbol because it is a primitive,
                          // like a number or string.
                          var symbol = symbols[i];
                          var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
                          if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                            continue;
                          }
                          child[symbol] = _clone(parent[symbol], depth - 1);
                          if (!descriptor.enumerable) {
                            Object.defineProperty(child, symbol, {
                              enumerable: false
                            });
                          }
                        }
                      }
                      if (includeNonEnumerable) {
                        var allPropertyNames = Object.getOwnPropertyNames(parent);
                        for (var i = 0; i < allPropertyNames.length; i++) {
                          var propertyName = allPropertyNames[i];
                          var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
                          if (descriptor && descriptor.enumerable) {
                            continue;
                          }
                          child[propertyName] = _clone(parent[propertyName], depth - 1);
                          Object.defineProperty(child, propertyName, {
                            enumerable: false
                          });
                        }
                      }
                      return child;
                    }
                    return _clone(parent, depth);
                  }

                  /**
                   * Simple flat clone using prototype, accepts only objects, usefull for property
                   * override on FLAT configuration object (no nested props).
                   *
                   * USE WITH CAUTION! This may not behave as you wish if you do not know how this
                   * works.
                   */
                  clone.clonePrototype = function clonePrototype(parent) {
                    if (parent === null) return null;
                    var c = function () {};
                    c.prototype = parent;
                    return new c();
                  };

                  // private utility functions

                  function __objToStr(o) {
                    return Object.prototype.toString.call(o);
                  }
                  clone.__objToStr = __objToStr;
                  function __isDate(o) {
                    return typeof o === 'object' && __objToStr(o) === '[object Date]';
                  }
                  clone.__isDate = __isDate;
                  function __isArray(o) {
                    return typeof o === 'object' && __objToStr(o) === '[object Array]';
                  }
                  clone.__isArray = __isArray;
                  function __isRegExp(o) {
                    return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
                  }
                  clone.__isRegExp = __isRegExp;
                  function __getRegExpFlags(re) {
                    var flags = '';
                    if (re.global) flags += 'g';
                    if (re.ignoreCase) flags += 'i';
                    if (re.multiline) flags += 'm';
                    return flags;
                  }
                  clone.__getRegExpFlags = __getRegExpFlags;
                  return clone;
                }();
                if (typeof module === 'object' && module.exports) {
                  module.exports = clone;
                }

                /***/
              }, /* 22 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var _slicedToArray = function () {
                  function sliceIterator(arr, i) {
                    var _arr = [];
                    var _n = true;
                    var _d = false;
                    var _e = undefined;
                    try {
                      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                        _arr.push(_s.value);
                        if (i && _arr.length === i) break;
                      }
                    } catch (err) {
                      _d = true;
                      _e = err;
                    } finally {
                      try {
                        if (!_n && _i["return"]) _i["return"]();
                      } finally {
                        if (_d) throw _e;
                      }
                    }
                    return _arr;
                  }
                  return function (arr, i) {
                    if (Array.isArray(arr)) {
                      return arr;
                    } else if (Symbol.iterator in Object(arr)) {
                      return sliceIterator(arr, i);
                    } else {
                      throw new TypeError("Invalid attempt to destructure non-iterable instance");
                    }
                  };
                }();
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _get = function get(object, property, receiver) {
                  if (object === null) object = Function.prototype;
                  var desc = Object.getOwnPropertyDescriptor(object, property);
                  if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                      return undefined;
                    } else {
                      return get(parent, property, receiver);
                    }
                  } else if ("value" in desc) {
                    return desc.value;
                  } else {
                    var getter = desc.get;
                    if (getter === undefined) {
                      return undefined;
                    }
                    return getter.call(receiver);
                  }
                };
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _emitter = __webpack_require__(8);
                var _emitter2 = _interopRequireDefault(_emitter);
                var _block = __webpack_require__(4);
                var _block2 = _interopRequireDefault(_block);
                var _break = __webpack_require__(16);
                var _break2 = _interopRequireDefault(_break);
                var _code = __webpack_require__(13);
                var _code2 = _interopRequireDefault(_code);
                var _container = __webpack_require__(25);
                var _container2 = _interopRequireDefault(_container);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                function isLine(blot) {
                  return blot instanceof _block2.default || blot instanceof _block.BlockEmbed;
                }
                var Scroll = function (_Parchment$Scroll) {
                  _inherits(Scroll, _Parchment$Scroll);
                  function Scroll(domNode, config) {
                    _classCallCheck(this, Scroll);
                    var _this = _possibleConstructorReturn(this, (Scroll.__proto__ || Object.getPrototypeOf(Scroll)).call(this, domNode));
                    _this.emitter = config.emitter;
                    if (Array.isArray(config.whitelist)) {
                      _this.whitelist = config.whitelist.reduce(function (whitelist, format) {
                        whitelist[format] = true;
                        return whitelist;
                      }, {});
                    }
                    // Some reason fixes composition issues with character languages in Windows/Chrome, Safari
                    _this.domNode.addEventListener('DOMNodeInserted', function () {});
                    _this.optimize();
                    _this.enable();
                    return _this;
                  }
                  _createClass(Scroll, [{
                    key: 'batchStart',
                    value: function batchStart() {
                      this.batch = true;
                    }
                  }, {
                    key: 'batchEnd',
                    value: function batchEnd() {
                      this.batch = false;
                      this.optimize();
                    }
                  }, {
                    key: 'deleteAt',
                    value: function deleteAt(index, length) {
                      var _line = this.line(index),
                        _line2 = _slicedToArray(_line, 2),
                        first = _line2[0],
                        offset = _line2[1];
                      var _line3 = this.line(index + length),
                        _line4 = _slicedToArray(_line3, 1),
                        last = _line4[0];
                      _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'deleteAt', this).call(this, index, length);
                      if (last != null && first !== last && offset > 0) {
                        if (first instanceof _block.BlockEmbed || last instanceof _block.BlockEmbed) {
                          this.optimize();
                          return;
                        }
                        if (first instanceof _code2.default) {
                          var newlineIndex = first.newlineIndex(first.length(), true);
                          if (newlineIndex > -1) {
                            first = first.split(newlineIndex + 1);
                            if (first === last) {
                              this.optimize();
                              return;
                            }
                          }
                        } else if (last instanceof _code2.default) {
                          var _newlineIndex = last.newlineIndex(0);
                          if (_newlineIndex > -1) {
                            last.split(_newlineIndex + 1);
                          }
                        }
                        var ref = last.children.head instanceof _break2.default ? null : last.children.head;
                        first.moveChildren(last, ref);
                        first.remove();
                      }
                      this.optimize();
                    }
                  }, {
                    key: 'enable',
                    value: function enable() {
                      var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
                      this.domNode.setAttribute('contenteditable', enabled);
                    }
                  }, {
                    key: 'formatAt',
                    value: function formatAt(index, length, format, value) {
                      if (this.whitelist != null && !this.whitelist[format]) return;
                      _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'formatAt', this).call(this, index, length, format, value);
                      this.optimize();
                    }
                  }, {
                    key: 'insertAt',
                    value: function insertAt(index, value, def) {
                      if (def != null && this.whitelist != null && !this.whitelist[value]) return;
                      if (index >= this.length()) {
                        if (def == null || _parchment2.default.query(value, _parchment2.default.Scope.BLOCK) == null) {
                          var blot = _parchment2.default.create(this.statics.defaultChild);
                          this.appendChild(blot);
                          if (def == null && value.endsWith('\n')) {
                            value = value.slice(0, -1);
                          }
                          blot.insertAt(0, value, def);
                        } else {
                          var embed = _parchment2.default.create(value, def);
                          this.appendChild(embed);
                        }
                      } else {
                        _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'insertAt', this).call(this, index, value, def);
                      }
                      this.optimize();
                    }
                  }, {
                    key: 'insertBefore',
                    value: function insertBefore(blot, ref) {
                      if (blot.statics.scope === _parchment2.default.Scope.INLINE_BLOT) {
                        var wrapper = _parchment2.default.create(this.statics.defaultChild);
                        wrapper.appendChild(blot);
                        blot = wrapper;
                      }
                      _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'insertBefore', this).call(this, blot, ref);
                    }
                  }, {
                    key: 'leaf',
                    value: function leaf(index) {
                      return this.path(index).pop() || [null, -1];
                    }
                  }, {
                    key: 'line',
                    value: function line(index) {
                      if (index === this.length()) {
                        return this.line(index - 1);
                      }
                      return this.descendant(isLine, index);
                    }
                  }, {
                    key: 'lines',
                    value: function lines() {
                      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;
                      var getLines = function getLines(blot, index, length) {
                        var lines = [],
                          lengthLeft = length;
                        blot.children.forEachAt(index, length, function (child, index, length) {
                          if (isLine(child)) {
                            lines.push(child);
                          } else if (child instanceof _parchment2.default.Container) {
                            lines = lines.concat(getLines(child, index, lengthLeft));
                          }
                          lengthLeft -= length;
                        });
                        return lines;
                      };
                      return getLines(this, index, length);
                    }
                  }, {
                    key: 'optimize',
                    value: function optimize() {
                      var mutations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
                      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                      if (this.batch === true) return;
                      _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'optimize', this).call(this, mutations, context);
                      if (mutations.length > 0) {
                        this.emitter.emit(_emitter2.default.events.SCROLL_OPTIMIZE, mutations, context);
                      }
                    }
                  }, {
                    key: 'path',
                    value: function path(index) {
                      return _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'path', this).call(this, index).slice(1); // Exclude self
                    }
                  }, {
                    key: 'update',
                    value: function update(mutations) {
                      if (this.batch === true) return;
                      var source = _emitter2.default.sources.USER;
                      if (typeof mutations === 'string') {
                        source = mutations;
                      }
                      if (!Array.isArray(mutations)) {
                        mutations = this.observer.takeRecords();
                      }
                      if (mutations.length > 0) {
                        this.emitter.emit(_emitter2.default.events.SCROLL_BEFORE_UPDATE, source, mutations);
                      }
                      _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'update', this).call(this, mutations.concat([])); // pass copy
                      if (mutations.length > 0) {
                        this.emitter.emit(_emitter2.default.events.SCROLL_UPDATE, source, mutations);
                      }
                    }
                  }]);
                  return Scroll;
                }(_parchment2.default.Scroll);
                Scroll.blotName = 'scroll';
                Scroll.className = 'ql-editor';
                Scroll.tagName = 'DIV';
                Scroll.defaultChild = 'block';
                Scroll.allowedChildren = [_block2.default, _block.BlockEmbed, _container2.default];
                exports.default = Scroll;

                /***/
              }, /* 23 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.SHORTKEY = exports.default = undefined;
                var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
                  return typeof obj;
                } : function (obj) {
                  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
                var _slicedToArray = function () {
                  function sliceIterator(arr, i) {
                    var _arr = [];
                    var _n = true;
                    var _d = false;
                    var _e = undefined;
                    try {
                      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                        _arr.push(_s.value);
                        if (i && _arr.length === i) break;
                      }
                    } catch (err) {
                      _d = true;
                      _e = err;
                    } finally {
                      try {
                        if (!_n && _i["return"]) _i["return"]();
                      } finally {
                        if (_d) throw _e;
                      }
                    }
                    return _arr;
                  }
                  return function (arr, i) {
                    if (Array.isArray(arr)) {
                      return arr;
                    } else if (Symbol.iterator in Object(arr)) {
                      return sliceIterator(arr, i);
                    } else {
                      throw new TypeError("Invalid attempt to destructure non-iterable instance");
                    }
                  };
                }();
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _clone = __webpack_require__(21);
                var _clone2 = _interopRequireDefault(_clone);
                var _deepEqual = __webpack_require__(11);
                var _deepEqual2 = _interopRequireDefault(_deepEqual);
                var _extend = __webpack_require__(3);
                var _extend2 = _interopRequireDefault(_extend);
                var _quillDelta = __webpack_require__(2);
                var _quillDelta2 = _interopRequireDefault(_quillDelta);
                var _op = __webpack_require__(20);
                var _op2 = _interopRequireDefault(_op);
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _quill = __webpack_require__(5);
                var _quill2 = _interopRequireDefault(_quill);
                var _logger = __webpack_require__(10);
                var _logger2 = _interopRequireDefault(_logger);
                var _module = __webpack_require__(9);
                var _module2 = _interopRequireDefault(_module);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _defineProperty(obj, key, value) {
                  if (key in obj) {
                    Object.defineProperty(obj, key, {
                      value: value,
                      enumerable: true,
                      configurable: true,
                      writable: true
                    });
                  } else {
                    obj[key] = value;
                  }
                  return obj;
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var debug = (0, _logger2.default)('quill:keyboard');
                var SHORTKEY = /Mac/i.test(navigator.platform) ? 'metaKey' : 'ctrlKey';
                var Keyboard = function (_Module) {
                  _inherits(Keyboard, _Module);
                  _createClass(Keyboard, null, [{
                    key: 'match',
                    value: function match(evt, binding) {
                      binding = normalize(binding);
                      if (['altKey', 'ctrlKey', 'metaKey', 'shiftKey'].some(function (key) {
                        return !!binding[key] !== evt[key] && binding[key] !== null;
                      })) {
                        return false;
                      }
                      return binding.key === (evt.which || evt.keyCode);
                    }
                  }]);
                  function Keyboard(quill, options) {
                    _classCallCheck(this, Keyboard);
                    var _this = _possibleConstructorReturn(this, (Keyboard.__proto__ || Object.getPrototypeOf(Keyboard)).call(this, quill, options));
                    _this.bindings = {};
                    Object.keys(_this.options.bindings).forEach(function (name) {
                      if (name === 'list autofill' && quill.scroll.whitelist != null && !quill.scroll.whitelist['list']) {
                        return;
                      }
                      if (_this.options.bindings[name]) {
                        _this.addBinding(_this.options.bindings[name]);
                      }
                    });
                    _this.addBinding({
                      key: Keyboard.keys.ENTER,
                      shiftKey: null
                    }, handleEnter);
                    _this.addBinding({
                      key: Keyboard.keys.ENTER,
                      metaKey: null,
                      ctrlKey: null,
                      altKey: null
                    }, function () {});
                    if (/Firefox/i.test(navigator.userAgent)) {
                      // Need to handle delete and backspace for Firefox in the general case #1171
                      _this.addBinding({
                        key: Keyboard.keys.BACKSPACE
                      }, {
                        collapsed: true
                      }, handleBackspace);
                      _this.addBinding({
                        key: Keyboard.keys.DELETE
                      }, {
                        collapsed: true
                      }, handleDelete);
                    } else {
                      _this.addBinding({
                        key: Keyboard.keys.BACKSPACE
                      }, {
                        collapsed: true,
                        prefix: /^.?$/
                      }, handleBackspace);
                      _this.addBinding({
                        key: Keyboard.keys.DELETE
                      }, {
                        collapsed: true,
                        suffix: /^.?$/
                      }, handleDelete);
                    }
                    _this.addBinding({
                      key: Keyboard.keys.BACKSPACE
                    }, {
                      collapsed: false
                    }, handleDeleteRange);
                    _this.addBinding({
                      key: Keyboard.keys.DELETE
                    }, {
                      collapsed: false
                    }, handleDeleteRange);
                    _this.addBinding({
                      key: Keyboard.keys.BACKSPACE,
                      altKey: null,
                      ctrlKey: null,
                      metaKey: null,
                      shiftKey: null
                    }, {
                      collapsed: true,
                      offset: 0
                    }, handleBackspace);
                    _this.listen();
                    return _this;
                  }
                  _createClass(Keyboard, [{
                    key: 'addBinding',
                    value: function addBinding(key) {
                      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                      var handler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                      var binding = normalize(key);
                      if (binding == null || binding.key == null) {
                        return debug.warn('Attempted to add invalid keyboard binding', binding);
                      }
                      if (typeof context === 'function') {
                        context = {
                          handler: context
                        };
                      }
                      if (typeof handler === 'function') {
                        handler = {
                          handler: handler
                        };
                      }
                      binding = (0, _extend2.default)(binding, context, handler);
                      this.bindings[binding.key] = this.bindings[binding.key] || [];
                      this.bindings[binding.key].push(binding);
                    }
                  }, {
                    key: 'listen',
                    value: function listen() {
                      var _this2 = this;
                      this.quill.root.addEventListener('keydown', function (evt) {
                        if (evt.defaultPrevented) return;
                        var which = evt.which || evt.keyCode;
                        var bindings = (_this2.bindings[which] || []).filter(function (binding) {
                          return Keyboard.match(evt, binding);
                        });
                        if (bindings.length === 0) return;
                        var range = _this2.quill.getSelection();
                        if (range == null || !_this2.quill.hasFocus()) return;
                        var _quill$getLine = _this2.quill.getLine(range.index),
                          _quill$getLine2 = _slicedToArray(_quill$getLine, 2),
                          line = _quill$getLine2[0],
                          offset = _quill$getLine2[1];
                        var _quill$getLeaf = _this2.quill.getLeaf(range.index),
                          _quill$getLeaf2 = _slicedToArray(_quill$getLeaf, 2),
                          leafStart = _quill$getLeaf2[0],
                          offsetStart = _quill$getLeaf2[1];
                        var _ref = range.length === 0 ? [leafStart, offsetStart] : _this2.quill.getLeaf(range.index + range.length),
                          _ref2 = _slicedToArray(_ref, 2),
                          leafEnd = _ref2[0],
                          offsetEnd = _ref2[1];
                        var prefixText = leafStart instanceof _parchment2.default.Text ? leafStart.value().slice(0, offsetStart) : '';
                        var suffixText = leafEnd instanceof _parchment2.default.Text ? leafEnd.value().slice(offsetEnd) : '';
                        var curContext = {
                          collapsed: range.length === 0,
                          empty: range.length === 0 && line.length() <= 1,
                          format: _this2.quill.getFormat(range),
                          offset: offset,
                          prefix: prefixText,
                          suffix: suffixText
                        };
                        var prevented = bindings.some(function (binding) {
                          if (binding.collapsed != null && binding.collapsed !== curContext.collapsed) return false;
                          if (binding.empty != null && binding.empty !== curContext.empty) return false;
                          if (binding.offset != null && binding.offset !== curContext.offset) return false;
                          if (Array.isArray(binding.format)) {
                            // any format is present
                            if (binding.format.every(function (name) {
                              return curContext.format[name] == null;
                            })) {
                              return false;
                            }
                          } else if (_typeof(binding.format) === 'object') {
                            // all formats must match
                            if (!Object.keys(binding.format).every(function (name) {
                              if (binding.format[name] === true) return curContext.format[name] != null;
                              if (binding.format[name] === false) return curContext.format[name] == null;
                              return (0, _deepEqual2.default)(binding.format[name], curContext.format[name]);
                            })) {
                              return false;
                            }
                          }
                          if (binding.prefix != null && !binding.prefix.test(curContext.prefix)) return false;
                          if (binding.suffix != null && !binding.suffix.test(curContext.suffix)) return false;
                          return binding.handler.call(_this2, range, curContext) !== true;
                        });
                        if (prevented) {
                          evt.preventDefault();
                        }
                      });
                    }
                  }]);
                  return Keyboard;
                }(_module2.default);
                Keyboard.keys = {
                  BACKSPACE: 8,
                  TAB: 9,
                  ENTER: 13,
                  ESCAPE: 27,
                  LEFT: 37,
                  UP: 38,
                  RIGHT: 39,
                  DOWN: 40,
                  DELETE: 46
                };
                Keyboard.DEFAULTS = {
                  bindings: {
                    'bold': makeFormatHandler('bold'),
                    'italic': makeFormatHandler('italic'),
                    'underline': makeFormatHandler('underline'),
                    'indent': {
                      // highlight tab or tab at beginning of list, indent or blockquote
                      key: Keyboard.keys.TAB,
                      format: ['blockquote', 'indent', 'list'],
                      handler: function handler(range, context) {
                        if (context.collapsed && context.offset !== 0) return true;
                        this.quill.format('indent', '+1', _quill2.default.sources.USER);
                      }
                    },
                    'outdent': {
                      key: Keyboard.keys.TAB,
                      shiftKey: true,
                      format: ['blockquote', 'indent', 'list'],
                      // highlight tab or tab at beginning of list, indent or blockquote
                      handler: function handler(range, context) {
                        if (context.collapsed && context.offset !== 0) return true;
                        this.quill.format('indent', '-1', _quill2.default.sources.USER);
                      }
                    },
                    'outdent backspace': {
                      key: Keyboard.keys.BACKSPACE,
                      collapsed: true,
                      shiftKey: null,
                      metaKey: null,
                      ctrlKey: null,
                      altKey: null,
                      format: ['indent', 'list'],
                      offset: 0,
                      handler: function handler(range, context) {
                        if (context.format.indent != null) {
                          this.quill.format('indent', '-1', _quill2.default.sources.USER);
                        } else if (context.format.list != null) {
                          this.quill.format('list', false, _quill2.default.sources.USER);
                        }
                      }
                    },
                    'indent code-block': makeCodeBlockHandler(true),
                    'outdent code-block': makeCodeBlockHandler(false),
                    'remove tab': {
                      key: Keyboard.keys.TAB,
                      shiftKey: true,
                      collapsed: true,
                      prefix: /\t$/,
                      handler: function handler(range) {
                        this.quill.deleteText(range.index - 1, 1, _quill2.default.sources.USER);
                      }
                    },
                    'tab': {
                      key: Keyboard.keys.TAB,
                      handler: function handler(range) {
                        this.quill.history.cutoff();
                        var delta = new _quillDelta2.default().retain(range.index).delete(range.length).insert('\t');
                        this.quill.updateContents(delta, _quill2.default.sources.USER);
                        this.quill.history.cutoff();
                        this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
                      }
                    },
                    'list empty enter': {
                      key: Keyboard.keys.ENTER,
                      collapsed: true,
                      format: ['list'],
                      empty: true,
                      handler: function handler(range, context) {
                        this.quill.format('list', false, _quill2.default.sources.USER);
                        if (context.format.indent) {
                          this.quill.format('indent', false, _quill2.default.sources.USER);
                        }
                      }
                    },
                    'checklist enter': {
                      key: Keyboard.keys.ENTER,
                      collapsed: true,
                      format: {
                        list: 'checked'
                      },
                      handler: function handler(range) {
                        var _quill$getLine3 = this.quill.getLine(range.index),
                          _quill$getLine4 = _slicedToArray(_quill$getLine3, 2),
                          line = _quill$getLine4[0],
                          offset = _quill$getLine4[1];
                        var formats = (0, _extend2.default)({}, line.formats(), {
                          list: 'checked'
                        });
                        var delta = new _quillDelta2.default().retain(range.index).insert('\n', formats).retain(line.length() - offset - 1).retain(1, {
                          list: 'unchecked'
                        });
                        this.quill.updateContents(delta, _quill2.default.sources.USER);
                        this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
                        this.quill.scrollIntoView();
                      }
                    },
                    'header enter': {
                      key: Keyboard.keys.ENTER,
                      collapsed: true,
                      format: ['header'],
                      suffix: /^$/,
                      handler: function handler(range, context) {
                        var _quill$getLine5 = this.quill.getLine(range.index),
                          _quill$getLine6 = _slicedToArray(_quill$getLine5, 2),
                          line = _quill$getLine6[0],
                          offset = _quill$getLine6[1];
                        var delta = new _quillDelta2.default().retain(range.index).insert('\n', context.format).retain(line.length() - offset - 1).retain(1, {
                          header: null
                        });
                        this.quill.updateContents(delta, _quill2.default.sources.USER);
                        this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
                        this.quill.scrollIntoView();
                      }
                    },
                    'list autofill': {
                      key: ' ',
                      collapsed: true,
                      format: {
                        list: false
                      },
                      prefix: /^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/,
                      handler: function handler(range, context) {
                        var length = context.prefix.length;
                        var _quill$getLine7 = this.quill.getLine(range.index),
                          _quill$getLine8 = _slicedToArray(_quill$getLine7, 2),
                          line = _quill$getLine8[0],
                          offset = _quill$getLine8[1];
                        if (offset > length) return true;
                        var value = void 0;
                        switch (context.prefix.trim()) {
                          case '[]':
                          case '[ ]':
                            value = 'unchecked';
                            break;
                          case '[x]':
                            value = 'checked';
                            break;
                          case '-':
                          case '*':
                            value = 'bullet';
                            break;
                          default:
                            value = 'ordered';
                        }
                        this.quill.insertText(range.index, ' ', _quill2.default.sources.USER);
                        this.quill.history.cutoff();
                        var delta = new _quillDelta2.default().retain(range.index - offset).delete(length + 1).retain(line.length() - 2 - offset).retain(1, {
                          list: value
                        });
                        this.quill.updateContents(delta, _quill2.default.sources.USER);
                        this.quill.history.cutoff();
                        this.quill.setSelection(range.index - length, _quill2.default.sources.SILENT);
                      }
                    },
                    'code exit': {
                      key: Keyboard.keys.ENTER,
                      collapsed: true,
                      format: ['code-block'],
                      prefix: /\n\n$/,
                      suffix: /^\s+$/,
                      handler: function handler(range) {
                        var _quill$getLine9 = this.quill.getLine(range.index),
                          _quill$getLine10 = _slicedToArray(_quill$getLine9, 2),
                          line = _quill$getLine10[0],
                          offset = _quill$getLine10[1];
                        var delta = new _quillDelta2.default().retain(range.index + line.length() - offset - 2).retain(1, {
                          'code-block': null
                        }).delete(1);
                        this.quill.updateContents(delta, _quill2.default.sources.USER);
                      }
                    },
                    'embed left': makeEmbedArrowHandler(Keyboard.keys.LEFT, false),
                    'embed left shift': makeEmbedArrowHandler(Keyboard.keys.LEFT, true),
                    'embed right': makeEmbedArrowHandler(Keyboard.keys.RIGHT, false),
                    'embed right shift': makeEmbedArrowHandler(Keyboard.keys.RIGHT, true)
                  }
                };
                function makeEmbedArrowHandler(key, shiftKey) {
                  var _ref3;
                  var where = key === Keyboard.keys.LEFT ? 'prefix' : 'suffix';
                  return _ref3 = {
                    key: key,
                    shiftKey: shiftKey,
                    altKey: null
                  }, _defineProperty(_ref3, where, /^$/), _defineProperty(_ref3, 'handler', function handler(range) {
                    var index = range.index;
                    if (key === Keyboard.keys.RIGHT) {
                      index += range.length + 1;
                    }
                    var _quill$getLeaf3 = this.quill.getLeaf(index),
                      _quill$getLeaf4 = _slicedToArray(_quill$getLeaf3, 1),
                      leaf = _quill$getLeaf4[0];
                    if (!(leaf instanceof _parchment2.default.Embed)) return true;
                    if (key === Keyboard.keys.LEFT) {
                      if (shiftKey) {
                        this.quill.setSelection(range.index - 1, range.length + 1, _quill2.default.sources.USER);
                      } else {
                        this.quill.setSelection(range.index - 1, _quill2.default.sources.USER);
                      }
                    } else {
                      if (shiftKey) {
                        this.quill.setSelection(range.index, range.length + 1, _quill2.default.sources.USER);
                      } else {
                        this.quill.setSelection(range.index + range.length + 1, _quill2.default.sources.USER);
                      }
                    }
                    return false;
                  }), _ref3;
                }
                function handleBackspace(range, context) {
                  if (range.index === 0 || this.quill.getLength() <= 1) return;
                  var _quill$getLine11 = this.quill.getLine(range.index),
                    _quill$getLine12 = _slicedToArray(_quill$getLine11, 1),
                    line = _quill$getLine12[0];
                  var formats = {};
                  if (context.offset === 0) {
                    var _quill$getLine13 = this.quill.getLine(range.index - 1),
                      _quill$getLine14 = _slicedToArray(_quill$getLine13, 1),
                      prev = _quill$getLine14[0];
                    if (prev != null && prev.length() > 1) {
                      var curFormats = line.formats();
                      var prevFormats = this.quill.getFormat(range.index - 1, 1);
                      formats = _op2.default.attributes.diff(curFormats, prevFormats) || {};
                    }
                  }
                  // Check for astral symbols
                  var length = /[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(context.prefix) ? 2 : 1;
                  this.quill.deleteText(range.index - length, length, _quill2.default.sources.USER);
                  if (Object.keys(formats).length > 0) {
                    this.quill.formatLine(range.index - length, length, formats, _quill2.default.sources.USER);
                  }
                  this.quill.focus();
                }
                function handleDelete(range, context) {
                  // Check for astral symbols
                  var length = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(context.suffix) ? 2 : 1;
                  if (range.index >= this.quill.getLength() - length) return;
                  var formats = {},
                    nextLength = 0;
                  var _quill$getLine15 = this.quill.getLine(range.index),
                    _quill$getLine16 = _slicedToArray(_quill$getLine15, 1),
                    line = _quill$getLine16[0];
                  if (context.offset >= line.length() - 1) {
                    var _quill$getLine17 = this.quill.getLine(range.index + 1),
                      _quill$getLine18 = _slicedToArray(_quill$getLine17, 1),
                      next = _quill$getLine18[0];
                    if (next) {
                      var curFormats = line.formats();
                      var nextFormats = this.quill.getFormat(range.index, 1);
                      formats = _op2.default.attributes.diff(curFormats, nextFormats) || {};
                      nextLength = next.length();
                    }
                  }
                  this.quill.deleteText(range.index, length, _quill2.default.sources.USER);
                  if (Object.keys(formats).length > 0) {
                    this.quill.formatLine(range.index + nextLength - 1, length, formats, _quill2.default.sources.USER);
                  }
                }
                function handleDeleteRange(range) {
                  var lines = this.quill.getLines(range);
                  var formats = {};
                  if (lines.length > 1) {
                    var firstFormats = lines[0].formats();
                    var lastFormats = lines[lines.length - 1].formats();
                    formats = _op2.default.attributes.diff(lastFormats, firstFormats) || {};
                  }
                  this.quill.deleteText(range, _quill2.default.sources.USER);
                  if (Object.keys(formats).length > 0) {
                    this.quill.formatLine(range.index, 1, formats, _quill2.default.sources.USER);
                  }
                  this.quill.setSelection(range.index, _quill2.default.sources.SILENT);
                  this.quill.focus();
                }
                function handleEnter(range, context) {
                  var _this3 = this;
                  if (range.length > 0) {
                    this.quill.scroll.deleteAt(range.index, range.length); // So we do not trigger text-change
                  }

                  var lineFormats = Object.keys(context.format).reduce(function (lineFormats, format) {
                    if (_parchment2.default.query(format, _parchment2.default.Scope.BLOCK) && !Array.isArray(context.format[format])) {
                      lineFormats[format] = context.format[format];
                    }
                    return lineFormats;
                  }, {});
                  this.quill.insertText(range.index, '\n', lineFormats, _quill2.default.sources.USER);
                  // Earlier scroll.deleteAt might have messed up our selection,
                  // so insertText's built in selection preservation is not reliable
                  this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
                  this.quill.focus();
                  Object.keys(context.format).forEach(function (name) {
                    if (lineFormats[name] != null) return;
                    if (Array.isArray(context.format[name])) return;
                    if (name === 'link') return;
                    _this3.quill.format(name, context.format[name], _quill2.default.sources.USER);
                  });
                }
                function makeCodeBlockHandler(indent) {
                  return {
                    key: Keyboard.keys.TAB,
                    shiftKey: !indent,
                    format: {
                      'code-block': true
                    },
                    handler: function handler(range) {
                      var CodeBlock = _parchment2.default.query('code-block');
                      var index = range.index,
                        length = range.length;
                      var _quill$scroll$descend = this.quill.scroll.descendant(CodeBlock, index),
                        _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2),
                        block = _quill$scroll$descend2[0],
                        offset = _quill$scroll$descend2[1];
                      if (block == null) return;
                      var scrollIndex = this.quill.getIndex(block);
                      var start = block.newlineIndex(offset, true) + 1;
                      var end = block.newlineIndex(scrollIndex + offset + length);
                      var lines = block.domNode.textContent.slice(start, end).split('\n');
                      offset = 0;
                      lines.forEach(function (line, i) {
                        if (indent) {
                          block.insertAt(start + offset, CodeBlock.TAB);
                          offset += CodeBlock.TAB.length;
                          if (i === 0) {
                            index += CodeBlock.TAB.length;
                          } else {
                            length += CodeBlock.TAB.length;
                          }
                        } else if (line.startsWith(CodeBlock.TAB)) {
                          block.deleteAt(start + offset, CodeBlock.TAB.length);
                          offset -= CodeBlock.TAB.length;
                          if (i === 0) {
                            index -= CodeBlock.TAB.length;
                          } else {
                            length -= CodeBlock.TAB.length;
                          }
                        }
                        offset += line.length + 1;
                      });
                      this.quill.update(_quill2.default.sources.USER);
                      this.quill.setSelection(index, length, _quill2.default.sources.SILENT);
                    }
                  };
                }
                function makeFormatHandler(format) {
                  return {
                    key: format[0].toUpperCase(),
                    shortKey: true,
                    handler: function handler(range, context) {
                      this.quill.format(format, !context.format[format], _quill2.default.sources.USER);
                    }
                  };
                }
                function normalize(binding) {
                  if (typeof binding === 'string' || typeof binding === 'number') {
                    return normalize({
                      key: binding
                    });
                  }
                  if ((typeof binding === 'undefined' ? 'undefined' : _typeof(binding)) === 'object') {
                    binding = (0, _clone2.default)(binding, false);
                  }
                  if (typeof binding.key === 'string') {
                    if (Keyboard.keys[binding.key.toUpperCase()] != null) {
                      binding.key = Keyboard.keys[binding.key.toUpperCase()];
                    } else if (binding.key.length === 1) {
                      binding.key = binding.key.toUpperCase().charCodeAt(0);
                    } else {
                      return null;
                    }
                  }
                  if (binding.shortKey) {
                    binding[SHORTKEY] = binding.shortKey;
                    delete binding.shortKey;
                  }
                  return binding;
                }
                exports.default = Keyboard;
                exports.SHORTKEY = SHORTKEY;

                /***/
              }, /* 24 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var _slicedToArray = function () {
                  function sliceIterator(arr, i) {
                    var _arr = [];
                    var _n = true;
                    var _d = false;
                    var _e = undefined;
                    try {
                      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                        _arr.push(_s.value);
                        if (i && _arr.length === i) break;
                      }
                    } catch (err) {
                      _d = true;
                      _e = err;
                    } finally {
                      try {
                        if (!_n && _i["return"]) _i["return"]();
                      } finally {
                        if (_d) throw _e;
                      }
                    }
                    return _arr;
                  }
                  return function (arr, i) {
                    if (Array.isArray(arr)) {
                      return arr;
                    } else if (Symbol.iterator in Object(arr)) {
                      return sliceIterator(arr, i);
                    } else {
                      throw new TypeError("Invalid attempt to destructure non-iterable instance");
                    }
                  };
                }();
                var _get = function get(object, property, receiver) {
                  if (object === null) object = Function.prototype;
                  var desc = Object.getOwnPropertyDescriptor(object, property);
                  if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                      return undefined;
                    } else {
                      return get(parent, property, receiver);
                    }
                  } else if ("value" in desc) {
                    return desc.value;
                  } else {
                    var getter = desc.get;
                    if (getter === undefined) {
                      return undefined;
                    }
                    return getter.call(receiver);
                  }
                };
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _text = __webpack_require__(7);
                var _text2 = _interopRequireDefault(_text);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var Cursor = function (_Parchment$Embed) {
                  _inherits(Cursor, _Parchment$Embed);
                  _createClass(Cursor, null, [{
                    key: 'value',
                    value: function value() {
                      return undefined;
                    }
                  }]);
                  function Cursor(domNode, selection) {
                    _classCallCheck(this, Cursor);
                    var _this = _possibleConstructorReturn(this, (Cursor.__proto__ || Object.getPrototypeOf(Cursor)).call(this, domNode));
                    _this.selection = selection;
                    _this.textNode = document.createTextNode(Cursor.CONTENTS);
                    _this.domNode.appendChild(_this.textNode);
                    _this._length = 0;
                    return _this;
                  }
                  _createClass(Cursor, [{
                    key: 'detach',
                    value: function detach() {
                      // super.detach() will also clear domNode.__blot
                      if (this.parent != null) this.parent.removeChild(this);
                    }
                  }, {
                    key: 'format',
                    value: function format(name, value) {
                      if (this._length !== 0) {
                        return _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), 'format', this).call(this, name, value);
                      }
                      var target = this,
                        index = 0;
                      while (target != null && target.statics.scope !== _parchment2.default.Scope.BLOCK_BLOT) {
                        index += target.offset(target.parent);
                        target = target.parent;
                      }
                      if (target != null) {
                        this._length = Cursor.CONTENTS.length;
                        target.optimize();
                        target.formatAt(index, Cursor.CONTENTS.length, name, value);
                        this._length = 0;
                      }
                    }
                  }, {
                    key: 'index',
                    value: function index(node, offset) {
                      if (node === this.textNode) return 0;
                      return _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), 'index', this).call(this, node, offset);
                    }
                  }, {
                    key: 'length',
                    value: function length() {
                      return this._length;
                    }
                  }, {
                    key: 'position',
                    value: function position() {
                      return [this.textNode, this.textNode.data.length];
                    }
                  }, {
                    key: 'remove',
                    value: function remove() {
                      _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), 'remove', this).call(this);
                      this.parent = null;
                    }
                  }, {
                    key: 'restore',
                    value: function restore() {
                      if (this.selection.composing || this.parent == null) return;
                      var textNode = this.textNode;
                      var range = this.selection.getNativeRange();
                      var restoreText = void 0,
                        start = void 0,
                        end = void 0;
                      if (range != null && range.start.node === textNode && range.end.node === textNode) {
                        var _ref = [textNode, range.start.offset, range.end.offset];
                        restoreText = _ref[0];
                        start = _ref[1];
                        end = _ref[2];
                      }
                      // Link format will insert text outside of anchor tag
                      while (this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode) {
                        this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);
                      }
                      if (this.textNode.data !== Cursor.CONTENTS) {
                        var text = this.textNode.data.split(Cursor.CONTENTS).join('');
                        if (this.next instanceof _text2.default) {
                          restoreText = this.next.domNode;
                          this.next.insertAt(0, text);
                          this.textNode.data = Cursor.CONTENTS;
                        } else {
                          this.textNode.data = text;
                          this.parent.insertBefore(_parchment2.default.create(this.textNode), this);
                          this.textNode = document.createTextNode(Cursor.CONTENTS);
                          this.domNode.appendChild(this.textNode);
                        }
                      }
                      this.remove();
                      if (start != null) {
                        var _map = [start, end].map(function (offset) {
                          return Math.max(0, Math.min(restoreText.data.length, offset - 1));
                        });
                        var _map2 = _slicedToArray(_map, 2);
                        start = _map2[0];
                        end = _map2[1];
                        return {
                          startNode: restoreText,
                          startOffset: start,
                          endNode: restoreText,
                          endOffset: end
                        };
                      }
                    }
                  }, {
                    key: 'update',
                    value: function update(mutations, context) {
                      var _this2 = this;
                      if (mutations.some(function (mutation) {
                        return mutation.type === 'characterData' && mutation.target === _this2.textNode;
                      })) {
                        var range = this.restore();
                        if (range) context.range = range;
                      }
                    }
                  }, {
                    key: 'value',
                    value: function value() {
                      return '';
                    }
                  }]);
                  return Cursor;
                }(_parchment2.default.Embed);
                Cursor.blotName = 'cursor';
                Cursor.className = 'ql-cursor';
                Cursor.tagName = 'span';
                Cursor.CONTENTS = '\uFEFF'; // Zero width no break space

                exports.default = Cursor;

                /***/
              }, /* 25 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _block = __webpack_require__(4);
                var _block2 = _interopRequireDefault(_block);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var Container = function (_Parchment$Container) {
                  _inherits(Container, _Parchment$Container);
                  function Container() {
                    _classCallCheck(this, Container);
                    return _possibleConstructorReturn(this, (Container.__proto__ || Object.getPrototypeOf(Container)).apply(this, arguments));
                  }
                  return Container;
                }(_parchment2.default.Container);
                Container.allowedChildren = [_block2.default, _block.BlockEmbed, Container];
                exports.default = Container;

                /***/
              }, /* 26 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.ColorStyle = exports.ColorClass = exports.ColorAttributor = undefined;
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _get = function get(object, property, receiver) {
                  if (object === null) object = Function.prototype;
                  var desc = Object.getOwnPropertyDescriptor(object, property);
                  if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                      return undefined;
                    } else {
                      return get(parent, property, receiver);
                    }
                  } else if ("value" in desc) {
                    return desc.value;
                  } else {
                    var getter = desc.get;
                    if (getter === undefined) {
                      return undefined;
                    }
                    return getter.call(receiver);
                  }
                };
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var ColorAttributor = function (_Parchment$Attributor) {
                  _inherits(ColorAttributor, _Parchment$Attributor);
                  function ColorAttributor() {
                    _classCallCheck(this, ColorAttributor);
                    return _possibleConstructorReturn(this, (ColorAttributor.__proto__ || Object.getPrototypeOf(ColorAttributor)).apply(this, arguments));
                  }
                  _createClass(ColorAttributor, [{
                    key: 'value',
                    value: function value(domNode) {
                      var value = _get(ColorAttributor.prototype.__proto__ || Object.getPrototypeOf(ColorAttributor.prototype), 'value', this).call(this, domNode);
                      if (!value.startsWith('rgb(')) return value;
                      value = value.replace(/^[^\d]+/, '').replace(/[^\d]+$/, '');
                      return '#' + value.split(',').map(function (component) {
                        return ('00' + parseInt(component).toString(16)).slice(-2);
                      }).join('');
                    }
                  }]);
                  return ColorAttributor;
                }(_parchment2.default.Attributor.Style);
                var ColorClass = new _parchment2.default.Attributor.Class('color', 'ql-color', {
                  scope: _parchment2.default.Scope.INLINE
                });
                var ColorStyle = new ColorAttributor('color', 'color', {
                  scope: _parchment2.default.Scope.INLINE
                });
                exports.ColorAttributor = ColorAttributor;
                exports.ColorClass = ColorClass;
                exports.ColorStyle = ColorStyle;

                /***/
              }, /* 27 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.sanitize = exports.default = undefined;
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _get = function get(object, property, receiver) {
                  if (object === null) object = Function.prototype;
                  var desc = Object.getOwnPropertyDescriptor(object, property);
                  if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                      return undefined;
                    } else {
                      return get(parent, property, receiver);
                    }
                  } else if ("value" in desc) {
                    return desc.value;
                  } else {
                    var getter = desc.get;
                    if (getter === undefined) {
                      return undefined;
                    }
                    return getter.call(receiver);
                  }
                };
                var _inline = __webpack_require__(6);
                var _inline2 = _interopRequireDefault(_inline);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var Link = function (_Inline) {
                  _inherits(Link, _Inline);
                  function Link() {
                    _classCallCheck(this, Link);
                    return _possibleConstructorReturn(this, (Link.__proto__ || Object.getPrototypeOf(Link)).apply(this, arguments));
                  }
                  _createClass(Link, [{
                    key: 'format',
                    value: function format(name, value) {
                      if (name !== this.statics.blotName || !value) return _get(Link.prototype.__proto__ || Object.getPrototypeOf(Link.prototype), 'format', this).call(this, name, value);
                      value = this.constructor.sanitize(value);
                      this.domNode.setAttribute('href', value);
                    }
                  }], [{
                    key: 'create',
                    value: function create(value) {
                      var node = _get(Link.__proto__ || Object.getPrototypeOf(Link), 'create', this).call(this, value);
                      value = this.sanitize(value);
                      node.setAttribute('href', value);
                      node.setAttribute('rel', 'noopener noreferrer');
                      node.setAttribute('target', '_blank');
                      return node;
                    }
                  }, {
                    key: 'formats',
                    value: function formats(domNode) {
                      return domNode.getAttribute('href');
                    }
                  }, {
                    key: 'sanitize',
                    value: function sanitize(url) {
                      return _sanitize(url, this.PROTOCOL_WHITELIST) ? url : this.SANITIZED_URL;
                    }
                  }]);
                  return Link;
                }(_inline2.default);
                Link.blotName = 'link';
                Link.tagName = 'A';
                Link.SANITIZED_URL = 'about:blank';
                Link.PROTOCOL_WHITELIST = ['http', 'https', 'mailto', 'tel'];
                function _sanitize(url, protocols) {
                  var anchor = document.createElement('a');
                  anchor.href = url;
                  var protocol = anchor.href.slice(0, anchor.href.indexOf(':'));
                  return protocols.indexOf(protocol) > -1;
                }
                exports.default = Link;
                exports.sanitize = _sanitize;

                /***/
              }, /* 28 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
                  return typeof obj;
                } : function (obj) {
                  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _keyboard = __webpack_require__(23);
                var _keyboard2 = _interopRequireDefault(_keyboard);
                var _dropdown = __webpack_require__(107);
                var _dropdown2 = _interopRequireDefault(_dropdown);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                var optionsCounter = 0;
                function toggleAriaAttribute(element, attribute) {
                  element.setAttribute(attribute, !(element.getAttribute(attribute) === 'true'));
                }
                var Picker = function () {
                  function Picker(select) {
                    var _this = this;
                    _classCallCheck(this, Picker);
                    this.select = select;
                    this.container = document.createElement('span');
                    this.buildPicker();
                    this.select.style.display = 'none';
                    this.select.parentNode.insertBefore(this.container, this.select);
                    this.label.addEventListener('mousedown', function () {
                      _this.togglePicker();
                    });
                    this.label.addEventListener('keydown', function (event) {
                      switch (event.keyCode) {
                        // Allows the "Enter" key to open the picker
                        case _keyboard2.default.keys.ENTER:
                          _this.togglePicker();
                          break;

                        // Allows the "Escape" key to close the picker
                        case _keyboard2.default.keys.ESCAPE:
                          _this.escape();
                          event.preventDefault();
                          break;
                      }
                    });
                    this.select.addEventListener('change', this.update.bind(this));
                  }
                  _createClass(Picker, [{
                    key: 'togglePicker',
                    value: function togglePicker() {
                      this.container.classList.toggle('ql-expanded');
                      // Toggle aria-expanded and aria-hidden to make the picker accessible
                      toggleAriaAttribute(this.label, 'aria-expanded');
                      toggleAriaAttribute(this.options, 'aria-hidden');
                    }
                  }, {
                    key: 'buildItem',
                    value: function buildItem(option) {
                      var _this2 = this;
                      var item = document.createElement('span');
                      item.tabIndex = '0';
                      item.setAttribute('role', 'button');
                      item.classList.add('ql-picker-item');
                      if (option.hasAttribute('value')) {
                        item.setAttribute('data-value', option.getAttribute('value'));
                      }
                      if (option.textContent) {
                        item.setAttribute('data-label', option.textContent);
                      }
                      item.addEventListener('click', function () {
                        _this2.selectItem(item, true);
                      });
                      item.addEventListener('keydown', function (event) {
                        switch (event.keyCode) {
                          // Allows the "Enter" key to select an item
                          case _keyboard2.default.keys.ENTER:
                            _this2.selectItem(item, true);
                            event.preventDefault();
                            break;

                          // Allows the "Escape" key to close the picker
                          case _keyboard2.default.keys.ESCAPE:
                            _this2.escape();
                            event.preventDefault();
                            break;
                        }
                      });
                      return item;
                    }
                  }, {
                    key: 'buildLabel',
                    value: function buildLabel() {
                      var label = document.createElement('span');
                      label.classList.add('ql-picker-label');
                      label.innerHTML = _dropdown2.default;
                      label.tabIndex = '0';
                      label.setAttribute('role', 'button');
                      label.setAttribute('aria-expanded', 'false');
                      this.container.appendChild(label);
                      return label;
                    }
                  }, {
                    key: 'buildOptions',
                    value: function buildOptions() {
                      var _this3 = this;
                      var options = document.createElement('span');
                      options.classList.add('ql-picker-options');

                      // Don't want screen readers to read this until options are visible
                      options.setAttribute('aria-hidden', 'true');
                      options.tabIndex = '-1';

                      // Need a unique id for aria-controls
                      options.id = 'ql-picker-options-' + optionsCounter;
                      optionsCounter += 1;
                      this.label.setAttribute('aria-controls', options.id);
                      this.options = options;
                      [].slice.call(this.select.options).forEach(function (option) {
                        var item = _this3.buildItem(option);
                        options.appendChild(item);
                        if (option.selected === true) {
                          _this3.selectItem(item);
                        }
                      });
                      this.container.appendChild(options);
                    }
                  }, {
                    key: 'buildPicker',
                    value: function buildPicker() {
                      var _this4 = this;
                      [].slice.call(this.select.attributes).forEach(function (item) {
                        _this4.container.setAttribute(item.name, item.value);
                      });
                      this.container.classList.add('ql-picker');
                      this.label = this.buildLabel();
                      this.buildOptions();
                    }
                  }, {
                    key: 'escape',
                    value: function escape() {
                      var _this5 = this;

                      // Close menu and return focus to trigger label
                      this.close();
                      // Need setTimeout for accessibility to ensure that the browser executes
                      // focus on the next process thread and after any DOM content changes
                      setTimeout(function () {
                        return _this5.label.focus();
                      }, 1);
                    }
                  }, {
                    key: 'close',
                    value: function close() {
                      this.container.classList.remove('ql-expanded');
                      this.label.setAttribute('aria-expanded', 'false');
                      this.options.setAttribute('aria-hidden', 'true');
                    }
                  }, {
                    key: 'selectItem',
                    value: function selectItem(item) {
                      var trigger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                      var selected = this.container.querySelector('.ql-selected');
                      if (item === selected) return;
                      if (selected != null) {
                        selected.classList.remove('ql-selected');
                      }
                      if (item == null) return;
                      item.classList.add('ql-selected');
                      this.select.selectedIndex = [].indexOf.call(item.parentNode.children, item);
                      if (item.hasAttribute('data-value')) {
                        this.label.setAttribute('data-value', item.getAttribute('data-value'));
                      } else {
                        this.label.removeAttribute('data-value');
                      }
                      if (item.hasAttribute('data-label')) {
                        this.label.setAttribute('data-label', item.getAttribute('data-label'));
                      } else {
                        this.label.removeAttribute('data-label');
                      }
                      if (trigger) {
                        if (typeof Event === 'function') {
                          this.select.dispatchEvent(new Event('change'));
                        } else if ((typeof Event === 'undefined' ? 'undefined' : _typeof(Event)) === 'object') {
                          // IE11
                          var event = document.createEvent('Event');
                          event.initEvent('change', true, true);
                          this.select.dispatchEvent(event);
                        }
                        this.close();
                      }
                    }
                  }, {
                    key: 'update',
                    value: function update() {
                      var option = void 0;
                      if (this.select.selectedIndex > -1) {
                        var item = this.container.querySelector('.ql-picker-options').children[this.select.selectedIndex];
                        option = this.select.options[this.select.selectedIndex];
                        this.selectItem(item);
                      } else {
                        this.selectItem(null);
                      }
                      var isActive = option != null && option !== this.select.querySelector('option[selected]');
                      this.label.classList.toggle('ql-active', isActive);
                    }
                  }]);
                  return Picker;
                }();
                exports.default = Picker;

                /***/
              }, /* 29 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _quill = __webpack_require__(5);
                var _quill2 = _interopRequireDefault(_quill);
                var _block = __webpack_require__(4);
                var _block2 = _interopRequireDefault(_block);
                var _break = __webpack_require__(16);
                var _break2 = _interopRequireDefault(_break);
                var _container = __webpack_require__(25);
                var _container2 = _interopRequireDefault(_container);
                var _cursor = __webpack_require__(24);
                var _cursor2 = _interopRequireDefault(_cursor);
                var _embed = __webpack_require__(35);
                var _embed2 = _interopRequireDefault(_embed);
                var _inline = __webpack_require__(6);
                var _inline2 = _interopRequireDefault(_inline);
                var _scroll = __webpack_require__(22);
                var _scroll2 = _interopRequireDefault(_scroll);
                var _text = __webpack_require__(7);
                var _text2 = _interopRequireDefault(_text);
                var _clipboard = __webpack_require__(55);
                var _clipboard2 = _interopRequireDefault(_clipboard);
                var _history = __webpack_require__(42);
                var _history2 = _interopRequireDefault(_history);
                var _keyboard = __webpack_require__(23);
                var _keyboard2 = _interopRequireDefault(_keyboard);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                _quill2.default.register({
                  'blots/block': _block2.default,
                  'blots/block/embed': _block.BlockEmbed,
                  'blots/break': _break2.default,
                  'blots/container': _container2.default,
                  'blots/cursor': _cursor2.default,
                  'blots/embed': _embed2.default,
                  'blots/inline': _inline2.default,
                  'blots/scroll': _scroll2.default,
                  'blots/text': _text2.default,
                  'modules/clipboard': _clipboard2.default,
                  'modules/history': _history2.default,
                  'modules/keyboard': _keyboard2.default
                });
                _parchment2.default.register(_block2.default, _break2.default, _cursor2.default, _inline2.default, _scroll2.default, _text2.default);
                exports.default = _quill2.default;

                /***/
              }, /* 30 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var Registry = __webpack_require__(1);
                var ShadowBlot = /** @class */function () {
                  function ShadowBlot(domNode) {
                    this.domNode = domNode;
                    // @ts-ignore
                    this.domNode[Registry.DATA_KEY] = {
                      blot: this
                    };
                  }
                  Object.defineProperty(ShadowBlot.prototype, "statics", {
                    // Hack for accessing inherited static methods
                    get: function () {
                      return this.constructor;
                    },
                    enumerable: true,
                    configurable: true
                  });
                  ShadowBlot.create = function (value) {
                    if (this.tagName == null) {
                      throw new Registry.ParchmentError('Blot definition missing tagName');
                    }
                    var node;
                    if (Array.isArray(this.tagName)) {
                      if (typeof value === 'string') {
                        value = value.toUpperCase();
                        if (parseInt(value).toString() === value) {
                          value = parseInt(value);
                        }
                      }
                      if (typeof value === 'number') {
                        node = document.createElement(this.tagName[value - 1]);
                      } else if (this.tagName.indexOf(value) > -1) {
                        node = document.createElement(value);
                      } else {
                        node = document.createElement(this.tagName[0]);
                      }
                    } else {
                      node = document.createElement(this.tagName);
                    }
                    if (this.className) {
                      node.classList.add(this.className);
                    }
                    return node;
                  };
                  ShadowBlot.prototype.attach = function () {
                    if (this.parent != null) {
                      this.scroll = this.parent.scroll;
                    }
                  };
                  ShadowBlot.prototype.clone = function () {
                    var domNode = this.domNode.cloneNode(false);
                    return Registry.create(domNode);
                  };
                  ShadowBlot.prototype.detach = function () {
                    if (this.parent != null) this.parent.removeChild(this);
                    // @ts-ignore
                    delete this.domNode[Registry.DATA_KEY];
                  };
                  ShadowBlot.prototype.deleteAt = function (index, length) {
                    var blot = this.isolate(index, length);
                    blot.remove();
                  };
                  ShadowBlot.prototype.formatAt = function (index, length, name, value) {
                    var blot = this.isolate(index, length);
                    if (Registry.query(name, Registry.Scope.BLOT) != null && value) {
                      blot.wrap(name, value);
                    } else if (Registry.query(name, Registry.Scope.ATTRIBUTE) != null) {
                      var parent = Registry.create(this.statics.scope);
                      blot.wrap(parent);
                      parent.format(name, value);
                    }
                  };
                  ShadowBlot.prototype.insertAt = function (index, value, def) {
                    var blot = def == null ? Registry.create('text', value) : Registry.create(value, def);
                    var ref = this.split(index);
                    this.parent.insertBefore(blot, ref);
                  };
                  ShadowBlot.prototype.insertInto = function (parentBlot, refBlot) {
                    if (refBlot === void 0) {
                      refBlot = null;
                    }
                    if (this.parent != null) {
                      this.parent.children.remove(this);
                    }
                    var refDomNode = null;
                    parentBlot.children.insertBefore(this, refBlot);
                    if (refBlot != null) {
                      refDomNode = refBlot.domNode;
                    }
                    if (this.domNode.parentNode != parentBlot.domNode || this.domNode.nextSibling != refDomNode) {
                      parentBlot.domNode.insertBefore(this.domNode, refDomNode);
                    }
                    this.parent = parentBlot;
                    this.attach();
                  };
                  ShadowBlot.prototype.isolate = function (index, length) {
                    var target = this.split(index);
                    target.split(length);
                    return target;
                  };
                  ShadowBlot.prototype.length = function () {
                    return 1;
                  };
                  ShadowBlot.prototype.offset = function (root) {
                    if (root === void 0) {
                      root = this.parent;
                    }
                    if (this.parent == null || this == root) return 0;
                    return this.parent.children.offset(this) + this.parent.offset(root);
                  };
                  ShadowBlot.prototype.optimize = function (context) {
                    // TODO clean up once we use WeakMap
                    // @ts-ignore
                    if (this.domNode[Registry.DATA_KEY] != null) {
                      // @ts-ignore
                      delete this.domNode[Registry.DATA_KEY].mutations;
                    }
                  };
                  ShadowBlot.prototype.remove = function () {
                    if (this.domNode.parentNode != null) {
                      this.domNode.parentNode.removeChild(this.domNode);
                    }
                    this.detach();
                  };
                  ShadowBlot.prototype.replace = function (target) {
                    if (target.parent == null) return;
                    target.parent.insertBefore(this, target.next);
                    target.remove();
                  };
                  ShadowBlot.prototype.replaceWith = function (name, value) {
                    var replacement = typeof name === 'string' ? Registry.create(name, value) : name;
                    replacement.replace(this);
                    return replacement;
                  };
                  ShadowBlot.prototype.split = function (index, force) {
                    return index === 0 ? this : this.next;
                  };
                  ShadowBlot.prototype.update = function (mutations, context) {
                    // Nothing to do by default
                  };
                  ShadowBlot.prototype.wrap = function (name, value) {
                    var wrapper = typeof name === 'string' ? Registry.create(name, value) : name;
                    if (this.parent != null) {
                      this.parent.insertBefore(wrapper, this.next);
                    }
                    wrapper.appendChild(this);
                    return wrapper;
                  };
                  ShadowBlot.blotName = 'abstract';
                  return ShadowBlot;
                }();
                exports.default = ShadowBlot;

                /***/
              }, /* 31 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var attributor_1 = __webpack_require__(12);
                var class_1 = __webpack_require__(32);
                var style_1 = __webpack_require__(33);
                var Registry = __webpack_require__(1);
                var AttributorStore = /** @class */function () {
                  function AttributorStore(domNode) {
                    this.attributes = {};
                    this.domNode = domNode;
                    this.build();
                  }
                  AttributorStore.prototype.attribute = function (attribute, value) {
                    // verb
                    if (value) {
                      if (attribute.add(this.domNode, value)) {
                        if (attribute.value(this.domNode) != null) {
                          this.attributes[attribute.attrName] = attribute;
                        } else {
                          delete this.attributes[attribute.attrName];
                        }
                      }
                    } else {
                      attribute.remove(this.domNode);
                      delete this.attributes[attribute.attrName];
                    }
                  };
                  AttributorStore.prototype.build = function () {
                    var _this = this;
                    this.attributes = {};
                    var attributes = attributor_1.default.keys(this.domNode);
                    var classes = class_1.default.keys(this.domNode);
                    var styles = style_1.default.keys(this.domNode);
                    attributes.concat(classes).concat(styles).forEach(function (name) {
                      var attr = Registry.query(name, Registry.Scope.ATTRIBUTE);
                      if (attr instanceof attributor_1.default) {
                        _this.attributes[attr.attrName] = attr;
                      }
                    });
                  };
                  AttributorStore.prototype.copy = function (target) {
                    var _this = this;
                    Object.keys(this.attributes).forEach(function (key) {
                      var value = _this.attributes[key].value(_this.domNode);
                      target.format(key, value);
                    });
                  };
                  AttributorStore.prototype.move = function (target) {
                    var _this = this;
                    this.copy(target);
                    Object.keys(this.attributes).forEach(function (key) {
                      _this.attributes[key].remove(_this.domNode);
                    });
                    this.attributes = {};
                  };
                  AttributorStore.prototype.values = function () {
                    var _this = this;
                    return Object.keys(this.attributes).reduce(function (attributes, name) {
                      attributes[name] = _this.attributes[name].value(_this.domNode);
                      return attributes;
                    }, {});
                  };
                  return AttributorStore;
                }();
                exports.default = AttributorStore;

                /***/
              }, /* 32 */
              /***/function (module, exports, __webpack_require__) {
                var __extends = this && this.__extends || function () {
                  var extendStatics = Object.setPrototypeOf || {
                    __proto__: []
                  } instanceof Array && function (d, b) {
                    d.__proto__ = b;
                  } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                  };
                  return function (d, b) {
                    extendStatics(d, b);
                    function __() {
                      this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                  };
                }();
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var attributor_1 = __webpack_require__(12);
                function match(node, prefix) {
                  var className = node.getAttribute('class') || '';
                  return className.split(/\s+/).filter(function (name) {
                    return name.indexOf(prefix + "-") === 0;
                  });
                }
                var ClassAttributor = /** @class */function (_super) {
                  __extends(ClassAttributor, _super);
                  function ClassAttributor() {
                    return _super !== null && _super.apply(this, arguments) || this;
                  }
                  ClassAttributor.keys = function (node) {
                    return (node.getAttribute('class') || '').split(/\s+/).map(function (name) {
                      return name.split('-').slice(0, -1).join('-');
                    });
                  };
                  ClassAttributor.prototype.add = function (node, value) {
                    if (!this.canAdd(node, value)) return false;
                    this.remove(node);
                    node.classList.add(this.keyName + "-" + value);
                    return true;
                  };
                  ClassAttributor.prototype.remove = function (node) {
                    var matches = match(node, this.keyName);
                    matches.forEach(function (name) {
                      node.classList.remove(name);
                    });
                    if (node.classList.length === 0) {
                      node.removeAttribute('class');
                    }
                  };
                  ClassAttributor.prototype.value = function (node) {
                    var result = match(node, this.keyName)[0] || '';
                    var value = result.slice(this.keyName.length + 1); // +1 for hyphen
                    return this.canAdd(node, value) ? value : '';
                  };
                  return ClassAttributor;
                }(attributor_1.default);
                exports.default = ClassAttributor;

                /***/
              }, /* 33 */
              /***/function (module, exports, __webpack_require__) {
                var __extends = this && this.__extends || function () {
                  var extendStatics = Object.setPrototypeOf || {
                    __proto__: []
                  } instanceof Array && function (d, b) {
                    d.__proto__ = b;
                  } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                  };
                  return function (d, b) {
                    extendStatics(d, b);
                    function __() {
                      this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                  };
                }();
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var attributor_1 = __webpack_require__(12);
                function camelize(name) {
                  var parts = name.split('-');
                  var rest = parts.slice(1).map(function (part) {
                    return part[0].toUpperCase() + part.slice(1);
                  }).join('');
                  return parts[0] + rest;
                }
                var StyleAttributor = /** @class */function (_super) {
                  __extends(StyleAttributor, _super);
                  function StyleAttributor() {
                    return _super !== null && _super.apply(this, arguments) || this;
                  }
                  StyleAttributor.keys = function (node) {
                    return (node.getAttribute('style') || '').split(';').map(function (value) {
                      var arr = value.split(':');
                      return arr[0].trim();
                    });
                  };
                  StyleAttributor.prototype.add = function (node, value) {
                    if (!this.canAdd(node, value)) return false;
                    // @ts-ignore
                    node.style[camelize(this.keyName)] = value;
                    return true;
                  };
                  StyleAttributor.prototype.remove = function (node) {
                    // @ts-ignore
                    node.style[camelize(this.keyName)] = '';
                    if (!node.getAttribute('style')) {
                      node.removeAttribute('style');
                    }
                  };
                  StyleAttributor.prototype.value = function (node) {
                    // @ts-ignore
                    var value = node.style[camelize(this.keyName)];
                    return this.canAdd(node, value) ? value : '';
                  };
                  return StyleAttributor;
                }(attributor_1.default);
                exports.default = StyleAttributor;

                /***/
              }, /* 34 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                var Theme = function () {
                  function Theme(quill, options) {
                    _classCallCheck(this, Theme);
                    this.quill = quill;
                    this.options = options;
                    this.modules = {};
                  }
                  _createClass(Theme, [{
                    key: 'init',
                    value: function init() {
                      var _this = this;
                      Object.keys(this.options.modules).forEach(function (name) {
                        if (_this.modules[name] == null) {
                          _this.addModule(name);
                        }
                      });
                    }
                  }, {
                    key: 'addModule',
                    value: function addModule(name) {
                      var moduleClass = this.quill.constructor.import('modules/' + name);
                      this.modules[name] = new moduleClass(this.quill, this.options.modules[name] || {});
                      return this.modules[name];
                    }
                  }]);
                  return Theme;
                }();
                Theme.DEFAULTS = {
                  modules: {}
                };
                Theme.themes = {
                  'default': Theme
                };
                exports.default = Theme;

                /***/
              }, /* 35 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _get = function get(object, property, receiver) {
                  if (object === null) object = Function.prototype;
                  var desc = Object.getOwnPropertyDescriptor(object, property);
                  if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                      return undefined;
                    } else {
                      return get(parent, property, receiver);
                    }
                  } else if ("value" in desc) {
                    return desc.value;
                  } else {
                    var getter = desc.get;
                    if (getter === undefined) {
                      return undefined;
                    }
                    return getter.call(receiver);
                  }
                };
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _text = __webpack_require__(7);
                var _text2 = _interopRequireDefault(_text);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var GUARD_TEXT = '\uFEFF';
                var Embed = function (_Parchment$Embed) {
                  _inherits(Embed, _Parchment$Embed);
                  function Embed(node) {
                    _classCallCheck(this, Embed);
                    var _this = _possibleConstructorReturn(this, (Embed.__proto__ || Object.getPrototypeOf(Embed)).call(this, node));
                    _this.contentNode = document.createElement('span');
                    _this.contentNode.setAttribute('contenteditable', false);
                    [].slice.call(_this.domNode.childNodes).forEach(function (childNode) {
                      _this.contentNode.appendChild(childNode);
                    });
                    _this.leftGuard = document.createTextNode(GUARD_TEXT);
                    _this.rightGuard = document.createTextNode(GUARD_TEXT);
                    _this.domNode.appendChild(_this.leftGuard);
                    _this.domNode.appendChild(_this.contentNode);
                    _this.domNode.appendChild(_this.rightGuard);
                    return _this;
                  }
                  _createClass(Embed, [{
                    key: 'index',
                    value: function index(node, offset) {
                      if (node === this.leftGuard) return 0;
                      if (node === this.rightGuard) return 1;
                      return _get(Embed.prototype.__proto__ || Object.getPrototypeOf(Embed.prototype), 'index', this).call(this, node, offset);
                    }
                  }, {
                    key: 'restore',
                    value: function restore(node) {
                      var range = void 0,
                        textNode = void 0;
                      var text = node.data.split(GUARD_TEXT).join('');
                      if (node === this.leftGuard) {
                        if (this.prev instanceof _text2.default) {
                          var prevLength = this.prev.length();
                          this.prev.insertAt(prevLength, text);
                          range = {
                            startNode: this.prev.domNode,
                            startOffset: prevLength + text.length
                          };
                        } else {
                          textNode = document.createTextNode(text);
                          this.parent.insertBefore(_parchment2.default.create(textNode), this);
                          range = {
                            startNode: textNode,
                            startOffset: text.length
                          };
                        }
                      } else if (node === this.rightGuard) {
                        if (this.next instanceof _text2.default) {
                          this.next.insertAt(0, text);
                          range = {
                            startNode: this.next.domNode,
                            startOffset: text.length
                          };
                        } else {
                          textNode = document.createTextNode(text);
                          this.parent.insertBefore(_parchment2.default.create(textNode), this.next);
                          range = {
                            startNode: textNode,
                            startOffset: text.length
                          };
                        }
                      }
                      node.data = GUARD_TEXT;
                      return range;
                    }
                  }, {
                    key: 'update',
                    value: function update(mutations, context) {
                      var _this2 = this;
                      mutations.forEach(function (mutation) {
                        if (mutation.type === 'characterData' && (mutation.target === _this2.leftGuard || mutation.target === _this2.rightGuard)) {
                          var range = _this2.restore(mutation.target);
                          if (range) context.range = range;
                        }
                      });
                    }
                  }]);
                  return Embed;
                }(_parchment2.default.Embed);
                exports.default = Embed;

                /***/
              }, /* 36 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.AlignStyle = exports.AlignClass = exports.AlignAttribute = undefined;
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                var config = {
                  scope: _parchment2.default.Scope.BLOCK,
                  whitelist: ['right', 'center', 'justify']
                };
                var AlignAttribute = new _parchment2.default.Attributor.Attribute('align', 'align', config);
                var AlignClass = new _parchment2.default.Attributor.Class('align', 'ql-align', config);
                var AlignStyle = new _parchment2.default.Attributor.Style('align', 'text-align', config);
                exports.AlignAttribute = AlignAttribute;
                exports.AlignClass = AlignClass;
                exports.AlignStyle = AlignStyle;

                /***/
              }, /* 37 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.BackgroundStyle = exports.BackgroundClass = undefined;
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _color = __webpack_require__(26);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                var BackgroundClass = new _parchment2.default.Attributor.Class('background', 'ql-bg', {
                  scope: _parchment2.default.Scope.INLINE
                });
                var BackgroundStyle = new _color.ColorAttributor('background', 'background-color', {
                  scope: _parchment2.default.Scope.INLINE
                });
                exports.BackgroundClass = BackgroundClass;
                exports.BackgroundStyle = BackgroundStyle;

                /***/
              }, /* 38 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.DirectionStyle = exports.DirectionClass = exports.DirectionAttribute = undefined;
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                var config = {
                  scope: _parchment2.default.Scope.BLOCK,
                  whitelist: ['rtl']
                };
                var DirectionAttribute = new _parchment2.default.Attributor.Attribute('direction', 'dir', config);
                var DirectionClass = new _parchment2.default.Attributor.Class('direction', 'ql-direction', config);
                var DirectionStyle = new _parchment2.default.Attributor.Style('direction', 'direction', config);
                exports.DirectionAttribute = DirectionAttribute;
                exports.DirectionClass = DirectionClass;
                exports.DirectionStyle = DirectionStyle;

                /***/
              }, /* 39 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.FontClass = exports.FontStyle = undefined;
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _get = function get(object, property, receiver) {
                  if (object === null) object = Function.prototype;
                  var desc = Object.getOwnPropertyDescriptor(object, property);
                  if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                      return undefined;
                    } else {
                      return get(parent, property, receiver);
                    }
                  } else if ("value" in desc) {
                    return desc.value;
                  } else {
                    var getter = desc.get;
                    if (getter === undefined) {
                      return undefined;
                    }
                    return getter.call(receiver);
                  }
                };
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var config = {
                  scope: _parchment2.default.Scope.INLINE,
                  whitelist: ['serif', 'monospace']
                };
                var FontClass = new _parchment2.default.Attributor.Class('font', 'ql-font', config);
                var FontStyleAttributor = function (_Parchment$Attributor) {
                  _inherits(FontStyleAttributor, _Parchment$Attributor);
                  function FontStyleAttributor() {
                    _classCallCheck(this, FontStyleAttributor);
                    return _possibleConstructorReturn(this, (FontStyleAttributor.__proto__ || Object.getPrototypeOf(FontStyleAttributor)).apply(this, arguments));
                  }
                  _createClass(FontStyleAttributor, [{
                    key: 'value',
                    value: function value(node) {
                      return _get(FontStyleAttributor.prototype.__proto__ || Object.getPrototypeOf(FontStyleAttributor.prototype), 'value', this).call(this, node).replace(/["']/g, '');
                    }
                  }]);
                  return FontStyleAttributor;
                }(_parchment2.default.Attributor.Style);
                var FontStyle = new FontStyleAttributor('font', 'font-family', config);
                exports.FontStyle = FontStyle;
                exports.FontClass = FontClass;

                /***/
              }, /* 40 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.SizeStyle = exports.SizeClass = undefined;
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                var SizeClass = new _parchment2.default.Attributor.Class('size', 'ql-size', {
                  scope: _parchment2.default.Scope.INLINE,
                  whitelist: ['small', 'large', 'huge']
                });
                var SizeStyle = new _parchment2.default.Attributor.Style('size', 'font-size', {
                  scope: _parchment2.default.Scope.INLINE,
                  whitelist: ['10px', '18px', '32px']
                });
                exports.SizeClass = SizeClass;
                exports.SizeStyle = SizeStyle;

                /***/
              }, /* 41 */
              /***/function (module, exports, __webpack_require__) {
                module.exports = {
                  'align': {
                    '': __webpack_require__(76),
                    'center': __webpack_require__(77),
                    'right': __webpack_require__(78),
                    'justify': __webpack_require__(79)
                  },
                  'background': __webpack_require__(80),
                  'blockquote': __webpack_require__(81),
                  'bold': __webpack_require__(82),
                  'clean': __webpack_require__(83),
                  'code': __webpack_require__(58),
                  'code-block': __webpack_require__(58),
                  'color': __webpack_require__(84),
                  'direction': {
                    '': __webpack_require__(85),
                    'rtl': __webpack_require__(86)
                  },
                  'float': {
                    'center': __webpack_require__(87),
                    'full': __webpack_require__(88),
                    'left': __webpack_require__(89),
                    'right': __webpack_require__(90)
                  },
                  'formula': __webpack_require__(91),
                  'header': {
                    '1': __webpack_require__(92),
                    '2': __webpack_require__(93)
                  },
                  'italic': __webpack_require__(94),
                  'image': __webpack_require__(95),
                  'indent': {
                    '+1': __webpack_require__(96),
                    '-1': __webpack_require__(97)
                  },
                  'link': __webpack_require__(98),
                  'list': {
                    'ordered': __webpack_require__(99),
                    'bullet': __webpack_require__(100),
                    'check': __webpack_require__(101)
                  },
                  'script': {
                    'sub': __webpack_require__(102),
                    'super': __webpack_require__(103)
                  },
                  'strike': __webpack_require__(104),
                  'underline': __webpack_require__(105),
                  'video': __webpack_require__(106)
                };

                /***/
              }, /* 42 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.getLastChangeIndex = exports.default = undefined;
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _quill = __webpack_require__(5);
                var _quill2 = _interopRequireDefault(_quill);
                var _module = __webpack_require__(9);
                var _module2 = _interopRequireDefault(_module);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var History = function (_Module) {
                  _inherits(History, _Module);
                  function History(quill, options) {
                    _classCallCheck(this, History);
                    var _this = _possibleConstructorReturn(this, (History.__proto__ || Object.getPrototypeOf(History)).call(this, quill, options));
                    _this.lastRecorded = 0;
                    _this.ignoreChange = false;
                    _this.clear();
                    _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function (eventName, delta, oldDelta, source) {
                      if (eventName !== _quill2.default.events.TEXT_CHANGE || _this.ignoreChange) return;
                      if (!_this.options.userOnly || source === _quill2.default.sources.USER) {
                        _this.record(delta, oldDelta);
                      } else {
                        _this.transform(delta);
                      }
                    });
                    _this.quill.keyboard.addBinding({
                      key: 'Z',
                      shortKey: true
                    }, _this.undo.bind(_this));
                    _this.quill.keyboard.addBinding({
                      key: 'Z',
                      shortKey: true,
                      shiftKey: true
                    }, _this.redo.bind(_this));
                    if (/Win/i.test(navigator.platform)) {
                      _this.quill.keyboard.addBinding({
                        key: 'Y',
                        shortKey: true
                      }, _this.redo.bind(_this));
                    }
                    return _this;
                  }
                  _createClass(History, [{
                    key: 'change',
                    value: function change(source, dest) {
                      if (this.stack[source].length === 0) return;
                      var delta = this.stack[source].pop();
                      this.stack[dest].push(delta);
                      this.lastRecorded = 0;
                      this.ignoreChange = true;
                      this.quill.updateContents(delta[source], _quill2.default.sources.USER);
                      this.ignoreChange = false;
                      var index = getLastChangeIndex(delta[source]);
                      this.quill.setSelection(index);
                    }
                  }, {
                    key: 'clear',
                    value: function clear() {
                      this.stack = {
                        undo: [],
                        redo: []
                      };
                    }
                  }, {
                    key: 'cutoff',
                    value: function cutoff() {
                      this.lastRecorded = 0;
                    }
                  }, {
                    key: 'record',
                    value: function record(changeDelta, oldDelta) {
                      if (changeDelta.ops.length === 0) return;
                      this.stack.redo = [];
                      var undoDelta = this.quill.getContents().diff(oldDelta);
                      var timestamp = Date.now();
                      if (this.lastRecorded + this.options.delay > timestamp && this.stack.undo.length > 0) {
                        var delta = this.stack.undo.pop();
                        undoDelta = undoDelta.compose(delta.undo);
                        changeDelta = delta.redo.compose(changeDelta);
                      } else {
                        this.lastRecorded = timestamp;
                      }
                      this.stack.undo.push({
                        redo: changeDelta,
                        undo: undoDelta
                      });
                      if (this.stack.undo.length > this.options.maxStack) {
                        this.stack.undo.shift();
                      }
                    }
                  }, {
                    key: 'redo',
                    value: function redo() {
                      this.change('redo', 'undo');
                    }
                  }, {
                    key: 'transform',
                    value: function transform(delta) {
                      this.stack.undo.forEach(function (change) {
                        change.undo = delta.transform(change.undo, true);
                        change.redo = delta.transform(change.redo, true);
                      });
                      this.stack.redo.forEach(function (change) {
                        change.undo = delta.transform(change.undo, true);
                        change.redo = delta.transform(change.redo, true);
                      });
                    }
                  }, {
                    key: 'undo',
                    value: function undo() {
                      this.change('undo', 'redo');
                    }
                  }]);
                  return History;
                }(_module2.default);
                History.DEFAULTS = {
                  delay: 1000,
                  maxStack: 100,
                  userOnly: false
                };
                function endsWithNewlineChange(delta) {
                  var lastOp = delta.ops[delta.ops.length - 1];
                  if (lastOp == null) return false;
                  if (lastOp.insert != null) {
                    return typeof lastOp.insert === 'string' && lastOp.insert.endsWith('\n');
                  }
                  if (lastOp.attributes != null) {
                    return Object.keys(lastOp.attributes).some(function (attr) {
                      return _parchment2.default.query(attr, _parchment2.default.Scope.BLOCK) != null;
                    });
                  }
                  return false;
                }
                function getLastChangeIndex(delta) {
                  var deleteLength = delta.reduce(function (length, op) {
                    length += op.delete || 0;
                    return length;
                  }, 0);
                  var changeIndex = delta.length() - deleteLength;
                  if (endsWithNewlineChange(delta)) {
                    changeIndex -= 1;
                  }
                  return changeIndex;
                }
                exports.default = History;
                exports.getLastChangeIndex = getLastChangeIndex;

                /***/
              }, /* 43 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.default = exports.BaseTooltip = undefined;
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _get = function get(object, property, receiver) {
                  if (object === null) object = Function.prototype;
                  var desc = Object.getOwnPropertyDescriptor(object, property);
                  if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                      return undefined;
                    } else {
                      return get(parent, property, receiver);
                    }
                  } else if ("value" in desc) {
                    return desc.value;
                  } else {
                    var getter = desc.get;
                    if (getter === undefined) {
                      return undefined;
                    }
                    return getter.call(receiver);
                  }
                };
                var _extend = __webpack_require__(3);
                var _extend2 = _interopRequireDefault(_extend);
                var _quillDelta = __webpack_require__(2);
                var _quillDelta2 = _interopRequireDefault(_quillDelta);
                var _emitter = __webpack_require__(8);
                var _emitter2 = _interopRequireDefault(_emitter);
                var _keyboard = __webpack_require__(23);
                var _keyboard2 = _interopRequireDefault(_keyboard);
                var _theme = __webpack_require__(34);
                var _theme2 = _interopRequireDefault(_theme);
                var _colorPicker = __webpack_require__(59);
                var _colorPicker2 = _interopRequireDefault(_colorPicker);
                var _iconPicker = __webpack_require__(60);
                var _iconPicker2 = _interopRequireDefault(_iconPicker);
                var _picker = __webpack_require__(28);
                var _picker2 = _interopRequireDefault(_picker);
                var _tooltip = __webpack_require__(61);
                var _tooltip2 = _interopRequireDefault(_tooltip);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var ALIGNS = [false, 'center', 'right', 'justify'];
                var COLORS = ["#000000", "#e60000", "#ff9900", "#ffff00", "#008a00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466"];
                var FONTS = [false, 'serif', 'monospace'];
                var HEADERS = ['1', '2', '3', false];
                var SIZES = ['small', false, 'large', 'huge'];
                var BaseTheme = function (_Theme) {
                  _inherits(BaseTheme, _Theme);
                  function BaseTheme(quill, options) {
                    _classCallCheck(this, BaseTheme);
                    var _this = _possibleConstructorReturn(this, (BaseTheme.__proto__ || Object.getPrototypeOf(BaseTheme)).call(this, quill, options));
                    var listener = function listener(e) {
                      if (!document.body.contains(quill.root)) {
                        return document.body.removeEventListener('click', listener);
                      }
                      if (_this.tooltip != null && !_this.tooltip.root.contains(e.target) && document.activeElement !== _this.tooltip.textbox && !_this.quill.hasFocus()) {
                        _this.tooltip.hide();
                      }
                      if (_this.pickers != null) {
                        _this.pickers.forEach(function (picker) {
                          if (!picker.container.contains(e.target)) {
                            picker.close();
                          }
                        });
                      }
                    };
                    quill.emitter.listenDOM('click', document.body, listener);
                    return _this;
                  }
                  _createClass(BaseTheme, [{
                    key: 'addModule',
                    value: function addModule(name) {
                      var module = _get(BaseTheme.prototype.__proto__ || Object.getPrototypeOf(BaseTheme.prototype), 'addModule', this).call(this, name);
                      if (name === 'toolbar') {
                        this.extendToolbar(module);
                      }
                      return module;
                    }
                  }, {
                    key: 'buildButtons',
                    value: function buildButtons(buttons, icons) {
                      buttons.forEach(function (button) {
                        var className = button.getAttribute('class') || '';
                        className.split(/\s+/).forEach(function (name) {
                          if (!name.startsWith('ql-')) return;
                          name = name.slice('ql-'.length);
                          if (icons[name] == null) return;
                          if (name === 'direction') {
                            button.innerHTML = icons[name][''] + icons[name]['rtl'];
                          } else if (typeof icons[name] === 'string') {
                            button.innerHTML = icons[name];
                          } else {
                            var value = button.value || '';
                            if (value != null && icons[name][value]) {
                              button.innerHTML = icons[name][value];
                            }
                          }
                        });
                      });
                    }
                  }, {
                    key: 'buildPickers',
                    value: function buildPickers(selects, icons) {
                      var _this2 = this;
                      this.pickers = selects.map(function (select) {
                        if (select.classList.contains('ql-align')) {
                          if (select.querySelector('option') == null) {
                            fillSelect(select, ALIGNS);
                          }
                          return new _iconPicker2.default(select, icons.align);
                        } else if (select.classList.contains('ql-background') || select.classList.contains('ql-color')) {
                          var format = select.classList.contains('ql-background') ? 'background' : 'color';
                          if (select.querySelector('option') == null) {
                            fillSelect(select, COLORS, format === 'background' ? '#ffffff' : '#000000');
                          }
                          return new _colorPicker2.default(select, icons[format]);
                        } else {
                          if (select.querySelector('option') == null) {
                            if (select.classList.contains('ql-font')) {
                              fillSelect(select, FONTS);
                            } else if (select.classList.contains('ql-header')) {
                              fillSelect(select, HEADERS);
                            } else if (select.classList.contains('ql-size')) {
                              fillSelect(select, SIZES);
                            }
                          }
                          return new _picker2.default(select);
                        }
                      });
                      var update = function update() {
                        _this2.pickers.forEach(function (picker) {
                          picker.update();
                        });
                      };
                      this.quill.on(_emitter2.default.events.EDITOR_CHANGE, update);
                    }
                  }]);
                  return BaseTheme;
                }(_theme2.default);
                BaseTheme.DEFAULTS = (0, _extend2.default)(true, {}, _theme2.default.DEFAULTS, {
                  modules: {
                    toolbar: {
                      handlers: {
                        formula: function formula() {
                          this.quill.theme.tooltip.edit('formula');
                        },
                        image: function image() {
                          var _this3 = this;
                          var fileInput = this.container.querySelector('input.ql-image[type=file]');
                          if (fileInput == null) {
                            fileInput = document.createElement('input');
                            fileInput.setAttribute('type', 'file');
                            fileInput.setAttribute('accept', 'image/png, image/gif, image/jpeg, image/bmp, image/x-icon');
                            fileInput.classList.add('ql-image');
                            fileInput.addEventListener('change', function () {
                              if (fileInput.files != null && fileInput.files[0] != null) {
                                var reader = new FileReader();
                                reader.onload = function (e) {
                                  var range = _this3.quill.getSelection(true);
                                  _this3.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert({
                                    image: e.target.result
                                  }), _emitter2.default.sources.USER);
                                  _this3.quill.setSelection(range.index + 1, _emitter2.default.sources.SILENT);
                                  fileInput.value = "";
                                };
                                reader.readAsDataURL(fileInput.files[0]);
                              }
                            });
                            this.container.appendChild(fileInput);
                          }
                          fileInput.click();
                        },
                        video: function video() {
                          this.quill.theme.tooltip.edit('video');
                        }
                      }
                    }
                  }
                });
                var BaseTooltip = function (_Tooltip) {
                  _inherits(BaseTooltip, _Tooltip);
                  function BaseTooltip(quill, boundsContainer) {
                    _classCallCheck(this, BaseTooltip);
                    var _this4 = _possibleConstructorReturn(this, (BaseTooltip.__proto__ || Object.getPrototypeOf(BaseTooltip)).call(this, quill, boundsContainer));
                    _this4.textbox = _this4.root.querySelector('input[type="text"]');
                    _this4.listen();
                    return _this4;
                  }
                  _createClass(BaseTooltip, [{
                    key: 'listen',
                    value: function listen() {
                      var _this5 = this;
                      this.textbox.addEventListener('keydown', function (event) {
                        if (_keyboard2.default.match(event, 'enter')) {
                          _this5.save();
                          event.preventDefault();
                        } else if (_keyboard2.default.match(event, 'escape')) {
                          _this5.cancel();
                          event.preventDefault();
                        }
                      });
                    }
                  }, {
                    key: 'cancel',
                    value: function cancel() {
                      this.hide();
                    }
                  }, {
                    key: 'edit',
                    value: function edit() {
                      var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'link';
                      var preview = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                      this.root.classList.remove('ql-hidden');
                      this.root.classList.add('ql-editing');
                      if (preview != null) {
                        this.textbox.value = preview;
                      } else if (mode !== this.root.getAttribute('data-mode')) {
                        this.textbox.value = '';
                      }
                      this.position(this.quill.getBounds(this.quill.selection.savedRange));
                      this.textbox.select();
                      this.textbox.setAttribute('placeholder', this.textbox.getAttribute('data-' + mode) || '');
                      this.root.setAttribute('data-mode', mode);
                    }
                  }, {
                    key: 'restoreFocus',
                    value: function restoreFocus() {
                      var scrollTop = this.quill.scrollingContainer.scrollTop;
                      this.quill.focus();
                      this.quill.scrollingContainer.scrollTop = scrollTop;
                    }
                  }, {
                    key: 'save',
                    value: function save() {
                      var value = this.textbox.value;
                      switch (this.root.getAttribute('data-mode')) {
                        case 'link':
                          {
                            var scrollTop = this.quill.root.scrollTop;
                            if (this.linkRange) {
                              this.quill.formatText(this.linkRange, 'link', value, _emitter2.default.sources.USER);
                              delete this.linkRange;
                            } else {
                              this.restoreFocus();
                              this.quill.format('link', value, _emitter2.default.sources.USER);
                            }
                            this.quill.root.scrollTop = scrollTop;
                            break;
                          }
                        case 'video':
                          {
                            value = extractVideoUrl(value);
                          }
                        // eslint-disable-next-line no-fallthrough
                        case 'formula':
                          {
                            if (!value) break;
                            var range = this.quill.getSelection(true);
                            if (range != null) {
                              var index = range.index + range.length;
                              this.quill.insertEmbed(index, this.root.getAttribute('data-mode'), value, _emitter2.default.sources.USER);
                              if (this.root.getAttribute('data-mode') === 'formula') {
                                this.quill.insertText(index + 1, ' ', _emitter2.default.sources.USER);
                              }
                              this.quill.setSelection(index + 2, _emitter2.default.sources.USER);
                            }
                            break;
                          }
                      }
                      this.textbox.value = '';
                      this.hide();
                    }
                  }]);
                  return BaseTooltip;
                }(_tooltip2.default);
                function extractVideoUrl(url) {
                  var match = url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/) || url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);
                  if (match) {
                    return (match[1] || 'https') + '://www.youtube.com/embed/' + match[2] + '?showinfo=0';
                  }
                  if (match = url.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/)) {
                    // eslint-disable-line no-cond-assign
                    return (match[1] || 'https') + '://player.vimeo.com/video/' + match[2] + '/';
                  }
                  return url;
                }
                function fillSelect(select, values) {
                  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                  values.forEach(function (value) {
                    var option = document.createElement('option');
                    if (value === defaultValue) {
                      option.setAttribute('selected', 'selected');
                    } else {
                      option.setAttribute('value', value);
                    }
                    select.appendChild(option);
                  });
                }
                exports.BaseTooltip = BaseTooltip;
                exports.default = BaseTheme;

                /***/
              }, /* 44 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var LinkedList = /** @class */function () {
                  function LinkedList() {
                    this.head = this.tail = null;
                    this.length = 0;
                  }
                  LinkedList.prototype.append = function () {
                    var nodes = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                      nodes[_i] = arguments[_i];
                    }
                    this.insertBefore(nodes[0], null);
                    if (nodes.length > 1) {
                      this.append.apply(this, nodes.slice(1));
                    }
                  };
                  LinkedList.prototype.contains = function (node) {
                    var cur,
                      next = this.iterator();
                    while (cur = next()) {
                      if (cur === node) return true;
                    }
                    return false;
                  };
                  LinkedList.prototype.insertBefore = function (node, refNode) {
                    if (!node) return;
                    node.next = refNode;
                    if (refNode != null) {
                      node.prev = refNode.prev;
                      if (refNode.prev != null) {
                        refNode.prev.next = node;
                      }
                      refNode.prev = node;
                      if (refNode === this.head) {
                        this.head = node;
                      }
                    } else if (this.tail != null) {
                      this.tail.next = node;
                      node.prev = this.tail;
                      this.tail = node;
                    } else {
                      node.prev = null;
                      this.head = this.tail = node;
                    }
                    this.length += 1;
                  };
                  LinkedList.prototype.offset = function (target) {
                    var index = 0,
                      cur = this.head;
                    while (cur != null) {
                      if (cur === target) return index;
                      index += cur.length();
                      cur = cur.next;
                    }
                    return -1;
                  };
                  LinkedList.prototype.remove = function (node) {
                    if (!this.contains(node)) return;
                    if (node.prev != null) node.prev.next = node.next;
                    if (node.next != null) node.next.prev = node.prev;
                    if (node === this.head) this.head = node.next;
                    if (node === this.tail) this.tail = node.prev;
                    this.length -= 1;
                  };
                  LinkedList.prototype.iterator = function (curNode) {
                    if (curNode === void 0) {
                      curNode = this.head;
                    }
                    // TODO use yield when we can
                    return function () {
                      var ret = curNode;
                      if (curNode != null) curNode = curNode.next;
                      return ret;
                    };
                  };
                  LinkedList.prototype.find = function (index, inclusive) {
                    if (inclusive === void 0) {
                      inclusive = false;
                    }
                    var cur,
                      next = this.iterator();
                    while (cur = next()) {
                      var length = cur.length();
                      if (index < length || inclusive && index === length && (cur.next == null || cur.next.length() !== 0)) {
                        return [cur, index];
                      }
                      index -= length;
                    }
                    return [null, 0];
                  };
                  LinkedList.prototype.forEach = function (callback) {
                    var cur,
                      next = this.iterator();
                    while (cur = next()) {
                      callback(cur);
                    }
                  };
                  LinkedList.prototype.forEachAt = function (index, length, callback) {
                    if (length <= 0) return;
                    var _a = this.find(index),
                      startNode = _a[0],
                      offset = _a[1];
                    var cur,
                      curIndex = index - offset,
                      next = this.iterator(startNode);
                    while ((cur = next()) && curIndex < index + length) {
                      var curLength = cur.length();
                      if (index > curIndex) {
                        callback(cur, index - curIndex, Math.min(length, curIndex + curLength - index));
                      } else {
                        callback(cur, 0, Math.min(curLength, index + length - curIndex));
                      }
                      curIndex += curLength;
                    }
                  };
                  LinkedList.prototype.map = function (callback) {
                    return this.reduce(function (memo, cur) {
                      memo.push(callback(cur));
                      return memo;
                    }, []);
                  };
                  LinkedList.prototype.reduce = function (callback, memo) {
                    var cur,
                      next = this.iterator();
                    while (cur = next()) {
                      memo = callback(memo, cur);
                    }
                    return memo;
                  };
                  return LinkedList;
                }();
                exports.default = LinkedList;

                /***/
              }, /* 45 */
              /***/function (module, exports, __webpack_require__) {
                var __extends = this && this.__extends || function () {
                  var extendStatics = Object.setPrototypeOf || {
                    __proto__: []
                  } instanceof Array && function (d, b) {
                    d.__proto__ = b;
                  } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                  };
                  return function (d, b) {
                    extendStatics(d, b);
                    function __() {
                      this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                  };
                }();
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var container_1 = __webpack_require__(17);
                var Registry = __webpack_require__(1);
                var OBSERVER_CONFIG = {
                  attributes: true,
                  characterData: true,
                  characterDataOldValue: true,
                  childList: true,
                  subtree: true
                };
                var MAX_OPTIMIZE_ITERATIONS = 100;
                var ScrollBlot = /** @class */function (_super) {
                  __extends(ScrollBlot, _super);
                  function ScrollBlot(node) {
                    var _this = _super.call(this, node) || this;
                    _this.scroll = _this;
                    _this.observer = new MutationObserver(function (mutations) {
                      _this.update(mutations);
                    });
                    _this.observer.observe(_this.domNode, OBSERVER_CONFIG);
                    _this.attach();
                    return _this;
                  }
                  ScrollBlot.prototype.detach = function () {
                    _super.prototype.detach.call(this);
                    this.observer.disconnect();
                  };
                  ScrollBlot.prototype.deleteAt = function (index, length) {
                    this.update();
                    if (index === 0 && length === this.length()) {
                      this.children.forEach(function (child) {
                        child.remove();
                      });
                    } else {
                      _super.prototype.deleteAt.call(this, index, length);
                    }
                  };
                  ScrollBlot.prototype.formatAt = function (index, length, name, value) {
                    this.update();
                    _super.prototype.formatAt.call(this, index, length, name, value);
                  };
                  ScrollBlot.prototype.insertAt = function (index, value, def) {
                    this.update();
                    _super.prototype.insertAt.call(this, index, value, def);
                  };
                  ScrollBlot.prototype.optimize = function (mutations, context) {
                    var _this = this;
                    if (mutations === void 0) {
                      mutations = [];
                    }
                    if (context === void 0) {
                      context = {};
                    }
                    _super.prototype.optimize.call(this, context);
                    // We must modify mutations directly, cannot make copy and then modify
                    var records = [].slice.call(this.observer.takeRecords());
                    // Array.push currently seems to be implemented by a non-tail recursive function
                    // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());
                    while (records.length > 0) mutations.push(records.pop());
                    // TODO use WeakMap
                    var mark = function (blot, markParent) {
                      if (markParent === void 0) {
                        markParent = true;
                      }
                      if (blot == null || blot === _this) return;
                      if (blot.domNode.parentNode == null) return;
                      // @ts-ignore
                      if (blot.domNode[Registry.DATA_KEY].mutations == null) {
                        // @ts-ignore
                        blot.domNode[Registry.DATA_KEY].mutations = [];
                      }
                      if (markParent) mark(blot.parent);
                    };
                    var optimize = function (blot) {
                      // Post-order traversal
                      if (
                      // @ts-ignore
                      blot.domNode[Registry.DATA_KEY] == null ||
                      // @ts-ignore
                      blot.domNode[Registry.DATA_KEY].mutations == null) {
                        return;
                      }
                      if (blot instanceof container_1.default) {
                        blot.children.forEach(optimize);
                      }
                      blot.optimize(context);
                    };
                    var remaining = mutations;
                    for (var i = 0; remaining.length > 0; i += 1) {
                      if (i >= MAX_OPTIMIZE_ITERATIONS) {
                        throw new Error('[Parchment] Maximum optimize iterations reached');
                      }
                      remaining.forEach(function (mutation) {
                        var blot = Registry.find(mutation.target, true);
                        if (blot == null) return;
                        if (blot.domNode === mutation.target) {
                          if (mutation.type === 'childList') {
                            mark(Registry.find(mutation.previousSibling, false));
                            [].forEach.call(mutation.addedNodes, function (node) {
                              var child = Registry.find(node, false);
                              mark(child, false);
                              if (child instanceof container_1.default) {
                                child.children.forEach(function (grandChild) {
                                  mark(grandChild, false);
                                });
                              }
                            });
                          } else if (mutation.type === 'attributes') {
                            mark(blot.prev);
                          }
                        }
                        mark(blot);
                      });
                      this.children.forEach(optimize);
                      remaining = [].slice.call(this.observer.takeRecords());
                      records = remaining.slice();
                      while (records.length > 0) mutations.push(records.pop());
                    }
                  };
                  ScrollBlot.prototype.update = function (mutations, context) {
                    var _this = this;
                    if (context === void 0) {
                      context = {};
                    }
                    mutations = mutations || this.observer.takeRecords();
                    // TODO use WeakMap
                    mutations.map(function (mutation) {
                      var blot = Registry.find(mutation.target, true);
                      if (blot == null) return null;
                      // @ts-ignore
                      if (blot.domNode[Registry.DATA_KEY].mutations == null) {
                        // @ts-ignore
                        blot.domNode[Registry.DATA_KEY].mutations = [mutation];
                        return blot;
                      } else {
                        // @ts-ignore
                        blot.domNode[Registry.DATA_KEY].mutations.push(mutation);
                        return null;
                      }
                    }).forEach(function (blot) {
                      if (blot == null || blot === _this ||
                      //@ts-ignore
                      blot.domNode[Registry.DATA_KEY] == null) return;
                      // @ts-ignore
                      blot.update(blot.domNode[Registry.DATA_KEY].mutations || [], context);
                    });
                    // @ts-ignore
                    if (this.domNode[Registry.DATA_KEY].mutations != null) {
                      // @ts-ignore
                      _super.prototype.update.call(this, this.domNode[Registry.DATA_KEY].mutations, context);
                    }
                    this.optimize(mutations, context);
                  };
                  ScrollBlot.blotName = 'scroll';
                  ScrollBlot.defaultChild = 'block';
                  ScrollBlot.scope = Registry.Scope.BLOCK_BLOT;
                  ScrollBlot.tagName = 'DIV';
                  return ScrollBlot;
                }(container_1.default);
                exports.default = ScrollBlot;

                /***/
              }, /* 46 */
              /***/function (module, exports, __webpack_require__) {
                var __extends = this && this.__extends || function () {
                  var extendStatics = Object.setPrototypeOf || {
                    __proto__: []
                  } instanceof Array && function (d, b) {
                    d.__proto__ = b;
                  } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                  };
                  return function (d, b) {
                    extendStatics(d, b);
                    function __() {
                      this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                  };
                }();
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var format_1 = __webpack_require__(18);
                var Registry = __webpack_require__(1);
                // Shallow object comparison
                function isEqual(obj1, obj2) {
                  if (Object.keys(obj1).length !== Object.keys(obj2).length) return false;
                  // @ts-ignore
                  for (var prop in obj1) {
                    // @ts-ignore
                    if (obj1[prop] !== obj2[prop]) return false;
                  }
                  return true;
                }
                var InlineBlot = /** @class */function (_super) {
                  __extends(InlineBlot, _super);
                  function InlineBlot() {
                    return _super !== null && _super.apply(this, arguments) || this;
                  }
                  InlineBlot.formats = function (domNode) {
                    if (domNode.tagName === InlineBlot.tagName) return undefined;
                    return _super.formats.call(this, domNode);
                  };
                  InlineBlot.prototype.format = function (name, value) {
                    var _this = this;
                    if (name === this.statics.blotName && !value) {
                      this.children.forEach(function (child) {
                        if (!(child instanceof format_1.default)) {
                          child = child.wrap(InlineBlot.blotName, true);
                        }
                        _this.attributes.copy(child);
                      });
                      this.unwrap();
                    } else {
                      _super.prototype.format.call(this, name, value);
                    }
                  };
                  InlineBlot.prototype.formatAt = function (index, length, name, value) {
                    if (this.formats()[name] != null || Registry.query(name, Registry.Scope.ATTRIBUTE)) {
                      var blot = this.isolate(index, length);
                      blot.format(name, value);
                    } else {
                      _super.prototype.formatAt.call(this, index, length, name, value);
                    }
                  };
                  InlineBlot.prototype.optimize = function (context) {
                    _super.prototype.optimize.call(this, context);
                    var formats = this.formats();
                    if (Object.keys(formats).length === 0) {
                      return this.unwrap(); // unformatted span
                    }

                    var next = this.next;
                    if (next instanceof InlineBlot && next.prev === this && isEqual(formats, next.formats())) {
                      next.moveChildren(this);
                      next.remove();
                    }
                  };
                  InlineBlot.blotName = 'inline';
                  InlineBlot.scope = Registry.Scope.INLINE_BLOT;
                  InlineBlot.tagName = 'SPAN';
                  return InlineBlot;
                }(format_1.default);
                exports.default = InlineBlot;

                /***/
              }, /* 47 */
              /***/function (module, exports, __webpack_require__) {
                var __extends = this && this.__extends || function () {
                  var extendStatics = Object.setPrototypeOf || {
                    __proto__: []
                  } instanceof Array && function (d, b) {
                    d.__proto__ = b;
                  } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                  };
                  return function (d, b) {
                    extendStatics(d, b);
                    function __() {
                      this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                  };
                }();
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var format_1 = __webpack_require__(18);
                var Registry = __webpack_require__(1);
                var BlockBlot = /** @class */function (_super) {
                  __extends(BlockBlot, _super);
                  function BlockBlot() {
                    return _super !== null && _super.apply(this, arguments) || this;
                  }
                  BlockBlot.formats = function (domNode) {
                    var tagName = Registry.query(BlockBlot.blotName).tagName;
                    if (domNode.tagName === tagName) return undefined;
                    return _super.formats.call(this, domNode);
                  };
                  BlockBlot.prototype.format = function (name, value) {
                    if (Registry.query(name, Registry.Scope.BLOCK) == null) {
                      return;
                    } else if (name === this.statics.blotName && !value) {
                      this.replaceWith(BlockBlot.blotName);
                    } else {
                      _super.prototype.format.call(this, name, value);
                    }
                  };
                  BlockBlot.prototype.formatAt = function (index, length, name, value) {
                    if (Registry.query(name, Registry.Scope.BLOCK) != null) {
                      this.format(name, value);
                    } else {
                      _super.prototype.formatAt.call(this, index, length, name, value);
                    }
                  };
                  BlockBlot.prototype.insertAt = function (index, value, def) {
                    if (def == null || Registry.query(value, Registry.Scope.INLINE) != null) {
                      // Insert text or inline
                      _super.prototype.insertAt.call(this, index, value, def);
                    } else {
                      var after = this.split(index);
                      var blot = Registry.create(value, def);
                      after.parent.insertBefore(blot, after);
                    }
                  };
                  BlockBlot.prototype.update = function (mutations, context) {
                    if (navigator.userAgent.match(/Trident/)) {
                      this.build();
                    } else {
                      _super.prototype.update.call(this, mutations, context);
                    }
                  };
                  BlockBlot.blotName = 'block';
                  BlockBlot.scope = Registry.Scope.BLOCK_BLOT;
                  BlockBlot.tagName = 'P';
                  return BlockBlot;
                }(format_1.default);
                exports.default = BlockBlot;

                /***/
              }, /* 48 */
              /***/function (module, exports, __webpack_require__) {
                var __extends = this && this.__extends || function () {
                  var extendStatics = Object.setPrototypeOf || {
                    __proto__: []
                  } instanceof Array && function (d, b) {
                    d.__proto__ = b;
                  } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                  };
                  return function (d, b) {
                    extendStatics(d, b);
                    function __() {
                      this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                  };
                }();
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var leaf_1 = __webpack_require__(19);
                var EmbedBlot = /** @class */function (_super) {
                  __extends(EmbedBlot, _super);
                  function EmbedBlot() {
                    return _super !== null && _super.apply(this, arguments) || this;
                  }
                  EmbedBlot.formats = function (domNode) {
                    return undefined;
                  };
                  EmbedBlot.prototype.format = function (name, value) {
                    // super.formatAt wraps, which is what we want in general,
                    // but this allows subclasses to overwrite for formats
                    // that just apply to particular embeds
                    _super.prototype.formatAt.call(this, 0, this.length(), name, value);
                  };
                  EmbedBlot.prototype.formatAt = function (index, length, name, value) {
                    if (index === 0 && length === this.length()) {
                      this.format(name, value);
                    } else {
                      _super.prototype.formatAt.call(this, index, length, name, value);
                    }
                  };
                  EmbedBlot.prototype.formats = function () {
                    return this.statics.formats(this.domNode);
                  };
                  return EmbedBlot;
                }(leaf_1.default);
                exports.default = EmbedBlot;

                /***/
              }, /* 49 */
              /***/function (module, exports, __webpack_require__) {
                var __extends = this && this.__extends || function () {
                  var extendStatics = Object.setPrototypeOf || {
                    __proto__: []
                  } instanceof Array && function (d, b) {
                    d.__proto__ = b;
                  } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                  };
                  return function (d, b) {
                    extendStatics(d, b);
                    function __() {
                      this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                  };
                }();
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var leaf_1 = __webpack_require__(19);
                var Registry = __webpack_require__(1);
                var TextBlot = /** @class */function (_super) {
                  __extends(TextBlot, _super);
                  function TextBlot(node) {
                    var _this = _super.call(this, node) || this;
                    _this.text = _this.statics.value(_this.domNode);
                    return _this;
                  }
                  TextBlot.create = function (value) {
                    return document.createTextNode(value);
                  };
                  TextBlot.value = function (domNode) {
                    var text = domNode.data;
                    // @ts-ignore
                    if (text['normalize']) text = text['normalize']();
                    return text;
                  };
                  TextBlot.prototype.deleteAt = function (index, length) {
                    this.domNode.data = this.text = this.text.slice(0, index) + this.text.slice(index + length);
                  };
                  TextBlot.prototype.index = function (node, offset) {
                    if (this.domNode === node) {
                      return offset;
                    }
                    return -1;
                  };
                  TextBlot.prototype.insertAt = function (index, value, def) {
                    if (def == null) {
                      this.text = this.text.slice(0, index) + value + this.text.slice(index);
                      this.domNode.data = this.text;
                    } else {
                      _super.prototype.insertAt.call(this, index, value, def);
                    }
                  };
                  TextBlot.prototype.length = function () {
                    return this.text.length;
                  };
                  TextBlot.prototype.optimize = function (context) {
                    _super.prototype.optimize.call(this, context);
                    this.text = this.statics.value(this.domNode);
                    if (this.text.length === 0) {
                      this.remove();
                    } else if (this.next instanceof TextBlot && this.next.prev === this) {
                      this.insertAt(this.length(), this.next.value());
                      this.next.remove();
                    }
                  };
                  TextBlot.prototype.position = function (index, inclusive) {
                    return [this.domNode, index];
                  };
                  TextBlot.prototype.split = function (index, force) {
                    if (force === void 0) {
                      force = false;
                    }
                    if (!force) {
                      if (index === 0) return this;
                      if (index === this.length()) return this.next;
                    }
                    var after = Registry.create(this.domNode.splitText(index));
                    this.parent.insertBefore(after, this.next);
                    this.text = this.statics.value(this.domNode);
                    return after;
                  };
                  TextBlot.prototype.update = function (mutations, context) {
                    var _this = this;
                    if (mutations.some(function (mutation) {
                      return mutation.type === 'characterData' && mutation.target === _this.domNode;
                    })) {
                      this.text = this.statics.value(this.domNode);
                    }
                  };
                  TextBlot.prototype.value = function () {
                    return this.text;
                  };
                  TextBlot.blotName = 'text';
                  TextBlot.scope = Registry.Scope.INLINE_BLOT;
                  return TextBlot;
                }(leaf_1.default);
                exports.default = TextBlot;

                /***/
              }, /* 50 */
              /***/function (module, exports, __webpack_require__) {
                var elem = document.createElement('div');
                elem.classList.toggle('test-class', false);
                if (elem.classList.contains('test-class')) {
                  var _toggle = DOMTokenList.prototype.toggle;
                  DOMTokenList.prototype.toggle = function (token, force) {
                    if (arguments.length > 1 && !this.contains(token) === !force) {
                      return force;
                    } else {
                      return _toggle.call(this, token);
                    }
                  };
                }
                if (!String.prototype.startsWith) {
                  String.prototype.startsWith = function (searchString, position) {
                    position = position || 0;
                    return this.substr(position, searchString.length) === searchString;
                  };
                }
                if (!String.prototype.endsWith) {
                  String.prototype.endsWith = function (searchString, position) {
                    var subjectString = this.toString();
                    if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
                      position = subjectString.length;
                    }
                    position -= searchString.length;
                    var lastIndex = subjectString.indexOf(searchString, position);
                    return lastIndex !== -1 && lastIndex === position;
                  };
                }
                if (!Array.prototype.find) {
                  Object.defineProperty(Array.prototype, "find", {
                    value: function value(predicate) {
                      if (this === null) {
                        throw new TypeError('Array.prototype.find called on null or undefined');
                      }
                      if (typeof predicate !== 'function') {
                        throw new TypeError('predicate must be a function');
                      }
                      var list = Object(this);
                      var length = list.length >>> 0;
                      var thisArg = arguments[1];
                      var value;
                      for (var i = 0; i < length; i++) {
                        value = list[i];
                        if (predicate.call(thisArg, value, i, list)) {
                          return value;
                        }
                      }
                      return undefined;
                    }
                  });
                }
                document.addEventListener("DOMContentLoaded", function () {
                  // Disable resizing in Firefox
                  document.execCommand("enableObjectResizing", false, false);
                  // Disable automatic linkifying in IE11
                  document.execCommand("autoUrlDetect", false, false);
                });

                /***/
              }, /* 51 */
              /***/function (module, exports) {
                /**
                 * This library modifies the diff-patch-match library by Neil Fraser
                 * by removing the patch and match functionality and certain advanced
                 * options in the diff function. The original license is as follows:
                 *
                 * ===
                 *
                 * Diff Match and Patch
                 *
                 * Copyright 2006 Google Inc.
                 * http://code.google.com/p/google-diff-match-patch/
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *   http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

                /**
                 * The data structure representing a diff is an array of tuples:
                 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
                 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
                 */
                var DIFF_DELETE = -1;
                var DIFF_INSERT = 1;
                var DIFF_EQUAL = 0;

                /**
                 * Find the differences between two texts.  Simplifies the problem by stripping
                 * any common prefix or suffix off the texts before diffing.
                 * @param {string} text1 Old string to be diffed.
                 * @param {string} text2 New string to be diffed.
                 * @param {Int} cursor_pos Expected edit position in text1 (optional)
                 * @return {Array} Array of diff tuples.
                 */
                function diff_main(text1, text2, cursor_pos) {
                  // Check for equality (speedup).
                  if (text1 == text2) {
                    if (text1) {
                      return [[DIFF_EQUAL, text1]];
                    }
                    return [];
                  }

                  // Check cursor_pos within bounds
                  if (cursor_pos < 0 || text1.length < cursor_pos) {
                    cursor_pos = null;
                  }

                  // Trim off common prefix (speedup).
                  var commonlength = diff_commonPrefix(text1, text2);
                  var commonprefix = text1.substring(0, commonlength);
                  text1 = text1.substring(commonlength);
                  text2 = text2.substring(commonlength);

                  // Trim off common suffix (speedup).
                  commonlength = diff_commonSuffix(text1, text2);
                  var commonsuffix = text1.substring(text1.length - commonlength);
                  text1 = text1.substring(0, text1.length - commonlength);
                  text2 = text2.substring(0, text2.length - commonlength);

                  // Compute the diff on the middle block.
                  var diffs = diff_compute_(text1, text2);

                  // Restore the prefix and suffix.
                  if (commonprefix) {
                    diffs.unshift([DIFF_EQUAL, commonprefix]);
                  }
                  if (commonsuffix) {
                    diffs.push([DIFF_EQUAL, commonsuffix]);
                  }
                  diff_cleanupMerge(diffs);
                  if (cursor_pos != null) {
                    diffs = fix_cursor(diffs, cursor_pos);
                  }
                  diffs = fix_emoji(diffs);
                  return diffs;
                }

                /**
                 * Find the differences between two texts.  Assumes that the texts do not
                 * have any common prefix or suffix.
                 * @param {string} text1 Old string to be diffed.
                 * @param {string} text2 New string to be diffed.
                 * @return {Array} Array of diff tuples.
                 */
                function diff_compute_(text1, text2) {
                  var diffs;
                  if (!text1) {
                    // Just add some text (speedup).
                    return [[DIFF_INSERT, text2]];
                  }
                  if (!text2) {
                    // Just delete some text (speedup).
                    return [[DIFF_DELETE, text1]];
                  }
                  var longtext = text1.length > text2.length ? text1 : text2;
                  var shorttext = text1.length > text2.length ? text2 : text1;
                  var i = longtext.indexOf(shorttext);
                  if (i != -1) {
                    // Shorter text is inside the longer text (speedup).
                    diffs = [[DIFF_INSERT, longtext.substring(0, i)], [DIFF_EQUAL, shorttext], [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
                    // Swap insertions for deletions if diff is reversed.
                    if (text1.length > text2.length) {
                      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
                    }
                    return diffs;
                  }
                  if (shorttext.length == 1) {
                    // Single character string.
                    // After the previous speedup, the character can't be an equality.
                    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
                  }

                  // Check to see if the problem can be split in two.
                  var hm = diff_halfMatch_(text1, text2);
                  if (hm) {
                    // A half-match was found, sort out the return data.
                    var text1_a = hm[0];
                    var text1_b = hm[1];
                    var text2_a = hm[2];
                    var text2_b = hm[3];
                    var mid_common = hm[4];
                    // Send both pairs off for separate processing.
                    var diffs_a = diff_main(text1_a, text2_a);
                    var diffs_b = diff_main(text1_b, text2_b);
                    // Merge the results.
                    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
                  }
                  return diff_bisect_(text1, text2);
                }

                /**
                 * Find the 'middle snake' of a diff, split the problem in two
                 * and return the recursively constructed diff.
                 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
                 * @param {string} text1 Old string to be diffed.
                 * @param {string} text2 New string to be diffed.
                 * @return {Array} Array of diff tuples.
                 * @private
                 */
                function diff_bisect_(text1, text2) {
                  // Cache the text lengths to prevent multiple calls.
                  var text1_length = text1.length;
                  var text2_length = text2.length;
                  var max_d = Math.ceil((text1_length + text2_length) / 2);
                  var v_offset = max_d;
                  var v_length = 2 * max_d;
                  var v1 = new Array(v_length);
                  var v2 = new Array(v_length);
                  // Setting all elements to -1 is faster in Chrome & Firefox than mixing
                  // integers and undefined.
                  for (var x = 0; x < v_length; x++) {
                    v1[x] = -1;
                    v2[x] = -1;
                  }
                  v1[v_offset + 1] = 0;
                  v2[v_offset + 1] = 0;
                  var delta = text1_length - text2_length;
                  // If the total number of characters is odd, then the front path will collide
                  // with the reverse path.
                  var front = delta % 2 != 0;
                  // Offsets for start and end of k loop.
                  // Prevents mapping of space beyond the grid.
                  var k1start = 0;
                  var k1end = 0;
                  var k2start = 0;
                  var k2end = 0;
                  for (var d = 0; d < max_d; d++) {
                    // Walk the front path one step.
                    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
                      var k1_offset = v_offset + k1;
                      var x1;
                      if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
                        x1 = v1[k1_offset + 1];
                      } else {
                        x1 = v1[k1_offset - 1] + 1;
                      }
                      var y1 = x1 - k1;
                      while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)) {
                        x1++;
                        y1++;
                      }
                      v1[k1_offset] = x1;
                      if (x1 > text1_length) {
                        // Ran off the right of the graph.
                        k1end += 2;
                      } else if (y1 > text2_length) {
                        // Ran off the bottom of the graph.
                        k1start += 2;
                      } else if (front) {
                        var k2_offset = v_offset + delta - k1;
                        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
                          // Mirror x2 onto top-left coordinate system.
                          var x2 = text1_length - v2[k2_offset];
                          if (x1 >= x2) {
                            // Overlap detected.
                            return diff_bisectSplit_(text1, text2, x1, y1);
                          }
                        }
                      }
                    }

                    // Walk the reverse path one step.
                    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
                      var k2_offset = v_offset + k2;
                      var x2;
                      if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
                        x2 = v2[k2_offset + 1];
                      } else {
                        x2 = v2[k2_offset - 1] + 1;
                      }
                      var y2 = x2 - k2;
                      while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) == text2.charAt(text2_length - y2 - 1)) {
                        x2++;
                        y2++;
                      }
                      v2[k2_offset] = x2;
                      if (x2 > text1_length) {
                        // Ran off the left of the graph.
                        k2end += 2;
                      } else if (y2 > text2_length) {
                        // Ran off the top of the graph.
                        k2start += 2;
                      } else if (!front) {
                        var k1_offset = v_offset + delta - k2;
                        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
                          var x1 = v1[k1_offset];
                          var y1 = v_offset + x1 - k1_offset;
                          // Mirror x2 onto top-left coordinate system.
                          x2 = text1_length - x2;
                          if (x1 >= x2) {
                            // Overlap detected.
                            return diff_bisectSplit_(text1, text2, x1, y1);
                          }
                        }
                      }
                    }
                  }
                  // Diff took too long and hit the deadline or
                  // number of diffs equals number of characters, no commonality at all.
                  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
                }

                /**
                 * Given the location of the 'middle snake', split the diff in two parts
                 * and recurse.
                 * @param {string} text1 Old string to be diffed.
                 * @param {string} text2 New string to be diffed.
                 * @param {number} x Index of split point in text1.
                 * @param {number} y Index of split point in text2.
                 * @return {Array} Array of diff tuples.
                 */
                function diff_bisectSplit_(text1, text2, x, y) {
                  var text1a = text1.substring(0, x);
                  var text2a = text2.substring(0, y);
                  var text1b = text1.substring(x);
                  var text2b = text2.substring(y);

                  // Compute both diffs serially.
                  var diffs = diff_main(text1a, text2a);
                  var diffsb = diff_main(text1b, text2b);
                  return diffs.concat(diffsb);
                }

                /**
                 * Determine the common prefix of two strings.
                 * @param {string} text1 First string.
                 * @param {string} text2 Second string.
                 * @return {number} The number of characters common to the start of each
                 *     string.
                 */
                function diff_commonPrefix(text1, text2) {
                  // Quick check for common null cases.
                  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
                    return 0;
                  }
                  // Binary search.
                  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
                  var pointermin = 0;
                  var pointermax = Math.min(text1.length, text2.length);
                  var pointermid = pointermax;
                  var pointerstart = 0;
                  while (pointermin < pointermid) {
                    if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
                      pointermin = pointermid;
                      pointerstart = pointermin;
                    } else {
                      pointermax = pointermid;
                    }
                    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
                  }
                  return pointermid;
                }

                /**
                 * Determine the common suffix of two strings.
                 * @param {string} text1 First string.
                 * @param {string} text2 Second string.
                 * @return {number} The number of characters common to the end of each string.
                 */
                function diff_commonSuffix(text1, text2) {
                  // Quick check for common null cases.
                  if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
                    return 0;
                  }
                  // Binary search.
                  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
                  var pointermin = 0;
                  var pointermax = Math.min(text1.length, text2.length);
                  var pointermid = pointermax;
                  var pointerend = 0;
                  while (pointermin < pointermid) {
                    if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
                      pointermin = pointermid;
                      pointerend = pointermin;
                    } else {
                      pointermax = pointermid;
                    }
                    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
                  }
                  return pointermid;
                }

                /**
                 * Do the two texts share a substring which is at least half the length of the
                 * longer text?
                 * This speedup can produce non-minimal diffs.
                 * @param {string} text1 First string.
                 * @param {string} text2 Second string.
                 * @return {Array.<string>} Five element Array, containing the prefix of
                 *     text1, the suffix of text1, the prefix of text2, the suffix of
                 *     text2 and the common middle.  Or null if there was no match.
                 */
                function diff_halfMatch_(text1, text2) {
                  var longtext = text1.length > text2.length ? text1 : text2;
                  var shorttext = text1.length > text2.length ? text2 : text1;
                  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
                    return null; // Pointless.
                  }

                  /**
                   * Does a substring of shorttext exist within longtext such that the substring
                   * is at least half the length of longtext?
                   * Closure, but does not reference any external variables.
                   * @param {string} longtext Longer string.
                   * @param {string} shorttext Shorter string.
                   * @param {number} i Start index of quarter length substring within longtext.
                   * @return {Array.<string>} Five element Array, containing the prefix of
                   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
                   *     of shorttext and the common middle.  Or null if there was no match.
                   * @private
                   */
                  function diff_halfMatchI_(longtext, shorttext, i) {
                    // Start with a 1/4 length substring at position i as a seed.
                    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
                    var j = -1;
                    var best_common = '';
                    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
                    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
                      var prefixLength = diff_commonPrefix(longtext.substring(i), shorttext.substring(j));
                      var suffixLength = diff_commonSuffix(longtext.substring(0, i), shorttext.substring(0, j));
                      if (best_common.length < suffixLength + prefixLength) {
                        best_common = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);
                        best_longtext_a = longtext.substring(0, i - suffixLength);
                        best_longtext_b = longtext.substring(i + prefixLength);
                        best_shorttext_a = shorttext.substring(0, j - suffixLength);
                        best_shorttext_b = shorttext.substring(j + prefixLength);
                      }
                    }
                    if (best_common.length * 2 >= longtext.length) {
                      return [best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b, best_common];
                    } else {
                      return null;
                    }
                  }

                  // First check if the second quarter is the seed for a half-match.
                  var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
                  // Check again based on the third quarter.
                  var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
                  var hm;
                  if (!hm1 && !hm2) {
                    return null;
                  } else if (!hm2) {
                    hm = hm1;
                  } else if (!hm1) {
                    hm = hm2;
                  } else {
                    // Both matched.  Select the longest.
                    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
                  }

                  // A half-match was found, sort out the return data.
                  var text1_a, text1_b, text2_a, text2_b;
                  if (text1.length > text2.length) {
                    text1_a = hm[0];
                    text1_b = hm[1];
                    text2_a = hm[2];
                    text2_b = hm[3];
                  } else {
                    text2_a = hm[0];
                    text2_b = hm[1];
                    text1_a = hm[2];
                    text1_b = hm[3];
                  }
                  var mid_common = hm[4];
                  return [text1_a, text1_b, text2_a, text2_b, mid_common];
                }

                /**
                 * Reorder and merge like edit sections.  Merge equalities.
                 * Any edit section can move as long as it doesn't cross an equality.
                 * @param {Array} diffs Array of diff tuples.
                 */
                function diff_cleanupMerge(diffs) {
                  diffs.push([DIFF_EQUAL, '']); // Add a dummy entry at the end.
                  var pointer = 0;
                  var count_delete = 0;
                  var count_insert = 0;
                  var text_delete = '';
                  var text_insert = '';
                  var commonlength;
                  while (pointer < diffs.length) {
                    switch (diffs[pointer][0]) {
                      case DIFF_INSERT:
                        count_insert++;
                        text_insert += diffs[pointer][1];
                        pointer++;
                        break;
                      case DIFF_DELETE:
                        count_delete++;
                        text_delete += diffs[pointer][1];
                        pointer++;
                        break;
                      case DIFF_EQUAL:
                        // Upon reaching an equality, check for prior redundancies.
                        if (count_delete + count_insert > 1) {
                          if (count_delete !== 0 && count_insert !== 0) {
                            // Factor out any common prefixies.
                            commonlength = diff_commonPrefix(text_insert, text_delete);
                            if (commonlength !== 0) {
                              if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {
                                diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
                              } else {
                                diffs.splice(0, 0, [DIFF_EQUAL, text_insert.substring(0, commonlength)]);
                                pointer++;
                              }
                              text_insert = text_insert.substring(commonlength);
                              text_delete = text_delete.substring(commonlength);
                            }
                            // Factor out any common suffixies.
                            commonlength = diff_commonSuffix(text_insert, text_delete);
                            if (commonlength !== 0) {
                              diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                              text_insert = text_insert.substring(0, text_insert.length - commonlength);
                              text_delete = text_delete.substring(0, text_delete.length - commonlength);
                            }
                          }
                          // Delete the offending records and add the merged ones.
                          if (count_delete === 0) {
                            diffs.splice(pointer - count_insert, count_delete + count_insert, [DIFF_INSERT, text_insert]);
                          } else if (count_insert === 0) {
                            diffs.splice(pointer - count_delete, count_delete + count_insert, [DIFF_DELETE, text_delete]);
                          } else {
                            diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert, [DIFF_DELETE, text_delete], [DIFF_INSERT, text_insert]);
                          }
                          pointer = pointer - count_delete - count_insert + (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
                        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
                          // Merge this equality with the previous one.
                          diffs[pointer - 1][1] += diffs[pointer][1];
                          diffs.splice(pointer, 1);
                        } else {
                          pointer++;
                        }
                        count_insert = 0;
                        count_delete = 0;
                        text_delete = '';
                        text_insert = '';
                        break;
                    }
                  }
                  if (diffs[diffs.length - 1][1] === '') {
                    diffs.pop(); // Remove the dummy entry at the end.
                  }

                  // Second pass: look for single edits surrounded on both sides by equalities
                  // which can be shifted sideways to eliminate an equality.
                  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
                  var changes = false;
                  pointer = 1;
                  // Intentionally ignore the first and last element (don't need checking).
                  while (pointer < diffs.length - 1) {
                    if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
                      // This is a single edit surrounded by equalities.
                      if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
                        // Shift the edit over the previous equality.
                        diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
                        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
                        diffs.splice(pointer - 1, 1);
                        changes = true;
                      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
                        // Shift the edit over the next equality.
                        diffs[pointer - 1][1] += diffs[pointer + 1][1];
                        diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
                        diffs.splice(pointer + 1, 1);
                        changes = true;
                      }
                    }
                    pointer++;
                  }
                  // If shifts were made, the diff needs reordering and another shift sweep.
                  if (changes) {
                    diff_cleanupMerge(diffs);
                  }
                }
                var diff = diff_main;
                diff.INSERT = DIFF_INSERT;
                diff.DELETE = DIFF_DELETE;
                diff.EQUAL = DIFF_EQUAL;
                module.exports = diff;

                /*
                 * Modify a diff such that the cursor position points to the start of a change:
                 * E.g.
                 *   cursor_normalize_diff([[DIFF_EQUAL, 'abc']], 1)
                 *     => [1, [[DIFF_EQUAL, 'a'], [DIFF_EQUAL, 'bc']]]
                 *   cursor_normalize_diff([[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xyz']], 2)
                 *     => [2, [[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xy'], [DIFF_DELETE, 'z']]]
                 *
                 * @param {Array} diffs Array of diff tuples
                 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
                 * @return {Array} A tuple [cursor location in the modified diff, modified diff]
                 */
                function cursor_normalize_diff(diffs, cursor_pos) {
                  if (cursor_pos === 0) {
                    return [DIFF_EQUAL, diffs];
                  }
                  for (var current_pos = 0, i = 0; i < diffs.length; i++) {
                    var d = diffs[i];
                    if (d[0] === DIFF_DELETE || d[0] === DIFF_EQUAL) {
                      var next_pos = current_pos + d[1].length;
                      if (cursor_pos === next_pos) {
                        return [i + 1, diffs];
                      } else if (cursor_pos < next_pos) {
                        // copy to prevent side effects
                        diffs = diffs.slice();
                        // split d into two diff changes
                        var split_pos = cursor_pos - current_pos;
                        var d_left = [d[0], d[1].slice(0, split_pos)];
                        var d_right = [d[0], d[1].slice(split_pos)];
                        diffs.splice(i, 1, d_left, d_right);
                        return [i + 1, diffs];
                      } else {
                        current_pos = next_pos;
                      }
                    }
                  }
                  throw new Error('cursor_pos is out of bounds!');
                }

                /*
                 * Modify a diff such that the edit position is "shifted" to the proposed edit location (cursor_position).
                 *
                 * Case 1)
                 *   Check if a naive shift is possible:
                 *     [0, X], [ 1, Y] -> [ 1, Y], [0, X]    (if X + Y === Y + X)
                 *     [0, X], [-1, Y] -> [-1, Y], [0, X]    (if X + Y === Y + X) - holds same result
                 * Case 2)
                 *   Check if the following shifts are possible:
                 *     [0, 'pre'], [ 1, 'prefix'] -> [ 1, 'pre'], [0, 'pre'], [ 1, 'fix']
                 *     [0, 'pre'], [-1, 'prefix'] -> [-1, 'pre'], [0, 'pre'], [-1, 'fix']
                 *         ^            ^
                 *         d          d_next
                 *
                 * @param {Array} diffs Array of diff tuples
                 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
                 * @return {Array} Array of diff tuples
                 */
                function fix_cursor(diffs, cursor_pos) {
                  var norm = cursor_normalize_diff(diffs, cursor_pos);
                  var ndiffs = norm[1];
                  var cursor_pointer = norm[0];
                  var d = ndiffs[cursor_pointer];
                  var d_next = ndiffs[cursor_pointer + 1];
                  if (d == null) {
                    // Text was deleted from end of original string,
                    // cursor is now out of bounds in new string
                    return diffs;
                  } else if (d[0] !== DIFF_EQUAL) {
                    // A modification happened at the cursor location.
                    // This is the expected outcome, so we can return the original diff.
                    return diffs;
                  } else {
                    if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {
                      // Case 1)
                      // It is possible to perform a naive shift
                      ndiffs.splice(cursor_pointer, 2, d_next, d);
                      return merge_tuples(ndiffs, cursor_pointer, 2);
                    } else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {
                      // Case 2)
                      // d[1] is a prefix of d_next[1]
                      // We can assume that d_next[0] !== 0, since d[0] === 0
                      // Shift edit locations..
                      ndiffs.splice(cursor_pointer, 2, [d_next[0], d[1]], [0, d[1]]);
                      var suffix = d_next[1].slice(d[1].length);
                      if (suffix.length > 0) {
                        ndiffs.splice(cursor_pointer + 2, 0, [d_next[0], suffix]);
                      }
                      return merge_tuples(ndiffs, cursor_pointer, 3);
                    } else {
                      // Not possible to perform any modification
                      return diffs;
                    }
                  }
                }

                /*
                 * Check diff did not split surrogate pairs.
                 * Ex. [0, '\uD83D'], [-1, '\uDC36'], [1, '\uDC2F'] -> [-1, '\uD83D\uDC36'], [1, '\uD83D\uDC2F']
                 *     '\uD83D\uDC36' === '🐶', '\uD83D\uDC2F' === '🐯'
                 *
                 * @param {Array} diffs Array of diff tuples
                 * @return {Array} Array of diff tuples
                 */
                function fix_emoji(diffs) {
                  var compact = false;
                  var starts_with_pair_end = function (str) {
                    return str.charCodeAt(0) >= 0xDC00 && str.charCodeAt(0) <= 0xDFFF;
                  };
                  var ends_with_pair_start = function (str) {
                    return str.charCodeAt(str.length - 1) >= 0xD800 && str.charCodeAt(str.length - 1) <= 0xDBFF;
                  };
                  for (var i = 2; i < diffs.length; i += 1) {
                    if (diffs[i - 2][0] === DIFF_EQUAL && ends_with_pair_start(diffs[i - 2][1]) && diffs[i - 1][0] === DIFF_DELETE && starts_with_pair_end(diffs[i - 1][1]) && diffs[i][0] === DIFF_INSERT && starts_with_pair_end(diffs[i][1])) {
                      compact = true;
                      diffs[i - 1][1] = diffs[i - 2][1].slice(-1) + diffs[i - 1][1];
                      diffs[i][1] = diffs[i - 2][1].slice(-1) + diffs[i][1];
                      diffs[i - 2][1] = diffs[i - 2][1].slice(0, -1);
                    }
                  }
                  if (!compact) {
                    return diffs;
                  }
                  var fixed_diffs = [];
                  for (var i = 0; i < diffs.length; i += 1) {
                    if (diffs[i][1].length > 0) {
                      fixed_diffs.push(diffs[i]);
                    }
                  }
                  return fixed_diffs;
                }

                /*
                 * Try to merge tuples with their neigbors in a given range.
                 * E.g. [0, 'a'], [0, 'b'] -> [0, 'ab']
                 *
                 * @param {Array} diffs Array of diff tuples.
                 * @param {Int} start Position of the first element to merge (diffs[start] is also merged with diffs[start - 1]).
                 * @param {Int} length Number of consecutive elements to check.
                 * @return {Array} Array of merged diff tuples.
                 */
                function merge_tuples(diffs, start, length) {
                  // Check from (start-1) to (start+length).
                  for (var i = start + length - 1; i >= 0 && i >= start - 1; i--) {
                    if (i + 1 < diffs.length) {
                      var left_d = diffs[i];
                      var right_d = diffs[i + 1];
                      if (left_d[0] === right_d[1]) {
                        diffs.splice(i, 2, [left_d[0], left_d[1] + right_d[1]]);
                      }
                    }
                  }
                  return diffs;
                }

                /***/
              }, /* 52 */
              /***/function (module, exports) {
                exports = module.exports = typeof Object.keys === 'function' ? Object.keys : shim;
                exports.shim = shim;
                function shim(obj) {
                  var keys = [];
                  for (var key in obj) keys.push(key);
                  return keys;
                }

                /***/
              }, /* 53 */
              /***/function (module, exports) {
                var supportsArgumentsClass = function () {
                  return Object.prototype.toString.call(arguments);
                }() == '[object Arguments]';
                exports = module.exports = supportsArgumentsClass ? supported : unsupported;
                exports.supported = supported;
                function supported(object) {
                  return Object.prototype.toString.call(object) == '[object Arguments]';
                }
                exports.unsupported = unsupported;
                function unsupported(object) {
                  return object && typeof object == 'object' && typeof object.length == 'number' && Object.prototype.hasOwnProperty.call(object, 'callee') && !Object.prototype.propertyIsEnumerable.call(object, 'callee') || false;
                }

                /***/
              }, /* 54 */
              /***/function (module, exports) {
                var has = Object.prototype.hasOwnProperty,
                  prefix = '~';

                /**
                 * Constructor to create a storage for our `EE` objects.
                 * An `Events` instance is a plain object whose properties are event names.
                 *
                 * @constructor
                 * @api private
                 */
                function Events() {}

                //
                // We try to not inherit from `Object.prototype`. In some engines creating an
                // instance in this way is faster than calling `Object.create(null)` directly.
                // If `Object.create(null)` is not supported we prefix the event names with a
                // character to make sure that the built-in object properties are not
                // overridden or used as an attack vector.
                //
                if (Object.create) {
                  Events.prototype = Object.create(null);

                  //
                  // This hack is needed because the `__proto__` property is still inherited in
                  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
                  //
                  if (!new Events().__proto__) prefix = false;
                }

                /**
                 * Representation of a single event listener.
                 *
                 * @param {Function} fn The listener function.
                 * @param {Mixed} context The context to invoke the listener with.
                 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
                 * @constructor
                 * @api private
                 */
                function EE(fn, context, once) {
                  this.fn = fn;
                  this.context = context;
                  this.once = once || false;
                }

                /**
                 * Minimal `EventEmitter` interface that is molded against the Node.js
                 * `EventEmitter` interface.
                 *
                 * @constructor
                 * @api public
                 */
                function EventEmitter() {
                  this._events = new Events();
                  this._eventsCount = 0;
                }

                /**
                 * Return an array listing the events for which the emitter has registered
                 * listeners.
                 *
                 * @returns {Array}
                 * @api public
                 */
                EventEmitter.prototype.eventNames = function eventNames() {
                  var names = [],
                    events,
                    name;
                  if (this._eventsCount === 0) return names;
                  for (name in events = this._events) {
                    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
                  }
                  if (Object.getOwnPropertySymbols) {
                    return names.concat(Object.getOwnPropertySymbols(events));
                  }
                  return names;
                };

                /**
                 * Return the listeners registered for a given event.
                 *
                 * @param {String|Symbol} event The event name.
                 * @param {Boolean} exists Only check if there are listeners.
                 * @returns {Array|Boolean}
                 * @api public
                 */
                EventEmitter.prototype.listeners = function listeners(event, exists) {
                  var evt = prefix ? prefix + event : event,
                    available = this._events[evt];
                  if (exists) return !!available;
                  if (!available) return [];
                  if (available.fn) return [available.fn];
                  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
                    ee[i] = available[i].fn;
                  }
                  return ee;
                };

                /**
                 * Calls each of the listeners registered for a given event.
                 *
                 * @param {String|Symbol} event The event name.
                 * @returns {Boolean} `true` if the event had listeners, else `false`.
                 * @api public
                 */
                EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
                  var evt = prefix ? prefix + event : event;
                  if (!this._events[evt]) return false;
                  var listeners = this._events[evt],
                    len = arguments.length,
                    args,
                    i;
                  if (listeners.fn) {
                    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
                    switch (len) {
                      case 1:
                        return listeners.fn.call(listeners.context), true;
                      case 2:
                        return listeners.fn.call(listeners.context, a1), true;
                      case 3:
                        return listeners.fn.call(listeners.context, a1, a2), true;
                      case 4:
                        return listeners.fn.call(listeners.context, a1, a2, a3), true;
                      case 5:
                        return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
                      case 6:
                        return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
                    }
                    for (i = 1, args = new Array(len - 1); i < len; i++) {
                      args[i - 1] = arguments[i];
                    }
                    listeners.fn.apply(listeners.context, args);
                  } else {
                    var length = listeners.length,
                      j;
                    for (i = 0; i < length; i++) {
                      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
                      switch (len) {
                        case 1:
                          listeners[i].fn.call(listeners[i].context);
                          break;
                        case 2:
                          listeners[i].fn.call(listeners[i].context, a1);
                          break;
                        case 3:
                          listeners[i].fn.call(listeners[i].context, a1, a2);
                          break;
                        case 4:
                          listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                          break;
                        default:
                          if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                            args[j - 1] = arguments[j];
                          }
                          listeners[i].fn.apply(listeners[i].context, args);
                      }
                    }
                  }
                  return true;
                };

                /**
                 * Add a listener for a given event.
                 *
                 * @param {String|Symbol} event The event name.
                 * @param {Function} fn The listener function.
                 * @param {Mixed} [context=this] The context to invoke the listener with.
                 * @returns {EventEmitter} `this`.
                 * @api public
                 */
                EventEmitter.prototype.on = function on(event, fn, context) {
                  var listener = new EE(fn, context || this),
                    evt = prefix ? prefix + event : event;
                  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;else if (!this._events[evt].fn) this._events[evt].push(listener);else this._events[evt] = [this._events[evt], listener];
                  return this;
                };

                /**
                 * Add a one-time listener for a given event.
                 *
                 * @param {String|Symbol} event The event name.
                 * @param {Function} fn The listener function.
                 * @param {Mixed} [context=this] The context to invoke the listener with.
                 * @returns {EventEmitter} `this`.
                 * @api public
                 */
                EventEmitter.prototype.once = function once(event, fn, context) {
                  var listener = new EE(fn, context || this, true),
                    evt = prefix ? prefix + event : event;
                  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;else if (!this._events[evt].fn) this._events[evt].push(listener);else this._events[evt] = [this._events[evt], listener];
                  return this;
                };

                /**
                 * Remove the listeners of a given event.
                 *
                 * @param {String|Symbol} event The event name.
                 * @param {Function} fn Only remove the listeners that match this function.
                 * @param {Mixed} context Only remove the listeners that have this context.
                 * @param {Boolean} once Only remove one-time listeners.
                 * @returns {EventEmitter} `this`.
                 * @api public
                 */
                EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
                  var evt = prefix ? prefix + event : event;
                  if (!this._events[evt]) return this;
                  if (!fn) {
                    if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];
                    return this;
                  }
                  var listeners = this._events[evt];
                  if (listeners.fn) {
                    if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
                      if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];
                    }
                  } else {
                    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
                      if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
                        events.push(listeners[i]);
                      }
                    }

                    //
                    // Reset the array, or remove it completely if we have no more listeners.
                    //
                    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];
                  }
                  return this;
                };

                /**
                 * Remove all listeners, or those of the specified event.
                 *
                 * @param {String|Symbol} [event] The event name.
                 * @returns {EventEmitter} `this`.
                 * @api public
                 */
                EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
                  var evt;
                  if (event) {
                    evt = prefix ? prefix + event : event;
                    if (this._events[evt]) {
                      if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];
                    }
                  } else {
                    this._events = new Events();
                    this._eventsCount = 0;
                  }
                  return this;
                };

                //
                // Alias methods names because people roll like that.
                //
                EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
                EventEmitter.prototype.addListener = EventEmitter.prototype.on;

                //
                // This function doesn't apply anymore.
                //
                EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
                  return this;
                };

                //
                // Expose the prefix.
                //
                EventEmitter.prefixed = prefix;

                //
                // Allow `EventEmitter` to be imported as module namespace.
                //
                EventEmitter.EventEmitter = EventEmitter;

                //
                // Expose the module.
                //
                if ('undefined' !== typeof module) {
                  module.exports = EventEmitter;
                }

                /***/
              }, /* 55 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.matchText = exports.matchSpacing = exports.matchNewline = exports.matchBlot = exports.matchAttributor = exports.default = undefined;
                var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
                  return typeof obj;
                } : function (obj) {
                  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
                var _slicedToArray = function () {
                  function sliceIterator(arr, i) {
                    var _arr = [];
                    var _n = true;
                    var _d = false;
                    var _e = undefined;
                    try {
                      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                        _arr.push(_s.value);
                        if (i && _arr.length === i) break;
                      }
                    } catch (err) {
                      _d = true;
                      _e = err;
                    } finally {
                      try {
                        if (!_n && _i["return"]) _i["return"]();
                      } finally {
                        if (_d) throw _e;
                      }
                    }
                    return _arr;
                  }
                  return function (arr, i) {
                    if (Array.isArray(arr)) {
                      return arr;
                    } else if (Symbol.iterator in Object(arr)) {
                      return sliceIterator(arr, i);
                    } else {
                      throw new TypeError("Invalid attempt to destructure non-iterable instance");
                    }
                  };
                }();
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _extend2 = __webpack_require__(3);
                var _extend3 = _interopRequireDefault(_extend2);
                var _quillDelta = __webpack_require__(2);
                var _quillDelta2 = _interopRequireDefault(_quillDelta);
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _quill = __webpack_require__(5);
                var _quill2 = _interopRequireDefault(_quill);
                var _logger = __webpack_require__(10);
                var _logger2 = _interopRequireDefault(_logger);
                var _module = __webpack_require__(9);
                var _module2 = _interopRequireDefault(_module);
                var _align = __webpack_require__(36);
                var _background = __webpack_require__(37);
                var _code = __webpack_require__(13);
                var _code2 = _interopRequireDefault(_code);
                var _color = __webpack_require__(26);
                var _direction = __webpack_require__(38);
                var _font = __webpack_require__(39);
                var _size = __webpack_require__(40);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _defineProperty(obj, key, value) {
                  if (key in obj) {
                    Object.defineProperty(obj, key, {
                      value: value,
                      enumerable: true,
                      configurable: true,
                      writable: true
                    });
                  } else {
                    obj[key] = value;
                  }
                  return obj;
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var debug = (0, _logger2.default)('quill:clipboard');
                var DOM_KEY = '__ql-matcher';
                var CLIPBOARD_CONFIG = [[Node.TEXT_NODE, matchText], [Node.TEXT_NODE, matchNewline], ['br', matchBreak], [Node.ELEMENT_NODE, matchNewline], [Node.ELEMENT_NODE, matchBlot], [Node.ELEMENT_NODE, matchSpacing], [Node.ELEMENT_NODE, matchAttributor], [Node.ELEMENT_NODE, matchStyles], ['li', matchIndent], ['b', matchAlias.bind(matchAlias, 'bold')], ['i', matchAlias.bind(matchAlias, 'italic')], ['style', matchIgnore]];
                var ATTRIBUTE_ATTRIBUTORS = [_align.AlignAttribute, _direction.DirectionAttribute].reduce(function (memo, attr) {
                  memo[attr.keyName] = attr;
                  return memo;
                }, {});
                var STYLE_ATTRIBUTORS = [_align.AlignStyle, _background.BackgroundStyle, _color.ColorStyle, _direction.DirectionStyle, _font.FontStyle, _size.SizeStyle].reduce(function (memo, attr) {
                  memo[attr.keyName] = attr;
                  return memo;
                }, {});
                var Clipboard = function (_Module) {
                  _inherits(Clipboard, _Module);
                  function Clipboard(quill, options) {
                    _classCallCheck(this, Clipboard);
                    var _this = _possibleConstructorReturn(this, (Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)).call(this, quill, options));
                    _this.quill.root.addEventListener('paste', _this.onPaste.bind(_this));
                    _this.container = _this.quill.addContainer('ql-clipboard');
                    _this.container.setAttribute('contenteditable', true);
                    _this.container.setAttribute('tabindex', -1);
                    _this.matchers = [];
                    CLIPBOARD_CONFIG.concat(_this.options.matchers).forEach(function (_ref) {
                      var _ref2 = _slicedToArray(_ref, 2),
                        selector = _ref2[0],
                        matcher = _ref2[1];
                      if (!options.matchVisual && matcher === matchSpacing) return;
                      _this.addMatcher(selector, matcher);
                    });
                    return _this;
                  }
                  _createClass(Clipboard, [{
                    key: 'addMatcher',
                    value: function addMatcher(selector, matcher) {
                      this.matchers.push([selector, matcher]);
                    }
                  }, {
                    key: 'convert',
                    value: function convert(html) {
                      if (typeof html === 'string') {
                        this.container.innerHTML = html.replace(/\>\r?\n +\</g, '><'); // Remove spaces between tags
                        return this.convert();
                      }
                      var formats = this.quill.getFormat(this.quill.selection.savedRange.index);
                      if (formats[_code2.default.blotName]) {
                        var text = this.container.innerText;
                        this.container.innerHTML = '';
                        return new _quillDelta2.default().insert(text, _defineProperty({}, _code2.default.blotName, formats[_code2.default.blotName]));
                      }
                      var _prepareMatching = this.prepareMatching(),
                        _prepareMatching2 = _slicedToArray(_prepareMatching, 2),
                        elementMatchers = _prepareMatching2[0],
                        textMatchers = _prepareMatching2[1];
                      var delta = traverse(this.container, elementMatchers, textMatchers);
                      // Remove trailing newline
                      if (deltaEndsWith(delta, '\n') && delta.ops[delta.ops.length - 1].attributes == null) {
                        delta = delta.compose(new _quillDelta2.default().retain(delta.length() - 1).delete(1));
                      }
                      debug.log('convert', this.container.innerHTML, delta);
                      this.container.innerHTML = '';
                      return delta;
                    }
                  }, {
                    key: 'dangerouslyPasteHTML',
                    value: function dangerouslyPasteHTML(index, html) {
                      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _quill2.default.sources.API;
                      if (typeof index === 'string') {
                        this.quill.setContents(this.convert(index), html);
                        this.quill.setSelection(0, _quill2.default.sources.SILENT);
                      } else {
                        var paste = this.convert(html);
                        this.quill.updateContents(new _quillDelta2.default().retain(index).concat(paste), source);
                        this.quill.setSelection(index + paste.length(), _quill2.default.sources.SILENT);
                      }
                    }
                  }, {
                    key: 'onPaste',
                    value: function onPaste(e) {
                      var _this2 = this;
                      if (e.defaultPrevented || !this.quill.isEnabled()) return;
                      var range = this.quill.getSelection();
                      var delta = new _quillDelta2.default().retain(range.index);
                      var scrollTop = this.quill.scrollingContainer.scrollTop;
                      this.container.focus();
                      this.quill.selection.update(_quill2.default.sources.SILENT);
                      setTimeout(function () {
                        delta = delta.concat(_this2.convert()).delete(range.length);
                        _this2.quill.updateContents(delta, _quill2.default.sources.USER);
                        // range.length contributes to delta.length()
                        _this2.quill.setSelection(delta.length() - range.length, _quill2.default.sources.SILENT);
                        _this2.quill.scrollingContainer.scrollTop = scrollTop;
                        _this2.quill.focus();
                      }, 1);
                    }
                  }, {
                    key: 'prepareMatching',
                    value: function prepareMatching() {
                      var _this3 = this;
                      var elementMatchers = [],
                        textMatchers = [];
                      this.matchers.forEach(function (pair) {
                        var _pair = _slicedToArray(pair, 2),
                          selector = _pair[0],
                          matcher = _pair[1];
                        switch (selector) {
                          case Node.TEXT_NODE:
                            textMatchers.push(matcher);
                            break;
                          case Node.ELEMENT_NODE:
                            elementMatchers.push(matcher);
                            break;
                          default:
                            [].forEach.call(_this3.container.querySelectorAll(selector), function (node) {
                              // TODO use weakmap
                              node[DOM_KEY] = node[DOM_KEY] || [];
                              node[DOM_KEY].push(matcher);
                            });
                            break;
                        }
                      });
                      return [elementMatchers, textMatchers];
                    }
                  }]);
                  return Clipboard;
                }(_module2.default);
                Clipboard.DEFAULTS = {
                  matchers: [],
                  matchVisual: true
                };
                function applyFormat(delta, format, value) {
                  if ((typeof format === 'undefined' ? 'undefined' : _typeof(format)) === 'object') {
                    return Object.keys(format).reduce(function (delta, key) {
                      return applyFormat(delta, key, format[key]);
                    }, delta);
                  } else {
                    return delta.reduce(function (delta, op) {
                      if (op.attributes && op.attributes[format]) {
                        return delta.push(op);
                      } else {
                        return delta.insert(op.insert, (0, _extend3.default)({}, _defineProperty({}, format, value), op.attributes));
                      }
                    }, new _quillDelta2.default());
                  }
                }
                function computeStyle(node) {
                  if (node.nodeType !== Node.ELEMENT_NODE) return {};
                  var DOM_KEY = '__ql-computed-style';
                  return node[DOM_KEY] || (node[DOM_KEY] = window.getComputedStyle(node));
                }
                function deltaEndsWith(delta, text) {
                  var endText = "";
                  for (var i = delta.ops.length - 1; i >= 0 && endText.length < text.length; --i) {
                    var op = delta.ops[i];
                    if (typeof op.insert !== 'string') break;
                    endText = op.insert + endText;
                  }
                  return endText.slice(-1 * text.length) === text;
                }
                function isLine(node) {
                  if (node.childNodes.length === 0) return false; // Exclude embed blocks
                  var style = computeStyle(node);
                  return ['block', 'list-item'].indexOf(style.display) > -1;
                }
                function traverse(node, elementMatchers, textMatchers) {
                  // Post-order
                  if (node.nodeType === node.TEXT_NODE) {
                    return textMatchers.reduce(function (delta, matcher) {
                      return matcher(node, delta);
                    }, new _quillDelta2.default());
                  } else if (node.nodeType === node.ELEMENT_NODE) {
                    return [].reduce.call(node.childNodes || [], function (delta, childNode) {
                      var childrenDelta = traverse(childNode, elementMatchers, textMatchers);
                      if (childNode.nodeType === node.ELEMENT_NODE) {
                        childrenDelta = elementMatchers.reduce(function (childrenDelta, matcher) {
                          return matcher(childNode, childrenDelta);
                        }, childrenDelta);
                        childrenDelta = (childNode[DOM_KEY] || []).reduce(function (childrenDelta, matcher) {
                          return matcher(childNode, childrenDelta);
                        }, childrenDelta);
                      }
                      return delta.concat(childrenDelta);
                    }, new _quillDelta2.default());
                  } else {
                    return new _quillDelta2.default();
                  }
                }
                function matchAlias(format, node, delta) {
                  return applyFormat(delta, format, true);
                }
                function matchAttributor(node, delta) {
                  var attributes = _parchment2.default.Attributor.Attribute.keys(node);
                  var classes = _parchment2.default.Attributor.Class.keys(node);
                  var styles = _parchment2.default.Attributor.Style.keys(node);
                  var formats = {};
                  attributes.concat(classes).concat(styles).forEach(function (name) {
                    var attr = _parchment2.default.query(name, _parchment2.default.Scope.ATTRIBUTE);
                    if (attr != null) {
                      formats[attr.attrName] = attr.value(node);
                      if (formats[attr.attrName]) return;
                    }
                    attr = ATTRIBUTE_ATTRIBUTORS[name];
                    if (attr != null && (attr.attrName === name || attr.keyName === name)) {
                      formats[attr.attrName] = attr.value(node) || undefined;
                    }
                    attr = STYLE_ATTRIBUTORS[name];
                    if (attr != null && (attr.attrName === name || attr.keyName === name)) {
                      attr = STYLE_ATTRIBUTORS[name];
                      formats[attr.attrName] = attr.value(node) || undefined;
                    }
                  });
                  if (Object.keys(formats).length > 0) {
                    delta = applyFormat(delta, formats);
                  }
                  return delta;
                }
                function matchBlot(node, delta) {
                  var match = _parchment2.default.query(node);
                  if (match == null) return delta;
                  if (match.prototype instanceof _parchment2.default.Embed) {
                    var embed = {};
                    var value = match.value(node);
                    if (value != null) {
                      embed[match.blotName] = value;
                      delta = new _quillDelta2.default().insert(embed, match.formats(node));
                    }
                  } else if (typeof match.formats === 'function') {
                    delta = applyFormat(delta, match.blotName, match.formats(node));
                  }
                  return delta;
                }
                function matchBreak(node, delta) {
                  if (!deltaEndsWith(delta, '\n')) {
                    delta.insert('\n');
                  }
                  return delta;
                }
                function matchIgnore() {
                  return new _quillDelta2.default();
                }
                function matchIndent(node, delta) {
                  var match = _parchment2.default.query(node);
                  if (match == null || match.blotName !== 'list-item' || !deltaEndsWith(delta, '\n')) {
                    return delta;
                  }
                  var indent = -1,
                    parent = node.parentNode;
                  while (!parent.classList.contains('ql-clipboard')) {
                    if ((_parchment2.default.query(parent) || {}).blotName === 'list') {
                      indent += 1;
                    }
                    parent = parent.parentNode;
                  }
                  if (indent <= 0) return delta;
                  return delta.compose(new _quillDelta2.default().retain(delta.length() - 1).retain(1, {
                    indent: indent
                  }));
                }
                function matchNewline(node, delta) {
                  if (!deltaEndsWith(delta, '\n')) {
                    if (isLine(node) || delta.length() > 0 && node.nextSibling && isLine(node.nextSibling)) {
                      delta.insert('\n');
                    }
                  }
                  return delta;
                }
                function matchSpacing(node, delta) {
                  if (isLine(node) && node.nextElementSibling != null && !deltaEndsWith(delta, '\n\n')) {
                    var nodeHeight = node.offsetHeight + parseFloat(computeStyle(node).marginTop) + parseFloat(computeStyle(node).marginBottom);
                    if (node.nextElementSibling.offsetTop > node.offsetTop + nodeHeight * 1.5) {
                      delta.insert('\n');
                    }
                  }
                  return delta;
                }
                function matchStyles(node, delta) {
                  var formats = {};
                  var style = node.style || {};
                  if (style.fontStyle && computeStyle(node).fontStyle === 'italic') {
                    formats.italic = true;
                  }
                  if (style.fontWeight && (computeStyle(node).fontWeight.startsWith('bold') || parseInt(computeStyle(node).fontWeight) >= 700)) {
                    formats.bold = true;
                  }
                  if (Object.keys(formats).length > 0) {
                    delta = applyFormat(delta, formats);
                  }
                  if (parseFloat(style.textIndent || 0) > 0) {
                    // Could be 0.5in
                    delta = new _quillDelta2.default().insert('\t').concat(delta);
                  }
                  return delta;
                }
                function matchText(node, delta) {
                  var text = node.data;
                  // Word represents empty line with <o:p>&nbsp;</o:p>
                  if (node.parentNode.tagName === 'O:P') {
                    return delta.insert(text.trim());
                  }
                  if (text.trim().length === 0 && node.parentNode.classList.contains('ql-clipboard')) {
                    return delta;
                  }
                  if (!computeStyle(node.parentNode).whiteSpace.startsWith('pre')) {
                    // eslint-disable-next-line func-style
                    var replacer = function replacer(collapse, match) {
                      match = match.replace(/[^\u00a0]/g, ''); // \u00a0 is nbsp;
                      return match.length < 1 && collapse ? ' ' : match;
                    };
                    text = text.replace(/\r\n/g, ' ').replace(/\n/g, ' ');
                    text = text.replace(/\s\s+/g, replacer.bind(replacer, true)); // collapse whitespace
                    if (node.previousSibling == null && isLine(node.parentNode) || node.previousSibling != null && isLine(node.previousSibling)) {
                      text = text.replace(/^\s+/, replacer.bind(replacer, false));
                    }
                    if (node.nextSibling == null && isLine(node.parentNode) || node.nextSibling != null && isLine(node.nextSibling)) {
                      text = text.replace(/\s+$/, replacer.bind(replacer, false));
                    }
                  }
                  return delta.insert(text);
                }
                exports.default = Clipboard;
                exports.matchAttributor = matchAttributor;
                exports.matchBlot = matchBlot;
                exports.matchNewline = matchNewline;
                exports.matchSpacing = matchSpacing;
                exports.matchText = matchText;

                /***/
              }, /* 56 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _get = function get(object, property, receiver) {
                  if (object === null) object = Function.prototype;
                  var desc = Object.getOwnPropertyDescriptor(object, property);
                  if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                      return undefined;
                    } else {
                      return get(parent, property, receiver);
                    }
                  } else if ("value" in desc) {
                    return desc.value;
                  } else {
                    var getter = desc.get;
                    if (getter === undefined) {
                      return undefined;
                    }
                    return getter.call(receiver);
                  }
                };
                var _inline = __webpack_require__(6);
                var _inline2 = _interopRequireDefault(_inline);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var Bold = function (_Inline) {
                  _inherits(Bold, _Inline);
                  function Bold() {
                    _classCallCheck(this, Bold);
                    return _possibleConstructorReturn(this, (Bold.__proto__ || Object.getPrototypeOf(Bold)).apply(this, arguments));
                  }
                  _createClass(Bold, [{
                    key: 'optimize',
                    value: function optimize(context) {
                      _get(Bold.prototype.__proto__ || Object.getPrototypeOf(Bold.prototype), 'optimize', this).call(this, context);
                      if (this.domNode.tagName !== this.statics.tagName[0]) {
                        this.replaceWith(this.statics.blotName);
                      }
                    }
                  }], [{
                    key: 'create',
                    value: function create() {
                      return _get(Bold.__proto__ || Object.getPrototypeOf(Bold), 'create', this).call(this);
                    }
                  }, {
                    key: 'formats',
                    value: function formats() {
                      return true;
                    }
                  }]);
                  return Bold;
                }(_inline2.default);
                Bold.blotName = 'bold';
                Bold.tagName = ['STRONG', 'B'];
                exports.default = Bold;

                /***/
              }, /* 57 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.addControls = exports.default = undefined;
                var _slicedToArray = function () {
                  function sliceIterator(arr, i) {
                    var _arr = [];
                    var _n = true;
                    var _d = false;
                    var _e = undefined;
                    try {
                      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                        _arr.push(_s.value);
                        if (i && _arr.length === i) break;
                      }
                    } catch (err) {
                      _d = true;
                      _e = err;
                    } finally {
                      try {
                        if (!_n && _i["return"]) _i["return"]();
                      } finally {
                        if (_d) throw _e;
                      }
                    }
                    return _arr;
                  }
                  return function (arr, i) {
                    if (Array.isArray(arr)) {
                      return arr;
                    } else if (Symbol.iterator in Object(arr)) {
                      return sliceIterator(arr, i);
                    } else {
                      throw new TypeError("Invalid attempt to destructure non-iterable instance");
                    }
                  };
                }();
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _quillDelta = __webpack_require__(2);
                var _quillDelta2 = _interopRequireDefault(_quillDelta);
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _quill = __webpack_require__(5);
                var _quill2 = _interopRequireDefault(_quill);
                var _logger = __webpack_require__(10);
                var _logger2 = _interopRequireDefault(_logger);
                var _module = __webpack_require__(9);
                var _module2 = _interopRequireDefault(_module);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _defineProperty(obj, key, value) {
                  if (key in obj) {
                    Object.defineProperty(obj, key, {
                      value: value,
                      enumerable: true,
                      configurable: true,
                      writable: true
                    });
                  } else {
                    obj[key] = value;
                  }
                  return obj;
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var debug = (0, _logger2.default)('quill:toolbar');
                var Toolbar = function (_Module) {
                  _inherits(Toolbar, _Module);
                  function Toolbar(quill, options) {
                    _classCallCheck(this, Toolbar);
                    var _this = _possibleConstructorReturn(this, (Toolbar.__proto__ || Object.getPrototypeOf(Toolbar)).call(this, quill, options));
                    if (Array.isArray(_this.options.container)) {
                      var container = document.createElement('div');
                      addControls(container, _this.options.container);
                      quill.container.parentNode.insertBefore(container, quill.container);
                      _this.container = container;
                    } else if (typeof _this.options.container === 'string') {
                      _this.container = document.querySelector(_this.options.container);
                    } else {
                      _this.container = _this.options.container;
                    }
                    if (!(_this.container instanceof HTMLElement)) {
                      var _ret;
                      return _ret = debug.error('Container required for toolbar', _this.options), _possibleConstructorReturn(_this, _ret);
                    }
                    _this.container.classList.add('ql-toolbar');
                    _this.controls = [];
                    _this.handlers = {};
                    Object.keys(_this.options.handlers).forEach(function (format) {
                      _this.addHandler(format, _this.options.handlers[format]);
                    });
                    [].forEach.call(_this.container.querySelectorAll('button, select'), function (input) {
                      _this.attach(input);
                    });
                    _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function (type, range) {
                      if (type === _quill2.default.events.SELECTION_CHANGE) {
                        _this.update(range);
                      }
                    });
                    _this.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function () {
                      var _this$quill$selection = _this.quill.selection.getRange(),
                        _this$quill$selection2 = _slicedToArray(_this$quill$selection, 1),
                        range = _this$quill$selection2[0]; // quill.getSelection triggers update

                      _this.update(range);
                    });
                    return _this;
                  }
                  _createClass(Toolbar, [{
                    key: 'addHandler',
                    value: function addHandler(format, handler) {
                      this.handlers[format] = handler;
                    }
                  }, {
                    key: 'attach',
                    value: function attach(input) {
                      var _this2 = this;
                      var format = [].find.call(input.classList, function (className) {
                        return className.indexOf('ql-') === 0;
                      });
                      if (!format) return;
                      format = format.slice('ql-'.length);
                      if (input.tagName === 'BUTTON') {
                        input.setAttribute('type', 'button');
                      }
                      if (this.handlers[format] == null) {
                        if (this.quill.scroll.whitelist != null && this.quill.scroll.whitelist[format] == null) {
                          debug.warn('ignoring attaching to disabled format', format, input);
                          return;
                        }
                        if (_parchment2.default.query(format) == null) {
                          debug.warn('ignoring attaching to nonexistent format', format, input);
                          return;
                        }
                      }
                      var eventName = input.tagName === 'SELECT' ? 'change' : 'click';
                      input.addEventListener(eventName, function (e) {
                        var value = void 0;
                        if (input.tagName === 'SELECT') {
                          if (input.selectedIndex < 0) return;
                          var selected = input.options[input.selectedIndex];
                          if (selected.hasAttribute('selected')) {
                            value = false;
                          } else {
                            value = selected.value || false;
                          }
                        } else {
                          if (input.classList.contains('ql-active')) {
                            value = false;
                          } else {
                            value = input.value || !input.hasAttribute('value');
                          }
                          e.preventDefault();
                        }
                        _this2.quill.focus();
                        var _quill$selection$getR = _this2.quill.selection.getRange(),
                          _quill$selection$getR2 = _slicedToArray(_quill$selection$getR, 1),
                          range = _quill$selection$getR2[0];
                        if (_this2.handlers[format] != null) {
                          _this2.handlers[format].call(_this2, value);
                        } else if (_parchment2.default.query(format).prototype instanceof _parchment2.default.Embed) {
                          value = prompt('Enter ' + format);
                          if (!value) return;
                          _this2.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert(_defineProperty({}, format, value)), _quill2.default.sources.USER);
                        } else {
                          _this2.quill.format(format, value, _quill2.default.sources.USER);
                        }
                        _this2.update(range);
                      });
                      // TODO use weakmap
                      this.controls.push([format, input]);
                    }
                  }, {
                    key: 'update',
                    value: function update(range) {
                      var formats = range == null ? {} : this.quill.getFormat(range);
                      this.controls.forEach(function (pair) {
                        var _pair = _slicedToArray(pair, 2),
                          format = _pair[0],
                          input = _pair[1];
                        if (input.tagName === 'SELECT') {
                          var option = void 0;
                          if (range == null) {
                            option = null;
                          } else if (formats[format] == null) {
                            option = input.querySelector('option[selected]');
                          } else if (!Array.isArray(formats[format])) {
                            var value = formats[format];
                            if (typeof value === 'string') {
                              value = value.replace(/\"/g, '\\"');
                            }
                            option = input.querySelector('option[value="' + value + '"]');
                          }
                          if (option == null) {
                            input.value = ''; // TODO make configurable?
                            input.selectedIndex = -1;
                          } else {
                            option.selected = true;
                          }
                        } else {
                          if (range == null) {
                            input.classList.remove('ql-active');
                          } else if (input.hasAttribute('value')) {
                            // both being null should match (default values)
                            // '1' should match with 1 (headers)
                            var isActive = formats[format] === input.getAttribute('value') || formats[format] != null && formats[format].toString() === input.getAttribute('value') || formats[format] == null && !input.getAttribute('value');
                            input.classList.toggle('ql-active', isActive);
                          } else {
                            input.classList.toggle('ql-active', formats[format] != null);
                          }
                        }
                      });
                    }
                  }]);
                  return Toolbar;
                }(_module2.default);
                Toolbar.DEFAULTS = {};
                function addButton(container, format, value) {
                  var input = document.createElement('button');
                  input.setAttribute('type', 'button');
                  input.classList.add('ql-' + format);
                  if (value != null) {
                    input.value = value;
                  }
                  container.appendChild(input);
                }
                function addControls(container, groups) {
                  if (!Array.isArray(groups[0])) {
                    groups = [groups];
                  }
                  groups.forEach(function (controls) {
                    var group = document.createElement('span');
                    group.classList.add('ql-formats');
                    controls.forEach(function (control) {
                      if (typeof control === 'string') {
                        addButton(group, control);
                      } else {
                        var format = Object.keys(control)[0];
                        var value = control[format];
                        if (Array.isArray(value)) {
                          addSelect(group, format, value);
                        } else {
                          addButton(group, format, value);
                        }
                      }
                    });
                    container.appendChild(group);
                  });
                }
                function addSelect(container, format, values) {
                  var input = document.createElement('select');
                  input.classList.add('ql-' + format);
                  values.forEach(function (value) {
                    var option = document.createElement('option');
                    if (value !== false) {
                      option.setAttribute('value', value);
                    } else {
                      option.setAttribute('selected', 'selected');
                    }
                    input.appendChild(option);
                  });
                  container.appendChild(input);
                }
                Toolbar.DEFAULTS = {
                  container: null,
                  handlers: {
                    clean: function clean() {
                      var _this3 = this;
                      var range = this.quill.getSelection();
                      if (range == null) return;
                      if (range.length == 0) {
                        var formats = this.quill.getFormat();
                        Object.keys(formats).forEach(function (name) {
                          // Clean functionality in existing apps only clean inline formats
                          if (_parchment2.default.query(name, _parchment2.default.Scope.INLINE) != null) {
                            _this3.quill.format(name, false);
                          }
                        });
                      } else {
                        this.quill.removeFormat(range, _quill2.default.sources.USER);
                      }
                    },
                    direction: function direction(value) {
                      var align = this.quill.getFormat()['align'];
                      if (value === 'rtl' && align == null) {
                        this.quill.format('align', 'right', _quill2.default.sources.USER);
                      } else if (!value && align === 'right') {
                        this.quill.format('align', false, _quill2.default.sources.USER);
                      }
                      this.quill.format('direction', value, _quill2.default.sources.USER);
                    },
                    indent: function indent(value) {
                      var range = this.quill.getSelection();
                      var formats = this.quill.getFormat(range);
                      var indent = parseInt(formats.indent || 0);
                      if (value === '+1' || value === '-1') {
                        var modifier = value === '+1' ? 1 : -1;
                        if (formats.direction === 'rtl') modifier *= -1;
                        this.quill.format('indent', indent + modifier, _quill2.default.sources.USER);
                      }
                    },
                    link: function link(value) {
                      if (value === true) {
                        value = prompt('Enter link URL:');
                      }
                      this.quill.format('link', value, _quill2.default.sources.USER);
                    },
                    list: function list(value) {
                      var range = this.quill.getSelection();
                      var formats = this.quill.getFormat(range);
                      if (value === 'check') {
                        if (formats['list'] === 'checked' || formats['list'] === 'unchecked') {
                          this.quill.format('list', false, _quill2.default.sources.USER);
                        } else {
                          this.quill.format('list', 'unchecked', _quill2.default.sources.USER);
                        }
                      } else {
                        this.quill.format('list', value, _quill2.default.sources.USER);
                      }
                    }
                  }
                };
                exports.default = Toolbar;
                exports.addControls = addControls;

                /***/
              }, /* 58 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <polyline class=\"ql-even ql-stroke\" points=\"5 7 3 9 5 11\"></polyline> <polyline class=\"ql-even ql-stroke\" points=\"13 7 15 9 13 11\"></polyline> <line class=ql-stroke x1=10 x2=8 y1=5 y2=13></line> </svg>";

                /***/
              }, /* 59 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _get = function get(object, property, receiver) {
                  if (object === null) object = Function.prototype;
                  var desc = Object.getOwnPropertyDescriptor(object, property);
                  if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                      return undefined;
                    } else {
                      return get(parent, property, receiver);
                    }
                  } else if ("value" in desc) {
                    return desc.value;
                  } else {
                    var getter = desc.get;
                    if (getter === undefined) {
                      return undefined;
                    }
                    return getter.call(receiver);
                  }
                };
                var _picker = __webpack_require__(28);
                var _picker2 = _interopRequireDefault(_picker);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var ColorPicker = function (_Picker) {
                  _inherits(ColorPicker, _Picker);
                  function ColorPicker(select, label) {
                    _classCallCheck(this, ColorPicker);
                    var _this = _possibleConstructorReturn(this, (ColorPicker.__proto__ || Object.getPrototypeOf(ColorPicker)).call(this, select));
                    _this.label.innerHTML = label;
                    _this.container.classList.add('ql-color-picker');
                    [].slice.call(_this.container.querySelectorAll('.ql-picker-item'), 0, 7).forEach(function (item) {
                      item.classList.add('ql-primary');
                    });
                    return _this;
                  }
                  _createClass(ColorPicker, [{
                    key: 'buildItem',
                    value: function buildItem(option) {
                      var item = _get(ColorPicker.prototype.__proto__ || Object.getPrototypeOf(ColorPicker.prototype), 'buildItem', this).call(this, option);
                      item.style.backgroundColor = option.getAttribute('value') || '';
                      return item;
                    }
                  }, {
                    key: 'selectItem',
                    value: function selectItem(item, trigger) {
                      _get(ColorPicker.prototype.__proto__ || Object.getPrototypeOf(ColorPicker.prototype), 'selectItem', this).call(this, item, trigger);
                      var colorLabel = this.label.querySelector('.ql-color-label');
                      var value = item ? item.getAttribute('data-value') || '' : '';
                      if (colorLabel) {
                        if (colorLabel.tagName === 'line') {
                          colorLabel.style.stroke = value;
                        } else {
                          colorLabel.style.fill = value;
                        }
                      }
                    }
                  }]);
                  return ColorPicker;
                }(_picker2.default);
                exports.default = ColorPicker;

                /***/
              }, /* 60 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _get = function get(object, property, receiver) {
                  if (object === null) object = Function.prototype;
                  var desc = Object.getOwnPropertyDescriptor(object, property);
                  if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                      return undefined;
                    } else {
                      return get(parent, property, receiver);
                    }
                  } else if ("value" in desc) {
                    return desc.value;
                  } else {
                    var getter = desc.get;
                    if (getter === undefined) {
                      return undefined;
                    }
                    return getter.call(receiver);
                  }
                };
                var _picker = __webpack_require__(28);
                var _picker2 = _interopRequireDefault(_picker);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var IconPicker = function (_Picker) {
                  _inherits(IconPicker, _Picker);
                  function IconPicker(select, icons) {
                    _classCallCheck(this, IconPicker);
                    var _this = _possibleConstructorReturn(this, (IconPicker.__proto__ || Object.getPrototypeOf(IconPicker)).call(this, select));
                    _this.container.classList.add('ql-icon-picker');
                    [].forEach.call(_this.container.querySelectorAll('.ql-picker-item'), function (item) {
                      item.innerHTML = icons[item.getAttribute('data-value') || ''];
                    });
                    _this.defaultItem = _this.container.querySelector('.ql-selected');
                    _this.selectItem(_this.defaultItem);
                    return _this;
                  }
                  _createClass(IconPicker, [{
                    key: 'selectItem',
                    value: function selectItem(item, trigger) {
                      _get(IconPicker.prototype.__proto__ || Object.getPrototypeOf(IconPicker.prototype), 'selectItem', this).call(this, item, trigger);
                      item = item || this.defaultItem;
                      this.label.innerHTML = item.innerHTML;
                    }
                  }]);
                  return IconPicker;
                }(_picker2.default);
                exports.default = IconPicker;

                /***/
              }, /* 61 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                var Tooltip = function () {
                  function Tooltip(quill, boundsContainer) {
                    var _this = this;
                    _classCallCheck(this, Tooltip);
                    this.quill = quill;
                    this.boundsContainer = boundsContainer || document.body;
                    this.root = quill.addContainer('ql-tooltip');
                    this.root.innerHTML = this.constructor.TEMPLATE;
                    if (this.quill.root === this.quill.scrollingContainer) {
                      this.quill.root.addEventListener('scroll', function () {
                        _this.root.style.marginTop = -1 * _this.quill.root.scrollTop + 'px';
                      });
                    }
                    this.hide();
                  }
                  _createClass(Tooltip, [{
                    key: 'hide',
                    value: function hide() {
                      this.root.classList.add('ql-hidden');
                    }
                  }, {
                    key: 'position',
                    value: function position(reference) {
                      var left = reference.left + reference.width / 2 - this.root.offsetWidth / 2;
                      // root.scrollTop should be 0 if scrollContainer !== root
                      var top = reference.bottom + this.quill.root.scrollTop;
                      this.root.style.left = left + 'px';
                      this.root.style.top = top + 'px';
                      this.root.classList.remove('ql-flip');
                      var containerBounds = this.boundsContainer.getBoundingClientRect();
                      var rootBounds = this.root.getBoundingClientRect();
                      var shift = 0;
                      if (rootBounds.right > containerBounds.right) {
                        shift = containerBounds.right - rootBounds.right;
                        this.root.style.left = left + shift + 'px';
                      }
                      if (rootBounds.left < containerBounds.left) {
                        shift = containerBounds.left - rootBounds.left;
                        this.root.style.left = left + shift + 'px';
                      }
                      if (rootBounds.bottom > containerBounds.bottom) {
                        var height = rootBounds.bottom - rootBounds.top;
                        var verticalShift = reference.bottom - reference.top + height;
                        this.root.style.top = top - verticalShift + 'px';
                        this.root.classList.add('ql-flip');
                      }
                      return shift;
                    }
                  }, {
                    key: 'show',
                    value: function show() {
                      this.root.classList.remove('ql-editing');
                      this.root.classList.remove('ql-hidden');
                    }
                  }]);
                  return Tooltip;
                }();
                exports.default = Tooltip;

                /***/
              }, /* 62 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var _slicedToArray = function () {
                  function sliceIterator(arr, i) {
                    var _arr = [];
                    var _n = true;
                    var _d = false;
                    var _e = undefined;
                    try {
                      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                        _arr.push(_s.value);
                        if (i && _arr.length === i) break;
                      }
                    } catch (err) {
                      _d = true;
                      _e = err;
                    } finally {
                      try {
                        if (!_n && _i["return"]) _i["return"]();
                      } finally {
                        if (_d) throw _e;
                      }
                    }
                    return _arr;
                  }
                  return function (arr, i) {
                    if (Array.isArray(arr)) {
                      return arr;
                    } else if (Symbol.iterator in Object(arr)) {
                      return sliceIterator(arr, i);
                    } else {
                      throw new TypeError("Invalid attempt to destructure non-iterable instance");
                    }
                  };
                }();
                var _get = function get(object, property, receiver) {
                  if (object === null) object = Function.prototype;
                  var desc = Object.getOwnPropertyDescriptor(object, property);
                  if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                      return undefined;
                    } else {
                      return get(parent, property, receiver);
                    }
                  } else if ("value" in desc) {
                    return desc.value;
                  } else {
                    var getter = desc.get;
                    if (getter === undefined) {
                      return undefined;
                    }
                    return getter.call(receiver);
                  }
                };
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _extend = __webpack_require__(3);
                var _extend2 = _interopRequireDefault(_extend);
                var _emitter = __webpack_require__(8);
                var _emitter2 = _interopRequireDefault(_emitter);
                var _base = __webpack_require__(43);
                var _base2 = _interopRequireDefault(_base);
                var _link = __webpack_require__(27);
                var _link2 = _interopRequireDefault(_link);
                var _selection = __webpack_require__(15);
                var _icons = __webpack_require__(41);
                var _icons2 = _interopRequireDefault(_icons);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var TOOLBAR_CONFIG = [[{
                  header: ['1', '2', '3', false]
                }], ['bold', 'italic', 'underline', 'link'], [{
                  list: 'ordered'
                }, {
                  list: 'bullet'
                }], ['clean']];
                var SnowTheme = function (_BaseTheme) {
                  _inherits(SnowTheme, _BaseTheme);
                  function SnowTheme(quill, options) {
                    _classCallCheck(this, SnowTheme);
                    if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
                      options.modules.toolbar.container = TOOLBAR_CONFIG;
                    }
                    var _this = _possibleConstructorReturn(this, (SnowTheme.__proto__ || Object.getPrototypeOf(SnowTheme)).call(this, quill, options));
                    _this.quill.container.classList.add('ql-snow');
                    return _this;
                  }
                  _createClass(SnowTheme, [{
                    key: 'extendToolbar',
                    value: function extendToolbar(toolbar) {
                      toolbar.container.classList.add('ql-snow');
                      this.buildButtons([].slice.call(toolbar.container.querySelectorAll('button')), _icons2.default);
                      this.buildPickers([].slice.call(toolbar.container.querySelectorAll('select')), _icons2.default);
                      this.tooltip = new SnowTooltip(this.quill, this.options.bounds);
                      if (toolbar.container.querySelector('.ql-link')) {
                        this.quill.keyboard.addBinding({
                          key: 'K',
                          shortKey: true
                        }, function (range, context) {
                          toolbar.handlers['link'].call(toolbar, !context.format.link);
                        });
                      }
                    }
                  }]);
                  return SnowTheme;
                }(_base2.default);
                SnowTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {
                  modules: {
                    toolbar: {
                      handlers: {
                        link: function link(value) {
                          if (value) {
                            var range = this.quill.getSelection();
                            if (range == null || range.length == 0) return;
                            var preview = this.quill.getText(range);
                            if (/^\S+@\S+\.\S+$/.test(preview) && preview.indexOf('mailto:') !== 0) {
                              preview = 'mailto:' + preview;
                            }
                            var tooltip = this.quill.theme.tooltip;
                            tooltip.edit('link', preview);
                          } else {
                            this.quill.format('link', false);
                          }
                        }
                      }
                    }
                  }
                });
                var SnowTooltip = function (_BaseTooltip) {
                  _inherits(SnowTooltip, _BaseTooltip);
                  function SnowTooltip(quill, bounds) {
                    _classCallCheck(this, SnowTooltip);
                    var _this2 = _possibleConstructorReturn(this, (SnowTooltip.__proto__ || Object.getPrototypeOf(SnowTooltip)).call(this, quill, bounds));
                    _this2.preview = _this2.root.querySelector('a.ql-preview');
                    return _this2;
                  }
                  _createClass(SnowTooltip, [{
                    key: 'listen',
                    value: function listen() {
                      var _this3 = this;
                      _get(SnowTooltip.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip.prototype), 'listen', this).call(this);
                      this.root.querySelector('a.ql-action').addEventListener('click', function (event) {
                        if (_this3.root.classList.contains('ql-editing')) {
                          _this3.save();
                        } else {
                          _this3.edit('link', _this3.preview.textContent);
                        }
                        event.preventDefault();
                      });
                      this.root.querySelector('a.ql-remove').addEventListener('click', function (event) {
                        if (_this3.linkRange != null) {
                          var range = _this3.linkRange;
                          _this3.restoreFocus();
                          _this3.quill.formatText(range, 'link', false, _emitter2.default.sources.USER);
                          delete _this3.linkRange;
                        }
                        event.preventDefault();
                        _this3.hide();
                      });
                      this.quill.on(_emitter2.default.events.SELECTION_CHANGE, function (range, oldRange, source) {
                        if (range == null) return;
                        if (range.length === 0 && source === _emitter2.default.sources.USER) {
                          var _quill$scroll$descend = _this3.quill.scroll.descendant(_link2.default, range.index),
                            _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2),
                            link = _quill$scroll$descend2[0],
                            offset = _quill$scroll$descend2[1];
                          if (link != null) {
                            _this3.linkRange = new _selection.Range(range.index - offset, link.length());
                            var preview = _link2.default.formats(link.domNode);
                            _this3.preview.textContent = preview;
                            _this3.preview.setAttribute('href', preview);
                            _this3.show();
                            _this3.position(_this3.quill.getBounds(_this3.linkRange));
                            return;
                          }
                        } else {
                          delete _this3.linkRange;
                        }
                        _this3.hide();
                      });
                    }
                  }, {
                    key: 'show',
                    value: function show() {
                      _get(SnowTooltip.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip.prototype), 'show', this).call(this);
                      this.root.removeAttribute('data-mode');
                    }
                  }]);
                  return SnowTooltip;
                }(_base.BaseTooltip);
                SnowTooltip.TEMPLATE = ['<a class="ql-preview" rel="noopener noreferrer" target="_blank" href="about:blank"></a>', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-action"></a>', '<a class="ql-remove"></a>'].join('');
                exports.default = SnowTheme;

                /***/
              }, /* 63 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var _core = __webpack_require__(29);
                var _core2 = _interopRequireDefault(_core);
                var _align = __webpack_require__(36);
                var _direction = __webpack_require__(38);
                var _indent = __webpack_require__(64);
                var _blockquote = __webpack_require__(65);
                var _blockquote2 = _interopRequireDefault(_blockquote);
                var _header = __webpack_require__(66);
                var _header2 = _interopRequireDefault(_header);
                var _list = __webpack_require__(67);
                var _list2 = _interopRequireDefault(_list);
                var _background = __webpack_require__(37);
                var _color = __webpack_require__(26);
                var _font = __webpack_require__(39);
                var _size = __webpack_require__(40);
                var _bold = __webpack_require__(56);
                var _bold2 = _interopRequireDefault(_bold);
                var _italic = __webpack_require__(68);
                var _italic2 = _interopRequireDefault(_italic);
                var _link = __webpack_require__(27);
                var _link2 = _interopRequireDefault(_link);
                var _script = __webpack_require__(69);
                var _script2 = _interopRequireDefault(_script);
                var _strike = __webpack_require__(70);
                var _strike2 = _interopRequireDefault(_strike);
                var _underline = __webpack_require__(71);
                var _underline2 = _interopRequireDefault(_underline);
                var _image = __webpack_require__(72);
                var _image2 = _interopRequireDefault(_image);
                var _video = __webpack_require__(73);
                var _video2 = _interopRequireDefault(_video);
                var _code = __webpack_require__(13);
                var _code2 = _interopRequireDefault(_code);
                var _formula = __webpack_require__(74);
                var _formula2 = _interopRequireDefault(_formula);
                var _syntax = __webpack_require__(75);
                var _syntax2 = _interopRequireDefault(_syntax);
                var _toolbar = __webpack_require__(57);
                var _toolbar2 = _interopRequireDefault(_toolbar);
                var _icons = __webpack_require__(41);
                var _icons2 = _interopRequireDefault(_icons);
                var _picker = __webpack_require__(28);
                var _picker2 = _interopRequireDefault(_picker);
                var _colorPicker = __webpack_require__(59);
                var _colorPicker2 = _interopRequireDefault(_colorPicker);
                var _iconPicker = __webpack_require__(60);
                var _iconPicker2 = _interopRequireDefault(_iconPicker);
                var _tooltip = __webpack_require__(61);
                var _tooltip2 = _interopRequireDefault(_tooltip);
                var _bubble = __webpack_require__(108);
                var _bubble2 = _interopRequireDefault(_bubble);
                var _snow = __webpack_require__(62);
                var _snow2 = _interopRequireDefault(_snow);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                _core2.default.register({
                  'attributors/attribute/direction': _direction.DirectionAttribute,
                  'attributors/class/align': _align.AlignClass,
                  'attributors/class/background': _background.BackgroundClass,
                  'attributors/class/color': _color.ColorClass,
                  'attributors/class/direction': _direction.DirectionClass,
                  'attributors/class/font': _font.FontClass,
                  'attributors/class/size': _size.SizeClass,
                  'attributors/style/align': _align.AlignStyle,
                  'attributors/style/background': _background.BackgroundStyle,
                  'attributors/style/color': _color.ColorStyle,
                  'attributors/style/direction': _direction.DirectionStyle,
                  'attributors/style/font': _font.FontStyle,
                  'attributors/style/size': _size.SizeStyle
                }, true);
                _core2.default.register({
                  'formats/align': _align.AlignClass,
                  'formats/direction': _direction.DirectionClass,
                  'formats/indent': _indent.IndentClass,
                  'formats/background': _background.BackgroundStyle,
                  'formats/color': _color.ColorStyle,
                  'formats/font': _font.FontClass,
                  'formats/size': _size.SizeClass,
                  'formats/blockquote': _blockquote2.default,
                  'formats/code-block': _code2.default,
                  'formats/header': _header2.default,
                  'formats/list': _list2.default,
                  'formats/bold': _bold2.default,
                  'formats/code': _code.Code,
                  'formats/italic': _italic2.default,
                  'formats/link': _link2.default,
                  'formats/script': _script2.default,
                  'formats/strike': _strike2.default,
                  'formats/underline': _underline2.default,
                  'formats/image': _image2.default,
                  'formats/video': _video2.default,
                  'formats/list/item': _list.ListItem,
                  'modules/formula': _formula2.default,
                  'modules/syntax': _syntax2.default,
                  'modules/toolbar': _toolbar2.default,
                  'themes/bubble': _bubble2.default,
                  'themes/snow': _snow2.default,
                  'ui/icons': _icons2.default,
                  'ui/picker': _picker2.default,
                  'ui/icon-picker': _iconPicker2.default,
                  'ui/color-picker': _colorPicker2.default,
                  'ui/tooltip': _tooltip2.default
                }, true);
                exports.default = _core2.default;

                /***/
              }, /* 64 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.IndentClass = undefined;
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _get = function get(object, property, receiver) {
                  if (object === null) object = Function.prototype;
                  var desc = Object.getOwnPropertyDescriptor(object, property);
                  if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                      return undefined;
                    } else {
                      return get(parent, property, receiver);
                    }
                  } else if ("value" in desc) {
                    return desc.value;
                  } else {
                    var getter = desc.get;
                    if (getter === undefined) {
                      return undefined;
                    }
                    return getter.call(receiver);
                  }
                };
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var IdentAttributor = function (_Parchment$Attributor) {
                  _inherits(IdentAttributor, _Parchment$Attributor);
                  function IdentAttributor() {
                    _classCallCheck(this, IdentAttributor);
                    return _possibleConstructorReturn(this, (IdentAttributor.__proto__ || Object.getPrototypeOf(IdentAttributor)).apply(this, arguments));
                  }
                  _createClass(IdentAttributor, [{
                    key: 'add',
                    value: function add(node, value) {
                      if (value === '+1' || value === '-1') {
                        var indent = this.value(node) || 0;
                        value = value === '+1' ? indent + 1 : indent - 1;
                      }
                      if (value === 0) {
                        this.remove(node);
                        return true;
                      } else {
                        return _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'add', this).call(this, node, value);
                      }
                    }
                  }, {
                    key: 'canAdd',
                    value: function canAdd(node, value) {
                      return _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'canAdd', this).call(this, node, value) || _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'canAdd', this).call(this, node, parseInt(value));
                    }
                  }, {
                    key: 'value',
                    value: function value(node) {
                      return parseInt(_get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'value', this).call(this, node)) || undefined; // Don't return NaN
                    }
                  }]);

                  return IdentAttributor;
                }(_parchment2.default.Attributor.Class);
                var IndentClass = new IdentAttributor('indent', 'ql-indent', {
                  scope: _parchment2.default.Scope.BLOCK,
                  whitelist: [1, 2, 3, 4, 5, 6, 7, 8]
                });
                exports.IndentClass = IndentClass;

                /***/
              }, /* 65 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var _block = __webpack_require__(4);
                var _block2 = _interopRequireDefault(_block);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var Blockquote = function (_Block) {
                  _inherits(Blockquote, _Block);
                  function Blockquote() {
                    _classCallCheck(this, Blockquote);
                    return _possibleConstructorReturn(this, (Blockquote.__proto__ || Object.getPrototypeOf(Blockquote)).apply(this, arguments));
                  }
                  return Blockquote;
                }(_block2.default);
                Blockquote.blotName = 'blockquote';
                Blockquote.tagName = 'blockquote';
                exports.default = Blockquote;

                /***/
              }, /* 66 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _block = __webpack_require__(4);
                var _block2 = _interopRequireDefault(_block);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var Header = function (_Block) {
                  _inherits(Header, _Block);
                  function Header() {
                    _classCallCheck(this, Header);
                    return _possibleConstructorReturn(this, (Header.__proto__ || Object.getPrototypeOf(Header)).apply(this, arguments));
                  }
                  _createClass(Header, null, [{
                    key: 'formats',
                    value: function formats(domNode) {
                      return this.tagName.indexOf(domNode.tagName) + 1;
                    }
                  }]);
                  return Header;
                }(_block2.default);
                Header.blotName = 'header';
                Header.tagName = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6'];
                exports.default = Header;

                /***/
              }, /* 67 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.default = exports.ListItem = undefined;
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _get = function get(object, property, receiver) {
                  if (object === null) object = Function.prototype;
                  var desc = Object.getOwnPropertyDescriptor(object, property);
                  if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                      return undefined;
                    } else {
                      return get(parent, property, receiver);
                    }
                  } else if ("value" in desc) {
                    return desc.value;
                  } else {
                    var getter = desc.get;
                    if (getter === undefined) {
                      return undefined;
                    }
                    return getter.call(receiver);
                  }
                };
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _block = __webpack_require__(4);
                var _block2 = _interopRequireDefault(_block);
                var _container = __webpack_require__(25);
                var _container2 = _interopRequireDefault(_container);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _defineProperty(obj, key, value) {
                  if (key in obj) {
                    Object.defineProperty(obj, key, {
                      value: value,
                      enumerable: true,
                      configurable: true,
                      writable: true
                    });
                  } else {
                    obj[key] = value;
                  }
                  return obj;
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var ListItem = function (_Block) {
                  _inherits(ListItem, _Block);
                  function ListItem() {
                    _classCallCheck(this, ListItem);
                    return _possibleConstructorReturn(this, (ListItem.__proto__ || Object.getPrototypeOf(ListItem)).apply(this, arguments));
                  }
                  _createClass(ListItem, [{
                    key: 'format',
                    value: function format(name, value) {
                      if (name === List.blotName && !value) {
                        this.replaceWith(_parchment2.default.create(this.statics.scope));
                      } else {
                        _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'format', this).call(this, name, value);
                      }
                    }
                  }, {
                    key: 'remove',
                    value: function remove() {
                      if (this.prev == null && this.next == null) {
                        this.parent.remove();
                      } else {
                        _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'remove', this).call(this);
                      }
                    }
                  }, {
                    key: 'replaceWith',
                    value: function replaceWith(name, value) {
                      this.parent.isolate(this.offset(this.parent), this.length());
                      if (name === this.parent.statics.blotName) {
                        this.parent.replaceWith(name, value);
                        return this;
                      } else {
                        this.parent.unwrap();
                        return _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'replaceWith', this).call(this, name, value);
                      }
                    }
                  }], [{
                    key: 'formats',
                    value: function formats(domNode) {
                      return domNode.tagName === this.tagName ? undefined : _get(ListItem.__proto__ || Object.getPrototypeOf(ListItem), 'formats', this).call(this, domNode);
                    }
                  }]);
                  return ListItem;
                }(_block2.default);
                ListItem.blotName = 'list-item';
                ListItem.tagName = 'LI';
                var List = function (_Container) {
                  _inherits(List, _Container);
                  _createClass(List, null, [{
                    key: 'create',
                    value: function create(value) {
                      var tagName = value === 'ordered' ? 'OL' : 'UL';
                      var node = _get(List.__proto__ || Object.getPrototypeOf(List), 'create', this).call(this, tagName);
                      if (value === 'checked' || value === 'unchecked') {
                        node.setAttribute('data-checked', value === 'checked');
                      }
                      return node;
                    }
                  }, {
                    key: 'formats',
                    value: function formats(domNode) {
                      if (domNode.tagName === 'OL') return 'ordered';
                      if (domNode.tagName === 'UL') {
                        if (domNode.hasAttribute('data-checked')) {
                          return domNode.getAttribute('data-checked') === 'true' ? 'checked' : 'unchecked';
                        } else {
                          return 'bullet';
                        }
                      }
                      return undefined;
                    }
                  }]);
                  function List(domNode) {
                    _classCallCheck(this, List);
                    var _this2 = _possibleConstructorReturn(this, (List.__proto__ || Object.getPrototypeOf(List)).call(this, domNode));
                    var listEventHandler = function listEventHandler(e) {
                      if (e.target.parentNode !== domNode) return;
                      var format = _this2.statics.formats(domNode);
                      var blot = _parchment2.default.find(e.target);
                      if (format === 'checked') {
                        blot.format('list', 'unchecked');
                      } else if (format === 'unchecked') {
                        blot.format('list', 'checked');
                      }
                    };
                    domNode.addEventListener('touchstart', listEventHandler);
                    domNode.addEventListener('mousedown', listEventHandler);
                    return _this2;
                  }
                  _createClass(List, [{
                    key: 'format',
                    value: function format(name, value) {
                      if (this.children.length > 0) {
                        this.children.tail.format(name, value);
                      }
                    }
                  }, {
                    key: 'formats',
                    value: function formats() {
                      // We don't inherit from FormatBlot
                      return _defineProperty({}, this.statics.blotName, this.statics.formats(this.domNode));
                    }
                  }, {
                    key: 'insertBefore',
                    value: function insertBefore(blot, ref) {
                      if (blot instanceof ListItem) {
                        _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'insertBefore', this).call(this, blot, ref);
                      } else {
                        var index = ref == null ? this.length() : ref.offset(this);
                        var after = this.split(index);
                        after.parent.insertBefore(blot, after);
                      }
                    }
                  }, {
                    key: 'optimize',
                    value: function optimize(context) {
                      _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'optimize', this).call(this, context);
                      var next = this.next;
                      if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && next.domNode.tagName === this.domNode.tagName && next.domNode.getAttribute('data-checked') === this.domNode.getAttribute('data-checked')) {
                        next.moveChildren(this);
                        next.remove();
                      }
                    }
                  }, {
                    key: 'replace',
                    value: function replace(target) {
                      if (target.statics.blotName !== this.statics.blotName) {
                        var item = _parchment2.default.create(this.statics.defaultChild);
                        target.moveChildren(item);
                        this.appendChild(item);
                      }
                      _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'replace', this).call(this, target);
                    }
                  }]);
                  return List;
                }(_container2.default);
                List.blotName = 'list';
                List.scope = _parchment2.default.Scope.BLOCK_BLOT;
                List.tagName = ['OL', 'UL'];
                List.defaultChild = 'list-item';
                List.allowedChildren = [ListItem];
                exports.ListItem = ListItem;
                exports.default = List;

                /***/
              }, /* 68 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var _bold = __webpack_require__(56);
                var _bold2 = _interopRequireDefault(_bold);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var Italic = function (_Bold) {
                  _inherits(Italic, _Bold);
                  function Italic() {
                    _classCallCheck(this, Italic);
                    return _possibleConstructorReturn(this, (Italic.__proto__ || Object.getPrototypeOf(Italic)).apply(this, arguments));
                  }
                  return Italic;
                }(_bold2.default);
                Italic.blotName = 'italic';
                Italic.tagName = ['EM', 'I'];
                exports.default = Italic;

                /***/
              }, /* 69 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _get = function get(object, property, receiver) {
                  if (object === null) object = Function.prototype;
                  var desc = Object.getOwnPropertyDescriptor(object, property);
                  if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                      return undefined;
                    } else {
                      return get(parent, property, receiver);
                    }
                  } else if ("value" in desc) {
                    return desc.value;
                  } else {
                    var getter = desc.get;
                    if (getter === undefined) {
                      return undefined;
                    }
                    return getter.call(receiver);
                  }
                };
                var _inline = __webpack_require__(6);
                var _inline2 = _interopRequireDefault(_inline);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var Script = function (_Inline) {
                  _inherits(Script, _Inline);
                  function Script() {
                    _classCallCheck(this, Script);
                    return _possibleConstructorReturn(this, (Script.__proto__ || Object.getPrototypeOf(Script)).apply(this, arguments));
                  }
                  _createClass(Script, null, [{
                    key: 'create',
                    value: function create(value) {
                      if (value === 'super') {
                        return document.createElement('sup');
                      } else if (value === 'sub') {
                        return document.createElement('sub');
                      } else {
                        return _get(Script.__proto__ || Object.getPrototypeOf(Script), 'create', this).call(this, value);
                      }
                    }
                  }, {
                    key: 'formats',
                    value: function formats(domNode) {
                      if (domNode.tagName === 'SUB') return 'sub';
                      if (domNode.tagName === 'SUP') return 'super';
                      return undefined;
                    }
                  }]);
                  return Script;
                }(_inline2.default);
                Script.blotName = 'script';
                Script.tagName = ['SUB', 'SUP'];
                exports.default = Script;

                /***/
              }, /* 70 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var _inline = __webpack_require__(6);
                var _inline2 = _interopRequireDefault(_inline);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var Strike = function (_Inline) {
                  _inherits(Strike, _Inline);
                  function Strike() {
                    _classCallCheck(this, Strike);
                    return _possibleConstructorReturn(this, (Strike.__proto__ || Object.getPrototypeOf(Strike)).apply(this, arguments));
                  }
                  return Strike;
                }(_inline2.default);
                Strike.blotName = 'strike';
                Strike.tagName = 'S';
                exports.default = Strike;

                /***/
              }, /* 71 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var _inline = __webpack_require__(6);
                var _inline2 = _interopRequireDefault(_inline);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var Underline = function (_Inline) {
                  _inherits(Underline, _Inline);
                  function Underline() {
                    _classCallCheck(this, Underline);
                    return _possibleConstructorReturn(this, (Underline.__proto__ || Object.getPrototypeOf(Underline)).apply(this, arguments));
                  }
                  return Underline;
                }(_inline2.default);
                Underline.blotName = 'underline';
                Underline.tagName = 'U';
                exports.default = Underline;

                /***/
              }, /* 72 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _get = function get(object, property, receiver) {
                  if (object === null) object = Function.prototype;
                  var desc = Object.getOwnPropertyDescriptor(object, property);
                  if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                      return undefined;
                    } else {
                      return get(parent, property, receiver);
                    }
                  } else if ("value" in desc) {
                    return desc.value;
                  } else {
                    var getter = desc.get;
                    if (getter === undefined) {
                      return undefined;
                    }
                    return getter.call(receiver);
                  }
                };
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _link = __webpack_require__(27);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var ATTRIBUTES = ['alt', 'height', 'width'];
                var Image = function (_Parchment$Embed) {
                  _inherits(Image, _Parchment$Embed);
                  function Image() {
                    _classCallCheck(this, Image);
                    return _possibleConstructorReturn(this, (Image.__proto__ || Object.getPrototypeOf(Image)).apply(this, arguments));
                  }
                  _createClass(Image, [{
                    key: 'format',
                    value: function format(name, value) {
                      if (ATTRIBUTES.indexOf(name) > -1) {
                        if (value) {
                          this.domNode.setAttribute(name, value);
                        } else {
                          this.domNode.removeAttribute(name);
                        }
                      } else {
                        _get(Image.prototype.__proto__ || Object.getPrototypeOf(Image.prototype), 'format', this).call(this, name, value);
                      }
                    }
                  }], [{
                    key: 'create',
                    value: function create(value) {
                      var node = _get(Image.__proto__ || Object.getPrototypeOf(Image), 'create', this).call(this, value);
                      if (typeof value === 'string') {
                        node.setAttribute('src', this.sanitize(value));
                      }
                      return node;
                    }
                  }, {
                    key: 'formats',
                    value: function formats(domNode) {
                      return ATTRIBUTES.reduce(function (formats, attribute) {
                        if (domNode.hasAttribute(attribute)) {
                          formats[attribute] = domNode.getAttribute(attribute);
                        }
                        return formats;
                      }, {});
                    }
                  }, {
                    key: 'match',
                    value: function match(url) {
                      return /\.(jpe?g|gif|png)$/.test(url) || /^data:image\/.+;base64/.test(url);
                    }
                  }, {
                    key: 'sanitize',
                    value: function sanitize(url) {
                      return (0, _link.sanitize)(url, ['http', 'https', 'data']) ? url : '//:0';
                    }
                  }, {
                    key: 'value',
                    value: function value(domNode) {
                      return domNode.getAttribute('src');
                    }
                  }]);
                  return Image;
                }(_parchment2.default.Embed);
                Image.blotName = 'image';
                Image.tagName = 'IMG';
                exports.default = Image;

                /***/
              }, /* 73 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _get = function get(object, property, receiver) {
                  if (object === null) object = Function.prototype;
                  var desc = Object.getOwnPropertyDescriptor(object, property);
                  if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                      return undefined;
                    } else {
                      return get(parent, property, receiver);
                    }
                  } else if ("value" in desc) {
                    return desc.value;
                  } else {
                    var getter = desc.get;
                    if (getter === undefined) {
                      return undefined;
                    }
                    return getter.call(receiver);
                  }
                };
                var _block = __webpack_require__(4);
                var _link = __webpack_require__(27);
                var _link2 = _interopRequireDefault(_link);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var ATTRIBUTES = ['height', 'width'];
                var Video = function (_BlockEmbed) {
                  _inherits(Video, _BlockEmbed);
                  function Video() {
                    _classCallCheck(this, Video);
                    return _possibleConstructorReturn(this, (Video.__proto__ || Object.getPrototypeOf(Video)).apply(this, arguments));
                  }
                  _createClass(Video, [{
                    key: 'format',
                    value: function format(name, value) {
                      if (ATTRIBUTES.indexOf(name) > -1) {
                        if (value) {
                          this.domNode.setAttribute(name, value);
                        } else {
                          this.domNode.removeAttribute(name);
                        }
                      } else {
                        _get(Video.prototype.__proto__ || Object.getPrototypeOf(Video.prototype), 'format', this).call(this, name, value);
                      }
                    }
                  }], [{
                    key: 'create',
                    value: function create(value) {
                      var node = _get(Video.__proto__ || Object.getPrototypeOf(Video), 'create', this).call(this, value);
                      node.setAttribute('frameborder', '0');
                      node.setAttribute('allowfullscreen', true);
                      node.setAttribute('src', this.sanitize(value));
                      return node;
                    }
                  }, {
                    key: 'formats',
                    value: function formats(domNode) {
                      return ATTRIBUTES.reduce(function (formats, attribute) {
                        if (domNode.hasAttribute(attribute)) {
                          formats[attribute] = domNode.getAttribute(attribute);
                        }
                        return formats;
                      }, {});
                    }
                  }, {
                    key: 'sanitize',
                    value: function sanitize(url) {
                      return _link2.default.sanitize(url);
                    }
                  }, {
                    key: 'value',
                    value: function value(domNode) {
                      return domNode.getAttribute('src');
                    }
                  }]);
                  return Video;
                }(_block.BlockEmbed);
                Video.blotName = 'video';
                Video.className = 'ql-video';
                Video.tagName = 'IFRAME';
                exports.default = Video;

                /***/
              }, /* 74 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.default = exports.FormulaBlot = undefined;
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _get = function get(object, property, receiver) {
                  if (object === null) object = Function.prototype;
                  var desc = Object.getOwnPropertyDescriptor(object, property);
                  if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                      return undefined;
                    } else {
                      return get(parent, property, receiver);
                    }
                  } else if ("value" in desc) {
                    return desc.value;
                  } else {
                    var getter = desc.get;
                    if (getter === undefined) {
                      return undefined;
                    }
                    return getter.call(receiver);
                  }
                };
                var _embed = __webpack_require__(35);
                var _embed2 = _interopRequireDefault(_embed);
                var _quill = __webpack_require__(5);
                var _quill2 = _interopRequireDefault(_quill);
                var _module = __webpack_require__(9);
                var _module2 = _interopRequireDefault(_module);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var FormulaBlot = function (_Embed) {
                  _inherits(FormulaBlot, _Embed);
                  function FormulaBlot() {
                    _classCallCheck(this, FormulaBlot);
                    return _possibleConstructorReturn(this, (FormulaBlot.__proto__ || Object.getPrototypeOf(FormulaBlot)).apply(this, arguments));
                  }
                  _createClass(FormulaBlot, null, [{
                    key: 'create',
                    value: function create(value) {
                      var node = _get(FormulaBlot.__proto__ || Object.getPrototypeOf(FormulaBlot), 'create', this).call(this, value);
                      if (typeof value === 'string') {
                        window.katex.render(value, node, {
                          throwOnError: false,
                          errorColor: '#f00'
                        });
                        node.setAttribute('data-value', value);
                      }
                      return node;
                    }
                  }, {
                    key: 'value',
                    value: function value(domNode) {
                      return domNode.getAttribute('data-value');
                    }
                  }]);
                  return FormulaBlot;
                }(_embed2.default);
                FormulaBlot.blotName = 'formula';
                FormulaBlot.className = 'ql-formula';
                FormulaBlot.tagName = 'SPAN';
                var Formula = function (_Module) {
                  _inherits(Formula, _Module);
                  _createClass(Formula, null, [{
                    key: 'register',
                    value: function register() {
                      _quill2.default.register(FormulaBlot, true);
                    }
                  }]);
                  function Formula() {
                    _classCallCheck(this, Formula);
                    var _this2 = _possibleConstructorReturn(this, (Formula.__proto__ || Object.getPrototypeOf(Formula)).call(this));
                    if (window.katex == null) {
                      throw new Error('Formula module requires KaTeX.');
                    }
                    return _this2;
                  }
                  return Formula;
                }(_module2.default);
                exports.FormulaBlot = FormulaBlot;
                exports.default = Formula;

                /***/
              }, /* 75 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.default = exports.CodeToken = exports.CodeBlock = undefined;
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _get = function get(object, property, receiver) {
                  if (object === null) object = Function.prototype;
                  var desc = Object.getOwnPropertyDescriptor(object, property);
                  if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                      return undefined;
                    } else {
                      return get(parent, property, receiver);
                    }
                  } else if ("value" in desc) {
                    return desc.value;
                  } else {
                    var getter = desc.get;
                    if (getter === undefined) {
                      return undefined;
                    }
                    return getter.call(receiver);
                  }
                };
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _quill = __webpack_require__(5);
                var _quill2 = _interopRequireDefault(_quill);
                var _module = __webpack_require__(9);
                var _module2 = _interopRequireDefault(_module);
                var _code = __webpack_require__(13);
                var _code2 = _interopRequireDefault(_code);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var SyntaxCodeBlock = function (_CodeBlock) {
                  _inherits(SyntaxCodeBlock, _CodeBlock);
                  function SyntaxCodeBlock() {
                    _classCallCheck(this, SyntaxCodeBlock);
                    return _possibleConstructorReturn(this, (SyntaxCodeBlock.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock)).apply(this, arguments));
                  }
                  _createClass(SyntaxCodeBlock, [{
                    key: 'replaceWith',
                    value: function replaceWith(block) {
                      this.domNode.textContent = this.domNode.textContent;
                      this.attach();
                      _get(SyntaxCodeBlock.prototype.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock.prototype), 'replaceWith', this).call(this, block);
                    }
                  }, {
                    key: 'highlight',
                    value: function highlight(_highlight) {
                      var text = this.domNode.textContent;
                      if (this.cachedText !== text) {
                        if (text.trim().length > 0 || this.cachedText == null) {
                          this.domNode.innerHTML = _highlight(text);
                          this.domNode.normalize();
                          this.attach();
                        }
                        this.cachedText = text;
                      }
                    }
                  }]);
                  return SyntaxCodeBlock;
                }(_code2.default);
                SyntaxCodeBlock.className = 'ql-syntax';
                var CodeToken = new _parchment2.default.Attributor.Class('token', 'hljs', {
                  scope: _parchment2.default.Scope.INLINE
                });
                var Syntax = function (_Module) {
                  _inherits(Syntax, _Module);
                  _createClass(Syntax, null, [{
                    key: 'register',
                    value: function register() {
                      _quill2.default.register(CodeToken, true);
                      _quill2.default.register(SyntaxCodeBlock, true);
                    }
                  }]);
                  function Syntax(quill, options) {
                    _classCallCheck(this, Syntax);
                    var _this2 = _possibleConstructorReturn(this, (Syntax.__proto__ || Object.getPrototypeOf(Syntax)).call(this, quill, options));
                    if (typeof _this2.options.highlight !== 'function') {
                      throw new Error('Syntax module requires highlight.js. Please include the library on the page before Quill.');
                    }
                    var timer = null;
                    _this2.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function () {
                      clearTimeout(timer);
                      timer = setTimeout(function () {
                        _this2.highlight();
                        timer = null;
                      }, _this2.options.interval);
                    });
                    _this2.highlight();
                    return _this2;
                  }
                  _createClass(Syntax, [{
                    key: 'highlight',
                    value: function highlight() {
                      var _this3 = this;
                      if (this.quill.selection.composing) return;
                      this.quill.update(_quill2.default.sources.USER);
                      var range = this.quill.getSelection();
                      this.quill.scroll.descendants(SyntaxCodeBlock).forEach(function (code) {
                        code.highlight(_this3.options.highlight);
                      });
                      this.quill.update(_quill2.default.sources.SILENT);
                      if (range != null) {
                        this.quill.setSelection(range, _quill2.default.sources.SILENT);
                      }
                    }
                  }]);
                  return Syntax;
                }(_module2.default);
                Syntax.DEFAULTS = {
                  highlight: function () {
                    if (window.hljs == null) return null;
                    return function (text) {
                      var result = window.hljs.highlightAuto(text);
                      return result.value;
                    };
                  }(),
                  interval: 1000
                };
                exports.CodeBlock = SyntaxCodeBlock;
                exports.CodeToken = CodeToken;
                exports.default = Syntax;

                /***/
              }, /* 76 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=13 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=9 y1=4 y2=4></line> </svg>";

                /***/
              }, /* 77 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=14 x2=4 y1=14 y2=14></line> <line class=ql-stroke x1=12 x2=6 y1=4 y2=4></line> </svg>";

                /***/
              }, /* 78 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=5 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=9 y1=4 y2=4></line> </svg>";

                /***/
              }, /* 79 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=3 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=3 y1=4 y2=4></line> </svg>";

                /***/
              }, /* 80 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <g class=\"ql-fill ql-color-label\"> <polygon points=\"6 6.868 6 6 5 6 5 7 5.942 7 6 6.868\"></polygon> <rect height=1 width=1 x=4 y=4></rect> <polygon points=\"6.817 5 6 5 6 6 6.38 6 6.817 5\"></polygon> <rect height=1 width=1 x=2 y=6></rect> <rect height=1 width=1 x=3 y=5></rect> <rect height=1 width=1 x=4 y=7></rect> <polygon points=\"4 11.439 4 11 3 11 3 12 3.755 12 4 11.439\"></polygon> <rect height=1 width=1 x=2 y=12></rect> <rect height=1 width=1 x=2 y=9></rect> <rect height=1 width=1 x=2 y=15></rect> <polygon points=\"4.63 10 4 10 4 11 4.192 11 4.63 10\"></polygon> <rect height=1 width=1 x=3 y=8></rect> <path d=M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z></path> <path d=M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z></path> <path d=M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z></path> <rect height=1 width=1 x=12 y=2></rect> <rect height=1 width=1 x=11 y=3></rect> <path d=M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z></path> <rect height=1 width=1 x=2 y=3></rect> <rect height=1 width=1 x=6 y=2></rect> <rect height=1 width=1 x=3 y=2></rect> <rect height=1 width=1 x=5 y=3></rect> <rect height=1 width=1 x=9 y=2></rect> <rect height=1 width=1 x=15 y=14></rect> <polygon points=\"13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174\"></polygon> <rect height=1 width=1 x=13 y=7></rect> <rect height=1 width=1 x=15 y=5></rect> <rect height=1 width=1 x=14 y=6></rect> <rect height=1 width=1 x=15 y=8></rect> <rect height=1 width=1 x=14 y=9></rect> <path d=M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z></path> <rect height=1 width=1 x=14 y=3></rect> <polygon points=\"12 6.868 12 6 11.62 6 12 6.868\"></polygon> <rect height=1 width=1 x=15 y=2></rect> <rect height=1 width=1 x=12 y=5></rect> <rect height=1 width=1 x=13 y=4></rect> <polygon points=\"12.933 9 13 9 13 8 12.495 8 12.933 9\"></polygon> <rect height=1 width=1 x=9 y=14></rect> <rect height=1 width=1 x=8 y=15></rect> <path d=M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z></path> <rect height=1 width=1 x=5 y=15></rect> <path d=M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z></path> <rect height=1 width=1 x=11 y=15></rect> <path d=M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z></path> <rect height=1 width=1 x=14 y=15></rect> <rect height=1 width=1 x=15 y=11></rect> </g> <polyline class=ql-stroke points=\"5.5 13 9 5 12.5 13\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=11 y2=11></line> </svg>";

                /***/
              }, /* 81 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=4 y=5></rect> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=11 y=5></rect> <path class=\"ql-even ql-fill ql-stroke\" d=M7,8c0,4.031-3,5-3,5></path> <path class=\"ql-even ql-fill ql-stroke\" d=M14,8c0,4.031-3,5-3,5></path> </svg>";

                /***/
              }, /* 82 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z></path> <path class=ql-stroke d=M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z></path> </svg>";

                /***/
              }, /* 83 */
              /***/function (module, exports) {
                module.exports = "<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=5 x2=13 y1=3 y2=3></line> <line class=ql-stroke x1=6 x2=9.35 y1=12 y2=3></line> <line class=ql-stroke x1=11 x2=15 y1=11 y2=15></line> <line class=ql-stroke x1=15 x2=11 y1=11 y2=15></line> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=7 x=2 y=14></rect> </svg>";

                /***/
              }, /* 84 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=\"ql-color-label ql-stroke ql-transparent\" x1=3 x2=15 y1=15 y2=15></line> <polyline class=ql-stroke points=\"5.5 11 9 3 12.5 11\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=9 y2=9></line> </svg>";

                /***/
              }, /* 85 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"3 11 5 9 3 7 3 11\"></polygon> <line class=\"ql-stroke ql-fill\" x1=15 x2=11 y1=4 y2=4></line> <path class=ql-fill d=M11,3a3,3,0,0,0,0,6h1V3H11Z></path> <rect class=ql-fill height=11 width=1 x=11 y=4></rect> <rect class=ql-fill height=11 width=1 x=13 y=4></rect> </svg>";

                /***/
              }, /* 86 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"15 12 13 10 15 8 15 12\"></polygon> <line class=\"ql-stroke ql-fill\" x1=9 x2=5 y1=4 y2=4></line> <path class=ql-fill d=M5,3A3,3,0,0,0,5,9H6V3H5Z></path> <rect class=ql-fill height=11 width=1 x=5 y=4></rect> <rect class=ql-fill height=11 width=1 x=7 y=4></rect> </svg>";

                /***/
              }, /* 87 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M14,16H4a1,1,0,0,1,0-2H14A1,1,0,0,1,14,16Z /> <path class=ql-fill d=M14,4H4A1,1,0,0,1,4,2H14A1,1,0,0,1,14,4Z /> <rect class=ql-fill x=3 y=6 width=12 height=6 rx=1 ry=1 /> </svg>";

                /***/
              }, /* 88 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M13,16H5a1,1,0,0,1,0-2h8A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H5A1,1,0,0,1,5,2h8A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=2 y=6 width=14 height=6 rx=1 ry=1 /> </svg>";

                /***/
              }, /* 89 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15,8H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,8Z /> <path class=ql-fill d=M15,12H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,12Z /> <path class=ql-fill d=M15,16H5a1,1,0,0,1,0-2H15A1,1,0,0,1,15,16Z /> <path class=ql-fill d=M15,4H5A1,1,0,0,1,5,2H15A1,1,0,0,1,15,4Z /> <rect class=ql-fill x=2 y=6 width=8 height=6 rx=1 ry=1 /> </svg>";

                /***/
              }, /* 90 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M5,8H3A1,1,0,0,1,3,6H5A1,1,0,0,1,5,8Z /> <path class=ql-fill d=M5,12H3a1,1,0,0,1,0-2H5A1,1,0,0,1,5,12Z /> <path class=ql-fill d=M13,16H3a1,1,0,0,1,0-2H13A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H3A1,1,0,0,1,3,2H13A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=8 y=6 width=8 height=6 rx=1 ry=1 transform=\"translate(24 18) rotate(-180)\"/> </svg>";

                /***/
              }, /* 91 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z></path> <rect class=ql-fill height=1.6 rx=0.8 ry=0.8 width=5 x=5.15 y=6.2></rect> <path class=ql-fill d=M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z></path> </svg>";

                /***/
              }, /* 92 */
              /***/function (module, exports) {
                module.exports = "<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z /> </svg>";

                /***/
              }, /* 93 */
              /***/function (module, exports) {
                module.exports = "<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z /> </svg>";

                /***/
              }, /* 94 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=13 y1=4 y2=4></line> <line class=ql-stroke x1=5 x2=11 y1=14 y2=14></line> <line class=ql-stroke x1=8 x2=10 y1=14 y2=4></line> </svg>";

                /***/
              }, /* 95 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=10 width=12 x=3 y=4></rect> <circle class=ql-fill cx=6 cy=7 r=1></circle> <polyline class=\"ql-even ql-fill\" points=\"5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12\"></polyline> </svg>";

                /***/
              }, /* 96 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=\"ql-fill ql-stroke\" points=\"3 7 3 11 5 9 3 7\"></polyline> </svg>";

                /***/
              }, /* 97 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"5 7 5 11 3 9 5 7\"></polyline> </svg>";

                /***/
              }, /* 98 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=11 y1=7 y2=11></line> <path class=\"ql-even ql-stroke\" d=M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z></path> <path class=\"ql-even ql-stroke\" d=M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z></path> </svg>";

                /***/
              }, /* 99 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=7 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=7 x2=15 y1=14 y2=14></line> <line class=\"ql-stroke ql-thin\" x1=2.5 x2=4.5 y1=5.5 y2=5.5></line> <path class=ql-fill d=M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z></path> <path class=\"ql-stroke ql-thin\" d=M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156></path> <path class=\"ql-stroke ql-thin\" d=M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109></path> </svg>";

                /***/
              }, /* 100 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=6 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=6 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=6 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=3 y1=4 y2=4></line> <line class=ql-stroke x1=3 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=3 y1=14 y2=14></line> </svg>";

                /***/
              }, /* 101 */
              /***/function (module, exports) {
                module.exports = "<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=9 x2=15 y1=4 y2=4></line> <polyline class=ql-stroke points=\"3 4 4 5 6 3\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=14 y2=14></line> <polyline class=ql-stroke points=\"3 14 4 15 6 13\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"3 9 4 10 6 8\"></polyline> </svg>";

                /***/
              }, /* 102 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z /> <path class=ql-fill d=M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z /> </svg>";

                /***/
              }, /* 103 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z /> <path class=ql-fill d=M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z /> </svg>";

                /***/
              }, /* 104 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=\"ql-stroke ql-thin\" x1=15.5 x2=2.5 y1=8.5 y2=9.5></line> <path class=ql-fill d=M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z></path> <path class=ql-fill d=M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z></path> </svg>";

                /***/
              }, /* 105 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3></path> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=12 x=3 y=15></rect> </svg>";

                /***/
              }, /* 106 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=12 width=12 x=3 y=3></rect> <rect class=ql-fill height=12 width=1 x=5 y=3></rect> <rect class=ql-fill height=12 width=1 x=12 y=3></rect> <rect class=ql-fill height=2 width=8 x=5 y=8></rect> <rect class=ql-fill height=1 width=3 x=3 y=5></rect> <rect class=ql-fill height=1 width=3 x=3 y=7></rect> <rect class=ql-fill height=1 width=3 x=3 y=10></rect> <rect class=ql-fill height=1 width=3 x=3 y=12></rect> <rect class=ql-fill height=1 width=3 x=12 y=5></rect> <rect class=ql-fill height=1 width=3 x=12 y=7></rect> <rect class=ql-fill height=1 width=3 x=12 y=10></rect> <rect class=ql-fill height=1 width=3 x=12 y=12></rect> </svg>";

                /***/
              }, /* 107 */
              /***/function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <polygon class=ql-stroke points=\"7 11 9 13 11 11 7 11\"></polygon> <polygon class=ql-stroke points=\"7 7 9 5 11 7 7 7\"></polygon> </svg>";

                /***/
              }, /* 108 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.default = exports.BubbleTooltip = undefined;
                var _get = function get(object, property, receiver) {
                  if (object === null) object = Function.prototype;
                  var desc = Object.getOwnPropertyDescriptor(object, property);
                  if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                      return undefined;
                    } else {
                      return get(parent, property, receiver);
                    }
                  } else if ("value" in desc) {
                    return desc.value;
                  } else {
                    var getter = desc.get;
                    if (getter === undefined) {
                      return undefined;
                    }
                    return getter.call(receiver);
                  }
                };
                var _createClass = function () {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function (Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                var _extend = __webpack_require__(3);
                var _extend2 = _interopRequireDefault(_extend);
                var _emitter = __webpack_require__(8);
                var _emitter2 = _interopRequireDefault(_emitter);
                var _base = __webpack_require__(43);
                var _base2 = _interopRequireDefault(_base);
                var _selection = __webpack_require__(15);
                var _icons = __webpack_require__(41);
                var _icons2 = _interopRequireDefault(_icons);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    default: obj
                  };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self, call) {
                  if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var TOOLBAR_CONFIG = [['bold', 'italic', 'link'], [{
                  header: 1
                }, {
                  header: 2
                }, 'blockquote']];
                var BubbleTheme = function (_BaseTheme) {
                  _inherits(BubbleTheme, _BaseTheme);
                  function BubbleTheme(quill, options) {
                    _classCallCheck(this, BubbleTheme);
                    if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
                      options.modules.toolbar.container = TOOLBAR_CONFIG;
                    }
                    var _this = _possibleConstructorReturn(this, (BubbleTheme.__proto__ || Object.getPrototypeOf(BubbleTheme)).call(this, quill, options));
                    _this.quill.container.classList.add('ql-bubble');
                    return _this;
                  }
                  _createClass(BubbleTheme, [{
                    key: 'extendToolbar',
                    value: function extendToolbar(toolbar) {
                      this.tooltip = new BubbleTooltip(this.quill, this.options.bounds);
                      this.tooltip.root.appendChild(toolbar.container);
                      this.buildButtons([].slice.call(toolbar.container.querySelectorAll('button')), _icons2.default);
                      this.buildPickers([].slice.call(toolbar.container.querySelectorAll('select')), _icons2.default);
                    }
                  }]);
                  return BubbleTheme;
                }(_base2.default);
                BubbleTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {
                  modules: {
                    toolbar: {
                      handlers: {
                        link: function link(value) {
                          if (!value) {
                            this.quill.format('link', false);
                          } else {
                            this.quill.theme.tooltip.edit();
                          }
                        }
                      }
                    }
                  }
                });
                var BubbleTooltip = function (_BaseTooltip) {
                  _inherits(BubbleTooltip, _BaseTooltip);
                  function BubbleTooltip(quill, bounds) {
                    _classCallCheck(this, BubbleTooltip);
                    var _this2 = _possibleConstructorReturn(this, (BubbleTooltip.__proto__ || Object.getPrototypeOf(BubbleTooltip)).call(this, quill, bounds));
                    _this2.quill.on(_emitter2.default.events.EDITOR_CHANGE, function (type, range, oldRange, source) {
                      if (type !== _emitter2.default.events.SELECTION_CHANGE) return;
                      if (range != null && range.length > 0 && source === _emitter2.default.sources.USER) {
                        _this2.show();
                        // Lock our width so we will expand beyond our offsetParent boundaries
                        _this2.root.style.left = '0px';
                        _this2.root.style.width = '';
                        _this2.root.style.width = _this2.root.offsetWidth + 'px';
                        var lines = _this2.quill.getLines(range.index, range.length);
                        if (lines.length === 1) {
                          _this2.position(_this2.quill.getBounds(range));
                        } else {
                          var lastLine = lines[lines.length - 1];
                          var index = _this2.quill.getIndex(lastLine);
                          var length = Math.min(lastLine.length() - 1, range.index + range.length - index);
                          var _bounds = _this2.quill.getBounds(new _selection.Range(index, length));
                          _this2.position(_bounds);
                        }
                      } else if (document.activeElement !== _this2.textbox && _this2.quill.hasFocus()) {
                        _this2.hide();
                      }
                    });
                    return _this2;
                  }
                  _createClass(BubbleTooltip, [{
                    key: 'listen',
                    value: function listen() {
                      var _this3 = this;
                      _get(BubbleTooltip.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip.prototype), 'listen', this).call(this);
                      this.root.querySelector('.ql-close').addEventListener('click', function () {
                        _this3.root.classList.remove('ql-editing');
                      });
                      this.quill.on(_emitter2.default.events.SCROLL_OPTIMIZE, function () {
                        // Let selection be restored by toolbar handlers before repositioning
                        setTimeout(function () {
                          if (_this3.root.classList.contains('ql-hidden')) return;
                          var range = _this3.quill.getSelection();
                          if (range != null) {
                            _this3.position(_this3.quill.getBounds(range));
                          }
                        }, 1);
                      });
                    }
                  }, {
                    key: 'cancel',
                    value: function cancel() {
                      this.show();
                    }
                  }, {
                    key: 'position',
                    value: function position(reference) {
                      var shift = _get(BubbleTooltip.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip.prototype), 'position', this).call(this, reference);
                      var arrow = this.root.querySelector('.ql-tooltip-arrow');
                      arrow.style.marginLeft = '';
                      if (shift === 0) return shift;
                      arrow.style.marginLeft = -1 * shift - arrow.offsetWidth / 2 + 'px';
                    }
                  }]);
                  return BubbleTooltip;
                }(_base.BaseTooltip);
                BubbleTooltip.TEMPLATE = ['<span class="ql-tooltip-arrow"></span>', '<div class="ql-tooltip-editor">', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-close"></a>', '</div>'].join('');
                exports.BubbleTooltip = BubbleTooltip;
                exports.default = BubbleTheme;

                /***/
              }, /* 109 */
              /***/function (module, exports, __webpack_require__) {
                module.exports = __webpack_require__(63);

                /***/
              }
              /******/])["default"]
            );
          });
        })(quill);
        var quillExports = quill.exports;
        const Quill = /*@__PURE__*/getDefaultExportFromCjs(quillExports);

        /*
        React-Quill
        https://github.com/zenoamaro/react-quill
        */
        var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
          var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf || {
              __proto__: []
            } instanceof Array && function (d, b) {
              d.__proto__ = b;
            } || function (d, b) {
              for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };
            return extendStatics(d, b);
          };
          return function (d, b) {
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var __assign$1 = commonjsGlobal && commonjsGlobal.__assign || function () {
          __assign$1 = Object.assign || function (t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
          };
          return __assign$1.apply(this, arguments);
        };
        var __spreadArrays = commonjsGlobal && commonjsGlobal.__spreadArrays || function () {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
          return r;
        };
        var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
          return mod && mod.__esModule ? mod : {
            "default": mod
          };
        };
        var react_1 = __importDefault(reactExports);
        var react_dom_1 = __importDefault(reactDomExports);
        var isEqual_1 = __importDefault(isEqual_1$1);
        var quill_1 = __importDefault(quillExports);
        var ReactQuill = /** @class */function (_super) {
          __extends(ReactQuill, _super);
          function ReactQuill(props) {
            var _this = _super.call(this, props) || this;
            /*
            Changing one of these props should cause a full re-render and a
            re-instantiation of the Quill editor.
            */
            _this.dirtyProps = ['modules', 'formats', 'bounds', 'theme', 'children'];
            /*
            Changing one of these props should cause a regular update. These are mostly
            props that act on the container, rather than the quillized editing area.
            */
            _this.cleanProps = ['id', 'className', 'style', 'placeholder', 'tabIndex', 'onChange', 'onChangeSelection', 'onFocus', 'onBlur', 'onKeyPress', 'onKeyDown', 'onKeyUp'];
            _this.state = {
              generation: 0
            };
            /*
            Tracks the internal selection of the Quill editor
            */
            _this.selection = null;
            _this.onEditorChange = function (eventName, rangeOrDelta, oldRangeOrDelta, source) {
              var _a, _b, _c, _d;
              if (eventName === 'text-change') {
                (_b = (_a = _this).onEditorChangeText) === null || _b === void 0 ? void 0 : _b.call(_a, _this.editor.root.innerHTML, rangeOrDelta, source, _this.unprivilegedEditor);
              } else if (eventName === 'selection-change') {
                (_d = (_c = _this).onEditorChangeSelection) === null || _d === void 0 ? void 0 : _d.call(_c, rangeOrDelta, source, _this.unprivilegedEditor);
              }
            };
            var value = _this.isControlled() ? props.value : props.defaultValue;
            _this.value = value !== null && value !== void 0 ? value : '';
            return _this;
          }
          ReactQuill.prototype.validateProps = function (props) {
            var _a;
            if (react_1.default.Children.count(props.children) > 1) throw new Error('The Quill editing area can only be composed of a single React element.');
            if (react_1.default.Children.count(props.children)) {
              var child = react_1.default.Children.only(props.children);
              if (((_a = child) === null || _a === void 0 ? void 0 : _a.type) === 'textarea') throw new Error('Quill does not support editing on a <textarea>. Use a <div> instead.');
            }
            if (this.lastDeltaChangeSet && props.value === this.lastDeltaChangeSet) throw new Error('You are passing the `delta` object from the `onChange` event back ' + 'as `value`. You most probably want `editor.getContents()` instead. ' + 'See: https://github.com/zenoamaro/react-quill#using-deltas');
          };
          ReactQuill.prototype.shouldComponentUpdate = function (nextProps, nextState) {
            var _this = this;
            var _a;
            this.validateProps(nextProps);
            // If the editor hasn't been instantiated yet, or the component has been
            // regenerated, we already know we should update.
            if (!this.editor || this.state.generation !== nextState.generation) {
              return true;
            }
            // Handle value changes in-place
            if ('value' in nextProps) {
              var prevContents = this.getEditorContents();
              var nextContents = (_a = nextProps.value, _a !== null && _a !== void 0 ? _a : '');
              // NOTE: Seeing that Quill is missing a way to prevent edits, we have to
              //       settle for a hybrid between controlled and uncontrolled mode. We
              //       can't prevent the change, but we'll still override content
              //       whenever `value` differs from current state.
              // NOTE: Comparing an HTML string and a Quill Delta will always trigger a
              //       change, regardless of whether they represent the same document.
              if (!this.isEqualValue(nextContents, prevContents)) {
                this.setEditorContents(this.editor, nextContents);
              }
            }
            // Handle read-only changes in-place
            if (nextProps.readOnly !== this.props.readOnly) {
              this.setEditorReadOnly(this.editor, nextProps.readOnly);
            }
            // Clean and Dirty props require a render
            return __spreadArrays(this.cleanProps, this.dirtyProps).some(function (prop) {
              return !isEqual_1.default(nextProps[prop], _this.props[prop]);
            });
          };
          ReactQuill.prototype.shouldComponentRegenerate = function (nextProps) {
            var _this = this;
            // Whenever a `dirtyProp` changes, the editor needs reinstantiation.
            return this.dirtyProps.some(function (prop) {
              return !isEqual_1.default(nextProps[prop], _this.props[prop]);
            });
          };
          ReactQuill.prototype.componentDidMount = function () {
            this.instantiateEditor();
            this.setEditorContents(this.editor, this.getEditorContents());
          };
          ReactQuill.prototype.componentWillUnmount = function () {
            this.destroyEditor();
          };
          ReactQuill.prototype.componentDidUpdate = function (prevProps, prevState) {
            var _this = this;
            // If we're changing one of the `dirtyProps`, the entire Quill Editor needs
            // to be re-instantiated. Regenerating the editor will cause the whole tree,
            // including the container, to be cleaned up and re-rendered from scratch.
            // Store the contents so they can be restored later.
            if (this.editor && this.shouldComponentRegenerate(prevProps)) {
              var delta = this.editor.getContents();
              var selection = this.editor.getSelection();
              this.regenerationSnapshot = {
                delta: delta,
                selection: selection
              };
              this.setState({
                generation: this.state.generation + 1
              });
              this.destroyEditor();
            }
            // The component has been regenerated, so it must be re-instantiated, and
            // its content must be restored to the previous values from the snapshot.
            if (this.state.generation !== prevState.generation) {
              var _a = this.regenerationSnapshot,
                delta = _a.delta,
                selection_1 = _a.selection;
              delete this.regenerationSnapshot;
              this.instantiateEditor();
              var editor_1 = this.editor;
              editor_1.setContents(delta);
              postpone(function () {
                return _this.setEditorSelection(editor_1, selection_1);
              });
            }
          };
          ReactQuill.prototype.instantiateEditor = function () {
            if (this.editor) {
              this.hookEditor(this.editor);
            } else {
              this.editor = this.createEditor(this.getEditingArea(), this.getEditorConfig());
            }
          };
          ReactQuill.prototype.destroyEditor = function () {
            if (!this.editor) return;
            this.unhookEditor(this.editor);
          };
          /*
          We consider the component to be controlled if `value` is being sent in props.
          */
          ReactQuill.prototype.isControlled = function () {
            return 'value' in this.props;
          };
          ReactQuill.prototype.getEditorConfig = function () {
            return {
              bounds: this.props.bounds,
              formats: this.props.formats,
              modules: this.props.modules,
              placeholder: this.props.placeholder,
              readOnly: this.props.readOnly,
              scrollingContainer: this.props.scrollingContainer,
              tabIndex: this.props.tabIndex,
              theme: this.props.theme
            };
          };
          ReactQuill.prototype.getEditor = function () {
            if (!this.editor) throw new Error('Accessing non-instantiated editor');
            return this.editor;
          };
          /**
          Creates an editor on the given element. The editor will be passed the
          configuration, have its events bound,
          */
          ReactQuill.prototype.createEditor = function (element, config) {
            var editor = new quill_1.default(element, config);
            if (config.tabIndex != null) {
              this.setEditorTabIndex(editor, config.tabIndex);
            }
            this.hookEditor(editor);
            return editor;
          };
          ReactQuill.prototype.hookEditor = function (editor) {
            // Expose the editor on change events via a weaker, unprivileged proxy
            // object that does not allow accidentally modifying editor state.
            this.unprivilegedEditor = this.makeUnprivilegedEditor(editor);
            // Using `editor-change` allows picking up silent updates, like selection
            // changes on typing.
            editor.on('editor-change', this.onEditorChange);
          };
          ReactQuill.prototype.unhookEditor = function (editor) {
            editor.off('editor-change', this.onEditorChange);
          };
          ReactQuill.prototype.getEditorContents = function () {
            return this.value;
          };
          ReactQuill.prototype.getEditorSelection = function () {
            return this.selection;
          };
          /*
          True if the value is a Delta instance or a Delta look-alike.
          */
          ReactQuill.prototype.isDelta = function (value) {
            return value && value.ops;
          };
          /*
          Special comparison function that knows how to compare Deltas.
          */
          ReactQuill.prototype.isEqualValue = function (value, nextValue) {
            if (this.isDelta(value) && this.isDelta(nextValue)) {
              return isEqual_1.default(value.ops, nextValue.ops);
            } else {
              return isEqual_1.default(value, nextValue);
            }
          };
          /*
          Replace the contents of the editor, but keep the previous selection hanging
          around so that the cursor won't move.
          */
          ReactQuill.prototype.setEditorContents = function (editor, value) {
            var _this = this;
            this.value = value;
            var sel = this.getEditorSelection();
            if (typeof value === 'string') {
              editor.setContents(editor.clipboard.convert(value));
            } else {
              editor.setContents(value);
            }
            postpone(function () {
              return _this.setEditorSelection(editor, sel);
            });
          };
          ReactQuill.prototype.setEditorSelection = function (editor, range) {
            this.selection = range;
            if (range) {
              // Validate bounds before applying.
              var length_1 = editor.getLength();
              range.index = Math.max(0, Math.min(range.index, length_1 - 1));
              range.length = Math.max(0, Math.min(range.length, length_1 - 1 - range.index));
              editor.setSelection(range);
            }
          };
          ReactQuill.prototype.setEditorTabIndex = function (editor, tabIndex) {
            var _a, _b;
            if ((_b = (_a = editor) === null || _a === void 0 ? void 0 : _a.scroll) === null || _b === void 0 ? void 0 : _b.domNode) {
              editor.scroll.domNode.tabIndex = tabIndex;
            }
          };
          ReactQuill.prototype.setEditorReadOnly = function (editor, value) {
            if (value) {
              editor.disable();
            } else {
              editor.enable();
            }
          };
          /*
          Returns a weaker, unprivileged proxy object that only exposes read-only
          accessors found on the editor instance, without any state-modifying methods.
          */
          ReactQuill.prototype.makeUnprivilegedEditor = function (editor) {
            var e = editor;
            return {
              getHTML: function () {
                return e.root.innerHTML;
              },
              getLength: e.getLength.bind(e),
              getText: e.getText.bind(e),
              getContents: e.getContents.bind(e),
              getSelection: e.getSelection.bind(e),
              getBounds: e.getBounds.bind(e)
            };
          };
          ReactQuill.prototype.getEditingArea = function () {
            if (!this.editingArea) {
              throw new Error('Instantiating on missing editing area');
            }
            var element = react_dom_1.default.findDOMNode(this.editingArea);
            if (!element) {
              throw new Error('Cannot find element for editing area');
            }
            if (element.nodeType === 3) {
              throw new Error('Editing area cannot be a text node');
            }
            return element;
          };
          /*
          Renders an editor area, unless it has been provided one to clone.
          */
          ReactQuill.prototype.renderEditingArea = function () {
            var _this = this;
            var _a = this.props,
              children = _a.children,
              preserveWhitespace = _a.preserveWhitespace;
            var generation = this.state.generation;
            var properties = {
              key: generation,
              ref: function (instance) {
                _this.editingArea = instance;
              }
            };
            if (react_1.default.Children.count(children)) {
              return react_1.default.cloneElement(react_1.default.Children.only(children), properties);
            }
            return preserveWhitespace ? react_1.default.createElement("pre", __assign$1({}, properties)) : react_1.default.createElement("div", __assign$1({}, properties));
          };
          ReactQuill.prototype.render = function () {
            var _a;
            return react_1.default.createElement("div", {
              id: this.props.id,
              style: this.props.style,
              key: this.state.generation,
              className: "quill " + (_a = this.props.className, _a !== null && _a !== void 0 ? _a : ''),
              onKeyPress: this.props.onKeyPress,
              onKeyDown: this.props.onKeyDown,
              onKeyUp: this.props.onKeyUp
            }, this.renderEditingArea());
          };
          ReactQuill.prototype.onEditorChangeText = function (value, delta, source, editor) {
            var _a, _b;
            if (!this.editor) return;
            // We keep storing the same type of value as what the user gives us,
            // so that value comparisons will be more stable and predictable.
            var nextContents = this.isDelta(this.value) ? editor.getContents() : editor.getHTML();
            if (nextContents !== this.getEditorContents()) {
              // Taint this `delta` object, so we can recognize whether the user
              // is trying to send it back as `value`, preventing a likely loop.
              this.lastDeltaChangeSet = delta;
              this.value = nextContents;
              (_b = (_a = this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, value, delta, source, editor);
            }
          };
          ReactQuill.prototype.onEditorChangeSelection = function (nextSelection, source, editor) {
            var _a, _b, _c, _d, _e, _f;
            if (!this.editor) return;
            var currentSelection = this.getEditorSelection();
            var hasGainedFocus = !currentSelection && nextSelection;
            var hasLostFocus = currentSelection && !nextSelection;
            if (isEqual_1.default(nextSelection, currentSelection)) return;
            this.selection = nextSelection;
            (_b = (_a = this.props).onChangeSelection) === null || _b === void 0 ? void 0 : _b.call(_a, nextSelection, source, editor);
            if (hasGainedFocus) {
              (_d = (_c = this.props).onFocus) === null || _d === void 0 ? void 0 : _d.call(_c, nextSelection, source, editor);
            } else if (hasLostFocus) {
              (_f = (_e = this.props).onBlur) === null || _f === void 0 ? void 0 : _f.call(_e, currentSelection, source, editor);
            }
          };
          ReactQuill.prototype.focus = function () {
            if (!this.editor) return;
            this.editor.focus();
          };
          ReactQuill.prototype.blur = function () {
            if (!this.editor) return;
            this.selection = null;
            this.editor.blur();
          };
          ReactQuill.displayName = 'React Quill';
          /*
          Export Quill to be able to call `register`
          */
          ReactQuill.Quill = quill_1.default;
          ReactQuill.defaultProps = {
            theme: 'snow',
            modules: {},
            readOnly: false
          };
          return ReactQuill;
        }(react_1.default.Component);
        /*
        Small helper to execute a function in the next micro-tick.
        */
        function postpone(fn) {
          Promise.resolve().then(fn);
        }
        var lib$1 = ReactQuill;
        const ReactQuill$1 = /*@__PURE__*/getDefaultExportFromCjs(lib$1);
        function _classCallCheck$a(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass$8(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties(Constructor.prototype, protoProps);
          if (staticProps) _defineProperties(Constructor, staticProps);
          return Constructor;
        }
        function _defineProperty$3(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function _extends$g() {
          _extends$g = Object.assign || function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          return _extends$g.apply(this, arguments);
        }
        function _inherits$a(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function");
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              writable: true,
              configurable: true
            }
          });
          if (superClass) _setPrototypeOf(subClass, superClass);
        }
        function _getPrototypeOf(o) {
          _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
            return o.__proto__ || Object.getPrototypeOf(o);
          };
          return _getPrototypeOf(o);
        }
        function _setPrototypeOf(o, p) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
            o.__proto__ = p;
            return o;
          };
          return _setPrototypeOf(o, p);
        }
        function _isNativeReflectConstruct$s() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        function _assertThisInitialized(self) {
          if (self === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return self;
        }
        function _possibleConstructorReturn$a(self, call) {
          if (call && (typeof call === "object" || typeof call === "function")) {
            return call;
          } else if (call !== void 0) {
            throw new TypeError("Derived constructors may only return object or undefined");
          }
          return _assertThisInitialized(self);
        }
        function _createSuper$s(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$s();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$a(this, result);
          };
        }
        function _superPropBase$1(object, property) {
          while (!Object.prototype.hasOwnProperty.call(object, property)) {
            object = _getPrototypeOf(object);
            if (object === null) break;
          }
          return object;
        }
        function _get$1() {
          if (typeof Reflect !== "undefined" && Reflect.get) {
            _get$1 = Reflect.get;
          } else {
            _get$1 = function _get(target, property, receiver) {
              var base = _superPropBase$1(target, property);
              if (!base) return;
              var desc = Object.getOwnPropertyDescriptor(base, property);
              if (desc.get) {
                return desc.get.call(arguments.length < 3 ? target : receiver);
              }
              return desc.value;
            };
          }
          return _get$1.apply(this, arguments);
        }
        function _unsupportedIterableToArray$7(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray$7(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen);
        }
        function _arrayLikeToArray$7(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }
        function _createForOfIteratorHelper$6(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$7(o)) || allowArrayLike && o && typeof o.length === "number") {
              if (it) o = it;
              var i = 0;
              var F = function () {};
              return {
                s: F,
                n: function () {
                  if (i >= o.length) return {
                    done: true
                  };
                  return {
                    done: false,
                    value: o[i++]
                  };
                },
                e: function (e) {
                  throw e;
                },
                f: F
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true,
            didErr = false,
            err;
          return {
            s: function () {
              it = it.call(o);
            },
            n: function () {
              var step = it.next();
              normalCompletion = step.done;
              return step;
            },
            e: function (e) {
              didErr = true;
              err = e;
            },
            f: function () {
              try {
                if (!normalCompletion && it.return != null) it.return();
              } finally {
                if (didErr) throw err;
              }
            }
          };
        }
        var Keys = {
          TAB: 9,
          ENTER: 13,
          ESCAPE: 27,
          UP: 38,
          DOWN: 40
        };
        function attachDataValues(element, data, dataAttributes) {
          var mention = element;
          Object.keys(data).forEach(function (key) {
            if (dataAttributes.indexOf(key) > -1) {
              mention.dataset[key] = data[key];
            } else {
              delete mention.dataset[key];
            }
          });
          return mention;
        }
        function getMentionCharIndex(text, mentionDenotationChars) {
          return mentionDenotationChars.reduce(function (prev, mentionChar) {
            var mentionCharIndex = text.lastIndexOf(mentionChar);
            if (mentionCharIndex > prev.mentionCharIndex) {
              return {
                mentionChar: mentionChar,
                mentionCharIndex: mentionCharIndex
              };
            }
            return {
              mentionChar: prev.mentionChar,
              mentionCharIndex: prev.mentionCharIndex
            };
          }, {
            mentionChar: null,
            mentionCharIndex: -1
          });
        }
        function hasValidChars(text, allowedChars) {
          return allowedChars.test(text);
        }
        function hasValidMentionCharIndex(mentionCharIndex, text, isolateChar) {
          if (mentionCharIndex > -1) {
            if (isolateChar && !(mentionCharIndex === 0 || !!text[mentionCharIndex - 1].match(/\s/g))) {
              return false;
            }
            return true;
          }
          return false;
        }
        var Embed = Quill["import"]("blots/embed");
        var MentionBlot = /*#__PURE__*/function (_Embed) {
          _inherits$a(MentionBlot, _Embed);
          var _super = _createSuper$s(MentionBlot);
          function MentionBlot(scroll, node) {
            var _this;
            _classCallCheck$a(this, MentionBlot);
            _this = _super.call(this, scroll, node);
            _defineProperty$3(_assertThisInitialized(_this), "hoverHandler", void 0);
            _defineProperty$3(_assertThisInitialized(_this), "hoverHandler", void 0);
            _this.clickHandler = null;
            _this.hoverHandler = null;
            _this.mounted = false;
            return _this;
          }
          _createClass$8(MentionBlot, [{
            key: "attach",
            value: function attach() {
              _get$1(_getPrototypeOf(MentionBlot.prototype), "attach", this).call(this);
              if (!this.mounted) {
                this.mounted = true;
                this.clickHandler = this.getClickHandler();
                this.hoverHandler = this.getHoverHandler();
                this.domNode.addEventListener("click", this.clickHandler, false);
                this.domNode.addEventListener("mouseenter", this.hoverHandler, false);
              }
            }
          }, {
            key: "detach",
            value: function detach() {
              _get$1(_getPrototypeOf(MentionBlot.prototype), "detach", this).call(this);
              this.mounted = false;
              if (this.clickHandler) {
                this.domNode.removeEventListener("click", this.clickHandler);
                this.clickHandler = null;
              }
            }
          }, {
            key: "getClickHandler",
            value: function getClickHandler() {
              var _this2 = this;
              return function (e) {
                var event = _this2.buildEvent("mention-clicked", e);
                window.dispatchEvent(event);
                e.preventDefault();
              };
            }
          }, {
            key: "getHoverHandler",
            value: function getHoverHandler() {
              var _this3 = this;
              return function (e) {
                var event = _this3.buildEvent('mention-hovered', e);
                window.dispatchEvent(event);
                e.preventDefault();
              };
            }
          }, {
            key: "buildEvent",
            value: function buildEvent(name, e) {
              var event = new Event(name, {
                bubbles: true,
                cancelable: true
              });
              event.value = _extends$g({}, this.domNode.dataset);
              event.event = e;
              return event;
            }
          }], [{
            key: "create",
            value: function create(data) {
              var node = _get$1(_getPrototypeOf(MentionBlot), "create", this).call(this);
              var denotationChar = document.createElement("span");
              denotationChar.className = "ql-mention-denotation-char";
              denotationChar.innerHTML = data.denotationChar;
              node.appendChild(denotationChar);
              node.innerHTML += data.value;
              return MentionBlot.setDataValues(node, data);
            }
          }, {
            key: "setDataValues",
            value: function setDataValues(element, data) {
              var domNode = element;
              Object.keys(data).forEach(function (key) {
                domNode.dataset[key] = data[key];
              });
              return domNode;
            }
          }, {
            key: "value",
            value: function value(domNode) {
              return domNode.dataset;
            }
          }]);
          return MentionBlot;
        }(Embed);
        MentionBlot.blotName = "mention";
        MentionBlot.tagName = "span";
        MentionBlot.className = "mention";
        Quill.register(MentionBlot);
        var Mention = /*#__PURE__*/function () {
          function Mention(quill, options) {
            var _this = this;
            _classCallCheck$a(this, Mention);
            this.isOpen = false;
            this.itemIndex = 0;
            this.mentionCharPos = null;
            this.cursorPos = null;
            this.values = [];
            this.suspendMouseEnter = false; //this token is an object that may contains one key "abandoned", set to
            //true when the previous source call should be ignored in favor or a
            //more recent execution.  This token will be null unless a source call
            //is in progress.

            this.existingSourceExecutionToken = null;
            this.quill = quill;
            this.options = {
              source: null,
              renderItem: function renderItem(item) {
                return "".concat(item.value);
              },
              renderLoading: function renderLoading() {
                return null;
              },
              onSelect: function onSelect(item, insertItem) {
                insertItem(item);
              },
              mentionDenotationChars: ["@"],
              showDenotationChar: true,
              allowedChars: /^[a-zA-Z0-9_]*$/,
              minChars: 0,
              maxChars: 31,
              offsetTop: 2,
              offsetLeft: 0,
              isolateCharacter: false,
              fixMentionsToQuill: false,
              positioningStrategy: "normal",
              defaultMenuOrientation: "bottom",
              blotName: "mention",
              dataAttributes: ["id", "value", "denotationChar", "link", "target", "disabled"],
              linkTarget: "_blank",
              onOpen: function onOpen() {
                return true;
              },
              onBeforeClose: function onBeforeClose() {
                return true;
              },
              onClose: function onClose() {
                return true;
              },
              // Style options
              listItemClass: "ql-mention-list-item",
              mentionContainerClass: "ql-mention-list-container",
              mentionListClass: "ql-mention-list",
              spaceAfterInsert: true,
              selectKeys: [Keys.ENTER]
            };
            _extends$g(this.options, options, {
              dataAttributes: Array.isArray(options.dataAttributes) ? this.options.dataAttributes.concat(options.dataAttributes) : this.options.dataAttributes
            }); //create mention container

            this.mentionContainer = document.createElement("div");
            this.mentionContainer.className = this.options.mentionContainerClass ? this.options.mentionContainerClass : "";
            this.mentionContainer.style.cssText = "display: none; position: absolute;";
            this.mentionContainer.onmousemove = this.onContainerMouseMove.bind(this);
            if (this.options.fixMentionsToQuill) {
              this.mentionContainer.style.width = "auto";
            }
            this.mentionList = document.createElement("ul");
            this.mentionList.id = 'quill-mention-list';
            quill.root.setAttribute('aria-owns', 'quill-mention-list');
            this.mentionList.className = this.options.mentionListClass ? this.options.mentionListClass : "";
            this.mentionContainer.appendChild(this.mentionList);
            quill.on("text-change", this.onTextChange.bind(this));
            quill.on("selection-change", this.onSelectionChange.bind(this)); //Pasting doesn't fire selection-change after the pasted text is
            //inserted, so here we manually trigger one

            quill.container.addEventListener("paste", function () {
              setTimeout(function () {
                var range = quill.getSelection();
                _this.onSelectionChange(range);
              });
            });
            quill.keyboard.addBinding({
              key: Keys.TAB
            }, this.selectHandler.bind(this));
            quill.keyboard.bindings[Keys.TAB].unshift(quill.keyboard.bindings[Keys.TAB].pop());
            var _iterator = _createForOfIteratorHelper$6(this.options.selectKeys),
              _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var selectKey = _step.value;
                quill.keyboard.addBinding({
                  key: selectKey
                }, this.selectHandler.bind(this));
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
            quill.keyboard.bindings[Keys.ENTER].unshift(quill.keyboard.bindings[Keys.ENTER].pop());
            quill.keyboard.addBinding({
              key: Keys.ESCAPE
            }, this.escapeHandler.bind(this));
            quill.keyboard.addBinding({
              key: Keys.UP
            }, this.upHandler.bind(this));
            quill.keyboard.addBinding({
              key: Keys.DOWN
            }, this.downHandler.bind(this));
          }
          _createClass$8(Mention, [{
            key: "selectHandler",
            value: function selectHandler() {
              if (this.isOpen && !this.existingSourceExecutionToken) {
                this.selectItem();
                return false;
              }
              return true;
            }
          }, {
            key: "escapeHandler",
            value: function escapeHandler() {
              if (this.isOpen) {
                if (this.existingSourceExecutionToken) {
                  this.existingSourceExecutionToken.abandoned = true;
                }
                this.hideMentionList();
                return false;
              }
              return true;
            }
          }, {
            key: "upHandler",
            value: function upHandler() {
              if (this.isOpen && !this.existingSourceExecutionToken) {
                this.prevItem();
                return false;
              }
              return true;
            }
          }, {
            key: "downHandler",
            value: function downHandler() {
              if (this.isOpen && !this.existingSourceExecutionToken) {
                this.nextItem();
                return false;
              }
              return true;
            }
          }, {
            key: "showMentionList",
            value: function showMentionList() {
              if (this.options.positioningStrategy === "fixed") {
                document.body.appendChild(this.mentionContainer);
              } else {
                this.quill.container.appendChild(this.mentionContainer);
              }
              this.mentionContainer.style.visibility = "hidden";
              this.mentionContainer.style.display = "";
              this.mentionContainer.scrollTop = 0;
              this.setMentionContainerPosition();
              this.setIsOpen(true);
            }
          }, {
            key: "hideMentionList",
            value: function hideMentionList() {
              this.options.onBeforeClose();
              this.mentionContainer.style.display = "none";
              this.mentionContainer.remove();
              this.setIsOpen(false);
              this.quill.root.removeAttribute('aria-activedescendant');
            }
          }, {
            key: "highlightItem",
            value: function highlightItem() {
              var scrollItemInView = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
              for (var i = 0; i < this.mentionList.childNodes.length; i += 1) {
                this.mentionList.childNodes[i].classList.remove("selected");
              }
              if (this.itemIndex === -1 || this.mentionList.childNodes[this.itemIndex].dataset.disabled === "true") {
                return;
              }
              this.mentionList.childNodes[this.itemIndex].classList.add("selected");
              this.quill.root.setAttribute('aria-activedescendant', this.mentionList.childNodes[this.itemIndex].id);
              if (scrollItemInView) {
                var itemHeight = this.mentionList.childNodes[this.itemIndex].offsetHeight;
                var itemPos = this.mentionList.childNodes[this.itemIndex].offsetTop;
                var containerTop = this.mentionContainer.scrollTop;
                var containerBottom = containerTop + this.mentionContainer.offsetHeight;
                if (itemPos < containerTop) {
                  // Scroll up if the item is above the top of the container
                  this.mentionContainer.scrollTop = itemPos;
                } else if (itemPos > containerBottom - itemHeight) {
                  // scroll down if any part of the element is below the bottom of the container
                  this.mentionContainer.scrollTop += itemPos - containerBottom + itemHeight;
                }
              }
            }
          }, {
            key: "getItemData",
            value: function getItemData() {
              var link = this.mentionList.childNodes[this.itemIndex].dataset.link;
              var hasLinkValue = typeof link !== "undefined";
              var itemTarget = this.mentionList.childNodes[this.itemIndex].dataset.target;
              if (hasLinkValue) {
                this.mentionList.childNodes[this.itemIndex].dataset.value = "<a href=\"".concat(link, "\" target=").concat(itemTarget || this.options.linkTarget, ">").concat(this.mentionList.childNodes[this.itemIndex].dataset.value);
              }
              return this.mentionList.childNodes[this.itemIndex].dataset;
            }
          }, {
            key: "onContainerMouseMove",
            value: function onContainerMouseMove() {
              this.suspendMouseEnter = false;
            }
          }, {
            key: "selectItem",
            value: function selectItem() {
              var _this2 = this;
              if (this.itemIndex === -1) {
                return;
              }
              var data = this.getItemData();
              if (data.disabled) {
                return;
              }
              this.options.onSelect(data, function (asyncData) {
                _this2.insertItem(asyncData);
              });
              this.hideMentionList();
            }
          }, {
            key: "insertItem",
            value: function insertItem(data, programmaticInsert) {
              var render = data;
              if (render === null) {
                return;
              }
              if (!this.options.showDenotationChar) {
                render.denotationChar = "";
              }
              var insertAtPos;
              if (!programmaticInsert) {
                insertAtPos = this.mentionCharPos;
                this.quill.deleteText(this.mentionCharPos, this.cursorPos - this.mentionCharPos, Quill.sources.USER);
              } else {
                insertAtPos = this.cursorPos;
              }
              this.quill.insertEmbed(insertAtPos, this.options.blotName, render, Quill.sources.USER);
              if (this.options.spaceAfterInsert) {
                this.quill.insertText(insertAtPos + 1, " ", Quill.sources.USER); // setSelection here sets cursor position

                this.quill.setSelection(insertAtPos + 2, Quill.sources.USER);
              } else {
                this.quill.setSelection(insertAtPos + 1, Quill.sources.USER);
              }
              this.hideMentionList();
            }
          }, {
            key: "onItemMouseEnter",
            value: function onItemMouseEnter(e) {
              if (this.suspendMouseEnter) {
                return;
              }
              var index = Number(e.target.dataset.index);
              if (!Number.isNaN(index) && index !== this.itemIndex) {
                this.itemIndex = index;
                this.highlightItem(false);
              }
            }
          }, {
            key: "onDisabledItemMouseEnter",
            value: function onDisabledItemMouseEnter(e) {
              if (this.suspendMouseEnter) {
                return;
              }
              this.itemIndex = -1;
              this.highlightItem(false);
            }
          }, {
            key: "onItemClick",
            value: function onItemClick(e) {
              if (e.button !== 0) {
                return;
              }
              e.preventDefault();
              e.stopImmediatePropagation();
              this.itemIndex = e.currentTarget.dataset.index;
              this.highlightItem();
              this.selectItem();
            }
          }, {
            key: "onItemMouseDown",
            value: function onItemMouseDown(e) {
              e.preventDefault();
              e.stopImmediatePropagation();
            }
          }, {
            key: "renderLoading",
            value: function renderLoading() {
              var renderedLoading = this.options.renderLoading();
              if (!renderedLoading) {
                return;
              }
              if (this.mentionContainer.getElementsByClassName("ql-mention-loading").length > 0) {
                this.showMentionList();
                return;
              }
              this.mentionList.innerHTML = "";
              var loadingDiv = document.createElement("div");
              loadingDiv.className = "ql-mention-loading";
              loadingDiv.innerHTML = this.options.renderLoading();
              this.mentionContainer.append(loadingDiv);
              this.showMentionList();
            }
          }, {
            key: "removeLoading",
            value: function removeLoading() {
              var loadingDiv = this.mentionContainer.getElementsByClassName("ql-mention-loading");
              if (loadingDiv.length > 0) {
                loadingDiv[0].remove();
              }
            }
          }, {
            key: "renderList",
            value: function renderList(mentionChar, data, searchTerm) {
              if (data && data.length > 0) {
                this.removeLoading();
                this.values = data;
                this.mentionList.innerHTML = "";
                var initialSelection = -1;
                for (var i = 0; i < data.length; i += 1) {
                  var li = document.createElement("li");
                  li.id = 'quill-mention-item-' + i;
                  li.className = this.options.listItemClass ? this.options.listItemClass : "";
                  if (data[i].disabled) {
                    li.className += " disabled";
                    li.setAttribute('aria-hidden', 'true');
                  } else if (initialSelection === -1) {
                    initialSelection = i;
                  }
                  li.dataset.index = i;
                  li.innerHTML = this.options.renderItem(data[i], searchTerm);
                  if (!data[i].disabled) {
                    li.onmouseenter = this.onItemMouseEnter.bind(this);
                    li.onmouseup = this.onItemClick.bind(this);
                    li.onmousedown = this.onItemMouseDown.bind(this);
                  } else {
                    li.onmouseenter = this.onDisabledItemMouseEnter.bind(this);
                  }
                  li.dataset.denotationChar = mentionChar;
                  this.mentionList.appendChild(attachDataValues(li, data[i], this.options.dataAttributes));
                }
                this.itemIndex = initialSelection;
                this.highlightItem();
                this.showMentionList();
              } else {
                this.hideMentionList();
              }
            }
          }, {
            key: "nextItem",
            value: function nextItem() {
              var increment = 0;
              var newIndex;
              do {
                increment++;
                newIndex = (this.itemIndex + increment) % this.values.length;
                var disabled = this.mentionList.childNodes[newIndex].dataset.disabled === "true";
                if (increment === this.values.length + 1) {
                  //we've wrapped around w/o finding an enabled item
                  newIndex = -1;
                  break;
                }
              } while (disabled);
              this.itemIndex = newIndex;
              this.suspendMouseEnter = true;
              this.highlightItem();
            }
          }, {
            key: "prevItem",
            value: function prevItem() {
              var decrement = 0;
              var newIndex;
              do {
                decrement++;
                newIndex = (this.itemIndex + this.values.length - decrement) % this.values.length;
                var disabled = this.mentionList.childNodes[newIndex].dataset.disabled === "true";
                if (decrement === this.values.length + 1) {
                  //we've wrapped around w/o finding an enabled item
                  newIndex = -1;
                  break;
                }
              } while (disabled);
              this.itemIndex = newIndex;
              this.suspendMouseEnter = true;
              this.highlightItem();
            }
          }, {
            key: "containerBottomIsNotVisible",
            value: function containerBottomIsNotVisible(topPos, containerPos) {
              var mentionContainerBottom = topPos + this.mentionContainer.offsetHeight + containerPos.top;
              return mentionContainerBottom > window.pageYOffset + window.innerHeight;
            }
          }, {
            key: "containerRightIsNotVisible",
            value: function containerRightIsNotVisible(leftPos, containerPos) {
              if (this.options.fixMentionsToQuill) {
                return false;
              }
              var rightPos = leftPos + this.mentionContainer.offsetWidth + containerPos.left;
              var browserWidth = window.pageXOffset + document.documentElement.clientWidth;
              return rightPos > browserWidth;
            }
          }, {
            key: "setIsOpen",
            value: function setIsOpen(isOpen) {
              if (this.isOpen !== isOpen) {
                if (isOpen) {
                  this.options.onOpen();
                } else {
                  this.options.onClose();
                }
                this.isOpen = isOpen;
              }
            }
          }, {
            key: "setMentionContainerPosition",
            value: function setMentionContainerPosition() {
              if (this.options.positioningStrategy === "fixed") {
                this.setMentionContainerPosition_Fixed();
              } else {
                this.setMentionContainerPosition_Normal();
              }
            }
          }, {
            key: "setMentionContainerPosition_Normal",
            value: function setMentionContainerPosition_Normal() {
              var _this3 = this;
              var containerPos = this.quill.container.getBoundingClientRect();
              var mentionCharPos = this.quill.getBounds(this.mentionCharPos);
              var containerHeight = this.mentionContainer.offsetHeight;
              var topPos = this.options.offsetTop;
              var leftPos = this.options.offsetLeft; // handle horizontal positioning

              if (this.options.fixMentionsToQuill) {
                var rightPos = 0;
                this.mentionContainer.style.right = "".concat(rightPos, "px");
              } else {
                leftPos += mentionCharPos.left;
              }
              if (this.containerRightIsNotVisible(leftPos, containerPos)) {
                var containerWidth = this.mentionContainer.offsetWidth + this.options.offsetLeft;
                var quillWidth = containerPos.width;
                leftPos = quillWidth - containerWidth;
              } // handle vertical positioning

              if (this.options.defaultMenuOrientation === "top") {
                // Attempt to align the mention container with the top of the quill editor
                if (this.options.fixMentionsToQuill) {
                  topPos = -1 * (containerHeight + this.options.offsetTop);
                } else {
                  topPos = mentionCharPos.top - (containerHeight + this.options.offsetTop);
                } // default to bottom if the top is not visible

                if (topPos + containerPos.top <= 0) {
                  var overMentionCharPos = this.options.offsetTop;
                  if (this.options.fixMentionsToQuill) {
                    overMentionCharPos += containerPos.height;
                  } else {
                    overMentionCharPos += mentionCharPos.bottom;
                  }
                  topPos = overMentionCharPos;
                }
              } else {
                // Attempt to align the mention container with the bottom of the quill editor
                if (this.options.fixMentionsToQuill) {
                  topPos += containerPos.height;
                } else {
                  topPos += mentionCharPos.bottom;
                } // default to the top if the bottom is not visible

                if (this.containerBottomIsNotVisible(topPos, containerPos)) {
                  var _overMentionCharPos = this.options.offsetTop * -1;
                  if (!this.options.fixMentionsToQuill) {
                    _overMentionCharPos += mentionCharPos.top;
                  }
                  topPos = _overMentionCharPos - containerHeight;
                }
              }
              if (topPos >= 0) {
                this.options.mentionContainerClass.split(' ').forEach(function (className) {
                  _this3.mentionContainer.classList.add("".concat(className, "-bottom"));
                  _this3.mentionContainer.classList.remove("".concat(className, "-top"));
                });
              } else {
                this.options.mentionContainerClass.split(' ').forEach(function (className) {
                  _this3.mentionContainer.classList.add("".concat(className, "-top"));
                  _this3.mentionContainer.classList.remove("".concat(className, "-bottom"));
                });
              }
              this.mentionContainer.style.top = "".concat(topPos, "px");
              this.mentionContainer.style.left = "".concat(leftPos, "px");
              this.mentionContainer.style.visibility = "visible";
            }
          }, {
            key: "setMentionContainerPosition_Fixed",
            value: function setMentionContainerPosition_Fixed() {
              var _this4 = this;
              this.mentionContainer.style.position = "fixed";
              this.mentionContainer.style.height = null;
              var containerPos = this.quill.container.getBoundingClientRect();
              var mentionCharPos = this.quill.getBounds(this.mentionCharPos);
              var mentionCharPosAbsolute = {
                left: containerPos.left + mentionCharPos.left,
                top: containerPos.top + mentionCharPos.top,
                width: 0,
                height: mentionCharPos.height
              }; //Which rectangle should it be relative to

              var relativeToPos = this.options.fixMentionsToQuill ? containerPos : mentionCharPosAbsolute;
              var topPos = this.options.offsetTop;
              var leftPos = this.options.offsetLeft; // handle horizontal positioning

              if (this.options.fixMentionsToQuill) {
                var rightPos = relativeToPos.right;
                this.mentionContainer.style.right = "".concat(rightPos, "px");
              } else {
                leftPos += relativeToPos.left; //if its off the righ edge, push it back

                if (leftPos + this.mentionContainer.offsetWidth > document.documentElement.clientWidth) {
                  leftPos -= leftPos + this.mentionContainer.offsetWidth - document.documentElement.clientWidth;
                }
              }
              var availableSpaceTop = relativeToPos.top;
              var availableSpaceBottom = document.documentElement.clientHeight - (relativeToPos.top + relativeToPos.height);
              var fitsBottom = this.mentionContainer.offsetHeight <= availableSpaceBottom;
              var fitsTop = this.mentionContainer.offsetHeight <= availableSpaceTop;
              var placement;
              if (this.options.defaultMenuOrientation === "top" && fitsTop) {
                placement = "top";
              } else if (this.options.defaultMenuOrientation === "bottom" && fitsBottom) {
                placement = "bottom";
              } else {
                //it doesnt fit either so put it where there's the most space
                placement = availableSpaceBottom > availableSpaceTop ? "bottom" : "top";
              }
              if (placement === "bottom") {
                topPos = relativeToPos.top + relativeToPos.height;
                if (!fitsBottom) {
                  //shrink it to fit
                  //3 is a bit of a fudge factor so it doesnt touch the edge of the screen
                  this.mentionContainer.style.height = availableSpaceBottom - 3 + "px";
                }
                this.options.mentionContainerClass.split(" ").forEach(function (className) {
                  _this4.mentionContainer.classList.add("".concat(className, "-bottom"));
                  _this4.mentionContainer.classList.remove("".concat(className, "-top"));
                });
              } else {
                topPos = relativeToPos.top - this.mentionContainer.offsetHeight;
                if (!fitsTop) {
                  //shrink it to fit
                  //3 is a bit of a fudge factor so it doesnt touch the edge of the screen
                  this.mentionContainer.style.height = availableSpaceTop - 3 + "px";
                  topPos = 3;
                }
                this.options.mentionContainerClass.split(" ").forEach(function (className) {
                  _this4.mentionContainer.classList.add("".concat(className, "-top"));
                  _this4.mentionContainer.classList.remove("".concat(className, "-bottom"));
                });
              }
              this.mentionContainer.style.top = "".concat(topPos, "px");
              this.mentionContainer.style.left = "".concat(leftPos, "px");
              this.mentionContainer.style.visibility = "visible";
            }
          }, {
            key: "getTextBeforeCursor",
            value: function getTextBeforeCursor() {
              var startPos = Math.max(0, this.cursorPos - this.options.maxChars);
              var textBeforeCursorPos = this.quill.getText(startPos, this.cursorPos - startPos);
              return textBeforeCursorPos;
            }
          }, {
            key: "onSomethingChange",
            value: function onSomethingChange() {
              var _this5 = this;
              var range = this.quill.getSelection();
              if (range == null) return;
              this.cursorPos = range.index;
              var textBeforeCursor = this.getTextBeforeCursor();
              var _getMentionCharIndex = getMentionCharIndex(textBeforeCursor, this.options.mentionDenotationChars),
                mentionChar = _getMentionCharIndex.mentionChar,
                mentionCharIndex = _getMentionCharIndex.mentionCharIndex;
              if (hasValidMentionCharIndex(mentionCharIndex, textBeforeCursor, this.options.isolateCharacter)) {
                var mentionCharPos = this.cursorPos - (textBeforeCursor.length - mentionCharIndex);
                this.mentionCharPos = mentionCharPos;
                var textAfter = textBeforeCursor.substring(mentionCharIndex + mentionChar.length);
                if (textAfter.length >= this.options.minChars && hasValidChars(textAfter, this.getAllowedCharsRegex(mentionChar))) {
                  if (this.existingSourceExecutionToken) {
                    this.existingSourceExecutionToken.abandoned = true;
                  }
                  this.renderLoading();
                  var sourceRequestToken = {
                    abandoned: false
                  };
                  this.existingSourceExecutionToken = sourceRequestToken;
                  this.options.source(textAfter, function (data, searchTerm) {
                    if (sourceRequestToken.abandoned) {
                      return;
                    }
                    _this5.existingSourceExecutionToken = null;
                    _this5.renderList(mentionChar, data, searchTerm);
                  }, mentionChar);
                } else {
                  if (this.existingSourceExecutionToken) {
                    this.existingSourceExecutionToken.abandoned = true;
                  }
                  this.hideMentionList();
                }
              } else {
                if (this.existingSourceExecutionToken) {
                  this.existingSourceExecutionToken.abandoned = true;
                }
                this.hideMentionList();
              }
            }
          }, {
            key: "getAllowedCharsRegex",
            value: function getAllowedCharsRegex(denotationChar) {
              if (this.options.allowedChars instanceof RegExp) {
                return this.options.allowedChars;
              } else {
                return this.options.allowedChars(denotationChar);
              }
            }
          }, {
            key: "onTextChange",
            value: function onTextChange(delta, oldDelta, source) {
              if (source === "user") {
                this.onSomethingChange();
              }
            }
          }, {
            key: "onSelectionChange",
            value: function onSelectionChange(range) {
              if (range && range.length === 0) {
                this.onSomethingChange();
              } else {
                this.hideMentionList();
              }
            }
          }, {
            key: "openMenu",
            value: function openMenu(denotationChar) {
              var selection = this.quill.getSelection(true);
              this.quill.insertText(selection.index, denotationChar);
              this.quill.blur();
              this.quill.focus();
            }
          }]);
          return Mention;
        }();
        Quill.register("modules/mention", Mention);
        const quill_mention = '';
        const accessibleDependencies = (componentIndices, code) => {
          let dependencies = [];
          if (!componentIndices) {
            return dependencies;
          }
          let componentIndex = componentIndices.find(element => element.code === code);
          if (!componentIndex) {
            return dependencies;
          }
          if (componentIndex.parent) {
            let componentParents = parents$1(componentIndices, componentIndex);
            componentParents.forEach(element => {
              dependencies = dependencies.concat(accessibleSiblings$1(componentIndices, element));
            });
          }
          if (isGroup(componentIndex.code) || isQuestion(componentIndex.code)) {
            dependencies = dependencies.concat(accessibleSiblings$1(componentIndices, componentIndex));
          }
          return dependencies;
        };
        const parents$1 = (componentIndices, componentIndex) => {
          let result = [];
          let parent = componentIndices.find(element => element.code === componentIndex.parent);
          if (parent && parent.parent) {
            result.push(parent);
            result = result.concat(parents$1(componentIndices, parent));
          }
          return result;
        };
        const accessibleSiblings$1 = (componentIndices, componentIndex) => {
          let result = [];
          if (!isGroup(componentIndex.code) && !isQuestion(componentIndex.code)) {
            return result;
          }
          let accessibleSiblings = componentIndices.filter(elem => {
            return elem.parent === componentIndex.parent && elem.maxIndex < componentIndex.minIndex && (!componentIndex.prioritisedSiblings || componentIndex.prioritisedSiblings.indexOf(elem.code) === -1);
          });
          accessibleSiblings.forEach(sibling => {
            result = result.concat(sibling.code);
            result = result.concat(childrenDependencies$1(componentIndices, sibling));
          });
          return result;
        };
        const childrenDependencies$1 = (componentIndices, componentIndex) => {
          let result = [];
          if (!isGroup(componentIndex.code)) {
            return result;
          }
          if (componentIndex.children) {
            componentIndex.children.forEach(childCode => {
              let child = componentIndices.find(element => element.code === childCode);
              result = result.concat(child.code);
              result = result.concat(childrenDependencies$1(componentIndices, child));
            });
          }
          return result;
        };
        const buildReferences = (componentIndices, code, state, mainLang) => {
          let dependencies = accessibleDependencies(componentIndices, code);
          let returnResult = [];
          dependencies.forEach(el => {
            if (isQuestion(el)) {
              const reference = buildReference(el, state[el], state, mainLang);
              if (reference.length) {
                returnResult = returnResult.concat(reference);
              }
            }
          });
          return returnResult;
        };
        const buildReference = (code, component, state, mainLang) => {
          var _component$content, _component$content$la;
          const label = code + ". " + stripTags((_component$content = component.content) === null || _component$content === void 0 ? void 0 : (_component$content$la = _component$content.label) === null || _component$content$la === void 0 ? void 0 : _component$content$la[mainLang]);
          let instruction = "";
          let type = component.type;
          switch (component.type) {
            case "scq_array":
              return component.children.filter(el => el.type == "row").map(element => {
                var _state$element$qualif, _state$element$qualif2;
                return {
                  value: label + " - " + code + ". " + stripTags((_state$element$qualif = state[element.qualifiedCode].content) === null || _state$element$qualif === void 0 ? void 0 : (_state$element$qualif2 = _state$element$qualif.label) === null || _state$element$qualif2 === void 0 ? void 0 : _state$element$qualif2[mainLang]),
                  id: code + element.code,
                  type: "SCQ Array Row",
                  instruction: code + element.code + ".masked_value"
                };
              });
            case "text":
              type = "Short Text";
              instruction = `${code}.value`;
              break;
            case "nps":
              type = "NPS";
              instruction = `${code}.value`;
              break;
            case "email":
              type = "Email";
              instruction = `${code}.value`;
              break;
            case "paragraph":
              instruction = `${code}.value`;
              type = "Long Text";
              break;
            case "number":
              type = "Number";
              instruction = `${code}.value`;
              break;
            case "date":
              type = "Date";
              instruction = `${code}.masked_value`;
              break;
            case "time":
              type = "time";
              instruction = `${code}.masked_value`;
              break;
            case "date_time":
              type = "Date Time";
              instruction = `${code}.masked_value`;
              break;
            case "scq":
              type = "SCQ";
              instruction = `${code}.masked_value`;
              break;
            case "image_scq":
              type = "Image SCQ";
              instruction = `${code}.masked_value`;
              break;
            case "mcq":
              type = "MCQ";
              instruction = `${code}.masked_value`;
              break;
            case "image_mcq":
              type = "Image MCQ";
              instruction = `${code}.masked_value`;
              break;
            default:
              return [];
          }
          return [{
            id: code,
            instruction,
            value: label,
            type
          }];
        };
        lib$1.Quill.register("modules/mentions", Mention);
        function DraftEditor({
          value,
          onBlurListener,
          extended,
          isRtl,
          lang,
          code
        }) {
          console.log("DraftEditor for: " + code);
          const oneLine = (value2, oneLine2) => {
            return !oneLine2 ? value2 : "<p>" + value2.replace(/<br>/gi, "").replace(/<p>/gi, "").replace(/<\/p>/, "") + "</p>";
          };
          const editor = React.createRef();
          const [state, setState] = reactExports.useState(oneLine(value, !extended));
          const [lastFocus, setLastFocus] = reactExports.useState(0);
          async function references(searchTerm) {
            const designState = designStore.getState().designState;
            const values = buildReferences(designState.componentIndex, code, designState, designState.langInfo.mainLang);
            if (searchTerm.length === 0) {
              return values;
            } else {
              const matches = [];
              for (var i = 0; i < values.length; i++) {
                if (values[i].value.toLowerCase().indexOf(searchTerm.toLowerCase()) >= 0) {
                  matches.push(values[i]);
                }
              }
              return matches;
            }
          }
          reactExports.useEffect(() => {
            const quill = editor.current.getEditor();
            quill.setSelection(quill.getLength(), 0);
          }, [editor.current]);
          const modules = reactExports.useMemo(() => {
            return {
              mention: {
                dataAttributes: ["instruction", "type"],
                isolateCharacter: true,
                allowedChars: /[^\p{L}\p{N}]*$/,
                mentionDenotationChars: ["@"],
                showDenotationChar: false,
                onSelect: function (item, insertItem) {
                  insertItem({
                    ...item,
                    value: `{{${item.id}:${item.type}}}`
                  });
                },
                source: async function (searchTerm, renderList) {
                  const values = await references(searchTerm);
                  renderList(values);
                }
              },
              toolbar: {
                container: extended ? [["bold", "italic", "underline", "strike", "link"], [{
                  list: "ordered"
                }, {
                  list: "bullet"
                }, {
                  indent: "-1"
                }, {
                  indent: "+1"
                }], [{
                  color: []
                }, {
                  background: []
                }], ["clean"]] : [["bold", "italic", "underline", "strike", "link"], [{
                  color: []
                }, {
                  background: []
                }], ["clean"]]
              }
            };
          }, []);
          const formats = ["bold", "italic", "underline", "strike", "direction", "list", "bullet", "indent", "color", "background", "mention", "link"];
          let timeoutID = null;
          const onFocus = () => {
            setLastFocus(Date.now());
            timeoutID && clearTimeout(timeoutID);
          };
          const onBlur = () => {
            if (Date.now() - lastFocus > 100) {
              timeoutID = setTimeout(() => {
                onBlurListener(state, lang);
              }, 100);
            }
          };
          const onChange = value2 => {
            onFocus();
            setState(oneLine(value2, !extended));
          };
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            onFocus,
            onBlur,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(ReactQuill$1, {
              className: isRtl ? "rtl" : "ltr",
              theme: "snow",
              ref: editor,
              modules,
              formats,
              value: state,
              onChange
            })
          });
        }
        const DraftEditor$1 = React.memo(DraftEditor);
        function ContentEditor$1({
          placeholder,
          extended,
          contentKey,
          code,
          onActive
        }) {
          console.log("ContentEditor for : " + code);
          const dispatch = useDispatch();
          const content = useSelector(state => {
            var _state$designState$co;
            return (_state$designState$co = state.designState[code].content) === null || _state$designState$co === void 0 ? void 0 : _state$designState$co[contentKey];
          });
          const langInfo = useSelector(state => {
            return state.designState.langInfo;
          });
          const lang = langInfo.lang;
          const mainLang = langInfo.mainLang;
          const onMainLang = langInfo.mainLang == langInfo.lang;
          const value = (content === null || content === void 0 ? void 0 : content[lang]) || "";
          const finalPlaceholder = onMainLang ? placeholder : (content === null || content === void 0 ? void 0 : content[mainLang]) || placeholder;
          const [isActive, setActive] = reactExports.useState(false);
          const OnEditorBlurred = (text, editorLang) => {
            setActive(false);
            if (lang != editorLang) {
              return;
            } else if (text != value) {
              dispatch(changeContent({
                code,
                key: contentKey,
                lang,
                value: text
              }));
            }
          };
          const onContainerClicked = event => {
            event.preventDefault();
            setActive(true);
            onActive();
          };
          const isRtl = rtlLanguage.includes(lang);
          return /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
            className: styles$F.fullWidth,
            onClick: e => {
              onContainerClicked(e);
            },
            children: isActive ? /* @__PURE__ */jsxRuntimeExports.jsx(DraftEditor$1, {
              lang,
              isRtl,
              code,
              extended,
              onBlurListener: OnEditorBlurred,
              value
            }) : /[^<br><p><\/p>\s]/gm.test(value) ? /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: `${isRtl ? "rtl" : "ltr"} ql-editor ${styles$F.noPadding}`,
              dangerouslySetInnerHTML: {
                __html: value
              }
            }) : /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: `${isRtl ? "rtl" : "ltr"} ql-editor ${styles$F.placeholder}`,
              dangerouslySetInnerHTML: {
                __html: finalPlaceholder
              }
            })
          });
        }
        const ContentEditor$2 = React.memo(ContentEditor$1);
        const questionItem$2 = "_questionItem_1sx0f_1";
        const styles$E = {
          questionItem: questionItem$2
        };
        function FileUploadQuestionDesign({
          code
        }) {
          var _state$validation5, _state$validation5$va;
          const theme = useTheme();
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const lang = useSelector(state2 => {
            return state2.designState.langInfo.lang;
          });
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            className: styles$E.questionItem,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
              variant: "standard",
              required: (_state$validation5 = state.validation) !== null && _state$validation5 !== void 0 && (_state$validation5$va = _state$validation5.validation_required) !== null && _state$validation5$va !== void 0 && _state$validation5$va.isActive ? true : false,
              label: state.showHint && state.content.hint ? state.content.hint[lang] : "",
              InputProps: {
                sx: {
                  fontFamily: theme.textStyles.text.font,
                  color: theme.textStyles.text.color,
                  fontSize: theme.textStyles.text.size
                }
              },
              value: "",
              type: "file",
              disabled: true
            })
          });
        }
        const questionItem$1 = "_questionItem_1sx0f_1";
        const styles$D = {
          questionItem: questionItem$1
        };
        function DateTimeQuestionDesign({
          code
        }) {
          var _state$validation6, _state$validation6$va;
          const theme = useTheme();
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const lang = useSelector(state2 => {
            return state2.designState.langInfo.lang;
          });
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            className: styles$D.questionItem,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
              disabled: true,
              variant: "standard",
              required: (_state$validation6 = state.validation) !== null && _state$validation6 !== void 0 && (_state$validation6$va = _state$validation6.validation_required) !== null && _state$validation6$va !== void 0 && _state$validation6$va.isActive ? true : false,
              label: state.showHint && state.content.hint ? state.content.hint[lang] : "",
              value: "",
              InputProps: {
                sx: {
                  fontFamily: theme.textStyles.text,
                  color: theme.textStyles.text.color,
                  fontSize: theme.textStyles.text.size
                }
              },
              placeholder: state.dateFormat
            })
          });
        }
        const questionItem = "_questionItem_wb37f_1";
        const styles$C = {
          questionItem: questionItem
        };
        function TimeQuestionDesign({
          code
        }) {
          var _state$validation7, _state$validation7$va;
          const theme = useTheme();
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const lang = useSelector(state2 => {
            return state2.designState.langInfo.lang;
          });
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            className: styles$C.questionItem,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
              disabled: true,
              variant: "standard",
              required: (_state$validation7 = state.validation) !== null && _state$validation7 !== void 0 && (_state$validation7$va = _state$validation7.validation_required) !== null && _state$validation7$va !== void 0 && _state$validation7$va.isActive ? true : false,
              label: state.showHint && state.content.hint ? state.content.hint[lang] : "",
              value: "",
              type: "time",
              InputProps: {
                sx: {
                  fontFamily: theme.textStyles.text.font,
                  color: theme.textStyles.text.color,
                  fontSize: theme.textStyles.text.size
                }
              }
            })
          });
        }
        const answerAdd$1 = "_answerAdd_1mqlf_1";
        const answerIcon$2 = "_answerIcon_1mqlf_7";
        const styles$B = {
          answerAdd: answerAdd$1,
          answerIcon: answerIcon$2
        };
        var RadioButtonUnchecked = {};
        var _interopRequireDefault$v = interopRequireDefaultExports;
        Object.defineProperty(RadioButtonUnchecked, "__esModule", {
          value: true
        });
        var default_1$n = RadioButtonUnchecked.default = void 0;
        var _createSvgIcon$n = _interopRequireDefault$v(requireCreateSvgIcon());
        var _jsxRuntime$n = jsxRuntimeExports;
        var _default$q = (0, _createSvgIcon$n.default)( /*#__PURE__*/(0, _jsxRuntime$n.jsx)("path", {
          d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
        }), 'RadioButtonUnchecked');
        default_1$n = RadioButtonUnchecked.default = _default$q;
        var CheckBoxOutlineBlank = {};
        var _interopRequireDefault$u = interopRequireDefaultExports;
        Object.defineProperty(CheckBoxOutlineBlank, "__esModule", {
          value: true
        });
        var default_1$m = CheckBoxOutlineBlank.default = void 0;
        var _createSvgIcon$m = _interopRequireDefault$u(requireCreateSvgIcon());
        var _jsxRuntime$m = jsxRuntimeExports;
        var _default$p = (0, _createSvgIcon$m.default)( /*#__PURE__*/(0, _jsxRuntime$m.jsx)("path", {
          d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
        }), 'CheckBoxOutlineBlank');
        default_1$m = CheckBoxOutlineBlank.default = _default$p;
        const answerItem = "_answerItem_1h53l_1";
        const answerIcon$1 = "_answerIcon_1h53l_8";
        const answerIconOther = "_answerIconOther_1h53l_16";
        const answerNumberOrder$1 = "_answerNumberOrder_1h53l_25";
        const answerControl = "_answerControl_1h53l_30";
        const answerControlRtl = "_answerControlRtl_1h53l_35";
        const answerControlOther = "_answerControlOther_1h53l_40";
        const answerControlOtherRtl = "_answerControlOtherRtl_1h53l_45";
        const answerOtherControl = "_answerOtherControl_1h53l_50";
        const styles$A = {
          answerItem: answerItem,
          answerIcon: answerIcon$1,
          answerIconOther: answerIconOther,
          answerNumberOrder: answerNumberOrder$1,
          answerControl: answerControl,
          answerControlRtl: answerControlRtl,
          answerControlOther: answerControlOther,
          answerControlOtherRtl: answerControlOtherRtl,
          answerOtherControl: answerOtherControl
        };
        var DragIndicator = {};
        var _interopRequireDefault$t = interopRequireDefaultExports;
        Object.defineProperty(DragIndicator, "__esModule", {
          value: true
        });
        var default_1$l = DragIndicator.default = void 0;
        var _createSvgIcon$l = _interopRequireDefault$t(requireCreateSvgIcon());
        var _jsxRuntime$l = jsxRuntimeExports;
        var _default$o = (0, _createSvgIcon$l.default)( /*#__PURE__*/(0, _jsxRuntime$l.jsx)("path", {
          d: "M11 18c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zm-2-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
        }), 'DragIndicator');
        default_1$l = DragIndicator.default = _default$o;
        var Close = {};
        var _interopRequireDefault$s = interopRequireDefaultExports;
        Object.defineProperty(Close, "__esModule", {
          value: true
        });
        var default_1$k = Close.default = void 0;
        var _createSvgIcon$k = _interopRequireDefault$s(requireCreateSvgIcon());
        var _jsxRuntime$k = jsxRuntimeExports;
        var _default$n = (0, _createSvgIcon$k.default)( /*#__PURE__*/(0, _jsxRuntime$k.jsx)("path", {
          d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
        }), 'Close');
        default_1$k = Close.default = _default$n;
        var Build = {};
        var _interopRequireDefault$r = interopRequireDefaultExports;
        Object.defineProperty(Build, "__esModule", {
          value: true
        });
        var default_1$j = Build.default = void 0;
        var _createSvgIcon$j = _interopRequireDefault$r(requireCreateSvgIcon());
        var _jsxRuntime$j = jsxRuntimeExports;
        var _default$m = (0, _createSvgIcon$j.default)( /*#__PURE__*/(0, _jsxRuntime$j.jsx)("path", {
          d: "m22.7 19-9.1-9.1c.9-2.3.4-5-1.5-6.9-2-2-5-2.4-7.4-1.3L9 6 6 9 1.6 4.7C.4 7.1.9 10.1 2.9 12.1c1.9 1.9 4.6 2.4 6.9 1.5l9.1 9.1c.4.4 1 .4 1.4 0l2.3-2.3c.5-.4.5-1.1.1-1.4z"
        }), 'Build');
        default_1$j = Build.default = _default$m;
        function ChoiceQuestionItem(props) {
          const dispatch = useDispatch();
          const theme = useTheme();
          const langInfo = useSelector(state => {
            return state.designState.langInfo;
          });
          const answer = useSelector(state => {
            return state.designState[props.qualifiedCode];
          });
          const onMainLang = langInfo.lang === langInfo.mainLang;
          const lang = langInfo.lang;
          const isRtl = rtlLanguage.includes(lang);
          const isInSetup = useSelector(state => {
            var _state$designState$se;
            return answer.type === "other" && ((_state$designState$se = state.designState.setup) === null || _state$designState$se === void 0 ? void 0 : _state$designState$se.code) == props.qualifiedCode + "Atext";
          });
          const content = useSelector(state => {
            var _state$designState$pr, _state$designState$pr2;
            return (_state$designState$pr = state.designState[props.qualifiedCode].content) === null || _state$designState$pr === void 0 ? void 0 : (_state$designState$pr2 = _state$designState$pr["label"]) === null || _state$designState$pr2 === void 0 ? void 0 : _state$designState$pr2[lang];
          });
          const mainContent = useSelector(state => {
            var _state$designState$pr3, _state$designState$pr4;
            return (_state$designState$pr3 = state.designState[props.qualifiedCode].content) === null || _state$designState$pr3 === void 0 ? void 0 : (_state$designState$pr4 = _state$designState$pr3["label"]) === null || _state$designState$pr4 === void 0 ? void 0 : _state$designState$pr4[langInfo.mainLang];
          });
          const renderIconByType = type => {
            switch (type) {
              case "radio":
                return /* @__PURE__ */jsxRuntimeExports.jsx(default_1$n, {
                  className: styles$A.answerIcon,
                  sx: {
                    fontSize: 18,
                    color: grey[600]
                  }
                });
              case "checkbox":
                return /* @__PURE__ */jsxRuntimeExports.jsx(default_1$m, {
                  className: styles$A.answerIcon,
                  sx: {
                    fontSize: 18,
                    color: grey[600]
                  }
                });
              case "numberOrder":
                return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                  className: styles$A.answerNumberOrder,
                  style: {
                    fontFamily: theme.textStyles.text.font,
                    color: theme.textStyles.text.color,
                    fontSize: 18
                  },
                  children: props.code
                });
            }
          };
          return /* @__PURE__ */jsxRuntimeExports.jsx(PublicDraggable, {
            draggableId: props.qualifiedCode,
            index: props.index,
            children: provided => /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
              sx: {
                backgroundColor: isInSetup ? "beige" : "inherit"
              },
              ref: provided.innerRef,
              ...provided.draggableProps,
              ...provided.dragHandleProps,
              className: styles$A.answerItem,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(default_1$l, {
                className: styles$A.answerIcon,
                sx: {
                  fontSize: 18,
                  color: grey[600]
                }
              }), renderIconByType(props.type), props.label ? /* @__PURE__ */jsxRuntimeExports.jsx("b", {
                children: props.label
              }) : "", /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
                variant: "standard",
                className: answer.type === "other" && isRtl ? styles$A.answerControlOtherRtl : answer.type === "other" ? styles$A.answerControlOther : isRtl ? styles$A.answerControlRtl : styles$A.answerControl,
                value: content || "",
                onChange: e => dispatch(changeContent({
                  code: props.qualifiedCode,
                  key: "label",
                  lang,
                  value: e.target.value
                })),
                placeholder: onMainLang ? "Option" : mainContent || "Option",
                InputProps: {
                  sx: {
                    fontFamily: theme.textStyles.text.font,
                    color: theme.textStyles.text.color,
                    fontSize: theme.textStyles.text.size
                  }
                }
              }), answer.type === "other" && /* @__PURE__ */jsxRuntimeExports.jsx(default_1$j, {
                sx: {
                  fontSize: 18,
                  color: grey[600]
                },
                className: styles$A.answerIconOther,
                onClick: () => {
                  dispatch(setup({
                    code: props.qualifiedCode + "Atext",
                    rules: setupOptions("other_text")
                  }));
                }
              }, "setup"), /* @__PURE__ */jsxRuntimeExports.jsx(default_1$k, {
                sx: {
                  fontSize: 18,
                  color: grey[600]
                },
                className: styles$A.answerIcon,
                onClick: e => dispatch(removeAnswer(props.qualifiedCode))
              }, "close")]
            })
          });
        }
        function ChoiceQuestion(props) {
          const theme = useTheme();
          const t = props.t;
          const children = useSelector(state => {
            return state.designState[props.code].children;
          });
          const questionType = useSelector(state => {
            return state.designState[props.code].type;
          });
          const isOther = (questionType == "mcq" || questionType == "scq") && (!children || !children.some(el => el.code === "Aother"));
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            className: styles$B.questionItem,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(ConnectedDroppable, {
              droppableId: `option-${props.code}`,
              type: `option-${props.code}`,
              children: provided => /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                ref: provided.innerRef,
                ...provided.droppableProps,
                children: [children && children.length > 0 && children.map((item, index) => /* @__PURE__ */jsxRuntimeExports.jsx(ChoiceQuestionItem, {
                  code: item.code,
                  label: item.code,
                  qualifiedCode: item.qualifiedCode,
                  index,
                  type: props.type
                }, item.code)), provided.placeholder]
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$B.answerAdd,
              children: [props.type === "checkbox" ? /* @__PURE__ */jsxRuntimeExports.jsx(default_1$m, {
                style: {
                  fontSize: 18,
                  color: grey[600]
                },
                className: styles$B.answerIcon
              }) : props.type === "radio" ? /* @__PURE__ */jsxRuntimeExports.jsx(default_1$n, {
                style: {
                  fontSize: 18,
                  color: grey[600]
                },
                className: styles$B.answerIcon
              }) : /* @__PURE__ */jsxRuntimeExports.jsx(default_1$p, {
                style: {
                  fontSize: 18,
                  color: grey[600]
                },
                className: styles$B.answerIcon
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                size: "small",
                style: {
                  fontFamily: theme.textStyles.text.font,
                  fontSize: theme.textStyles.text.size
                },
                onClick: () => props.addNewAnswer(props.code, questionType),
                children: t("add_option")
              }), isOther && /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx("span", {
                  children: t("or")
                }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                  style: {
                    fontFamily: theme.textStyles.text.font,
                    fontSize: theme.textStyles.text.size
                  },
                  size: "small",
                  className: styles$B.answerIcon,
                  onClick: () => props.addNewAnswer(props.code, questionType, "other"),
                  children: t("add_other")
                })]
              })]
            })]
          });
        }
        const scqList = "_scqList_13vte_1";
        const scqItem = "_scqItem_13vte_6";
        const answerAdd = "_answerAdd_13vte_15";
        const answerIcon = "_answerIcon_13vte_20";
        const answerNumberOrder = "_answerNumberOrder_13vte_24";
        const styles$z = {
          scqList: scqList,
          scqItem: scqItem,
          answerAdd: answerAdd,
          answerIcon: answerIcon,
          answerNumberOrder: answerNumberOrder
        };
        function SCQArray(props) {
          const theme = useTheme();
          const t = props.t;
          const rows = useSelector(state => {
            var _state$designState$pr5;
            return ((_state$designState$pr5 = state.designState[props.code].children) === null || _state$designState$pr5 === void 0 ? void 0 : _state$designState$pr5.filter(el => el.type == "row")) || [];
          });
          const columns = useSelector(state => {
            var _state$designState$pr6;
            return ((_state$designState$pr6 = state.designState[props.code].children) === null || _state$designState$pr6 === void 0 ? void 0 : _state$designState$pr6.filter(el => el.type == "column")) || [];
          });
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            className: styles$z.scqList,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(ConnectedDroppable, {
              droppableId: `row-${props.code}`,
              type: `row-${props.code}`,
              children: provided => /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                ref: provided.innerRef,
                ...provided.droppableProps,
                className: styles$z.scqItem,
                children: [/* @__PURE__ */jsxRuntimeExports.jsx("h5", {
                  children: "Rows"
                }), rows && rows.map((item, index) => {
                  return /* @__PURE__ */jsxRuntimeExports.jsx(ChoiceQuestionItem, {
                    code: item.code,
                    index,
                    qualifiedCode: item.qualifiedCode,
                    type: "numberOrder"
                  }, item.code);
                }), provided.placeholder, /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                  className: styles$z.answerAdd,
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                    sx: {
                      fontFamily: theme.textStyles.text.font,
                      fontSize: theme.textStyles.text.size
                    },
                    onClick: e => props.addNewAnswer(props.code, props.type, "row"),
                    children: t("add_row")
                  })
                })]
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(ConnectedDroppable, {
              droppableId: `col-${props.code}`,
              type: `col-${props.code}`,
              children: provided => /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                ref: provided.innerRef,
                ...provided.droppableProps,
                className: styles$z.scqItem,
                children: [/* @__PURE__ */jsxRuntimeExports.jsx("h5", {
                  children: "Columns"
                }), columns && columns.map((item, index) => {
                  return /* @__PURE__ */jsxRuntimeExports.jsx(ChoiceQuestionItem, {
                    code: item.code,
                    index,
                    qualifiedCode: item.qualifiedCode,
                    type: "radio"
                  }, item.code);
                }), provided.placeholder, /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                  className: styles$z.answerAdd,
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                    sx: {
                      fontFamily: theme.textStyles.text.font,
                      fontSize: theme.textStyles.text.size
                    },
                    size: "small",
                    onClick: e => props.addNewAnswer(props.code, props.type, "column"),
                    children: t("add_column")
                  })
                })]
              })
            })]
          });
        }
        const errorDisplay$3 = "_errorDisplay_1joy4_1";
        const clickable = "_clickable_1joy4_10";
        const styles$y = {
          errorDisplay: errorDisplay$3,
          clickable: clickable
        };
        var ErrorOutline = {};
        var _interopRequireDefault$q = interopRequireDefaultExports;
        Object.defineProperty(ErrorOutline, "__esModule", {
          value: true
        });
        var default_1$i = ErrorOutline.default = void 0;
        var _createSvgIcon$i = _interopRequireDefault$q(requireCreateSvgIcon());
        var _jsxRuntime$i = jsxRuntimeExports;
        var _default$l = (0, _createSvgIcon$i.default)( /*#__PURE__*/(0, _jsxRuntime$i.jsx)("path", {
          d: "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
        }), 'ErrorOutline');
        default_1$i = ErrorOutline.default = _default$l;
        function ErrorDisplay(props) {
          var _state$instructionLis;
          const {
            t
          } = useTranslation("design");
          const dispatch = useDispatch();
          const state = useSelector(state2 => {
            return state2.designState[props.code];
          });
          const errors = state.errors;
          const designErrors = state.designErrors;
          const instructions = (_state$instructionLis = state.instructionList) === null || _state$instructionLis === void 0 ? void 0 : _state$instructionLis.filter(instructions2 => instructions2.errors);
          const hasErrors = (errors === null || errors === void 0 ? void 0 : errors.length) > 0 || (designErrors === null || designErrors === void 0 ? void 0 : designErrors.length) > 0 || (instructions === null || instructions === void 0 ? void 0 : instructions.length) > 0;
          const type = useSelector(state2 => {
            var _state2$designState$p;
            return props.code == "Survey" ? "" : isGroup(props.code) ? ((_state2$designState$p = state2.designState[props.code].groupType) === null || _state2$designState$p === void 0 ? void 0 : _state2$designState$p.toLowerCase()) || "group" : state2.designState[props.code].type;
          });
          const onErrClick = instruction => {
            if (instruction.code === "conditional_relevance") {
              dispatch(setup({
                code: props.code,
                rules: setupOptions(type),
                highlighted: "relevance",
                expanded: ["relevance"]
              }));
            } else if (instruction.code === "random_group" || instruction.code === "priority_groups") {
              if (props.code == "Survey") {
                dispatch(setup({
                  ...serveyRandomSetup,
                  highlighted: "random"
                }));
              } else {
                dispatch(setup({
                  code: props.code,
                  rules: setupOptions(type),
                  highlighted: "random",
                  expanded: ["random"]
                }));
              }
            } else if (instruction.code.startsWith("skip_to")) {
              dispatch(setup({
                code: props.code,
                rules: setupOptions(type),
                highlighted: "skip_logic",
                expanded: ["skip_logic"]
              }));
            }
            return "";
          };
          const isClickable = instruction => {
            return instruction.code === "conditional_relevance" || instruction.code === "random_group" || instruction.code === "priority_groups" || instruction.code.startsWith("skip_to");
          };
          return hasErrors ? /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
            className: styles$y.errorDisplay,
            children: [errors && errors.map(el => {
              return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(default_1$k, {
                  style: {
                    verticalAlign: "middle"
                  }
                }), mapComponentError(props.code, el, t)]
              }, el);
            }), designErrors && designErrors.map(el => {
              return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(default_1$k, {
                  style: {
                    verticalAlign: "middle"
                  }
                }), el.message]
              }, el.code);
            }), instructions && instructions.map(el => {
              return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                className: isClickable(el) ? styles$y.clickable : "",
                onClick: () => onErrClick(el),
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(default_1$i, {
                  style: {
                    verticalAlign: "middle"
                  }
                }), mapInstructionError(el, t)]
              }, el.code);
            })]
          }) : "";
        }
        const mapComponentError = (code, error, t) => {
          if (error === "EMPTY_PARENT") {
            return t("err_empty_parent", {
              component_name: componentName(code, t),
              child_name: componentChildName(code, t)
            });
          } else if (error === "DUPLICATE_CODE") {
            return t("err_duplicate_code"), {
              component_name: componentName(code, t)
            };
          } else if (error === "NO_END_GROUP") {
            return t("err_no_end_group");
          } else if (error === "MISPLACED_END_GROUP") {
            return t("err_misplaced_end_group");
          } else if (error === "MISPLACED_WELCOME_GROUP") {
            return t("err_misplaced_welcome_group");
          }
          return "";
        };
        const mapInstructionError = (instruction, t) => {
          if (instruction.code === "value" && instruction.errors[0].name == "InvalidInstructionInEndGroup") {
            return t("err_value_in_end_group");
          } else if (instruction.code === "conditional_relevance") {
            return t("err_relevance");
          } else if (instruction.code === "random_group") {
            return t("err_random");
          } else if (instruction.code === "priority_groups") {
            return t("err_priority");
          } else if (instruction.code.startsWith("reference")) {
            return /* @__PURE__ */jsxRuntimeExports.jsx(Trans, {
              t,
              values: {
                codes: instruction.errors.map(error => error.dependency.componentCode).join(", "),
                lang: instruction.lang
              },
              i18nKey: "err_reference"
            });
          } else if (instruction.code.startsWith("skip_to")) {
            return t("err_skip");
          }
          return "";
        };
        const componentName = (code, t) => {
          if (code == "Survey") {
            return t("survey");
          } else if (isQuestion(code)) {
            return t("question");
          } else if (isGroup(code)) {
            return t("group");
          }
          return t("option");
        };
        const componentChildName = (code, t) => {
          if (isGroup(code)) {
            return t("question");
          } else if (code == "Survey") {
            return t("group");
          }
          return t("option");
        };
        const ErrorDisplay$1 = reactExports.memo(ErrorDisplay);
        const actionControl = "_actionControl_1xa5v_1";
        const statusIcon = "_statusIcon_1xa5v_8";
        const questionContainer = "_questionContainer_1xa5v_12";
        const actionIcon = "_actionIcon_1xa5v_16";
        const settingIcon$2 = "_settingIcon_1xa5v_17";
        const deleteIcon = "_deleteIcon_1xa5v_25";
        const styles$x = {
          actionControl: actionControl,
          statusIcon: statusIcon,
          questionContainer: questionContainer,
          actionIcon: actionIcon,
          settingIcon: settingIcon$2,
          deleteIcon: deleteIcon
        };
        var DeleteOutline = {};
        var _interopRequireDefault$p = interopRequireDefaultExports;
        Object.defineProperty(DeleteOutline, "__esModule", {
          value: true
        });
        var default_1$h = DeleteOutline.default = void 0;
        var _createSvgIcon$h = _interopRequireDefault$p(requireCreateSvgIcon());
        var _jsxRuntime$h = jsxRuntimeExports;
        var _default$k = (0, _createSvgIcon$h.default)( /*#__PURE__*/(0, _jsxRuntime$h.jsx)("path", {
          d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM8 9h8v10H8V9zm7.5-5-1-1h-5l-1 1H5v2h14V4z"
        }), 'DeleteOutline');
        default_1$h = DeleteOutline.default = _default$k;
        var UnfoldLess = {};
        var _interopRequireDefault$o = interopRequireDefaultExports;
        Object.defineProperty(UnfoldLess, "__esModule", {
          value: true
        });
        var default_1$g = UnfoldLess.default = void 0;
        var _createSvgIcon$g = _interopRequireDefault$o(requireCreateSvgIcon());
        var _jsxRuntime$g = jsxRuntimeExports;
        var _default$j = (0, _createSvgIcon$g.default)( /*#__PURE__*/(0, _jsxRuntime$g.jsx)("path", {
          d: "M7.41 18.59 8.83 20 12 16.83 15.17 20l1.41-1.41L12 14l-4.59 4.59zm9.18-13.18L15.17 4 12 7.17 8.83 4 7.41 5.41 12 10l4.59-4.59z"
        }), 'UnfoldLess');
        default_1$g = UnfoldLess.default = _default$j;
        var UnfoldMore = {};
        var _interopRequireDefault$n = interopRequireDefaultExports;
        Object.defineProperty(UnfoldMore, "__esModule", {
          value: true
        });
        var default_1$f = UnfoldMore.default = void 0;
        var _createSvgIcon$f = _interopRequireDefault$n(requireCreateSvgIcon());
        var _jsxRuntime$f = jsxRuntimeExports;
        var _default$i = (0, _createSvgIcon$f.default)( /*#__PURE__*/(0, _jsxRuntime$f.jsx)("path", {
          d: "M12 5.83 15.17 9l1.41-1.41L12 3 7.41 7.59 8.83 9 12 5.83zm0 12.34L8.83 15l-1.41 1.41L12 21l4.59-4.59L15.17 15 12 18.17z"
        }), 'UnfoldMore');
        default_1$f = UnfoldMore.default = _default$i;
        var Visibility = {};
        var _interopRequireDefault$m = interopRequireDefaultExports;
        Object.defineProperty(Visibility, "__esModule", {
          value: true
        });
        var default_1$e = Visibility.default = void 0;
        var _createSvgIcon$e = _interopRequireDefault$m(requireCreateSvgIcon());
        var _jsxRuntime$e = jsxRuntimeExports;
        var _default$h = (0, _createSvgIcon$e.default)( /*#__PURE__*/(0, _jsxRuntime$e.jsx)("path", {
          d: "M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"
        }), 'Visibility');
        default_1$e = Visibility.default = _default$h;
        var Verified = {};
        var _interopRequireDefault$l = interopRequireDefaultExports;
        Object.defineProperty(Verified, "__esModule", {
          value: true
        });
        var default_1$d = Verified.default = void 0;
        var _createSvgIcon$d = _interopRequireDefault$l(requireCreateSvgIcon());
        var _jsxRuntime$d = jsxRuntimeExports;
        var _default$g = (0, _createSvgIcon$d.default)( /*#__PURE__*/(0, _jsxRuntime$d.jsx)("path", {
          d: "m23 12-2.44-2.79.34-3.69-3.61-.82-1.89-3.2L12 2.96 8.6 1.5 6.71 4.69 3.1 5.5l.34 3.7L1 12l2.44 2.79-.34 3.7 3.61.82L8.6 22.5l3.4-1.47 3.4 1.46 1.89-3.19 3.61-.82-.34-3.69L23 12zm-12.91 4.72-3.8-3.81 1.48-1.48 2.32 2.33 5.85-5.87 1.48 1.48-7.33 7.35z"
        }), 'Verified');
        default_1$d = Verified.default = _default$g;
        var Shuffle = {};
        var _interopRequireDefault$k = interopRequireDefaultExports;
        Object.defineProperty(Shuffle, "__esModule", {
          value: true
        });
        var default_1$c = Shuffle.default = void 0;
        var _createSvgIcon$c = _interopRequireDefault$k(requireCreateSvgIcon());
        var _jsxRuntime$c = jsxRuntimeExports;
        var _default$f = (0, _createSvgIcon$c.default)( /*#__PURE__*/(0, _jsxRuntime$c.jsx)("path", {
          d: "M10.59 9.17 5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z"
        }), 'Shuffle');
        default_1$c = Shuffle.default = _default$f;
        var LowPriority = {};
        var _interopRequireDefault$j = interopRequireDefaultExports;
        Object.defineProperty(LowPriority, "__esModule", {
          value: true
        });
        var default_1$b = LowPriority.default = void 0;
        var _createSvgIcon$b = _interopRequireDefault$j(requireCreateSvgIcon());
        var _jsxRuntime$b = jsxRuntimeExports;
        var _default$e = (0, _createSvgIcon$b.default)( /*#__PURE__*/(0, _jsxRuntime$b.jsx)("path", {
          d: "M14 5h8v2h-8zm0 5.5h8v2h-8zm0 5.5h8v2h-8zM2 11.5C2 15.08 4.92 18 8.5 18H9v2l3-3-3-3v2h-.5C6.02 16 4 13.98 4 11.5S6.02 7 8.5 7H12V5H8.5C4.92 5 2 7.92 2 11.5z"
        }), 'LowPriority');
        default_1$b = LowPriority.default = _default$e;
        var MoveDown = {};
        var _interopRequireDefault$i = interopRequireDefaultExports;
        Object.defineProperty(MoveDown, "__esModule", {
          value: true
        });
        var default_1$a = MoveDown.default = void 0;
        var _createSvgIcon$a = _interopRequireDefault$i(requireCreateSvgIcon());
        var _jsxRuntime$a = jsxRuntimeExports;
        var _default$d = (0, _createSvgIcon$a.default)( /*#__PURE__*/(0, _jsxRuntime$a.jsx)("path", {
          d: "M3 11c0 2.45 1.76 4.47 4.08 4.91l-1.49-1.49L7 13l4 4.01L7 21l-1.41-1.41 1.58-1.58v-.06C3.7 17.54 1 14.58 1 11c0-3.87 3.13-7 7-7h3v2H8c-2.76 0-5 2.24-5 5zm19 0V4h-9v7h9zm-2-2h-5V6h5v3zm-7 4h9v7h-9z"
        }), 'MoveDown');
        default_1$a = MoveDown.default = _default$d;
        function ActionToolbar({
          code,
          isGroup,
          parentCode,
          collapsed,
          toggleCollapse,
          disableDelete,
          onDelete,
          onClone,
          t
        }) {
          const dispatch = useDispatch();
          const type = useSelector(state => {
            var _state$designState$co2;
            return isGroup ? ((_state$designState$co2 = state.designState[code].groupType) === null || _state$designState$co2 === void 0 ? void 0 : _state$designState$co2.toLowerCase()) || "group" : state.designState[code].type;
          });
          const hasRelevance = useSelector(state => {
            var _state$designState$co3, _state$designState$co4;
            let instruction = (_state$designState$co3 = state.designState[code]) === null || _state$designState$co3 === void 0 ? void 0 : (_state$designState$co4 = _state$designState$co3.instructionList) === null || _state$designState$co4 === void 0 ? void 0 : _state$designState$co4.find(el => el.code == "conditional_relevance");
            return typeof instruction !== "undefined" && !instruction.errors;
          });
          const hasValidation = useSelector(state => {
            var _state$designState$co5, _state$designState$co6, _state$designState$co7;
            return !isGroup && ((_state$designState$co5 = state.designState[code]) === null || _state$designState$co5 === void 0 ? void 0 : (_state$designState$co6 = _state$designState$co5.instructionList) === null || _state$designState$co6 === void 0 ? void 0 : (_state$designState$co7 = _state$designState$co6.filter(el => el.code.startsWith("validation_") && !el.errors)) === null || _state$designState$co7 === void 0 ? void 0 : _state$designState$co7.length) > 0;
          });
          const setSetup = () => {
            dispatch(setup({
              code,
              rules: setupOptions(type)
            }));
          };
          const expandRelevance = () => {
            dispatch(setup({
              code,
              rules: setupOptions(type),
              highlighted: "relevance",
              expanded: ["relevance"]
            }));
          };
          const expandValidation = () => {
            dispatch(setup({
              code,
              rules: setupOptions(type),
              highlighted: "validation",
              expanded: ["validation"]
            }));
          };
          const expandSkipLogic = () => {
            dispatch(setup({
              code,
              rules: setupOptions(type),
              highlighted: "skip_logic",
              expanded: ["skip_logic"]
            }));
          };
          const expandParentRandom = () => {
            if (isGroup) {
              dispatch(setup({
                ...serveyRandomSetup,
                highlighted: "random"
              }));
            } else {
              dispatch(setup({
                code: parentCode,
                rules: setupOptions("group"),
                highlighted: "random",
                expanded: ["random"]
              }));
            }
          };
          const hasSkip = useSelector(state => {
            var _state$designState$co8, _state$designState$co9, _skipInstructions$fil;
            let skipInstructions = (_state$designState$co8 = state.designState[code]) === null || _state$designState$co8 === void 0 ? void 0 : (_state$designState$co9 = _state$designState$co8.instructionList) === null || _state$designState$co9 === void 0 ? void 0 : _state$designState$co9.filter(el => el.code.startsWith("skip_to"));
            return (skipInstructions === null || skipInstructions === void 0 ? void 0 : (_skipInstructions$fil = skipInstructions.filter(el => !el.errors)) === null || _skipInstructions$fil === void 0 ? void 0 : _skipInstructions$fil.length) >= 1;
          });
          const isRandomized = useSelector(state => {
            var _state$designState$co10;
            let indexObj = (_state$designState$co10 = state.designState.componentIndex) === null || _state$designState$co10 === void 0 ? void 0 : _state$designState$co10.find(el => el.code == code);
            return indexObj && indexObj.minIndex != indexObj.maxIndex;
          });
          const isPrioritised = useSelector(state => {
            var _state$designState$co11, _indexObj$prioritised;
            let indexObj = (_state$designState$co11 = state.designState.componentIndex) === null || _state$designState$co11 === void 0 ? void 0 : _state$designState$co11.find(el => el.code == code);
            return (indexObj === null || indexObj === void 0 ? void 0 : (_indexObj$prioritised = indexObj.prioritisedSiblings) === null || _indexObj$prioritised === void 0 ? void 0 : _indexObj$prioritised.length) > 0;
          });
          return /* @__PURE__ */jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
            children: /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$x.actionControl,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                onClick: toggleCollapse,
                children: collapsed ? /* @__PURE__ */jsxRuntimeExports.jsx(default_1$f, {}) : /* @__PURE__ */jsxRuntimeExports.jsx(default_1$g, {})
              }), hasRelevance && /* @__PURE__ */jsxRuntimeExports.jsx(Tooltip$1, {
                title: "Has show/Hide Condition",
                children: /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                  className: styles$x.statusIcon,
                  onClick: () => expandRelevance(),
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$e, {})
                })
              }), hasValidation && /* @__PURE__ */jsxRuntimeExports.jsx(Tooltip$1, {
                title: "Has Validation",
                children: /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                  className: styles$x.statusIcon,
                  onClick: () => expandValidation(),
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$d, {})
                })
              }), isRandomized && /* @__PURE__ */jsxRuntimeExports.jsx(Tooltip$1, {
                title: "Is part of a valid Random Group (within parent)",
                children: /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                  className: styles$x.statusIcon,
                  onClick: () => expandParentRandom(),
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$c, {})
                })
              }), isPrioritised && /* @__PURE__ */jsxRuntimeExports.jsx(Tooltip$1, {
                title: "Is part of a valid Priority Group (within parent)",
                children: /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                  className: styles$x.statusIcon,
                  onClick: () => expandParentRandom(),
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$b, {})
                })
              }), hasSkip && /* @__PURE__ */jsxRuntimeExports.jsx(Tooltip$1, {
                title: "Has active Skip Logic",
                children: /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                  className: styles$x.statusIcon,
                  onClick: () => expandSkipLogic(),
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$a, {})
                })
              }), type != "welcome" && type != "end" && /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                onClick: () => setSetup(),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$j, {
                  className: styles$x.settingIcon
                })
              }), !isGroup && /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                onClick: () => onClone(),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$q, {
                  className: styles$x.actionIcon
                })
              }), /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                onClick: () => {
                  if (window.confirm(t("are_you_sure"))) {
                    onDelete();
                  }
                },
                disabled: disableDelete,
                children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$h, {
                  className: styles$x.deleteIcon
                })
              })]
            })
          });
        }
        const addAnswerIcon$1 = "_addAnswerIcon_1fnbz_1";
        const addAnswerButton$1 = "_addAnswerButton_1fnbz_5";
        const styles$w = {
          addAnswerIcon: addAnswerIcon$1,
          addAnswerButton: addAnswerButton$1
        };

        /*! *****************************************************************************
        Copyright (c) Microsoft Corporation.
          Permission to use, copy, modify, and/or distribute this software for any
        purpose with or without fee is hereby granted.
          THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
        REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
        AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
        INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
        LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
        OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
        PERFORMANCE OF THIS SOFTWARE.
        ***************************************************************************** */
        /* global Reflect, Promise */

        var __assign = function () {
          __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
          };
          return __assign.apply(this, arguments);
        };
        function __rest(s, e) {
          var t = {};
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
          }
          return t;
        }
        function __values(o) {
          var s = typeof Symbol === "function" && Symbol.iterator,
            m = s && o[s],
            i = 0;
          if (m) return m.call(o);
          if (o && typeof o.length === "number") return {
            next: function () {
              if (o && i >= o.length) o = void 0;
              return {
                value: o && o[i++],
                done: !o
              };
            }
          };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }
        function __read(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m) return o;
          var i = m.call(o),
            r,
            ar = [],
            e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
          } catch (error) {
            e = {
              error: error
            };
          } finally {
            try {
              if (r && !r.done && (m = i["return"])) m.call(i);
            } finally {
              if (e) throw e.error;
            }
          }
          return ar;
        }
        function __spread() {
          for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
          return ar;
        }

        /**
         * Get the active drag position given its initial
         * coordinates and grid meta
         * @param index
         * @param grid
         * @param dx
         * @param dy
         */
        function getDragPosition(index, grid, dx, dy, center) {
          var _a = __read(getPositionForIndex(index, grid).xy, 2),
            left = _a[0],
            top = _a[1];
          return {
            xy: [left + dx + (center ? grid.columnWidth / 2 : 0), top + dy + (center ? grid.rowHeight / 2 : 0)]
          };
        }
        /**
         * Get the relative top, left position for a particular
         * index in a grid
         * @param i
         * @param grid
         * @param traverseIndex (destination for traverse)
         */
        function getPositionForIndex(i, _a, traverseIndex) {
          var boxesPerRow = _a.boxesPerRow,
            rowHeight = _a.rowHeight,
            columnWidth = _a.columnWidth;
          var index = typeof traverseIndex == "number" ? i >= traverseIndex ? i + 1 : i : i;
          var x = index % boxesPerRow * columnWidth;
          var y = Math.floor(index / boxesPerRow) * rowHeight;
          return {
            xy: [x, y]
          };
        }
        /**
         * Given relative coordinates, determine which index
         * we are currently in
         * @param x
         * @param y
         * @param param2
         */
        function getIndexFromCoordinates(x, y, _a, count) {
          var rowHeight = _a.rowHeight,
            boxesPerRow = _a.boxesPerRow,
            columnWidth = _a.columnWidth;
          var index = Math.floor(y / rowHeight) * boxesPerRow + Math.floor(x / columnWidth);
          return index >= count ? count : index;
        }
        /**
         * Get the target index during a drag
         * @param startIndex
         * @param grid
         * @param count
         * @param dx
         * @param dy
         */
        function getTargetIndex(startIndex, grid, count, dx, dy) {
          var _a = __read(getDragPosition(startIndex, grid, dx, dy, true).xy, 2),
            cx = _a[0],
            cy = _a[1];
          return getIndexFromCoordinates(cx, cy, grid, count);
        }
        var noop = function () {
          throw new Error("Make sure that you have wrapped your drop zones with GridContext");
        };
        var GridContext = reactExports.createContext({
          register: noop,
          remove: noop,
          getActiveDropId: noop,
          startTraverse: noop,
          measureAll: noop,
          traverse: null,
          endTraverse: noop,
          onChange: noop
        });
        function GridContextProvider(_a) {
          var children = _a.children,
            onChange = _a.onChange;
          var _b = __read(reactExports.useState(null), 2),
            traverse = _b[0],
            setTraverse = _b[1];
          var dropRefs = reactExports.useRef(new Map());
          /**
           * Register a drop zone with relevant information
           * @param id
           * @param options
           */
          function register(id, options) {
            dropRefs.current.set(id, options);
          }
          /**
           * Remove a drop zone (typically on unmount)
           * @param id
           */
          function remove(id) {
            dropRefs.current.delete(id);
          }
          /**
           * Determine the fixed position (pageX) of an item
           * @param sourceId
           * @param rx relative x
           * @param ry relative y
           */
          function getFixedPosition(sourceId, rx, ry) {
            var item = dropRefs.current.get(sourceId);
            // When items are removed from the DOM, the left and top values could be undefined.
            if (!item) {
              return {
                x: rx,
                y: ry
              };
            }
            var left = item.left,
              top = item.top;
            return {
              x: left + rx,
              y: top + ry
            };
          }
          /**
           * Get a relative position for a target dropzone given
           * a fixed position
           * @param targetId
           * @param fx fixed x
           * @param fy fixed y
           */
          function getRelativePosition(targetId, fx, fy) {
            var _a = dropRefs.current.get(targetId),
              left = _a.left,
              top = _a.top;
            return {
              x: fx - left,
              y: fy - top
            };
          }
          /**
           * Determine the difference in coordinates between
           * two dropzones
           * @param sourceId
           * @param targetId
           */
          function diffDropzones(sourceId, targetId) {
            var sBounds = dropRefs.current.get(sourceId);
            var tBounds = dropRefs.current.get(targetId);
            return {
              x: tBounds.left - sBounds.left,
              y: tBounds.top - sBounds.top
            };
          }
          /**
           * Determine which dropzone we are actively dragging over
           * @param sourceId
           * @param x
           * @param y
           */
          function getActiveDropId(sourceId, x, y) {
            var e_1, _a;
            var _b = getFixedPosition(sourceId, x, y),
              fx = _b.x,
              fy = _b.y;
            try {
              // probably faster just using an array for dropRefs
              for (var _c = __values(dropRefs.current.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {
                var _e = __read(_d.value, 2),
                  key = _e[0],
                  bounds = _e[1];
                if (!bounds.disableDrop && fx > bounds.left && fx < bounds.right && fy > bounds.top && fy < bounds.bottom) {
                  return key;
                }
              }
            } catch (e_1_1) {
              e_1 = {
                error: e_1_1
              };
            } finally {
              try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
            return null;
          }
          /**
           * Trigger a traversal (when one item is being dropped
           * on a different dropzone)
           * @param sourceId
           * @param targetId
           * @param x
           * @param y
           * @param sourceIndex
           */
          function startTraverse(sourceId, targetId, x, y, sourceIndex) {
            var _a = getFixedPosition(sourceId, x, y),
              fx = _a.x,
              fy = _a.y;
            var _b = getRelativePosition(targetId, fx, fy),
              rx = _b.x,
              ry = _b.y;
            var _c = dropRefs.current.get(targetId),
              targetGrid = _c.grid,
              count = _c.count;
            var targetIndex = getIndexFromCoordinates(rx + targetGrid.columnWidth / 2, ry + targetGrid.rowHeight / 2, targetGrid, count);
            var _d = __read(getPositionForIndex(targetIndex, targetGrid).xy, 2),
              px = _d[0],
              py = _d[1];
            var _e = diffDropzones(sourceId, targetId),
              dx = _e.x,
              dy = _e.y;
            // only update traverse if targetId or targetIndex have changed
            if (!traverse || !(traverse && traverse.targetIndex !== targetIndex && traverse.targetId !== targetId)) {
              setTraverse({
                rx: px + dx,
                ry: py + dy,
                tx: rx,
                ty: ry,
                sourceId: sourceId,
                targetId: targetId,
                sourceIndex: sourceIndex,
                targetIndex: targetIndex
              });
            }
          }
          /**
           * End any active traversals
           */
          function endTraverse() {
            setTraverse(null);
          }
          /**
           * Perform a change to list item arrays.
           * If it doesn't include targetId, it's a switch
           * of order within the one array itself.
           */
          function onSwitch(sourceId, sourceIndex, targetIndex, targetId) {
            // this is a bit hacky, but seems to work for now. The idea
            // is that we want our newly mounted traversed grid item
            // to start its animation from the last target location.
            // Execute informs our GridDropZone to remove the placeholder
            // but to pass the initial location to the newly mounted
            // grid item at the specified index.
            // The problem here is that it's async, so potentially something
            // could mount in its place in between setTraversal and onChange
            // executing. Or maybe onChange won't do anything, in which case
            // our state is kinda messed up.
            // So it's sorta a controlled component, but not really, because
            // if you don't do what we suggest, then it gets messed up.
            // One solution is to bring the state in-component and force
            // the state to be updated by us, since it's basically required
            // anyway.
            // We could possibly also use a unique identifier for the grid (besides
            // the index). This could still result in weirdness, but would
            // be more unlikely.
            // Ultimately it's kinda messed because we are trying to do something
            // imperative in a declarative interface.
            setTraverse(__assign({}, traverse, {
              execute: true
            }));
            onChange(sourceId, sourceIndex, targetIndex, targetId);
          }
          function measureAll() {
            dropRefs.current.forEach(function (ref) {
              ref.remeasure();
            });
          }
          return reactExports.createElement(GridContext.Provider, {
            value: {
              register: register,
              remove: remove,
              getActiveDropId: getActiveDropId,
              startTraverse: startTraverse,
              traverse: traverse,
              measureAll: measureAll,
              endTraverse: endTraverse,
              onChange: onSwitch
            }
          }, children);
        }

        /**
         * A collection of shims that provide minimal functionality of the ES6 collections.
         *
         * These implementations are not meant to be used outside of the ResizeObserver
         * modules as they cover only a limited range of use cases.
         */
        /* eslint-disable require-jsdoc, valid-jsdoc */
        var MapShim = function () {
          if (typeof Map !== 'undefined') {
            return Map;
          }
          /**
           * Returns index in provided array that matches the specified key.
           *
           * @param {Array<Array>} arr
           * @param {*} key
           * @returns {number}
           */
          function getIndex(arr, key) {
            var result = -1;
            arr.some(function (entry, index) {
              if (entry[0] === key) {
                result = index;
                return true;
              }
              return false;
            });
            return result;
          }
          return (/** @class */function () {
              function class_1() {
                this.__entries__ = [];
              }
              Object.defineProperty(class_1.prototype, "size", {
                /**
                 * @returns {boolean}
                 */
                get: function () {
                  return this.__entries__.length;
                },
                enumerable: true,
                configurable: true
              });
              /**
               * @param {*} key
               * @returns {*}
               */
              class_1.prototype.get = function (key) {
                var index = getIndex(this.__entries__, key);
                var entry = this.__entries__[index];
                return entry && entry[1];
              };
              /**
               * @param {*} key
               * @param {*} value
               * @returns {void}
               */
              class_1.prototype.set = function (key, value) {
                var index = getIndex(this.__entries__, key);
                if (~index) {
                  this.__entries__[index][1] = value;
                } else {
                  this.__entries__.push([key, value]);
                }
              };
              /**
               * @param {*} key
               * @returns {void}
               */
              class_1.prototype.delete = function (key) {
                var entries = this.__entries__;
                var index = getIndex(entries, key);
                if (~index) {
                  entries.splice(index, 1);
                }
              };
              /**
               * @param {*} key
               * @returns {void}
               */
              class_1.prototype.has = function (key) {
                return !!~getIndex(this.__entries__, key);
              };
              /**
               * @returns {void}
               */
              class_1.prototype.clear = function () {
                this.__entries__.splice(0);
              };
              /**
               * @param {Function} callback
               * @param {*} [ctx=null]
               * @returns {void}
               */
              class_1.prototype.forEach = function (callback, ctx) {
                if (ctx === void 0) {
                  ctx = null;
                }
                for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                  var entry = _a[_i];
                  callback.call(ctx, entry[1], entry[0]);
                }
              };
              return class_1;
            }()
          );
        }();

        /**
         * Detects whether window and document objects are available in current environment.
         */
        var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

        // Returns global object of a current environment.
        var global$1 = function () {
          if (typeof global !== 'undefined' && global.Math === Math) {
            return global;
          }
          if (typeof self !== 'undefined' && self.Math === Math) {
            return self;
          }
          if (typeof window !== 'undefined' && window.Math === Math) {
            return window;
          }
          // eslint-disable-next-line no-new-func
          return Function('return this')();
        }();

        /**
         * A shim for the requestAnimationFrame which falls back to the setTimeout if
         * first one is not supported.
         *
         * @returns {number} Requests' identifier.
         */
        var requestAnimationFrame$1$1 = function () {
          if (typeof requestAnimationFrame === 'function') {
            // It's required to use a bounded function because IE sometimes throws
            // an "Invalid calling object" error if rAF is invoked without the global
            // object on the left hand side.
            return requestAnimationFrame.bind(global$1);
          }
          return function (callback) {
            return setTimeout(function () {
              return callback(Date.now());
            }, 1000 / 60);
          };
        }();

        // Defines minimum timeout before adding a trailing call.
        var trailingTimeout = 2;
        /**
         * Creates a wrapper function which ensures that provided callback will be
         * invoked only once during the specified delay period.
         *
         * @param {Function} callback - Function to be invoked after the delay period.
         * @param {number} delay - Delay after which to invoke callback.
         * @returns {Function}
         */
        function throttle$1(callback, delay) {
          var leadingCall = false,
            trailingCall = false,
            lastCallTime = 0;
          /**
           * Invokes the original callback function and schedules new invocation if
           * the "proxy" was called during current request.
           *
           * @returns {void}
           */
          function resolvePending() {
            if (leadingCall) {
              leadingCall = false;
              callback();
            }
            if (trailingCall) {
              proxy();
            }
          }
          /**
           * Callback invoked after the specified delay. It will further postpone
           * invocation of the original function delegating it to the
           * requestAnimationFrame.
           *
           * @returns {void}
           */
          function timeoutCallback() {
            requestAnimationFrame$1$1(resolvePending);
          }
          /**
           * Schedules invocation of the original function.
           *
           * @returns {void}
           */
          function proxy() {
            var timeStamp = Date.now();
            if (leadingCall) {
              // Reject immediately following calls.
              if (timeStamp - lastCallTime < trailingTimeout) {
                return;
              }
              // Schedule new call to be in invoked when the pending one is resolved.
              // This is important for "transitions" which never actually start
              // immediately so there is a chance that we might miss one if change
              // happens amids the pending invocation.
              trailingCall = true;
            } else {
              leadingCall = true;
              trailingCall = false;
              setTimeout(timeoutCallback, delay);
            }
            lastCallTime = timeStamp;
          }
          return proxy;
        }

        // Minimum delay before invoking the update of observers.
        var REFRESH_DELAY = 20;
        // A list of substrings of CSS properties used to find transition events that
        // might affect dimensions of observed elements.
        var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
        // Check if MutationObserver is available.
        var mutationObserverSupported = typeof MutationObserver !== 'undefined';
        /**
         * Singleton controller class which handles updates of ResizeObserver instances.
         */
        var ResizeObserverController = /** @class */function () {
          /**
           * Creates a new instance of ResizeObserverController.
           *
           * @private
           */
          function ResizeObserverController() {
            /**
             * Indicates whether DOM listeners have been added.
             *
             * @private {boolean}
             */
            this.connected_ = false;
            /**
             * Tells that controller has subscribed for Mutation Events.
             *
             * @private {boolean}
             */
            this.mutationEventsAdded_ = false;
            /**
             * Keeps reference to the instance of MutationObserver.
             *
             * @private {MutationObserver}
             */
            this.mutationsObserver_ = null;
            /**
             * A list of connected observers.
             *
             * @private {Array<ResizeObserverSPI>}
             */
            this.observers_ = [];
            this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
            this.refresh = throttle$1(this.refresh.bind(this), REFRESH_DELAY);
          }
          /**
           * Adds observer to observers list.
           *
           * @param {ResizeObserverSPI} observer - Observer to be added.
           * @returns {void}
           */
          ResizeObserverController.prototype.addObserver = function (observer) {
            if (!~this.observers_.indexOf(observer)) {
              this.observers_.push(observer);
            }
            // Add listeners if they haven't been added yet.
            if (!this.connected_) {
              this.connect_();
            }
          };
          /**
           * Removes observer from observers list.
           *
           * @param {ResizeObserverSPI} observer - Observer to be removed.
           * @returns {void}
           */
          ResizeObserverController.prototype.removeObserver = function (observer) {
            var observers = this.observers_;
            var index = observers.indexOf(observer);
            // Remove observer if it's present in registry.
            if (~index) {
              observers.splice(index, 1);
            }
            // Remove listeners if controller has no connected observers.
            if (!observers.length && this.connected_) {
              this.disconnect_();
            }
          };
          /**
           * Invokes the update of observers. It will continue running updates insofar
           * it detects changes.
           *
           * @returns {void}
           */
          ResizeObserverController.prototype.refresh = function () {
            var changesDetected = this.updateObservers_();
            // Continue running updates if changes have been detected as there might
            // be future ones caused by CSS transitions.
            if (changesDetected) {
              this.refresh();
            }
          };
          /**
           * Updates every observer from observers list and notifies them of queued
           * entries.
           *
           * @private
           * @returns {boolean} Returns "true" if any observer has detected changes in
           *      dimensions of it's elements.
           */
          ResizeObserverController.prototype.updateObservers_ = function () {
            // Collect observers that have active observations.
            var activeObservers = this.observers_.filter(function (observer) {
              return observer.gatherActive(), observer.hasActive();
            });
            // Deliver notifications in a separate cycle in order to avoid any
            // collisions between observers, e.g. when multiple instances of
            // ResizeObserver are tracking the same element and the callback of one
            // of them changes content dimensions of the observed target. Sometimes
            // this may result in notifications being blocked for the rest of observers.
            activeObservers.forEach(function (observer) {
              return observer.broadcastActive();
            });
            return activeObservers.length > 0;
          };
          /**
           * Initializes DOM listeners.
           *
           * @private
           * @returns {void}
           */
          ResizeObserverController.prototype.connect_ = function () {
            // Do nothing if running in a non-browser environment or if listeners
            // have been already added.
            if (!isBrowser || this.connected_) {
              return;
            }
            // Subscription to the "Transitionend" event is used as a workaround for
            // delayed transitions. This way it's possible to capture at least the
            // final state of an element.
            document.addEventListener('transitionend', this.onTransitionEnd_);
            window.addEventListener('resize', this.refresh);
            if (mutationObserverSupported) {
              this.mutationsObserver_ = new MutationObserver(this.refresh);
              this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
              });
            } else {
              document.addEventListener('DOMSubtreeModified', this.refresh);
              this.mutationEventsAdded_ = true;
            }
            this.connected_ = true;
          };
          /**
           * Removes DOM listeners.
           *
           * @private
           * @returns {void}
           */
          ResizeObserverController.prototype.disconnect_ = function () {
            // Do nothing if running in a non-browser environment or if listeners
            // have been already removed.
            if (!isBrowser || !this.connected_) {
              return;
            }
            document.removeEventListener('transitionend', this.onTransitionEnd_);
            window.removeEventListener('resize', this.refresh);
            if (this.mutationsObserver_) {
              this.mutationsObserver_.disconnect();
            }
            if (this.mutationEventsAdded_) {
              document.removeEventListener('DOMSubtreeModified', this.refresh);
            }
            this.mutationsObserver_ = null;
            this.mutationEventsAdded_ = false;
            this.connected_ = false;
          };
          /**
           * "Transitionend" event handler.
           *
           * @private
           * @param {TransitionEvent} event
           * @returns {void}
           */
          ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
            var _b = _a.propertyName,
              propertyName = _b === void 0 ? '' : _b;
            // Detect whether transition may affect dimensions of an element.
            var isReflowProperty = transitionKeys.some(function (key) {
              return !!~propertyName.indexOf(key);
            });
            if (isReflowProperty) {
              this.refresh();
            }
          };
          /**
           * Returns instance of the ResizeObserverController.
           *
           * @returns {ResizeObserverController}
           */
          ResizeObserverController.getInstance = function () {
            if (!this.instance_) {
              this.instance_ = new ResizeObserverController();
            }
            return this.instance_;
          };
          /**
           * Holds reference to the controller's instance.
           *
           * @private {ResizeObserverController}
           */
          ResizeObserverController.instance_ = null;
          return ResizeObserverController;
        }();

        /**
         * Defines non-writable/enumerable properties of the provided target object.
         *
         * @param {Object} target - Object for which to define properties.
         * @param {Object} props - Properties to be defined.
         * @returns {Object} Target object.
         */
        var defineConfigurable = function (target, props) {
          for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
            var key = _a[_i];
            Object.defineProperty(target, key, {
              value: props[key],
              enumerable: false,
              writable: false,
              configurable: true
            });
          }
          return target;
        };

        /**
         * Returns the global object associated with provided element.
         *
         * @param {Object} target
         * @returns {Object}
         */
        var getWindowOf = function (target) {
          // Assume that the element is an instance of Node, which means that it
          // has the "ownerDocument" property from which we can retrieve a
          // corresponding global object.
          var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
          // Return the local global object if it's not possible extract one from
          // provided element.
          return ownerGlobal || global$1;
        };

        // Placeholder of an empty content rectangle.
        var emptyRect = createRectInit(0, 0, 0, 0);
        /**
         * Converts provided string to a number.
         *
         * @param {number|string} value
         * @returns {number}
         */
        function toFloat(value) {
          return parseFloat(value) || 0;
        }
        /**
         * Extracts borders size from provided styles.
         *
         * @param {CSSStyleDeclaration} styles
         * @param {...string} positions - Borders positions (top, right, ...)
         * @returns {number}
         */
        function getBordersSize(styles) {
          var positions = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            positions[_i - 1] = arguments[_i];
          }
          return positions.reduce(function (size, position) {
            var value = styles['border-' + position + '-width'];
            return size + toFloat(value);
          }, 0);
        }
        /**
         * Extracts paddings sizes from provided styles.
         *
         * @param {CSSStyleDeclaration} styles
         * @returns {Object} Paddings box.
         */
        function getPaddings(styles) {
          var positions = ['top', 'right', 'bottom', 'left'];
          var paddings = {};
          for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
            var position = positions_1[_i];
            var value = styles['padding-' + position];
            paddings[position] = toFloat(value);
          }
          return paddings;
        }
        /**
         * Calculates content rectangle of provided SVG element.
         *
         * @param {SVGGraphicsElement} target - Element content rectangle of which needs
         *      to be calculated.
         * @returns {DOMRectInit}
         */
        function getSVGContentRect(target) {
          var bbox = target.getBBox();
          return createRectInit(0, 0, bbox.width, bbox.height);
        }
        /**
         * Calculates content rectangle of provided HTMLElement.
         *
         * @param {HTMLElement} target - Element for which to calculate the content rectangle.
         * @returns {DOMRectInit}
         */
        function getHTMLElementContentRect(target) {
          // Client width & height properties can't be
          // used exclusively as they provide rounded values.
          var clientWidth = target.clientWidth,
            clientHeight = target.clientHeight;
          // By this condition we can catch all non-replaced inline, hidden and
          // detached elements. Though elements with width & height properties less
          // than 0.5 will be discarded as well.
          //
          // Without it we would need to implement separate methods for each of
          // those cases and it's not possible to perform a precise and performance
          // effective test for hidden elements. E.g. even jQuery's ':visible' filter
          // gives wrong results for elements with width & height less than 0.5.
          if (!clientWidth && !clientHeight) {
            return emptyRect;
          }
          var styles = getWindowOf(target).getComputedStyle(target);
          var paddings = getPaddings(styles);
          var horizPad = paddings.left + paddings.right;
          var vertPad = paddings.top + paddings.bottom;
          // Computed styles of width & height are being used because they are the
          // only dimensions available to JS that contain non-rounded values. It could
          // be possible to utilize the getBoundingClientRect if only it's data wasn't
          // affected by CSS transformations let alone paddings, borders and scroll bars.
          var width = toFloat(styles.width),
            height = toFloat(styles.height);
          // Width & height include paddings and borders when the 'border-box' box
          // model is applied (except for IE).
          if (styles.boxSizing === 'border-box') {
            // Following conditions are required to handle Internet Explorer which
            // doesn't include paddings and borders to computed CSS dimensions.
            //
            // We can say that if CSS dimensions + paddings are equal to the "client"
            // properties then it's either IE, and thus we don't need to subtract
            // anything, or an element merely doesn't have paddings/borders styles.
            if (Math.round(width + horizPad) !== clientWidth) {
              width -= getBordersSize(styles, 'left', 'right') + horizPad;
            }
            if (Math.round(height + vertPad) !== clientHeight) {
              height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
            }
          }
          // Following steps can't be applied to the document's root element as its
          // client[Width/Height] properties represent viewport area of the window.
          // Besides, it's as well not necessary as the <html> itself neither has
          // rendered scroll bars nor it can be clipped.
          if (!isDocumentElement(target)) {
            // In some browsers (only in Firefox, actually) CSS width & height
            // include scroll bars size which can be removed at this step as scroll
            // bars are the only difference between rounded dimensions + paddings
            // and "client" properties, though that is not always true in Chrome.
            var vertScrollbar = Math.round(width + horizPad) - clientWidth;
            var horizScrollbar = Math.round(height + vertPad) - clientHeight;
            // Chrome has a rather weird rounding of "client" properties.
            // E.g. for an element with content width of 314.2px it sometimes gives
            // the client width of 315px and for the width of 314.7px it may give
            // 314px. And it doesn't happen all the time. So just ignore this delta
            // as a non-relevant.
            if (Math.abs(vertScrollbar) !== 1) {
              width -= vertScrollbar;
            }
            if (Math.abs(horizScrollbar) !== 1) {
              height -= horizScrollbar;
            }
          }
          return createRectInit(paddings.left, paddings.top, width, height);
        }
        /**
         * Checks whether provided element is an instance of the SVGGraphicsElement.
         *
         * @param {Element} target - Element to be checked.
         * @returns {boolean}
         */
        var isSVGGraphicsElement = function () {
          // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
          // interface.
          if (typeof SVGGraphicsElement !== 'undefined') {
            return function (target) {
              return target instanceof getWindowOf(target).SVGGraphicsElement;
            };
          }
          // If it's so, then check that element is at least an instance of the
          // SVGElement and that it has the "getBBox" method.
          // eslint-disable-next-line no-extra-parens
          return function (target) {
            return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function';
          };
        }();
        /**
         * Checks whether provided element is a document element (<html>).
         *
         * @param {Element} target - Element to be checked.
         * @returns {boolean}
         */
        function isDocumentElement(target) {
          return target === getWindowOf(target).document.documentElement;
        }
        /**
         * Calculates an appropriate content rectangle for provided html or svg element.
         *
         * @param {Element} target - Element content rectangle of which needs to be calculated.
         * @returns {DOMRectInit}
         */
        function getContentRect(target) {
          if (!isBrowser) {
            return emptyRect;
          }
          if (isSVGGraphicsElement(target)) {
            return getSVGContentRect(target);
          }
          return getHTMLElementContentRect(target);
        }
        /**
         * Creates rectangle with an interface of the DOMRectReadOnly.
         * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
         *
         * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
         * @returns {DOMRectReadOnly}
         */
        function createReadOnlyRect(_a) {
          var x = _a.x,
            y = _a.y,
            width = _a.width,
            height = _a.height;
          // If DOMRectReadOnly is available use it as a prototype for the rectangle.
          var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
          var rect = Object.create(Constr.prototype);
          // Rectangle's properties are not writable and non-enumerable.
          defineConfigurable(rect, {
            x: x,
            y: y,
            width: width,
            height: height,
            top: y,
            right: x + width,
            bottom: height + y,
            left: x
          });
          return rect;
        }
        /**
         * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
         * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
         *
         * @param {number} x - X coordinate.
         * @param {number} y - Y coordinate.
         * @param {number} width - Rectangle's width.
         * @param {number} height - Rectangle's height.
         * @returns {DOMRectInit}
         */
        function createRectInit(x, y, width, height) {
          return {
            x: x,
            y: y,
            width: width,
            height: height
          };
        }

        /**
         * Class that is responsible for computations of the content rectangle of
         * provided DOM element and for keeping track of it's changes.
         */
        var ResizeObservation = /** @class */function () {
          /**
           * Creates an instance of ResizeObservation.
           *
           * @param {Element} target - Element to be observed.
           */
          function ResizeObservation(target) {
            /**
             * Broadcasted width of content rectangle.
             *
             * @type {number}
             */
            this.broadcastWidth = 0;
            /**
             * Broadcasted height of content rectangle.
             *
             * @type {number}
             */
            this.broadcastHeight = 0;
            /**
             * Reference to the last observed content rectangle.
             *
             * @private {DOMRectInit}
             */
            this.contentRect_ = createRectInit(0, 0, 0, 0);
            this.target = target;
          }
          /**
           * Updates content rectangle and tells whether it's width or height properties
           * have changed since the last broadcast.
           *
           * @returns {boolean}
           */
          ResizeObservation.prototype.isActive = function () {
            var rect = getContentRect(this.target);
            this.contentRect_ = rect;
            return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
          };
          /**
           * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
           * from the corresponding properties of the last observed content rectangle.
           *
           * @returns {DOMRectInit} Last observed content rectangle.
           */
          ResizeObservation.prototype.broadcastRect = function () {
            var rect = this.contentRect_;
            this.broadcastWidth = rect.width;
            this.broadcastHeight = rect.height;
            return rect;
          };
          return ResizeObservation;
        }();
        var ResizeObserverEntry = /** @class */function () {
          /**
           * Creates an instance of ResizeObserverEntry.
           *
           * @param {Element} target - Element that is being observed.
           * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
           */
          function ResizeObserverEntry(target, rectInit) {
            var contentRect = createReadOnlyRect(rectInit);
            // According to the specification following properties are not writable
            // and are also not enumerable in the native implementation.
            //
            // Property accessors are not being used as they'd require to define a
            // private WeakMap storage which may cause memory leaks in browsers that
            // don't support this type of collections.
            defineConfigurable(this, {
              target: target,
              contentRect: contentRect
            });
          }
          return ResizeObserverEntry;
        }();
        var ResizeObserverSPI = /** @class */function () {
          /**
           * Creates a new instance of ResizeObserver.
           *
           * @param {ResizeObserverCallback} callback - Callback function that is invoked
           *      when one of the observed elements changes it's content dimensions.
           * @param {ResizeObserverController} controller - Controller instance which
           *      is responsible for the updates of observer.
           * @param {ResizeObserver} callbackCtx - Reference to the public
           *      ResizeObserver instance which will be passed to callback function.
           */
          function ResizeObserverSPI(callback, controller, callbackCtx) {
            /**
             * Collection of resize observations that have detected changes in dimensions
             * of elements.
             *
             * @private {Array<ResizeObservation>}
             */
            this.activeObservations_ = [];
            /**
             * Registry of the ResizeObservation instances.
             *
             * @private {Map<Element, ResizeObservation>}
             */
            this.observations_ = new MapShim();
            if (typeof callback !== 'function') {
              throw new TypeError('The callback provided as parameter 1 is not a function.');
            }
            this.callback_ = callback;
            this.controller_ = controller;
            this.callbackCtx_ = callbackCtx;
          }
          /**
           * Starts observing provided element.
           *
           * @param {Element} target - Element to be observed.
           * @returns {void}
           */
          ResizeObserverSPI.prototype.observe = function (target) {
            if (!arguments.length) {
              throw new TypeError('1 argument required, but only 0 present.');
            }
            // Do nothing if current environment doesn't have the Element interface.
            if (typeof Element === 'undefined' || !(Element instanceof Object)) {
              return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
              throw new TypeError('parameter 1 is not of type "Element".');
            }
            var observations = this.observations_;
            // Do nothing if element is already being observed.
            if (observations.has(target)) {
              return;
            }
            observations.set(target, new ResizeObservation(target));
            this.controller_.addObserver(this);
            // Force the update of observations.
            this.controller_.refresh();
          };
          /**
           * Stops observing provided element.
           *
           * @param {Element} target - Element to stop observing.
           * @returns {void}
           */
          ResizeObserverSPI.prototype.unobserve = function (target) {
            if (!arguments.length) {
              throw new TypeError('1 argument required, but only 0 present.');
            }
            // Do nothing if current environment doesn't have the Element interface.
            if (typeof Element === 'undefined' || !(Element instanceof Object)) {
              return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
              throw new TypeError('parameter 1 is not of type "Element".');
            }
            var observations = this.observations_;
            // Do nothing if element is not being observed.
            if (!observations.has(target)) {
              return;
            }
            observations.delete(target);
            if (!observations.size) {
              this.controller_.removeObserver(this);
            }
          };
          /**
           * Stops observing all elements.
           *
           * @returns {void}
           */
          ResizeObserverSPI.prototype.disconnect = function () {
            this.clearActive();
            this.observations_.clear();
            this.controller_.removeObserver(this);
          };
          /**
           * Collects observation instances the associated element of which has changed
           * it's content rectangle.
           *
           * @returns {void}
           */
          ResizeObserverSPI.prototype.gatherActive = function () {
            var _this = this;
            this.clearActive();
            this.observations_.forEach(function (observation) {
              if (observation.isActive()) {
                _this.activeObservations_.push(observation);
              }
            });
          };
          /**
           * Invokes initial callback function with a list of ResizeObserverEntry
           * instances collected from active resize observations.
           *
           * @returns {void}
           */
          ResizeObserverSPI.prototype.broadcastActive = function () {
            // Do nothing if observer doesn't have active observations.
            if (!this.hasActive()) {
              return;
            }
            var ctx = this.callbackCtx_;
            // Create ResizeObserverEntry instance for every active observation.
            var entries = this.activeObservations_.map(function (observation) {
              return new ResizeObserverEntry(observation.target, observation.broadcastRect());
            });
            this.callback_.call(ctx, entries, ctx);
            this.clearActive();
          };
          /**
           * Clears the collection of active observations.
           *
           * @returns {void}
           */
          ResizeObserverSPI.prototype.clearActive = function () {
            this.activeObservations_.splice(0);
          };
          /**
           * Tells whether observer has active observations.
           *
           * @returns {boolean}
           */
          ResizeObserverSPI.prototype.hasActive = function () {
            return this.activeObservations_.length > 0;
          };
          return ResizeObserverSPI;
        }();

        // Registry of internal observers. If WeakMap is not available use current shim
        // for the Map collection as it has all required methods and because WeakMap
        // can't be fully polyfilled anyway.
        var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
        /**
         * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
         * exposing only those methods and properties that are defined in the spec.
         */
        var ResizeObserver = /** @class */function () {
          /**
           * Creates a new instance of ResizeObserver.
           *
           * @param {ResizeObserverCallback} callback - Callback that is invoked when
           *      dimensions of the observed elements change.
           */
          function ResizeObserver(callback) {
            if (!(this instanceof ResizeObserver)) {
              throw new TypeError('Cannot call a class as a function.');
            }
            if (!arguments.length) {
              throw new TypeError('1 argument required, but only 0 present.');
            }
            var controller = ResizeObserverController.getInstance();
            var observer = new ResizeObserverSPI(callback, controller, this);
            observers.set(this, observer);
          }
          return ResizeObserver;
        }();
        // Expose public methods of ResizeObserver.
        ['observe', 'unobserve', 'disconnect'].forEach(function (method) {
          ResizeObserver.prototype[method] = function () {
            var _a;
            return (_a = observers.get(this))[method].apply(_a, arguments);
          };
        });
        var index = function () {
          // Export existing implementation if available.
          if (typeof global$1.ResizeObserver !== 'undefined') {
            return global$1.ResizeObserver;
          }
          return ResizeObserver;
        }();
        function useMeasure(ref) {
          var _a = __read(reactExports.useState({
              left: 0,
              top: 0,
              width: 0,
              height: 0,
              right: 0,
              bottom: 0
            }), 2),
            bounds = _a[0],
            setBounds = _a[1];
          var _b = __read(reactExports.useState(function () {
              return new index(function (_a) {
                var _b = __read(_a, 1),
                  entry = _b[0];
                setBounds(entry.target.getBoundingClientRect());
              });
            }), 1),
            observer = _b[0];
          reactExports.useLayoutEffect(function () {
            if (ref.current) {
              observer.observe(ref.current);
            }
            return function () {
              return observer.disconnect();
            };
          }, [ref, observer]);
          function remeasure() {
            setBounds(ref.current.getBoundingClientRect());
          }
          return {
            bounds: bounds,
            remeasure: remeasure
          };
        }
        function swap(array, moveIndex, toIndex) {
          /* #move - Moves an array item from one position in an array to another.
             Note: This is a pure function so a new array will be returned, instead
             of altering the array argument.
            Arguments:
            1. array     (String) : Array in which to move an item.         (required)
            2. moveIndex (Object) : The index of the item to move.          (required)
            3. toIndex   (Object) : The index to move item at moveIndex to. (required)
          */
          var item = array[moveIndex];
          var length = array.length;
          var diff = moveIndex - toIndex;
          if (diff > 0) {
            // move left
            return __spread(array.slice(0, toIndex), [item], array.slice(toIndex, moveIndex), array.slice(moveIndex + 1, length));
          } else if (diff < 0) {
            // move right
            var targetIndex = toIndex + 1;
            return __spread(array.slice(0, moveIndex), array.slice(moveIndex + 1, targetIndex), [item], array.slice(targetIndex, length));
          }
          return array;
        }
        var GridItemContext = reactExports.createContext(null);
        function GridDropZone(_a) {
          var id = _a.id,
            boxesPerRow = _a.boxesPerRow,
            children = _a.children,
            style = _a.style,
            _b = _a.disableDrag,
            disableDrag = _b === void 0 ? false : _b,
            _c = _a.disableDrop,
            disableDrop = _c === void 0 ? false : _c,
            rowHeight = _a.rowHeight,
            other = __rest(_a, ["id", "boxesPerRow", "children", "style", "disableDrag", "disableDrop", "rowHeight"]);
          var _d = reactExports.useContext(GridContext),
            traverse = _d.traverse,
            startTraverse = _d.startTraverse,
            endTraverse = _d.endTraverse,
            register = _d.register,
            measureAll = _d.measureAll,
            onChange = _d.onChange,
            remove = _d.remove,
            getActiveDropId = _d.getActiveDropId;
          var ref = reactExports.useRef(null);
          var _e = useMeasure(ref),
            bounds = _e.bounds,
            remeasure = _e.remeasure;
          var _f = __read(reactExports.useState(null), 2),
            draggingIndex = _f[0],
            setDraggingIndex = _f[1];
          var _g = __read(reactExports.useState(null), 2),
            placeholder = _g[0],
            setPlaceholder = _g[1];
          var traverseIndex = traverse && !traverse.execute && traverse.targetId === id ? traverse.targetIndex : null;
          var grid = {
            columnWidth: bounds.width / boxesPerRow,
            boxesPerRow: boxesPerRow,
            rowHeight: rowHeight
          };
          var childCount = reactExports.Children.count(children);
          /**
           * Register our dropzone with our grid context
           */
          reactExports.useEffect(function () {
            register(id, {
              top: bounds.top,
              bottom: bounds.bottom,
              left: bounds.left,
              right: bounds.right,
              width: bounds.width,
              height: bounds.height,
              count: childCount,
              grid: grid,
              disableDrop: disableDrop,
              remeasure: remeasure
            });
          }, [childCount, disableDrop, bounds, id, grid]);
          /**
           * Unregister when unmounting
           */
          reactExports.useEffect(function () {
            return function () {
              return remove(id);
            };
          }, [id]);
          // keep an initial list of our item indexes. We use this
          // when animating swap positions on drag events
          var itemsIndexes = reactExports.Children.map(children, function (_, i) {
            return i;
          });
          return reactExports.createElement("div", __assign({
            ref: ref,
            style: __assign({
              position: "relative"
            }, style)
          }, other), grid.columnWidth === 0 ? null : reactExports.Children.map(children, function (child, i) {
            var isTraverseTarget = traverse && traverse.targetId === id && traverse.targetIndex === i;
            var order = placeholder ? swap(itemsIndexes, placeholder.startIndex, placeholder.targetIndex) : itemsIndexes;
            var pos = getPositionForIndex(order.indexOf(i), grid, traverseIndex);
            /**
             * Handle a child being dragged
             * @param state
             * @param x
             * @param y
             */
            function onMove(state, x, y) {
              if (!ref.current) return;
              if (draggingIndex !== i) {
                setDraggingIndex(i);
              }
              var targetDropId = getActiveDropId(id, x + grid.columnWidth / 2, y + grid.rowHeight / 2);
              if (targetDropId && targetDropId !== id) {
                startTraverse(id, targetDropId, x, y, i);
              } else {
                endTraverse();
              }
              var targetIndex = targetDropId !== id ? childCount : getTargetIndex(i, grid, childCount, state.delta[0], state.delta[1]);
              if (targetIndex !== i) {
                if (placeholder && placeholder.targetIndex !== targetIndex || !placeholder) {
                  setPlaceholder({
                    targetIndex: targetIndex,
                    startIndex: i
                  });
                }
              } else if (placeholder) {
                setPlaceholder(null);
              }
            }
            /**
             * Handle drag end events
             */
            function onEnd(state, x, y) {
              var targetDropId = getActiveDropId(id, x + grid.columnWidth / 2, y + grid.rowHeight / 2);
              var targetIndex = targetDropId !== id ? childCount : getTargetIndex(i, grid, childCount, state.delta[0], state.delta[1]);
              // traverse?
              if (traverse) {
                onChange(traverse.sourceId, traverse.sourceIndex, traverse.targetIndex, traverse.targetId);
              } else {
                onChange(id, i, targetIndex);
              }
              setPlaceholder(null);
              setDraggingIndex(null);
            }
            function onStart() {
              measureAll();
            }
            return reactExports.createElement(GridItemContext.Provider, {
              value: {
                top: pos.xy[1],
                disableDrag: disableDrag,
                endTraverse: endTraverse,
                mountWithTraverseTarget: isTraverseTarget ? [traverse.tx, traverse.ty] : undefined,
                left: pos.xy[0],
                i: i,
                onMove: onMove,
                onEnd: onEnd,
                onStart: onStart,
                grid: grid,
                dragging: i === draggingIndex
              }
            }, child);
          }));
        }
        var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
        var isEnabled = false;
        var MOUSE_MOVE_THRESHOLD = 1000;
        var lastTouchTimestamp = 0;
        function enableMouse() {
          if (isEnabled || Date.now() - lastTouchTimestamp < MOUSE_MOVE_THRESHOLD) {
            return;
          }
          isEnabled = true;
        }
        function disableMouse() {
          lastTouchTimestamp = Date.now();
          if (isEnabled) {
            isEnabled = false;
          }
        }
        if (canUseDOM) {
          document.addEventListener("touchstart", disableMouse, true);
          document.addEventListener("touchmove", disableMouse, true);
          document.addEventListener("mousemove", enableMouse, true);
        }
        function isMouseEnabled() {
          return isEnabled;
        }
        var initialState = {
          time: Date.now(),
          xy: [0, 0],
          delta: [0, 0],
          initial: [0, 0],
          previous: [0, 0],
          direction: [0, 0],
          initialDirection: [0, 0],
          local: [0, 0],
          lastLocal: [0, 0],
          velocity: 0,
          distance: 0
        };
        var defaultConfig = {
          enableMouse: true
        };
        var grantedTouch = null;
        function useGestureResponder(options, config) {
          if (options === void 0) {
            options = {};
          }
          if (config === void 0) {
            config = {};
          }
          var state = reactExports.useRef(initialState);
          var _a = __assign({}, defaultConfig, config),
            uid = _a.uid,
            enableMouse = _a.enableMouse;
          var id = reactExports.useRef(uid || Math.random());
          var pressed = reactExports.useRef(false);
          // update our callbacks when they change
          var callbackRefs = reactExports.useRef(options);
          reactExports.useEffect(function () {
            callbackRefs.current = options;
          }, [options]);
          /**
           * Attempt to claim the active touch
           */
          function claimTouch(e) {
            if (grantedTouch && grantedTouch.onTerminationRequest(e)) {
              grantedTouch.onTerminate(e);
              grantedTouch = null;
            }
            attemptGrant(e);
          }
          /**
           * Attempt to claim the active touch
           * @param e
           */
          function attemptGrant(e) {
            // if a touch is already active we won't register
            if (grantedTouch) {
              return;
            }
            grantedTouch = {
              id: id.current,
              onTerminate: onTerminate,
              onTerminationRequest: onTerminationRequest
            };
            onGrant(e);
          }
          function bindGlobalMouseEvents() {
            window.addEventListener("mousemove", handleMoveMouse, false);
            window.addEventListener("mousemove", handleMoveMouseCapture, true);
            window.addEventListener("mouseup", handleEndMouse);
          }
          function unbindGlobalMouseEvents() {
            window.removeEventListener("mousemove", handleMoveMouse, false);
            window.removeEventListener("mousemove", handleMoveMouseCapture, true);
            window.removeEventListener("mouseup", handleEndMouse);
          }
          function handleStartCapture(e) {
            updateStartState(e);
            pressed.current = true;
            var granted = onStartShouldSetCapture(e);
            if (granted) {
              attemptGrant(e);
            }
          }
          function handleStart(e) {
            updateStartState(e);
            pressed.current = true;
            bindGlobalMouseEvents();
            var granted = onStartShouldSet(e);
            if (granted) {
              attemptGrant(e);
            }
          }
          function isGrantedTouch() {
            return grantedTouch && grantedTouch.id === id.current;
          }
          /**
           * Handle touchend / mouseup events
           * @param e
           */
          function handleEnd(e) {
            pressed.current = false;
            unbindGlobalMouseEvents();
            if (!isGrantedTouch()) {
              return;
            }
            // remove touch
            grantedTouch = null;
            onRelease(e);
          }
          /**
           * Handle touchmove / mousemove capture events
           * @param e
           */
          function handleMoveCapture(e) {
            updateMoveState(e);
            if (isGrantedTouch()) {
              return;
            }
            if (onMoveShouldSetCapture(e)) {
              claimTouch(e);
            }
          }
          /**
           * Handle touchmove / mousemove events
           * @param e
           */
          function handleMove(e) {
            if (isGrantedTouch()) {
              onMove(e);
              return;
            }
            if (onMoveShouldSet(e)) {
              claimTouch(e);
            }
          }
          /**
           * When our gesture starts, should we become the responder?
           */
          function onStartShouldSet(e) {
            return callbackRefs.current.onStartShouldSet ? callbackRefs.current.onStartShouldSet(state.current, e) : false;
          }
          /**
           * Same as onStartShouldSet, except using capture.
           */
          function onStartShouldSetCapture(e) {
            return callbackRefs.current.onStartShouldSetCapture ? callbackRefs.current.onStartShouldSetCapture(state.current, e) : false;
          }
          /**
           * When our gesture moves, should we become the responder?
           */
          function onMoveShouldSet(e) {
            return callbackRefs.current.onMoveShouldSet ? callbackRefs.current.onMoveShouldSet(state.current, e) : false;
          }
          /**
           * Same as onMoveShouldSet, but using capture instead
           * of bubbling.
           */
          function onMoveShouldSetCapture(e) {
            return callbackRefs.current.onMoveShouldSetCapture ? callbackRefs.current.onMoveShouldSetCapture(state.current, e) : false;
          }
          /**
           * The view is responding to gestures. Typically corresponds
           * with mousedown or touchstart.
           * @param e
           */
          function onGrant(e) {
            if (callbackRefs.current.onGrant) {
              callbackRefs.current.onGrant(state.current, e);
            }
          }
          /**
           * Update our kinematics for start events
           * @param e
           */
          function updateStartState(e) {
            var _a = e.touches && e.touches[0] ? e.touches[0] : e,
              pageX = _a.pageX,
              pageY = _a.pageY;
            var s = state.current;
            state.current = __assign({}, initialState, {
              lastLocal: s.lastLocal || initialState.lastLocal,
              xy: [pageX, pageY],
              initial: [pageX, pageY],
              previous: [pageX, pageY],
              time: Date.now()
            });
          }
          /**
           * Update our kinematics when moving
           * @param e
           */
          function updateMoveState(e) {
            var _a = e.touches && e.touches[0] ? e.touches[0] : e,
              pageX = _a.pageX,
              pageY = _a.pageY;
            var s = state.current;
            var time = Date.now();
            var x_dist = pageX - s.xy[0];
            var y_dist = pageY - s.xy[1];
            var delta_x = pageX - s.initial[0];
            var delta_y = pageY - s.initial[1];
            var distance = Math.sqrt(delta_x * delta_x + delta_y * delta_y);
            var len = Math.sqrt(x_dist * x_dist + y_dist * y_dist);
            var scaler = 1 / (len || 1);
            var velocity = len / (time - s.time);
            var initialDirection = s.initialDirection[0] !== 0 || s.initialDirection[1] !== 0 ? s.initialDirection : [delta_x * scaler, delta_y * scaler];
            state.current = __assign({}, state.current, {
              time: time,
              xy: [pageX, pageY],
              initialDirection: initialDirection,
              delta: [delta_x, delta_y],
              local: [s.lastLocal[0] + pageX - s.initial[0], s.lastLocal[1] + pageY - s.initial[1]],
              velocity: time - s.time === 0 ? s.velocity : velocity,
              distance: distance,
              direction: [x_dist * scaler, y_dist * scaler],
              previous: s.xy
            });
          }
          /**
           * The user is moving their touch / mouse.
           * @param e
           */
          function onMove(e) {
            if (pressed.current && callbackRefs.current.onMove) {
              callbackRefs.current.onMove(state.current, e);
            }
          }
          /**
           * The responder has been released. Typically mouse-up or
           * touchend events.
           * @param e
           */
          function onRelease(e) {
            var s = state.current;
            state.current = __assign({}, state.current, {
              lastLocal: s.local
            });
            if (callbackRefs.current.onRelease) {
              callbackRefs.current.onRelease(state.current, e);
            }
            grantedTouch = null;
          }
          /**
           * Check with the current responder to see if it can
           * be terminated. This is currently only triggered when returns true
           * from onMoveShouldSet. I can't really envision much of a
           * use-case for doing this with a standard onStartShouldSet.
           *
           * By default, returns true.
           */
          function onTerminationRequest(e) {
            return callbackRefs.current.onTerminationRequest ? callbackRefs.current.onTerminationRequest(state.current, e) : true;
          }
          /**
           * The responder has been taken by another view
           */
          function onTerminate(e) {
            var s = state.current;
            state.current = __assign({}, state.current, {
              lastLocal: s.local
            });
            if (callbackRefs.current.onTerminate) {
              callbackRefs.current.onTerminate(state.current, e);
            }
          }
          /**
           * Use window mousemove events instead of binding to the
           * element itself to better emulate how touchmove works.
           */
          function handleMoveMouse(e) {
            if (isMouseEnabled()) {
              handleMove(e);
            }
          }
          function handleMoveMouseCapture(e) {
            if (isMouseEnabled()) {
              handleMoveCapture(e);
            }
          }
          function handleEndMouse(e) {
            if (isMouseEnabled()) {
              handleEnd(e);
            }
          }
          reactExports.useEffect(function () {
            return unbindGlobalMouseEvents;
          }, []);
          /**
           * Imperatively terminate the current responder
           */
          function terminateCurrentResponder() {
            if (grantedTouch) {
              grantedTouch.onTerminate();
              grantedTouch = null;
            }
          }
          /**
           * A getter for returning the current
           * responder, if it exists
           */
          function getCurrentResponder() {
            return grantedTouch;
          }
          /**
           * Required touch / mouse events
           */
          var touchEvents = {
            onTouchStart: handleStart,
            onTouchEnd: handleEnd,
            onTouchMove: handleMove,
            onTouchStartCapture: handleStartCapture,
            onTouchMoveCapture: handleMoveCapture
          };
          var mouseEvents = enableMouse ? {
            onMouseDown: function (e) {
              if (isMouseEnabled()) {
                handleStart(e);
              }
            },
            onMouseDownCapture: function (e) {
              if (isMouseEnabled()) {
                handleStartCapture(e);
              }
            }
          } : {};
          return {
            bind: __assign({}, touchEvents, mouseEvents),
            terminateCurrentResponder: terminateCurrentResponder,
            getCurrentResponder: getCurrentResponder
          };
        }

        //
        // Required
        let applyAnimatedValues;
        let createStringInterpolator; //
        // Optional
        //

        let now$5 = () => Date.now();
        let colorNames = {};
        let defaultElement;
        let manualFrameloop;
        let createAnimatedStyle;
        let createAnimatedTransform;
        let createAnimatedInterpolation;
        let createAnimatedRef = node => node.current;
        let requestAnimationFrame$1 = typeof window !== 'undefined' ? window.requestAnimationFrame : () => {};
        let cancelAnimationFrame = typeof window !== 'undefined' ? window.cancelAnimationFrame : () => {}; //
        // Configuration
        //

        const assign = globals => {
          var _Object$assign = Object.assign({
            colorNames,
            defaultElement,
            applyAnimatedValues,
            createStringInterpolator,
            createAnimatedInterpolation,
            createAnimatedTransform,
            createAnimatedStyle,
            createAnimatedRef,
            requestAnimationFrame: requestAnimationFrame$1,
            cancelAnimationFrame,
            manualFrameloop
          }, globals);
          colorNames = _Object$assign.colorNames;
          defaultElement = _Object$assign.defaultElement;
          applyAnimatedValues = _Object$assign.applyAnimatedValues;
          createStringInterpolator = _Object$assign.createStringInterpolator;
          createAnimatedInterpolation = _Object$assign.createAnimatedInterpolation;
          createAnimatedTransform = _Object$assign.createAnimatedTransform;
          createAnimatedStyle = _Object$assign.createAnimatedStyle;
          createAnimatedRef = _Object$assign.createAnimatedRef;
          requestAnimationFrame$1 = _Object$assign.requestAnimationFrame;
          cancelAnimationFrame = _Object$assign.cancelAnimationFrame;
          manualFrameloop = _Object$assign.manualFrameloop;
          return _Object$assign;
        };
        class Animated {
          constructor() {
            this.payload = void 0;
            this.children = [];
          }
          getAnimatedValue() {
            return this.getValue();
          }
          getPayload() {
            return this.payload || this;
          }
          attach() {}
          detach() {}
          getChildren() {
            return this.children;
          }
          addChild(child) {
            if (this.children.length === 0) this.attach();
            this.children.push(child);
          }
          removeChild(child) {
            const index = this.children.indexOf(child);
            this.children.splice(index, 1);
            if (this.children.length === 0) this.detach();
          }
        }
        class AnimatedArray extends Animated {
          constructor() {
            super(...arguments);
            this.payload = void 0;
          }
          attach() {
            this.payload.forEach(p => p instanceof Animated && p.addChild(this));
          }
          detach() {
            this.payload.forEach(p => p instanceof Animated && p.removeChild(this));
          }
        }
        class AnimatedObject extends Animated {
          constructor(payload) {
            super();
            this.payload = payload;
          }
          getValue(animated) {
            if (animated === void 0) {
              animated = false;
            }
            const payload = {};
            for (const key in this.payload) {
              const value = this.payload[key];
              if (animated && !(value instanceof Animated)) continue;
              payload[key] = value instanceof Animated ? value[animated ? 'getAnimatedValue' : 'getValue']() : value;
            }
            return payload;
          }
          getAnimatedValue() {
            return this.getValue(true);
          }
          attach() {
            Object.values(this.payload).forEach(s => s instanceof Animated && s.addChild(this));
          }
          detach() {
            Object.values(this.payload).forEach(s => s instanceof Animated && s.removeChild(this));
          }
        }
        class AnimatedStyle extends AnimatedObject {
          constructor(style) {
            if (style === void 0) {
              style = {};
            }
            super(style.transform && createAnimatedTransform ? _extends$h({}, style, {
              transform: createAnimatedTransform(style.transform)
            }) : style);
          }
        }
        const is$1 = {
          arr: Array.isArray,
          obj: a => Object.prototype.toString.call(a) === '[object Object]',
          fun: a => typeof a === 'function',
          str: a => typeof a === 'string',
          num: a => typeof a === 'number',
          und: a => a === void 0,
          boo: a => typeof a === 'boolean'
        };
        function useForceUpdate() {
          const _useState = reactExports.useState(false),
            f = _useState[1];
          const forceUpdate = reactExports.useCallback(() => f(v => !v), []);
          return forceUpdate;
        }
        function withDefault(value, defaultValue) {
          return value == null ? defaultValue : value;
        }
        function toArray$1(a) {
          return is$1.und(a) ? [] : Array.isArray(a) ? a : [a];
        }
        function callProp(obj) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          return is$1.fun(obj) ? obj(...args) : obj;
        }
        function getForwardProps(props) {
          props.to;
          props.from;
          props.config;
          props.onStart;
          props.onRest;
          props.onFrame;
          props.children;
          props.cancel;
          props.reset;
          props.reverse;
          props.force;
          props.immediate;
          props.delay;
          props.attach;
          props.destroyed;
          props.interpolateTo;
          props.ref;
          props.lazy;
          const forward = _objectWithoutPropertiesLoose(props, ["to", "from", "config", "onStart", "onRest", "onFrame", "children", "cancel", "reset", "reverse", "force", "immediate", "delay", "attach", "destroyed", "interpolateTo", "ref", "lazy"]);
          return forward;
        }
        function interpolateTo(props) {
          const forward = getForwardProps(props);
          props = Object.entries(props).reduce((props, _ref) => {
            let key = _ref[0],
              value = _ref[1];
            return key in forward || (props[key] = value), props;
          }, {});
          return _extends$h({
            to: forward
          }, props);
        }
        function handleRef(ref, forward) {
          if (forward) {
            // If it's a function, assume it's a ref callback
            if (is$1.fun(forward)) forward(ref);else if (is$1.obj(forward)) {
              forward.current = ref;
            }
          }
          return ref;
        }
        /** Use a value from the previous render */

        function usePrev(value) {
          const prevRef = reactExports.useRef(undefined);
          const prev = prevRef.current;
          prevRef.current = value;
          return prev;
        }
        function fillArray(length, mapIndex) {
          const arr = [];
          for (let i = 0; i < length; i++) arr.push(mapIndex(i));
          return arr;
        }
        function freeze(obj) {
          if (typeof process !== 'undefined' && "production" === 'development') {
            return Object.freeze(obj);
          }
          return obj;
        }
        class AnimatedValueArray extends AnimatedArray {
          constructor(values) {
            super();
            this.payload = values;
          }
          getValue() {
            return this.payload.map(v => v.getValue());
          }
          setValue(value, flush) {
            if (flush === void 0) {
              flush = true;
            }
            if (is$1.arr(value)) {
              if (value.length === this.payload.length) {
                value.forEach((v, i) => this.payload[i].setValue(v, flush));
              }
            } else {
              this.payload.forEach(p => p.setValue(value, flush));
            }
          }
          interpolate() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return createAnimatedInterpolation(this, ...args);
          }
        }
        const createInterpolator = (range, output, extrapolate) => {
          if (is$1.fun(range)) {
            return range;
          }
          if (is$1.arr(range)) {
            return createInterpolator({
              range,
              output: output,
              extrapolate
            });
          }
          if (is$1.str(range.output[0])) {
            return createStringInterpolator(range);
          }
          const config = range;
          const outputRange = config.output;
          const inputRange = config.range || [0, 1];
          const extrapolateLeft = config.extrapolateLeft || config.extrapolate || 'extend';
          const extrapolateRight = config.extrapolateRight || config.extrapolate || 'extend';
          const easing = config.easing || (t => t);
          return input => {
            const range = findRange(input, inputRange);
            return interpolate(input, inputRange[range], inputRange[range + 1], outputRange[range], outputRange[range + 1], easing, extrapolateLeft, extrapolateRight, config.map);
          };
        };
        function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {
          let result = map ? map(input) : input; // Extrapolate

          if (result < inputMin) {
            if (extrapolateLeft === 'identity') return result;else if (extrapolateLeft === 'clamp') result = inputMin;
          }
          if (result > inputMax) {
            if (extrapolateRight === 'identity') return result;else if (extrapolateRight === 'clamp') result = inputMax;
          }
          if (outputMin === outputMax) return outputMin;
          if (inputMin === inputMax) return input <= inputMin ? outputMin : outputMax; // Input Range

          if (inputMin === -Infinity) result = -result;else if (inputMax === Infinity) result = result - inputMin;else result = (result - inputMin) / (inputMax - inputMin); // Easing

          result = easing(result); // Output Range

          if (outputMin === -Infinity) result = -result;else if (outputMax === Infinity) result = result + outputMin;else result = result * (outputMax - outputMin) + outputMin;
          return result;
        }
        function findRange(input, inputRange) {
          for (var i = 1; i < inputRange.length - 1; ++i) if (inputRange[i] >= input) break;
          return i - 1;
        }

        /** Wrap each element type of `T` with the `Animated` type */

        class AnimatedInterpolation extends AnimatedArray {
          constructor(parents, args) {
            super();
            this.calc = void 0;
            this.calc = createInterpolator(...args);
            this.payload = Array.isArray(parents) ? parents : parents instanceof AnimatedValueArray ? parents.getPayload() : [parents];
          }
          getValue() {
            const args = this.payload.map(value => value.getValue());
            return this.calc(...args);
          }
          interpolate() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return createAnimatedInterpolation(this, ...args);
          }
        }
        let active$2 = false;
        const controllers = new Set();
        const update = () => {
          if (!active$2) return false;
          let time = now$5();
          for (let controller of controllers) {
            let isActive = false; // Number of updated animations

            let updateCount = 0;
            for (let configIdx = 0; configIdx < controller.configs.length; configIdx++) {
              let config = controller.configs[configIdx];
              let endOfAnimation, lastTime;
              for (let valIdx = 0; valIdx < config.animatedValues.length; valIdx++) {
                let animated = config.animatedValues[valIdx];
                if (animated.done) continue;
                updateCount++;
                let to = config.toValues[valIdx];
                let isAnimated = to instanceof Animated;
                if (isAnimated) to = to.getValue(); // Jump to end value for immediate animations

                if (config.immediate) {
                  animated.setValue(to);
                  animated.done = true;
                  continue;
                }
                let from = config.fromValues[valIdx]; // Break animation when string values are involved

                if (typeof from === 'string' || typeof to === 'string') {
                  animated.setValue(to);
                  animated.done = true;
                  continue;
                }
                let position = animated.lastPosition;
                let velocity = Array.isArray(config.initialVelocity) ? config.initialVelocity[valIdx] : config.initialVelocity;
                if (config.duration !== void 0) {
                  /** Duration easing */
                  position = from + config.easing((time - animated.startTime) / config.duration) * (to - from);
                  endOfAnimation = time >= animated.startTime + config.duration;
                } else if (config.decay) {
                  const decay = config.decay === true ? 0.998 : config.decay;
                  /** Decay easing */

                  position = from + velocity / (1 - decay) * (1 - Math.exp(-(1 - decay) * (time - animated.startTime)));
                  endOfAnimation = Math.abs(animated.lastPosition - position) < 0.1;
                  if (endOfAnimation) to = position;
                } else {
                  /** Spring easing */
                  lastTime = animated.lastTime !== void 0 ? animated.lastTime : time;
                  velocity = animated.lastVelocity !== void 0 ? animated.lastVelocity : config.initialVelocity; // If we lost a lot of frames just jump to the end.

                  if (time > lastTime + 64) lastTime = time; // http://gafferongames.com/game-physics/fix-your-timestep/

                  let numSteps = Math.floor(time - lastTime);
                  for (let i = 0; i < numSteps; ++i) {
                    let force = -config.tension * (position - to);
                    let damping = -config.friction * velocity;
                    let acceleration = (force + damping) / config.mass;
                    velocity = velocity + acceleration * 1 / 1000;
                    position = position + velocity * 1 / 1000;
                  } // Conditions for stopping the spring animation

                  let isOvershooting = config.clamp && config.tension !== 0 ? from < to ? position > to : position < to : false;
                  let isVelocity = Math.abs(velocity) <= config.precision;
                  let isDisplacement = config.tension !== 0 ? Math.abs(to - position) <= config.precision : true;
                  endOfAnimation = isOvershooting || isVelocity && isDisplacement;
                  animated.lastVelocity = velocity;
                  animated.lastTime = time;
                } // Trails aren't done until their parents conclude

                if (isAnimated && !config.toValues[valIdx].done) {
                  endOfAnimation = false;
                }
                if (endOfAnimation) {
                  // Ensure that we end up with a round value
                  if (animated.value !== to) position = to;
                  animated.done = true;
                } else {
                  isActive = true;
                }
                animated.setValue(position);
                animated.lastPosition = position;
              } // Keep track of updated values only when necessary

              if (controller.props.onFrame) {
                controller.values[config.key] = config.animated.getValue();
              }
            }
            controller.onFrame(isActive, updateCount);
          } // Loop over as long as there are controllers ...

          if (controllers.size) {
            if (manualFrameloop) manualFrameloop();else requestAnimationFrame$1(update);
          } else {
            active$2 = false;
          }
          return active$2;
        };
        const start = controller => {
          controllers.add(controller);
          if (!active$2) {
            active$2 = true;
            if (manualFrameloop) manualFrameloop();else requestAnimationFrame$1(update);
          }
        };
        const stop = controller => {
          controllers.delete(controller);
        };

        /**
         * Animated works by building a directed acyclic graph of dependencies
         * transparently when you render your Animated components.
         *
         *               new Animated.Value(0)
         *     .interpolate()        .interpolate()    new Animated.Value(1)
         *         opacity               translateY      scale
         *          style                         transform
         *         View#234                         style
         *                                         View#123
         *
         * A) Top Down phase
         * When an AnimatedValue is updated, we recursively go down through this
         * graph in order to find leaf nodes: the views that we flag as needing
         * an update.
         *
         * B) Bottom Up phase
         * When a view is flagged as needing an update, we recursively go back up
         * in order to build the new value that it needs. The reason why we need
         * this two-phases process is to deal with composite props such as
         * transform which can receive values from multiple parents.
         */

        function addAnimatedStyles(node, styles) {
          if ('update' in node) {
            styles.add(node);
          } else {
            node.getChildren().forEach(child => addAnimatedStyles(child, styles));
          }
        }
        class AnimatedValue extends Animated {
          constructor(_value) {
            var _this;
            super();
            _this = this;
            this.animatedStyles = new Set();
            this.value = void 0;
            this.startPosition = void 0;
            this.lastPosition = void 0;
            this.lastVelocity = void 0;
            this.startTime = void 0;
            this.lastTime = void 0;
            this.done = false;
            this.setValue = function (value, flush) {
              if (flush === void 0) {
                flush = true;
              }
              _this.value = value;
              if (flush) _this.flush();
            };
            this.value = _value;
            if (is$1.num(_value)) {
              this.startPosition = _value;
              this.lastPosition = _value;
            }
          }
          getValue() {
            return this.value;
          }
          interpolate() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return createAnimatedInterpolation(this, ...args);
          }
          reset(isActive) {
            if (is$1.num(this.value)) {
              this.startPosition = this.value;
              this.lastPosition = this.value;
              this.lastVelocity = isActive ? this.lastVelocity : undefined;
              this.lastTime = isActive ? this.lastTime : undefined;
              this.startTime = now$5();
            }
            this.done = false;
            this.animatedStyles.clear();
          }
          clearStyles() {
            this.animatedStyles.clear();
          }
          flush() {
            if (this.animatedStyles.size === 0) {
              addAnimatedStyles(this, this.animatedStyles);
            }
            this.animatedStyles.forEach(animatedStyle => animatedStyle.update());
          }
        }

        // Default easing
        const linear = t => t;
        const emptyObj = Object.freeze({});
        let nextId = 1;
        class Controller {
          constructor(props) {
            this.id = nextId++;
            this.idle = true;
            this.runCount = 0;
            this.destroyed = false;
            this.props = {};
            this.queue = [];
            this.timestamps = {};
            this.values = {};
            this.merged = {};
            this.animated = {};
            this.animations = {};
            this.configs = [];
            this.onEndQueue = [];
            this.cancelledAt = 0;
            if (props) this.update(props).start();
          }
          /**
           * Push props into the update queue. The props are used after `start` is
           * called and any delay is over. The props are intelligently diffed to ensure
           * that later calls to this method properly override any delayed props.
           * The `propsArg` argument is always copied before mutations are made.
           */

          update(propsArg) {
            if (!propsArg || this.destroyed) return this;
            const props = interpolateTo(propsArg); // For async animations, the `from` prop must be defined for
            // the Animated nodes to exist before animations have started.

            this._ensureAnimated(props.from, true);
            this._ensureAnimated(props.to);
            props.timestamp = now$5(); // The `delay` prop of every update must be a number >= 0

            if (is$1.fun(props.delay) && is$1.obj(props.to)) {
              const from = props.from || emptyObj;
              for (const key in props.to) {
                this.queue.push(_extends$h({}, props, {
                  to: {
                    [key]: props.to[key]
                  },
                  from: key in from ? {
                    [key]: from[key]
                  } : void 0,
                  delay: Math.max(0, Math.round(props.delay(key)))
                }));
              }
            } else {
              props.delay = is$1.num(props.delay) ? Math.max(0, Math.round(props.delay)) : 0; // Coerce falsy values to undefined for these props

              if (!props.to) props.to = void 0;
              if (!props.from) props.from = void 0;
              this.queue.push(props);
            }
            return this;
          }
          /**
           * Flush the update queue.
           * If the queue is empty, try starting the frameloop.
           */

          start(onEnd) {
            if (this.queue.length) this._flush(onEnd);else this._start(onEnd);
            return this;
          }
          /** Stop one animation or all animations */

          stop() {
            for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
              keys[_key] = arguments[_key];
            }
            let finished = false;
            if (is$1.boo(keys[0])) {
              var _keys = keys;
              finished = _keys[0];
              keys = _keys.slice(1);
            } // Stop animations by key

            if (keys.length) {
              for (const key of keys) {
                const index = this.configs.findIndex(config => key === config.key);
                this._stopAnimation(key);
                this.configs[index] = this.animations[key];
              }
            } // Stop all animations
            else if (this.runCount) {
              this.cancelledAt = now$5(); // Update the animation configs

              this.configs.forEach(config => this._stopAnimation(config.key));
              this.configs = Object.values(this.animations); // Exit the frameloop

              this._stop(finished);
            }
            return this;
          }
          /** Revert the controller to its initial state */

          reset() {
            // Stop all current animations
            this.stop(); // Revert the internal state

            this.destroyed = false;
            this.props = {};
            this.queue = [];
            this.timestamps = {};
            this.values = {};
            this.merged = {};
            this.animated = {};
            this.animations = {};
            this.configs = [];
            return this;
          }
          /** Prevent all current and future animation */

          destroy() {
            if (!this.destroyed) {
              this.stop();
              this.destroyed = true;
            }
          }
          /** @internal Called by the frameloop */

          onFrame(isActive, updateCount) {
            if (updateCount) {
              const onFrame = this.props.onFrame;
              if (onFrame) onFrame(_extends$h({}, this.values));
            }
            if (!isActive) this._stop(true);
          }
          /**
           * Set a prop for the next animations where the prop is undefined. The given
           * value is overridden by the next update where the prop is defined.
           *
           * Ongoing animations are not changed.
           */

          setProp(key, value) {
            this.props[key] = value;
            this.timestamps[key] = now$5();
            return this;
          } // Create an Animated node if none exists.

          _ensureAnimated(values, shouldUpdate) {
            if (shouldUpdate === void 0) {
              shouldUpdate = false;
            }
            if (!is$1.obj(values)) return;
            for (const key in values) {
              const value = values[key];
              let animated = this.animated[key];
              if (animated && shouldUpdate && this.animations[key].isNew) {
                // Ensure the initial value is up-to-date.
                if (animated.setValue) {
                  animated.setValue(value);
                } else {
                  // Derived nodes need to be swapped out.
                  animated = null;
                }
              }
              if (!animated) {
                animated = createAnimated(value);
                if (animated) {
                  if (this.animated[key]) {
                    // Swap out the old node with the new node.
                    moveChildren(this.animated[key], animated);
                  }
                  this.animated[key] = animated;
                  this._stopAnimation(key, true);
                } else {
                  console.warn('Given value not animatable:', value);
                }
              }
            }
          } // Listen for all animations to end.

          _onEnd(onEnd) {
            if (this.runCount) this.onEndQueue.push(onEnd);else onEnd(true);
          } // Add this controller to the frameloop.

          _start(onEnd) {
            if (onEnd) this._onEnd(onEnd);
            if (this.idle && this.runCount) {
              this.idle = false;
              start(this);
            }
          } // Remove this controller from the frameloop, and notify any listeners.

          _stop(finished) {
            this.idle = true;
            stop(this);
            const onEndQueue = this.onEndQueue;
            if (onEndQueue.length) {
              this.onEndQueue = [];
              onEndQueue.forEach(onEnd => onEnd(finished));
            }
          } // Execute the current queue of prop updates.

          _flush(onEnd) {
            const queue = this.queue.reduce(reduceDelays, []);
            this.queue.length = 0; // Track the number of active `_run` calls.

            let runsLeft = Object.keys(queue).length;
            this.runCount += runsLeft; // Never assume that the last update always finishes last, since that's
            // not true when 2+ async updates have indeterminate durations.

            const onRunEnd = finished => {
              this.runCount--;
              if (--runsLeft) return;
              if (onEnd) onEnd(finished);
              if (!this.runCount && finished) {
                const onRest = this.props.onRest;
                if (onRest) onRest(this.merged);
              }
            };
            queue.forEach((props, delay) => {
              if (delay) {
                setTimeout(() => {
                  // Cancelling methods touch the `cancelledAt` property
                  if (props.timestamp < this.cancelledAt) return;
                  this._run(props, onRunEnd);
                }, delay);
              } else {
                this._run(props, onRunEnd);
              }
            });
          } // Update the props and animations

          _run(props, onEnd) {
            if (is$1.arr(props.to) || is$1.fun(props.to)) {
              this._runAsync(props, onEnd);
            } else if (this._diff(props)) {
              this._animate(props)._start(onEnd);
            } else {
              this._onEnd(onEnd);
            }
          } // Start an async chain or an async script.

          _runAsync(_ref, onEnd) {
            let to = _ref.to,
              props = _objectWithoutPropertiesLoose(_ref, ["to"]);

            // Merge other props immediately.
            if (this._diff(props)) {
              this._animate(props);
            } // Async scripts can be declaratively cancelled.

            if (props.cancel === true) {
              this.props.asyncTo = void 0;
              return onEnd(false);
            } // Never run more than one script at a time

            const timestamp = props.timestamp;
            if (!this._diff({
              asyncTo: to,
              timestamp
            })) {
              return onEnd(false);
            }
            const isCancelled = () =>
            // Cancelling methods touch the `cancelledAt` property
            timestamp < this.cancelledAt ||
            // Async scripts are also cancelled when a new chain/script begins
            is$1.fun(to) && to !== this.props.asyncTo;
            let last;
            const next = props => {
              if (isCancelled()) throw this;
              return (last = new Promise(done => {
                this.update(props).start(done);
              })).then(() => {
                if (isCancelled()) throw this;
              });
            };
            let queue = Promise.resolve();
            if (is$1.arr(to)) {
              to.forEach(props => queue = queue.then(() => next(props)));
            } else if (is$1.fun(to)) {
              queue = queue.then(() => to(next, this.stop.bind(this)) // Always wait for the last update.
              .then(() => last));
            }
            queue.catch(err => err !== this && console.error(err)).then(() => onEnd(!isCancelled()));
          } // Merge every fresh prop. Returns true if one or more props changed.
          // These props are ignored: (delay, config, immediate, reverse)

          _diff(_ref2) {
            let timestamp = _ref2.timestamp;
            _ref2.delay;
            _ref2.config;
            _ref2.immediate;
            let reverse = _ref2.reverse,
              props = _objectWithoutPropertiesLoose(_ref2, ["timestamp", "delay", "config", "immediate", "reverse"]);
            let changed = false; // Ensure the newer timestamp is used.

            const diffTimestamp = keyPath => {
              const previous = this.timestamps[keyPath];
              if (is$1.und(previous) || timestamp >= previous) {
                this.timestamps[keyPath] = timestamp;
                return true;
              }
              return false;
            }; // Generalized diffing algorithm

            const diffProp = (keys, value, parent) => {
              if (is$1.und(value)) return;
              const lastKey = keys[keys.length - 1];
              if (is$1.obj(value)) {
                if (!is$1.obj(parent[lastKey])) parent[lastKey] = {};
                for (const key in value) {
                  diffProp(keys.concat(key), value[key], parent[lastKey]);
                }
              } else if (diffTimestamp(keys.join('.'))) {
                const oldValue = parent[lastKey];
                if (!isEqual(value, oldValue)) {
                  changed = true;
                  parent[lastKey] = value;
                }
              }
            };
            if (reverse) {
              const to = props.to;
              props.to = props.from;
              props.from = is$1.obj(to) ? to : void 0;
            }
            for (const key in props) {
              diffProp([key], props[key], this.props);
            } // These props only affect one update

            if ('reset' in props) this.props.reset = false;
            if ('cancel' in props) this.props.cancel = void 0;
            return changed;
          } // Return true if the given prop was changed by this update

          _isModified(props, prop) {
            return this.timestamps[prop] === props.timestamp;
          } // Update the animation configs. The given props override any default props.

          _animate(props) {
            const _this$props = this.props,
              _this$props$from = _this$props.from,
              from = _this$props$from === void 0 ? emptyObj : _this$props$from,
              _this$props$to = _this$props.to,
              to = _this$props$to === void 0 ? emptyObj : _this$props$to,
              attach = _this$props.attach,
              onStart = _this$props.onStart;
            let isPrevented = _ => false;
            if (props.cancel && this._isModified(props, 'cancel')) {
              // Stop all animations when `cancel` is true
              if (props.cancel === true) {
                this.stop(); // Prevent pending updates from *before* this update only!
                // (This must come after the `stop` call above)

                this.cancelledAt = props.timestamp;
                return this;
              } // Prevent matching properties from animating when
              // `cancel` is a string or array of strings

              const keys = toArray$1(props.cancel);
              if (is$1.arr(keys) && keys.length) {
                isPrevented = key => keys.indexOf(key) >= 0;
                this.stop(...keys);
              }
            } // Merge `from` values with `to` values

            this.merged = freeze(_extends$h({}, from, to)); // True if any animation was updated

            let changed = false; // The animations that are starting or restarting

            const started = []; // Attachment handling, trailed springs can "attach" themselves to a previous spring

            const target = attach && attach(this); // Reduces input { key: value } pairs into animation objects

            for (const key in this.merged) {
              if (isPrevented(key)) continue;
              const state = this.animations[key];
              if (!state) {
                console.warn(`Failed to animate key: "${key}"\n` + `Did you forget to define "from.${key}" for an async animation?`);
                continue;
              } // Reuse the Animated nodes whenever possible

              let animated = state.animated,
                animatedValues = state.animatedValues;
              const value = this.merged[key];
              const goalValue = computeGoalValue(value);
              const currValue = animated.getValue(); // Stop animations with a goal value equal to its current value.

              if (!props.reset && isEqual(goalValue, currValue)) {
                // The animation might be stopped already.
                if (!state.idle) {
                  changed = true;
                  this._stopAnimation(key);
                }
                continue;
              } // Replace an animation when its goal value is changed (or it's been reset)

              if (props.reset || !isEqual(goalValue, state.isNew ? currValue : state.goalValue)) {
                let _ref3 = is$1.und(props.immediate) ? this.props : props,
                  immediate = _ref3.immediate;
                immediate = !!callProp(immediate, key);
                const isActive = animatedValues.some(v => !v.done);
                const fromValue = !is$1.und(from[key]) ? computeGoalValue(from[key]) : goalValue; // Animatable strings use interpolation

                const isInterpolated = isAnimatableString(value);
                if (isInterpolated) {
                  const output = [props.reset ? fromValue : animated.getValue(), goalValue];
                  let input = animatedValues[0];
                  if (input) {
                    input.setValue(0, false);
                    input.reset(isActive);
                  } else {
                    input = new AnimatedValue(0);
                  }
                  try {
                    const prev = animated;
                    animated = input.interpolate({
                      output
                    });
                    moveChildren(prev, animated);
                  } catch (err) {
                    console.warn('Failed to interpolate string from "%s" to "%s"', output[0], output[1]);
                    console.error(err);
                    continue;
                  }
                  if (immediate) {
                    input.setValue(1, false);
                  }
                } else {
                  // Convert values into Animated nodes (reusing nodes whenever possible)
                  if (is$1.arr(value)) {
                    if (animated instanceof AnimatedValueArray) {
                      if (props.reset) animated.setValue(fromValue, false);
                      animatedValues.forEach(v => v.reset(isActive));
                    } else {
                      const prev = animated;
                      animated = createAnimated(fromValue);
                      moveChildren(prev, animated);
                    }
                  } else {
                    if (animated instanceof AnimatedValue) {
                      if (props.reset) animated.setValue(fromValue, false);
                      animated.reset(isActive);
                    } else {
                      const prev = animated;
                      animated = new AnimatedValue(fromValue);
                      moveChildren(prev, animated);
                    }
                  }
                  if (immediate) {
                    animated.setValue(goalValue, false);
                  }
                } // Only change the "config" of updated animations.

                const config = callProp(props.config, key) || callProp(this.props.config, key) || emptyObj;
                if (!immediate) {
                  started.push(key);
                }
                changed = true;
                animatedValues = toArray$1(animated.getPayload());
                this.animations[key] = {
                  key,
                  idle: false,
                  goalValue,
                  toValues: toArray$1(target instanceof Controller ? target.animations[key].animated.getPayload() : isInterpolated && 1 || goalValue),
                  fromValues: animatedValues.map(v => v.getValue()),
                  animated,
                  animatedValues,
                  immediate,
                  duration: config.duration,
                  easing: withDefault(config.easing, linear),
                  decay: config.decay,
                  mass: withDefault(config.mass, 1),
                  tension: withDefault(config.tension, 170),
                  friction: withDefault(config.friction, 26),
                  initialVelocity: withDefault(config.velocity, 0),
                  clamp: withDefault(config.clamp, false),
                  precision: withDefault(config.precision, 0.005),
                  config
                };
              }
            }
            if (changed) {
              if (onStart && started.length) {
                started.forEach(key => onStart(this.animations[key]));
              } // Make animations available to the frameloop

              const keys = Object.keys(this.animations);
              this.configs.length = keys.length;
              keys.forEach((key, i) => {
                const config = this.animations[key];
                this.configs[i] = config;
                this.values[key] = config.animated.getValue();
                this.animated[key] = config.animated;
              });
            }
            return this;
          }
          /**
           * Stop an animation by its key.
           *
           * This mutates the `timestamps.to[key]`, `props.to[key]`, and `animations[key]` properties.
           * Notably, it does *not* mutate the `configs[key]` or `animated[key]` properties.
           */

          _stopAnimation(key, isNew) {
            const animated = this.animated[key];
            if (!animated) {
              return console.warn(`Cannot stop an animation for a key that isn't animated: "${key}"`);
            } // Prevent any pending updates to this key

            this.timestamps['to.' + key] = now$5(); // Idle animations are skipped unless their Animated node changed

            const state = this.animations[key] || emptyObj;
            if (state.idle && animated === state.animated) return; // Use the previous `isNew` value if nothing was passed

            if (is$1.und(isNew)) {
              isNew = !!state.isNew;
            } // Tell the frameloop to skip animating these values

            const animatedValues = toArray$1(animated.getPayload());
            animatedValues.forEach(v => v.done = true); // The current value becomes the goal value,
            // which ensures the integrity of the diffing algorithm.

            const goalValue = animated.getValue();
            if (this.props.to) {
              this.props.to[key] = goalValue;
            } // Remove unused data from this key's animation config

            this.animations[key] = {
              key,
              idle: true,
              isNew,
              goalValue,
              animated,
              animatedValues
            };
          }
        }
        /** Wrap any value with an `Animated` node */

        function createAnimated(value) {
          return is$1.arr(value) ? new AnimatedValueArray(value.map(value => {
            const animated = createAnimated(value);
            const payload = animated.getPayload();
            return animated instanceof AnimatedInterpolation ? payload[0] : payload;
          })) : isAnimatableString(value) ?
          // Convert "red" into "rgba(255, 0, 0, 1)" etc
          new AnimatedValue(0).interpolate({
            output: [value, value]
          }) :
          // The `AnimatedValue` class supports any type, but only numbers are
          // interpolated by the frameloop.
          new AnimatedValue(value);
        }
        /**
         * Replace an `Animated` node in the graph.
         * This is most useful for async updates, which don't cause a re-render.
         */

        function moveChildren(prev, next) {
          const children = prev.getChildren().slice();
          children.forEach(child => {
            prev.removeChild(child);
            next.addChild(child); // Replace `prev` with `next` in child payloads

            const payload = child.getPayload();
            if (is$1.arr(payload)) {
              const i = payload.indexOf(prev);
              if (i >= 0) {
                const copy = [...payload];
                copy[i] = next;
                child['payload'] = copy;
              }
            } else if (is$1.obj(payload)) {
              const entry = Object.entries(payload).find(entry => entry[1] === prev);
              if (entry) {
                child['payload'] = _extends$h({}, payload, {
                  [entry[0]]: next
                });
              }
            }
          });
        } // Merge updates with the same delay.
        // NOTE: Mutation of `props` may occur!

        function reduceDelays(merged, props) {
          const prev = merged[props.delay];
          if (prev) {
            props.to = merge$5(prev.to, props.to);
            props.from = merge$5(prev.from, props.from);
            Object.assign(prev, props);
          } else {
            merged[props.delay] = props;
          }
          return merged;
        }
        function merge$5(dest, src) {
          return is$1.obj(dest) && is$1.obj(src) ? _extends$h({}, dest, src) : src || dest;
        } // Not all strings can be animated (eg: {display: "none"})

        function isAnimatableString(value) {
          if (!is$1.str(value)) return false;
          return value.startsWith('#') || /\d/.test(value) || !!colorNames[value];
        } // Compute the goal value, converting "red" to "rgba(255, 0, 0, 1)" in the process

        function computeGoalValue(value) {
          return is$1.arr(value) ? value.map(computeGoalValue) : isAnimatableString(value) ? createStringInterpolator({
            range: [0, 1],
            output: [value, value]
          })(1) : value;
        } // Compare animatable values

        function isEqual(a, b) {
          if (is$1.arr(a)) {
            if (!is$1.arr(b) || a.length !== b.length) return false;
            for (let i = 0; i < a.length; i++) {
              if (a[i] !== b[i]) return false;
            }
            return true;
          }
          return a === b;
        }

        /** API
         * const props = useSprings(number, [{ ... }, { ... }, ...])
         * const [props, set] = useSprings(number, (i, controller) => ({ ... }))
         */

        const useSprings = (length, propsArg, deps) => {
          const hasNewSprings = length !== usePrev(length);
          const isFn = is$1.fun(propsArg);
          const state = reactExports.useRef({
            springs: [],
            ref: null
          }).current; // The `propsArg` coerced into an array

          const props = isFn ? [] : propsArg; // Recreate the controllers whenever `length` changes

          const springs = reactExports.useMemo(() => fillArray(length, i => {
            const s = new Controller();
            const p = props[i] || (props[i] = callProp(propsArg, i, s));
            return s.update(p);
          }), [length]);
          const _useMemo = reactExports.useMemo(() => ({
              /** Apply any pending updates */
              start: () => Promise.all(state.springs.map(s => new Promise(done => s.start(done)))),
              /** Update the spring controllers */
              update: props => {
                const isFn = is$1.fun(props);
                const isArr = is$1.arr(props);
                state.springs.forEach((spring, i) => {
                  spring.update(isFn ? callProp(props, i, spring) : isArr ? props[i] : props);
                  if (!state.ref) spring.start();
                });
              },
              /** Stop one key or all keys from animating */
              stop: function stop() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                return state.springs.forEach(s => s.stop(...args));
              }
            }), []),
            start = _useMemo.start,
            update = _useMemo.update,
            stop = _useMemo.stop;
          const ref = props[0] ? props[0].ref : isFn ? state.ref : null;
          reactExports.useImperativeHandle(ref, () => ({
            start,
            stop,
            get controllers() {
              return state.springs;
            }
          })); // Once mounted, update the local state and start any animations.

          reactExports.useEffect(() => {
            if (!isFn || hasNewSprings) {
              props.forEach((p, i) => {
                // Set default props for async updates
                springs[i].setProp('config', p.config);
                springs[i].setProp('immediate', p.immediate);
              });
            }
            if (hasNewSprings) {
              state.springs.forEach(s => s.destroy());
              state.springs = springs;
              state.ref = ref;
              if (!ref) {
                springs.forEach(s => s.start());
              }
            } else if (!isFn) {
              update(props);
            }
          }, deps); // Destroy the controllers on unmount

          reactExports.useEffect(() => {
            return () => state.springs.forEach(s => s.destroy());
          }, []);
          const values = springs.map(s => _extends$h({}, s.animated));
          return isFn ? [values, update, stop] : values;
        };

        /** API
         * const props = useSpring({ ... })
         * const [props, set] = useSpring(() => ({ ... }))
         */

        const useSpring = (props, deps) => {
          const isFn = is$1.fun(props);
          const _useSprings = useSprings(1, isFn ? props : [props], deps),
            result = _useSprings[0],
            set = _useSprings[1],
            stop = _useSprings[2];
          return isFn ? [result[0], set, stop] : result;
        };
        assign({
          createAnimatedStyle: style => new AnimatedStyle(style),
          createAnimatedInterpolation: function createAnimatedInterpolation$$1(parents) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return new AnimatedInterpolation(parents, args);
          }
        });

        /**
         * Wraps the `style` property with `AnimatedStyle`.
         */

        class AnimatedProps extends AnimatedObject {
          constructor(props, callback) {
            super(props.style && createAnimatedStyle ? _extends$h({}, props, {
              style: createAnimatedStyle(props.style)
            }) : props);
            this.update = void 0;
            this.update = callback;
            this.attach();
          }
        }
        const createAnimatedComponent = Component => {
          const AnimatedComponent = reactExports.forwardRef((props, _ref) => {
            const forceUpdate = useForceUpdate();
            const mounted = reactExports.useRef(true);
            const propsAnimated = reactExports.useRef(null);
            const node = reactExports.useRef(null);
            const attachProps = reactExports.useCallback(props => {
              const oldPropsAnimated = propsAnimated.current;
              const callback = () => {
                if (node.current) {
                  const didUpdate = applyAnimatedValues(node.current, propsAnimated.current.getAnimatedValue());
                  if (didUpdate === false) forceUpdate();
                }
              };
              propsAnimated.current = new AnimatedProps(props, callback);
              oldPropsAnimated && oldPropsAnimated.detach();
            }, []);
            reactExports.useEffect(() => () => {
              mounted.current = false;
              propsAnimated.current && propsAnimated.current.detach();
            }, []);
            reactExports.useImperativeHandle(_ref, () => createAnimatedRef(node, mounted, forceUpdate));
            attachProps(props);
            const _getValue = propsAnimated.current.getValue();
            _getValue.scrollTop;
            _getValue.scrollLeft;
            const animatedProps = _objectWithoutPropertiesLoose(_getValue, ["scrollTop", "scrollLeft"]);
            return React.createElement(Component, _extends$h({}, animatedProps, {
              ref: childRef => node.current = handleRef(childRef, _ref)
            }));
          });
          return AnimatedComponent;
        };
        // withExtend(animated, options = {})
        //

        /** Add an `extend` method to your `animated` factory function */
        function withExtend(animated, options) {
          if (options === void 0) {
            options = {};
          }
          const self = animated;
          self.extend = function () {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            args.forEach(arg => extend(arg));
            return self;
          };
          return self;
          function extend(arg, overrideKey) {
            // Arrays avoid passing their index to `extend`
            if (is$1.arr(arg)) {
              return arg.forEach(arg => extend(arg));
            } // Object keys are always used over value inspection

            if (is$1.obj(arg)) {
              for (const key in arg) extend(arg[key], key);
              return;
            } // Use the `overrideKey` or inspect the value for a key

            let key = is$1.str(overrideKey) ? overrideKey : is$1.str(arg) ? arg : arg && is$1.str(arg.displayName) ? arg.displayName : is$1.fun(arg) ? arg.name : ''; // This lowercases the first letter of the key

            if (options.lowercase) {
              key = key[0].toLowerCase() + key.slice(1);
            } // NOTE(typescript): Properties are not yet inferred from the arguments of
            // the `extend` method and then attached to the `animated` function via
            // the return type.

            self[key] = animated(arg);
          }
        }
        const elements = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr',
        // SVG
        'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan']; // Extend `animated` with every available DOM element

        const animated$1 = withExtend(createAnimatedComponent).extend(elements);
        /** @deprecated Use `animated.extend` instead */

        animated$1.extend;
        let isUnitlessNumber = {
          animationIterationCount: true,
          borderImageOutset: true,
          borderImageSlice: true,
          borderImageWidth: true,
          boxFlex: true,
          boxFlexGroup: true,
          boxOrdinalGroup: true,
          columnCount: true,
          columns: true,
          flex: true,
          flexGrow: true,
          flexPositive: true,
          flexShrink: true,
          flexNegative: true,
          flexOrder: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowSpan: true,
          gridRowStart: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnSpan: true,
          gridColumnStart: true,
          fontWeight: true,
          lineClamp: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          tabSize: true,
          widows: true,
          zIndex: true,
          zoom: true,
          // SVG-related properties
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeDasharray: true,
          strokeDashoffset: true,
          strokeMiterlimit: true,
          strokeOpacity: true,
          strokeWidth: true
        };
        const prefixKey = (prefix, key) => prefix + key.charAt(0).toUpperCase() + key.substring(1);
        const prefixes = ['Webkit', 'Ms', 'Moz', 'O'];
        isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
          prefixes.forEach(prefix => acc[prefixKey(prefix, prop)] = acc[prop]);
          return acc;
        }, isUnitlessNumber);
        function dangerousStyleValue(name, value, isCustomProperty) {
          if (value == null || typeof value === 'boolean' || value === '') return '';
          if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers

          return ('' + value).trim();
        }
        const attributeCache = {};
        function applyAnimatedValues$1(instance, props) {
          if (!instance.nodeType || !instance.setAttribute) {
            return false;
          }
          const _ref = props,
            style = _ref.style,
            children = _ref.children,
            scrollTop = _ref.scrollTop,
            scrollLeft = _ref.scrollLeft,
            attributes = _objectWithoutPropertiesLoose(_ref, ["style", "children", "scrollTop", "scrollLeft"]);
          if (scrollTop !== void 0) instance.scrollTop = scrollTop;
          if (scrollLeft !== void 0) instance.scrollLeft = scrollLeft; // Set textContent, if children is an animatable value

          if (children !== void 0) instance.textContent = children; // Apply CSS styles

          for (let styleName in style) {
            if (!style.hasOwnProperty(styleName)) continue;
            var isCustomProperty = styleName.indexOf('--') === 0;
            var styleValue = dangerousStyleValue(styleName, style[styleName], isCustomProperty);
            if (styleName === 'float') styleName = 'cssFloat';
            if (isCustomProperty) instance.style.setProperty(styleName, styleValue);else instance.style[styleName] = styleValue;
          }
          const isFilterElement = instance.nodeName === 'filter' || instance.parentNode && instance.parentNode.nodeName === 'filter'; // Apply DOM attributes

          for (let name in attributes) {
            // Attributes are written in dash case
            const attributeName = isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(/([A-Z])/g, n => '-' + n.toLowerCase()));
            instance.setAttribute(attributeName, attributes[name]);
          }
        }

        // const INTEGER = '[-+]?\\d+';
        const NUMBER = '[-+]?\\d*\\.?\\d+';
        const PERCENTAGE = NUMBER + '%';
        function call() {
          for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
            parts[_key] = arguments[_key];
          }
          return '\\(\\s*(' + parts.join(')\\s*,\\s*(') + ')\\s*\\)';
        }
        const rgb = new RegExp('rgb' + call(NUMBER, NUMBER, NUMBER));
        const rgba = new RegExp('rgba' + call(NUMBER, NUMBER, NUMBER, NUMBER));
        const hsl = new RegExp('hsl' + call(NUMBER, PERCENTAGE, PERCENTAGE));
        const hsla = new RegExp('hsla' + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));
        const hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
        const hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
        const hex6 = /^#([0-9a-fA-F]{6})$/;
        const hex8 = /^#([0-9a-fA-F]{8})$/;

        // http://www.w3.org/TR/css3-color/#svg-color
        const colors = {
          transparent: 0x00000000,
          aliceblue: 0xf0f8ffff,
          antiquewhite: 0xfaebd7ff,
          aqua: 0x00ffffff,
          aquamarine: 0x7fffd4ff,
          azure: 0xf0ffffff,
          beige: 0xf5f5dcff,
          bisque: 0xffe4c4ff,
          black: 0x000000ff,
          blanchedalmond: 0xffebcdff,
          blue: 0x0000ffff,
          blueviolet: 0x8a2be2ff,
          brown: 0xa52a2aff,
          burlywood: 0xdeb887ff,
          burntsienna: 0xea7e5dff,
          cadetblue: 0x5f9ea0ff,
          chartreuse: 0x7fff00ff,
          chocolate: 0xd2691eff,
          coral: 0xff7f50ff,
          cornflowerblue: 0x6495edff,
          cornsilk: 0xfff8dcff,
          crimson: 0xdc143cff,
          cyan: 0x00ffffff,
          darkblue: 0x00008bff,
          darkcyan: 0x008b8bff,
          darkgoldenrod: 0xb8860bff,
          darkgray: 0xa9a9a9ff,
          darkgreen: 0x006400ff,
          darkgrey: 0xa9a9a9ff,
          darkkhaki: 0xbdb76bff,
          darkmagenta: 0x8b008bff,
          darkolivegreen: 0x556b2fff,
          darkorange: 0xff8c00ff,
          darkorchid: 0x9932ccff,
          darkred: 0x8b0000ff,
          darksalmon: 0xe9967aff,
          darkseagreen: 0x8fbc8fff,
          darkslateblue: 0x483d8bff,
          darkslategray: 0x2f4f4fff,
          darkslategrey: 0x2f4f4fff,
          darkturquoise: 0x00ced1ff,
          darkviolet: 0x9400d3ff,
          deeppink: 0xff1493ff,
          deepskyblue: 0x00bfffff,
          dimgray: 0x696969ff,
          dimgrey: 0x696969ff,
          dodgerblue: 0x1e90ffff,
          firebrick: 0xb22222ff,
          floralwhite: 0xfffaf0ff,
          forestgreen: 0x228b22ff,
          fuchsia: 0xff00ffff,
          gainsboro: 0xdcdcdcff,
          ghostwhite: 0xf8f8ffff,
          gold: 0xffd700ff,
          goldenrod: 0xdaa520ff,
          gray: 0x808080ff,
          green: 0x008000ff,
          greenyellow: 0xadff2fff,
          grey: 0x808080ff,
          honeydew: 0xf0fff0ff,
          hotpink: 0xff69b4ff,
          indianred: 0xcd5c5cff,
          indigo: 0x4b0082ff,
          ivory: 0xfffff0ff,
          khaki: 0xf0e68cff,
          lavender: 0xe6e6faff,
          lavenderblush: 0xfff0f5ff,
          lawngreen: 0x7cfc00ff,
          lemonchiffon: 0xfffacdff,
          lightblue: 0xadd8e6ff,
          lightcoral: 0xf08080ff,
          lightcyan: 0xe0ffffff,
          lightgoldenrodyellow: 0xfafad2ff,
          lightgray: 0xd3d3d3ff,
          lightgreen: 0x90ee90ff,
          lightgrey: 0xd3d3d3ff,
          lightpink: 0xffb6c1ff,
          lightsalmon: 0xffa07aff,
          lightseagreen: 0x20b2aaff,
          lightskyblue: 0x87cefaff,
          lightslategray: 0x778899ff,
          lightslategrey: 0x778899ff,
          lightsteelblue: 0xb0c4deff,
          lightyellow: 0xffffe0ff,
          lime: 0x00ff00ff,
          limegreen: 0x32cd32ff,
          linen: 0xfaf0e6ff,
          magenta: 0xff00ffff,
          maroon: 0x800000ff,
          mediumaquamarine: 0x66cdaaff,
          mediumblue: 0x0000cdff,
          mediumorchid: 0xba55d3ff,
          mediumpurple: 0x9370dbff,
          mediumseagreen: 0x3cb371ff,
          mediumslateblue: 0x7b68eeff,
          mediumspringgreen: 0x00fa9aff,
          mediumturquoise: 0x48d1ccff,
          mediumvioletred: 0xc71585ff,
          midnightblue: 0x191970ff,
          mintcream: 0xf5fffaff,
          mistyrose: 0xffe4e1ff,
          moccasin: 0xffe4b5ff,
          navajowhite: 0xffdeadff,
          navy: 0x000080ff,
          oldlace: 0xfdf5e6ff,
          olive: 0x808000ff,
          olivedrab: 0x6b8e23ff,
          orange: 0xffa500ff,
          orangered: 0xff4500ff,
          orchid: 0xda70d6ff,
          palegoldenrod: 0xeee8aaff,
          palegreen: 0x98fb98ff,
          paleturquoise: 0xafeeeeff,
          palevioletred: 0xdb7093ff,
          papayawhip: 0xffefd5ff,
          peachpuff: 0xffdab9ff,
          peru: 0xcd853fff,
          pink: 0xffc0cbff,
          plum: 0xdda0ddff,
          powderblue: 0xb0e0e6ff,
          purple: 0x800080ff,
          rebeccapurple: 0x663399ff,
          red: 0xff0000ff,
          rosybrown: 0xbc8f8fff,
          royalblue: 0x4169e1ff,
          saddlebrown: 0x8b4513ff,
          salmon: 0xfa8072ff,
          sandybrown: 0xf4a460ff,
          seagreen: 0x2e8b57ff,
          seashell: 0xfff5eeff,
          sienna: 0xa0522dff,
          silver: 0xc0c0c0ff,
          skyblue: 0x87ceebff,
          slateblue: 0x6a5acdff,
          slategray: 0x708090ff,
          slategrey: 0x708090ff,
          snow: 0xfffafaff,
          springgreen: 0x00ff7fff,
          steelblue: 0x4682b4ff,
          tan: 0xd2b48cff,
          teal: 0x008080ff,
          thistle: 0xd8bfd8ff,
          tomato: 0xff6347ff,
          turquoise: 0x40e0d0ff,
          violet: 0xee82eeff,
          wheat: 0xf5deb3ff,
          white: 0xffffffff,
          whitesmoke: 0xf5f5f5ff,
          yellow: 0xffff00ff,
          yellowgreen: 0x9acd32ff
        };

        /*
        https://github.com/react-community/normalize-css-color
         BSD 3-Clause License
         Copyright (c) 2016, React Community
        All rights reserved.
         Redistribution and use in source and binary forms, with or without
        modification, are permitted provided that the following conditions are met:
         * Redistributions of source code must retain the above copyright notice, this
          list of conditions and the following disclaimer.
         * Redistributions in binary form must reproduce the above copyright notice,
          this list of conditions and the following disclaimer in the documentation
          and/or other materials provided with the distribution.
         * Neither the name of the copyright holder nor the names of its
          contributors may be used to endorse or promote products derived from
          this software without specific prior written permission.
         THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
        AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
        FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
        DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
        SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
        CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
        OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
        OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        */
        function normalizeColor(color) {
          let match;
          if (typeof color === 'number') {
            return color >>> 0 === color && color >= 0 && color <= 0xffffffff ? color : null;
          } // Ordered based on occurrences on Facebook codebase

          if (match = hex6.exec(color)) return parseInt(match[1] + 'ff', 16) >>> 0;
          if (colors.hasOwnProperty(color)) return colors[color];
          if (match = rgb.exec(color)) {
            return (parse255(match[1]) << 24 |
            // r
            parse255(match[2]) << 16 |
            // g
            parse255(match[3]) << 8 |
            // b
            0x000000ff) >>>
            // a
            0;
          }
          if (match = rgba.exec(color)) {
            return (parse255(match[1]) << 24 |
            // r
            parse255(match[2]) << 16 |
            // g
            parse255(match[3]) << 8 |
            // b
            parse1(match[4])) >>>
            // a
            0;
          }
          if (match = hex3.exec(color)) {
            return parseInt(match[1] + match[1] +
            // r
            match[2] + match[2] +
            // g
            match[3] + match[3] +
            // b
            'ff',
            // a
            16) >>> 0;
          } // https://drafts.csswg.org/css-color-4/#hex-notation

          if (match = hex8.exec(color)) return parseInt(match[1], 16) >>> 0;
          if (match = hex4.exec(color)) {
            return parseInt(match[1] + match[1] +
            // r
            match[2] + match[2] +
            // g
            match[3] + match[3] +
            // b
            match[4] + match[4],
            // a
            16) >>> 0;
          }
          if (match = hsl.exec(color)) {
            return (hslToRgb$1(parse360(match[1]),
            // h
            parsePercentage(match[2]),
            // s
            parsePercentage(match[3]) // l
            ) | 0x000000ff) >>>
            // a
            0;
          }
          if (match = hsla.exec(color)) {
            return (hslToRgb$1(parse360(match[1]),
            // h
            parsePercentage(match[2]),
            // s
            parsePercentage(match[3]) // l
            ) | parse1(match[4])) >>>
            // a
            0;
          }
          return null;
        }
        function hue2rgb(p, q, t) {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        }
        function hslToRgb$1(h, s, l) {
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          const r = hue2rgb(p, q, h + 1 / 3);
          const g = hue2rgb(p, q, h);
          const b = hue2rgb(p, q, h - 1 / 3);
          return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
        }
        function parse255(str) {
          const int = parseInt(str, 10);
          if (int < 0) return 0;
          if (int > 255) return 255;
          return int;
        }
        function parse360(str) {
          const int = parseFloat(str);
          return (int % 360 + 360) % 360 / 360;
        }
        function parse1(str) {
          const num = parseFloat(str);
          if (num < 0) return 0;
          if (num > 1) return 255;
          return Math.round(num * 255);
        }
        function parsePercentage(str) {
          // parseFloat conveniently ignores the final %
          const int = parseFloat(str);
          if (int < 0) return 0;
          if (int > 100) return 1;
          return int / 100;
        }
        function colorToRgba(input) {
          let int32Color = normalizeColor(input);
          if (int32Color === null) return input;
          int32Color = int32Color || 0;
          let r = (int32Color & 0xff000000) >>> 24;
          let g = (int32Color & 0x00ff0000) >>> 16;
          let b = (int32Color & 0x0000ff00) >>> 8;
          let a = (int32Color & 0x000000ff) / 255;
          return `rgba(${r}, ${g}, ${b}, ${a})`;
        } // Problem: https://github.com/animatedjs/animated/pull/102
        // Solution: https://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly/658662

        const stringShapeRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g; // Covers rgb, rgba, hsl, hsla
        // Taken from https://gist.github.com/olmokramer/82ccce673f86db7cda5e

        const colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi; // Covers color names (transparent, blue, etc.)

        const colorNamesRegex = new RegExp(`(${Object.keys(colors).join('|')})`, 'g');
        /**
         * Supports string shapes by extracting numbers so new values can be computed,
         * and recombines those values into new strings of the same shape.  Supports
         * things like:
         *
         *   rgba(123, 42, 99, 0.36)           // colors
         *   -45deg                            // values with units
         *   0 2px 2px 0px rgba(0, 0, 0, 0.12) // box shadows
         */

        const createStringInterpolator$1 = config => {
          // Replace colors with rgba
          const outputRange = config.output.map(rangeValue => rangeValue.replace(colorRegex, colorToRgba)).map(rangeValue => rangeValue.replace(colorNamesRegex, colorToRgba));
          const outputRanges = outputRange[0].match(stringShapeRegex).map(() => []);
          outputRange.forEach(value => {
            value.match(stringShapeRegex).forEach((number, i) => outputRanges[i].push(+number));
          });
          const interpolations = outputRange[0].match(stringShapeRegex).map((_value, i) => createInterpolator(_extends$h({}, config, {
            output: outputRanges[i]
          })));
          return input => {
            let i = 0;
            return outputRange[0] // 'rgba(0, 100, 200, 0)'
            // ->
            // 'rgba(${interpolations[0](input)}, ${interpolations[1](input)}, ...'
            .replace(stringShapeRegex, () => interpolations[i++](input)) // rgba requires that the r,g,b are integers.... so we want to round them, but we *dont* want to
            // round the opacity (4th column).
            .replace(/rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi, (_, p1, p2, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`);
          };
        };
        assign({
          defaultElement: 'div',
          colorNames: colors,
          applyAnimatedValues: applyAnimatedValues$1,
          createStringInterpolator: createStringInterpolator$1
        });
        function GridItem(_a) {
          var children = _a.children,
            style = _a.style,
            className = _a.className,
            other = __rest(_a, ["children", "style", "className"]);
          var context = reactExports.useContext(GridItemContext);
          if (!context) {
            throw Error("Unable to find GridItem context. Please ensure that GridItem is used as a child of GridDropZone");
          }
          var top = context.top,
            disableDrag = context.disableDrag,
            endTraverse = context.endTraverse,
            onStart = context.onStart,
            mountWithTraverseTarget = context.mountWithTraverseTarget,
            left = context.left,
            i = context.i,
            onMove = context.onMove,
            onEnd = context.onEnd,
            grid = context.grid,
            isDragging = context.dragging;
          var columnWidth = grid.columnWidth,
            rowHeight = grid.rowHeight;
          var dragging = reactExports.useRef(false);
          var startCoords = reactExports.useRef([left, top]);
          var _b = __read(useSpring(function () {
              if (mountWithTraverseTarget) {
                // this feels really brittle. unsure of a better
                // solution for now.
                var mountXY = mountWithTraverseTarget;
                endTraverse();
                return {
                  xy: mountXY,
                  immediate: true,
                  zIndex: "1",
                  scale: 1.1,
                  opacity: 0.8
                };
              }
              return {
                xy: [left, top],
                immediate: true,
                zIndex: "0",
                scale: 1,
                opacity: 1
              };
            }), 2),
            styles = _b[0],
            set = _b[1];
          // handle move updates imperatively
          function handleMove(state, e) {
            var x = startCoords.current[0] + state.delta[0];
            var y = startCoords.current[1] + state.delta[1];
            set({
              xy: [x, y],
              zIndex: "1",
              immediate: true,
              opacity: 0.8,
              scale: 1.1
            });
            onMove(state, x, y);
          }
          // handle end of drag
          function handleEnd(state) {
            var x = startCoords.current[0] + state.delta[0];
            var y = startCoords.current[1] + state.delta[1];
            dragging.current = false;
            onEnd(state, x, y);
          }
          var bind = useGestureResponder({
            onMoveShouldSet: function (state) {
              if (disableDrag) {
                return false;
              }
              onStart();
              startCoords.current = [left, top];
              dragging.current = true;
              return true;
            },
            onMove: handleMove,
            onTerminationRequest: function () {
              if (dragging.current) {
                return false;
              }
              return true;
            },
            onTerminate: handleEnd,
            onRelease: handleEnd
          }, {
            enableMouse: true
          }).bind;
          /**
           * Update our position when left or top
           * values change
           */
          reactExports.useEffect(function () {
            if (!dragging.current) {
              set({
                xy: [left, top],
                zIndex: "0",
                opacity: 1,
                scale: 1,
                immediate: false
              });
            }
          }, [dragging.current, left, top]);
          var props = __assign({
            className: "GridItem" + (isDragging ? " dragging" : "") + (!!disableDrag ? " disabled" : "") + className ? " " + className : ""
          }, bind, {
            style: __assign({
              cursor: !!disableDrag ? "grab" : undefined,
              zIndex: styles.zIndex,
              position: "absolute",
              width: columnWidth + "px",
              opacity: styles.opacity,
              height: rowHeight + "px",
              boxSizing: "border-box",
              transform: createAnimatedInterpolation([styles.xy, styles.scale], function (xy, s) {
                return "translate3d(" + xy[0] + "px, " + xy[1] + "px, 0) scale(" + s + ")";
              })
            }, style)
          }, other);
          return typeof children === "function" ? children(animated$1.div, props, {
            dragging: isDragging,
            disabled: !!disableDrag,
            i: i,
            grid: grid
          }) : reactExports.createElement(animated$1.div, __assign({}, props), children);
        }
        const imageIconButton = "_imageIconButton_12ufg_1";
        const imageContainer$1 = "_imageContainer_12ufg_9";
        const addAnswerIcon = "_addAnswerIcon_12ufg_15";
        const addAnswerButton = "_addAnswerButton_12ufg_19";
        const styles$v = {
          imageIconButton: imageIconButton,
          imageContainer: imageContainer$1,
          addAnswerIcon: addAnswerIcon,
          addAnswerButton: addAnswerButton
        };
        var Add = {};
        var _interopRequireDefault$h = interopRequireDefaultExports;
        Object.defineProperty(Add, "__esModule", {
          value: true
        });
        var default_1$9 = Add.default = void 0;
        var _createSvgIcon$9 = _interopRequireDefault$h(requireCreateSvgIcon());
        var _jsxRuntime$9 = jsxRuntimeExports;
        var _default$c = (0, _createSvgIcon$9.default)( /*#__PURE__*/(0, _jsxRuntime$9.jsx)("path", {
          d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"
        }), 'Add');
        default_1$9 = Add.default = _default$c;
        function ImageChoiceQuestionItem({
          qualifiedCode,
          imageHeight,
          hideText,
          spacing,
          type,
          addAnswer
        }) {
          var _answer$resources;
          const dispatch = useDispatch();
          const theme = useTheme();
          const langInfo = useSelector(state => {
            return state.designState.langInfo;
          });
          const answer = useSelector(state => {
            return type == "add" ? void 0 : state.designState[qualifiedCode];
          });
          const onMainLang = langInfo.lang === langInfo.mainLang;
          const lang = langInfo.lang;
          const content = useSelector(state => {
            var _state$designState$qu, _state$designState$qu2;
            return type == "add" ? void 0 : (_state$designState$qu = state.designState[qualifiedCode].content) === null || _state$designState$qu === void 0 ? void 0 : (_state$designState$qu2 = _state$designState$qu["label"]) === null || _state$designState$qu2 === void 0 ? void 0 : _state$designState$qu2[lang];
          });
          const mainContent = useSelector(state => {
            var _state$designState$qu3, _state$designState$qu4;
            return type == "add" ? void 0 : (_state$designState$qu3 = state.designState[qualifiedCode].content) === null || _state$designState$qu3 === void 0 ? void 0 : (_state$designState$qu4 = _state$designState$qu3["label"]) === null || _state$designState$qu4 === void 0 ? void 0 : _state$designState$qu4[langInfo.mainLang];
          });
          const onDelete = () => {
            if (window.confirm(`Are you sure?`)) {
              dispatch(removeAnswer(qualifiedCode));
            }
          };
          const backgroundImage = answer !== null && answer !== void 0 && (_answer$resources = answer.resources) !== null && _answer$resources !== void 0 && _answer$resources.image ? `url('${buildResourceUrl(answer.resources.image)}')` : "0";
          function handleImageChange(e) {
            e.preventDefault();
            let file = e.target.files[0];
            DesignService.uploadResource(file).then(response => {
              dispatch(changeResources({
                code: qualifiedCode,
                key: "image",
                value: file.name
              }));
            }).catch(err => {
              console.error(err);
            });
          }
          return type == "add" ? /* @__PURE__ */jsxRuntimeExports.jsx(GridItem, {
            style: {
              padding: spacing + "px"
            },
            children: /* @__PURE__ */jsxRuntimeExports.jsx(Card, {
              className: styles$v.addAnswerButton,
              style: {
                backgroundColor: theme.palette.background.default,
                height: imageHeight + "px",
                width: "100%"
              },
              children: /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                className: styles$v.addAnswerIcon,
                onClick: () => {
                  addAnswer();
                },
                children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$9, {})
              })
            })
          }, "add") : /* @__PURE__ */jsxRuntimeExports.jsxs(GridItem, {
            style: {
              padding: spacing + "px"
            },
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs(Card, {
              className: styles$v.imageContainer,
              style: {
                backgroundImage,
                backgroundColor: theme.palette.background.default,
                height: imageHeight + "px"
              },
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                className: styles$v.imageIconButton,
                onClick: () => {
                  onDelete();
                },
                children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$h, {})
              }), /* @__PURE__ */jsxRuntimeExports.jsxs(IconButton, {
                component: "label",
                className: styles$v.imageIconButton,
                children: [/* @__PURE__ */jsxRuntimeExports.jsx("input", {
                  hidden: true,
                  id: qualifiedCode,
                  accept: "image/*",
                  multiple: true,
                  type: "file",
                  onChange: handleImageChange
                }), /* @__PURE__ */jsxRuntimeExports.jsx(default_1$r, {})]
              })]
            }), !hideText && /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
              variant: "standard",
              value: content || "",
              onChange: e => dispatch(changeContent({
                code: qualifiedCode,
                key: "label",
                lang,
                value: e.target.value
              })),
              placeholder: onMainLang ? "Option" : mainContent || "Option",
              InputProps: {
                sx: {
                  fontFamily: theme.textStyles.text.font,
                  color: theme.textStyles.text.color,
                  fontSize: theme.textStyles.text.size
                }
              }
            })]
          }, qualifiedCode);
        }
        function ImageChoiceQuestion(props) {
          const containerRef = reactExports.useRef(null);
          const dispatch = useDispatch();
          const [width, setWidth] = reactExports.useState(800);
          const children = useSelector(state => {
            return state.designState[props.code].children || [];
          });
          const questionType = useSelector(state => {
            return state.designState[props.code].type;
          });
          const childrenWithAdd = [...children, {
            type: "add",
            code: "add"
          }];
          const columnNumber = useSelector(state => {
            return state.designState[props.code].columns || 2;
          });
          const hideText = useSelector(state => {
            return state.designState[props.code].hideText || false;
          });
          const spacing = useSelector(state => {
            return state.designState[props.code].spacing || 8;
          });
          const imageAspectRatio = useSelector(state => {
            return state.designState[props.code].imageAspectRatio || 1;
          });
          const textHeight = hideText ? 0 : 80;
          const imageHeight = (width - columnNumber * spacing * 2) / columnNumber / imageAspectRatio;
          const totalHeight = Math.ceil(((children ? children.length : 0) + 1) / columnNumber) * (imageHeight + textHeight + columnNumber * spacing);
          const onChange = (sourceId, sourceIndex, targetIndex, targetId) => {
            if (sourceIndex < childrenWithAdd.length - 1 && targetIndex < childrenWithAdd.length - 1) {
              const payload = {
                type: "reorder_answers",
                id: children[sourceIndex].qualifiedCode,
                fromIndex: sourceIndex,
                toIndex: targetIndex
              };
              dispatch(onDrag(payload));
            }
          };
          reactExports.useEffect(() => {
            var _containerRef$current;
            setWidth(containerRef === null || containerRef === void 0 ? void 0 : (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.offsetWidth);
          }, [containerRef]);
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            ref: containerRef,
            className: styles$w.questionItem,
            style: {
              direction: "ltr"
            },
            children: imageHeight && /* @__PURE__ */jsxRuntimeExports.jsx(GridContextProvider, {
              onChange,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(GridDropZone, {
                id: "items-" + props.code,
                boxesPerRow: columnNumber,
                rowHeight: imageHeight + textHeight + spacing,
                style: {
                  height: totalHeight + "px"
                },
                children: childrenWithAdd.map(item => /* @__PURE__ */jsxRuntimeExports.jsx(ImageChoiceQuestionItem, {
                  spacing,
                  addAnswer: () => props.addNewAnswer(props.code, questionType),
                  type: item.type,
                  imageHeight,
                  hideText,
                  qualifiedCode: item.qualifiedCode
                }, item.code))
              })
            })
          });
        }
        const placeholder$1 = "_placeholder_4iqf5_1";
        const buttonContainer$1 = "_buttonContainer_4iqf5_9";
        const styles$u = {
          placeholder: placeholder$1,
          buttonContainer: buttonContainer$1
        };
        function VideoDisplayDesign({
          code
        }) {
          var _state$resources;
          useTheme();
          const dispatch = useDispatch();
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const handleVideoUpload = e => {
            e.preventDefault();
            let file = e.target.files[0];
            DesignService.uploadResource(file).then(response => {
              dispatch(changeResources({
                code,
                key: "videoUrl",
                value: file.name
              }));
            }).catch(err => {
              console.error(err);
            });
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [((_state$resources = state.resources) === null || _state$resources === void 0 ? void 0 : _state$resources.videoUrl) && /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              style: {
                position: "relative",
                marginTop: "16px",
                // 16:9 aspect ratio
                paddingTop: state.audio_only ? "10%" : "56%"
              },
              children: /* @__PURE__ */jsxRuntimeExports.jsx(ReactPlayer, {
                url: buildResourceUrl(state.resources.videoUrl),
                loop: state.loop || false,
                light: true,
                controls: true,
                config: {
                  forceAudio: state.audio_only || false
                },
                style: {
                  backgroundColor: "black",
                  position: "absolute",
                  top: "0",
                  left: "0"
                },
                volume: 1,
                width: "100%",
                height: "100%"
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: styles$u.buttonContainer,
              children: /* @__PURE__ */jsxRuntimeExports.jsxs(Button, {
                component: "label",
                variant: "outlined",
                startIcon: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$s, {}),
                children: [state.video ? "Replace Video" : "Upload Video", /* @__PURE__ */jsxRuntimeExports.jsx("input", {
                  hidden: true,
                  id: code,
                  accept: "video/*",
                  multiple: true,
                  type: "file",
                  onChange: handleVideoUpload
                })]
              })
            })]
          });
        }
        const signatureCanvas = "_signatureCanvas_1uxb1_1";
        const styles$t = {
          signatureCanvas: signatureCanvas
        };
        function SignatureDesign() {
          return /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
            className: styles$t.signatureCanvas,
            sx: {
              backgroundColor: "background.default"
            },
            children: /* @__PURE__ */jsxRuntimeExports.jsx("img", {
              src: "/signature.png",
              style: {
                backgroundColor: "rgba(255,255,255,255)",
                width: "80%",
                maxWidth: "500px",
                height: "200px"
              }
            })
          });
        }
        const placeholder = "_placeholder_xjf3c_1";
        const buttonContainer = "_buttonContainer_xjf3c_9";
        const imageContainer = "_imageContainer_xjf3c_14";
        const styles$s = {
          placeholder: placeholder,
          buttonContainer: buttonContainer,
          imageContainer: imageContainer
        };
        function ImageDisplayDesign({
          code
        }) {
          var _state$resources2;
          const dispatch = useDispatch();
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const handleUpload = e => {
            e.preventDefault();
            let file = e.target.files[0];
            DesignService.uploadResource(file).then(response => {
              dispatch(changeResources({
                code,
                key: "imageUrl",
                value: file.name
              }));
            }).catch(err => {
              console.error(err);
            });
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [((_state$resources2 = state.resources) === null || _state$resources2 === void 0 ? void 0 : _state$resources2.imageUrl) && /* @__PURE__ */jsxRuntimeExports.jsx("img", {
              style: {
                width: "100%"
              },
              src: buildResourceUrl(state.resources.imageUrl)
            }), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: styles$s.buttonContainer,
              children: /* @__PURE__ */jsxRuntimeExports.jsxs(Button, {
                component: "label",
                variant: "outlined",
                startIcon: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$r, {}),
                children: [state.video ? "Replace Image" : "Upload Image", /* @__PURE__ */jsxRuntimeExports.jsx("input", {
                  hidden: true,
                  id: code,
                  accept: "image/*",
                  type: "file",
                  onChange: handleUpload
                })]
              })
            })]
          });
        }
        const choicesContainer = "_choicesContainer_k0bnu_1";
        const choice = "_choice_k0bnu_1";
        const choiceLabels = "_choiceLabels_k0bnu_19";
        const styles$r = {
          choicesContainer: choicesContainer,
          choice: choice,
          choiceLabels: choiceLabels
        };
        function NPSDesign({
          code
        }) {
          var _state$content5, _state$content5$lower, _state$content6, _state$content6$highe;
          useTheme();
          let columns = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const lang = useSelector(state2 => {
            return state2.designState.langInfo.lang;
          });
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
              className: styles$r.choiceLabels,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Box, {
                children: (_state$content5 = state.content) === null || _state$content5 === void 0 ? void 0 : (_state$content5$lower = _state$content5.lower_bound_hint) === null || _state$content5$lower === void 0 ? void 0 : _state$content5$lower[lang]
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
                children: (_state$content6 = state.content) === null || _state$content6 === void 0 ? void 0 : (_state$content6$highe = _state$content6.higher_bound_hint) === null || _state$content6$highe === void 0 ? void 0 : _state$content6$highe[lang]
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
              className: styles$r.choicesContainer,
              children: columns.map(option => {
                return /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
                  className: styles$r.choice,
                  children: option
                }, option);
              })
            })]
          });
        }
        const container$1 = "_container_cyg3h_1";
        const styles$q = {
          container: container$1
        };
        function PhotoCaptureDesign({
          code
        }) {
          var _state$content7, _state$content7$hint;
          useTheme$1();
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const lang = useSelector(state2 => {
            return state2.designState.langInfo.lang;
          });
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
            className: styles$q.container,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("img", {
              src: "/camera.png",
              style: {
                maxHeight: "200px"
              }
            }), /* @__PURE__ */jsxRuntimeExports.jsx("br", {}), state.showHint && /* @__PURE__ */jsxRuntimeExports.jsx("span", {
              children: ((_state$content7 = state.content) === null || _state$content7 === void 0 ? void 0 : (_state$content7$hint = _state$content7.hint) === null || _state$content7$hint === void 0 ? void 0 : _state$content7$hint[lang]) || ""
            })]
          });
        }
        const container = "_container_cyg3h_1";
        const styles$p = {
          container: container
        };
        function VideoCaptureDesign({
          code
        }) {
          var _state$content8, _state$content8$hint;
          useTheme$1();
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const lang = useSelector(state2 => {
            return state2.designState.langInfo.lang;
          });
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
            className: styles$p.container,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("img", {
              src: "/video.png",
              style: {
                maxHeight: "200px"
              }
            }), /* @__PURE__ */jsxRuntimeExports.jsx("br", {}), state.showHint && /* @__PURE__ */jsxRuntimeExports.jsx("span", {
              children: ((_state$content8 = state.content) === null || _state$content8 === void 0 ? void 0 : (_state$content8$hint = _state$content8.hint) === null || _state$content8$hint === void 0 ? void 0 : _state$content8$hint[lang]) || ""
            })]
          });
        }
        function QuestionDesign({
          code,
          type,
          parentCode,
          dragHandleProps,
          t
        }) {
          console.log(code);
          const dispatch = useDispatch();
          const theme = useTheme();
          const isInSetup = useSelector(state => {
            var _state$designState$se2;
            return ((_state$designState$se2 = state.designState.setup) === null || _state$designState$se2 === void 0 ? void 0 : _state$designState$se2.code) == code;
          });
          const children = useSelector(state => {
            return state.designState[code].children;
          });
          const collapsed = useSelector(state => {
            return state.designState[code].collapsed;
          });
          const toggleCollapse = () => {
            dispatch(toggleComponentCollapse(code));
          };
          const showQuestion = () => {
            switch (type) {
              case "video_display":
                return /* @__PURE__ */jsxRuntimeExports.jsx(VideoDisplayDesign, {
                  code
                }, code);
              case "image_display":
                return /* @__PURE__ */jsxRuntimeExports.jsx(ImageDisplayDesign, {
                  code
                }, code);
              case "signature":
                return /* @__PURE__ */jsxRuntimeExports.jsx(SignatureDesign, {});
              case "photo_capture":
                return /* @__PURE__ */jsxRuntimeExports.jsx(PhotoCaptureDesign, {
                  code
                });
              case "video_capture":
                return /* @__PURE__ */jsxRuntimeExports.jsx(VideoCaptureDesign, {
                  code
                });
              case "date_time":
                return /* @__PURE__ */jsxRuntimeExports.jsx(DateTimeQuestionDesign, {
                  code
                }, code);
              case "date":
                return /* @__PURE__ */jsxRuntimeExports.jsx(DateTimeQuestionDesign, {
                  code
                }, code);
              case "time":
                return /* @__PURE__ */jsxRuntimeExports.jsx(TimeQuestionDesign, {
                  code
                }, code);
              case "scq":
                return /* @__PURE__ */jsxRuntimeExports.jsx(ChoiceQuestion, {
                  t,
                  addNewAnswer: addAnswer,
                  code,
                  type: "radio"
                }, code);
              case "image_mcq":
              case "image_scq":
              case "image_ranking":
                return /* @__PURE__ */jsxRuntimeExports.jsx(ImageChoiceQuestion, {
                  t,
                  addNewAnswer: addAnswer,
                  code
                }, code);
              case "scq_array":
                return /* @__PURE__ */jsxRuntimeExports.jsx(SCQArray, {
                  addNewAnswer: addAnswer,
                  code,
                  t
                }, code);
              case "file_upload":
                return /* @__PURE__ */jsxRuntimeExports.jsx(FileUploadQuestionDesign, {
                  code
                }, code);
              case "mcq":
                return /* @__PURE__ */jsxRuntimeExports.jsx(ChoiceQuestion, {
                  addNewAnswer: addAnswer,
                  code,
                  t,
                  type: "checkbox"
                }, code);
              case "ranking":
                return /* @__PURE__ */jsxRuntimeExports.jsx(ChoiceQuestion, {
                  addNewAnswer: addAnswer,
                  code,
                  t,
                  type: "ranking"
                }, code);
              case "nps":
                return /* @__PURE__ */jsxRuntimeExports.jsx(NPSDesign, {
                  code
                }, code);
              case "number":
                return /* @__PURE__ */jsxRuntimeExports.jsx(NumberQuestionDesign, {
                  code
                }, code);
              case "text":
                return /* @__PURE__ */jsxRuntimeExports.jsx(TextQuestionDesign, {
                  code
                }, code);
              case "paragraph":
                return /* @__PURE__ */jsxRuntimeExports.jsx(ParagraphQuestionDesign, {
                  t,
                  code
                }, code);
              case "email":
                return /* @__PURE__ */jsxRuntimeExports.jsx(EmailQuestionDesign, {
                  code
                }, code);
              default:
                return "";
            }
          };
          const addAnswer = (questionCode, questionType, type2) => {
            const answers = children || [];
            let nextAnswerIndex = 1;
            let code2 = "";
            let qualifiedCode = "";
            let label = "";
            const valueInstruction = {
              code: "value",
              isActive: false,
              returnType: {
                name: questionType == "ranking" || questionType == "nps" || questionType == "image_ranking" ? "Int" : "Boolean"
              },
              text: ""
            };
            switch (type2) {
              case "column":
                nextAnswerIndex = nextId$1(answers.filter(el => el.type === "column"));
                label = "Col" + nextAnswerIndex;
                code2 = "Ac" + nextAnswerIndex;
                qualifiedCode = questionCode + code2;
                dispatch(addNewAnswer({
                  label,
                  answer: {
                    code: code2,
                    qualifiedCode,
                    type: type2
                  }
                }));
                break;
              case "row":
                nextAnswerIndex = nextId$1(answers.filter(el => el.type === "row"));
                code2 = "A" + nextAnswerIndex;
                label = "Row" + nextAnswerIndex;
                qualifiedCode = questionCode + code2;
                dispatch(addNewAnswer({
                  label,
                  instructionList: [valueInstruction],
                  answer: {
                    code: code2,
                    qualifiedCode,
                    type: type2
                  }
                }));
                break;
              case "other":
                code2 = "Aother";
                label = "Other";
                qualifiedCode = questionCode + code2;
                const instructionListForText = [{
                  code: "value",
                  isActive: false,
                  returnType: {
                    name: "String"
                  },
                  text: ""
                }, {
                  code: "conditional_relevance",
                  isActive: true,
                  returnType: {
                    name: "Boolean"
                  },
                  text: questionType === "scq" ? `${questionCode}.value === 'Aother'` : `${questionCode}Aother.value === true`
                }];
                dispatch(addNewAnswer({
                  label,
                  answer: {
                    code: code2,
                    qualifiedCode,
                    type: type2
                  },
                  instructionList: questionType == "mcq" ? [valueInstruction] : []
                }));
                dispatch(addNewAnswer({
                  instructionList: instructionListForText,
                  answer: {
                    code: "Atext",
                    qualifiedCode: qualifiedCode + "Atext",
                    type: "other_text"
                  }
                }));
                break;
              default:
                nextAnswerIndex = nextId$1(answers);
                code2 = "A" + nextAnswerIndex;
                label = "Option" + nextAnswerIndex;
                qualifiedCode = questionCode + code2;
                dispatch(addNewAnswer({
                  label,
                  answer: {
                    code: code2,
                    qualifiedCode
                  },
                  instructionList: questionType == "mcq" || questionType == "image_mcq" || questionType == "ranking" || questionType == "image_ranking" ? [valueInstruction] : []
                }));
                break;
            }
          };
          const setSetup = React.useCallback(() => {
            dispatch(setup({
              code,
              rules: setupOptions(type)
            }));
          });
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
            sx: {
              backgroundColor: isInSetup ? "beige" : "background.paper",
              borderColor: "grey.500"
            },
            className: `${styles$G.groupQuestion}`,
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$G.questionWrapper,
              children: [/* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx("div", {
                  className: styles$G.moveBox,
                  ...dragHandleProps,
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$o, {})
                }), /* @__PURE__ */jsxRuntimeExports.jsx(ActionToolbar, {
                  t,
                  isGroup: false,
                  code,
                  parentCode,
                  toggleCollapse,
                  collapsed,
                  onClone: () => dispatch(cloneQuestion(code)),
                  onDelete: () => dispatch(deleteQuestion(code)),
                  disableDelete: false
                })]
              }), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                className: styles$G.titleQuestion,
                style: {
                  fontFamily: theme.textStyles.question.font,
                  color: theme.textStyles.question.color,
                  fontSize: theme.textStyles.question.size
                },
                children: /* @__PURE__ */jsxRuntimeExports.jsx(ContentEditor$2, {
                  code,
                  extended: false,
                  onActive: setSetup,
                  placeholder: "Title",
                  contentKey: "label"
                })
              }), !collapsed && /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
                className: styles$G.textDescriptionContent,
                children: /* @__PURE__ */jsxRuntimeExports.jsx(ContentEditor$2, {
                  code,
                  onActive: setSetup,
                  extended: true,
                  placeholder: "Description",
                  contentKey: "description"
                })
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Collapse, {
              in: collapsed !== true,
              timeout: "auto",
              unmountOnExit: true,
              children: showQuestion()
            }), /* @__PURE__ */jsxRuntimeExports.jsx(ErrorDisplay$1, {
              code
            })]
          });
        }
        const QuestionDesign$1 = React.memo(QuestionDesign);
        const textHeader = "_textHeader_iiwtl_1";
        const textDescription = "_textDescription_iiwtl_6";
        const titleRow = "_titleRow_iiwtl_12";
        const groupCard = "_groupCard_iiwtl_23";
        const groupEmptyHint$1 = "_groupEmptyHint_iiwtl_33";
        const type = "_type_iiwtl_43";
        const questionsOuterContainer = "_questionsOuterContainer_iiwtl_50";
        const questionsInnerContainer = "_questionsInnerContainer_iiwtl_54";
        const groupDesignError = "_groupDesignError_iiwtl_59";
        const groupHeader = "_groupHeader_iiwtl_64";
        const inputGroupTitle = "_inputGroupTitle_iiwtl_70";
        const inputGroupDescription = "_inputGroupDescription_iiwtl_75";
        const moveBox = "_moveBox_iiwtl_80";
        const styles$o = {
          textHeader: textHeader,
          textDescription: textDescription,
          titleRow: titleRow,
          groupCard: groupCard,
          groupEmptyHint: groupEmptyHint$1,
          type: type,
          questionsOuterContainer: questionsOuterContainer,
          questionsInnerContainer: questionsInnerContainer,
          groupDesignError: groupDesignError,
          groupHeader: groupHeader,
          inputGroupTitle: inputGroupTitle,
          inputGroupDescription: inputGroupDescription,
          moveBox: moveBox
        };
        function GroupDesign(props) {
          console.log(props.code);
          const dispatch = useDispatch();
          const [open, setOpen] = React.useState(false);
          const collapsed = useSelector(state => {
            return state.designState[props.code].collapsed;
          });
          const isInSetup = useSelector(state => {
            var _state$designState$se3;
            return ((_state$designState$se3 = state.designState.setup) === null || _state$designState$se3 === void 0 ? void 0 : _state$designState$se3.code) == props.code;
          });
          const children = useSelector(state => {
            return state.designState[props.code].children;
          });
          const toggleCollapse = () => {
            dispatch(toggleComponentCollapse(props.code));
          };
          const setSetup = React.useCallback(() => {
            dispatch(setup({
              code: props.code,
              rules: setupOptions("group")
            }));
          });
          const theme = useTheme();
          return /* @__PURE__ */jsxRuntimeExports.jsxs(React.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(PublicDraggable, {
              isDragDisabled: props.isDragDisabled,
              draggableId: props.code,
              index: props.dragIndex,
              children: provided => /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                ref: provided.innerRef,
                ...provided.draggableProps,
                children: /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                  className: styles$o.groupCard,
                  sx: {
                    borderColor: "grey.500",
                    boxShadow: 1,
                    backgroundColor: isInSetup ? "beige" : "background.paper"
                  },
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx(Box, {
                    sx: {
                      backgroundColor: "primary.main",
                      height: "8px"
                    },
                    className: styles$o.groupHeader
                  }), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                    ...provided.dragHandleProps,
                    className: styles$o.moveBox,
                    onMouseDown: event => {
                      if (props.isDragDisabled) {
                        event.preventDefault();
                        setOpen(true);
                      }
                    },
                    children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$o, {})
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(ActionToolbar, {
                    code: props.code,
                    t: props.t,
                    isGroup: true,
                    toggleCollapse,
                    collapsed,
                    onDelete: () => dispatch(deleteGroup(props.code)),
                    disableDelete: children && children.length > 0
                  }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                    className: styles$o.titleRow,
                    children: [/* @__PURE__ */jsxRuntimeExports.jsx("div", {
                      className: styles$o.textHeader,
                      style: {
                        fontFamily: theme.textStyles.group.font,
                        color: theme.textStyles.group.color,
                        fontSize: theme.textStyles.group.size
                      },
                      children: /* @__PURE__ */jsxRuntimeExports.jsx(ContentEditor$2, {
                        code: props.code,
                        extended: false,
                        onActive: setSetup,
                        contentKey: "label",
                        placeholder: "Title"
                      })
                    }), /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
                      className: styles$o.textDescription,
                      children: /* @__PURE__ */jsxRuntimeExports.jsx(ContentEditor$2, {
                        code: props.code,
                        extended: true,
                        onActive: setSetup,
                        contentKey: "description",
                        placeholder: "Description"
                      })
                    })]
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(ErrorDisplay$1, {
                    type: "group",
                    code: props.code
                  })]
                })
              })
            }, props.code), /* @__PURE__ */jsxRuntimeExports.jsx(Collapse, {
              className: styles$o.questionsOuterContainer,
              in: collapsed !== true,
              sx: {
                backgroundColor: isInSetup ? "beige" : "background.paper"
              },
              timeout: "auto",
              unmountOnExit: true,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(ConnectedDroppable, {
                droppableId: props.code,
                type: "questions",
                children: provided => /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
                  ref: provided.innerRef,
                  ...provided.droppableProps,
                  className: styles$o.questionsInnerContainer,
                  sx: {
                    backgroundColor: "background.default"
                  },
                  children: [children === null || children === void 0 ? void 0 : children.map((quest, index) => {
                    return /* @__PURE__ */jsxRuntimeExports.jsx(PublicDraggable, {
                      parentIndex: props.dragIndex,
                      draggableId: quest.code,
                      index: props.dragIndex + index + 1,
                      children: (provided2, snapshot) => /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                        ref: provided2.innerRef,
                        snapshot,
                        ...provided2.draggableProps,
                        children: [/* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                          className: styles$o.type,
                          children: [iconByType(quest.type, "small"), " ", props.t("component_" + quest.type + "_title")]
                        }), /* @__PURE__ */jsxRuntimeExports.jsx(QuestionDesign$1, {
                          t: props.t,
                          dragHandleProps: provided2.dragHandleProps,
                          parentCode: props.code,
                          index,
                          type: quest.type,
                          code: quest.code
                        }, quest.code)]
                      })
                    }, quest.code);
                  }), !children && /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                    className: styles$o.groupEmptyHint,
                    children: /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                      children: props.t("empty_group_hint")
                    })
                  }), provided.placeholder]
                })
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsxs(Dialog, {
              open,
              onClose: () => setOpen(false),
              "aria-labelledby": "alert-dialog-title-collapse-all",
              "aria-describedby": "alert-dialog-description",
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(DialogTitle, {
                id: "alert-dialog-title-collapse-all",
                children: "All Groups Must be collapsed first before you can drag them... Collapse All?"
              }), /* @__PURE__ */jsxRuntimeExports.jsxs(DialogActions, {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                  onClick: () => setOpen(false),
                  children: "Cancel"
                }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                  onClick: () => {
                    dispatch(collapseAllGroups());
                    setOpen(false);
                  },
                  children: "Collapse"
                })]
              })]
            })]
          });
        }
        const GroupDesign$1 = React.memo(GroupDesign);
        const surveyGroups = "_surveyGroups_10g3b_1";
        const groupEmptyHint = "_groupEmptyHint_10g3b_8";
        const footer = "_footer_10g3b_18";
        const contentPanel = "_contentPanel_10g3b_22";
        const headerImage = "_headerImage_10g3b_30";
        const styles$n = {
          surveyGroups: surveyGroups,
          groupEmptyHint: groupEmptyHint,
          footer: footer,
          contentPanel: contentPanel,
          headerImage: headerImage
        };
        function ContentPanel(props) {
          var _props$groups2;
          const theme = useTheme();
          let isDragDisabled = false;
          const codeIndex = useSelector(state => {
            return buildIndex(state.designState, props.groups);
          }, isEquivalent);
          const collapseInfo = useSelector(state => {
            var _props$groups;
            const info = {};
            (_props$groups = props.groups) === null || _props$groups === void 0 ? void 0 : _props$groups.forEach(element => {
              info[element.code] = state.designState[element.code].collapsed;
            });
            return info;
          }, isEquivalent);
          (_props$groups2 = props.groups) === null || _props$groups2 === void 0 ? void 0 : _props$groups2.forEach(group => {
            if (group && !collapseInfo[group.code]) {
              isDragDisabled = true;
            }
          });
          const groupsEmpty = !props.groups;
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            className: styles$n.contentPanel,
            style: {
              fontFamily: theme.textStyles.text.font,
              color: theme.textStyles.text.color,
              fontSize: theme.textStyles.text.size
            },
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(ErrorDisplay$1, {
              code: "Survey"
            }), /* @__PURE__ */jsxRuntimeExports.jsx(ConnectedDroppable, {
              droppableId: "content-panel",
              type: "groups",
              children: provided => /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                ref: provided.innerRef,
                ...provided.droppableProps,
                children: [props.headerImage && /* @__PURE__ */jsxRuntimeExports.jsx(CardMedia, {
                  className: styles$n.cardImage,
                  component: "img",
                  image: buildResourceUrl(props.headerImage),
                  height: "140"
                }), props.groups && props.groups.map(group => {
                  const groupDesign = /* @__PURE__ */jsxRuntimeExports.jsx(GroupDesign$1, {
                    className: styles$n.surveyGroups,
                    t: props.t,
                    code: group.code,
                    dragIndex: codeIndex.indexOf(group.code),
                    isDragDisabled
                  }, group.code);
                  return groupDesign;
                }), groupsEmpty && /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                  className: styles$n.groupEmptyHint,
                  children: /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                    children: props.t("empty_survey_hint")
                  })
                }), provided.placeholder, /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                  className: styles$n.footer
                })]
              })
            })]
          });
        }
        const onDragEnd = (result, onDragListener) => {
          if (!result.destination) {
            return;
          } else if (result.type == "questions" && isGroup(result.source.droppableId) && isGroup(result.destination.droppableId)) {
            const payload = {
              type: "reorder_questions",
              source: result.source.droppableId,
              destination: result.destination.droppableId,
              id: result.draggableId,
              fromIndex: result.source.index,
              toIndex: result.destination.index
            };
            onDragListener(payload);
            return;
          } else if (result.type == "questions" && result.source.droppableId == "new-questions" && isGroup(result.destination.droppableId)) {
            const payload = {
              type: "new_question",
              questionType: result.draggableId,
              destination: result.destination.droppableId,
              toIndex: result.destination.index
            };
            onDragListener(payload);
            return;
          } else if (result.type == "groups" && isGroup(result.draggableId)) {
            const payload = {
              type: "reorder_groups",
              id: result.draggableId,
              fromIndex: result.source.index,
              toIndex: result.destination.index
            };
            onDragListener(payload);
            return;
          } else if (result.type == "groups" && result.source.droppableId == "new-groups") {
            const payload = {
              type: "new_group",
              groupType: result.draggableId,
              toIndex: result.destination.index
            };
            onDragListener(payload);
            return;
          } else if (result.type.startsWith("option")) {
            const payload = {
              type: "reorder_answers",
              id: result.draggableId,
              fromIndex: result.source.index,
              toIndex: result.destination.index
            };
            onDragListener(payload);
            return;
          } else if (result.type.startsWith("row") || result.type.startsWith("col")) {
            const payload = {
              type: "reorder_answers_by_type",
              id: result.draggableId,
              fromIndex: result.source.index,
              toIndex: result.destination.index
            };
            onDragListener(payload);
            return;
          }
        };
        var Palette = {};
        var _interopRequireDefault$g = interopRequireDefaultExports;
        Object.defineProperty(Palette, "__esModule", {
          value: true
        });
        var default_1$8 = Palette.default = void 0;
        var _createSvgIcon$8 = _interopRequireDefault$g(requireCreateSvgIcon());
        var _jsxRuntime$8 = jsxRuntimeExports;
        var _default$b = (0, _createSvgIcon$8.default)( /*#__PURE__*/(0, _jsxRuntime$8.jsx)("path", {
          d: "M12 2C6.49 2 2 6.49 2 12s4.49 10 10 10c1.38 0 2.5-1.12 2.5-2.5 0-.61-.23-1.2-.64-1.67-.08-.1-.13-.21-.13-.33 0-.28.22-.5.5-.5H16c3.31 0 6-2.69 6-6 0-4.96-4.49-9-10-9zm5.5 11c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm-3-4c-.83 0-1.5-.67-1.5-1.5S13.67 6 14.5 6s1.5.67 1.5 1.5S15.33 9 14.5 9zM5 11.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5S7.33 13 6.5 13 5 12.33 5 11.5zm6-4c0 .83-.67 1.5-1.5 1.5S8 8.33 8 7.5 8.67 6 9.5 6s1.5.67 1.5 1.5z"
        }), 'Palette');
        default_1$8 = Palette.default = _default$b;
        const leftContent = "_leftContent_1b40q_1";
        const leftPanelGroupItem = "_leftPanelGroupItem_1b40q_9";
        const close = "_close_1b40q_13";
        const styles$m = {
          leftContent: leftContent,
          leftPanelGroupItem: leftPanelGroupItem,
          close: close
        };
        function FieldSize({
          label,
          rule,
          defaultValue,
          code,
          lowerBound,
          upperBound
        }) {
          const dispatch = useDispatch();
          const value = useSelector(state => {
            return state.designState[code][rule] || defaultValue;
          });
          const onValueChange = event => {
            dispatch(changeAttribute({
              code,
              key: rule,
              value: Math.max(lowerBound, Math.min(upperBound, event.target.value))
            }));
          };
          const isError = value < lowerBound || value > upperBound;
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs("h4", {
              children: [label, ":"]
            }), /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
              label,
              error: isError,
              variant: "outlined",
              type: "number",
              size: "small",
              style: {
                maxWidth: "200px"
              },
              value,
              onChange: event => onValueChange(event)
            })]
          });
        }
        const showHint = "_showHint_9iocv_1";
        const inputValue$1 = "_inputValue_9iocv_9";
        const styles$l = {
          showHint: showHint,
          inputValue: inputValue$1
        };
        function ShowHint({
          code,
          t
        }) {
          const dispatch = useDispatch();
          const showHint = useSelector(state => {
            return state.designState[code].showHint || false;
          });
          const setCheckedHint = value => {
            dispatch(changeAttribute({
              code,
              key: "showHint",
              value
            }));
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$l.showHint,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("h4", {
                children: t("show_question_hint")
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Switch, {
                checked: showHint,
                onChange: event => setCheckedHint(event.target.checked)
              })]
            }), showHint && /* @__PURE__ */jsxRuntimeExports.jsx(ContentEditor, {
              code,
              objectName: "hint"
            })]
          });
        }
        function ContentEditor({
          code,
          objectName,
          title
        }) {
          const dispatch = useDispatch();
          const setContentValue = (lang, value) => {
            dispatch(changeContent({
              code,
              key: objectName,
              lang,
              value
            }));
          };
          const languagesList = useSelector(state => {
            return state.designState.langInfo.languagesList;
          });
          const hintObj = useSelector(state => {
            var _state$designState$co12;
            return (_state$designState$co12 = state.designState[code].content) === null || _state$designState$co12 === void 0 ? void 0 : _state$designState$co12[objectName];
          });
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [title && /* @__PURE__ */jsxRuntimeExports.jsx("h4", {
              children: title
            }), languagesList.map(lang => {
              return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                className: styles$l.inputValue,
                children: /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
                  label: lang.langName,
                  variant: "standard",
                  type: "text",
                  value: (hintObj === null || hintObj === void 0 ? void 0 : hintObj[lang.code]) || "",
                  onChange: event => setContentValue(lang.code, event.target.value)
                })
              }, lang.code);
            })]
          });
        }
        const boxContainer$1 = "_boxContainer_182us_1";
        const mt10$1 = "_mt10_182us_10";
        const uppercase$1 = "_uppercase_182us_14";
        const title$5 = "_title_182us_18";
        const styles$k = {
          boxContainer: boxContainer$1,
          mt10: mt10$1,
          uppercase: uppercase$1,
          title: title$5
        };
        const boxContainer = "_boxContainer_1vhs4_1";
        const mt10 = "_mt10_1vhs4_9";
        const uppercase = "_uppercase_1vhs4_13";
        const title$4 = "_title_1vhs4_18";
        const titleContent = "_titleContent_1vhs4_28";
        const standardError = "_standardError_1vhs4_33";
        const errorWrapper = "_errorWrapper_1vhs4_44";
        const errorLabelWrapper = "_errorLabelWrapper_1vhs4_48";
        const errorItem = "_errorItem_1vhs4_52";
        const errorItemContainer = "_errorItemContainer_1vhs4_58";
        const styles$j = {
          boxContainer: boxContainer,
          mt10: mt10,
          uppercase: uppercase,
          title: title$4,
          titleContent: titleContent,
          standardError: standardError,
          errorWrapper: errorWrapper,
          errorLabelWrapper: errorLabelWrapper,
          errorItem: errorItem,
          errorItemContainer: errorItemContainer
        };
        function ValidationSetupMessage({
          validationRule,
          code,
          rule,
          t
        }) {
          const dispatch = useDispatch();
          const isCustomErrorActive = validationRule.isCustomErrorActive || false;
          const languagesList = useSelector(state => {
            return state.designState.langInfo.languagesList;
          });
          let content = validationRule.content || {};
          const checkedCustomError = checked => {
            dispatch(changeValidationValue({
              code,
              rule,
              key: "isCustomErrorActive",
              value: checked
            }));
          };
          const onContentUpdate = (key, value) => {
            const newContent = {
              ...content,
              [key]: value
            };
            dispatch(changeValidationValue({
              code,
              rule,
              key: "content",
              value: newContent
            }));
          };
          const label = {
            inputProps: {
              "aria-label": "Switch validation"
            }
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("h4", {
              children: t("standard_error")
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$j.errorWrapper,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("div", {
                className: styles$j.errorLabelWrapper,
                children: languagesList.map(l => /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                  className: `${styles$j.errorItem} ${styles$j.uppercase}`,
                  children: [l.code, ":"]
                }, l.code))
              }), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                children: languagesList.map(l => /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                  className: styles$j.errorItem,
                  children: t(rule, {
                    ns: "run",
                    lng: l.code,
                    ...validationRule
                  })
                }, l.code))
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$j.title,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("h4", {
                className: styles$j.mt10,
                children: t("custom_error")
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Switch, {
                ...label,
                checked: isCustomErrorActive,
                onChange: event => checkedCustomError(event.target.checked)
              })]
            }), isCustomErrorActive ? /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$j.errorWrapper,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("div", {
                className: styles$j.errorLabelWrapper,
                children: languagesList.map(l => /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                  className: `${styles$j.errorItem} ${styles$j.uppercase}`,
                  children: [l.code, ":"]
                }, l.code))
              }), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                className: styles$j.errorItemContainer,
                children: languagesList.map(l => /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                  className: styles$j.errorItem,
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
                    size: "small",
                    variant: "standard",
                    value: content[l.code] || "",
                    onChange: event => onContentUpdate(l.code, event.target.value)
                  })
                }, l.code))
              })]
            }) : ""]
          });
        }
        const valueValidationItems = "_valueValidationItems_1hupk_1";
        const valueValidationItemsContainer = "_valueValidationItemsContainer_1hupk_6";
        const error = "_error_1hupk_11";
        const styles$i = {
          valueValidationItems: valueValidationItems,
          valueValidationItemsContainer: valueValidationItemsContainer,
          error: error
        };
        function ValidationSetupValue({
          code,
          validation,
          rule,
          t
        }) {
          const bounds = useSelector(state => {
            var _state$designState$co13, _state$designState$co14, _state$designState$co15;
            switch (rule) {
              case "validation_min_char_length":
                return [1, Number.MAX_VALUE];
              case "validation_max_char_length":
                return [1, Number.MAX_VALUE];
              case "validation_max_word_count":
                return [1, Number.MAX_VALUE];
              case "validation_min_word_count":
                return [1, Number.MAX_VALUE];
              case "validation_min_ranking_count":
              case "validation_min_option_count":
                return [1, ((_state$designState$co13 = state.designState[code].children) === null || _state$designState$co13 === void 0 ? void 0 : _state$designState$co13.length) || 0];
              case "validation_max_ranking_count":
              case "validation_max_option_count":
                return [1, ((_state$designState$co14 = state.designState[code].children) === null || _state$designState$co14 === void 0 ? void 0 : _state$designState$co14.length) || 0];
              case "validation_ranking_count":
              case "validation_option_count":
                return [1, ((_state$designState$co15 = state.designState[code].children) === null || _state$designState$co15 === void 0 ? void 0 : _state$designState$co15.length) || 0];
              default:
                return void 0;
            }
          });
          const dispatch = useDispatch();
          const onChange = (key, value) => {
            dispatch(changeValidationValue({
              rule,
              code,
              key,
              value
            }));
          };
          const onValuesUpdate = (key, value) => {
            onChange(key, typeof bounds === "undefined" ? value : Math.max(bounds[0], Math.min(bounds[1], value)));
          };
          let keys = validationAttributes(validation);
          const hasSubtitle = rule != "validation_required" && rule != "validation_pattern_email";
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            className: styles$i.valueValidationItemsContainer,
            children: [keys && hasSubtitle && /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              children: t(rule + "_subtitle")
            }), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: styles$i.valueValidationItems,
              children: keys.map(i => {
                const isInError = typeof bounds !== "undefined" && (validation[i] < bounds[0] || validation[i] > bounds[1]);
                return /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
                  error: isInError,
                  value: validation[i],
                  variant: "outlined",
                  size: "small",
                  type: typeof validation[i] === "number" ? "number" : "text",
                  onChange: event => onValuesUpdate(i, typeof validation[i] === "number" ? parseInt(event.target.value) : event.target.value),
                  style: {
                    maxWidth: "150px",
                    marginLeft: "8px"
                  }
                }, i);
              })
            })]
          });
        }
        const validationAttributes = validation => {
          return Object.keys(validation).filter(el => !["content", "isActive", "isCustomErrorActive", "bounds"].includes(el));
        };
        function ValidationSetupItem({
          rule,
          t,
          code
        }) {
          console.log("ValidationSetupItem: " + code);
          const dispatch = useDispatch();
          const validationRule = useSelector(state => {
            var _state$designState$co16, _state$designState$co17;
            return (_state$designState$co16 = state.designState[code]) === null || _state$designState$co16 === void 0 ? void 0 : (_state$designState$co17 = _state$designState$co16.validation) === null || _state$designState$co17 === void 0 ? void 0 : _state$designState$co17[rule];
          });
          const label = {
            inputProps: {
              "aria-label": "Switch validation"
            }
          };
          const isActive = (validationRule === null || validationRule === void 0 ? void 0 : validationRule.isActive) || false;
          const checkedValidationItem = checked => {
            dispatch(changeValidationValue({
              code,
              rule,
              key: "isActive",
              value: checked
            }));
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$k.title,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("h4", {
                children: t(rule + "_title")
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Switch, {
                ...label,
                checked: isActive,
                onChange: event => checkedValidationItem(event.target.checked)
              })]
            }), isActive && /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
              className: styles$k.boxContainer,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(ValidationSetupValue, {
                code,
                validation: validationRule,
                rule,
                t
              }), /* @__PURE__ */jsxRuntimeExports.jsx(ValidationSetupMessage, {
                code,
                validationRule,
                rule,
                t
              })]
            })]
          });
        }
        const ValidationSetupItem$1 = React.memo(ValidationSetupItem);
        const toggleValue = "_toggleValue_1d9zg_1";
        const inputValue = "_inputValue_1d9zg_8";
        const styles$h = {
          toggleValue: toggleValue,
          inputValue: inputValue
        };
        function ToggleValue({
          label,
          code,
          rule
        }) {
          const dispatch = useDispatch();
          const value = useSelector(state => {
            return state.designState[code][rule] || false;
          });
          const onChange = value2 => {
            dispatch(changeAttribute({
              code,
              key: rule,
              value: value2
            }));
          };
          const swithLabel = {
            inputProps: {
              "aria-label": "Switch demo"
            }
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            className: styles$h.toggleValue,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("h4", {
              children: label
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Switch, {
              ...swithLabel,
              checked: value,
              onChange: event => {
                onChange(event.target.checked);
              }
            })]
          });
        }
        const selectValue$1 = "_selectValue_9m4tq_1";
        const styles$g = {
          selectValue: selectValue$1
        };
        function SelectValue({
          label,
          rule,
          defaultValue,
          code,
          values,
          labels
        }) {
          const dispatch = useDispatch();
          const value = useSelector(state => {
            return state.designState[code][rule] || defaultValue;
          });
          const onChange = value2 => {
            dispatch(changeAttribute({
              code,
              key: rule,
              value: value2
            }));
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            className: styles$g.selectDate,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("h4", {
              children: label
            }), /* @__PURE__ */jsxRuntimeExports.jsx(FormControl, {
              variant: "standard",
              fullWidth: true,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(Select, {
                id: "select-value",
                value,
                label: "Select Value",
                onChange: e => {
                  onChange(e.target.value);
                },
                children: values.map((element, index) => {
                  return /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                    value: element,
                    children: labels ? labels[index] : element
                  }, element);
                })
              })
            })]
          });
        }
        const selectDate = "_selectDate_1qp3e_1";
        const selectDateField = "_selectDateField_1qp3e_8";
        const styles$f = {
          selectDate: selectDate,
          selectDateField: selectDateField
        };
        function SelectDate({
          label,
          rule,
          code
        }) {
          const dispatch = useDispatch();
          const value = useSelector(state => {
            return state.designState[code][rule] || "";
          });
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            className: styles$f.selectDate,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("h4", {
              children: label
            }), /* @__PURE__ */jsxRuntimeExports.jsx(TextField, {
              className: styles$f.selectDateField,
              variant: "standard",
              value,
              type: "date",
              onChange: event => {
                dispatch(changeAttribute({
                  code,
                  key: rule,
                  value: event.target.value
                }));
              }
            })]
          });
        }
        const theming = "_theming_5qk2m_1";
        const styles$e = {
          theming: theming
        };
        const color = "_color_1xjz4_1";
        const swatch = "_swatch_1xjz4_6";
        const popover = "_popover_1xjz4_13";
        const cover = "_cover_1xjz4_17";
        const styles$d = {
          color: color,
          swatch: swatch,
          popover: popover,
          cover: cover
        };
        var lib = {};
        var flattenNames$1 = {};
        var baseGetTag$3 = _baseGetTag,
          isArray$c = isArray_1,
          isObjectLike$6 = isObjectLike_1;

        /** `Object#toString` result references. */
        var stringTag$4 = '[object String]';

        /**
         * Checks if `value` is classified as a `String` primitive or object.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a string, else `false`.
         * @example
         *
         * _.isString('abc');
         * // => true
         *
         * _.isString(1);
         * // => false
         */
        function isString$1(value) {
          return typeof value == 'string' || !isArray$c(value) && isObjectLike$6(value) && baseGetTag$3(value) == stringTag$4;
        }
        var isString_1 = isString$1;

        /**
         * Creates a base function for methods like `_.forIn` and `_.forOwn`.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */

        function createBaseFor$2(fromRight) {
          return function (object, iteratee, keysFunc) {
            var index = -1,
              iterable = Object(object),
              props = keysFunc(object),
              length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        var _createBaseFor = createBaseFor$2;
        var createBaseFor$1 = _createBaseFor;

        /**
         * The base implementation of `baseForOwn` which iterates over `object`
         * properties returned by `keysFunc` and invokes `iteratee` for each property.
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */
        var baseFor$4 = createBaseFor$1();
        var _baseFor = baseFor$4;
        var baseFor$3 = _baseFor,
          keys$5 = keys_1;

        /**
         * The base implementation of `_.forOwn` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForOwn$4(object, iteratee) {
          return object && baseFor$3(object, iteratee, keys$5);
        }
        var _baseForOwn = baseForOwn$4;

        /**
         * This method returns the first argument it receives.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {*} value Any value.
         * @returns {*} Returns `value`.
         * @example
         *
         * var object = { 'a': 1 };
         *
         * console.log(_.identity(object) === object);
         * // => true
         */

        function identity$5(value) {
          return value;
        }
        var identity_1 = identity$5;
        var identity$4 = identity_1;

        /**
         * Casts `value` to `identity` if it's not a function.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {Function} Returns cast function.
         */
        function castFunction$2(value) {
          return typeof value == 'function' ? value : identity$4;
        }
        var _castFunction = castFunction$2;
        var baseForOwn$3 = _baseForOwn,
          castFunction$1 = _castFunction;

        /**
         * Iterates over own enumerable string keyed properties of an object and
         * invokes `iteratee` for each property. The iteratee is invoked with three
         * arguments: (value, key, object). Iteratee functions may exit iteration
         * early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @since 0.3.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @see _.forOwnRight
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forOwn(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'a' then 'b' (iteration order is not guaranteed).
         */
        function forOwn(object, iteratee) {
          return object && baseForOwn$3(object, castFunction$1(iteratee));
        }
        var forOwn_1 = forOwn;
        var overArg$1 = _overArg;

        /** Built-in value references. */
        var getPrototype$5 = overArg$1(Object.getPrototypeOf, Object);
        var _getPrototype = getPrototype$5;
        var baseGetTag$2 = _baseGetTag,
          getPrototype$4 = _getPrototype,
          isObjectLike$5 = isObjectLike_1;

        /** `Object#toString` result references. */
        var objectTag$5 = '[object Object]';

        /** Used for built-in method references. */
        var funcProto$3 = Function.prototype,
          objectProto$i = Object.prototype;

        /** Used to resolve the decompiled source of functions. */
        var funcToString$3 = funcProto$3.toString;

        /** Used to check objects for own properties. */
        var hasOwnProperty$f = objectProto$i.hasOwnProperty;

        /** Used to infer the `Object` constructor. */
        var objectCtorString$1 = funcToString$3.call(Object);

        /**
         * Checks if `value` is a plain object, that is, an object created by the
         * `Object` constructor or one with a `[[Prototype]]` of `null`.
         *
         * @static
         * @memberOf _
         * @since 0.8.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * _.isPlainObject(new Foo);
         * // => false
         *
         * _.isPlainObject([1, 2, 3]);
         * // => false
         *
         * _.isPlainObject({ 'x': 0, 'y': 0 });
         * // => true
         *
         * _.isPlainObject(Object.create(null));
         * // => true
         */
        function isPlainObject$3(value) {
          if (!isObjectLike$5(value) || baseGetTag$2(value) != objectTag$5) {
            return false;
          }
          var proto = getPrototype$4(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty$f.call(proto, 'constructor') && proto.constructor;
          return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString$3.call(Ctor) == objectCtorString$1;
        }
        var isPlainObject_1 = isPlainObject$3;

        /**
         * A specialized version of `_.map` for arrays without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */

        function arrayMap$5(array, iteratee) {
          var index = -1,
            length = array == null ? 0 : array.length,
            result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
        var _arrayMap = arrayMap$5;
        var Stack$3 = _Stack,
          baseIsEqual$2 = _baseIsEqual;

        /** Used to compose bitmasks for value comparisons. */
        var COMPARE_PARTIAL_FLAG$7 = 1,
          COMPARE_UNORDERED_FLAG$5 = 2;

        /**
         * The base implementation of `_.isMatch` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @param {Array} matchData The property names, values, and compare flags to match.
         * @param {Function} [customizer] The function to customize comparisons.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         */
        function baseIsMatch$2(object, source, matchData, customizer) {
          var index = matchData.length,
            length = index,
            noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0],
              objValue = object[key],
              srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack$3();
              if (customizer) {
                var result = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result === undefined ? baseIsEqual$2(srcValue, objValue, COMPARE_PARTIAL_FLAG$7 | COMPARE_UNORDERED_FLAG$5, customizer, stack) : result)) {
                return false;
              }
            }
          }
          return true;
        }
        var _baseIsMatch = baseIsMatch$2;
        var isObject$e = isObject_1;

        /**
         * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` if suitable for strict
         *  equality comparisons, else `false`.
         */
        function isStrictComparable$3(value) {
          return value === value && !isObject$e(value);
        }
        var _isStrictComparable = isStrictComparable$3;
        var isStrictComparable$2 = _isStrictComparable,
          keys$4 = keys_1;

        /**
         * Gets the property names, values, and compare flags of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the match data of `object`.
         */
        function getMatchData$2(object) {
          var result = keys$4(object),
            length = result.length;
          while (length--) {
            var key = result[length],
              value = object[key];
            result[length] = [key, value, isStrictComparable$2(value)];
          }
          return result;
        }
        var _getMatchData = getMatchData$2;

        /**
         * A specialized version of `matchesProperty` for source values suitable
         * for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {string} key The key of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         */

        function matchesStrictComparable$3(key, srcValue) {
          return function (object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
          };
        }
        var _matchesStrictComparable = matchesStrictComparable$3;
        var baseIsMatch$1 = _baseIsMatch,
          getMatchData$1 = _getMatchData,
          matchesStrictComparable$2 = _matchesStrictComparable;

        /**
         * The base implementation of `_.matches` which doesn't clone `source`.
         *
         * @private
         * @param {Object} source The object of property values to match.
         * @returns {Function} Returns the new spec function.
         */
        function baseMatches$2(source) {
          var matchData = getMatchData$1(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable$2(matchData[0][0], matchData[0][1]);
          }
          return function (object) {
            return object === source || baseIsMatch$1(object, source, matchData);
          };
        }
        var _baseMatches = baseMatches$2;
        var baseGetTag$1 = _baseGetTag,
          isObjectLike$4 = isObjectLike_1;

        /** `Object#toString` result references. */
        var symbolTag$4 = '[object Symbol]';

        /**
         * Checks if `value` is classified as a `Symbol` primitive or object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
         * @example
         *
         * _.isSymbol(Symbol.iterator);
         * // => true
         *
         * _.isSymbol('abc');
         * // => false
         */
        function isSymbol$5(value) {
          return typeof value == 'symbol' || isObjectLike$4(value) && baseGetTag$1(value) == symbolTag$4;
        }
        var isSymbol_1 = isSymbol$5;
        var isArray$b = isArray_1,
          isSymbol$4 = isSymbol_1;

        /** Used to match property names within property paths. */
        var reIsDeepProp$1 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
          reIsPlainProp$1 = /^\w*$/;

        /**
         * Checks if `value` is a property name and not a property path.
         *
         * @private
         * @param {*} value The value to check.
         * @param {Object} [object] The object to query keys on.
         * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
         */
        function isKey$4(value, object) {
          if (isArray$b(value)) {
            return false;
          }
          var type = typeof value;
          if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol$4(value)) {
            return true;
          }
          return reIsPlainProp$1.test(value) || !reIsDeepProp$1.test(value) || object != null && value in Object(object);
        }
        var _isKey = isKey$4;
        var MapCache$1 = _MapCache;

        /** Error message constants. */
        var FUNC_ERROR_TEXT$4 = 'Expected a function';

        /**
         * Creates a function that memoizes the result of `func`. If `resolver` is
         * provided, it determines the cache key for storing the result based on the
         * arguments provided to the memoized function. By default, the first argument
         * provided to the memoized function is used as the map cache key. The `func`
         * is invoked with the `this` binding of the memoized function.
         *
         * **Note:** The cache is exposed as the `cache` property on the memoized
         * function. Its creation may be customized by replacing the `_.memoize.Cache`
         * constructor with one whose instances implement the
         * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
         * method interface of `clear`, `delete`, `get`, `has`, and `set`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to have its output memoized.
         * @param {Function} [resolver] The function to resolve the cache key.
         * @returns {Function} Returns the new memoized function.
         * @example
         *
         * var object = { 'a': 1, 'b': 2 };
         * var other = { 'c': 3, 'd': 4 };
         *
         * var values = _.memoize(_.values);
         * values(object);
         * // => [1, 2]
         *
         * values(other);
         * // => [3, 4]
         *
         * object.a = 2;
         * values(object);
         * // => [1, 2]
         *
         * // Modify the result cache.
         * values.cache.set(object, ['a', 'b']);
         * values(object);
         * // => ['a', 'b']
         *
         * // Replace `_.memoize.Cache`.
         * _.memoize.Cache = WeakMap;
         */
        function memoize$2(func, resolver) {
          if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT$4);
          }
          var memoized = function () {
            var args = arguments,
              key = resolver ? resolver.apply(this, args) : args[0],
              cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, args);
            memoized.cache = cache.set(key, result) || cache;
            return result;
          };
          memoized.cache = new (memoize$2.Cache || MapCache$1)();
          return memoized;
        }

        // Expose `MapCache`.
        memoize$2.Cache = MapCache$1;
        var memoize_1 = memoize$2;
        var memoize$1 = memoize_1;

        /** Used as the maximum memoize cache size. */
        var MAX_MEMOIZE_SIZE$1 = 500;

        /**
         * A specialized version of `_.memoize` which clears the memoized function's
         * cache when it exceeds `MAX_MEMOIZE_SIZE`.
         *
         * @private
         * @param {Function} func The function to have its output memoized.
         * @returns {Function} Returns the new memoized function.
         */
        function memoizeCapped$2(func) {
          var result = memoize$1(func, function (key) {
            if (cache.size === MAX_MEMOIZE_SIZE$1) {
              cache.clear();
            }
            return key;
          });
          var cache = result.cache;
          return result;
        }
        var _memoizeCapped = memoizeCapped$2;
        var memoizeCapped$1 = _memoizeCapped;

        /** Used to match property names within property paths. */
        var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

        /** Used to match backslashes in property paths. */
        var reEscapeChar$1 = /\\(\\)?/g;

        /**
         * Converts `string` to a property path array.
         *
         * @private
         * @param {string} string The string to convert.
         * @returns {Array} Returns the property path array.
         */
        var stringToPath$3 = memoizeCapped$1(function (string) {
          var result = [];
          if (string.charCodeAt(0) === 46 /* . */) {
            result.push('');
          }
          string.replace(rePropName$1, function (match, number, quote, subString) {
            result.push(quote ? subString.replace(reEscapeChar$1, '$1') : number || match);
          });
          return result;
        });
        var _stringToPath = stringToPath$3;
        var Symbol$5 = _Symbol,
          arrayMap$4 = _arrayMap,
          isArray$a = isArray_1,
          isSymbol$3 = isSymbol_1;

        /** Used as references for various `Number` constants. */
        var INFINITY$4 = 1 / 0;

        /** Used to convert symbols to primitives and strings. */
        var symbolProto$3 = Symbol$5 ? Symbol$5.prototype : undefined,
          symbolToString$1 = symbolProto$3 ? symbolProto$3.toString : undefined;

        /**
         * The base implementation of `_.toString` which doesn't convert nullish
         * values to empty strings.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {string} Returns the string.
         */
        function baseToString$3(value) {
          // Exit early for strings to avoid a performance hit in some environments.
          if (typeof value == 'string') {
            return value;
          }
          if (isArray$a(value)) {
            // Recursively convert values (susceptible to call stack limits).
            return arrayMap$4(value, baseToString$3) + '';
          }
          if (isSymbol$3(value)) {
            return symbolToString$1 ? symbolToString$1.call(value) : '';
          }
          var result = value + '';
          return result == '0' && 1 / value == -INFINITY$4 ? '-0' : result;
        }
        var _baseToString = baseToString$3;
        var baseToString$2 = _baseToString;

        /**
         * Converts `value` to a string. An empty string is returned for `null`
         * and `undefined` values. The sign of `-0` is preserved.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.toString(null);
         * // => ''
         *
         * _.toString(-0);
         * // => '-0'
         *
         * _.toString([1, 2, 3]);
         * // => '1,2,3'
         */
        function toString$4(value) {
          return value == null ? '' : baseToString$2(value);
        }
        var toString_1 = toString$4;
        var isArray$9 = isArray_1,
          isKey$3 = _isKey,
          stringToPath$2 = _stringToPath,
          toString$3 = toString_1;

        /**
         * Casts `value` to a path array if it's not one.
         *
         * @private
         * @param {*} value The value to inspect.
         * @param {Object} [object] The object to query keys on.
         * @returns {Array} Returns the cast property path array.
         */
        function castPath$7(value, object) {
          if (isArray$9(value)) {
            return value;
          }
          return isKey$3(value, object) ? [value] : stringToPath$2(toString$3(value));
        }
        var _castPath = castPath$7;
        var isSymbol$2 = isSymbol_1;

        /** Used as references for various `Number` constants. */
        var INFINITY$3 = 1 / 0;

        /**
         * Converts `value` to a string key if it's not a string or symbol.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {string|symbol} Returns the key.
         */
        function toKey$7(value) {
          if (typeof value == 'string' || isSymbol$2(value)) {
            return value;
          }
          var result = value + '';
          return result == '0' && 1 / value == -INFINITY$3 ? '-0' : result;
        }
        var _toKey = toKey$7;
        var castPath$6 = _castPath,
          toKey$6 = _toKey;

        /**
         * The base implementation of `_.get` without support for default values.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @returns {*} Returns the resolved value.
         */
        function baseGet$5(object, path) {
          path = castPath$6(path, object);
          var index = 0,
            length = path.length;
          while (object != null && index < length) {
            object = object[toKey$6(path[index++])];
          }
          return index && index == length ? object : undefined;
        }
        var _baseGet = baseGet$5;
        var baseGet$4 = _baseGet;

        /**
         * Gets the value at `path` of `object`. If the resolved value is
         * `undefined`, the `defaultValue` is returned in its place.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @param {*} [defaultValue] The value returned for `undefined` resolved values.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.get(object, 'a[0].b.c');
         * // => 3
         *
         * _.get(object, ['a', '0', 'b', 'c']);
         * // => 3
         *
         * _.get(object, 'a.b.c', 'default');
         * // => 'default'
         */
        function get$6(object, path, defaultValue) {
          var result = object == null ? undefined : baseGet$4(object, path);
          return result === undefined ? defaultValue : result;
        }
        var get_1 = get$6;

        /**
         * The base implementation of `_.hasIn` without support for deep paths.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {Array|string} key The key to check.
         * @returns {boolean} Returns `true` if `key` exists, else `false`.
         */

        function baseHasIn$2(object, key) {
          return object != null && key in Object(object);
        }
        var _baseHasIn = baseHasIn$2;
        var castPath$5 = _castPath,
          isArguments$4 = isArguments_1,
          isArray$8 = isArray_1,
          isIndex$3 = _isIndex,
          isLength$1 = isLength_1,
          toKey$5 = _toKey;

        /**
         * Checks if `path` exists on `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @param {Function} hasFunc The function to check properties.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         */
        function hasPath$2(object, path, hasFunc) {
          path = castPath$5(path, object);
          var index = -1,
            length = path.length,
            result = false;
          while (++index < length) {
            var key = toKey$5(path[index]);
            if (!(result = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result || ++index != length) {
            return result;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength$1(length) && isIndex$3(key, length) && (isArray$8(object) || isArguments$4(object));
        }
        var _hasPath = hasPath$2;
        var baseHasIn$1 = _baseHasIn,
          hasPath$1 = _hasPath;

        /**
         * Checks if `path` is a direct or inherited property of `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         * @example
         *
         * var object = _.create({ 'a': _.create({ 'b': 2 }) });
         *
         * _.hasIn(object, 'a');
         * // => true
         *
         * _.hasIn(object, 'a.b');
         * // => true
         *
         * _.hasIn(object, ['a', 'b']);
         * // => true
         *
         * _.hasIn(object, 'b');
         * // => false
         */
        function hasIn$3(object, path) {
          return object != null && hasPath$1(object, path, baseHasIn$1);
        }
        var hasIn_1 = hasIn$3;
        var baseIsEqual$1 = _baseIsEqual,
          get$5 = get_1,
          hasIn$2 = hasIn_1,
          isKey$2 = _isKey,
          isStrictComparable$1 = _isStrictComparable,
          matchesStrictComparable$1 = _matchesStrictComparable,
          toKey$4 = _toKey;

        /** Used to compose bitmasks for value comparisons. */
        var COMPARE_PARTIAL_FLAG$6 = 1,
          COMPARE_UNORDERED_FLAG$4 = 2;

        /**
         * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
         *
         * @private
         * @param {string} path The path of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         */
        function baseMatchesProperty$2(path, srcValue) {
          if (isKey$2(path) && isStrictComparable$1(srcValue)) {
            return matchesStrictComparable$1(toKey$4(path), srcValue);
          }
          return function (object) {
            var objValue = get$5(object, path);
            return objValue === undefined && objValue === srcValue ? hasIn$2(object, path) : baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG$6 | COMPARE_UNORDERED_FLAG$4);
          };
        }
        var _baseMatchesProperty = baseMatchesProperty$2;

        /**
         * The base implementation of `_.property` without support for deep paths.
         *
         * @private
         * @param {string} key The key of the property to get.
         * @returns {Function} Returns the new accessor function.
         */

        function baseProperty$2(key) {
          return function (object) {
            return object == null ? undefined : object[key];
          };
        }
        var _baseProperty = baseProperty$2;
        var baseGet$3 = _baseGet;

        /**
         * A specialized version of `baseProperty` which supports deep paths.
         *
         * @private
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new accessor function.
         */
        function basePropertyDeep$2(path) {
          return function (object) {
            return baseGet$3(object, path);
          };
        }
        var _basePropertyDeep = basePropertyDeep$2;
        var baseProperty$1 = _baseProperty,
          basePropertyDeep$1 = _basePropertyDeep,
          isKey$1 = _isKey,
          toKey$3 = _toKey;

        /**
         * Creates a function that returns the value at `path` of a given object.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Util
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new accessor function.
         * @example
         *
         * var objects = [
         *   { 'a': { 'b': 2 } },
         *   { 'a': { 'b': 1 } }
         * ];
         *
         * _.map(objects, _.property('a.b'));
         * // => [2, 1]
         *
         * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
         * // => [1, 2]
         */
        function property$2(path) {
          return isKey$1(path) ? baseProperty$1(toKey$3(path)) : basePropertyDeep$1(path);
        }
        var property_1 = property$2;
        var baseMatches$1 = _baseMatches,
          baseMatchesProperty$1 = _baseMatchesProperty,
          identity$3 = identity_1,
          isArray$7 = isArray_1,
          property$1 = property_1;

        /**
         * The base implementation of `_.iteratee`.
         *
         * @private
         * @param {*} [value=_.identity] The value to convert to an iteratee.
         * @returns {Function} Returns the iteratee.
         */
        function baseIteratee$4(value) {
          // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
          // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
          if (typeof value == 'function') {
            return value;
          }
          if (value == null) {
            return identity$3;
          }
          if (typeof value == 'object') {
            return isArray$7(value) ? baseMatchesProperty$1(value[0], value[1]) : baseMatches$1(value);
          }
          return property$1(value);
        }
        var _baseIteratee = baseIteratee$4;
        var isArrayLike$5 = isArrayLike_1;

        /**
         * Creates a `baseEach` or `baseEachRight` function.
         *
         * @private
         * @param {Function} eachFunc The function to iterate over a collection.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseEach$2(eachFunc, fromRight) {
          return function (collection, iteratee) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike$5(collection)) {
              return eachFunc(collection, iteratee);
            }
            var length = collection.length,
              index = fromRight ? length : -1,
              iterable = Object(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        var _createBaseEach = createBaseEach$2;
        var baseForOwn$2 = _baseForOwn,
          createBaseEach$1 = _createBaseEach;

        /**
         * The base implementation of `_.forEach` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         */
        var baseEach$3 = createBaseEach$1(baseForOwn$2);
        var _baseEach = baseEach$3;
        var baseEach$2 = _baseEach,
          isArrayLike$4 = isArrayLike_1;

        /**
         * The base implementation of `_.map` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function baseMap$2(collection, iteratee) {
          var index = -1,
            result = isArrayLike$4(collection) ? Array(collection.length) : [];
          baseEach$2(collection, function (value, key, collection) {
            result[++index] = iteratee(value, key, collection);
          });
          return result;
        }
        var _baseMap = baseMap$2;
        var arrayMap$3 = _arrayMap,
          baseIteratee$3 = _baseIteratee,
          baseMap$1 = _baseMap,
          isArray$6 = isArray_1;

        /**
         * Creates an array of values by running each element in `collection` thru
         * `iteratee`. The iteratee is invoked with three arguments:
         * (value, index|key, collection).
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
         *
         * The guarded methods are:
         * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
         * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
         * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
         * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * _.map([4, 8], square);
         * // => [16, 64]
         *
         * _.map({ 'a': 4, 'b': 8 }, square);
         * // => [16, 64] (iteration order is not guaranteed)
         *
         * var users = [
         *   { 'user': 'barney' },
         *   { 'user': 'fred' }
         * ];
         *
         * // The `_.property` iteratee shorthand.
         * _.map(users, 'user');
         * // => ['barney', 'fred']
         */
        function map$2(collection, iteratee) {
          var func = isArray$6(collection) ? arrayMap$3 : baseMap$1;
          return func(collection, baseIteratee$3(iteratee));
        }
        var map_1 = map$2;
        Object.defineProperty(flattenNames$1, "__esModule", {
          value: true
        });
        flattenNames$1.flattenNames = undefined;
        var _isString2 = isString_1;
        var _isString3 = _interopRequireDefault$f(_isString2);
        var _forOwn2$2 = forOwn_1;
        var _forOwn3$2 = _interopRequireDefault$f(_forOwn2$2);
        var _isPlainObject2 = isPlainObject_1;
        var _isPlainObject3 = _interopRequireDefault$f(_isPlainObject2);
        var _map2 = map_1;
        var _map3 = _interopRequireDefault$f(_map2);
        function _interopRequireDefault$f(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        var flattenNames = flattenNames$1.flattenNames = function flattenNames() {
          var things = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          var names = [];
          (0, _map3.default)(things, function (thing) {
            if (Array.isArray(thing)) {
              flattenNames(thing).map(function (name) {
                return names.push(name);
              });
            } else if ((0, _isPlainObject3.default)(thing)) {
              (0, _forOwn3$2.default)(thing, function (value, key) {
                value === true && names.push(key);
                names.push(key + '-' + value);
              });
            } else if ((0, _isString3.default)(thing)) {
              names.push(thing);
            }
          });
          return names;
        };
        flattenNames$1.default = flattenNames;
        var mergeClasses$1 = {};

        /**
         * A specialized version of `_.forEach` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns `array`.
         */

        function arrayEach$2(array, iteratee) {
          var index = -1,
            length = array == null ? 0 : array.length;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        var _arrayEach = arrayEach$2;
        var getNative$1 = _getNative;
        var defineProperty$4 = function () {
          try {
            var func = getNative$1(Object, 'defineProperty');
            func({}, '', {});
            return func;
          } catch (e) {}
        }();
        var _defineProperty$2 = defineProperty$4;
        var defineProperty$3 = _defineProperty$2;

        /**
         * The base implementation of `assignValue` and `assignMergeValue` without
         * value checks.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function baseAssignValue$5(object, key, value) {
          if (key == '__proto__' && defineProperty$3) {
            defineProperty$3(object, key, {
              'configurable': true,
              'enumerable': true,
              'value': value,
              'writable': true
            });
          } else {
            object[key] = value;
          }
        }
        var _baseAssignValue = baseAssignValue$5;
        var baseAssignValue$4 = _baseAssignValue,
          eq$3 = eq_1;

        /** Used for built-in method references. */
        var objectProto$h = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$e = objectProto$h.hasOwnProperty;

        /**
         * Assigns `value` to `key` of `object` if the existing value is not equivalent
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function assignValue$4(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty$e.call(object, key) && eq$3(objValue, value)) || value === undefined && !(key in object)) {
            baseAssignValue$4(object, key, value);
          }
        }
        var _assignValue = assignValue$4;
        var assignValue$3 = _assignValue,
          baseAssignValue$3 = _baseAssignValue;

        /**
         * Copies properties of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy properties from.
         * @param {Array} props The property identifiers to copy.
         * @param {Object} [object={}] The object to copy properties to.
         * @param {Function} [customizer] The function to customize copied values.
         * @returns {Object} Returns `object`.
         */
        function copyObject$7(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1,
            length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
            if (newValue === undefined) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue$3(object, key, newValue);
            } else {
              assignValue$3(object, key, newValue);
            }
          }
          return object;
        }
        var _copyObject = copyObject$7;
        var copyObject$6 = _copyObject,
          keys$3 = keys_1;

        /**
         * The base implementation of `_.assign` without support for multiple sources
         * or `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @returns {Object} Returns `object`.
         */
        function baseAssign$1(object, source) {
          return object && copyObject$6(source, keys$3(source), object);
        }
        var _baseAssign = baseAssign$1;

        /**
         * This function is like
         * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
         * except that it includes inherited enumerable properties.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */

        function nativeKeysIn$2(object) {
          var result = [];
          if (object != null) {
            for (var key in Object(object)) {
              result.push(key);
            }
          }
          return result;
        }
        var _nativeKeysIn = nativeKeysIn$2;
        var isObject$d = isObject_1,
          isPrototype$2 = _isPrototype,
          nativeKeysIn$1 = _nativeKeysIn;

        /** Used for built-in method references. */
        var objectProto$g = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$d = objectProto$g.hasOwnProperty;

        /**
         * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function baseKeysIn$2(object) {
          if (!isObject$d(object)) {
            return nativeKeysIn$1(object);
          }
          var isProto = isPrototype$2(object),
            result = [];
          for (var key in object) {
            if (!(key == 'constructor' && (isProto || !hasOwnProperty$d.call(object, key)))) {
              result.push(key);
            }
          }
          return result;
        }
        var _baseKeysIn = baseKeysIn$2;
        var arrayLikeKeys$1 = _arrayLikeKeys,
          baseKeysIn$1 = _baseKeysIn,
          isArrayLike$3 = isArrayLike_1;

        /**
         * Creates an array of the own and inherited enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keysIn(new Foo);
         * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
         */
        function keysIn$6(object) {
          return isArrayLike$3(object) ? arrayLikeKeys$1(object, true) : baseKeysIn$1(object);
        }
        var keysIn_1 = keysIn$6;
        var copyObject$5 = _copyObject,
          keysIn$5 = keysIn_1;

        /**
         * The base implementation of `_.assignIn` without support for multiple sources
         * or `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @returns {Object} Returns `object`.
         */
        function baseAssignIn$1(object, source) {
          return object && copyObject$5(source, keysIn$5(source), object);
        }
        var _baseAssignIn = baseAssignIn$1;
        var _cloneBuffer = {
          exports: {}
        };
        _cloneBuffer.exports;
        (function (module, exports) {
          var root = _root;

          /** Detect free variable `exports`. */
          var freeExports = exports && !exports.nodeType && exports;

          /** Detect free variable `module`. */
          var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

          /** Detect the popular CommonJS extension `module.exports`. */
          var moduleExports = freeModule && freeModule.exports === freeExports;

          /** Built-in value references. */
          var Buffer = moduleExports ? root.Buffer : undefined,
            allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

          /**
           * Creates a clone of  `buffer`.
           *
           * @private
           * @param {Buffer} buffer The buffer to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Buffer} Returns the cloned buffer.
           */
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }
            var length = buffer.length,
              result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            buffer.copy(result);
            return result;
          }
          module.exports = cloneBuffer;
        })(_cloneBuffer, _cloneBuffer.exports);
        var _cloneBufferExports = _cloneBuffer.exports;

        /**
         * Copies the values of `source` to `array`.
         *
         * @private
         * @param {Array} source The array to copy values from.
         * @param {Array} [array=[]] The array to copy values to.
         * @returns {Array} Returns `array`.
         */

        function copyArray$3(source, array) {
          var index = -1,
            length = source.length;
          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        var _copyArray = copyArray$3;
        var copyObject$4 = _copyObject,
          getSymbols$3 = _getSymbols;

        /**
         * Copies own symbols of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy symbols from.
         * @param {Object} [object={}] The object to copy symbols to.
         * @returns {Object} Returns `object`.
         */
        function copySymbols$1(source, object) {
          return copyObject$4(source, getSymbols$3(source), object);
        }
        var _copySymbols = copySymbols$1;
        var arrayPush$2 = _arrayPush,
          getPrototype$3 = _getPrototype,
          getSymbols$2 = _getSymbols,
          stubArray$1 = stubArray_1;

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

        /**
         * Creates an array of the own and inherited enumerable symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of symbols.
         */
        var getSymbolsIn$2 = !nativeGetSymbols$1 ? stubArray$1 : function (object) {
          var result = [];
          while (object) {
            arrayPush$2(result, getSymbols$2(object));
            object = getPrototype$3(object);
          }
          return result;
        };
        var _getSymbolsIn = getSymbolsIn$2;
        var copyObject$3 = _copyObject,
          getSymbolsIn$1 = _getSymbolsIn;

        /**
         * Copies own and inherited symbols of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy symbols from.
         * @param {Object} [object={}] The object to copy symbols to.
         * @returns {Object} Returns `object`.
         */
        function copySymbolsIn$1(source, object) {
          return copyObject$3(source, getSymbolsIn$1(source), object);
        }
        var _copySymbolsIn = copySymbolsIn$1;
        var baseGetAllKeys$1 = _baseGetAllKeys,
          getSymbolsIn = _getSymbolsIn,
          keysIn$4 = keysIn_1;

        /**
         * Creates an array of own and inherited enumerable property names and
         * symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function getAllKeysIn$3(object) {
          return baseGetAllKeys$1(object, keysIn$4, getSymbolsIn);
        }
        var _getAllKeysIn = getAllKeysIn$3;

        /** Used for built-in method references. */

        var objectProto$f = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$c = objectProto$f.hasOwnProperty;

        /**
         * Initializes an array clone.
         *
         * @private
         * @param {Array} array The array to clone.
         * @returns {Array} Returns the initialized clone.
         */
        function initCloneArray$1(array) {
          var length = array.length,
            result = new array.constructor(length);

          // Add properties assigned by `RegExp#exec`.
          if (length && typeof array[0] == 'string' && hasOwnProperty$c.call(array, 'index')) {
            result.index = array.index;
            result.input = array.input;
          }
          return result;
        }
        var _initCloneArray = initCloneArray$1;
        var Uint8Array$2 = _Uint8Array;

        /**
         * Creates a clone of `arrayBuffer`.
         *
         * @private
         * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
         * @returns {ArrayBuffer} Returns the cloned array buffer.
         */
        function cloneArrayBuffer$4(arrayBuffer) {
          var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
          return result;
        }
        var _cloneArrayBuffer = cloneArrayBuffer$4;
        var cloneArrayBuffer$3 = _cloneArrayBuffer;

        /**
         * Creates a clone of `dataView`.
         *
         * @private
         * @param {Object} dataView The data view to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the cloned data view.
         */
        function cloneDataView$1(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer$3(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        var _cloneDataView = cloneDataView$1;

        /** Used to match `RegExp` flags from their coerced string values. */

        var reFlags = /\w*$/;

        /**
         * Creates a clone of `regexp`.
         *
         * @private
         * @param {Object} regexp The regexp to clone.
         * @returns {Object} Returns the cloned regexp.
         */
        function cloneRegExp$1(regexp) {
          var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result.lastIndex = regexp.lastIndex;
          return result;
        }
        var _cloneRegExp = cloneRegExp$1;
        var Symbol$4 = _Symbol;

        /** Used to convert symbols to primitives and strings. */
        var symbolProto$2 = Symbol$4 ? Symbol$4.prototype : undefined,
          symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : undefined;

        /**
         * Creates a clone of the `symbol` object.
         *
         * @private
         * @param {Object} symbol The symbol object to clone.
         * @returns {Object} Returns the cloned symbol object.
         */
        function cloneSymbol$1(symbol) {
          return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
        }
        var _cloneSymbol = cloneSymbol$1;
        var cloneArrayBuffer$2 = _cloneArrayBuffer;

        /**
         * Creates a clone of `typedArray`.
         *
         * @private
         * @param {Object} typedArray The typed array to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the cloned typed array.
         */
        function cloneTypedArray$3(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer$2(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        var _cloneTypedArray = cloneTypedArray$3;
        var cloneArrayBuffer$1 = _cloneArrayBuffer,
          cloneDataView = _cloneDataView,
          cloneRegExp = _cloneRegExp,
          cloneSymbol = _cloneSymbol,
          cloneTypedArray$2 = _cloneTypedArray;

        /** `Object#toString` result references. */
        var boolTag$3 = '[object Boolean]',
          dateTag$3 = '[object Date]',
          mapTag$5 = '[object Map]',
          numberTag$3 = '[object Number]',
          regexpTag$3 = '[object RegExp]',
          setTag$5 = '[object Set]',
          stringTag$3 = '[object String]',
          symbolTag$3 = '[object Symbol]';
        var arrayBufferTag$3 = '[object ArrayBuffer]',
          dataViewTag$4 = '[object DataView]',
          float32Tag$2 = '[object Float32Array]',
          float64Tag$2 = '[object Float64Array]',
          int8Tag$2 = '[object Int8Array]',
          int16Tag$2 = '[object Int16Array]',
          int32Tag$2 = '[object Int32Array]',
          uint8Tag$2 = '[object Uint8Array]',
          uint8ClampedTag$2 = '[object Uint8ClampedArray]',
          uint16Tag$2 = '[object Uint16Array]',
          uint32Tag$2 = '[object Uint32Array]';

        /**
         * Initializes an object clone based on its `toStringTag`.
         *
         * **Note:** This function only supports cloning values with tags of
         * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
         *
         * @private
         * @param {Object} object The object to clone.
         * @param {string} tag The `toStringTag` of the object to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneByTag$1(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag$3:
              return cloneArrayBuffer$1(object);
            case boolTag$3:
            case dateTag$3:
              return new Ctor(+object);
            case dataViewTag$4:
              return cloneDataView(object, isDeep);
            case float32Tag$2:
            case float64Tag$2:
            case int8Tag$2:
            case int16Tag$2:
            case int32Tag$2:
            case uint8Tag$2:
            case uint8ClampedTag$2:
            case uint16Tag$2:
            case uint32Tag$2:
              return cloneTypedArray$2(object, isDeep);
            case mapTag$5:
              return new Ctor();
            case numberTag$3:
            case stringTag$3:
              return new Ctor(object);
            case regexpTag$3:
              return cloneRegExp(object);
            case setTag$5:
              return new Ctor();
            case symbolTag$3:
              return cloneSymbol(object);
          }
        }
        var _initCloneByTag = initCloneByTag$1;
        var isObject$c = isObject_1;

        /** Built-in value references. */
        var objectCreate$1 = Object.create;

        /**
         * The base implementation of `_.create` without support for assigning
         * properties to the created object.
         *
         * @private
         * @param {Object} proto The object to inherit from.
         * @returns {Object} Returns the new object.
         */
        var baseCreate$3 = function () {
          function object() {}
          return function (proto) {
            if (!isObject$c(proto)) {
              return {};
            }
            if (objectCreate$1) {
              return objectCreate$1(proto);
            }
            object.prototype = proto;
            var result = new object();
            object.prototype = undefined;
            return result;
          };
        }();
        var _baseCreate = baseCreate$3;
        var baseCreate$2 = _baseCreate,
          getPrototype$2 = _getPrototype,
          isPrototype$1 = _isPrototype;

        /**
         * Initializes an object clone.
         *
         * @private
         * @param {Object} object The object to clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneObject$3(object) {
          return typeof object.constructor == 'function' && !isPrototype$1(object) ? baseCreate$2(getPrototype$2(object)) : {};
        }
        var _initCloneObject = initCloneObject$3;
        var getTag$4 = _getTag,
          isObjectLike$3 = isObjectLike_1;

        /** `Object#toString` result references. */
        var mapTag$4 = '[object Map]';

        /**
         * The base implementation of `_.isMap` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a map, else `false`.
         */
        function baseIsMap$1(value) {
          return isObjectLike$3(value) && getTag$4(value) == mapTag$4;
        }
        var _baseIsMap = baseIsMap$1;
        var baseIsMap = _baseIsMap,
          baseUnary$2 = _baseUnary,
          nodeUtil$3 = _nodeUtilExports;

        /* Node.js helper references. */
        var nodeIsMap = nodeUtil$3 && nodeUtil$3.isMap;

        /**
         * Checks if `value` is classified as a `Map` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a map, else `false`.
         * @example
         *
         * _.isMap(new Map);
         * // => true
         *
         * _.isMap(new WeakMap);
         * // => false
         */
        var isMap$1 = nodeIsMap ? baseUnary$2(nodeIsMap) : baseIsMap;
        var isMap_1 = isMap$1;
        var getTag$3 = _getTag,
          isObjectLike$2 = isObjectLike_1;

        /** `Object#toString` result references. */
        var setTag$4 = '[object Set]';

        /**
         * The base implementation of `_.isSet` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a set, else `false`.
         */
        function baseIsSet$1(value) {
          return isObjectLike$2(value) && getTag$3(value) == setTag$4;
        }
        var _baseIsSet = baseIsSet$1;
        var baseIsSet = _baseIsSet,
          baseUnary$1 = _baseUnary,
          nodeUtil$2 = _nodeUtilExports;

        /* Node.js helper references. */
        var nodeIsSet = nodeUtil$2 && nodeUtil$2.isSet;

        /**
         * Checks if `value` is classified as a `Set` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a set, else `false`.
         * @example
         *
         * _.isSet(new Set);
         * // => true
         *
         * _.isSet(new WeakSet);
         * // => false
         */
        var isSet$1 = nodeIsSet ? baseUnary$1(nodeIsSet) : baseIsSet;
        var isSet_1 = isSet$1;
        var Stack$2 = _Stack,
          arrayEach$1 = _arrayEach,
          assignValue$2 = _assignValue,
          baseAssign = _baseAssign,
          baseAssignIn = _baseAssignIn,
          cloneBuffer$2 = _cloneBufferExports,
          copyArray$2 = _copyArray,
          copySymbols = _copySymbols,
          copySymbolsIn = _copySymbolsIn,
          getAllKeys$1 = _getAllKeys,
          getAllKeysIn$2 = _getAllKeysIn,
          getTag$2 = _getTag,
          initCloneArray = _initCloneArray,
          initCloneByTag = _initCloneByTag,
          initCloneObject$2 = _initCloneObject,
          isArray$5 = isArray_1,
          isBuffer$3 = isBufferExports,
          isMap = isMap_1,
          isObject$b = isObject_1,
          isSet = isSet_1,
          keys$2 = keys_1,
          keysIn$3 = keysIn_1;

        /** Used to compose bitmasks for cloning. */
        var CLONE_DEEP_FLAG$2 = 1,
          CLONE_FLAT_FLAG$1 = 2,
          CLONE_SYMBOLS_FLAG$2 = 4;

        /** `Object#toString` result references. */
        var argsTag$3 = '[object Arguments]',
          arrayTag$2 = '[object Array]',
          boolTag$2 = '[object Boolean]',
          dateTag$2 = '[object Date]',
          errorTag$2 = '[object Error]',
          funcTag$2 = '[object Function]',
          genTag$1 = '[object GeneratorFunction]',
          mapTag$3 = '[object Map]',
          numberTag$2 = '[object Number]',
          objectTag$4 = '[object Object]',
          regexpTag$2 = '[object RegExp]',
          setTag$3 = '[object Set]',
          stringTag$2 = '[object String]',
          symbolTag$2 = '[object Symbol]',
          weakMapTag$2 = '[object WeakMap]';
        var arrayBufferTag$2 = '[object ArrayBuffer]',
          dataViewTag$3 = '[object DataView]',
          float32Tag$1 = '[object Float32Array]',
          float64Tag$1 = '[object Float64Array]',
          int8Tag$1 = '[object Int8Array]',
          int16Tag$1 = '[object Int16Array]',
          int32Tag$1 = '[object Int32Array]',
          uint8Tag$1 = '[object Uint8Array]',
          uint8ClampedTag$1 = '[object Uint8ClampedArray]',
          uint16Tag$1 = '[object Uint16Array]',
          uint32Tag$1 = '[object Uint32Array]';

        /** Used to identify `toStringTag` values supported by `_.clone`. */
        var cloneableTags = {};
        cloneableTags[argsTag$3] = cloneableTags[arrayTag$2] = cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$3] = cloneableTags[boolTag$2] = cloneableTags[dateTag$2] = cloneableTags[float32Tag$1] = cloneableTags[float64Tag$1] = cloneableTags[int8Tag$1] = cloneableTags[int16Tag$1] = cloneableTags[int32Tag$1] = cloneableTags[mapTag$3] = cloneableTags[numberTag$2] = cloneableTags[objectTag$4] = cloneableTags[regexpTag$2] = cloneableTags[setTag$3] = cloneableTags[stringTag$2] = cloneableTags[symbolTag$2] = cloneableTags[uint8Tag$1] = cloneableTags[uint8ClampedTag$1] = cloneableTags[uint16Tag$1] = cloneableTags[uint32Tag$1] = true;
        cloneableTags[errorTag$2] = cloneableTags[funcTag$2] = cloneableTags[weakMapTag$2] = false;

        /**
         * The base implementation of `_.clone` and `_.cloneDeep` which tracks
         * traversed objects.
         *
         * @private
         * @param {*} value The value to clone.
         * @param {boolean} bitmask The bitmask flags.
         *  1 - Deep clone
         *  2 - Flatten inherited properties
         *  4 - Clone symbols
         * @param {Function} [customizer] The function to customize cloning.
         * @param {string} [key] The key of `value`.
         * @param {Object} [object] The parent object of `value`.
         * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
         * @returns {*} Returns the cloned value.
         */
        function baseClone$2(value, bitmask, customizer, key, object, stack) {
          var result,
            isDeep = bitmask & CLONE_DEEP_FLAG$2,
            isFlat = bitmask & CLONE_FLAT_FLAG$1,
            isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
          if (customizer) {
            result = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result !== undefined) {
            return result;
          }
          if (!isObject$b(value)) {
            return value;
          }
          var isArr = isArray$5(value);
          if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
              return copyArray$2(value, result);
            }
          } else {
            var tag = getTag$2(value),
              isFunc = tag == funcTag$2 || tag == genTag$1;
            if (isBuffer$3(value)) {
              return cloneBuffer$2(value, isDeep);
            }
            if (tag == objectTag$4 || tag == argsTag$3 || isFunc && !object) {
              result = isFlat || isFunc ? {} : initCloneObject$2(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result = initCloneByTag(value, tag, isDeep);
            }
          }
          // Check for circular references and return its corresponding clone.
          stack || (stack = new Stack$2());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result);
          if (isSet(value)) {
            value.forEach(function (subValue) {
              result.add(baseClone$2(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function (subValue, key) {
              result.set(key, baseClone$2(subValue, bitmask, customizer, key, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn$2 : getAllKeys$1 : isFlat ? keysIn$3 : keys$2;
          var props = isArr ? undefined : keysFunc(value);
          arrayEach$1(props || value, function (subValue, key) {
            if (props) {
              key = subValue;
              subValue = value[key];
            }
            // Recursively populate clone (susceptible to call stack limits).
            assignValue$2(result, key, baseClone$2(subValue, bitmask, customizer, key, value, stack));
          });
          return result;
        }
        var _baseClone = baseClone$2;
        var baseClone$1 = _baseClone;

        /** Used to compose bitmasks for cloning. */
        var CLONE_DEEP_FLAG$1 = 1,
          CLONE_SYMBOLS_FLAG$1 = 4;

        /**
         * This method is like `_.clone` except that it recursively clones `value`.
         *
         * @static
         * @memberOf _
         * @since 1.0.0
         * @category Lang
         * @param {*} value The value to recursively clone.
         * @returns {*} Returns the deep cloned value.
         * @see _.clone
         * @example
         *
         * var objects = [{ 'a': 1 }, { 'b': 2 }];
         *
         * var deep = _.cloneDeep(objects);
         * console.log(deep[0] === objects[0]);
         * // => false
         */
        function cloneDeep(value) {
          return baseClone$1(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
        }
        var cloneDeep_1 = cloneDeep;
        Object.defineProperty(mergeClasses$1, "__esModule", {
          value: true
        });
        mergeClasses$1.mergeClasses = undefined;
        var _forOwn2$1 = forOwn_1;
        var _forOwn3$1 = _interopRequireDefault$e(_forOwn2$1);
        var _cloneDeep2 = cloneDeep_1;
        var _cloneDeep3 = _interopRequireDefault$e(_cloneDeep2);
        var _extends$f = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        function _interopRequireDefault$e(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        var mergeClasses = mergeClasses$1.mergeClasses = function mergeClasses(classes) {
          var activeNames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
          var styles = classes.default && (0, _cloneDeep3.default)(classes.default) || {};
          activeNames.map(function (name) {
            var toMerge = classes[name];
            if (toMerge) {
              (0, _forOwn3$1.default)(toMerge, function (value, key) {
                if (!styles[key]) {
                  styles[key] = {};
                }
                styles[key] = _extends$f({}, styles[key], toMerge[key]);
              });
            }
            return name;
          });
          return styles;
        };
        mergeClasses$1.default = mergeClasses;
        var autoprefix$1 = {};
        Object.defineProperty(autoprefix$1, "__esModule", {
          value: true
        });
        autoprefix$1.autoprefix = undefined;
        var _forOwn2 = forOwn_1;
        var _forOwn3 = _interopRequireDefault$d(_forOwn2);
        var _extends$e = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        function _interopRequireDefault$d(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        var transforms = {
          borderRadius: function borderRadius(value) {
            return {
              msBorderRadius: value,
              MozBorderRadius: value,
              OBorderRadius: value,
              WebkitBorderRadius: value,
              borderRadius: value
            };
          },
          boxShadow: function boxShadow(value) {
            return {
              msBoxShadow: value,
              MozBoxShadow: value,
              OBoxShadow: value,
              WebkitBoxShadow: value,
              boxShadow: value
            };
          },
          userSelect: function userSelect(value) {
            return {
              WebkitTouchCallout: value,
              KhtmlUserSelect: value,
              MozUserSelect: value,
              msUserSelect: value,
              WebkitUserSelect: value,
              userSelect: value
            };
          },
          flex: function flex(value) {
            return {
              WebkitBoxFlex: value,
              MozBoxFlex: value,
              WebkitFlex: value,
              msFlex: value,
              flex: value
            };
          },
          flexBasis: function flexBasis(value) {
            return {
              WebkitFlexBasis: value,
              flexBasis: value
            };
          },
          justifyContent: function justifyContent(value) {
            return {
              WebkitJustifyContent: value,
              justifyContent: value
            };
          },
          transition: function transition(value) {
            return {
              msTransition: value,
              MozTransition: value,
              OTransition: value,
              WebkitTransition: value,
              transition: value
            };
          },
          transform: function transform(value) {
            return {
              msTransform: value,
              MozTransform: value,
              OTransform: value,
              WebkitTransform: value,
              transform: value
            };
          },
          absolute: function absolute(value) {
            var direction = value && value.split(' ');
            return {
              position: 'absolute',
              top: direction && direction[0],
              right: direction && direction[1],
              bottom: direction && direction[2],
              left: direction && direction[3]
            };
          },
          extend: function extend(name, otherElementStyles) {
            var otherStyle = otherElementStyles[name];
            if (otherStyle) {
              return otherStyle;
            }
            return {
              'extend': name
            };
          }
        };
        var autoprefix = autoprefix$1.autoprefix = function autoprefix(elements) {
          var prefixed = {};
          (0, _forOwn3.default)(elements, function (styles, element) {
            var expanded = {};
            (0, _forOwn3.default)(styles, function (value, key) {
              var transform = transforms[key];
              if (transform) {
                expanded = _extends$e({}, expanded, transform(value));
              } else {
                expanded[key] = value;
              }
            });
            prefixed[element] = expanded;
          });
          return prefixed;
        };
        autoprefix$1.default = autoprefix;
        var hover$1 = {};
        Object.defineProperty(hover$1, "__esModule", {
          value: true
        });
        hover$1.hover = undefined;
        var _extends$d = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        var _react$3 = reactExports;
        var _react2$3 = _interopRequireDefault$c(_react$3);
        function _interopRequireDefault$c(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        function _classCallCheck$9(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn$9(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self;
        }
        function _inherits$9(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var hover = hover$1.hover = function hover(Component) {
          var Span = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'span';
          return function (_React$Component) {
            _inherits$9(Hover, _React$Component);
            function Hover() {
              var _ref;
              var _temp, _this, _ret;
              _classCallCheck$9(this, Hover);
              for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return _ret = (_temp = (_this = _possibleConstructorReturn$9(this, (_ref = Hover.__proto__ || Object.getPrototypeOf(Hover)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
                hover: false
              }, _this.handleMouseOver = function () {
                return _this.setState({
                  hover: true
                });
              }, _this.handleMouseOut = function () {
                return _this.setState({
                  hover: false
                });
              }, _this.render = function () {
                return _react2$3.default.createElement(Span, {
                  onMouseOver: _this.handleMouseOver,
                  onMouseOut: _this.handleMouseOut
                }, _react2$3.default.createElement(Component, _extends$d({}, _this.props, _this.state)));
              }, _temp), _possibleConstructorReturn$9(_this, _ret);
            }
            return Hover;
          }(_react2$3.default.Component);
        };
        hover$1.default = hover;
        var active$1 = {};
        Object.defineProperty(active$1, "__esModule", {
          value: true
        });
        active$1.active = undefined;
        var _extends$c = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        var _react$2 = reactExports;
        var _react2$2 = _interopRequireDefault$b(_react$2);
        function _interopRequireDefault$b(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        function _classCallCheck$8(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn$8(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self;
        }
        function _inherits$8(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var active = active$1.active = function active(Component) {
          var Span = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'span';
          return function (_React$Component) {
            _inherits$8(Active, _React$Component);
            function Active() {
              var _ref;
              var _temp, _this, _ret;
              _classCallCheck$8(this, Active);
              for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return _ret = (_temp = (_this = _possibleConstructorReturn$8(this, (_ref = Active.__proto__ || Object.getPrototypeOf(Active)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
                active: false
              }, _this.handleMouseDown = function () {
                return _this.setState({
                  active: true
                });
              }, _this.handleMouseUp = function () {
                return _this.setState({
                  active: false
                });
              }, _this.render = function () {
                return _react2$2.default.createElement(Span, {
                  onMouseDown: _this.handleMouseDown,
                  onMouseUp: _this.handleMouseUp
                }, _react2$2.default.createElement(Component, _extends$c({}, _this.props, _this.state)));
              }, _temp), _possibleConstructorReturn$8(_this, _ret);
            }
            return Active;
          }(_react2$2.default.Component);
        };
        active$1.default = active;
        var loop = {};
        Object.defineProperty(loop, "__esModule", {
          value: true
        });
        var loopable = function loopable(i, length) {
          var props = {};
          var setProp = function setProp(name) {
            var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            props[name] = value;
          };
          i === 0 && setProp('first-child');
          i === length - 1 && setProp('last-child');
          (i === 0 || i % 2 === 0) && setProp('even');
          Math.abs(i % 2) === 1 && setProp('odd');
          setProp('nth-child', i);
          return props;
        };
        loop.default = loopable;
        Object.defineProperty(lib, "__esModule", {
          value: true
        });
        lib.ReactCSS = lib.loop = lib.handleActive = handleHover = lib.handleHover = lib.hover = undefined;
        var _flattenNames = flattenNames$1;
        var _flattenNames2 = _interopRequireDefault$a(_flattenNames);
        var _mergeClasses = mergeClasses$1;
        var _mergeClasses2 = _interopRequireDefault$a(_mergeClasses);
        var _autoprefix = autoprefix$1;
        var _autoprefix2 = _interopRequireDefault$a(_autoprefix);
        var _hover2 = hover$1;
        var _hover3 = _interopRequireDefault$a(_hover2);
        var _active = active$1;
        var _active2 = _interopRequireDefault$a(_active);
        var _loop2 = loop;
        var _loop3 = _interopRequireDefault$a(_loop2);
        function _interopRequireDefault$a(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        lib.hover = _hover3.default;
        var handleHover = lib.handleHover = _hover3.default;
        lib.handleActive = _active2.default;
        lib.loop = _loop3.default;
        var ReactCSS = lib.ReactCSS = function ReactCSS(classes) {
          for (var _len = arguments.length, activations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            activations[_key - 1] = arguments[_key];
          }
          var activeNames = (0, _flattenNames2.default)(activations);
          var merged = (0, _mergeClasses2.default)(classes, activeNames);
          return (0, _autoprefix2.default)(merged);
        };
        var _default$a = lib.default = ReactCSS;
        var calculateChange$2 = function calculateChange(e, hsl, direction, initialA, container) {
          var containerWidth = container.clientWidth;
          var containerHeight = container.clientHeight;
          var x = typeof e.pageX === 'number' ? e.pageX : e.touches[0].pageX;
          var y = typeof e.pageY === 'number' ? e.pageY : e.touches[0].pageY;
          var left = x - (container.getBoundingClientRect().left + window.pageXOffset);
          var top = y - (container.getBoundingClientRect().top + window.pageYOffset);
          if (direction === 'vertical') {
            var a = void 0;
            if (top < 0) {
              a = 0;
            } else if (top > containerHeight) {
              a = 1;
            } else {
              a = Math.round(top * 100 / containerHeight) / 100;
            }
            if (hsl.a !== a) {
              return {
                h: hsl.h,
                s: hsl.s,
                l: hsl.l,
                a: a,
                source: 'rgb'
              };
            }
          } else {
            var _a = void 0;
            if (left < 0) {
              _a = 0;
            } else if (left > containerWidth) {
              _a = 1;
            } else {
              _a = Math.round(left * 100 / containerWidth) / 100;
            }
            if (initialA !== _a) {
              return {
                h: hsl.h,
                s: hsl.s,
                l: hsl.l,
                a: _a,
                source: 'rgb'
              };
            }
          }
          return null;
        };
        var checkboardCache = {};
        var render = function render(c1, c2, size, serverCanvas) {
          if (typeof document === 'undefined' && !serverCanvas) {
            return null;
          }
          var canvas = serverCanvas ? new serverCanvas() : document.createElement('canvas');
          canvas.width = size * 2;
          canvas.height = size * 2;
          var ctx = canvas.getContext('2d');
          if (!ctx) {
            return null;
          } // If no context can be found, return early.
          ctx.fillStyle = c1;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = c2;
          ctx.fillRect(0, 0, size, size);
          ctx.translate(size, size);
          ctx.fillRect(0, 0, size, size);
          return canvas.toDataURL();
        };
        var get$4 = function get(c1, c2, size, serverCanvas) {
          var key = c1 + '-' + c2 + '-' + size + (serverCanvas ? '-server' : '');
          if (checkboardCache[key]) {
            return checkboardCache[key];
          }
          var checkboard = render(c1, c2, size, serverCanvas);
          checkboardCache[key] = checkboard;
          return checkboard;
        };
        var _extends$b = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        var Checkboard = function Checkboard(_ref) {
          var white = _ref.white,
            grey = _ref.grey,
            size = _ref.size,
            renderers = _ref.renderers,
            borderRadius = _ref.borderRadius,
            boxShadow = _ref.boxShadow,
            children = _ref.children;
          var styles = _default$a({
            'default': {
              grid: {
                borderRadius: borderRadius,
                boxShadow: boxShadow,
                absolute: '0px 0px 0px 0px',
                background: 'url(' + get$4(white, grey, size, renderers.canvas) + ') center left'
              }
            }
          });
          return reactExports.isValidElement(children) ? React.cloneElement(children, _extends$b({}, children.props, {
            style: _extends$b({}, children.props.style, styles.grid)
          })) : React.createElement('div', {
            style: styles.grid
          });
        };
        Checkboard.defaultProps = {
          size: 8,
          white: 'transparent',
          grey: 'rgba(0,0,0,.08)',
          renderers: {}
        };
        var _extends$a = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        var _createClass$7 = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        function _classCallCheck$7(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn$7(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self;
        }
        function _inherits$7(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var Alpha = function (_ref) {
          _inherits$7(Alpha, _ref);
          function Alpha() {
            var _ref2;
            var _temp, _this, _ret;
            _classCallCheck$7(this, Alpha);
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return _ret = (_temp = (_this = _possibleConstructorReturn$7(this, (_ref2 = Alpha.__proto__ || Object.getPrototypeOf(Alpha)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function (e) {
              var change = calculateChange$2(e, _this.props.hsl, _this.props.direction, _this.props.a, _this.container);
              change && typeof _this.props.onChange === 'function' && _this.props.onChange(change, e);
            }, _this.handleMouseDown = function (e) {
              _this.handleChange(e);
              window.addEventListener('mousemove', _this.handleChange);
              window.addEventListener('mouseup', _this.handleMouseUp);
            }, _this.handleMouseUp = function () {
              _this.unbindEventListeners();
            }, _this.unbindEventListeners = function () {
              window.removeEventListener('mousemove', _this.handleChange);
              window.removeEventListener('mouseup', _this.handleMouseUp);
            }, _temp), _possibleConstructorReturn$7(_this, _ret);
          }
          _createClass$7(Alpha, [{
            key: 'componentWillUnmount',
            value: function componentWillUnmount() {
              this.unbindEventListeners();
            }
          }, {
            key: 'render',
            value: function render() {
              var _this2 = this;
              var rgb = this.props.rgb;
              var styles = _default$a({
                'default': {
                  alpha: {
                    absolute: '0px 0px 0px 0px',
                    borderRadius: this.props.radius
                  },
                  checkboard: {
                    absolute: '0px 0px 0px 0px',
                    overflow: 'hidden',
                    borderRadius: this.props.radius
                  },
                  gradient: {
                    absolute: '0px 0px 0px 0px',
                    background: 'linear-gradient(to right, rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ', 0) 0%,\n           rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ', 1) 100%)',
                    boxShadow: this.props.shadow,
                    borderRadius: this.props.radius
                  },
                  container: {
                    position: 'relative',
                    height: '100%',
                    margin: '0 3px'
                  },
                  pointer: {
                    position: 'absolute',
                    left: rgb.a * 100 + '%'
                  },
                  slider: {
                    width: '4px',
                    borderRadius: '1px',
                    height: '8px',
                    boxShadow: '0 0 2px rgba(0, 0, 0, .6)',
                    background: '#fff',
                    marginTop: '1px',
                    transform: 'translateX(-2px)'
                  }
                },
                'vertical': {
                  gradient: {
                    background: 'linear-gradient(to bottom, rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ', 0) 0%,\n           rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ', 1) 100%)'
                  },
                  pointer: {
                    left: 0,
                    top: rgb.a * 100 + '%'
                  }
                },
                'overwrite': _extends$a({}, this.props.style)
              }, {
                vertical: this.props.direction === 'vertical',
                overwrite: true
              });
              return React.createElement('div', {
                style: styles.alpha
              }, React.createElement('div', {
                style: styles.checkboard
              }, React.createElement(Checkboard, {
                renderers: this.props.renderers
              })), React.createElement('div', {
                style: styles.gradient
              }), React.createElement('div', {
                style: styles.container,
                ref: function ref(container) {
                  return _this2.container = container;
                },
                onMouseDown: this.handleMouseDown,
                onTouchMove: this.handleChange,
                onTouchStart: this.handleChange
              }, React.createElement('div', {
                style: styles.pointer
              }, this.props.pointer ? React.createElement(this.props.pointer, this.props) : React.createElement('div', {
                style: styles.slider
              }))));
            }
          }]);
          return Alpha;
        }(reactExports.PureComponent || reactExports.Component);
        var _createClass$6 = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        function _defineProperty$1(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function _classCallCheck$6(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn$6(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self;
        }
        function _inherits$6(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var DEFAULT_ARROW_OFFSET = 1;
        var UP_KEY_CODE = 38;
        var DOWN_KEY_CODE = 40;
        var VALID_KEY_CODES = [UP_KEY_CODE, DOWN_KEY_CODE];
        var isValidKeyCode = function isValidKeyCode(keyCode) {
          return VALID_KEY_CODES.indexOf(keyCode) > -1;
        };
        var getNumberValue = function getNumberValue(value) {
          return Number(String(value).replace(/%/g, ''));
        };
        var idCounter = 1;
        var EditableInput = function (_ref) {
          _inherits$6(EditableInput, _ref);
          function EditableInput(props) {
            _classCallCheck$6(this, EditableInput);
            var _this = _possibleConstructorReturn$6(this, (EditableInput.__proto__ || Object.getPrototypeOf(EditableInput)).call(this));
            _this.handleBlur = function () {
              if (_this.state.blurValue) {
                _this.setState({
                  value: _this.state.blurValue,
                  blurValue: null
                });
              }
            };
            _this.handleChange = function (e) {
              _this.setUpdatedValue(e.target.value, e);
            };
            _this.handleKeyDown = function (e) {
              // In case `e.target.value` is a percentage remove the `%` character
              // and update accordingly with a percentage
              // https://github.com/casesandberg/react-color/issues/383
              var value = getNumberValue(e.target.value);
              if (!isNaN(value) && isValidKeyCode(e.keyCode)) {
                var offset = _this.getArrowOffset();
                var updatedValue = e.keyCode === UP_KEY_CODE ? value + offset : value - offset;
                _this.setUpdatedValue(updatedValue, e);
              }
            };
            _this.handleDrag = function (e) {
              if (_this.props.dragLabel) {
                var newValue = Math.round(_this.props.value + e.movementX);
                if (newValue >= 0 && newValue <= _this.props.dragMax) {
                  _this.props.onChange && _this.props.onChange(_this.getValueObjectWithLabel(newValue), e);
                }
              }
            };
            _this.handleMouseDown = function (e) {
              if (_this.props.dragLabel) {
                e.preventDefault();
                _this.handleDrag(e);
                window.addEventListener('mousemove', _this.handleDrag);
                window.addEventListener('mouseup', _this.handleMouseUp);
              }
            };
            _this.handleMouseUp = function () {
              _this.unbindEventListeners();
            };
            _this.unbindEventListeners = function () {
              window.removeEventListener('mousemove', _this.handleDrag);
              window.removeEventListener('mouseup', _this.handleMouseUp);
            };
            _this.state = {
              value: String(props.value).toUpperCase(),
              blurValue: String(props.value).toUpperCase()
            };
            _this.inputId = 'rc-editable-input-' + idCounter++;
            return _this;
          }
          _createClass$6(EditableInput, [{
            key: 'componentDidUpdate',
            value: function componentDidUpdate(prevProps, prevState) {
              if (this.props.value !== this.state.value && (prevProps.value !== this.props.value || prevState.value !== this.state.value)) {
                if (this.input === document.activeElement) {
                  this.setState({
                    blurValue: String(this.props.value).toUpperCase()
                  });
                } else {
                  this.setState({
                    value: String(this.props.value).toUpperCase(),
                    blurValue: !this.state.blurValue && String(this.props.value).toUpperCase()
                  });
                }
              }
            }
          }, {
            key: 'componentWillUnmount',
            value: function componentWillUnmount() {
              this.unbindEventListeners();
            }
          }, {
            key: 'getValueObjectWithLabel',
            value: function getValueObjectWithLabel(value) {
              return _defineProperty$1({}, this.props.label, value);
            }
          }, {
            key: 'getArrowOffset',
            value: function getArrowOffset() {
              return this.props.arrowOffset || DEFAULT_ARROW_OFFSET;
            }
          }, {
            key: 'setUpdatedValue',
            value: function setUpdatedValue(value, e) {
              var onChangeValue = this.props.label ? this.getValueObjectWithLabel(value) : value;
              this.props.onChange && this.props.onChange(onChangeValue, e);
              this.setState({
                value: value
              });
            }
          }, {
            key: 'render',
            value: function render() {
              var _this2 = this;
              var styles = _default$a({
                'default': {
                  wrap: {
                    position: 'relative'
                  }
                },
                'user-override': {
                  wrap: this.props.style && this.props.style.wrap ? this.props.style.wrap : {},
                  input: this.props.style && this.props.style.input ? this.props.style.input : {},
                  label: this.props.style && this.props.style.label ? this.props.style.label : {}
                },
                'dragLabel-true': {
                  label: {
                    cursor: 'ew-resize'
                  }
                }
              }, {
                'user-override': true
              }, this.props);
              return React.createElement('div', {
                style: styles.wrap
              }, React.createElement('input', {
                id: this.inputId,
                style: styles.input,
                ref: function ref(input) {
                  return _this2.input = input;
                },
                value: this.state.value,
                onKeyDown: this.handleKeyDown,
                onChange: this.handleChange,
                onBlur: this.handleBlur,
                placeholder: this.props.placeholder,
                spellCheck: 'false'
              }), this.props.label && !this.props.hideLabel ? React.createElement('label', {
                htmlFor: this.inputId,
                style: styles.label,
                onMouseDown: this.handleMouseDown
              }, this.props.label) : null);
            }
          }]);
          return EditableInput;
        }(reactExports.PureComponent || reactExports.Component);
        var calculateChange$1 = function calculateChange(e, direction, hsl, container) {
          var containerWidth = container.clientWidth;
          var containerHeight = container.clientHeight;
          var x = typeof e.pageX === 'number' ? e.pageX : e.touches[0].pageX;
          var y = typeof e.pageY === 'number' ? e.pageY : e.touches[0].pageY;
          var left = x - (container.getBoundingClientRect().left + window.pageXOffset);
          var top = y - (container.getBoundingClientRect().top + window.pageYOffset);
          if (direction === 'vertical') {
            var h = void 0;
            if (top < 0) {
              h = 359;
            } else if (top > containerHeight) {
              h = 0;
            } else {
              var percent = -(top * 100 / containerHeight) + 100;
              h = 360 * percent / 100;
            }
            if (hsl.h !== h) {
              return {
                h: h,
                s: hsl.s,
                l: hsl.l,
                a: hsl.a,
                source: 'hsl'
              };
            }
          } else {
            var _h = void 0;
            if (left < 0) {
              _h = 0;
            } else if (left > containerWidth) {
              _h = 359;
            } else {
              var _percent = left * 100 / containerWidth;
              _h = 360 * _percent / 100;
            }
            if (hsl.h !== _h) {
              return {
                h: _h,
                s: hsl.s,
                l: hsl.l,
                a: hsl.a,
                source: 'hsl'
              };
            }
          }
          return null;
        };
        var _createClass$5 = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        function _classCallCheck$5(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn$5(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self;
        }
        function _inherits$5(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var Hue = function (_ref) {
          _inherits$5(Hue, _ref);
          function Hue() {
            var _ref2;
            var _temp, _this, _ret;
            _classCallCheck$5(this, Hue);
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return _ret = (_temp = (_this = _possibleConstructorReturn$5(this, (_ref2 = Hue.__proto__ || Object.getPrototypeOf(Hue)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function (e) {
              var change = calculateChange$1(e, _this.props.direction, _this.props.hsl, _this.container);
              change && typeof _this.props.onChange === 'function' && _this.props.onChange(change, e);
            }, _this.handleMouseDown = function (e) {
              _this.handleChange(e);
              window.addEventListener('mousemove', _this.handleChange);
              window.addEventListener('mouseup', _this.handleMouseUp);
            }, _this.handleMouseUp = function () {
              _this.unbindEventListeners();
            }, _temp), _possibleConstructorReturn$5(_this, _ret);
          }
          _createClass$5(Hue, [{
            key: 'componentWillUnmount',
            value: function componentWillUnmount() {
              this.unbindEventListeners();
            }
          }, {
            key: 'unbindEventListeners',
            value: function unbindEventListeners() {
              window.removeEventListener('mousemove', this.handleChange);
              window.removeEventListener('mouseup', this.handleMouseUp);
            }
          }, {
            key: 'render',
            value: function render() {
              var _this2 = this;
              var _props$direction = this.props.direction,
                direction = _props$direction === undefined ? 'horizontal' : _props$direction;
              var styles = _default$a({
                'default': {
                  hue: {
                    absolute: '0px 0px 0px 0px',
                    borderRadius: this.props.radius,
                    boxShadow: this.props.shadow
                  },
                  container: {
                    padding: '0 2px',
                    position: 'relative',
                    height: '100%',
                    borderRadius: this.props.radius
                  },
                  pointer: {
                    position: 'absolute',
                    left: this.props.hsl.h * 100 / 360 + '%'
                  },
                  slider: {
                    marginTop: '1px',
                    width: '4px',
                    borderRadius: '1px',
                    height: '8px',
                    boxShadow: '0 0 2px rgba(0, 0, 0, .6)',
                    background: '#fff',
                    transform: 'translateX(-2px)'
                  }
                },
                'vertical': {
                  pointer: {
                    left: '0px',
                    top: -(this.props.hsl.h * 100 / 360) + 100 + '%'
                  }
                }
              }, {
                vertical: direction === 'vertical'
              });
              return React.createElement('div', {
                style: styles.hue
              }, React.createElement('div', {
                className: 'hue-' + direction,
                style: styles.container,
                ref: function ref(container) {
                  return _this2.container = container;
                },
                onMouseDown: this.handleMouseDown,
                onTouchMove: this.handleChange,
                onTouchStart: this.handleChange
              }, React.createElement('style', null, '\n            .hue-horizontal {\n              background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0\n                33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n              background: -webkit-linear-gradient(to right, #f00 0%, #ff0\n                17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n            }\n\n            .hue-vertical {\n              background: linear-gradient(to top, #f00 0%, #ff0 17%, #0f0 33%,\n                #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n              background: -webkit-linear-gradient(to top, #f00 0%, #ff0 17%,\n                #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n            }\n          '), React.createElement('div', {
                style: styles.pointer
              }, this.props.pointer ? React.createElement(this.props.pointer, this.props) : React.createElement('div', {
                style: styles.slider
              }))));
            }
          }]);
          return Hue;
        }(reactExports.PureComponent || reactExports.Component);

        /**
         * Removes all key-value entries from the list cache.
         *
         * @private
         * @name clear
         * @memberOf ListCache
         */
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }

        /**
         * Performs a
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * comparison between two values to determine if they are equivalent.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'a': 1 };
         * var other = { 'a': 1 };
         *
         * _.eq(object, object);
         * // => true
         *
         * _.eq(object, other);
         * // => false
         *
         * _.eq('a', 'a');
         * // => true
         *
         * _.eq('a', Object('a'));
         * // => false
         *
         * _.eq(NaN, NaN);
         * // => true
         */
        function eq$2(value, other) {
          return value === other || value !== value && other !== other;
        }

        /**
         * Gets the index at which the `key` is found in `array` of key-value pairs.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} key The key to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq$2(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }

        /** Used for built-in method references. */
        var arrayProto = Array.prototype;

        /** Built-in value references. */
        var splice = arrayProto.splice;

        /**
         * Removes `key` and its value from the list cache.
         *
         * @private
         * @name delete
         * @memberOf ListCache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function listCacheDelete(key) {
          var data = this.__data__,
            index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }

        /**
         * Gets the list cache value for `key`.
         *
         * @private
         * @name get
         * @memberOf ListCache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function listCacheGet(key) {
          var data = this.__data__,
            index = assocIndexOf(data, key);
          return index < 0 ? undefined : data[index][1];
        }

        /**
         * Checks if a list cache value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf ListCache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }

        /**
         * Sets the list cache `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf ListCache
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the list cache instance.
         */
        function listCacheSet(key, value) {
          var data = this.__data__,
            index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }

        /**
         * Creates an list cache object.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function ListCache(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        // Add methods to `ListCache`.
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype['delete'] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;

        /**
         * Removes all key-value entries from the stack.
         *
         * @private
         * @name clear
         * @memberOf Stack
         */
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }

        /**
         * Removes `key` and its value from the stack.
         *
         * @private
         * @name delete
         * @memberOf Stack
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function stackDelete(key) {
          var data = this.__data__,
            result = data['delete'](key);
          this.size = data.size;
          return result;
        }

        /**
         * Gets the stack value for `key`.
         *
         * @private
         * @name get
         * @memberOf Stack
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function stackGet(key) {
          return this.__data__.get(key);
        }

        /**
         * Checks if a stack value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf Stack
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function stackHas(key) {
          return this.__data__.has(key);
        }

        /** Detect free variable `global` from Node.js. */
        var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
        const freeGlobal$1 = freeGlobal;

        /** Detect free variable `self`. */
        var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

        /** Used as a reference to the global object. */
        var root$1 = freeGlobal$1 || freeSelf || Function('return this')();
        const root$2 = root$1;

        /** Built-in value references. */
        var Symbol$2 = root$2.Symbol;
        const Symbol$3 = Symbol$2;

        /** Used for built-in method references. */
        var objectProto$e = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$b = objectProto$e.hasOwnProperty;

        /**
         * Used to resolve the
         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
         * of values.
         */
        var nativeObjectToString$1 = objectProto$e.toString;

        /** Built-in value references. */
        var symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : undefined;

        /**
         * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the raw `toStringTag`.
         */
        function getRawTag(value) {
          var isOwn = hasOwnProperty$b.call(value, symToStringTag$1),
            tag = value[symToStringTag$1];
          try {
            value[symToStringTag$1] = undefined;
            var unmasked = true;
          } catch (e) {}
          var result = nativeObjectToString$1.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag$1] = tag;
            } else {
              delete value[symToStringTag$1];
            }
          }
          return result;
        }

        /** Used for built-in method references. */
        var objectProto$d = Object.prototype;

        /**
         * Used to resolve the
         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
         * of values.
         */
        var nativeObjectToString = objectProto$d.toString;

        /**
         * Converts `value` to a string using `Object.prototype.toString`.
         *
         * @private
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         */
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }

        /** `Object#toString` result references. */
        var nullTag = '[object Null]',
          undefinedTag = '[object Undefined]';

        /** Built-in value references. */
        var symToStringTag = Symbol$3 ? Symbol$3.toStringTag : undefined;

        /**
         * The base implementation of `getTag` without fallbacks for buggy environments.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
        }

        /**
         * Checks if `value` is the
         * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
         * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
         * @example
         *
         * _.isObject({});
         * // => true
         *
         * _.isObject([1, 2, 3]);
         * // => true
         *
         * _.isObject(_.noop);
         * // => true
         *
         * _.isObject(null);
         * // => false
         */
        function isObject$a(value) {
          var type = typeof value;
          return value != null && (type == 'object' || type == 'function');
        }

        /** `Object#toString` result references. */
        var asyncTag = '[object AsyncFunction]',
          funcTag$1 = '[object Function]',
          genTag = '[object GeneratorFunction]',
          proxyTag = '[object Proxy]';

        /**
         * Checks if `value` is classified as a `Function` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a function, else `false`.
         * @example
         *
         * _.isFunction(_);
         * // => true
         *
         * _.isFunction(/abc/);
         * // => false
         */
        function isFunction$2(value) {
          if (!isObject$a(value)) {
            return false;
          }
          // The use of `Object#toString` avoids issues with the `typeof` operator
          // in Safari 9 which returns 'object' for typed arrays and other constructors.
          var tag = baseGetTag(value);
          return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
        }

        /** Used to detect overreaching core-js shims. */
        var coreJsData = root$2['__core-js_shared__'];
        const coreJsData$1 = coreJsData;

        /** Used to detect methods masquerading as native. */
        var maskSrcKey = function () {
          var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || '');
          return uid ? 'Symbol(src)_1.' + uid : '';
        }();

        /**
         * Checks if `func` has its source masked.
         *
         * @private
         * @param {Function} func The function to check.
         * @returns {boolean} Returns `true` if `func` is masked, else `false`.
         */
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }

        /** Used for built-in method references. */
        var funcProto$2 = Function.prototype;

        /** Used to resolve the decompiled source of functions. */
        var funcToString$2 = funcProto$2.toString;

        /**
         * Converts `func` to its source code.
         *
         * @private
         * @param {Function} func The function to convert.
         * @returns {string} Returns the source code.
         */
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString$2.call(func);
            } catch (e) {}
            try {
              return func + '';
            } catch (e) {}
          }
          return '';
        }

        /**
         * Used to match `RegExp`
         * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
         */
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

        /** Used to detect host constructors (Safari). */
        var reIsHostCtor = /^\[object .+?Constructor\]$/;

        /** Used for built-in method references. */
        var funcProto$1 = Function.prototype,
          objectProto$c = Object.prototype;

        /** Used to resolve the decompiled source of functions. */
        var funcToString$1 = funcProto$1.toString;

        /** Used to check objects for own properties. */
        var hasOwnProperty$a = objectProto$c.hasOwnProperty;

        /** Used to detect if a method is native. */
        var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

        /**
         * The base implementation of `_.isNative` without bad shim checks.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a native function,
         *  else `false`.
         */
        function baseIsNative(value) {
          if (!isObject$a(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }

        /**
         * Gets the value at `key` of `object`.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {string} key The key of the property to get.
         * @returns {*} Returns the property value.
         */
        function getValue(object, key) {
          return object == null ? undefined : object[key];
        }

        /**
         * Gets the native function at `key` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the method to get.
         * @returns {*} Returns the function if it's native, else `undefined`.
         */
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined;
        }

        /* Built-in method references that are verified to be native. */
        var Map$1 = getNative(root$2, 'Map');
        const Map$2 = Map$1;

        /* Built-in method references that are verified to be native. */
        var nativeCreate = getNative(Object, 'create');
        const nativeCreate$1 = nativeCreate;

        /**
         * Removes all key-value entries from the hash.
         *
         * @private
         * @name clear
         * @memberOf Hash
         */
        function hashClear() {
          this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
          this.size = 0;
        }

        /**
         * Removes `key` and its value from the hash.
         *
         * @private
         * @name delete
         * @memberOf Hash
         * @param {Object} hash The hash to modify.
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function hashDelete(key) {
          var result = this.has(key) && delete this.__data__[key];
          this.size -= result ? 1 : 0;
          return result;
        }

        /** Used to stand-in for `undefined` hash values. */
        var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

        /** Used for built-in method references. */
        var objectProto$b = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$9 = objectProto$b.hasOwnProperty;

        /**
         * Gets the hash value for `key`.
         *
         * @private
         * @name get
         * @memberOf Hash
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate$1) {
            var result = data[key];
            return result === HASH_UNDEFINED$2 ? undefined : result;
          }
          return hasOwnProperty$9.call(data, key) ? data[key] : undefined;
        }

        /** Used for built-in method references. */
        var objectProto$a = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

        /**
         * Checks if a hash value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf Hash
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate$1 ? data[key] !== undefined : hasOwnProperty$8.call(data, key);
        }

        /** Used to stand-in for `undefined` hash values. */
        var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

        /**
         * Sets the hash `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf Hash
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the hash instance.
         */
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate$1 && value === undefined ? HASH_UNDEFINED$1 : value;
          return this;
        }

        /**
         * Creates a hash object.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function Hash(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        // Add methods to `Hash`.
        Hash.prototype.clear = hashClear;
        Hash.prototype['delete'] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;

        /**
         * Removes all key-value entries from the map.
         *
         * @private
         * @name clear
         * @memberOf MapCache
         */
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            'hash': new Hash(),
            'map': new (Map$2 || ListCache)(),
            'string': new Hash()
          };
        }

        /**
         * Checks if `value` is suitable for use as unique object key.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
         */
        function isKeyable(value) {
          var type = typeof value;
          return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
        }

        /**
         * Gets the data for `map`.
         *
         * @private
         * @param {Object} map The map to query.
         * @param {string} key The reference key.
         * @returns {*} Returns the map data.
         */
        function getMapData(map, key) {
          var data = map.__data__;
          return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
        }

        /**
         * Removes `key` and its value from the map.
         *
         * @private
         * @name delete
         * @memberOf MapCache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function mapCacheDelete(key) {
          var result = getMapData(this, key)['delete'](key);
          this.size -= result ? 1 : 0;
          return result;
        }

        /**
         * Gets the map value for `key`.
         *
         * @private
         * @name get
         * @memberOf MapCache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }

        /**
         * Checks if a map value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf MapCache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }

        /**
         * Sets the map `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf MapCache
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the map cache instance.
         */
        function mapCacheSet(key, value) {
          var data = getMapData(this, key),
            size = data.size;
          data.set(key, value);
          this.size += data.size == size ? 0 : 1;
          return this;
        }

        /**
         * Creates a map cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function MapCache(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        // Add methods to `MapCache`.
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype['delete'] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;

        /** Used as the size to enable large array optimizations. */
        var LARGE_ARRAY_SIZE = 200;

        /**
         * Sets the stack `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf Stack
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the stack cache instance.
         */
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }

        /**
         * Creates a stack cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function Stack$1(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }

        // Add methods to `Stack`.
        Stack$1.prototype.clear = stackClear;
        Stack$1.prototype['delete'] = stackDelete;
        Stack$1.prototype.get = stackGet;
        Stack$1.prototype.has = stackHas;
        Stack$1.prototype.set = stackSet;
        var defineProperty$1 = function () {
          try {
            var func = getNative(Object, 'defineProperty');
            func({}, '', {});
            return func;
          } catch (e) {}
        }();
        const defineProperty$2 = defineProperty$1;

        /**
         * The base implementation of `assignValue` and `assignMergeValue` without
         * value checks.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function baseAssignValue$2(object, key, value) {
          if (key == '__proto__' && defineProperty$2) {
            defineProperty$2(object, key, {
              'configurable': true,
              'enumerable': true,
              'value': value,
              'writable': true
            });
          } else {
            object[key] = value;
          }
        }

        /**
         * This function is like `assignValue` except that it doesn't assign
         * `undefined` values.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function assignMergeValue$3(object, key, value) {
          if (value !== undefined && !eq$2(object[key], value) || value === undefined && !(key in object)) {
            baseAssignValue$2(object, key, value);
          }
        }

        /**
         * Creates a base function for methods like `_.forIn` and `_.forOwn`.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseFor(fromRight) {
          return function (object, iteratee, keysFunc) {
            var index = -1,
              iterable = Object(object),
              props = keysFunc(object),
              length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }

        /**
         * The base implementation of `baseForOwn` which iterates over `object`
         * properties returned by `keysFunc` and invokes `iteratee` for each property.
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */
        var baseFor$1 = createBaseFor();
        const baseFor$2 = baseFor$1;

        /** Detect free variable `exports`. */
        var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;

        /** Detect free variable `module`. */
        var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;

        /** Detect the popular CommonJS extension `module.exports`. */
        var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;

        /** Built-in value references. */
        var Buffer$2 = moduleExports$2 ? root$2.Buffer : undefined,
          allocUnsafe = Buffer$2 ? Buffer$2.allocUnsafe : undefined;

        /**
         * Creates a clone of  `buffer`.
         *
         * @private
         * @param {Buffer} buffer The buffer to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Buffer} Returns the cloned buffer.
         */
        function cloneBuffer$1(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length,
            result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result);
          return result;
        }

        /** Built-in value references. */
        var Uint8Array = root$2.Uint8Array;
        const Uint8Array$1 = Uint8Array;

        /**
         * Creates a clone of `arrayBuffer`.
         *
         * @private
         * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
         * @returns {ArrayBuffer} Returns the cloned array buffer.
         */
        function cloneArrayBuffer(arrayBuffer) {
          var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
          return result;
        }

        /**
         * Creates a clone of `typedArray`.
         *
         * @private
         * @param {Object} typedArray The typed array to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the cloned typed array.
         */
        function cloneTypedArray$1(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }

        /**
         * Copies the values of `source` to `array`.
         *
         * @private
         * @param {Array} source The array to copy values from.
         * @param {Array} [array=[]] The array to copy values to.
         * @returns {Array} Returns `array`.
         */
        function copyArray$1(source, array) {
          var index = -1,
            length = source.length;
          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }

        /** Built-in value references. */
        var objectCreate = Object.create;

        /**
         * The base implementation of `_.create` without support for assigning
         * properties to the created object.
         *
         * @private
         * @param {Object} proto The object to inherit from.
         * @returns {Object} Returns the new object.
         */
        var baseCreate = function () {
          function object() {}
          return function (proto) {
            if (!isObject$a(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result = new object();
            object.prototype = undefined;
            return result;
          };
        }();
        const baseCreate$1 = baseCreate;

        /**
         * Creates a unary function that invokes `func` with its argument transformed.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {Function} transform The argument transform.
         * @returns {Function} Returns the new function.
         */
        function overArg(func, transform) {
          return function (arg) {
            return func(transform(arg));
          };
        }

        /** Built-in value references. */
        var getPrototype = overArg(Object.getPrototypeOf, Object);
        const getPrototype$1 = getPrototype;

        /** Used for built-in method references. */
        var objectProto$9 = Object.prototype;

        /**
         * Checks if `value` is likely a prototype object.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
         */
        function isPrototype(value) {
          var Ctor = value && value.constructor,
            proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$9;
          return value === proto;
        }

        /**
         * Initializes an object clone.
         *
         * @private
         * @param {Object} object The object to clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneObject$1(object) {
          return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate$1(getPrototype$1(object)) : {};
        }

        /**
         * Checks if `value` is object-like. A value is object-like if it's not `null`
         * and has a `typeof` result of "object".
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
         * @example
         *
         * _.isObjectLike({});
         * // => true
         *
         * _.isObjectLike([1, 2, 3]);
         * // => true
         *
         * _.isObjectLike(_.noop);
         * // => false
         *
         * _.isObjectLike(null);
         * // => false
         */
        function isObjectLike$1(value) {
          return value != null && typeof value == 'object';
        }

        /** `Object#toString` result references. */
        var argsTag$2 = '[object Arguments]';

        /**
         * The base implementation of `_.isArguments`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         */
        function baseIsArguments(value) {
          return isObjectLike$1(value) && baseGetTag(value) == argsTag$2;
        }

        /** Used for built-in method references. */
        var objectProto$8 = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$7 = objectProto$8.hasOwnProperty;

        /** Built-in value references. */
        var propertyIsEnumerable$1 = objectProto$8.propertyIsEnumerable;

        /**
         * Checks if `value` is likely an `arguments` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         *  else `false`.
         * @example
         *
         * _.isArguments(function() { return arguments; }());
         * // => true
         *
         * _.isArguments([1, 2, 3]);
         * // => false
         */
        var isArguments$2 = baseIsArguments(function () {
          return arguments;
        }()) ? baseIsArguments : function (value) {
          return isObjectLike$1(value) && hasOwnProperty$7.call(value, 'callee') && !propertyIsEnumerable$1.call(value, 'callee');
        };
        const isArguments$3 = isArguments$2;

        /**
         * Checks if `value` is classified as an `Array` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array, else `false`.
         * @example
         *
         * _.isArray([1, 2, 3]);
         * // => true
         *
         * _.isArray(document.body.children);
         * // => false
         *
         * _.isArray('abc');
         * // => false
         *
         * _.isArray(_.noop);
         * // => false
         */
        var isArray$3 = Array.isArray;
        const isArray$4 = isArray$3;

        /** Used as references for various `Number` constants. */
        var MAX_SAFE_INTEGER$1 = 9007199254740991;

        /**
         * Checks if `value` is a valid array-like length.
         *
         * **Note:** This method is loosely based on
         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
         * @example
         *
         * _.isLength(3);
         * // => true
         *
         * _.isLength(Number.MIN_VALUE);
         * // => false
         *
         * _.isLength(Infinity);
         * // => false
         *
         * _.isLength('3');
         * // => false
         */
        function isLength(value) {
          return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
        }

        /**
         * Checks if `value` is array-like. A value is considered array-like if it's
         * not a function and has a `value.length` that's an integer greater than or
         * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
         * @example
         *
         * _.isArrayLike([1, 2, 3]);
         * // => true
         *
         * _.isArrayLike(document.body.children);
         * // => true
         *
         * _.isArrayLike('abc');
         * // => true
         *
         * _.isArrayLike(_.noop);
         * // => false
         */
        function isArrayLike$2(value) {
          return value != null && isLength(value.length) && !isFunction$2(value);
        }

        /**
         * This method is like `_.isArrayLike` except that it also checks if `value`
         * is an object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array-like object,
         *  else `false`.
         * @example
         *
         * _.isArrayLikeObject([1, 2, 3]);
         * // => true
         *
         * _.isArrayLikeObject(document.body.children);
         * // => true
         *
         * _.isArrayLikeObject('abc');
         * // => false
         *
         * _.isArrayLikeObject(_.noop);
         * // => false
         */
        function isArrayLikeObject$2(value) {
          return isObjectLike$1(value) && isArrayLike$2(value);
        }

        /**
         * This method returns `false`.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {boolean} Returns `false`.
         * @example
         *
         * _.times(2, _.stubFalse);
         * // => [false, false]
         */
        function stubFalse() {
          return false;
        }

        /** Detect free variable `exports`. */
        var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

        /** Detect free variable `module`. */
        var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

        /** Detect the popular CommonJS extension `module.exports`. */
        var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

        /** Built-in value references. */
        var Buffer$1 = moduleExports$1 ? root$2.Buffer : undefined;

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : undefined;

        /**
         * Checks if `value` is a buffer.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
         * @example
         *
         * _.isBuffer(new Buffer(2));
         * // => true
         *
         * _.isBuffer(new Uint8Array(2));
         * // => false
         */
        var isBuffer$1 = nativeIsBuffer || stubFalse;
        const isBuffer$2 = isBuffer$1;

        /** `Object#toString` result references. */
        var objectTag$3 = '[object Object]';

        /** Used for built-in method references. */
        var funcProto = Function.prototype,
          objectProto$7 = Object.prototype;

        /** Used to resolve the decompiled source of functions. */
        var funcToString = funcProto.toString;

        /** Used to check objects for own properties. */
        var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

        /** Used to infer the `Object` constructor. */
        var objectCtorString = funcToString.call(Object);

        /**
         * Checks if `value` is a plain object, that is, an object created by the
         * `Object` constructor or one with a `[[Prototype]]` of `null`.
         *
         * @static
         * @memberOf _
         * @since 0.8.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * _.isPlainObject(new Foo);
         * // => false
         *
         * _.isPlainObject([1, 2, 3]);
         * // => false
         *
         * _.isPlainObject({ 'x': 0, 'y': 0 });
         * // => true
         *
         * _.isPlainObject(Object.create(null));
         * // => true
         */
        function isPlainObject$2(value) {
          if (!isObjectLike$1(value) || baseGetTag(value) != objectTag$3) {
            return false;
          }
          var proto = getPrototype$1(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty$6.call(proto, 'constructor') && proto.constructor;
          return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }

        /** `Object#toString` result references. */
        var argsTag$1 = '[object Arguments]',
          arrayTag$1 = '[object Array]',
          boolTag$1 = '[object Boolean]',
          dateTag$1 = '[object Date]',
          errorTag$1 = '[object Error]',
          funcTag = '[object Function]',
          mapTag$2 = '[object Map]',
          numberTag$1 = '[object Number]',
          objectTag$2 = '[object Object]',
          regexpTag$1 = '[object RegExp]',
          setTag$2 = '[object Set]',
          stringTag$1 = '[object String]',
          weakMapTag$1 = '[object WeakMap]';
        var arrayBufferTag$1 = '[object ArrayBuffer]',
          dataViewTag$2 = '[object DataView]',
          float32Tag = '[object Float32Array]',
          float64Tag = '[object Float64Array]',
          int8Tag = '[object Int8Array]',
          int16Tag = '[object Int16Array]',
          int32Tag = '[object Int32Array]',
          uint8Tag = '[object Uint8Array]',
          uint8ClampedTag = '[object Uint8ClampedArray]',
          uint16Tag = '[object Uint16Array]',
          uint32Tag = '[object Uint32Array]';

        /** Used to identify `toStringTag` values of typed arrays. */
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;

        /**
         * The base implementation of `_.isTypedArray` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         */
        function baseIsTypedArray(value) {
          return isObjectLike$1(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }

        /**
         * The base implementation of `_.unary` without support for storing metadata.
         *
         * @private
         * @param {Function} func The function to cap arguments for.
         * @returns {Function} Returns the new capped function.
         */
        function baseUnary(func) {
          return function (value) {
            return func(value);
          };
        }

        /** Detect free variable `exports`. */
        var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

        /** Detect free variable `module`. */
        var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

        /** Detect the popular CommonJS extension `module.exports`. */
        var moduleExports = freeModule && freeModule.exports === freeExports;

        /** Detect free variable `process` from Node.js. */
        var freeProcess = moduleExports && freeGlobal$1.process;

        /** Used to access faster Node.js helpers. */
        var nodeUtil = function () {
          try {
            // Use `util.types` for Node.js 10+.
            var types = freeModule && freeModule.require && freeModule.require('util').types;
            if (types) {
              return types;
            }

            // Legacy `process.binding('util')` for Node.js < 10.
            return freeProcess && freeProcess.binding && freeProcess.binding('util');
          } catch (e) {}
        }();
        const nodeUtil$1 = nodeUtil;

        /* Node.js helper references. */
        var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;

        /**
         * Checks if `value` is classified as a typed array.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         * @example
         *
         * _.isTypedArray(new Uint8Array);
         * // => true
         *
         * _.isTypedArray([]);
         * // => false
         */
        var isTypedArray$1 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        const isTypedArray$2 = isTypedArray$1;

        /**
         * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the property to get.
         * @returns {*} Returns the property value.
         */
        function safeGet$3(object, key) {
          if (key === 'constructor' && typeof object[key] === 'function') {
            return;
          }
          if (key == '__proto__') {
            return;
          }
          return object[key];
        }

        /** Used for built-in method references. */
        var objectProto$6 = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$5 = objectProto$6.hasOwnProperty;

        /**
         * Assigns `value` to `key` of `object` if the existing value is not equivalent
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function assignValue$1(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty$5.call(object, key) && eq$2(objValue, value)) || value === undefined && !(key in object)) {
            baseAssignValue$2(object, key, value);
          }
        }

        /**
         * Copies properties of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy properties from.
         * @param {Array} props The property identifiers to copy.
         * @param {Object} [object={}] The object to copy properties to.
         * @param {Function} [customizer] The function to customize copied values.
         * @returns {Object} Returns `object`.
         */
        function copyObject$2(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1,
            length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
            if (newValue === undefined) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue$2(object, key, newValue);
            } else {
              assignValue$1(object, key, newValue);
            }
          }
          return object;
        }

        /**
         * The base implementation of `_.times` without support for iteratee shorthands
         * or max array length checks.
         *
         * @private
         * @param {number} n The number of times to invoke `iteratee`.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the array of results.
         */
        function baseTimes(n, iteratee) {
          var index = -1,
            result = Array(n);
          while (++index < n) {
            result[index] = iteratee(index);
          }
          return result;
        }

        /** Used as references for various `Number` constants. */
        var MAX_SAFE_INTEGER = 9007199254740991;

        /** Used to detect unsigned integer values. */
        var reIsUint = /^(?:0|[1-9]\d*)$/;

        /**
         * Checks if `value` is a valid array-like index.
         *
         * @private
         * @param {*} value The value to check.
         * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
         * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
         */
        function isIndex$2(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
        }

        /** Used for built-in method references. */
        var objectProto$5 = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

        /**
         * Creates an array of the enumerable property names of the array-like `value`.
         *
         * @private
         * @param {*} value The value to query.
         * @param {boolean} inherited Specify returning inherited property names.
         * @returns {Array} Returns the array of property names.
         */
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray$4(value),
            isArg = !isArr && isArguments$3(value),
            isBuff = !isArr && !isArg && isBuffer$2(value),
            isType = !isArr && !isArg && !isBuff && isTypedArray$2(value),
            skipIndexes = isArr || isArg || isBuff || isType,
            result = skipIndexes ? baseTimes(value.length, String) : [],
            length = result.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && (
            // Safari 9 has enumerable `arguments.length` in strict mode.
            key == 'length' ||
            // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == 'offset' || key == 'parent') ||
            // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
            // Skip index properties.
            isIndex$2(key, length)))) {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * This function is like
         * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
         * except that it includes inherited enumerable properties.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function nativeKeysIn(object) {
          var result = [];
          if (object != null) {
            for (var key in Object(object)) {
              result.push(key);
            }
          }
          return result;
        }

        /** Used for built-in method references. */
        var objectProto$4 = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

        /**
         * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function baseKeysIn(object) {
          if (!isObject$a(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object),
            result = [];
          for (var key in object) {
            if (!(key == 'constructor' && (isProto || !hasOwnProperty$3.call(object, key)))) {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * Creates an array of the own and inherited enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keysIn(new Foo);
         * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
         */
        function keysIn$2(object) {
          return isArrayLike$2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }

        /**
         * Converts `value` to a plain object flattening inherited enumerable string
         * keyed properties of `value` to own properties of the plain object.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Object} Returns the converted plain object.
         * @example
         *
         * function Foo() {
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.assign({ 'a': 1 }, new Foo);
         * // => { 'a': 1, 'b': 2 }
         *
         * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
         * // => { 'a': 1, 'b': 2, 'c': 3 }
         */
        function toPlainObject$2(value) {
          return copyObject$2(value, keysIn$2(value));
        }

        /**
         * A specialized version of `baseMerge` for arrays and objects which performs
         * deep merges and tracks traversed objects enabling objects with circular
         * references to be merged.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {string} key The key of the value to merge.
         * @param {number} srcIndex The index of `source`.
         * @param {Function} mergeFunc The function to merge values.
         * @param {Function} [customizer] The function to customize assigned values.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         */
        function baseMergeDeep$2(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet$3(object, key),
            srcValue = safeGet$3(source, key),
            stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue$3(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
          var isCommon = newValue === undefined;
          if (isCommon) {
            var isArr = isArray$4(srcValue),
              isBuff = !isArr && isBuffer$2(srcValue),
              isTyped = !isArr && !isBuff && isTypedArray$2(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray$4(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject$2(objValue)) {
                newValue = copyArray$1(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer$1(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray$1(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject$2(srcValue) || isArguments$3(srcValue)) {
              newValue = objValue;
              if (isArguments$3(objValue)) {
                newValue = toPlainObject$2(objValue);
              } else if (!isObject$a(objValue) || isFunction$2(objValue)) {
                newValue = initCloneObject$1(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            // Recursively merge objects and arrays (susceptible to call stack limits).
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack['delete'](srcValue);
          }
          assignMergeValue$3(object, key, newValue);
        }

        /**
         * The base implementation of `_.merge` without support for multiple sources.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {number} srcIndex The index of `source`.
         * @param {Function} [customizer] The function to customize merged values.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         */
        function baseMerge$3(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor$2(source, function (srcValue, key) {
            stack || (stack = new Stack$1());
            if (isObject$a(srcValue)) {
              baseMergeDeep$2(object, source, key, srcIndex, baseMerge$3, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet$3(object, key), srcValue, key + '', object, source, stack) : undefined;
              if (newValue === undefined) {
                newValue = srcValue;
              }
              assignMergeValue$3(object, key, newValue);
            }
          }, keysIn$2);
        }

        /**
         * This method returns the first argument it receives.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {*} value Any value.
         * @returns {*} Returns `value`.
         * @example
         *
         * var object = { 'a': 1 };
         *
         * console.log(_.identity(object) === object);
         * // => true
         */
        function identity$2(value) {
          return value;
        }

        /**
         * A faster alternative to `Function#apply`, this function invokes `func`
         * with the `this` binding of `thisArg` and the arguments of `args`.
         *
         * @private
         * @param {Function} func The function to invoke.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {Array} args The arguments to invoke `func` with.
         * @returns {*} Returns the result of `func`.
         */
        function apply$2(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeMax$4 = Math.max;

        /**
         * A specialized version of `baseRest` which transforms the rest array.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @param {Function} transform The rest array transform.
         * @returns {Function} Returns the new function.
         */
        function overRest$3(func, start, transform) {
          start = nativeMax$4(start === undefined ? func.length - 1 : start, 0);
          return function () {
            var args = arguments,
              index = -1,
              length = nativeMax$4(args.length - start, 0),
              array = Array(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform(array);
            return apply$2(func, this, otherArgs);
          };
        }

        /**
         * Creates a function that returns `value`.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Util
         * @param {*} value The value to return from the new function.
         * @returns {Function} Returns the new constant function.
         * @example
         *
         * var objects = _.times(2, _.constant({ 'a': 1 }));
         *
         * console.log(objects);
         * // => [{ 'a': 1 }, { 'a': 1 }]
         *
         * console.log(objects[0] === objects[1]);
         * // => true
         */
        function constant$2(value) {
          return function () {
            return value;
          };
        }

        /**
         * The base implementation of `setToString` without support for hot loop shorting.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */
        var baseSetToString$2 = !defineProperty$2 ? identity$2 : function (func, string) {
          return defineProperty$2(func, 'toString', {
            'configurable': true,
            'enumerable': false,
            'value': constant$2(string),
            'writable': true
          });
        };
        const baseSetToString$3 = baseSetToString$2;

        /** Used to detect hot functions by number of calls within a span of milliseconds. */
        var HOT_COUNT$1 = 800,
          HOT_SPAN$1 = 16;

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeNow$1 = Date.now;

        /**
         * Creates a function that'll short out and invoke `identity` instead
         * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
         * milliseconds.
         *
         * @private
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new shortable function.
         */
        function shortOut$2(func) {
          var count = 0,
            lastCalled = 0;
          return function () {
            var stamp = nativeNow$1(),
              remaining = HOT_SPAN$1 - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT$1) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined, arguments);
          };
        }

        /**
         * Sets the `toString` method of `func` to return `string`.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */
        var setToString$3 = shortOut$2(baseSetToString$3);
        const setToString$4 = setToString$3;

        /**
         * The base implementation of `_.rest` which doesn't validate or coerce arguments.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @returns {Function} Returns the new function.
         */
        function baseRest$2(func, start) {
          return setToString$4(overRest$3(func, start, identity$2), func + '');
        }

        /**
         * Checks if the given arguments are from an iteratee call.
         *
         * @private
         * @param {*} value The potential iteratee value argument.
         * @param {*} index The potential iteratee index or key argument.
         * @param {*} object The potential iteratee object argument.
         * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
         *  else `false`.
         */
        function isIterateeCall$3(value, index, object) {
          if (!isObject$a(object)) {
            return false;
          }
          var type = typeof index;
          if (type == 'number' ? isArrayLike$2(object) && isIndex$2(index, object.length) : type == 'string' && index in object) {
            return eq$2(object[index], value);
          }
          return false;
        }

        /**
         * Creates a function like `_.assign`.
         *
         * @private
         * @param {Function} assigner The function to assign values.
         * @returns {Function} Returns the new assigner function.
         */
        function createAssigner$3(assigner) {
          return baseRest$2(function (object, sources) {
            var index = -1,
              length = sources.length,
              customizer = length > 1 ? sources[length - 1] : undefined,
              guard = length > 2 ? sources[2] : undefined;
            customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;
            if (guard && isIterateeCall$3(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined : customizer;
              length = 1;
            }
            object = Object(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }

        /**
         * This method is like `_.assign` except that it recursively merges own and
         * inherited enumerable string keyed properties of source objects into the
         * destination object. Source properties that resolve to `undefined` are
         * skipped if a destination value exists. Array and plain object properties
         * are merged recursively. Other objects and value types are overridden by
         * assignment. Source objects are applied from left to right. Subsequent
         * sources overwrite property assignments of previous sources.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 0.5.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = {
         *   'a': [{ 'b': 2 }, { 'd': 4 }]
         * };
         *
         * var other = {
         *   'a': [{ 'c': 3 }, { 'e': 5 }]
         * };
         *
         * _.merge(object, other);
         * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
         */
        var merge$3 = createAssigner$3(function (object, source, srcIndex) {
          baseMerge$3(object, source, srcIndex);
        });
        const merge$4 = merge$3;
        var Raised = function Raised(_ref) {
          var zDepth = _ref.zDepth,
            radius = _ref.radius,
            background = _ref.background,
            children = _ref.children,
            _ref$styles = _ref.styles,
            passedStyles = _ref$styles === undefined ? {} : _ref$styles;
          var styles = _default$a(merge$4({
            'default': {
              wrap: {
                position: 'relative',
                display: 'inline-block'
              },
              content: {
                position: 'relative'
              },
              bg: {
                absolute: '0px 0px 0px 0px',
                boxShadow: '0 ' + zDepth + 'px ' + zDepth * 4 + 'px rgba(0,0,0,.24)',
                borderRadius: radius,
                background: background
              }
            },
            'zDepth-0': {
              bg: {
                boxShadow: 'none'
              }
            },
            'zDepth-1': {
              bg: {
                boxShadow: '0 2px 10px rgba(0,0,0,.12), 0 2px 5px rgba(0,0,0,.16)'
              }
            },
            'zDepth-2': {
              bg: {
                boxShadow: '0 6px 20px rgba(0,0,0,.19), 0 8px 17px rgba(0,0,0,.2)'
              }
            },
            'zDepth-3': {
              bg: {
                boxShadow: '0 17px 50px rgba(0,0,0,.19), 0 12px 15px rgba(0,0,0,.24)'
              }
            },
            'zDepth-4': {
              bg: {
                boxShadow: '0 25px 55px rgba(0,0,0,.21), 0 16px 28px rgba(0,0,0,.22)'
              }
            },
            'zDepth-5': {
              bg: {
                boxShadow: '0 40px 77px rgba(0,0,0,.22), 0 27px 24px rgba(0,0,0,.2)'
              }
            },
            'square': {
              bg: {
                borderRadius: '0'
              }
            },
            'circle': {
              bg: {
                borderRadius: '50%'
              }
            }
          }, passedStyles), {
            'zDepth-1': zDepth === 1
          });
          return React.createElement('div', {
            style: styles.wrap
          }, React.createElement('div', {
            style: styles.bg
          }), React.createElement('div', {
            style: styles.content
          }, children));
        };
        Raised.propTypes = {
          background: PropTypes.string,
          zDepth: PropTypes.oneOf([0, 1, 2, 3, 4, 5]),
          radius: PropTypes.number,
          styles: PropTypes.object
        };
        Raised.defaultProps = {
          background: '#fff',
          zDepth: 1,
          radius: 2,
          styles: {}
        };

        /**
         * Gets the timestamp of the number of milliseconds that have elapsed since
         * the Unix epoch (1 January 1970 00:00:00 UTC).
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Date
         * @returns {number} Returns the timestamp.
         * @example
         *
         * _.defer(function(stamp) {
         *   console.log(_.now() - stamp);
         * }, _.now());
         * // => Logs the number of milliseconds it took for the deferred invocation.
         */
        var now$3 = function () {
          return root$2.Date.now();
        };
        const now$4 = now$3;

        /** Used to match a single whitespace character. */
        var reWhitespace$1 = /\s/;

        /**
         * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
         * character of `string`.
         *
         * @private
         * @param {string} string The string to inspect.
         * @returns {number} Returns the index of the last non-whitespace character.
         */
        function trimmedEndIndex$2(string) {
          var index = string.length;
          while (index-- && reWhitespace$1.test(string.charAt(index))) {}
          return index;
        }

        /** Used to match leading whitespace. */
        var reTrimStart$1 = /^\s+/;

        /**
         * The base implementation of `_.trim`.
         *
         * @private
         * @param {string} string The string to trim.
         * @returns {string} Returns the trimmed string.
         */
        function baseTrim$2(string) {
          return string ? string.slice(0, trimmedEndIndex$2(string) + 1).replace(reTrimStart$1, '') : string;
        }

        /** `Object#toString` result references. */
        var symbolTag$1 = '[object Symbol]';

        /**
         * Checks if `value` is classified as a `Symbol` primitive or object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
         * @example
         *
         * _.isSymbol(Symbol.iterator);
         * // => true
         *
         * _.isSymbol('abc');
         * // => false
         */
        function isSymbol$1(value) {
          return typeof value == 'symbol' || isObjectLike$1(value) && baseGetTag(value) == symbolTag$1;
        }

        /** Used as references for various `Number` constants. */
        var NAN$1 = 0 / 0;

        /** Used to detect bad signed hexadecimal string values. */
        var reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i;

        /** Used to detect binary string values. */
        var reIsBinary$1 = /^0b[01]+$/i;

        /** Used to detect octal string values. */
        var reIsOctal$1 = /^0o[0-7]+$/i;

        /** Built-in method references without a dependency on `root`. */
        var freeParseInt$1 = parseInt;

        /**
         * Converts `value` to a number.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to process.
         * @returns {number} Returns the number.
         * @example
         *
         * _.toNumber(3.2);
         * // => 3.2
         *
         * _.toNumber(Number.MIN_VALUE);
         * // => 5e-324
         *
         * _.toNumber(Infinity);
         * // => Infinity
         *
         * _.toNumber('3.2');
         * // => 3.2
         */
        function toNumber$3(value) {
          if (typeof value == 'number') {
            return value;
          }
          if (isSymbol$1(value)) {
            return NAN$1;
          }
          if (isObject$a(value)) {
            var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
            value = isObject$a(other) ? other + '' : other;
          }
          if (typeof value != 'string') {
            return value === 0 ? value : +value;
          }
          value = baseTrim$2(value);
          var isBinary = reIsBinary$1.test(value);
          return isBinary || reIsOctal$1.test(value) ? freeParseInt$1(value.slice(2), isBinary ? 2 : 8) : reIsBadHex$1.test(value) ? NAN$1 : +value;
        }

        /** Error message constants. */
        var FUNC_ERROR_TEXT$3 = 'Expected a function';

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeMax$3 = Math.max,
          nativeMin$1 = Math.min;

        /**
         * Creates a debounced function that delays invoking `func` until after `wait`
         * milliseconds have elapsed since the last time the debounced function was
         * invoked. The debounced function comes with a `cancel` method to cancel
         * delayed `func` invocations and a `flush` method to immediately invoke them.
         * Provide `options` to indicate whether `func` should be invoked on the
         * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
         * with the last arguments provided to the debounced function. Subsequent
         * calls to the debounced function return the result of the last `func`
         * invocation.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is
         * invoked on the trailing edge of the timeout only if the debounced function
         * is invoked more than once during the `wait` timeout.
         *
         * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
         * until to the next tick, similar to `setTimeout` with a timeout of `0`.
         *
         * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
         * for details over the differences between `_.debounce` and `_.throttle`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to debounce.
         * @param {number} [wait=0] The number of milliseconds to delay.
         * @param {Object} [options={}] The options object.
         * @param {boolean} [options.leading=false]
         *  Specify invoking on the leading edge of the timeout.
         * @param {number} [options.maxWait]
         *  The maximum time `func` is allowed to be delayed before it's invoked.
         * @param {boolean} [options.trailing=true]
         *  Specify invoking on the trailing edge of the timeout.
         * @returns {Function} Returns the new debounced function.
         * @example
         *
         * // Avoid costly calculations while the window size is in flux.
         * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
         *
         * // Invoke `sendMail` when clicked, debouncing subsequent calls.
         * jQuery(element).on('click', _.debounce(sendMail, 300, {
         *   'leading': true,
         *   'trailing': false
         * }));
         *
         * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
         * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
         * var source = new EventSource('/stream');
         * jQuery(source).on('message', debounced);
         *
         * // Cancel the trailing debounced invocation.
         * jQuery(window).on('popstate', debounced.cancel);
         */
        function debounce$2(func, wait, options) {
          var lastArgs,
            lastThis,
            maxWait,
            result,
            timerId,
            lastCallTime,
            lastInvokeTime = 0,
            leading = false,
            maxing = false,
            trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT$3);
          }
          wait = toNumber$3(wait) || 0;
          if (isObject$a(options)) {
            leading = !!options.leading;
            maxing = 'maxWait' in options;
            maxWait = maxing ? nativeMax$3(toNumber$3(options.maxWait) || 0, wait) : maxWait;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs,
              thisArg = lastThis;
            lastArgs = lastThis = undefined;
            lastInvokeTime = time;
            result = func.apply(thisArg, args);
            return result;
          }
          function leadingEdge(time) {
            // Reset any `maxWait` timer.
            lastInvokeTime = time;
            // Start the timer for the trailing edge.
            timerId = setTimeout(timerExpired, wait);
            // Invoke the leading edge.
            return leading ? invokeFunc(time) : result;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime,
              timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin$1(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime;

            // Either this is the first call, activity has stopped and we're at the
            // trailing edge, the system time has gone backwards and we're treating
            // it as the trailing edge, or we've hit the `maxWait` limit.
            return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now$4();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            // Restart the timer.
            timerId = setTimeout(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined;

            // Only invoke if we have `lastArgs` which means `func` has been
            // debounced at least once.
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined;
            return result;
          }
          function cancel() {
            if (timerId !== undefined) {
              clearTimeout(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined;
          }
          function flush() {
            return timerId === undefined ? result : trailingEdge(now$4());
          }
          function debounced() {
            var time = now$4(),
              isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                // Handle invocations in a tight loop.
                clearTimeout(timerId);
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined) {
              timerId = setTimeout(timerExpired, wait);
            }
            return result;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }

        /** Error message constants. */
        var FUNC_ERROR_TEXT$2 = 'Expected a function';

        /**
         * Creates a throttled function that only invokes `func` at most once per
         * every `wait` milliseconds. The throttled function comes with a `cancel`
         * method to cancel delayed `func` invocations and a `flush` method to
         * immediately invoke them. Provide `options` to indicate whether `func`
         * should be invoked on the leading and/or trailing edge of the `wait`
         * timeout. The `func` is invoked with the last arguments provided to the
         * throttled function. Subsequent calls to the throttled function return the
         * result of the last `func` invocation.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is
         * invoked on the trailing edge of the timeout only if the throttled function
         * is invoked more than once during the `wait` timeout.
         *
         * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
         * until to the next tick, similar to `setTimeout` with a timeout of `0`.
         *
         * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
         * for details over the differences between `_.throttle` and `_.debounce`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to throttle.
         * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
         * @param {Object} [options={}] The options object.
         * @param {boolean} [options.leading=true]
         *  Specify invoking on the leading edge of the timeout.
         * @param {boolean} [options.trailing=true]
         *  Specify invoking on the trailing edge of the timeout.
         * @returns {Function} Returns the new throttled function.
         * @example
         *
         * // Avoid excessively updating the position while scrolling.
         * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
         *
         * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
         * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
         * jQuery(element).on('click', throttled);
         *
         * // Cancel the trailing throttled invocation.
         * jQuery(window).on('popstate', throttled.cancel);
         */
        function throttle(func, wait, options) {
          var leading = true,
            trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT$2);
          }
          if (isObject$a(options)) {
            leading = 'leading' in options ? !!options.leading : leading;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          return debounce$2(func, wait, {
            'leading': leading,
            'maxWait': wait,
            'trailing': trailing
          });
        }
        var calculateChange = function calculateChange(e, hsl, container) {
          var _container$getBoundin = container.getBoundingClientRect(),
            containerWidth = _container$getBoundin.width,
            containerHeight = _container$getBoundin.height;
          var x = typeof e.pageX === 'number' ? e.pageX : e.touches[0].pageX;
          var y = typeof e.pageY === 'number' ? e.pageY : e.touches[0].pageY;
          var left = x - (container.getBoundingClientRect().left + window.pageXOffset);
          var top = y - (container.getBoundingClientRect().top + window.pageYOffset);
          if (left < 0) {
            left = 0;
          } else if (left > containerWidth) {
            left = containerWidth;
          }
          if (top < 0) {
            top = 0;
          } else if (top > containerHeight) {
            top = containerHeight;
          }
          var saturation = left / containerWidth;
          var bright = 1 - top / containerHeight;
          return {
            h: hsl.h,
            s: saturation,
            v: bright,
            a: hsl.a,
            source: 'hsv'
          };
        };
        var _createClass$4 = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        function _classCallCheck$4(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn$4(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self;
        }
        function _inherits$4(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var Saturation = function (_ref) {
          _inherits$4(Saturation, _ref);
          function Saturation(props) {
            _classCallCheck$4(this, Saturation);
            var _this = _possibleConstructorReturn$4(this, (Saturation.__proto__ || Object.getPrototypeOf(Saturation)).call(this, props));
            _this.handleChange = function (e) {
              typeof _this.props.onChange === 'function' && _this.throttle(_this.props.onChange, calculateChange(e, _this.props.hsl, _this.container), e);
            };
            _this.handleMouseDown = function (e) {
              _this.handleChange(e);
              var renderWindow = _this.getContainerRenderWindow();
              renderWindow.addEventListener('mousemove', _this.handleChange);
              renderWindow.addEventListener('mouseup', _this.handleMouseUp);
            };
            _this.handleMouseUp = function () {
              _this.unbindEventListeners();
            };
            _this.throttle = throttle(function (fn, data, e) {
              fn(data, e);
            }, 50);
            return _this;
          }
          _createClass$4(Saturation, [{
            key: 'componentWillUnmount',
            value: function componentWillUnmount() {
              this.throttle.cancel();
              this.unbindEventListeners();
            }
          }, {
            key: 'getContainerRenderWindow',
            value: function getContainerRenderWindow() {
              var container = this.container;
              var renderWindow = window;
              while (!renderWindow.document.contains(container) && renderWindow.parent !== renderWindow) {
                renderWindow = renderWindow.parent;
              }
              return renderWindow;
            }
          }, {
            key: 'unbindEventListeners',
            value: function unbindEventListeners() {
              var renderWindow = this.getContainerRenderWindow();
              renderWindow.removeEventListener('mousemove', this.handleChange);
              renderWindow.removeEventListener('mouseup', this.handleMouseUp);
            }
          }, {
            key: 'render',
            value: function render() {
              var _this2 = this;
              var _ref2 = this.props.style || {},
                color = _ref2.color,
                white = _ref2.white,
                black = _ref2.black,
                pointer = _ref2.pointer,
                circle = _ref2.circle;
              var styles = _default$a({
                'default': {
                  color: {
                    absolute: '0px 0px 0px 0px',
                    background: 'hsl(' + this.props.hsl.h + ',100%, 50%)',
                    borderRadius: this.props.radius
                  },
                  white: {
                    absolute: '0px 0px 0px 0px',
                    borderRadius: this.props.radius
                  },
                  black: {
                    absolute: '0px 0px 0px 0px',
                    boxShadow: this.props.shadow,
                    borderRadius: this.props.radius
                  },
                  pointer: {
                    position: 'absolute',
                    top: -(this.props.hsv.v * 100) + 100 + '%',
                    left: this.props.hsv.s * 100 + '%',
                    cursor: 'default'
                  },
                  circle: {
                    width: '4px',
                    height: '4px',
                    boxShadow: '0 0 0 1.5px #fff, inset 0 0 1px 1px rgba(0,0,0,.3),\n            0 0 1px 2px rgba(0,0,0,.4)',
                    borderRadius: '50%',
                    cursor: 'hand',
                    transform: 'translate(-2px, -2px)'
                  }
                },
                'custom': {
                  color: color,
                  white: white,
                  black: black,
                  pointer: pointer,
                  circle: circle
                }
              }, {
                'custom': !!this.props.style
              });
              return React.createElement('div', {
                style: styles.color,
                ref: function ref(container) {
                  return _this2.container = container;
                },
                onMouseDown: this.handleMouseDown,
                onTouchMove: this.handleChange,
                onTouchStart: this.handleChange
              }, React.createElement('style', null, '\n          .saturation-white {\n            background: -webkit-linear-gradient(to right, #fff, rgba(255,255,255,0));\n            background: linear-gradient(to right, #fff, rgba(255,255,255,0));\n          }\n          .saturation-black {\n            background: -webkit-linear-gradient(to top, #000, rgba(0,0,0,0));\n            background: linear-gradient(to top, #000, rgba(0,0,0,0));\n          }\n        '), React.createElement('div', {
                style: styles.white,
                className: 'saturation-white'
              }, React.createElement('div', {
                style: styles.black,
                className: 'saturation-black'
              }), React.createElement('div', {
                style: styles.pointer
              }, this.props.pointer ? React.createElement(this.props.pointer, this.props) : React.createElement('div', {
                style: styles.circle
              }))));
            }
          }]);
          return Saturation;
        }(reactExports.PureComponent || reactExports.Component);

        /**
         * A specialized version of `_.forEach` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns `array`.
         */
        function arrayEach(array, iteratee) {
          var index = -1,
            length = array == null ? 0 : array.length;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeKeys = overArg(Object.keys, Object);
        const nativeKeys$1 = nativeKeys;

        /** Used for built-in method references. */
        var objectProto$3 = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

        /**
         * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys$1(object);
          }
          var result = [];
          for (var key in Object(object)) {
            if (hasOwnProperty$2.call(object, key) && key != 'constructor') {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * Creates an array of the own enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects. See the
         * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
         * for more details.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keys(new Foo);
         * // => ['a', 'b'] (iteration order is not guaranteed)
         *
         * _.keys('hi');
         * // => ['0', '1']
         */
        function keys$1(object) {
          return isArrayLike$2(object) ? arrayLikeKeys(object) : baseKeys(object);
        }

        /**
         * The base implementation of `_.forOwn` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForOwn$1(object, iteratee) {
          return object && baseFor$2(object, iteratee, keys$1);
        }

        /**
         * Creates a `baseEach` or `baseEachRight` function.
         *
         * @private
         * @param {Function} eachFunc The function to iterate over a collection.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseEach(eachFunc, fromRight) {
          return function (collection, iteratee) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike$2(collection)) {
              return eachFunc(collection, iteratee);
            }
            var length = collection.length,
              index = fromRight ? length : -1,
              iterable = Object(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }

        /**
         * The base implementation of `_.forEach` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         */
        var baseEach = createBaseEach(baseForOwn$1);
        const baseEach$1 = baseEach;

        /**
         * Casts `value` to `identity` if it's not a function.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {Function} Returns cast function.
         */
        function castFunction(value) {
          return typeof value == 'function' ? value : identity$2;
        }

        /**
         * Iterates over elements of `collection` and invokes `iteratee` for each element.
         * The iteratee is invoked with three arguments: (value, index|key, collection).
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * **Note:** As with other "Collections" methods, objects with a "length"
         * property are iterated like arrays. To avoid this behavior use `_.forIn`
         * or `_.forOwn` for object iteration.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @alias each
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         * @see _.forEachRight
         * @example
         *
         * _.forEach([1, 2], function(value) {
         *   console.log(value);
         * });
         * // => Logs `1` then `2`.
         *
         * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'a' then 'b' (iteration order is not guaranteed).
         */
        function forEach(collection, iteratee) {
          var func = isArray$4(collection) ? arrayEach : baseEach$1;
          return func(collection, castFunction(iteratee));
        }

        // This file is autogenerated. It's used to publish ESM to npm.
        function _typeof$1(obj) {
          "@babel/helpers - typeof";

          return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          }, _typeof$1(obj);
        }

        // https://github.com/bgrins/TinyColor
        // Brian Grinstead, MIT License

        var trimLeft = /^\s+/;
        var trimRight = /\s+$/;
        function tinycolor(color, opts) {
          color = color ? color : "";
          opts = opts || {};

          // If input is already a tinycolor, return itself
          if (color instanceof tinycolor) {
            return color;
          }
          // If we are called as a function, call using new instead
          if (!(this instanceof tinycolor)) {
            return new tinycolor(color, opts);
          }
          var rgb = inputToRGB(color);
          this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
          this._gradientType = opts.gradientType;

          // Don't let the range of [0,255] come back in [0,1].
          // Potentially lose a little bit of precision here, but will fix issues where
          // .5 gets interpreted as half of the total, instead of half of 1
          // If it was supposed to be 128, this was already taken care of by `inputToRgb`
          if (this._r < 1) this._r = Math.round(this._r);
          if (this._g < 1) this._g = Math.round(this._g);
          if (this._b < 1) this._b = Math.round(this._b);
          this._ok = rgb.ok;
        }
        tinycolor.prototype = {
          isDark: function isDark() {
            return this.getBrightness() < 128;
          },
          isLight: function isLight() {
            return !this.isDark();
          },
          isValid: function isValid() {
            return this._ok;
          },
          getOriginalInput: function getOriginalInput() {
            return this._originalInput;
          },
          getFormat: function getFormat() {
            return this._format;
          },
          getAlpha: function getAlpha() {
            return this._a;
          },
          getBrightness: function getBrightness() {
            //http://www.w3.org/TR/AERT#color-contrast
            var rgb = this.toRgb();
            return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
          },
          getLuminance: function getLuminance() {
            //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
            var rgb = this.toRgb();
            var RsRGB, GsRGB, BsRGB, R, G, B;
            RsRGB = rgb.r / 255;
            GsRGB = rgb.g / 255;
            BsRGB = rgb.b / 255;
            if (RsRGB <= 0.03928) R = RsRGB / 12.92;else R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
            if (GsRGB <= 0.03928) G = GsRGB / 12.92;else G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
            if (BsRGB <= 0.03928) B = BsRGB / 12.92;else B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
            return 0.2126 * R + 0.7152 * G + 0.0722 * B;
          },
          setAlpha: function setAlpha(value) {
            this._a = boundAlpha(value);
            this._roundA = Math.round(100 * this._a) / 100;
            return this;
          },
          toHsv: function toHsv() {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            return {
              h: hsv.h * 360,
              s: hsv.s,
              v: hsv.v,
              a: this._a
            };
          },
          toHsvString: function toHsvString() {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            var h = Math.round(hsv.h * 360),
              s = Math.round(hsv.s * 100),
              v = Math.round(hsv.v * 100);
            return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
          },
          toHsl: function toHsl() {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            return {
              h: hsl.h * 360,
              s: hsl.s,
              l: hsl.l,
              a: this._a
            };
          },
          toHslString: function toHslString() {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            var h = Math.round(hsl.h * 360),
              s = Math.round(hsl.s * 100),
              l = Math.round(hsl.l * 100);
            return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
          },
          toHex: function toHex(allow3Char) {
            return rgbToHex(this._r, this._g, this._b, allow3Char);
          },
          toHexString: function toHexString(allow3Char) {
            return "#" + this.toHex(allow3Char);
          },
          toHex8: function toHex8(allow4Char) {
            return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
          },
          toHex8String: function toHex8String(allow4Char) {
            return "#" + this.toHex8(allow4Char);
          },
          toRgb: function toRgb() {
            return {
              r: Math.round(this._r),
              g: Math.round(this._g),
              b: Math.round(this._b),
              a: this._a
            };
          },
          toRgbString: function toRgbString() {
            return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
          },
          toPercentageRgb: function toPercentageRgb() {
            return {
              r: Math.round(bound01(this._r, 255) * 100) + "%",
              g: Math.round(bound01(this._g, 255) * 100) + "%",
              b: Math.round(bound01(this._b, 255) * 100) + "%",
              a: this._a
            };
          },
          toPercentageRgbString: function toPercentageRgbString() {
            return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
          },
          toName: function toName() {
            if (this._a === 0) {
              return "transparent";
            }
            if (this._a < 1) {
              return false;
            }
            return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
          },
          toFilter: function toFilter(secondColor) {
            var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
            var secondHex8String = hex8String;
            var gradientType = this._gradientType ? "GradientType = 1, " : "";
            if (secondColor) {
              var s = tinycolor(secondColor);
              secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
            }
            return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
          },
          toString: function toString(format) {
            var formatSet = !!format;
            format = format || this._format;
            var formattedString = false;
            var hasAlpha = this._a < 1 && this._a >= 0;
            var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
            if (needsAlphaFormat) {
              // Special case for "transparent", all other non-alpha formats
              // will return rgba when there is transparency.
              if (format === "name" && this._a === 0) {
                return this.toName();
              }
              return this.toRgbString();
            }
            if (format === "rgb") {
              formattedString = this.toRgbString();
            }
            if (format === "prgb") {
              formattedString = this.toPercentageRgbString();
            }
            if (format === "hex" || format === "hex6") {
              formattedString = this.toHexString();
            }
            if (format === "hex3") {
              formattedString = this.toHexString(true);
            }
            if (format === "hex4") {
              formattedString = this.toHex8String(true);
            }
            if (format === "hex8") {
              formattedString = this.toHex8String();
            }
            if (format === "name") {
              formattedString = this.toName();
            }
            if (format === "hsl") {
              formattedString = this.toHslString();
            }
            if (format === "hsv") {
              formattedString = this.toHsvString();
            }
            return formattedString || this.toHexString();
          },
          clone: function clone() {
            return tinycolor(this.toString());
          },
          _applyModification: function _applyModification(fn, args) {
            var color = fn.apply(null, [this].concat([].slice.call(args)));
            this._r = color._r;
            this._g = color._g;
            this._b = color._b;
            this.setAlpha(color._a);
            return this;
          },
          lighten: function lighten() {
            return this._applyModification(_lighten, arguments);
          },
          brighten: function brighten() {
            return this._applyModification(_brighten, arguments);
          },
          darken: function darken() {
            return this._applyModification(_darken, arguments);
          },
          desaturate: function desaturate() {
            return this._applyModification(_desaturate, arguments);
          },
          saturate: function saturate() {
            return this._applyModification(_saturate, arguments);
          },
          greyscale: function greyscale() {
            return this._applyModification(_greyscale, arguments);
          },
          spin: function spin() {
            return this._applyModification(_spin, arguments);
          },
          _applyCombination: function _applyCombination(fn, args) {
            return fn.apply(null, [this].concat([].slice.call(args)));
          },
          analogous: function analogous() {
            return this._applyCombination(_analogous, arguments);
          },
          complement: function complement() {
            return this._applyCombination(_complement, arguments);
          },
          monochromatic: function monochromatic() {
            return this._applyCombination(_monochromatic, arguments);
          },
          splitcomplement: function splitcomplement() {
            return this._applyCombination(_splitcomplement, arguments);
          },
          // Disabled until https://github.com/bgrins/TinyColor/issues/254
          // polyad: function (number) {
          //   return this._applyCombination(polyad, [number]);
          // },
          triad: function triad() {
            return this._applyCombination(polyad, [3]);
          },
          tetrad: function tetrad() {
            return this._applyCombination(polyad, [4]);
          }
        };

        // If input is an object, force 1 into "1.0" to handle ratios properly
        // String input requires "1.0" as input, so 1 will be treated as 1
        tinycolor.fromRatio = function (color, opts) {
          if (_typeof$1(color) == "object") {
            var newColor = {};
            for (var i in color) {
              if (color.hasOwnProperty(i)) {
                if (i === "a") {
                  newColor[i] = color[i];
                } else {
                  newColor[i] = convertToPercentage(color[i]);
                }
              }
            }
            color = newColor;
          }
          return tinycolor(color, opts);
        };

        // Given a string or object, convert that input to RGB
        // Possible string inputs:
        //
        //     "red"
        //     "#f00" or "f00"
        //     "#ff0000" or "ff0000"
        //     "#ff000000" or "ff000000"
        //     "rgb 255 0 0" or "rgb (255, 0, 0)"
        //     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
        //     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
        //     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
        //     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
        //     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
        //     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
        //
        function inputToRGB(color) {
          var rgb = {
            r: 0,
            g: 0,
            b: 0
          };
          var a = 1;
          var s = null;
          var v = null;
          var l = null;
          var ok = false;
          var format = false;
          if (typeof color == "string") {
            color = stringInputToObject(color);
          }
          if (_typeof$1(color) == "object") {
            if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
              rgb = rgbToRgb(color.r, color.g, color.b);
              ok = true;
              format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
            } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
              s = convertToPercentage(color.s);
              v = convertToPercentage(color.v);
              rgb = hsvToRgb(color.h, s, v);
              ok = true;
              format = "hsv";
            } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
              s = convertToPercentage(color.s);
              l = convertToPercentage(color.l);
              rgb = hslToRgb(color.h, s, l);
              ok = true;
              format = "hsl";
            }
            if (color.hasOwnProperty("a")) {
              a = color.a;
            }
          }
          a = boundAlpha(a);
          return {
            ok: ok,
            format: color.format || format,
            r: Math.min(255, Math.max(rgb.r, 0)),
            g: Math.min(255, Math.max(rgb.g, 0)),
            b: Math.min(255, Math.max(rgb.b, 0)),
            a: a
          };
        }

        // Conversion Functions
        // --------------------

        // `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
        // <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

        // `rgbToRgb`
        // Handle bounds / percentage checking to conform to CSS color spec
        // <http://www.w3.org/TR/css3-color/>
        // *Assumes:* r, g, b in [0, 255] or [0, 1]
        // *Returns:* { r, g, b } in [0, 255]
        function rgbToRgb(r, g, b) {
          return {
            r: bound01(r, 255) * 255,
            g: bound01(g, 255) * 255,
            b: bound01(b, 255) * 255
          };
        }

        // `rgbToHsl`
        // Converts an RGB color value to HSL.
        // *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
        // *Returns:* { h, s, l } in [0,1]
        function rgbToHsl(r, g, b) {
          r = bound01(r, 255);
          g = bound01(g, 255);
          b = bound01(b, 255);
          var max = Math.max(r, g, b),
            min = Math.min(r, g, b);
          var h,
            s,
            l = (max + min) / 2;
          if (max == min) {
            h = s = 0; // achromatic
          } else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
              case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
              case g:
                h = (b - r) / d + 2;
                break;
              case b:
                h = (r - g) / d + 4;
                break;
            }
            h /= 6;
          }
          return {
            h: h,
            s: s,
            l: l
          };
        }

        // `hslToRgb`
        // Converts an HSL color value to RGB.
        // *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
        // *Returns:* { r, g, b } in the set [0, 255]
        function hslToRgb(h, s, l) {
          var r, g, b;
          h = bound01(h, 360);
          s = bound01(s, 100);
          l = bound01(l, 100);
          function hue2rgb(p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
          }
          if (s === 0) {
            r = g = b = l; // achromatic
          } else {
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
          }
          return {
            r: r * 255,
            g: g * 255,
            b: b * 255
          };
        }

        // `rgbToHsv`
        // Converts an RGB color value to HSV
        // *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
        // *Returns:* { h, s, v } in [0,1]
        function rgbToHsv(r, g, b) {
          r = bound01(r, 255);
          g = bound01(g, 255);
          b = bound01(b, 255);
          var max = Math.max(r, g, b),
            min = Math.min(r, g, b);
          var h,
            s,
            v = max;
          var d = max - min;
          s = max === 0 ? 0 : d / max;
          if (max == min) {
            h = 0; // achromatic
          } else {
            switch (max) {
              case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
              case g:
                h = (b - r) / d + 2;
                break;
              case b:
                h = (r - g) / d + 4;
                break;
            }
            h /= 6;
          }
          return {
            h: h,
            s: s,
            v: v
          };
        }

        // `hsvToRgb`
        // Converts an HSV color value to RGB.
        // *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
        // *Returns:* { r, g, b } in the set [0, 255]
        function hsvToRgb(h, s, v) {
          h = bound01(h, 360) * 6;
          s = bound01(s, 100);
          v = bound01(v, 100);
          var i = Math.floor(h),
            f = h - i,
            p = v * (1 - s),
            q = v * (1 - f * s),
            t = v * (1 - (1 - f) * s),
            mod = i % 6,
            r = [v, q, p, p, t, v][mod],
            g = [t, v, v, q, p, p][mod],
            b = [p, p, t, v, v, q][mod];
          return {
            r: r * 255,
            g: g * 255,
            b: b * 255
          };
        }

        // `rgbToHex`
        // Converts an RGB color to hex
        // Assumes r, g, and b are contained in the set [0, 255]
        // Returns a 3 or 6 character hex
        function rgbToHex(r, g, b, allow3Char) {
          var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];

          // Return a 3 character hex if possible
          if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
            return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
          }
          return hex.join("");
        }

        // `rgbaToHex`
        // Converts an RGBA color plus alpha transparency to hex
        // Assumes r, g, b are contained in the set [0, 255] and
        // a in [0, 1]. Returns a 4 or 8 character rgba hex
        function rgbaToHex(r, g, b, a, allow4Char) {
          var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16)), pad2(convertDecimalToHex(a))];

          // Return a 4 character hex if possible
          if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
            return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
          }
          return hex.join("");
        }

        // `rgbaToArgbHex`
        // Converts an RGBA color to an ARGB Hex8 string
        // Rarely used, but required for "toFilter()"
        function rgbaToArgbHex(r, g, b, a) {
          var hex = [pad2(convertDecimalToHex(a)), pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
          return hex.join("");
        }

        // `equals`
        // Can be called with any tinycolor input
        tinycolor.equals = function (color1, color2) {
          if (!color1 || !color2) return false;
          return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
        };
        tinycolor.random = function () {
          return tinycolor.fromRatio({
            r: Math.random(),
            g: Math.random(),
            b: Math.random()
          });
        };

        // Modification Functions
        // ----------------------
        // Thanks to less.js for some of the basics here
        // <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

        function _desaturate(color, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var hsl = tinycolor(color).toHsl();
          hsl.s -= amount / 100;
          hsl.s = clamp01(hsl.s);
          return tinycolor(hsl);
        }
        function _saturate(color, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var hsl = tinycolor(color).toHsl();
          hsl.s += amount / 100;
          hsl.s = clamp01(hsl.s);
          return tinycolor(hsl);
        }
        function _greyscale(color) {
          return tinycolor(color).desaturate(100);
        }
        function _lighten(color, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var hsl = tinycolor(color).toHsl();
          hsl.l += amount / 100;
          hsl.l = clamp01(hsl.l);
          return tinycolor(hsl);
        }
        function _brighten(color, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var rgb = tinycolor(color).toRgb();
          rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
          rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
          rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
          return tinycolor(rgb);
        }
        function _darken(color, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var hsl = tinycolor(color).toHsl();
          hsl.l -= amount / 100;
          hsl.l = clamp01(hsl.l);
          return tinycolor(hsl);
        }

        // Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
        // Values outside of this range will be wrapped into this range.
        function _spin(color, amount) {
          var hsl = tinycolor(color).toHsl();
          var hue = (hsl.h + amount) % 360;
          hsl.h = hue < 0 ? 360 + hue : hue;
          return tinycolor(hsl);
        }

        // Combination Functions
        // ---------------------
        // Thanks to jQuery xColor for some of the ideas behind these
        // <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

        function _complement(color) {
          var hsl = tinycolor(color).toHsl();
          hsl.h = (hsl.h + 180) % 360;
          return tinycolor(hsl);
        }
        function polyad(color, number) {
          if (isNaN(number) || number <= 0) {
            throw new Error("Argument to polyad must be a positive number");
          }
          var hsl = tinycolor(color).toHsl();
          var result = [tinycolor(color)];
          var step = 360 / number;
          for (var i = 1; i < number; i++) {
            result.push(tinycolor({
              h: (hsl.h + i * step) % 360,
              s: hsl.s,
              l: hsl.l
            }));
          }
          return result;
        }
        function _splitcomplement(color) {
          var hsl = tinycolor(color).toHsl();
          var h = hsl.h;
          return [tinycolor(color), tinycolor({
            h: (h + 72) % 360,
            s: hsl.s,
            l: hsl.l
          }), tinycolor({
            h: (h + 216) % 360,
            s: hsl.s,
            l: hsl.l
          })];
        }
        function _analogous(color, results, slices) {
          results = results || 6;
          slices = slices || 30;
          var hsl = tinycolor(color).toHsl();
          var part = 360 / slices;
          var ret = [tinycolor(color)];
          for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results;) {
            hsl.h = (hsl.h + part) % 360;
            ret.push(tinycolor(hsl));
          }
          return ret;
        }
        function _monochromatic(color, results) {
          results = results || 6;
          var hsv = tinycolor(color).toHsv();
          var h = hsv.h,
            s = hsv.s,
            v = hsv.v;
          var ret = [];
          var modification = 1 / results;
          while (results--) {
            ret.push(tinycolor({
              h: h,
              s: s,
              v: v
            }));
            v = (v + modification) % 1;
          }
          return ret;
        }

        // Utility Functions
        // ---------------------

        tinycolor.mix = function (color1, color2, amount) {
          amount = amount === 0 ? 0 : amount || 50;
          var rgb1 = tinycolor(color1).toRgb();
          var rgb2 = tinycolor(color2).toRgb();
          var p = amount / 100;
          var rgba = {
            r: (rgb2.r - rgb1.r) * p + rgb1.r,
            g: (rgb2.g - rgb1.g) * p + rgb1.g,
            b: (rgb2.b - rgb1.b) * p + rgb1.b,
            a: (rgb2.a - rgb1.a) * p + rgb1.a
          };
          return tinycolor(rgba);
        };

        // Readability Functions
        // ---------------------
        // <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

        // `contrast`
        // Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
        tinycolor.readability = function (color1, color2) {
          var c1 = tinycolor(color1);
          var c2 = tinycolor(color2);
          return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
        };

        // `isReadable`
        // Ensure that foreground and background color combinations meet WCAG2 guidelines.
        // The third argument is an optional Object.
        //      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
        //      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
        // If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

        // *Example*
        //    tinycolor.isReadable("#000", "#111") => false
        //    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
        tinycolor.isReadable = function (color1, color2, wcag2) {
          var readability = tinycolor.readability(color1, color2);
          var wcag2Parms, out;
          out = false;
          wcag2Parms = validateWCAG2Parms(wcag2);
          switch (wcag2Parms.level + wcag2Parms.size) {
            case "AAsmall":
            case "AAAlarge":
              out = readability >= 4.5;
              break;
            case "AAlarge":
              out = readability >= 3;
              break;
            case "AAAsmall":
              out = readability >= 7;
              break;
          }
          return out;
        };

        // `mostReadable`
        // Given a base color and a list of possible foreground or background
        // colors for that base, returns the most readable color.
        // Optionally returns Black or White if the most readable color is unreadable.
        // *Example*
        //    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
        //    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
        //    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
        //    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
        tinycolor.mostReadable = function (baseColor, colorList, args) {
          var bestColor = null;
          var bestScore = 0;
          var readability;
          var includeFallbackColors, level, size;
          args = args || {};
          includeFallbackColors = args.includeFallbackColors;
          level = args.level;
          size = args.size;
          for (var i = 0; i < colorList.length; i++) {
            readability = tinycolor.readability(baseColor, colorList[i]);
            if (readability > bestScore) {
              bestScore = readability;
              bestColor = tinycolor(colorList[i]);
            }
          }
          if (tinycolor.isReadable(baseColor, bestColor, {
            level: level,
            size: size
          }) || !includeFallbackColors) {
            return bestColor;
          } else {
            args.includeFallbackColors = false;
            return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
          }
        };

        // Big List of Colors
        // ------------------
        // <https://www.w3.org/TR/css-color-4/#named-colors>
        var names = tinycolor.names = {
          aliceblue: "f0f8ff",
          antiquewhite: "faebd7",
          aqua: "0ff",
          aquamarine: "7fffd4",
          azure: "f0ffff",
          beige: "f5f5dc",
          bisque: "ffe4c4",
          black: "000",
          blanchedalmond: "ffebcd",
          blue: "00f",
          blueviolet: "8a2be2",
          brown: "a52a2a",
          burlywood: "deb887",
          burntsienna: "ea7e5d",
          cadetblue: "5f9ea0",
          chartreuse: "7fff00",
          chocolate: "d2691e",
          coral: "ff7f50",
          cornflowerblue: "6495ed",
          cornsilk: "fff8dc",
          crimson: "dc143c",
          cyan: "0ff",
          darkblue: "00008b",
          darkcyan: "008b8b",
          darkgoldenrod: "b8860b",
          darkgray: "a9a9a9",
          darkgreen: "006400",
          darkgrey: "a9a9a9",
          darkkhaki: "bdb76b",
          darkmagenta: "8b008b",
          darkolivegreen: "556b2f",
          darkorange: "ff8c00",
          darkorchid: "9932cc",
          darkred: "8b0000",
          darksalmon: "e9967a",
          darkseagreen: "8fbc8f",
          darkslateblue: "483d8b",
          darkslategray: "2f4f4f",
          darkslategrey: "2f4f4f",
          darkturquoise: "00ced1",
          darkviolet: "9400d3",
          deeppink: "ff1493",
          deepskyblue: "00bfff",
          dimgray: "696969",
          dimgrey: "696969",
          dodgerblue: "1e90ff",
          firebrick: "b22222",
          floralwhite: "fffaf0",
          forestgreen: "228b22",
          fuchsia: "f0f",
          gainsboro: "dcdcdc",
          ghostwhite: "f8f8ff",
          gold: "ffd700",
          goldenrod: "daa520",
          gray: "808080",
          green: "008000",
          greenyellow: "adff2f",
          grey: "808080",
          honeydew: "f0fff0",
          hotpink: "ff69b4",
          indianred: "cd5c5c",
          indigo: "4b0082",
          ivory: "fffff0",
          khaki: "f0e68c",
          lavender: "e6e6fa",
          lavenderblush: "fff0f5",
          lawngreen: "7cfc00",
          lemonchiffon: "fffacd",
          lightblue: "add8e6",
          lightcoral: "f08080",
          lightcyan: "e0ffff",
          lightgoldenrodyellow: "fafad2",
          lightgray: "d3d3d3",
          lightgreen: "90ee90",
          lightgrey: "d3d3d3",
          lightpink: "ffb6c1",
          lightsalmon: "ffa07a",
          lightseagreen: "20b2aa",
          lightskyblue: "87cefa",
          lightslategray: "789",
          lightslategrey: "789",
          lightsteelblue: "b0c4de",
          lightyellow: "ffffe0",
          lime: "0f0",
          limegreen: "32cd32",
          linen: "faf0e6",
          magenta: "f0f",
          maroon: "800000",
          mediumaquamarine: "66cdaa",
          mediumblue: "0000cd",
          mediumorchid: "ba55d3",
          mediumpurple: "9370db",
          mediumseagreen: "3cb371",
          mediumslateblue: "7b68ee",
          mediumspringgreen: "00fa9a",
          mediumturquoise: "48d1cc",
          mediumvioletred: "c71585",
          midnightblue: "191970",
          mintcream: "f5fffa",
          mistyrose: "ffe4e1",
          moccasin: "ffe4b5",
          navajowhite: "ffdead",
          navy: "000080",
          oldlace: "fdf5e6",
          olive: "808000",
          olivedrab: "6b8e23",
          orange: "ffa500",
          orangered: "ff4500",
          orchid: "da70d6",
          palegoldenrod: "eee8aa",
          palegreen: "98fb98",
          paleturquoise: "afeeee",
          palevioletred: "db7093",
          papayawhip: "ffefd5",
          peachpuff: "ffdab9",
          peru: "cd853f",
          pink: "ffc0cb",
          plum: "dda0dd",
          powderblue: "b0e0e6",
          purple: "800080",
          rebeccapurple: "663399",
          red: "f00",
          rosybrown: "bc8f8f",
          royalblue: "4169e1",
          saddlebrown: "8b4513",
          salmon: "fa8072",
          sandybrown: "f4a460",
          seagreen: "2e8b57",
          seashell: "fff5ee",
          sienna: "a0522d",
          silver: "c0c0c0",
          skyblue: "87ceeb",
          slateblue: "6a5acd",
          slategray: "708090",
          slategrey: "708090",
          snow: "fffafa",
          springgreen: "00ff7f",
          steelblue: "4682b4",
          tan: "d2b48c",
          teal: "008080",
          thistle: "d8bfd8",
          tomato: "ff6347",
          turquoise: "40e0d0",
          violet: "ee82ee",
          wheat: "f5deb3",
          white: "fff",
          whitesmoke: "f5f5f5",
          yellow: "ff0",
          yellowgreen: "9acd32"
        };

        // Make it easy to access colors via `hexNames[hex]`
        var hexNames = tinycolor.hexNames = flip(names);

        // Utilities
        // ---------

        // `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
        function flip(o) {
          var flipped = {};
          for (var i in o) {
            if (o.hasOwnProperty(i)) {
              flipped[o[i]] = i;
            }
          }
          return flipped;
        }

        // Return a valid alpha value [0,1] with all invalid values being set to 1
        function boundAlpha(a) {
          a = parseFloat(a);
          if (isNaN(a) || a < 0 || a > 1) {
            a = 1;
          }
          return a;
        }

        // Take input from [0, n] and return it as [0, 1]
        function bound01(n, max) {
          if (isOnePointZero(n)) n = "100%";
          var processPercent = isPercentage(n);
          n = Math.min(max, Math.max(0, parseFloat(n)));

          // Automatically convert percentage into number
          if (processPercent) {
            n = parseInt(n * max, 10) / 100;
          }

          // Handle floating point rounding errors
          if (Math.abs(n - max) < 0.000001) {
            return 1;
          }

          // Convert into [0, 1] range if it isn't already
          return n % max / parseFloat(max);
        }

        // Force a number between 0 and 1
        function clamp01(val) {
          return Math.min(1, Math.max(0, val));
        }

        // Parse a base-16 hex value into a base-10 integer
        function parseIntFromHex(val) {
          return parseInt(val, 16);
        }

        // Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
        // <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
        function isOnePointZero(n) {
          return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
        }

        // Check to see if string passed in is a percentage
        function isPercentage(n) {
          return typeof n === "string" && n.indexOf("%") != -1;
        }

        // Force a hex value to have 2 characters
        function pad2(c) {
          return c.length == 1 ? "0" + c : "" + c;
        }

        // Replace a decimal with it's percentage value
        function convertToPercentage(n) {
          if (n <= 1) {
            n = n * 100 + "%";
          }
          return n;
        }

        // Converts a decimal to a hex value
        function convertDecimalToHex(d) {
          return Math.round(parseFloat(d) * 255).toString(16);
        }
        // Converts a hex value to a decimal
        function convertHexToDecimal(h) {
          return parseIntFromHex(h) / 255;
        }
        var matchers = function () {
          // <http://www.w3.org/TR/css3-values/#integers>
          var CSS_INTEGER = "[-\\+]?\\d+%?";

          // <http://www.w3.org/TR/css3-values/#number-value>
          var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

          // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
          var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

          // Actual matching.
          // Parentheses and commas are optional, but not required.
          // Whitespace can take the place of commas or opening paren
          var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
          var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
          return {
            CSS_UNIT: new RegExp(CSS_UNIT),
            rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
            rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
            hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
            hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
            hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
            hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
            hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
            hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
          };
        }();

        // `isValidCSSUnit`
        // Take in a single string / number and check to see if it looks like a CSS unit
        // (see `matchers` above for definition).
        function isValidCSSUnit(color) {
          return !!matchers.CSS_UNIT.exec(color);
        }

        // `stringInputToObject`
        // Permissive string parsing.  Take in a number of formats, and output an object
        // based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
        function stringInputToObject(color) {
          color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
          var named = false;
          if (names[color]) {
            color = names[color];
            named = true;
          } else if (color == "transparent") {
            return {
              r: 0,
              g: 0,
              b: 0,
              a: 0,
              format: "name"
            };
          }

          // Try to match string input using regular expressions.
          // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
          // Just return an object and let the conversion functions handle that.
          // This way the result will be the same whether the tinycolor is initialized with string or object.
          var match;
          if (match = matchers.rgb.exec(color)) {
            return {
              r: match[1],
              g: match[2],
              b: match[3]
            };
          }
          if (match = matchers.rgba.exec(color)) {
            return {
              r: match[1],
              g: match[2],
              b: match[3],
              a: match[4]
            };
          }
          if (match = matchers.hsl.exec(color)) {
            return {
              h: match[1],
              s: match[2],
              l: match[3]
            };
          }
          if (match = matchers.hsla.exec(color)) {
            return {
              h: match[1],
              s: match[2],
              l: match[3],
              a: match[4]
            };
          }
          if (match = matchers.hsv.exec(color)) {
            return {
              h: match[1],
              s: match[2],
              v: match[3]
            };
          }
          if (match = matchers.hsva.exec(color)) {
            return {
              h: match[1],
              s: match[2],
              v: match[3],
              a: match[4]
            };
          }
          if (match = matchers.hex8.exec(color)) {
            return {
              r: parseIntFromHex(match[1]),
              g: parseIntFromHex(match[2]),
              b: parseIntFromHex(match[3]),
              a: convertHexToDecimal(match[4]),
              format: named ? "name" : "hex8"
            };
          }
          if (match = matchers.hex6.exec(color)) {
            return {
              r: parseIntFromHex(match[1]),
              g: parseIntFromHex(match[2]),
              b: parseIntFromHex(match[3]),
              format: named ? "name" : "hex"
            };
          }
          if (match = matchers.hex4.exec(color)) {
            return {
              r: parseIntFromHex(match[1] + "" + match[1]),
              g: parseIntFromHex(match[2] + "" + match[2]),
              b: parseIntFromHex(match[3] + "" + match[3]),
              a: convertHexToDecimal(match[4] + "" + match[4]),
              format: named ? "name" : "hex8"
            };
          }
          if (match = matchers.hex3.exec(color)) {
            return {
              r: parseIntFromHex(match[1] + "" + match[1]),
              g: parseIntFromHex(match[2] + "" + match[2]),
              b: parseIntFromHex(match[3] + "" + match[3]),
              format: named ? "name" : "hex"
            };
          }
          return false;
        }
        function validateWCAG2Parms(parms) {
          // return valid WCAG2 parms for isReadable.
          // If input parms are invalid, return {"level":"AA", "size":"small"}
          var level, size;
          parms = parms || {
            level: "AA",
            size: "small"
          };
          level = (parms.level || "AA").toUpperCase();
          size = (parms.size || "small").toLowerCase();
          if (level !== "AA" && level !== "AAA") {
            level = "AA";
          }
          if (size !== "small" && size !== "large") {
            size = "small";
          }
          return {
            level: level,
            size: size
          };
        }
        var simpleCheckForValidColor = function simpleCheckForValidColor(data) {
          var keysToCheck = ['r', 'g', 'b', 'a', 'h', 's', 'l', 'v'];
          var checked = 0;
          var passed = 0;
          forEach(keysToCheck, function (letter) {
            if (data[letter]) {
              checked += 1;
              if (!isNaN(data[letter])) {
                passed += 1;
              }
              if (letter === 's' || letter === 'l') {
                var percentPatt = /^\d+%$/;
                if (percentPatt.test(data[letter])) {
                  passed += 1;
                }
              }
            }
          });
          return checked === passed ? data : false;
        };
        var toState = function toState(data, oldHue) {
          var color = data.hex ? tinycolor(data.hex) : tinycolor(data);
          var hsl = color.toHsl();
          var hsv = color.toHsv();
          var rgb = color.toRgb();
          var hex = color.toHex();
          if (hsl.s === 0) {
            hsl.h = oldHue || 0;
            hsv.h = oldHue || 0;
          }
          var transparent = hex === '000000' && rgb.a === 0;
          return {
            hsl: hsl,
            hex: transparent ? 'transparent' : '#' + hex,
            rgb: rgb,
            hsv: hsv,
            oldHue: data.h || oldHue || hsl.h,
            source: data.source
          };
        };
        var isValidHex = function isValidHex(hex) {
          if (hex === 'transparent') {
            return true;
          }
          // disable hex4 and hex8
          var lh = String(hex).charAt(0) === '#' ? 1 : 0;
          return hex.length !== 4 + lh && hex.length < 7 + lh && tinycolor(hex).isValid();
        };
        var getContrastingColor = function getContrastingColor(data) {
          if (!data) {
            return '#fff';
          }
          var col = toState(data);
          if (col.hex === 'transparent') {
            return 'rgba(0,0,0,0.4)';
          }
          var yiq = (col.rgb.r * 299 + col.rgb.g * 587 + col.rgb.b * 114) / 1000;
          return yiq >= 128 ? '#000' : '#fff';
        };
        var isvalidColorString = function isvalidColorString(string, type) {
          var stringWithoutDegree = string.replace('°', '');
          return tinycolor(type + ' (' + stringWithoutDegree + ')')._ok;
        };
        var _extends$9 = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        var _createClass$3 = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        function _classCallCheck$3(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn$3(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self;
        }
        function _inherits$3(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var ColorWrap = function ColorWrap(Picker) {
          var ColorPicker = function (_ref) {
            _inherits$3(ColorPicker, _ref);
            function ColorPicker(props) {
              _classCallCheck$3(this, ColorPicker);
              var _this = _possibleConstructorReturn$3(this, (ColorPicker.__proto__ || Object.getPrototypeOf(ColorPicker)).call(this));
              _this.handleChange = function (data, event) {
                var isValidColor = simpleCheckForValidColor(data);
                if (isValidColor) {
                  var colors = toState(data, data.h || _this.state.oldHue);
                  _this.setState(colors);
                  _this.props.onChangeComplete && _this.debounce(_this.props.onChangeComplete, colors, event);
                  _this.props.onChange && _this.props.onChange(colors, event);
                }
              };
              _this.handleSwatchHover = function (data, event) {
                var isValidColor = simpleCheckForValidColor(data);
                if (isValidColor) {
                  var colors = toState(data, data.h || _this.state.oldHue);
                  _this.props.onSwatchHover && _this.props.onSwatchHover(colors, event);
                }
              };
              _this.state = _extends$9({}, toState(props.color, 0));
              _this.debounce = debounce$2(function (fn, data, event) {
                fn(data, event);
              }, 100);
              return _this;
            }
            _createClass$3(ColorPicker, [{
              key: 'render',
              value: function render() {
                var optionalEvents = {};
                if (this.props.onSwatchHover) {
                  optionalEvents.onSwatchHover = this.handleSwatchHover;
                }
                return React.createElement(Picker, _extends$9({}, this.props, this.state, {
                  onChange: this.handleChange
                }, optionalEvents));
              }
            }], [{
              key: 'getDerivedStateFromProps',
              value: function getDerivedStateFromProps(nextProps, state) {
                return _extends$9({}, toState(nextProps.color, state.oldHue));
              }
            }]);
            return ColorPicker;
          }(reactExports.PureComponent || reactExports.Component);
          ColorPicker.propTypes = _extends$9({}, Picker.propTypes);
          ColorPicker.defaultProps = _extends$9({}, Picker.defaultProps, {
            color: {
              h: 250,
              s: 0.50,
              l: 0.20,
              a: 1
            }
          });
          return ColorPicker;
        };
        var _extends$8 = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        var _createClass$2 = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        function _classCallCheck$2(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn$2(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self;
        }
        function _inherits$2(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var handleFocus = function handleFocus(Component) {
          var Span = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'span';
          return function (_React$Component) {
            _inherits$2(Focus, _React$Component);
            function Focus() {
              var _ref;
              var _temp, _this, _ret;
              _classCallCheck$2(this, Focus);
              for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return _ret = (_temp = (_this = _possibleConstructorReturn$2(this, (_ref = Focus.__proto__ || Object.getPrototypeOf(Focus)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
                focus: false
              }, _this.handleFocus = function () {
                return _this.setState({
                  focus: true
                });
              }, _this.handleBlur = function () {
                return _this.setState({
                  focus: false
                });
              }, _temp), _possibleConstructorReturn$2(_this, _ret);
            }
            _createClass$2(Focus, [{
              key: 'render',
              value: function render() {
                return React.createElement(Span, {
                  onFocus: this.handleFocus,
                  onBlur: this.handleBlur
                }, React.createElement(Component, _extends$8({}, this.props, this.state)));
              }
            }]);
            return Focus;
          }(React.Component);
        };
        var _extends$7 = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        var ENTER = 13;
        var Swatch = function Swatch(_ref) {
          var color = _ref.color,
            style = _ref.style,
            _ref$onClick = _ref.onClick,
            onClick = _ref$onClick === undefined ? function () {} : _ref$onClick,
            onHover = _ref.onHover,
            _ref$title = _ref.title,
            title = _ref$title === undefined ? color : _ref$title,
            children = _ref.children,
            focus = _ref.focus,
            _ref$focusStyle = _ref.focusStyle,
            focusStyle = _ref$focusStyle === undefined ? {} : _ref$focusStyle;
          var transparent = color === 'transparent';
          var styles = _default$a({
            default: {
              swatch: _extends$7({
                background: color,
                height: '100%',
                width: '100%',
                cursor: 'pointer',
                position: 'relative',
                outline: 'none'
              }, style, focus ? focusStyle : {})
            }
          });
          var handleClick = function handleClick(e) {
            return onClick(color, e);
          };
          var handleKeyDown = function handleKeyDown(e) {
            return e.keyCode === ENTER && onClick(color, e);
          };
          var handleHover = function handleHover(e) {
            return onHover(color, e);
          };
          var optionalEvents = {};
          if (onHover) {
            optionalEvents.onMouseOver = handleHover;
          }
          return React.createElement('div', _extends$7({
            style: styles.swatch,
            onClick: handleClick,
            title: title,
            tabIndex: 0,
            onKeyDown: handleKeyDown
          }, optionalEvents), children, transparent && React.createElement(Checkboard, {
            borderRadius: styles.swatch.borderRadius,
            boxShadow: 'inset 0 0 0 1px rgba(0,0,0,0.1)'
          }));
        };
        const Swatch$1 = handleFocus(Swatch);
        var AlphaPointer = function AlphaPointer(_ref) {
          var direction = _ref.direction;
          var styles = _default$a({
            'default': {
              picker: {
                width: '18px',
                height: '18px',
                borderRadius: '50%',
                transform: 'translate(-9px, -1px)',
                backgroundColor: 'rgb(248, 248, 248)',
                boxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.37)'
              }
            },
            'vertical': {
              picker: {
                transform: 'translate(-3px, -9px)'
              }
            }
          }, {
            vertical: direction === 'vertical'
          });
          return React.createElement('div', {
            style: styles.picker
          });
        };
        var _extends$6 = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        var AlphaPicker = function AlphaPicker(_ref) {
          var rgb = _ref.rgb,
            hsl = _ref.hsl,
            width = _ref.width,
            height = _ref.height,
            onChange = _ref.onChange,
            direction = _ref.direction,
            style = _ref.style,
            renderers = _ref.renderers,
            pointer = _ref.pointer,
            _ref$className = _ref.className,
            className = _ref$className === undefined ? '' : _ref$className;
          var styles = _default$a({
            'default': {
              picker: {
                position: 'relative',
                width: width,
                height: height
              },
              alpha: {
                radius: '2px',
                style: style
              }
            }
          });
          return React.createElement('div', {
            style: styles.picker,
            className: 'alpha-picker ' + className
          }, React.createElement(Alpha, _extends$6({}, styles.alpha, {
            rgb: rgb,
            hsl: hsl,
            pointer: pointer,
            renderers: renderers,
            onChange: onChange,
            direction: direction
          })));
        };
        AlphaPicker.defaultProps = {
          width: '316px',
          height: '16px',
          direction: 'horizontal',
          pointer: AlphaPointer
        };
        ColorWrap(AlphaPicker);

        /**
         * A specialized version of `_.map` for arrays without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function arrayMap$2(array, iteratee) {
          var index = -1,
            length = array == null ? 0 : array.length,
            result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }

        /** Used to stand-in for `undefined` hash values. */
        var HASH_UNDEFINED = '__lodash_hash_undefined__';

        /**
         * Adds `value` to the array cache.
         *
         * @private
         * @name add
         * @memberOf SetCache
         * @alias push
         * @param {*} value The value to cache.
         * @returns {Object} Returns the cache instance.
         */
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }

        /**
         * Checks if `value` is in the array cache.
         *
         * @private
         * @name has
         * @memberOf SetCache
         * @param {*} value The value to search for.
         * @returns {number} Returns `true` if `value` is found, else `false`.
         */
        function setCacheHas(value) {
          return this.__data__.has(value);
        }

        /**
         *
         * Creates an array cache object to store unique values.
         *
         * @private
         * @constructor
         * @param {Array} [values] The values to cache.
         */
        function SetCache(values) {
          var index = -1,
            length = values == null ? 0 : values.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values[index]);
          }
        }

        // Add methods to `SetCache`.
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;

        /**
         * A specialized version of `_.some` for arrays without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         */
        function arraySome(array, predicate) {
          var index = -1,
            length = array == null ? 0 : array.length;
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }

        /**
         * Checks if a `cache` value for `key` exists.
         *
         * @private
         * @param {Object} cache The cache to query.
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function cacheHas(cache, key) {
          return cache.has(key);
        }

        /** Used to compose bitmasks for value comparisons. */
        var COMPARE_PARTIAL_FLAG$5 = 1,
          COMPARE_UNORDERED_FLAG$3 = 2;

        /**
         * A specialized version of `baseIsEqualDeep` for arrays with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Array} array The array to compare.
         * @param {Array} other The other array to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `array` and `other` objects.
         * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
         */
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,
            arrLength = array.length,
            othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          // Check that cyclic values are equal.
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1,
            result = true,
            seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : undefined;
          stack.set(array, other);
          stack.set(other, array);

          // Ignore non-index properties.
          while (++index < arrLength) {
            var arrValue = array[index],
              othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined) {
              if (compared) {
                continue;
              }
              result = false;
              break;
            }
            // Recursively compare arrays (susceptible to call stack limits).
            if (seen) {
              if (!arraySome(other, function (othValue, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result = false;
              break;
            }
          }
          stack['delete'](array);
          stack['delete'](other);
          return result;
        }

        /**
         * Converts `map` to its key-value pairs.
         *
         * @private
         * @param {Object} map The map to convert.
         * @returns {Array} Returns the key-value pairs.
         */
        function mapToArray(map) {
          var index = -1,
            result = Array(map.size);
          map.forEach(function (value, key) {
            result[++index] = [key, value];
          });
          return result;
        }

        /**
         * Converts `set` to an array of its values.
         *
         * @private
         * @param {Object} set The set to convert.
         * @returns {Array} Returns the values.
         */
        function setToArray(set) {
          var index = -1,
            result = Array(set.size);
          set.forEach(function (value) {
            result[++index] = value;
          });
          return result;
        }

        /** Used to compose bitmasks for value comparisons. */
        var COMPARE_PARTIAL_FLAG$4 = 1,
          COMPARE_UNORDERED_FLAG$2 = 2;

        /** `Object#toString` result references. */
        var boolTag = '[object Boolean]',
          dateTag = '[object Date]',
          errorTag = '[object Error]',
          mapTag$1 = '[object Map]',
          numberTag = '[object Number]',
          regexpTag = '[object RegExp]',
          setTag$1 = '[object Set]',
          stringTag = '[object String]',
          symbolTag = '[object Symbol]';
        var arrayBufferTag = '[object ArrayBuffer]',
          dataViewTag$1 = '[object DataView]';

        /** Used to convert symbols to primitives and strings. */
        var symbolProto$1 = Symbol$3 ? Symbol$3.prototype : undefined,
          symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;

        /**
         * A specialized version of `baseIsEqualDeep` for comparing objects of
         * the same `toStringTag`.
         *
         * **Note:** This function only supports comparing values with tags of
         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {string} tag The `toStringTag` of the objects to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag$1:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              // Coerce booleans to `1` or `0` and dates to milliseconds.
              // Invalid dates are coerced to `NaN`.
              return eq$2(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              // Coerce regexes to strings and treat strings, primitives and objects,
              // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
              // for more details.
              return object == other + '';
            case mapTag$1:
              var convert = mapToArray;
            case setTag$1:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              // Assume cyclic values are equal.
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG$2;

              // Recursively compare objects (susceptible to call stack limits).
              stack.set(object, other);
              var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack['delete'](object);
              return result;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }

        /**
         * Appends the elements of `values` to `array`.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {Array} values The values to append.
         * @returns {Array} Returns `array`.
         */
        function arrayPush$1(array, values) {
          var index = -1,
            length = values.length,
            offset = array.length;
          while (++index < length) {
            array[offset + index] = values[index];
          }
          return array;
        }

        /**
         * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
         * `keysFunc` and `symbolsFunc` to get the enumerable property names and
         * symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @param {Function} symbolsFunc The function to get the symbols of `object`.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result = keysFunc(object);
          return isArray$4(object) ? result : arrayPush$1(result, symbolsFunc(object));
        }

        /**
         * A specialized version of `_.filter` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         */
        function arrayFilter(array, predicate) {
          var index = -1,
            length = array == null ? 0 : array.length,
            resIndex = 0,
            result = [];
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }

        /**
         * This method returns a new empty array.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {Array} Returns the new empty array.
         * @example
         *
         * var arrays = _.times(2, _.stubArray);
         *
         * console.log(arrays);
         * // => [[], []]
         *
         * console.log(arrays[0] === arrays[1]);
         * // => false
         */
        function stubArray() {
          return [];
        }

        /** Used for built-in method references. */
        var objectProto$2 = Object.prototype;

        /** Built-in value references. */
        var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeGetSymbols = Object.getOwnPropertySymbols;

        /**
         * Creates an array of the own enumerable symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of symbols.
         */
        var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
          if (object == null) {
            return [];
          }
          object = Object(object);
          return arrayFilter(nativeGetSymbols(object), function (symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        const getSymbols$1 = getSymbols;

        /**
         * Creates an array of own enumerable property names and symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys$1, getSymbols$1);
        }

        /** Used to compose bitmasks for value comparisons. */
        var COMPARE_PARTIAL_FLAG$3 = 1;

        /** Used for built-in method references. */
        var objectProto$1 = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

        /**
         * A specialized version of `baseIsEqualDeep` for objects with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
            objProps = getAllKeys(object),
            objLength = objProps.length,
            othProps = getAllKeys(other),
            othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
              return false;
            }
          }
          // Check that cyclic values are equal.
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key],
              othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            // Recursively compare objects (susceptible to call stack limits).
            if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result = false;
              break;
            }
            skipCtor || (skipCtor = key == 'constructor');
          }
          if (result && !skipCtor) {
            var objCtor = object.constructor,
              othCtor = other.constructor;

            // Non `Object` object instances with different constructors are not equal.
            if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
              result = false;
            }
          }
          stack['delete'](object);
          stack['delete'](other);
          return result;
        }

        /* Built-in method references that are verified to be native. */
        var DataView = getNative(root$2, 'DataView');
        const DataView$1 = DataView;

        /* Built-in method references that are verified to be native. */
        var Promise$1 = getNative(root$2, 'Promise');
        const Promise$2 = Promise$1;

        /* Built-in method references that are verified to be native. */
        var Set$1 = getNative(root$2, 'Set');
        const Set$2 = Set$1;

        /* Built-in method references that are verified to be native. */
        var WeakMap$1 = getNative(root$2, 'WeakMap');
        const WeakMap$2 = WeakMap$1;

        /** `Object#toString` result references. */
        var mapTag = '[object Map]',
          objectTag$1 = '[object Object]',
          promiseTag = '[object Promise]',
          setTag = '[object Set]',
          weakMapTag = '[object WeakMap]';
        var dataViewTag = '[object DataView]';

        /** Used to detect maps, sets, and weakmaps. */
        var dataViewCtorString = toSource(DataView$1),
          mapCtorString = toSource(Map$2),
          promiseCtorString = toSource(Promise$2),
          setCtorString = toSource(Set$2),
          weakMapCtorString = toSource(WeakMap$2);

        /**
         * Gets the `toStringTag` of `value`.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */
        var getTag = baseGetTag;

        // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
        if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag || Map$2 && getTag(new Map$2()) != mapTag || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag) {
          getTag = function (value) {
            var result = baseGetTag(value),
              Ctor = result == objectTag$1 ? value.constructor : undefined,
              ctorString = Ctor ? toSource(Ctor) : '';
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result;
          };
        }
        const getTag$1 = getTag;

        /** Used to compose bitmasks for value comparisons. */
        var COMPARE_PARTIAL_FLAG$2 = 1;

        /** `Object#toString` result references. */
        var argsTag = '[object Arguments]',
          arrayTag = '[object Array]',
          objectTag = '[object Object]';

        /** Used for built-in method references. */
        var objectProto = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /**
         * A specialized version of `baseIsEqual` for arrays and objects which performs
         * deep comparisons and tracks traversed objects enabling objects with circular
         * references to be compared.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} [stack] Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray$4(object),
            othIsArr = isArray$4(other),
            objTag = objIsArr ? arrayTag : getTag$1(object),
            othTag = othIsArr ? arrayTag : getTag$1(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag,
            othIsObj = othTag == objectTag,
            isSameTag = objTag == othTag;
          if (isSameTag && isBuffer$2(object)) {
            if (!isBuffer$2(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack$1());
            return objIsArr || isTypedArray$2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
              othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object,
                othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack$1());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack$1());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }

        /**
         * The base implementation of `_.isEqual` which supports partial comparisons
         * and tracks traversed objects.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @param {boolean} bitmask The bitmask flags.
         *  1 - Unordered comparison
         *  2 - Partial comparison
         * @param {Function} [customizer] The function to customize comparisons.
         * @param {Object} [stack] Tracks traversed `value` and `other` objects.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         */
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike$1(value) && !isObjectLike$1(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }

        /** Used to compose bitmasks for value comparisons. */
        var COMPARE_PARTIAL_FLAG$1 = 1,
          COMPARE_UNORDERED_FLAG$1 = 2;

        /**
         * The base implementation of `_.isMatch` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @param {Array} matchData The property names, values, and compare flags to match.
         * @param {Function} [customizer] The function to customize comparisons.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         */
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length,
            length = index,
            noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0],
              objValue = object[key],
              srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack$1();
              if (customizer) {
                var result = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
                return false;
              }
            }
          }
          return true;
        }

        /**
         * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` if suitable for strict
         *  equality comparisons, else `false`.
         */
        function isStrictComparable(value) {
          return value === value && !isObject$a(value);
        }

        /**
         * Gets the property names, values, and compare flags of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the match data of `object`.
         */
        function getMatchData(object) {
          var result = keys$1(object),
            length = result.length;
          while (length--) {
            var key = result[length],
              value = object[key];
            result[length] = [key, value, isStrictComparable(value)];
          }
          return result;
        }

        /**
         * A specialized version of `matchesProperty` for source values suitable
         * for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {string} key The key of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         */
        function matchesStrictComparable(key, srcValue) {
          return function (object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
          };
        }

        /**
         * The base implementation of `_.matches` which doesn't clone `source`.
         *
         * @private
         * @param {Object} source The object of property values to match.
         * @returns {Function} Returns the new spec function.
         */
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function (object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }

        /** Used to match property names within property paths. */
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
          reIsPlainProp = /^\w*$/;

        /**
         * Checks if `value` is a property name and not a property path.
         *
         * @private
         * @param {*} value The value to check.
         * @param {Object} [object] The object to query keys on.
         * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
         */
        function isKey(value, object) {
          if (isArray$4(value)) {
            return false;
          }
          var type = typeof value;
          if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol$1(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
        }

        /** Error message constants. */
        var FUNC_ERROR_TEXT$1 = 'Expected a function';

        /**
         * Creates a function that memoizes the result of `func`. If `resolver` is
         * provided, it determines the cache key for storing the result based on the
         * arguments provided to the memoized function. By default, the first argument
         * provided to the memoized function is used as the map cache key. The `func`
         * is invoked with the `this` binding of the memoized function.
         *
         * **Note:** The cache is exposed as the `cache` property on the memoized
         * function. Its creation may be customized by replacing the `_.memoize.Cache`
         * constructor with one whose instances implement the
         * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
         * method interface of `clear`, `delete`, `get`, `has`, and `set`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to have its output memoized.
         * @param {Function} [resolver] The function to resolve the cache key.
         * @returns {Function} Returns the new memoized function.
         * @example
         *
         * var object = { 'a': 1, 'b': 2 };
         * var other = { 'c': 3, 'd': 4 };
         *
         * var values = _.memoize(_.values);
         * values(object);
         * // => [1, 2]
         *
         * values(other);
         * // => [3, 4]
         *
         * object.a = 2;
         * values(object);
         * // => [1, 2]
         *
         * // Modify the result cache.
         * values.cache.set(object, ['a', 'b']);
         * values(object);
         * // => ['a', 'b']
         *
         * // Replace `_.memoize.Cache`.
         * _.memoize.Cache = WeakMap;
         */
        function memoize(func, resolver) {
          if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT$1);
          }
          var memoized = function () {
            var args = arguments,
              key = resolver ? resolver.apply(this, args) : args[0],
              cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, args);
            memoized.cache = cache.set(key, result) || cache;
            return result;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }

        // Expose `MapCache`.
        memoize.Cache = MapCache;

        /** Used as the maximum memoize cache size. */
        var MAX_MEMOIZE_SIZE = 500;

        /**
         * A specialized version of `_.memoize` which clears the memoized function's
         * cache when it exceeds `MAX_MEMOIZE_SIZE`.
         *
         * @private
         * @param {Function} func The function to have its output memoized.
         * @returns {Function} Returns the new memoized function.
         */
        function memoizeCapped(func) {
          var result = memoize(func, function (key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result.cache;
          return result;
        }

        /** Used to match property names within property paths. */
        var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

        /** Used to match backslashes in property paths. */
        var reEscapeChar = /\\(\\)?/g;

        /**
         * Converts `string` to a property path array.
         *
         * @private
         * @param {string} string The string to convert.
         * @returns {Array} Returns the property path array.
         */
        var stringToPath = memoizeCapped(function (string) {
          var result = [];
          if (string.charCodeAt(0) === 46 /* . */) {
            result.push('');
          }
          string.replace(rePropName, function (match, number, quote, subString) {
            result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
          });
          return result;
        });
        const stringToPath$1 = stringToPath;

        /** Used as references for various `Number` constants. */
        var INFINITY$2 = 1 / 0;

        /** Used to convert symbols to primitives and strings. */
        var symbolProto = Symbol$3 ? Symbol$3.prototype : undefined,
          symbolToString = symbolProto ? symbolProto.toString : undefined;

        /**
         * The base implementation of `_.toString` which doesn't convert nullish
         * values to empty strings.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {string} Returns the string.
         */
        function baseToString$1(value) {
          // Exit early for strings to avoid a performance hit in some environments.
          if (typeof value == 'string') {
            return value;
          }
          if (isArray$4(value)) {
            // Recursively convert values (susceptible to call stack limits).
            return arrayMap$2(value, baseToString$1) + '';
          }
          if (isSymbol$1(value)) {
            return symbolToString ? symbolToString.call(value) : '';
          }
          var result = value + '';
          return result == '0' && 1 / value == -INFINITY$2 ? '-0' : result;
        }

        /**
         * Converts `value` to a string. An empty string is returned for `null`
         * and `undefined` values. The sign of `-0` is preserved.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.toString(null);
         * // => ''
         *
         * _.toString(-0);
         * // => '-0'
         *
         * _.toString([1, 2, 3]);
         * // => '1,2,3'
         */
        function toString$2(value) {
          return value == null ? '' : baseToString$1(value);
        }

        /**
         * Casts `value` to a path array if it's not one.
         *
         * @private
         * @param {*} value The value to inspect.
         * @param {Object} [object] The object to query keys on.
         * @returns {Array} Returns the cast property path array.
         */
        function castPath$4(value, object) {
          if (isArray$4(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath$1(toString$2(value));
        }

        /** Used as references for various `Number` constants. */
        var INFINITY$1 = 1 / 0;

        /**
         * Converts `value` to a string key if it's not a string or symbol.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {string|symbol} Returns the key.
         */
        function toKey$2(value) {
          if (typeof value == 'string' || isSymbol$1(value)) {
            return value;
          }
          var result = value + '';
          return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
        }

        /**
         * The base implementation of `_.get` without support for default values.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @returns {*} Returns the resolved value.
         */
        function baseGet$2(object, path) {
          path = castPath$4(path, object);
          var index = 0,
            length = path.length;
          while (object != null && index < length) {
            object = object[toKey$2(path[index++])];
          }
          return index && index == length ? object : undefined;
        }

        /**
         * Gets the value at `path` of `object`. If the resolved value is
         * `undefined`, the `defaultValue` is returned in its place.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @param {*} [defaultValue] The value returned for `undefined` resolved values.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.get(object, 'a[0].b.c');
         * // => 3
         *
         * _.get(object, ['a', '0', 'b', 'c']);
         * // => 3
         *
         * _.get(object, 'a.b.c', 'default');
         * // => 'default'
         */
        function get$3(object, path, defaultValue) {
          var result = object == null ? undefined : baseGet$2(object, path);
          return result === undefined ? defaultValue : result;
        }

        /**
         * The base implementation of `_.hasIn` without support for deep paths.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {Array|string} key The key to check.
         * @returns {boolean} Returns `true` if `key` exists, else `false`.
         */
        function baseHasIn(object, key) {
          return object != null && key in Object(object);
        }

        /**
         * Checks if `path` exists on `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @param {Function} hasFunc The function to check properties.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         */
        function hasPath(object, path, hasFunc) {
          path = castPath$4(path, object);
          var index = -1,
            length = path.length,
            result = false;
          while (++index < length) {
            var key = toKey$2(path[index]);
            if (!(result = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result || ++index != length) {
            return result;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex$2(key, length) && (isArray$4(object) || isArguments$3(object));
        }

        /**
         * Checks if `path` is a direct or inherited property of `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         * @example
         *
         * var object = _.create({ 'a': _.create({ 'b': 2 }) });
         *
         * _.hasIn(object, 'a');
         * // => true
         *
         * _.hasIn(object, 'a.b');
         * // => true
         *
         * _.hasIn(object, ['a', 'b']);
         * // => true
         *
         * _.hasIn(object, 'b');
         * // => false
         */
        function hasIn$1(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }

        /** Used to compose bitmasks for value comparisons. */
        var COMPARE_PARTIAL_FLAG = 1,
          COMPARE_UNORDERED_FLAG = 2;

        /**
         * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
         *
         * @private
         * @param {string} path The path of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         */
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey$2(path), srcValue);
          }
          return function (object) {
            var objValue = get$3(object, path);
            return objValue === undefined && objValue === srcValue ? hasIn$1(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }

        /**
         * The base implementation of `_.property` without support for deep paths.
         *
         * @private
         * @param {string} key The key of the property to get.
         * @returns {Function} Returns the new accessor function.
         */
        function baseProperty(key) {
          return function (object) {
            return object == null ? undefined : object[key];
          };
        }

        /**
         * A specialized version of `baseProperty` which supports deep paths.
         *
         * @private
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new accessor function.
         */
        function basePropertyDeep(path) {
          return function (object) {
            return baseGet$2(object, path);
          };
        }

        /**
         * Creates a function that returns the value at `path` of a given object.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Util
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new accessor function.
         * @example
         *
         * var objects = [
         *   { 'a': { 'b': 2 } },
         *   { 'a': { 'b': 1 } }
         * ];
         *
         * _.map(objects, _.property('a.b'));
         * // => [2, 1]
         *
         * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
         * // => [1, 2]
         */
        function property(path) {
          return isKey(path) ? baseProperty(toKey$2(path)) : basePropertyDeep(path);
        }

        /**
         * The base implementation of `_.iteratee`.
         *
         * @private
         * @param {*} [value=_.identity] The value to convert to an iteratee.
         * @returns {Function} Returns the iteratee.
         */
        function baseIteratee$2(value) {
          // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
          // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
          if (typeof value == 'function') {
            return value;
          }
          if (value == null) {
            return identity$2;
          }
          if (typeof value == 'object') {
            return isArray$4(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }

        /**
         * The base implementation of `_.map` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function baseMap(collection, iteratee) {
          var index = -1,
            result = isArrayLike$2(collection) ? Array(collection.length) : [];
          baseEach$1(collection, function (value, key, collection) {
            result[++index] = iteratee(value, key, collection);
          });
          return result;
        }

        /**
         * Creates an array of values by running each element in `collection` thru
         * `iteratee`. The iteratee is invoked with three arguments:
         * (value, index|key, collection).
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
         *
         * The guarded methods are:
         * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
         * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
         * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
         * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * _.map([4, 8], square);
         * // => [16, 64]
         *
         * _.map({ 'a': 4, 'b': 8 }, square);
         * // => [16, 64] (iteration order is not guaranteed)
         *
         * var users = [
         *   { 'user': 'barney' },
         *   { 'user': 'fred' }
         * ];
         *
         * // The `_.property` iteratee shorthand.
         * _.map(users, 'user');
         * // => ['barney', 'fred']
         */
        function map$1(collection, iteratee) {
          var func = isArray$4(collection) ? arrayMap$2 : baseMap;
          return func(collection, baseIteratee$2(iteratee));
        }
        var BlockSwatches = function BlockSwatches(_ref) {
          var colors = _ref.colors,
            onClick = _ref.onClick,
            onSwatchHover = _ref.onSwatchHover;
          var styles = _default$a({
            'default': {
              swatches: {
                marginRight: '-10px'
              },
              swatch: {
                width: '22px',
                height: '22px',
                float: 'left',
                marginRight: '10px',
                marginBottom: '10px',
                borderRadius: '4px'
              },
              clear: {
                clear: 'both'
              }
            }
          });
          return React.createElement('div', {
            style: styles.swatches
          }, map$1(colors, function (c) {
            return React.createElement(Swatch$1, {
              key: c,
              color: c,
              style: styles.swatch,
              onClick: onClick,
              onHover: onSwatchHover,
              focusStyle: {
                boxShadow: '0 0 4px ' + c
              }
            });
          }), React.createElement('div', {
            style: styles.clear
          }));
        };
        var Block = function Block(_ref) {
          var onChange = _ref.onChange,
            onSwatchHover = _ref.onSwatchHover,
            hex = _ref.hex,
            colors = _ref.colors,
            width = _ref.width,
            triangle = _ref.triangle,
            _ref$styles = _ref.styles,
            passedStyles = _ref$styles === undefined ? {} : _ref$styles,
            _ref$className = _ref.className,
            className = _ref$className === undefined ? '' : _ref$className;
          var transparent = hex === 'transparent';
          var handleChange = function handleChange(hexCode, e) {
            isValidHex(hexCode) && onChange({
              hex: hexCode,
              source: 'hex'
            }, e);
          };
          var styles = _default$a(merge$4({
            'default': {
              card: {
                width: width,
                background: '#fff',
                boxShadow: '0 1px rgba(0,0,0,.1)',
                borderRadius: '6px',
                position: 'relative'
              },
              head: {
                height: '110px',
                background: hex,
                borderRadius: '6px 6px 0 0',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                position: 'relative'
              },
              body: {
                padding: '10px'
              },
              label: {
                fontSize: '18px',
                color: getContrastingColor(hex),
                position: 'relative'
              },
              triangle: {
                width: '0px',
                height: '0px',
                borderStyle: 'solid',
                borderWidth: '0 10px 10px 10px',
                borderColor: 'transparent transparent ' + hex + ' transparent',
                position: 'absolute',
                top: '-10px',
                left: '50%',
                marginLeft: '-10px'
              },
              input: {
                width: '100%',
                fontSize: '12px',
                color: '#666',
                border: '0px',
                outline: 'none',
                height: '22px',
                boxShadow: 'inset 0 0 0 1px #ddd',
                borderRadius: '4px',
                padding: '0 7px',
                boxSizing: 'border-box'
              }
            },
            'hide-triangle': {
              triangle: {
                display: 'none'
              }
            }
          }, passedStyles), {
            'hide-triangle': triangle === 'hide'
          });
          return React.createElement('div', {
            style: styles.card,
            className: 'block-picker ' + className
          }, React.createElement('div', {
            style: styles.triangle
          }), React.createElement('div', {
            style: styles.head
          }, transparent && React.createElement(Checkboard, {
            borderRadius: '6px 6px 0 0'
          }), React.createElement('div', {
            style: styles.label
          }, hex)), React.createElement('div', {
            style: styles.body
          }, React.createElement(BlockSwatches, {
            colors: colors,
            onClick: handleChange,
            onSwatchHover: onSwatchHover
          }), React.createElement(EditableInput, {
            style: {
              input: styles.input
            },
            value: hex,
            onChange: handleChange
          })));
        };
        Block.propTypes = {
          width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
          colors: PropTypes.arrayOf(PropTypes.string),
          triangle: PropTypes.oneOf(['top', 'hide']),
          styles: PropTypes.object
        };
        Block.defaultProps = {
          width: 170,
          colors: ['#D9E3F0', '#F47373', '#697689', '#37D67A', '#2CCCE4', '#555555', '#dce775', '#ff8a65', '#ba68c8'],
          triangle: 'top',
          styles: {}
        };
        ColorWrap(Block);
        var red = {
          "50": "#ffebee",
          "100": "#ffcdd2",
          "200": "#ef9a9a",
          "300": "#e57373",
          "400": "#ef5350",
          "500": "#f44336",
          "600": "#e53935",
          "700": "#d32f2f",
          "800": "#c62828",
          "900": "#b71c1c",
          "a100": "#ff8a80",
          "a200": "#ff5252",
          "a400": "#ff1744",
          "a700": "#d50000"
        };
        var pink = {
          "50": "#fce4ec",
          "100": "#f8bbd0",
          "200": "#f48fb1",
          "300": "#f06292",
          "400": "#ec407a",
          "500": "#e91e63",
          "600": "#d81b60",
          "700": "#c2185b",
          "800": "#ad1457",
          "900": "#880e4f",
          "a100": "#ff80ab",
          "a200": "#ff4081",
          "a400": "#f50057",
          "a700": "#c51162"
        };
        var purple = {
          "50": "#f3e5f5",
          "100": "#e1bee7",
          "200": "#ce93d8",
          "300": "#ba68c8",
          "400": "#ab47bc",
          "500": "#9c27b0",
          "600": "#8e24aa",
          "700": "#7b1fa2",
          "800": "#6a1b9a",
          "900": "#4a148c",
          "a100": "#ea80fc",
          "a200": "#e040fb",
          "a400": "#d500f9",
          "a700": "#aa00ff"
        };
        var deepPurple = {
          "50": "#ede7f6",
          "100": "#d1c4e9",
          "200": "#b39ddb",
          "300": "#9575cd",
          "400": "#7e57c2",
          "500": "#673ab7",
          "600": "#5e35b1",
          "700": "#512da8",
          "800": "#4527a0",
          "900": "#311b92",
          "a100": "#b388ff",
          "a200": "#7c4dff",
          "a400": "#651fff",
          "a700": "#6200ea"
        };
        var indigo = {
          "50": "#e8eaf6",
          "100": "#c5cae9",
          "200": "#9fa8da",
          "300": "#7986cb",
          "400": "#5c6bc0",
          "500": "#3f51b5",
          "600": "#3949ab",
          "700": "#303f9f",
          "800": "#283593",
          "900": "#1a237e",
          "a100": "#8c9eff",
          "a200": "#536dfe",
          "a400": "#3d5afe",
          "a700": "#304ffe"
        };
        var blue = {
          "50": "#e3f2fd",
          "100": "#bbdefb",
          "200": "#90caf9",
          "300": "#64b5f6",
          "400": "#42a5f5",
          "500": "#2196f3",
          "600": "#1e88e5",
          "700": "#1976d2",
          "800": "#1565c0",
          "900": "#0d47a1",
          "a100": "#82b1ff",
          "a200": "#448aff",
          "a400": "#2979ff",
          "a700": "#2962ff"
        };
        var lightBlue = {
          "50": "#e1f5fe",
          "100": "#b3e5fc",
          "200": "#81d4fa",
          "300": "#4fc3f7",
          "400": "#29b6f6",
          "500": "#03a9f4",
          "600": "#039be5",
          "700": "#0288d1",
          "800": "#0277bd",
          "900": "#01579b",
          "a100": "#80d8ff",
          "a200": "#40c4ff",
          "a400": "#00b0ff",
          "a700": "#0091ea"
        };
        var cyan = {
          "50": "#e0f7fa",
          "100": "#b2ebf2",
          "200": "#80deea",
          "300": "#4dd0e1",
          "400": "#26c6da",
          "500": "#00bcd4",
          "600": "#00acc1",
          "700": "#0097a7",
          "800": "#00838f",
          "900": "#006064",
          "a100": "#84ffff",
          "a200": "#18ffff",
          "a400": "#00e5ff",
          "a700": "#00b8d4"
        };
        var teal = {
          "50": "#e0f2f1",
          "100": "#b2dfdb",
          "200": "#80cbc4",
          "300": "#4db6ac",
          "400": "#26a69a",
          "500": "#009688",
          "600": "#00897b",
          "700": "#00796b",
          "800": "#00695c",
          "900": "#004d40",
          "a100": "#a7ffeb",
          "a200": "#64ffda",
          "a400": "#1de9b6",
          "a700": "#00bfa5"
        };
        var green = {
          "50": "#e8f5e9",
          "100": "#c8e6c9",
          "200": "#a5d6a7",
          "300": "#81c784",
          "400": "#66bb6a",
          "500": "#4caf50",
          "600": "#43a047",
          "700": "#388e3c",
          "800": "#2e7d32",
          "900": "#1b5e20",
          "a100": "#b9f6ca",
          "a200": "#69f0ae",
          "a400": "#00e676",
          "a700": "#00c853"
        };
        var lightGreen = {
          "50": "#f1f8e9",
          "100": "#dcedc8",
          "200": "#c5e1a5",
          "300": "#aed581",
          "400": "#9ccc65",
          "500": "#8bc34a",
          "600": "#7cb342",
          "700": "#689f38",
          "800": "#558b2f",
          "900": "#33691e",
          "a100": "#ccff90",
          "a200": "#b2ff59",
          "a400": "#76ff03",
          "a700": "#64dd17"
        };
        var lime = {
          "50": "#f9fbe7",
          "100": "#f0f4c3",
          "200": "#e6ee9c",
          "300": "#dce775",
          "400": "#d4e157",
          "500": "#cddc39",
          "600": "#c0ca33",
          "700": "#afb42b",
          "800": "#9e9d24",
          "900": "#827717",
          "a100": "#f4ff81",
          "a200": "#eeff41",
          "a400": "#c6ff00",
          "a700": "#aeea00"
        };
        var yellow = {
          "50": "#fffde7",
          "100": "#fff9c4",
          "200": "#fff59d",
          "300": "#fff176",
          "400": "#ffee58",
          "500": "#ffeb3b",
          "600": "#fdd835",
          "700": "#fbc02d",
          "800": "#f9a825",
          "900": "#f57f17",
          "a100": "#ffff8d",
          "a200": "#ffff00",
          "a400": "#ffea00",
          "a700": "#ffd600"
        };
        var amber = {
          "50": "#fff8e1",
          "100": "#ffecb3",
          "200": "#ffe082",
          "300": "#ffd54f",
          "400": "#ffca28",
          "500": "#ffc107",
          "600": "#ffb300",
          "700": "#ffa000",
          "800": "#ff8f00",
          "900": "#ff6f00",
          "a100": "#ffe57f",
          "a200": "#ffd740",
          "a400": "#ffc400",
          "a700": "#ffab00"
        };
        var orange = {
          "50": "#fff3e0",
          "100": "#ffe0b2",
          "200": "#ffcc80",
          "300": "#ffb74d",
          "400": "#ffa726",
          "500": "#ff9800",
          "600": "#fb8c00",
          "700": "#f57c00",
          "800": "#ef6c00",
          "900": "#e65100",
          "a100": "#ffd180",
          "a200": "#ffab40",
          "a400": "#ff9100",
          "a700": "#ff6d00"
        };
        var deepOrange = {
          "50": "#fbe9e7",
          "100": "#ffccbc",
          "200": "#ffab91",
          "300": "#ff8a65",
          "400": "#ff7043",
          "500": "#ff5722",
          "600": "#f4511e",
          "700": "#e64a19",
          "800": "#d84315",
          "900": "#bf360c",
          "a100": "#ff9e80",
          "a200": "#ff6e40",
          "a400": "#ff3d00",
          "a700": "#dd2c00"
        };
        var brown = {
          "50": "#efebe9",
          "100": "#d7ccc8",
          "200": "#bcaaa4",
          "300": "#a1887f",
          "400": "#8d6e63",
          "500": "#795548",
          "600": "#6d4c41",
          "700": "#5d4037",
          "800": "#4e342e",
          "900": "#3e2723"
        };
        var blueGrey = {
          "50": "#eceff1",
          "100": "#cfd8dc",
          "200": "#b0bec5",
          "300": "#90a4ae",
          "400": "#78909c",
          "500": "#607d8b",
          "600": "#546e7a",
          "700": "#455a64",
          "800": "#37474f",
          "900": "#263238"
        };
        var CircleSwatch = function CircleSwatch(_ref) {
          var color = _ref.color,
            onClick = _ref.onClick,
            onSwatchHover = _ref.onSwatchHover,
            hover = _ref.hover,
            active = _ref.active,
            circleSize = _ref.circleSize,
            circleSpacing = _ref.circleSpacing;
          var styles = _default$a({
            'default': {
              swatch: {
                width: circleSize,
                height: circleSize,
                marginRight: circleSpacing,
                marginBottom: circleSpacing,
                transform: 'scale(1)',
                transition: '100ms transform ease'
              },
              Swatch: {
                borderRadius: '50%',
                background: 'transparent',
                boxShadow: 'inset 0 0 0 ' + (circleSize / 2 + 1) + 'px ' + color,
                transition: '100ms box-shadow ease'
              }
            },
            'hover': {
              swatch: {
                transform: 'scale(1.2)'
              }
            },
            'active': {
              Swatch: {
                boxShadow: 'inset 0 0 0 3px ' + color
              }
            }
          }, {
            hover: hover,
            active: active
          });
          return React.createElement('div', {
            style: styles.swatch
          }, React.createElement(Swatch$1, {
            style: styles.Swatch,
            color: color,
            onClick: onClick,
            onHover: onSwatchHover,
            focusStyle: {
              boxShadow: styles.Swatch.boxShadow + ', 0 0 5px ' + color
            }
          }));
        };
        CircleSwatch.defaultProps = {
          circleSize: 28,
          circleSpacing: 14
        };
        const CircleSwatch$1 = handleHover(CircleSwatch);
        var Circle = function Circle(_ref) {
          var width = _ref.width,
            onChange = _ref.onChange,
            onSwatchHover = _ref.onSwatchHover,
            colors = _ref.colors,
            hex = _ref.hex,
            circleSize = _ref.circleSize,
            _ref$styles = _ref.styles,
            passedStyles = _ref$styles === undefined ? {} : _ref$styles,
            circleSpacing = _ref.circleSpacing,
            _ref$className = _ref.className,
            className = _ref$className === undefined ? '' : _ref$className;
          var styles = _default$a(merge$4({
            'default': {
              card: {
                width: width,
                display: 'flex',
                flexWrap: 'wrap',
                marginRight: -circleSpacing,
                marginBottom: -circleSpacing
              }
            }
          }, passedStyles));
          var handleChange = function handleChange(hexCode, e) {
            return onChange({
              hex: hexCode,
              source: 'hex'
            }, e);
          };
          return React.createElement('div', {
            style: styles.card,
            className: 'circle-picker ' + className
          }, map$1(colors, function (c) {
            return React.createElement(CircleSwatch$1, {
              key: c,
              color: c,
              onClick: handleChange,
              onSwatchHover: onSwatchHover,
              active: hex === c.toLowerCase(),
              circleSize: circleSize,
              circleSpacing: circleSpacing
            });
          }));
        };
        Circle.propTypes = {
          width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
          circleSize: PropTypes.number,
          circleSpacing: PropTypes.number,
          styles: PropTypes.object
        };
        Circle.defaultProps = {
          width: 252,
          circleSize: 28,
          circleSpacing: 14,
          colors: [red['500'], pink['500'], purple['500'], deepPurple['500'], indigo['500'], blue['500'], lightBlue['500'], cyan['500'], teal['500'], green['500'], lightGreen['500'], lime['500'], yellow['500'], amber['500'], orange['500'], deepOrange['500'], brown['500'], blueGrey['500']],
          styles: {}
        };
        ColorWrap(Circle);

        /**
         * Checks if `value` is `undefined`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
         * @example
         *
         * _.isUndefined(void 0);
         * // => true
         *
         * _.isUndefined(null);
         * // => false
         */
        function isUndefined$1(value) {
          return value === undefined;
        }
        var UnfoldMoreHorizontalIcon = {};
        Object.defineProperty(UnfoldMoreHorizontalIcon, "__esModule", {
          value: true
        });
        var _extends$5 = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        var _react$1 = reactExports;
        var _react2$1 = _interopRequireDefault$9(_react$1);
        function _interopRequireDefault$9(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        function _objectWithoutProperties$1(obj, keys) {
          var target = {};
          for (var i in obj) {
            if (keys.indexOf(i) >= 0) continue;
            if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
            target[i] = obj[i];
          }
          return target;
        }
        var DEFAULT_SIZE$1 = 24;
        var _default$9 = UnfoldMoreHorizontalIcon.default = function (_ref) {
          var _ref$fill = _ref.fill,
            fill = _ref$fill === undefined ? 'currentColor' : _ref$fill,
            _ref$width = _ref.width,
            width = _ref$width === undefined ? DEFAULT_SIZE$1 : _ref$width,
            _ref$height = _ref.height,
            height = _ref$height === undefined ? DEFAULT_SIZE$1 : _ref$height,
            _ref$style = _ref.style,
            style = _ref$style === undefined ? {} : _ref$style,
            props = _objectWithoutProperties$1(_ref, ['fill', 'width', 'height', 'style']);
          return _react2$1.default.createElement('svg', _extends$5({
            viewBox: '0 0 ' + DEFAULT_SIZE$1 + ' ' + DEFAULT_SIZE$1,
            style: _extends$5({
              fill: fill,
              width: width,
              height: height
            }, style)
          }, props), _react2$1.default.createElement('path', {
            d: 'M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z'
          }));
        };
        var _createClass$1 = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        function _classCallCheck$1(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn$1(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self;
        }
        function _inherits$1(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var ChromeFields = function (_React$Component) {
          _inherits$1(ChromeFields, _React$Component);
          function ChromeFields(props) {
            _classCallCheck$1(this, ChromeFields);
            var _this = _possibleConstructorReturn$1(this, (ChromeFields.__proto__ || Object.getPrototypeOf(ChromeFields)).call(this));
            _this.toggleViews = function () {
              if (_this.state.view === 'hex') {
                _this.setState({
                  view: 'rgb'
                });
              } else if (_this.state.view === 'rgb') {
                _this.setState({
                  view: 'hsl'
                });
              } else if (_this.state.view === 'hsl') {
                if (_this.props.hsl.a === 1) {
                  _this.setState({
                    view: 'hex'
                  });
                } else {
                  _this.setState({
                    view: 'rgb'
                  });
                }
              }
            };
            _this.handleChange = function (data, e) {
              if (data.hex) {
                isValidHex(data.hex) && _this.props.onChange({
                  hex: data.hex,
                  source: 'hex'
                }, e);
              } else if (data.r || data.g || data.b) {
                _this.props.onChange({
                  r: data.r || _this.props.rgb.r,
                  g: data.g || _this.props.rgb.g,
                  b: data.b || _this.props.rgb.b,
                  source: 'rgb'
                }, e);
              } else if (data.a) {
                if (data.a < 0) {
                  data.a = 0;
                } else if (data.a > 1) {
                  data.a = 1;
                }
                _this.props.onChange({
                  h: _this.props.hsl.h,
                  s: _this.props.hsl.s,
                  l: _this.props.hsl.l,
                  a: Math.round(data.a * 100) / 100,
                  source: 'rgb'
                }, e);
              } else if (data.h || data.s || data.l) {
                // Remove any occurances of '%'.
                if (typeof data.s === 'string' && data.s.includes('%')) {
                  data.s = data.s.replace('%', '');
                }
                if (typeof data.l === 'string' && data.l.includes('%')) {
                  data.l = data.l.replace('%', '');
                }

                // We store HSL as a unit interval so we need to override the 1 input to 0.01
                if (data.s == 1) {
                  data.s = 0.01;
                } else if (data.l == 1) {
                  data.l = 0.01;
                }
                _this.props.onChange({
                  h: data.h || _this.props.hsl.h,
                  s: Number(!isUndefined$1(data.s) ? data.s : _this.props.hsl.s),
                  l: Number(!isUndefined$1(data.l) ? data.l : _this.props.hsl.l),
                  source: 'hsl'
                }, e);
              }
            };
            _this.showHighlight = function (e) {
              e.currentTarget.style.background = '#eee';
            };
            _this.hideHighlight = function (e) {
              e.currentTarget.style.background = 'transparent';
            };
            if (props.hsl.a !== 1 && props.view === "hex") {
              _this.state = {
                view: "rgb"
              };
            } else {
              _this.state = {
                view: props.view
              };
            }
            return _this;
          }
          _createClass$1(ChromeFields, [{
            key: 'render',
            value: function render() {
              var _this2 = this;
              var styles = _default$a({
                'default': {
                  wrap: {
                    paddingTop: '16px',
                    display: 'flex'
                  },
                  fields: {
                    flex: '1',
                    display: 'flex',
                    marginLeft: '-6px'
                  },
                  field: {
                    paddingLeft: '6px',
                    width: '100%'
                  },
                  alpha: {
                    paddingLeft: '6px',
                    width: '100%'
                  },
                  toggle: {
                    width: '32px',
                    textAlign: 'right',
                    position: 'relative'
                  },
                  icon: {
                    marginRight: '-4px',
                    marginTop: '12px',
                    cursor: 'pointer',
                    position: 'relative'
                  },
                  iconHighlight: {
                    position: 'absolute',
                    width: '24px',
                    height: '28px',
                    background: '#eee',
                    borderRadius: '4px',
                    top: '10px',
                    left: '12px',
                    display: 'none'
                  },
                  input: {
                    fontSize: '11px',
                    color: '#333',
                    width: '100%',
                    borderRadius: '2px',
                    border: 'none',
                    boxShadow: 'inset 0 0 0 1px #dadada',
                    height: '21px',
                    textAlign: 'center'
                  },
                  label: {
                    textTransform: 'uppercase',
                    fontSize: '11px',
                    lineHeight: '11px',
                    color: '#969696',
                    textAlign: 'center',
                    display: 'block',
                    marginTop: '12px'
                  },
                  svg: {
                    fill: '#333',
                    width: '24px',
                    height: '24px',
                    border: '1px transparent solid',
                    borderRadius: '5px'
                  }
                },
                'disableAlpha': {
                  alpha: {
                    display: 'none'
                  }
                }
              }, this.props, this.state);
              var fields = void 0;
              if (this.state.view === 'hex') {
                fields = React.createElement('div', {
                  style: styles.fields,
                  className: 'flexbox-fix'
                }, React.createElement('div', {
                  style: styles.field
                }, React.createElement(EditableInput, {
                  style: {
                    input: styles.input,
                    label: styles.label
                  },
                  label: 'hex',
                  value: this.props.hex,
                  onChange: this.handleChange
                })));
              } else if (this.state.view === 'rgb') {
                fields = React.createElement('div', {
                  style: styles.fields,
                  className: 'flexbox-fix'
                }, React.createElement('div', {
                  style: styles.field
                }, React.createElement(EditableInput, {
                  style: {
                    input: styles.input,
                    label: styles.label
                  },
                  label: 'r',
                  value: this.props.rgb.r,
                  onChange: this.handleChange
                })), React.createElement('div', {
                  style: styles.field
                }, React.createElement(EditableInput, {
                  style: {
                    input: styles.input,
                    label: styles.label
                  },
                  label: 'g',
                  value: this.props.rgb.g,
                  onChange: this.handleChange
                })), React.createElement('div', {
                  style: styles.field
                }, React.createElement(EditableInput, {
                  style: {
                    input: styles.input,
                    label: styles.label
                  },
                  label: 'b',
                  value: this.props.rgb.b,
                  onChange: this.handleChange
                })), React.createElement('div', {
                  style: styles.alpha
                }, React.createElement(EditableInput, {
                  style: {
                    input: styles.input,
                    label: styles.label
                  },
                  label: 'a',
                  value: this.props.rgb.a,
                  arrowOffset: 0.01,
                  onChange: this.handleChange
                })));
              } else if (this.state.view === 'hsl') {
                fields = React.createElement('div', {
                  style: styles.fields,
                  className: 'flexbox-fix'
                }, React.createElement('div', {
                  style: styles.field
                }, React.createElement(EditableInput, {
                  style: {
                    input: styles.input,
                    label: styles.label
                  },
                  label: 'h',
                  value: Math.round(this.props.hsl.h),
                  onChange: this.handleChange
                })), React.createElement('div', {
                  style: styles.field
                }, React.createElement(EditableInput, {
                  style: {
                    input: styles.input,
                    label: styles.label
                  },
                  label: 's',
                  value: Math.round(this.props.hsl.s * 100) + '%',
                  onChange: this.handleChange
                })), React.createElement('div', {
                  style: styles.field
                }, React.createElement(EditableInput, {
                  style: {
                    input: styles.input,
                    label: styles.label
                  },
                  label: 'l',
                  value: Math.round(this.props.hsl.l * 100) + '%',
                  onChange: this.handleChange
                })), React.createElement('div', {
                  style: styles.alpha
                }, React.createElement(EditableInput, {
                  style: {
                    input: styles.input,
                    label: styles.label
                  },
                  label: 'a',
                  value: this.props.hsl.a,
                  arrowOffset: 0.01,
                  onChange: this.handleChange
                })));
              }
              return React.createElement('div', {
                style: styles.wrap,
                className: 'flexbox-fix'
              }, fields, React.createElement('div', {
                style: styles.toggle
              }, React.createElement('div', {
                style: styles.icon,
                onClick: this.toggleViews,
                ref: function ref(icon) {
                  return _this2.icon = icon;
                }
              }, React.createElement(_default$9, {
                style: styles.svg,
                onMouseOver: this.showHighlight,
                onMouseEnter: this.showHighlight,
                onMouseOut: this.hideHighlight
              }))));
            }
          }], [{
            key: 'getDerivedStateFromProps',
            value: function getDerivedStateFromProps(nextProps, state) {
              if (nextProps.hsl.a !== 1 && state.view === 'hex') {
                return {
                  view: 'rgb'
                };
              }
              return null;
            }
          }]);
          return ChromeFields;
        }(React.Component);
        ChromeFields.defaultProps = {
          view: "hex"
        };
        var ChromePointer = function ChromePointer() {
          var styles = _default$a({
            'default': {
              picker: {
                width: '12px',
                height: '12px',
                borderRadius: '6px',
                transform: 'translate(-6px, -1px)',
                backgroundColor: 'rgb(248, 248, 248)',
                boxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.37)'
              }
            }
          });
          return React.createElement('div', {
            style: styles.picker
          });
        };
        var ChromePointerCircle = function ChromePointerCircle() {
          var styles = _default$a({
            'default': {
              picker: {
                width: '12px',
                height: '12px',
                borderRadius: '6px',
                boxShadow: 'inset 0 0 0 1px #fff',
                transform: 'translate(-6px, -6px)'
              }
            }
          });
          return React.createElement('div', {
            style: styles.picker
          });
        };
        var Chrome = function Chrome(_ref) {
          var width = _ref.width,
            onChange = _ref.onChange,
            disableAlpha = _ref.disableAlpha,
            rgb = _ref.rgb,
            hsl = _ref.hsl,
            hsv = _ref.hsv,
            hex = _ref.hex,
            renderers = _ref.renderers,
            _ref$styles = _ref.styles,
            passedStyles = _ref$styles === undefined ? {} : _ref$styles,
            _ref$className = _ref.className,
            className = _ref$className === undefined ? '' : _ref$className,
            defaultView = _ref.defaultView;
          var styles = _default$a(merge$4({
            'default': {
              picker: {
                width: width,
                background: '#fff',
                borderRadius: '2px',
                boxShadow: '0 0 2px rgba(0,0,0,.3), 0 4px 8px rgba(0,0,0,.3)',
                boxSizing: 'initial',
                fontFamily: 'Menlo'
              },
              saturation: {
                width: '100%',
                paddingBottom: '55%',
                position: 'relative',
                borderRadius: '2px 2px 0 0',
                overflow: 'hidden'
              },
              Saturation: {
                radius: '2px 2px 0 0'
              },
              body: {
                padding: '16px 16px 12px'
              },
              controls: {
                display: 'flex'
              },
              color: {
                width: '32px'
              },
              swatch: {
                marginTop: '6px',
                width: '16px',
                height: '16px',
                borderRadius: '8px',
                position: 'relative',
                overflow: 'hidden'
              },
              active: {
                absolute: '0px 0px 0px 0px',
                borderRadius: '8px',
                boxShadow: 'inset 0 0 0 1px rgba(0,0,0,.1)',
                background: 'rgba(' + rgb.r + ', ' + rgb.g + ', ' + rgb.b + ', ' + rgb.a + ')',
                zIndex: '2'
              },
              toggles: {
                flex: '1'
              },
              hue: {
                height: '10px',
                position: 'relative',
                marginBottom: '8px'
              },
              Hue: {
                radius: '2px'
              },
              alpha: {
                height: '10px',
                position: 'relative'
              },
              Alpha: {
                radius: '2px'
              }
            },
            'disableAlpha': {
              color: {
                width: '22px'
              },
              alpha: {
                display: 'none'
              },
              hue: {
                marginBottom: '0px'
              },
              swatch: {
                width: '10px',
                height: '10px',
                marginTop: '0px'
              }
            }
          }, passedStyles), {
            disableAlpha: disableAlpha
          });
          return React.createElement('div', {
            style: styles.picker,
            className: 'chrome-picker ' + className
          }, React.createElement('div', {
            style: styles.saturation
          }, React.createElement(Saturation, {
            style: styles.Saturation,
            hsl: hsl,
            hsv: hsv,
            pointer: ChromePointerCircle,
            onChange: onChange
          })), React.createElement('div', {
            style: styles.body
          }, React.createElement('div', {
            style: styles.controls,
            className: 'flexbox-fix'
          }, React.createElement('div', {
            style: styles.color
          }, React.createElement('div', {
            style: styles.swatch
          }, React.createElement('div', {
            style: styles.active
          }), React.createElement(Checkboard, {
            renderers: renderers
          }))), React.createElement('div', {
            style: styles.toggles
          }, React.createElement('div', {
            style: styles.hue
          }, React.createElement(Hue, {
            style: styles.Hue,
            hsl: hsl,
            pointer: ChromePointer,
            onChange: onChange
          })), React.createElement('div', {
            style: styles.alpha
          }, React.createElement(Alpha, {
            style: styles.Alpha,
            rgb: rgb,
            hsl: hsl,
            pointer: ChromePointer,
            renderers: renderers,
            onChange: onChange
          })))), React.createElement(ChromeFields, {
            rgb: rgb,
            hsl: hsl,
            hex: hex,
            view: defaultView,
            onChange: onChange,
            disableAlpha: disableAlpha
          })));
        };
        Chrome.propTypes = {
          width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
          disableAlpha: PropTypes.bool,
          styles: PropTypes.object,
          defaultView: PropTypes.oneOf(["hex", "rgb", "hsl"])
        };
        Chrome.defaultProps = {
          width: 225,
          disableAlpha: false,
          styles: {}
        };
        ColorWrap(Chrome);
        var CompactColor = function CompactColor(_ref) {
          var color = _ref.color,
            _ref$onClick = _ref.onClick,
            onClick = _ref$onClick === undefined ? function () {} : _ref$onClick,
            onSwatchHover = _ref.onSwatchHover,
            active = _ref.active;
          var styles = _default$a({
            'default': {
              color: {
                background: color,
                width: '15px',
                height: '15px',
                float: 'left',
                marginRight: '5px',
                marginBottom: '5px',
                position: 'relative',
                cursor: 'pointer'
              },
              dot: {
                absolute: '5px 5px 5px 5px',
                background: getContrastingColor(color),
                borderRadius: '50%',
                opacity: '0'
              }
            },
            'active': {
              dot: {
                opacity: '1'
              }
            },
            'color-#FFFFFF': {
              color: {
                boxShadow: 'inset 0 0 0 1px #ddd'
              },
              dot: {
                background: '#000'
              }
            },
            'transparent': {
              dot: {
                background: '#000'
              }
            }
          }, {
            active: active,
            'color-#FFFFFF': color === '#FFFFFF',
            'transparent': color === 'transparent'
          });
          return React.createElement(Swatch$1, {
            style: styles.color,
            color: color,
            onClick: onClick,
            onHover: onSwatchHover,
            focusStyle: {
              boxShadow: '0 0 4px ' + color
            }
          }, React.createElement('div', {
            style: styles.dot
          }));
        };
        var CompactFields = function CompactFields(_ref) {
          var hex = _ref.hex,
            rgb = _ref.rgb,
            onChange = _ref.onChange;
          var styles = _default$a({
            'default': {
              fields: {
                display: 'flex',
                paddingBottom: '6px',
                paddingRight: '5px',
                position: 'relative'
              },
              active: {
                position: 'absolute',
                top: '6px',
                left: '5px',
                height: '9px',
                width: '9px',
                background: hex
              },
              HEXwrap: {
                flex: '6',
                position: 'relative'
              },
              HEXinput: {
                width: '80%',
                padding: '0px',
                paddingLeft: '20%',
                border: 'none',
                outline: 'none',
                background: 'none',
                fontSize: '12px',
                color: '#333',
                height: '16px'
              },
              HEXlabel: {
                display: 'none'
              },
              RGBwrap: {
                flex: '3',
                position: 'relative'
              },
              RGBinput: {
                width: '70%',
                padding: '0px',
                paddingLeft: '30%',
                border: 'none',
                outline: 'none',
                background: 'none',
                fontSize: '12px',
                color: '#333',
                height: '16px'
              },
              RGBlabel: {
                position: 'absolute',
                top: '3px',
                left: '0px',
                lineHeight: '16px',
                textTransform: 'uppercase',
                fontSize: '12px',
                color: '#999'
              }
            }
          });
          var handleChange = function handleChange(data, e) {
            if (data.r || data.g || data.b) {
              onChange({
                r: data.r || rgb.r,
                g: data.g || rgb.g,
                b: data.b || rgb.b,
                source: 'rgb'
              }, e);
            } else {
              onChange({
                hex: data.hex,
                source: 'hex'
              }, e);
            }
          };
          return React.createElement('div', {
            style: styles.fields,
            className: 'flexbox-fix'
          }, React.createElement('div', {
            style: styles.active
          }), React.createElement(EditableInput, {
            style: {
              wrap: styles.HEXwrap,
              input: styles.HEXinput,
              label: styles.HEXlabel
            },
            label: 'hex',
            value: hex,
            onChange: handleChange
          }), React.createElement(EditableInput, {
            style: {
              wrap: styles.RGBwrap,
              input: styles.RGBinput,
              label: styles.RGBlabel
            },
            label: 'r',
            value: rgb.r,
            onChange: handleChange
          }), React.createElement(EditableInput, {
            style: {
              wrap: styles.RGBwrap,
              input: styles.RGBinput,
              label: styles.RGBlabel
            },
            label: 'g',
            value: rgb.g,
            onChange: handleChange
          }), React.createElement(EditableInput, {
            style: {
              wrap: styles.RGBwrap,
              input: styles.RGBinput,
              label: styles.RGBlabel
            },
            label: 'b',
            value: rgb.b,
            onChange: handleChange
          }));
        };
        var Compact = function Compact(_ref) {
          var onChange = _ref.onChange,
            onSwatchHover = _ref.onSwatchHover,
            colors = _ref.colors,
            hex = _ref.hex,
            rgb = _ref.rgb,
            _ref$styles = _ref.styles,
            passedStyles = _ref$styles === undefined ? {} : _ref$styles,
            _ref$className = _ref.className,
            className = _ref$className === undefined ? '' : _ref$className;
          var styles = _default$a(merge$4({
            'default': {
              Compact: {
                background: '#f6f6f6',
                radius: '4px'
              },
              compact: {
                paddingTop: '5px',
                paddingLeft: '5px',
                boxSizing: 'initial',
                width: '240px'
              },
              clear: {
                clear: 'both'
              }
            }
          }, passedStyles));
          var handleChange = function handleChange(data, e) {
            if (data.hex) {
              isValidHex(data.hex) && onChange({
                hex: data.hex,
                source: 'hex'
              }, e);
            } else {
              onChange(data, e);
            }
          };
          return React.createElement(Raised, {
            style: styles.Compact,
            styles: passedStyles
          }, React.createElement('div', {
            style: styles.compact,
            className: 'compact-picker ' + className
          }, React.createElement('div', null, map$1(colors, function (c) {
            return React.createElement(CompactColor, {
              key: c,
              color: c,
              active: c.toLowerCase() === hex,
              onClick: handleChange,
              onSwatchHover: onSwatchHover
            });
          }), React.createElement('div', {
            style: styles.clear
          })), React.createElement(CompactFields, {
            hex: hex,
            rgb: rgb,
            onChange: handleChange
          })));
        };
        Compact.propTypes = {
          colors: PropTypes.arrayOf(PropTypes.string),
          styles: PropTypes.object
        };
        Compact.defaultProps = {
          colors: ['#4D4D4D', '#999999', '#FFFFFF', '#F44E3B', '#FE9200', '#FCDC00', '#DBDF00', '#A4DD00', '#68CCCA', '#73D8FF', '#AEA1FF', '#FDA1FF', '#333333', '#808080', '#cccccc', '#D33115', '#E27300', '#FCC400', '#B0BC00', '#68BC00', '#16A5A5', '#009CE0', '#7B64FF', '#FA28FF', '#000000', '#666666', '#B3B3B3', '#9F0500', '#C45100', '#FB9E00', '#808900', '#194D33', '#0C797D', '#0062B1', '#653294', '#AB149E'],
          styles: {}
        };
        ColorWrap(Compact);
        var GithubSwatch = function GithubSwatch(_ref) {
          var hover = _ref.hover,
            color = _ref.color,
            onClick = _ref.onClick,
            onSwatchHover = _ref.onSwatchHover;
          var hoverSwatch = {
            position: 'relative',
            zIndex: '2',
            outline: '2px solid #fff',
            boxShadow: '0 0 5px 2px rgba(0,0,0,0.25)'
          };
          var styles = _default$a({
            'default': {
              swatch: {
                width: '25px',
                height: '25px',
                fontSize: '0'
              }
            },
            'hover': {
              swatch: hoverSwatch
            }
          }, {
            hover: hover
          });
          return React.createElement('div', {
            style: styles.swatch
          }, React.createElement(Swatch$1, {
            color: color,
            onClick: onClick,
            onHover: onSwatchHover,
            focusStyle: hoverSwatch
          }));
        };
        const GithubSwatch$1 = handleHover(GithubSwatch);
        var Github = function Github(_ref) {
          var width = _ref.width,
            colors = _ref.colors,
            onChange = _ref.onChange,
            onSwatchHover = _ref.onSwatchHover,
            triangle = _ref.triangle,
            _ref$styles = _ref.styles,
            passedStyles = _ref$styles === undefined ? {} : _ref$styles,
            _ref$className = _ref.className,
            className = _ref$className === undefined ? '' : _ref$className;
          var styles = _default$a(merge$4({
            'default': {
              card: {
                width: width,
                background: '#fff',
                border: '1px solid rgba(0,0,0,0.2)',
                boxShadow: '0 3px 12px rgba(0,0,0,0.15)',
                borderRadius: '4px',
                position: 'relative',
                padding: '5px',
                display: 'flex',
                flexWrap: 'wrap'
              },
              triangle: {
                position: 'absolute',
                border: '7px solid transparent',
                borderBottomColor: '#fff'
              },
              triangleShadow: {
                position: 'absolute',
                border: '8px solid transparent',
                borderBottomColor: 'rgba(0,0,0,0.15)'
              }
            },
            'hide-triangle': {
              triangle: {
                display: 'none'
              },
              triangleShadow: {
                display: 'none'
              }
            },
            'top-left-triangle': {
              triangle: {
                top: '-14px',
                left: '10px'
              },
              triangleShadow: {
                top: '-16px',
                left: '9px'
              }
            },
            'top-right-triangle': {
              triangle: {
                top: '-14px',
                right: '10px'
              },
              triangleShadow: {
                top: '-16px',
                right: '9px'
              }
            },
            'bottom-left-triangle': {
              triangle: {
                top: '35px',
                left: '10px',
                transform: 'rotate(180deg)'
              },
              triangleShadow: {
                top: '37px',
                left: '9px',
                transform: 'rotate(180deg)'
              }
            },
            'bottom-right-triangle': {
              triangle: {
                top: '35px',
                right: '10px',
                transform: 'rotate(180deg)'
              },
              triangleShadow: {
                top: '37px',
                right: '9px',
                transform: 'rotate(180deg)'
              }
            }
          }, passedStyles), {
            'hide-triangle': triangle === 'hide',
            'top-left-triangle': triangle === 'top-left',
            'top-right-triangle': triangle === 'top-right',
            'bottom-left-triangle': triangle === 'bottom-left',
            'bottom-right-triangle': triangle === 'bottom-right'
          });
          var handleChange = function handleChange(hex, e) {
            return onChange({
              hex: hex,
              source: 'hex'
            }, e);
          };
          return React.createElement('div', {
            style: styles.card,
            className: 'github-picker ' + className
          }, React.createElement('div', {
            style: styles.triangleShadow
          }), React.createElement('div', {
            style: styles.triangle
          }), map$1(colors, function (c) {
            return React.createElement(GithubSwatch$1, {
              color: c,
              key: c,
              onClick: handleChange,
              onSwatchHover: onSwatchHover
            });
          }));
        };
        Github.propTypes = {
          width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
          colors: PropTypes.arrayOf(PropTypes.string),
          triangle: PropTypes.oneOf(['hide', 'top-left', 'top-right', 'bottom-left', 'bottom-right']),
          styles: PropTypes.object
        };
        Github.defaultProps = {
          width: 200,
          colors: ['#B80000', '#DB3E00', '#FCCB00', '#008B02', '#006B76', '#1273DE', '#004DCF', '#5300EB', '#EB9694', '#FAD0C3', '#FEF3BD', '#C1E1C5', '#BEDADC', '#C4DEF6', '#BED3F3', '#D4C4FB'],
          triangle: 'top-left',
          styles: {}
        };
        ColorWrap(Github);
        var SliderPointer$1 = function SliderPointer(_ref) {
          var direction = _ref.direction;
          var styles = _default$a({
            'default': {
              picker: {
                width: '18px',
                height: '18px',
                borderRadius: '50%',
                transform: 'translate(-9px, -1px)',
                backgroundColor: 'rgb(248, 248, 248)',
                boxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.37)'
              }
            },
            'vertical': {
              picker: {
                transform: 'translate(-3px, -9px)'
              }
            }
          }, {
            vertical: direction === 'vertical'
          });
          return React.createElement('div', {
            style: styles.picker
          });
        };
        var _extends$4 = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        var HuePicker = function HuePicker(_ref) {
          var width = _ref.width,
            height = _ref.height,
            onChange = _ref.onChange,
            hsl = _ref.hsl,
            direction = _ref.direction,
            pointer = _ref.pointer,
            _ref$styles = _ref.styles,
            passedStyles = _ref$styles === undefined ? {} : _ref$styles,
            _ref$className = _ref.className,
            className = _ref$className === undefined ? '' : _ref$className;
          var styles = _default$a(merge$4({
            'default': {
              picker: {
                position: 'relative',
                width: width,
                height: height
              },
              hue: {
                radius: '2px'
              }
            }
          }, passedStyles));

          // Overwrite to provide pure hue color
          var handleChange = function handleChange(data) {
            return onChange({
              a: 1,
              h: data.h,
              l: 0.5,
              s: 1
            });
          };
          return React.createElement('div', {
            style: styles.picker,
            className: 'hue-picker ' + className
          }, React.createElement(Hue, _extends$4({}, styles.hue, {
            hsl: hsl,
            pointer: pointer,
            onChange: handleChange,
            direction: direction
          })));
        };
        HuePicker.propTypes = {
          styles: PropTypes.object
        };
        HuePicker.defaultProps = {
          width: '316px',
          height: '16px',
          direction: 'horizontal',
          pointer: SliderPointer$1,
          styles: {}
        };
        ColorWrap(HuePicker);
        var Material = function Material(_ref) {
          var onChange = _ref.onChange,
            hex = _ref.hex,
            rgb = _ref.rgb,
            _ref$styles = _ref.styles,
            passedStyles = _ref$styles === undefined ? {} : _ref$styles,
            _ref$className = _ref.className,
            className = _ref$className === undefined ? '' : _ref$className;
          var styles = _default$a(merge$4({
            'default': {
              material: {
                width: '98px',
                height: '98px',
                padding: '16px',
                fontFamily: 'Roboto'
              },
              HEXwrap: {
                position: 'relative'
              },
              HEXinput: {
                width: '100%',
                marginTop: '12px',
                fontSize: '15px',
                color: '#333',
                padding: '0px',
                border: '0px',
                borderBottom: '2px solid ' + hex,
                outline: 'none',
                height: '30px'
              },
              HEXlabel: {
                position: 'absolute',
                top: '0px',
                left: '0px',
                fontSize: '11px',
                color: '#999999',
                textTransform: 'capitalize'
              },
              Hex: {
                style: {}
              },
              RGBwrap: {
                position: 'relative'
              },
              RGBinput: {
                width: '100%',
                marginTop: '12px',
                fontSize: '15px',
                color: '#333',
                padding: '0px',
                border: '0px',
                borderBottom: '1px solid #eee',
                outline: 'none',
                height: '30px'
              },
              RGBlabel: {
                position: 'absolute',
                top: '0px',
                left: '0px',
                fontSize: '11px',
                color: '#999999',
                textTransform: 'capitalize'
              },
              split: {
                display: 'flex',
                marginRight: '-10px',
                paddingTop: '11px'
              },
              third: {
                flex: '1',
                paddingRight: '10px'
              }
            }
          }, passedStyles));
          var handleChange = function handleChange(data, e) {
            if (data.hex) {
              isValidHex(data.hex) && onChange({
                hex: data.hex,
                source: 'hex'
              }, e);
            } else if (data.r || data.g || data.b) {
              onChange({
                r: data.r || rgb.r,
                g: data.g || rgb.g,
                b: data.b || rgb.b,
                source: 'rgb'
              }, e);
            }
          };
          return React.createElement(Raised, {
            styles: passedStyles
          }, React.createElement('div', {
            style: styles.material,
            className: 'material-picker ' + className
          }, React.createElement(EditableInput, {
            style: {
              wrap: styles.HEXwrap,
              input: styles.HEXinput,
              label: styles.HEXlabel
            },
            label: 'hex',
            value: hex,
            onChange: handleChange
          }), React.createElement('div', {
            style: styles.split,
            className: 'flexbox-fix'
          }, React.createElement('div', {
            style: styles.third
          }, React.createElement(EditableInput, {
            style: {
              wrap: styles.RGBwrap,
              input: styles.RGBinput,
              label: styles.RGBlabel
            },
            label: 'r',
            value: rgb.r,
            onChange: handleChange
          })), React.createElement('div', {
            style: styles.third
          }, React.createElement(EditableInput, {
            style: {
              wrap: styles.RGBwrap,
              input: styles.RGBinput,
              label: styles.RGBlabel
            },
            label: 'g',
            value: rgb.g,
            onChange: handleChange
          })), React.createElement('div', {
            style: styles.third
          }, React.createElement(EditableInput, {
            style: {
              wrap: styles.RGBwrap,
              input: styles.RGBinput,
              label: styles.RGBlabel
            },
            label: 'b',
            value: rgb.b,
            onChange: handleChange
          })))));
        };
        ColorWrap(Material);
        var PhotoshopPicker = function PhotoshopPicker(_ref) {
          var onChange = _ref.onChange,
            rgb = _ref.rgb,
            hsv = _ref.hsv,
            hex = _ref.hex;
          var styles = _default$a({
            'default': {
              fields: {
                paddingTop: '5px',
                paddingBottom: '9px',
                width: '80px',
                position: 'relative'
              },
              divider: {
                height: '5px'
              },
              RGBwrap: {
                position: 'relative'
              },
              RGBinput: {
                marginLeft: '40%',
                width: '40%',
                height: '18px',
                border: '1px solid #888888',
                boxShadow: 'inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC',
                marginBottom: '5px',
                fontSize: '13px',
                paddingLeft: '3px',
                marginRight: '10px'
              },
              RGBlabel: {
                left: '0px',
                top: '0px',
                width: '34px',
                textTransform: 'uppercase',
                fontSize: '13px',
                height: '18px',
                lineHeight: '22px',
                position: 'absolute'
              },
              HEXwrap: {
                position: 'relative'
              },
              HEXinput: {
                marginLeft: '20%',
                width: '80%',
                height: '18px',
                border: '1px solid #888888',
                boxShadow: 'inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC',
                marginBottom: '6px',
                fontSize: '13px',
                paddingLeft: '3px'
              },
              HEXlabel: {
                position: 'absolute',
                top: '0px',
                left: '0px',
                width: '14px',
                textTransform: 'uppercase',
                fontSize: '13px',
                height: '18px',
                lineHeight: '22px'
              },
              fieldSymbols: {
                position: 'absolute',
                top: '5px',
                right: '-7px',
                fontSize: '13px'
              },
              symbol: {
                height: '20px',
                lineHeight: '22px',
                paddingBottom: '7px'
              }
            }
          });
          var handleChange = function handleChange(data, e) {
            if (data['#']) {
              isValidHex(data['#']) && onChange({
                hex: data['#'],
                source: 'hex'
              }, e);
            } else if (data.r || data.g || data.b) {
              onChange({
                r: data.r || rgb.r,
                g: data.g || rgb.g,
                b: data.b || rgb.b,
                source: 'rgb'
              }, e);
            } else if (data.h || data.s || data.v) {
              onChange({
                h: data.h || hsv.h,
                s: data.s || hsv.s,
                v: data.v || hsv.v,
                source: 'hsv'
              }, e);
            }
          };
          return React.createElement('div', {
            style: styles.fields
          }, React.createElement(EditableInput, {
            style: {
              wrap: styles.RGBwrap,
              input: styles.RGBinput,
              label: styles.RGBlabel
            },
            label: 'h',
            value: Math.round(hsv.h),
            onChange: handleChange
          }), React.createElement(EditableInput, {
            style: {
              wrap: styles.RGBwrap,
              input: styles.RGBinput,
              label: styles.RGBlabel
            },
            label: 's',
            value: Math.round(hsv.s * 100),
            onChange: handleChange
          }), React.createElement(EditableInput, {
            style: {
              wrap: styles.RGBwrap,
              input: styles.RGBinput,
              label: styles.RGBlabel
            },
            label: 'v',
            value: Math.round(hsv.v * 100),
            onChange: handleChange
          }), React.createElement('div', {
            style: styles.divider
          }), React.createElement(EditableInput, {
            style: {
              wrap: styles.RGBwrap,
              input: styles.RGBinput,
              label: styles.RGBlabel
            },
            label: 'r',
            value: rgb.r,
            onChange: handleChange
          }), React.createElement(EditableInput, {
            style: {
              wrap: styles.RGBwrap,
              input: styles.RGBinput,
              label: styles.RGBlabel
            },
            label: 'g',
            value: rgb.g,
            onChange: handleChange
          }), React.createElement(EditableInput, {
            style: {
              wrap: styles.RGBwrap,
              input: styles.RGBinput,
              label: styles.RGBlabel
            },
            label: 'b',
            value: rgb.b,
            onChange: handleChange
          }), React.createElement('div', {
            style: styles.divider
          }), React.createElement(EditableInput, {
            style: {
              wrap: styles.HEXwrap,
              input: styles.HEXinput,
              label: styles.HEXlabel
            },
            label: '#',
            value: hex.replace('#', ''),
            onChange: handleChange
          }), React.createElement('div', {
            style: styles.fieldSymbols
          }, React.createElement('div', {
            style: styles.symbol
          }, '\xB0'), React.createElement('div', {
            style: styles.symbol
          }, '%'), React.createElement('div', {
            style: styles.symbol
          }, '%')));
        };
        var PhotoshopPointerCircle$1 = function PhotoshopPointerCircle(_ref) {
          var hsl = _ref.hsl;
          var styles = _default$a({
            'default': {
              picker: {
                width: '12px',
                height: '12px',
                borderRadius: '6px',
                boxShadow: 'inset 0 0 0 1px #fff',
                transform: 'translate(-6px, -6px)'
              }
            },
            'black-outline': {
              picker: {
                boxShadow: 'inset 0 0 0 1px #000'
              }
            }
          }, {
            'black-outline': hsl.l > 0.5
          });
          return React.createElement('div', {
            style: styles.picker
          });
        };
        var PhotoshopPointerCircle = function PhotoshopPointerCircle() {
          var styles = _default$a({
            'default': {
              triangle: {
                width: 0,
                height: 0,
                borderStyle: 'solid',
                borderWidth: '4px 0 4px 6px',
                borderColor: 'transparent transparent transparent #fff',
                position: 'absolute',
                top: '1px',
                left: '1px'
              },
              triangleBorder: {
                width: 0,
                height: 0,
                borderStyle: 'solid',
                borderWidth: '5px 0 5px 8px',
                borderColor: 'transparent transparent transparent #555'
              },
              left: {
                Extend: 'triangleBorder',
                transform: 'translate(-13px, -4px)'
              },
              leftInside: {
                Extend: 'triangle',
                transform: 'translate(-8px, -5px)'
              },
              right: {
                Extend: 'triangleBorder',
                transform: 'translate(20px, -14px) rotate(180deg)'
              },
              rightInside: {
                Extend: 'triangle',
                transform: 'translate(-8px, -5px)'
              }
            }
          });
          return React.createElement('div', {
            style: styles.pointer
          }, React.createElement('div', {
            style: styles.left
          }, React.createElement('div', {
            style: styles.leftInside
          })), React.createElement('div', {
            style: styles.right
          }, React.createElement('div', {
            style: styles.rightInside
          })));
        };
        var PhotoshopButton = function PhotoshopButton(_ref) {
          var onClick = _ref.onClick,
            label = _ref.label,
            children = _ref.children,
            active = _ref.active;
          var styles = _default$a({
            'default': {
              button: {
                backgroundImage: 'linear-gradient(-180deg, #FFFFFF 0%, #E6E6E6 100%)',
                border: '1px solid #878787',
                borderRadius: '2px',
                height: '20px',
                boxShadow: '0 1px 0 0 #EAEAEA',
                fontSize: '14px',
                color: '#000',
                lineHeight: '20px',
                textAlign: 'center',
                marginBottom: '10px',
                cursor: 'pointer'
              }
            },
            'active': {
              button: {
                boxShadow: '0 0 0 1px #878787'
              }
            }
          }, {
            active: active
          });
          return React.createElement('div', {
            style: styles.button,
            onClick: onClick
          }, label || children);
        };
        var PhotoshopPreviews = function PhotoshopPreviews(_ref) {
          var rgb = _ref.rgb,
            currentColor = _ref.currentColor;
          var styles = _default$a({
            'default': {
              swatches: {
                border: '1px solid #B3B3B3',
                borderBottom: '1px solid #F0F0F0',
                marginBottom: '2px',
                marginTop: '1px'
              },
              new: {
                height: '34px',
                background: 'rgb(' + rgb.r + ',' + rgb.g + ', ' + rgb.b + ')',
                boxShadow: 'inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 1px 0 #000'
              },
              current: {
                height: '34px',
                background: currentColor,
                boxShadow: 'inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 -1px 0 #000'
              },
              label: {
                fontSize: '14px',
                color: '#000',
                textAlign: 'center'
              }
            }
          });
          return React.createElement('div', null, React.createElement('div', {
            style: styles.label
          }, 'new'), React.createElement('div', {
            style: styles.swatches
          }, React.createElement('div', {
            style: styles.new
          }), React.createElement('div', {
            style: styles.current
          })), React.createElement('div', {
            style: styles.label
          }, 'current'));
        };
        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var Photoshop = function (_React$Component) {
          _inherits(Photoshop, _React$Component);
          function Photoshop(props) {
            _classCallCheck(this, Photoshop);
            var _this = _possibleConstructorReturn(this, (Photoshop.__proto__ || Object.getPrototypeOf(Photoshop)).call(this));
            _this.state = {
              currentColor: props.hex
            };
            return _this;
          }
          _createClass(Photoshop, [{
            key: 'render',
            value: function render() {
              var _props = this.props,
                _props$styles = _props.styles,
                passedStyles = _props$styles === undefined ? {} : _props$styles,
                _props$className = _props.className,
                className = _props$className === undefined ? '' : _props$className;
              var styles = _default$a(merge$4({
                'default': {
                  picker: {
                    background: '#DCDCDC',
                    borderRadius: '4px',
                    boxShadow: '0 0 0 1px rgba(0,0,0,.25), 0 8px 16px rgba(0,0,0,.15)',
                    boxSizing: 'initial',
                    width: '513px'
                  },
                  head: {
                    backgroundImage: 'linear-gradient(-180deg, #F0F0F0 0%, #D4D4D4 100%)',
                    borderBottom: '1px solid #B1B1B1',
                    boxShadow: 'inset 0 1px 0 0 rgba(255,255,255,.2), inset 0 -1px 0 0 rgba(0,0,0,.02)',
                    height: '23px',
                    lineHeight: '24px',
                    borderRadius: '4px 4px 0 0',
                    fontSize: '13px',
                    color: '#4D4D4D',
                    textAlign: 'center'
                  },
                  body: {
                    padding: '15px 15px 0',
                    display: 'flex'
                  },
                  saturation: {
                    width: '256px',
                    height: '256px',
                    position: 'relative',
                    border: '2px solid #B3B3B3',
                    borderBottom: '2px solid #F0F0F0',
                    overflow: 'hidden'
                  },
                  hue: {
                    position: 'relative',
                    height: '256px',
                    width: '19px',
                    marginLeft: '10px',
                    border: '2px solid #B3B3B3',
                    borderBottom: '2px solid #F0F0F0'
                  },
                  controls: {
                    width: '180px',
                    marginLeft: '10px'
                  },
                  top: {
                    display: 'flex'
                  },
                  previews: {
                    width: '60px'
                  },
                  actions: {
                    flex: '1',
                    marginLeft: '20px'
                  }
                }
              }, passedStyles));
              return React.createElement('div', {
                style: styles.picker,
                className: 'photoshop-picker ' + className
              }, React.createElement('div', {
                style: styles.head
              }, this.props.header), React.createElement('div', {
                style: styles.body,
                className: 'flexbox-fix'
              }, React.createElement('div', {
                style: styles.saturation
              }, React.createElement(Saturation, {
                hsl: this.props.hsl,
                hsv: this.props.hsv,
                pointer: PhotoshopPointerCircle$1,
                onChange: this.props.onChange
              })), React.createElement('div', {
                style: styles.hue
              }, React.createElement(Hue, {
                direction: 'vertical',
                hsl: this.props.hsl,
                pointer: PhotoshopPointerCircle,
                onChange: this.props.onChange
              })), React.createElement('div', {
                style: styles.controls
              }, React.createElement('div', {
                style: styles.top,
                className: 'flexbox-fix'
              }, React.createElement('div', {
                style: styles.previews
              }, React.createElement(PhotoshopPreviews, {
                rgb: this.props.rgb,
                currentColor: this.state.currentColor
              })), React.createElement('div', {
                style: styles.actions
              }, React.createElement(PhotoshopButton, {
                label: 'OK',
                onClick: this.props.onAccept,
                active: true
              }), React.createElement(PhotoshopButton, {
                label: 'Cancel',
                onClick: this.props.onCancel
              }), React.createElement(PhotoshopPicker, {
                onChange: this.props.onChange,
                rgb: this.props.rgb,
                hsv: this.props.hsv,
                hex: this.props.hex
              }))))));
            }
          }]);
          return Photoshop;
        }(React.Component);
        Photoshop.propTypes = {
          header: PropTypes.string,
          styles: PropTypes.object
        };
        Photoshop.defaultProps = {
          header: 'Color Picker',
          styles: {}
        };
        ColorWrap(Photoshop);

        /* eslint-disable no-param-reassign */

        var SketchFields = function SketchFields(_ref) {
          var onChange = _ref.onChange,
            rgb = _ref.rgb,
            hsl = _ref.hsl,
            hex = _ref.hex,
            disableAlpha = _ref.disableAlpha;
          var styles = _default$a({
            'default': {
              fields: {
                display: 'flex',
                paddingTop: '4px'
              },
              single: {
                flex: '1',
                paddingLeft: '6px'
              },
              alpha: {
                flex: '1',
                paddingLeft: '6px'
              },
              double: {
                flex: '2'
              },
              input: {
                width: '80%',
                padding: '4px 10% 3px',
                border: 'none',
                boxShadow: 'inset 0 0 0 1px #ccc',
                fontSize: '11px'
              },
              label: {
                display: 'block',
                textAlign: 'center',
                fontSize: '11px',
                color: '#222',
                paddingTop: '3px',
                paddingBottom: '4px',
                textTransform: 'capitalize'
              }
            },
            'disableAlpha': {
              alpha: {
                display: 'none'
              }
            }
          }, {
            disableAlpha: disableAlpha
          });
          var handleChange = function handleChange(data, e) {
            if (data.hex) {
              isValidHex(data.hex) && onChange({
                hex: data.hex,
                source: 'hex'
              }, e);
            } else if (data.r || data.g || data.b) {
              onChange({
                r: data.r || rgb.r,
                g: data.g || rgb.g,
                b: data.b || rgb.b,
                a: rgb.a,
                source: 'rgb'
              }, e);
            } else if (data.a) {
              if (data.a < 0) {
                data.a = 0;
              } else if (data.a > 100) {
                data.a = 100;
              }
              data.a /= 100;
              onChange({
                h: hsl.h,
                s: hsl.s,
                l: hsl.l,
                a: data.a,
                source: 'rgb'
              }, e);
            }
          };
          return React.createElement('div', {
            style: styles.fields,
            className: 'flexbox-fix'
          }, React.createElement('div', {
            style: styles.double
          }, React.createElement(EditableInput, {
            style: {
              input: styles.input,
              label: styles.label
            },
            label: 'hex',
            value: hex.replace('#', ''),
            onChange: handleChange
          })), React.createElement('div', {
            style: styles.single
          }, React.createElement(EditableInput, {
            style: {
              input: styles.input,
              label: styles.label
            },
            label: 'r',
            value: rgb.r,
            onChange: handleChange,
            dragLabel: 'true',
            dragMax: '255'
          })), React.createElement('div', {
            style: styles.single
          }, React.createElement(EditableInput, {
            style: {
              input: styles.input,
              label: styles.label
            },
            label: 'g',
            value: rgb.g,
            onChange: handleChange,
            dragLabel: 'true',
            dragMax: '255'
          })), React.createElement('div', {
            style: styles.single
          }, React.createElement(EditableInput, {
            style: {
              input: styles.input,
              label: styles.label
            },
            label: 'b',
            value: rgb.b,
            onChange: handleChange,
            dragLabel: 'true',
            dragMax: '255'
          })), React.createElement('div', {
            style: styles.alpha
          }, React.createElement(EditableInput, {
            style: {
              input: styles.input,
              label: styles.label
            },
            label: 'a',
            value: Math.round(rgb.a * 100),
            onChange: handleChange,
            dragLabel: 'true',
            dragMax: '100'
          })));
        };
        var _extends$3 = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        var SketchPresetColors = function SketchPresetColors(_ref) {
          var colors = _ref.colors,
            _ref$onClick = _ref.onClick,
            onClick = _ref$onClick === undefined ? function () {} : _ref$onClick,
            onSwatchHover = _ref.onSwatchHover;
          var styles = _default$a({
            'default': {
              colors: {
                margin: '0 -10px',
                padding: '10px 0 0 10px',
                borderTop: '1px solid #eee',
                display: 'flex',
                flexWrap: 'wrap',
                position: 'relative'
              },
              swatchWrap: {
                width: '16px',
                height: '16px',
                margin: '0 10px 10px 0'
              },
              swatch: {
                borderRadius: '3px',
                boxShadow: 'inset 0 0 0 1px rgba(0,0,0,.15)'
              }
            },
            'no-presets': {
              colors: {
                display: 'none'
              }
            }
          }, {
            'no-presets': !colors || !colors.length
          });
          var handleClick = function handleClick(hex, e) {
            onClick({
              hex: hex,
              source: 'hex'
            }, e);
          };
          return React.createElement('div', {
            style: styles.colors,
            className: 'flexbox-fix'
          }, colors.map(function (colorObjOrString) {
            var c = typeof colorObjOrString === 'string' ? {
              color: colorObjOrString
            } : colorObjOrString;
            var key = '' + c.color + (c.title || '');
            return React.createElement('div', {
              key: key,
              style: styles.swatchWrap
            }, React.createElement(Swatch$1, _extends$3({}, c, {
              style: styles.swatch,
              onClick: handleClick,
              onHover: onSwatchHover,
              focusStyle: {
                boxShadow: 'inset 0 0 0 1px rgba(0,0,0,.15), 0 0 4px ' + c.color
              }
            })));
          }));
        };
        SketchPresetColors.propTypes = {
          colors: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.shape({
            color: PropTypes.string,
            title: PropTypes.string
          })])).isRequired
        };
        var _extends$2 = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        var Sketch = function Sketch(_ref) {
          var width = _ref.width,
            rgb = _ref.rgb,
            hex = _ref.hex,
            hsv = _ref.hsv,
            hsl = _ref.hsl,
            onChange = _ref.onChange,
            onSwatchHover = _ref.onSwatchHover,
            disableAlpha = _ref.disableAlpha,
            presetColors = _ref.presetColors,
            renderers = _ref.renderers,
            _ref$styles = _ref.styles,
            passedStyles = _ref$styles === undefined ? {} : _ref$styles,
            _ref$className = _ref.className,
            className = _ref$className === undefined ? '' : _ref$className;
          var styles = _default$a(merge$4({
            'default': _extends$2({
              picker: {
                width: width,
                padding: '10px 10px 0',
                boxSizing: 'initial',
                background: '#fff',
                borderRadius: '4px',
                boxShadow: '0 0 0 1px rgba(0,0,0,.15), 0 8px 16px rgba(0,0,0,.15)'
              },
              saturation: {
                width: '100%',
                paddingBottom: '75%',
                position: 'relative',
                overflow: 'hidden'
              },
              Saturation: {
                radius: '3px',
                shadow: 'inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)'
              },
              controls: {
                display: 'flex'
              },
              sliders: {
                padding: '4px 0',
                flex: '1'
              },
              color: {
                width: '24px',
                height: '24px',
                position: 'relative',
                marginTop: '4px',
                marginLeft: '4px',
                borderRadius: '3px'
              },
              activeColor: {
                absolute: '0px 0px 0px 0px',
                borderRadius: '2px',
                background: 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + rgb.a + ')',
                boxShadow: 'inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)'
              },
              hue: {
                position: 'relative',
                height: '10px',
                overflow: 'hidden'
              },
              Hue: {
                radius: '2px',
                shadow: 'inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)'
              },
              alpha: {
                position: 'relative',
                height: '10px',
                marginTop: '4px',
                overflow: 'hidden'
              },
              Alpha: {
                radius: '2px',
                shadow: 'inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)'
              }
            }, passedStyles),
            'disableAlpha': {
              color: {
                height: '10px'
              },
              hue: {
                height: '10px'
              },
              alpha: {
                display: 'none'
              }
            }
          }, passedStyles), {
            disableAlpha: disableAlpha
          });
          return React.createElement('div', {
            style: styles.picker,
            className: 'sketch-picker ' + className
          }, React.createElement('div', {
            style: styles.saturation
          }, React.createElement(Saturation, {
            style: styles.Saturation,
            hsl: hsl,
            hsv: hsv,
            onChange: onChange
          })), React.createElement('div', {
            style: styles.controls,
            className: 'flexbox-fix'
          }, React.createElement('div', {
            style: styles.sliders
          }, React.createElement('div', {
            style: styles.hue
          }, React.createElement(Hue, {
            style: styles.Hue,
            hsl: hsl,
            onChange: onChange
          })), React.createElement('div', {
            style: styles.alpha
          }, React.createElement(Alpha, {
            style: styles.Alpha,
            rgb: rgb,
            hsl: hsl,
            renderers: renderers,
            onChange: onChange
          }))), React.createElement('div', {
            style: styles.color
          }, React.createElement(Checkboard, null), React.createElement('div', {
            style: styles.activeColor
          }))), React.createElement(SketchFields, {
            rgb: rgb,
            hsl: hsl,
            hex: hex,
            onChange: onChange,
            disableAlpha: disableAlpha
          }), React.createElement(SketchPresetColors, {
            colors: presetColors,
            onClick: onChange,
            onSwatchHover: onSwatchHover
          }));
        };
        Sketch.propTypes = {
          disableAlpha: PropTypes.bool,
          width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
          styles: PropTypes.object
        };
        Sketch.defaultProps = {
          disableAlpha: false,
          width: 200,
          styles: {},
          presetColors: ['#D0021B', '#F5A623', '#F8E71C', '#8B572A', '#7ED321', '#417505', '#BD10E0', '#9013FE', '#4A90E2', '#50E3C2', '#B8E986', '#000000', '#4A4A4A', '#9B9B9B', '#FFFFFF']
        };
        ColorWrap(Sketch);
        var SliderSwatch = function SliderSwatch(_ref) {
          var hsl = _ref.hsl,
            offset = _ref.offset,
            _ref$onClick = _ref.onClick,
            onClick = _ref$onClick === undefined ? function () {} : _ref$onClick,
            active = _ref.active,
            first = _ref.first,
            last = _ref.last;
          var styles = _default$a({
            'default': {
              swatch: {
                height: '12px',
                background: 'hsl(' + hsl.h + ', 50%, ' + offset * 100 + '%)',
                cursor: 'pointer'
              }
            },
            'first': {
              swatch: {
                borderRadius: '2px 0 0 2px'
              }
            },
            'last': {
              swatch: {
                borderRadius: '0 2px 2px 0'
              }
            },
            'active': {
              swatch: {
                transform: 'scaleY(1.8)',
                borderRadius: '3.6px/2px'
              }
            }
          }, {
            active: active,
            first: first,
            last: last
          });
          var handleClick = function handleClick(e) {
            return onClick({
              h: hsl.h,
              s: 0.5,
              l: offset,
              source: 'hsl'
            }, e);
          };
          return React.createElement('div', {
            style: styles.swatch,
            onClick: handleClick
          });
        };
        var SliderSwatches = function SliderSwatches(_ref) {
          var onClick = _ref.onClick,
            hsl = _ref.hsl;
          var styles = _default$a({
            'default': {
              swatches: {
                marginTop: '20px'
              },
              swatch: {
                boxSizing: 'border-box',
                width: '20%',
                paddingRight: '1px',
                float: 'left'
              },
              clear: {
                clear: 'both'
              }
            }
          });

          // Acceptible difference in floating point equality
          var epsilon = 0.1;
          return React.createElement('div', {
            style: styles.swatches
          }, React.createElement('div', {
            style: styles.swatch
          }, React.createElement(SliderSwatch, {
            hsl: hsl,
            offset: '.80',
            active: Math.abs(hsl.l - 0.80) < epsilon && Math.abs(hsl.s - 0.50) < epsilon,
            onClick: onClick,
            first: true
          })), React.createElement('div', {
            style: styles.swatch
          }, React.createElement(SliderSwatch, {
            hsl: hsl,
            offset: '.65',
            active: Math.abs(hsl.l - 0.65) < epsilon && Math.abs(hsl.s - 0.50) < epsilon,
            onClick: onClick
          })), React.createElement('div', {
            style: styles.swatch
          }, React.createElement(SliderSwatch, {
            hsl: hsl,
            offset: '.50',
            active: Math.abs(hsl.l - 0.50) < epsilon && Math.abs(hsl.s - 0.50) < epsilon,
            onClick: onClick
          })), React.createElement('div', {
            style: styles.swatch
          }, React.createElement(SliderSwatch, {
            hsl: hsl,
            offset: '.35',
            active: Math.abs(hsl.l - 0.35) < epsilon && Math.abs(hsl.s - 0.50) < epsilon,
            onClick: onClick
          })), React.createElement('div', {
            style: styles.swatch
          }, React.createElement(SliderSwatch, {
            hsl: hsl,
            offset: '.20',
            active: Math.abs(hsl.l - 0.20) < epsilon && Math.abs(hsl.s - 0.50) < epsilon,
            onClick: onClick,
            last: true
          })), React.createElement('div', {
            style: styles.clear
          }));
        };
        var SliderPointer = function SliderPointer() {
          var styles = _default$a({
            'default': {
              picker: {
                width: '14px',
                height: '14px',
                borderRadius: '6px',
                transform: 'translate(-7px, -1px)',
                backgroundColor: 'rgb(248, 248, 248)',
                boxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.37)'
              }
            }
          });
          return React.createElement('div', {
            style: styles.picker
          });
        };
        var Slider = function Slider(_ref) {
          var hsl = _ref.hsl,
            onChange = _ref.onChange,
            pointer = _ref.pointer,
            _ref$styles = _ref.styles,
            passedStyles = _ref$styles === undefined ? {} : _ref$styles,
            _ref$className = _ref.className,
            className = _ref$className === undefined ? '' : _ref$className;
          var styles = _default$a(merge$4({
            'default': {
              hue: {
                height: '12px',
                position: 'relative'
              },
              Hue: {
                radius: '2px'
              }
            }
          }, passedStyles));
          return React.createElement('div', {
            style: styles.wrap || {},
            className: 'slider-picker ' + className
          }, React.createElement('div', {
            style: styles.hue
          }, React.createElement(Hue, {
            style: styles.Hue,
            hsl: hsl,
            pointer: pointer,
            onChange: onChange
          })), React.createElement('div', {
            style: styles.swatches
          }, React.createElement(SliderSwatches, {
            hsl: hsl,
            onClick: onChange
          })));
        };
        Slider.propTypes = {
          styles: PropTypes.object
        };
        Slider.defaultProps = {
          pointer: SliderPointer,
          styles: {}
        };
        ColorWrap(Slider);
        var CheckIcon = {};
        Object.defineProperty(CheckIcon, "__esModule", {
          value: true
        });
        var _extends$1 = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        var _react = reactExports;
        var _react2 = _interopRequireDefault$8(_react);
        function _interopRequireDefault$8(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        function _objectWithoutProperties(obj, keys) {
          var target = {};
          for (var i in obj) {
            if (keys.indexOf(i) >= 0) continue;
            if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
            target[i] = obj[i];
          }
          return target;
        }
        var DEFAULT_SIZE = 24;
        var _default$8 = CheckIcon.default = function (_ref) {
          var _ref$fill = _ref.fill,
            fill = _ref$fill === undefined ? 'currentColor' : _ref$fill,
            _ref$width = _ref.width,
            width = _ref$width === undefined ? DEFAULT_SIZE : _ref$width,
            _ref$height = _ref.height,
            height = _ref$height === undefined ? DEFAULT_SIZE : _ref$height,
            _ref$style = _ref.style,
            style = _ref$style === undefined ? {} : _ref$style,
            props = _objectWithoutProperties(_ref, ['fill', 'width', 'height', 'style']);
          return _react2.default.createElement('svg', _extends$1({
            viewBox: '0 0 ' + DEFAULT_SIZE + ' ' + DEFAULT_SIZE,
            style: _extends$1({
              fill: fill,
              width: width,
              height: height
            }, style)
          }, props), _react2.default.createElement('path', {
            d: 'M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z'
          }));
        };
        var SwatchesColor = function SwatchesColor(_ref) {
          var color = _ref.color,
            _ref$onClick = _ref.onClick,
            onClick = _ref$onClick === undefined ? function () {} : _ref$onClick,
            onSwatchHover = _ref.onSwatchHover,
            first = _ref.first,
            last = _ref.last,
            active = _ref.active;
          var styles = _default$a({
            'default': {
              color: {
                width: '40px',
                height: '24px',
                cursor: 'pointer',
                background: color,
                marginBottom: '1px'
              },
              check: {
                color: getContrastingColor(color),
                marginLeft: '8px',
                display: 'none'
              }
            },
            'first': {
              color: {
                overflow: 'hidden',
                borderRadius: '2px 2px 0 0'
              }
            },
            'last': {
              color: {
                overflow: 'hidden',
                borderRadius: '0 0 2px 2px'
              }
            },
            'active': {
              check: {
                display: 'block'
              }
            },
            'color-#FFFFFF': {
              color: {
                boxShadow: 'inset 0 0 0 1px #ddd'
              },
              check: {
                color: '#333'
              }
            },
            'transparent': {
              check: {
                color: '#333'
              }
            }
          }, {
            first: first,
            last: last,
            active: active,
            'color-#FFFFFF': color === '#FFFFFF',
            'transparent': color === 'transparent'
          });
          return React.createElement(Swatch$1, {
            color: color,
            style: styles.color,
            onClick: onClick,
            onHover: onSwatchHover,
            focusStyle: {
              boxShadow: '0 0 4px ' + color
            }
          }, React.createElement('div', {
            style: styles.check
          }, React.createElement(_default$8, null)));
        };
        var SwatchesGroup = function SwatchesGroup(_ref) {
          var onClick = _ref.onClick,
            onSwatchHover = _ref.onSwatchHover,
            group = _ref.group,
            active = _ref.active;
          var styles = _default$a({
            'default': {
              group: {
                paddingBottom: '10px',
                width: '40px',
                float: 'left',
                marginRight: '10px'
              }
            }
          });
          return React.createElement('div', {
            style: styles.group
          }, map$1(group, function (color, i) {
            return React.createElement(SwatchesColor, {
              key: color,
              color: color,
              active: color.toLowerCase() === active,
              first: i === 0,
              last: i === group.length - 1,
              onClick: onClick,
              onSwatchHover: onSwatchHover
            });
          }));
        };
        var Swatches = function Swatches(_ref) {
          var width = _ref.width,
            height = _ref.height,
            onChange = _ref.onChange,
            onSwatchHover = _ref.onSwatchHover,
            colors = _ref.colors,
            hex = _ref.hex,
            _ref$styles = _ref.styles,
            passedStyles = _ref$styles === undefined ? {} : _ref$styles,
            _ref$className = _ref.className,
            className = _ref$className === undefined ? '' : _ref$className;
          var styles = _default$a(merge$4({
            'default': {
              picker: {
                width: width,
                height: height
              },
              overflow: {
                height: height,
                overflowY: 'scroll'
              },
              body: {
                padding: '16px 0 6px 16px'
              },
              clear: {
                clear: 'both'
              }
            }
          }, passedStyles));
          var handleChange = function handleChange(data, e) {
            return onChange({
              hex: data,
              source: 'hex'
            }, e);
          };
          return React.createElement('div', {
            style: styles.picker,
            className: 'swatches-picker ' + className
          }, React.createElement(Raised, null, React.createElement('div', {
            style: styles.overflow
          }, React.createElement('div', {
            style: styles.body
          }, map$1(colors, function (group) {
            return React.createElement(SwatchesGroup, {
              key: group.toString(),
              group: group,
              active: hex,
              onClick: handleChange,
              onSwatchHover: onSwatchHover
            });
          }), React.createElement('div', {
            style: styles.clear
          })))));
        };
        Swatches.propTypes = {
          width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
          height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
          colors: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)),
          styles: PropTypes.object

          /* eslint-disable max-len */
        };
        Swatches.defaultProps = {
          width: 320,
          height: 240,
          colors: [[red['900'], red['700'], red['500'], red['300'], red['100']], [pink['900'], pink['700'], pink['500'], pink['300'], pink['100']], [purple['900'], purple['700'], purple['500'], purple['300'], purple['100']], [deepPurple['900'], deepPurple['700'], deepPurple['500'], deepPurple['300'], deepPurple['100']], [indigo['900'], indigo['700'], indigo['500'], indigo['300'], indigo['100']], [blue['900'], blue['700'], blue['500'], blue['300'], blue['100']], [lightBlue['900'], lightBlue['700'], lightBlue['500'], lightBlue['300'], lightBlue['100']], [cyan['900'], cyan['700'], cyan['500'], cyan['300'], cyan['100']], [teal['900'], teal['700'], teal['500'], teal['300'], teal['100']], ['#194D33', green['700'], green['500'], green['300'], green['100']], [lightGreen['900'], lightGreen['700'], lightGreen['500'], lightGreen['300'], lightGreen['100']], [lime['900'], lime['700'], lime['500'], lime['300'], lime['100']], [yellow['900'], yellow['700'], yellow['500'], yellow['300'], yellow['100']], [amber['900'], amber['700'], amber['500'], amber['300'], amber['100']], [orange['900'], orange['700'], orange['500'], orange['300'], orange['100']], [deepOrange['900'], deepOrange['700'], deepOrange['500'], deepOrange['300'], deepOrange['100']], [brown['900'], brown['700'], brown['500'], brown['300'], brown['100']], [blueGrey['900'], blueGrey['700'], blueGrey['500'], blueGrey['300'], blueGrey['100']], ['#000000', '#525252', '#969696', '#D9D9D9', '#FFFFFF']],
          styles: {}
        };
        const SwatchesPicker = ColorWrap(Swatches);
        var Twitter = function Twitter(_ref) {
          var onChange = _ref.onChange,
            onSwatchHover = _ref.onSwatchHover,
            hex = _ref.hex,
            colors = _ref.colors,
            width = _ref.width,
            triangle = _ref.triangle,
            _ref$styles = _ref.styles,
            passedStyles = _ref$styles === undefined ? {} : _ref$styles,
            _ref$className = _ref.className,
            className = _ref$className === undefined ? '' : _ref$className;
          var styles = _default$a(merge$4({
            'default': {
              card: {
                width: width,
                background: '#fff',
                border: '0 solid rgba(0,0,0,0.25)',
                boxShadow: '0 1px 4px rgba(0,0,0,0.25)',
                borderRadius: '4px',
                position: 'relative'
              },
              body: {
                padding: '15px 9px 9px 15px'
              },
              label: {
                fontSize: '18px',
                color: '#fff'
              },
              triangle: {
                width: '0px',
                height: '0px',
                borderStyle: 'solid',
                borderWidth: '0 9px 10px 9px',
                borderColor: 'transparent transparent #fff transparent',
                position: 'absolute'
              },
              triangleShadow: {
                width: '0px',
                height: '0px',
                borderStyle: 'solid',
                borderWidth: '0 9px 10px 9px',
                borderColor: 'transparent transparent rgba(0,0,0,.1) transparent',
                position: 'absolute'
              },
              hash: {
                background: '#F0F0F0',
                height: '30px',
                width: '30px',
                borderRadius: '4px 0 0 4px',
                float: 'left',
                color: '#98A1A4',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center'
              },
              input: {
                width: '100px',
                fontSize: '14px',
                color: '#666',
                border: '0px',
                outline: 'none',
                height: '28px',
                boxShadow: 'inset 0 0 0 1px #F0F0F0',
                boxSizing: 'content-box',
                borderRadius: '0 4px 4px 0',
                float: 'left',
                paddingLeft: '8px'
              },
              swatch: {
                width: '30px',
                height: '30px',
                float: 'left',
                borderRadius: '4px',
                margin: '0 6px 6px 0'
              },
              clear: {
                clear: 'both'
              }
            },
            'hide-triangle': {
              triangle: {
                display: 'none'
              },
              triangleShadow: {
                display: 'none'
              }
            },
            'top-left-triangle': {
              triangle: {
                top: '-10px',
                left: '12px'
              },
              triangleShadow: {
                top: '-11px',
                left: '12px'
              }
            },
            'top-right-triangle': {
              triangle: {
                top: '-10px',
                right: '12px'
              },
              triangleShadow: {
                top: '-11px',
                right: '12px'
              }
            }
          }, passedStyles), {
            'hide-triangle': triangle === 'hide',
            'top-left-triangle': triangle === 'top-left',
            'top-right-triangle': triangle === 'top-right'
          });
          var handleChange = function handleChange(hexcode, e) {
            isValidHex(hexcode) && onChange({
              hex: hexcode,
              source: 'hex'
            }, e);
          };
          return React.createElement('div', {
            style: styles.card,
            className: 'twitter-picker ' + className
          }, React.createElement('div', {
            style: styles.triangleShadow
          }), React.createElement('div', {
            style: styles.triangle
          }), React.createElement('div', {
            style: styles.body
          }, map$1(colors, function (c, i) {
            return React.createElement(Swatch$1, {
              key: i,
              color: c,
              hex: c,
              style: styles.swatch,
              onClick: handleChange,
              onHover: onSwatchHover,
              focusStyle: {
                boxShadow: '0 0 4px ' + c
              }
            });
          }), React.createElement('div', {
            style: styles.hash
          }, '#'), React.createElement(EditableInput, {
            label: null,
            style: {
              input: styles.input
            },
            value: hex.replace('#', ''),
            onChange: handleChange
          }), React.createElement('div', {
            style: styles.clear
          })));
        };
        Twitter.propTypes = {
          width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
          triangle: PropTypes.oneOf(['hide', 'top-left', 'top-right']),
          colors: PropTypes.arrayOf(PropTypes.string),
          styles: PropTypes.object
        };
        Twitter.defaultProps = {
          width: 276,
          colors: ['#FF6900', '#FCB900', '#7BDCB5', '#00D084', '#8ED1FC', '#0693E3', '#ABB8C3', '#EB144C', '#F78DA7', '#9900EF'],
          triangle: 'top-left',
          styles: {}
        };
        ColorWrap(Twitter);
        var GooglePointerCircle = function GooglePointerCircle(props) {
          var styles = _default$a({
            'default': {
              picker: {
                width: '20px',
                height: '20px',
                borderRadius: '22px',
                border: '2px #fff solid',
                transform: 'translate(-12px, -13px)',
                background: 'hsl(' + Math.round(props.hsl.h) + ', ' + Math.round(props.hsl.s * 100) + '%, ' + Math.round(props.hsl.l * 100) + '%)'
              }
            }
          });
          return React.createElement('div', {
            style: styles.picker
          });
        };
        GooglePointerCircle.propTypes = {
          hsl: PropTypes.shape({
            h: PropTypes.number,
            s: PropTypes.number,
            l: PropTypes.number,
            a: PropTypes.number
          })
        };
        GooglePointerCircle.defaultProps = {
          hsl: {
            a: 1,
            h: 249.94,
            l: 0.2,
            s: 0.50
          }
        };
        var GooglePointer = function GooglePointer(props) {
          var styles = _default$a({
            'default': {
              picker: {
                width: '20px',
                height: '20px',
                borderRadius: '22px',
                transform: 'translate(-10px, -7px)',
                background: 'hsl(' + Math.round(props.hsl.h) + ', 100%, 50%)',
                border: '2px white solid'
              }
            }
          });
          return React.createElement('div', {
            style: styles.picker
          });
        };
        GooglePointer.propTypes = {
          hsl: PropTypes.shape({
            h: PropTypes.number,
            s: PropTypes.number,
            l: PropTypes.number,
            a: PropTypes.number
          })
        };
        GooglePointer.defaultProps = {
          hsl: {
            a: 1,
            h: 249.94,
            l: 0.2,
            s: 0.50
          }
        };
        var GoogleFields = function GoogleFields(_ref) {
          var onChange = _ref.onChange,
            rgb = _ref.rgb,
            hsl = _ref.hsl,
            hex = _ref.hex,
            hsv = _ref.hsv;
          var handleChange = function handleChange(data, e) {
            if (data.hex) {
              isValidHex(data.hex) && onChange({
                hex: data.hex,
                source: 'hex'
              }, e);
            } else if (data.rgb) {
              var values = data.rgb.split(',');
              isvalidColorString(data.rgb, 'rgb') && onChange({
                r: values[0],
                g: values[1],
                b: values[2],
                a: 1,
                source: 'rgb'
              }, e);
            } else if (data.hsv) {
              var _values = data.hsv.split(',');
              if (isvalidColorString(data.hsv, 'hsv')) {
                _values[2] = _values[2].replace('%', '');
                _values[1] = _values[1].replace('%', '');
                _values[0] = _values[0].replace('°', '');
                if (_values[1] == 1) {
                  _values[1] = 0.01;
                } else if (_values[2] == 1) {
                  _values[2] = 0.01;
                }
                onChange({
                  h: Number(_values[0]),
                  s: Number(_values[1]),
                  v: Number(_values[2]),
                  source: 'hsv'
                }, e);
              }
            } else if (data.hsl) {
              var _values2 = data.hsl.split(',');
              if (isvalidColorString(data.hsl, 'hsl')) {
                _values2[2] = _values2[2].replace('%', '');
                _values2[1] = _values2[1].replace('%', '');
                _values2[0] = _values2[0].replace('°', '');
                if (hsvValue[1] == 1) {
                  hsvValue[1] = 0.01;
                } else if (hsvValue[2] == 1) {
                  hsvValue[2] = 0.01;
                }
                onChange({
                  h: Number(_values2[0]),
                  s: Number(_values2[1]),
                  v: Number(_values2[2]),
                  source: 'hsl'
                }, e);
              }
            }
          };
          var styles = _default$a({
            'default': {
              wrap: {
                display: 'flex',
                height: '100px',
                marginTop: '4px'
              },
              fields: {
                width: '100%'
              },
              column: {
                paddingTop: '10px',
                display: 'flex',
                justifyContent: 'space-between'
              },
              double: {
                padding: '0px 4.4px',
                boxSizing: 'border-box'
              },
              input: {
                width: '100%',
                height: '38px',
                boxSizing: 'border-box',
                padding: '4px 10% 3px',
                textAlign: 'center',
                border: '1px solid #dadce0',
                fontSize: '11px',
                textTransform: 'lowercase',
                borderRadius: '5px',
                outline: 'none',
                fontFamily: 'Roboto,Arial,sans-serif'
              },
              input2: {
                height: '38px',
                width: '100%',
                border: '1px solid #dadce0',
                boxSizing: 'border-box',
                fontSize: '11px',
                textTransform: 'lowercase',
                borderRadius: '5px',
                outline: 'none',
                paddingLeft: '10px',
                fontFamily: 'Roboto,Arial,sans-serif'
              },
              label: {
                textAlign: 'center',
                fontSize: '12px',
                background: '#fff',
                position: 'absolute',
                textTransform: 'uppercase',
                color: '#3c4043',
                width: '35px',
                top: '-6px',
                left: '0',
                right: '0',
                marginLeft: 'auto',
                marginRight: 'auto',
                fontFamily: 'Roboto,Arial,sans-serif'
              },
              label2: {
                left: '10px',
                textAlign: 'center',
                fontSize: '12px',
                background: '#fff',
                position: 'absolute',
                textTransform: 'uppercase',
                color: '#3c4043',
                width: '32px',
                top: '-6px',
                fontFamily: 'Roboto,Arial,sans-serif'
              },
              single: {
                flexGrow: '1',
                margin: '0px 4.4px'
              }
            }
          });
          var rgbValue = rgb.r + ', ' + rgb.g + ', ' + rgb.b;
          var hslValue = Math.round(hsl.h) + '\xB0, ' + Math.round(hsl.s * 100) + '%, ' + Math.round(hsl.l * 100) + '%';
          var hsvValue = Math.round(hsv.h) + '\xB0, ' + Math.round(hsv.s * 100) + '%, ' + Math.round(hsv.v * 100) + '%';
          return React.createElement('div', {
            style: styles.wrap,
            className: 'flexbox-fix'
          }, React.createElement('div', {
            style: styles.fields
          }, React.createElement('div', {
            style: styles.double
          }, React.createElement(EditableInput, {
            style: {
              input: styles.input,
              label: styles.label
            },
            label: 'hex',
            value: hex,
            onChange: handleChange
          })), React.createElement('div', {
            style: styles.column
          }, React.createElement('div', {
            style: styles.single
          }, React.createElement(EditableInput, {
            style: {
              input: styles.input2,
              label: styles.label2
            },
            label: 'rgb',
            value: rgbValue,
            onChange: handleChange
          })), React.createElement('div', {
            style: styles.single
          }, React.createElement(EditableInput, {
            style: {
              input: styles.input2,
              label: styles.label2
            },
            label: 'hsv',
            value: hsvValue,
            onChange: handleChange
          })), React.createElement('div', {
            style: styles.single
          }, React.createElement(EditableInput, {
            style: {
              input: styles.input2,
              label: styles.label2
            },
            label: 'hsl',
            value: hslValue,
            onChange: handleChange
          })))));
        };
        var Google = function Google(_ref) {
          var width = _ref.width,
            onChange = _ref.onChange,
            rgb = _ref.rgb,
            hsl = _ref.hsl,
            hsv = _ref.hsv,
            hex = _ref.hex,
            header = _ref.header,
            _ref$styles = _ref.styles,
            passedStyles = _ref$styles === undefined ? {} : _ref$styles,
            _ref$className = _ref.className,
            className = _ref$className === undefined ? '' : _ref$className;
          var styles = _default$a(merge$4({
            'default': {
              picker: {
                width: width,
                background: '#fff',
                border: '1px solid #dfe1e5',
                boxSizing: 'initial',
                display: 'flex',
                flexWrap: 'wrap',
                borderRadius: '8px 8px 0px 0px'
              },
              head: {
                height: '57px',
                width: '100%',
                paddingTop: '16px',
                paddingBottom: '16px',
                paddingLeft: '16px',
                fontSize: '20px',
                boxSizing: 'border-box',
                fontFamily: 'Roboto-Regular,HelveticaNeue,Arial,sans-serif'
              },
              saturation: {
                width: '70%',
                padding: '0px',
                position: 'relative',
                overflow: 'hidden'
              },
              swatch: {
                width: '30%',
                height: '228px',
                padding: '0px',
                background: 'rgba(' + rgb.r + ', ' + rgb.g + ', ' + rgb.b + ', 1)',
                position: 'relative',
                overflow: 'hidden'
              },
              body: {
                margin: 'auto',
                width: '95%'
              },
              controls: {
                display: 'flex',
                boxSizing: 'border-box',
                height: '52px',
                paddingTop: '22px'
              },
              color: {
                width: '32px'
              },
              hue: {
                height: '8px',
                position: 'relative',
                margin: '0px 16px 0px 16px',
                width: '100%'
              },
              Hue: {
                radius: '2px'
              }
            }
          }, passedStyles));
          return React.createElement('div', {
            style: styles.picker,
            className: 'google-picker ' + className
          }, React.createElement('div', {
            style: styles.head
          }, header), React.createElement('div', {
            style: styles.swatch
          }), React.createElement('div', {
            style: styles.saturation
          }, React.createElement(Saturation, {
            hsl: hsl,
            hsv: hsv,
            pointer: GooglePointerCircle,
            onChange: onChange
          })), React.createElement('div', {
            style: styles.body
          }, React.createElement('div', {
            style: styles.controls,
            className: 'flexbox-fix'
          }, React.createElement('div', {
            style: styles.hue
          }, React.createElement(Hue, {
            style: styles.Hue,
            hsl: hsl,
            radius: '4px',
            pointer: GooglePointer,
            onChange: onChange
          }))), React.createElement(GoogleFields, {
            rgb: rgb,
            hsl: hsl,
            hex: hex,
            hsv: hsv,
            onChange: onChange
          })));
        };
        Google.propTypes = {
          width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
          styles: PropTypes.object,
          header: PropTypes.string
        };
        Google.defaultProps = {
          width: 652,
          styles: {},
          header: 'Color picker'
        };
        ColorWrap(Google);
        function ColorPicker(props) {
          const [showColorPicker, setShowColorPicker] = reactExports.useState(false);
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("div", {
              style: {
                backgroundColor: props.color || props.default
              },
              className: styles$d.swatch,
              onClick: e => setShowColorPicker(true),
              children: /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                className: styles$d.color
              })
            }), showColorPicker ? /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("div", {
                className: styles$d.cover,
                onClick: e => setShowColorPicker(false)
              }), /* @__PURE__ */jsxRuntimeExports.jsx(SwatchesPicker, {
                onChange: e => {
                  props.handleChange(e.hex);
                  setShowColorPicker(false);
                }
              })]
            }) : null]
          });
        }
        const themingItem = "_themingItem_1o98o_1";
        const themingItemBody = "_themingItemBody_1o98o_6";
        const styles$c = {
          themingItem: themingItem,
          themingItemBody: themingItemBody
        };
        function ThemingItem(props) {
          const listFont = ["Alegreya", "Amatic SC", "Arial", "Bree Serif", "Calibri", "Cambria", "Caveat", "Comfortaa", "Comic Sans MS", "Courier New", "EB Garamond", "Georgia", "Google Sans", "Impact", "Lexend", "Lobster", "Lora", "Merriweather", "Montserrat", "Nunito", "Oswald", "Pacifico", "Permanent Marker", "Pinyon Script", "Playfair Display", "Proxima Nova", "Roboto", "Roboto Mono", "Roboto Serif", "Spectral", "Times New Roman", "Trebuchet MS", "Ultra", "Varela Round", "Verdana"];
          const listFontSize = Array.from({
            length: 12
          }, (_, index) => index * 2 + 10);
          function handleChange(key, value) {
            props.onChange({
              ...props.value,
              [key]: value
            });
          }
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            className: styles$c.themingItem,
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$c.themingItemBody,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Select, {
                size: "small",
                className: "mr-10",
                value: props.value.font || props.default.font,
                onChange: e => handleChange("font", e.target.value),
                children: listFont && listFont.length > 0 && listFont.map((el, index) => /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                  sx: {
                    fontFamily: el
                  },
                  value: el,
                  children: el
                }, `fontFamily-${index}`))
              }, "fontFamily"), /* @__PURE__ */jsxRuntimeExports.jsx(Select, {
                size: "small",
                value: props.value.size || props.default.size,
                onChange: e => handleChange("size", e.target.value),
                children: listFontSize && listFontSize.length > 0 && listFontSize.map((el, index) => /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                  value: el,
                  children: el
                }, `fontSize-${index}`))
              }, "fontSize")]
            }), /* @__PURE__ */jsxRuntimeExports.jsx("br", {}), /* @__PURE__ */jsxRuntimeExports.jsx(ColorPicker, {
              color: props.value.color,
              default: props.default.color,
              handleChange: value => handleChange("color", value)
            })]
          });
        }
        var Image = {};
        var _interopRequireDefault$7 = interopRequireDefaultExports;
        Object.defineProperty(Image, "__esModule", {
          value: true
        });
        var default_1$7 = Image.default = void 0;
        var _createSvgIcon$7 = _interopRequireDefault$7(requireCreateSvgIcon());
        var _jsxRuntime$7 = jsxRuntimeExports;
        var _default$7 = (0, _createSvgIcon$7.default)( /*#__PURE__*/(0, _jsxRuntime$7.jsx)("path", {
          d: "M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"
        }), 'Image');
        default_1$7 = Image.default = _default$7;
        function Theming({
          t
        }) {
          const dispatch = useDispatch();
          const theme = useSelector(state => {
            return state.designState.Survey.theme;
          });
          function handleChange(key, val) {
            dispatch(changeAttribute({
              code: "Survey",
              key: "theme",
              value: {
                ...theme,
                [key]: val
              }
            }));
          }
          function handleImageChange(e) {
            e.preventDefault();
            let file = e.target.files[0];
            DesignService.uploadResource(file).then(response => {
              dispatch(changeResources({
                code: "Survey",
                key: "headerImage",
                value: file.name
              }));
            }).catch(err => {
              console.error(err);
            });
          }
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            className: styles$e.theming,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("h5", {
              children: t("text_style")
            }), /* @__PURE__ */jsxRuntimeExports.jsx("h6", {
              children: t("group_title")
            }), /* @__PURE__ */jsxRuntimeExports.jsx(ThemingItem, {
              value: theme.textStyles.group,
              default: defaultSurveyTheme.textStyles.group,
              onChange: val => {
                handleChange("textStyles", {
                  ...theme.textStyles,
                  ["group"]: val
                });
              }
            }, "group"), /* @__PURE__ */jsxRuntimeExports.jsx("hr", {}), /* @__PURE__ */jsxRuntimeExports.jsx("h6", {
              children: t("question_title")
            }), /* @__PURE__ */jsxRuntimeExports.jsx(ThemingItem, {
              value: theme.textStyles.question,
              default: defaultSurveyTheme.textStyles.question,
              onChange: val => handleChange("textStyles", {
                ...theme.textStyles,
                ["question"]: val
              })
            }, "question"), /* @__PURE__ */jsxRuntimeExports.jsx("hr", {}), /* @__PURE__ */jsxRuntimeExports.jsx("h6", {
              children: t("theme_text")
            }), /* @__PURE__ */jsxRuntimeExports.jsx(ThemingItem, {
              value: theme.textStyles.text,
              default: defaultSurveyTheme.textStyles.text,
              onChange: val => handleChange("textStyles", {
                ...theme.textStyles,
                ["text"]: val
              })
            }, "text"), /* @__PURE__ */jsxRuntimeExports.jsx("hr", {}), /* @__PURE__ */jsxRuntimeExports.jsx("h5", {
              children: t("highlight_color")
            }), /* @__PURE__ */jsxRuntimeExports.jsx(ColorPicker, {
              color: theme.primaryColor,
              default: defaultSurveyTheme.primaryColor,
              handleChange: value => handleChange("primaryColor", value)
            }), /* @__PURE__ */jsxRuntimeExports.jsx("hr", {}), /* @__PURE__ */jsxRuntimeExports.jsx("h5", {
              children: t("background_color")
            }), /* @__PURE__ */jsxRuntimeExports.jsx(ColorPicker, {
              color: theme.bgColor,
              default: defaultSurveyTheme.bgColor,
              handleChange: value => handleChange("bgColor", value)
            }), /* @__PURE__ */jsxRuntimeExports.jsx("hr", {}), /* @__PURE__ */jsxRuntimeExports.jsx("h5", {
              children: t("foreground_color")
            }), /* @__PURE__ */jsxRuntimeExports.jsx(ColorPicker, {
              color: theme.paperColor,
              default: defaultSurveyTheme.paperColor,
              handleChange: value => handleChange("paperColor", value)
            }), /* @__PURE__ */jsxRuntimeExports.jsx("hr", {}), /* @__PURE__ */jsxRuntimeExports.jsx("h5", {
              children: t("theme_header")
            }), /* @__PURE__ */jsxRuntimeExports.jsxs(Button, {
              variant: "outlined",
              component: "label",
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(default_1$7, {
                className: "mr-10"
              }), t("choose_image"), /* @__PURE__ */jsxRuntimeExports.jsx("input", {
                hidden: true,
                accept: "image/*",
                multiple: true,
                type: "file",
                onChange: handleImageChange
              })]
            })]
          });
        }
        function ownKeys$w(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread2(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$w(Object(source), !0).forEach(function (key) {
              _defineProperty(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$w(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function _extends() {
          _extends = Object.assign || function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          return _extends.apply(this, arguments);
        }
        function _slicedToArray(arr, i) {
          return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$6(arr, i) || _nonIterableRest();
        }
        function _arrayWithHoles(arr) {
          if (Array.isArray(arr)) return arr;
        }
        function _iterableToArrayLimit(arr, i) {
          var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
          if (_i == null) return;
          var _arr = [];
          var _n = true;
          var _d = false;
          var _s, _e;
          try {
            for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"] != null) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }
          return _arr;
        }
        function _unsupportedIterableToArray$6(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray$6(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen);
        }
        function _arrayLikeToArray$6(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }
        function _nonIterableRest() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var ConfirmContext = /*#__PURE__*/reactExports.createContext();
        var ConfirmationDialog = function ConfirmationDialog(_ref) {
          var open = _ref.open,
            options = _ref.options,
            onCancel = _ref.onCancel,
            onConfirm = _ref.onConfirm,
            onClose = _ref.onClose;
          var title = options.title,
            description = options.description,
            content = options.content,
            confirmationText = options.confirmationText,
            cancellationText = options.cancellationText,
            dialogProps = options.dialogProps,
            dialogActionsProps = options.dialogActionsProps,
            confirmationButtonProps = options.confirmationButtonProps,
            cancellationButtonProps = options.cancellationButtonProps,
            titleProps = options.titleProps,
            contentProps = options.contentProps,
            allowClose = options.allowClose,
            confirmationKeyword = options.confirmationKeyword,
            confirmationKeywordTextFieldProps = options.confirmationKeywordTextFieldProps,
            hideCancelButton = options.hideCancelButton,
            buttonOrder = options.buttonOrder;
          var _React$useState = React.useState(""),
            _React$useState2 = _slicedToArray(_React$useState, 2),
            confirmationKeywordValue = _React$useState2[0],
            setConfirmationKeywordValue = _React$useState2[1];
          var confirmationButtonDisabled = confirmationKeyword && confirmationKeywordValue !== confirmationKeyword;
          var confirmationContent = /*#__PURE__*/React.createElement(React.Fragment, null, confirmationKeyword && /*#__PURE__*/React.createElement(TextField, _extends({
            onChange: function onChange(e) {
              return setConfirmationKeywordValue(e.target.value);
            },
            value: confirmationKeywordValue,
            fullWidth: true
          }, confirmationKeywordTextFieldProps)));
          var dialogActions = buttonOrder.map(function (buttonType) {
            if (buttonType === "cancel") {
              return !hideCancelButton && /*#__PURE__*/React.createElement(Button, _extends({
                key: "cancel"
              }, cancellationButtonProps, {
                onClick: onCancel
              }), cancellationText);
            }
            if (buttonType === "confirm") {
              return /*#__PURE__*/React.createElement(Button, _extends({
                key: "confirm",
                color: "primary",
                disabled: confirmationButtonDisabled
              }, confirmationButtonProps, {
                onClick: onConfirm
              }), confirmationText);
            }
            throw new Error("Supported button types are only \"confirm\" and \"cancel\", got: ".concat(buttonType));
          });
          return /*#__PURE__*/React.createElement(Dialog, _extends({
            fullWidth: true
          }, dialogProps, {
            open: open,
            onClose: allowClose ? onClose : null
          }), title && /*#__PURE__*/React.createElement(DialogTitle, titleProps, title), content ? /*#__PURE__*/React.createElement(DialogContent, contentProps, content, confirmationContent) : description ? /*#__PURE__*/React.createElement(DialogContent, contentProps, /*#__PURE__*/React.createElement(DialogContentText$1, null, description), confirmationContent) : confirmationKeyword && /*#__PURE__*/React.createElement(DialogContent, contentProps, confirmationContent), /*#__PURE__*/React.createElement(DialogActions, dialogActionsProps, dialogActions));
        };
        var DEFAULT_OPTIONS = {
          title: "Are you sure?",
          description: "",
          content: null,
          confirmationText: "Ok",
          cancellationText: "Cancel",
          dialogProps: {},
          dialogActionsProps: {},
          confirmationButtonProps: {},
          cancellationButtonProps: {},
          titleProps: {},
          contentProps: {},
          allowClose: true,
          confirmationKeywordTextFieldProps: {},
          hideCancelButton: false,
          buttonOrder: ["cancel", "confirm"]
        };
        var buildOptions = function buildOptions(defaultOptions, options) {
          var dialogProps = _objectSpread2(_objectSpread2({}, defaultOptions.dialogProps || DEFAULT_OPTIONS.dialogProps), options.dialogProps || {});
          var dialogActionsProps = _objectSpread2(_objectSpread2({}, defaultOptions.dialogActionsProps || DEFAULT_OPTIONS.dialogActionsProps), options.dialogActionsProps || {});
          var confirmationButtonProps = _objectSpread2(_objectSpread2({}, defaultOptions.confirmationButtonProps || DEFAULT_OPTIONS.confirmationButtonProps), options.confirmationButtonProps || {});
          var cancellationButtonProps = _objectSpread2(_objectSpread2({}, defaultOptions.cancellationButtonProps || DEFAULT_OPTIONS.cancellationButtonProps), options.cancellationButtonProps || {});
          var titleProps = _objectSpread2(_objectSpread2({}, defaultOptions.titleProps || DEFAULT_OPTIONS.titleProps), options.titleProps || {});
          var contentProps = _objectSpread2(_objectSpread2({}, defaultOptions.contentProps || DEFAULT_OPTIONS.contentProps), options.contentProps || {});
          var confirmationKeywordTextFieldProps = _objectSpread2(_objectSpread2({}, defaultOptions.confirmationKeywordTextFieldProps || DEFAULT_OPTIONS.confirmationKeywordTextFieldProps), options.confirmationKeywordTextFieldProps || {});
          return _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, DEFAULT_OPTIONS), defaultOptions), options), {}, {
            dialogProps: dialogProps,
            dialogActionsProps: dialogActionsProps,
            confirmationButtonProps: confirmationButtonProps,
            cancellationButtonProps: cancellationButtonProps,
            titleProps: titleProps,
            contentProps: contentProps,
            confirmationKeywordTextFieldProps: confirmationKeywordTextFieldProps
          });
        };
        var ConfirmProvider = function ConfirmProvider(_ref) {
          var children = _ref.children,
            _ref$defaultOptions = _ref.defaultOptions,
            defaultOptions = _ref$defaultOptions === void 0 ? {} : _ref$defaultOptions;
          var _useState = reactExports.useState({}),
            _useState2 = _slicedToArray(_useState, 2),
            options = _useState2[0],
            setOptions = _useState2[1];
          var _useState3 = reactExports.useState([]),
            _useState4 = _slicedToArray(_useState3, 2),
            resolveReject = _useState4[0],
            setResolveReject = _useState4[1];
          var _resolveReject = _slicedToArray(resolveReject, 2),
            resolve = _resolveReject[0],
            reject = _resolveReject[1];
          var confirm = reactExports.useCallback(function () {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            return new Promise(function (resolve, reject) {
              setOptions(options);
              setResolveReject([resolve, reject]);
            });
          }, []);
          var handleClose = reactExports.useCallback(function () {
            setResolveReject([]);
          }, []);
          var handleCancel = reactExports.useCallback(function () {
            if (reject) {
              reject();
              handleClose();
            }
          }, [reject, handleClose]);
          var handleConfirm = reactExports.useCallback(function () {
            if (resolve) {
              resolve();
              handleClose();
            }
          }, [resolve, handleClose]);
          return /*#__PURE__*/React.createElement(reactExports.Fragment, null, /*#__PURE__*/React.createElement(ConfirmContext.Provider, {
            value: confirm
          }, children), /*#__PURE__*/React.createElement(ConfirmationDialog, {
            open: resolveReject.length === 2,
            options: buildOptions(defaultOptions, options),
            onClose: handleClose,
            onCancel: handleCancel,
            onConfirm: handleConfirm
          }));
        };
        var useConfirm = function useConfirm() {
          var confirm = reactExports.useContext(ConfirmContext);
          return confirm;
        };

        //! moment.js
        //! version : 2.29.4
        //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
        //! license : MIT
        //! momentjs.com

        var hookCallback;
        function hooks() {
          return hookCallback.apply(null, arguments);
        }

        // This is done to register the method called with moment()
        // without creating circular dependencies.
        function setHookCallback(callback) {
          hookCallback = callback;
        }
        function isArray$2(input) {
          return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
        }
        function isObject$9(input) {
          // IE8 will treat undefined and null as object if it wasn't for
          // input != null
          return input != null && Object.prototype.toString.call(input) === '[object Object]';
        }
        function hasOwnProp(a, b) {
          return Object.prototype.hasOwnProperty.call(a, b);
        }
        function isObjectEmpty(obj) {
          if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
          } else {
            var k;
            for (k in obj) {
              if (hasOwnProp(obj, k)) {
                return false;
              }
            }
            return true;
          }
        }
        function isUndefined(input) {
          return input === void 0;
        }
        function isNumber(input) {
          return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
        }
        function isDate(input) {
          return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
        }
        function map(arr, fn) {
          var res = [],
            i,
            arrLen = arr.length;
          for (i = 0; i < arrLen; ++i) {
            res.push(fn(arr[i], i));
          }
          return res;
        }
        function extend(a, b) {
          for (var i in b) {
            if (hasOwnProp(b, i)) {
              a[i] = b[i];
            }
          }
          if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
          }
          if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
          }
          return a;
        }
        function createUTC(input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, true).utc();
        }
        function defaultParsingFlags() {
          // We need to deep clone this object.
          return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false
          };
        }
        function getParsingFlags(m) {
          if (m._pf == null) {
            m._pf = defaultParsingFlags();
          }
          return m._pf;
        }
        var some;
        if (Array.prototype.some) {
          some = Array.prototype.some;
        } else {
          some = function (fun) {
            var t = Object(this),
              len = t.length >>> 0,
              i;
            for (i = 0; i < len; i++) {
              if (i in t && fun.call(this, t[i], i, t)) {
                return true;
              }
            }
            return false;
          };
        }
        function isValid(m) {
          if (m._isValid == null) {
            var flags = getParsingFlags(m),
              parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
              }),
              isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
            if (m._strict) {
              isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
            }
            if (Object.isFrozen == null || !Object.isFrozen(m)) {
              m._isValid = isNowValid;
            } else {
              return isNowValid;
            }
          }
          return m._isValid;
        }
        function createInvalid(flags) {
          var m = createUTC(NaN);
          if (flags != null) {
            extend(getParsingFlags(m), flags);
          } else {
            getParsingFlags(m).userInvalidated = true;
          }
          return m;
        }

        // Plugins that add properties should also add the key here (null value),
        // so we can properly clone ourselves.
        var momentProperties = hooks.momentProperties = [],
          updateInProgress = false;
        function copyConfig(to, from) {
          var i,
            prop,
            val,
            momentPropertiesLen = momentProperties.length;
          if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
          }
          if (!isUndefined(from._i)) {
            to._i = from._i;
          }
          if (!isUndefined(from._f)) {
            to._f = from._f;
          }
          if (!isUndefined(from._l)) {
            to._l = from._l;
          }
          if (!isUndefined(from._strict)) {
            to._strict = from._strict;
          }
          if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
          }
          if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
          }
          if (!isUndefined(from._offset)) {
            to._offset = from._offset;
          }
          if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
          }
          if (!isUndefined(from._locale)) {
            to._locale = from._locale;
          }
          if (momentPropertiesLen > 0) {
            for (i = 0; i < momentPropertiesLen; i++) {
              prop = momentProperties[i];
              val = from[prop];
              if (!isUndefined(val)) {
                to[prop] = val;
              }
            }
          }
          return to;
        }

        // Moment prototype object
        function Moment(config) {
          copyConfig(this, config);
          this._d = new Date(config._d != null ? config._d.getTime() : NaN);
          if (!this.isValid()) {
            this._d = new Date(NaN);
          }
          // Prevent infinite loop in case updateOffset creates new moment
          // objects.
          if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
          }
        }
        function isMoment(obj) {
          return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
        }
        function warn(msg) {
          if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
          }
        }
        function deprecate(msg, fn) {
          var firstTime = true;
          return extend(function () {
            if (hooks.deprecationHandler != null) {
              hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
              var args = [],
                arg,
                i,
                key,
                argLen = arguments.length;
              for (i = 0; i < argLen; i++) {
                arg = '';
                if (typeof arguments[i] === 'object') {
                  arg += '\n[' + i + '] ';
                  for (key in arguments[0]) {
                    if (hasOwnProp(arguments[0], key)) {
                      arg += key + ': ' + arguments[0][key] + ', ';
                    }
                  }
                  arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                  arg = arguments[i];
                }
                args.push(arg);
              }
              warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
              firstTime = false;
            }
            return fn.apply(this, arguments);
          }, fn);
        }
        var deprecations = {};
        function deprecateSimple(name, msg) {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
          }
          if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
          }
        }
        hooks.suppressDeprecationWarnings = false;
        hooks.deprecationHandler = null;
        function isFunction$1(input) {
          return typeof Function !== 'undefined' && input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
        }
        function set(config) {
          var prop, i;
          for (i in config) {
            if (hasOwnProp(config, i)) {
              prop = config[i];
              if (isFunction$1(prop)) {
                this[i] = prop;
              } else {
                this['_' + i] = prop;
              }
            }
          }
          this._config = config;
          // Lenient ordinal parsing accepts just a number in addition to
          // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
          // TODO: Remove "ordinalParse" fallback in next major release.
          this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
        }
        function mergeConfigs(parentConfig, childConfig) {
          var res = extend({}, parentConfig),
            prop;
          for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
              if (isObject$9(parentConfig[prop]) && isObject$9(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
              } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
              } else {
                delete res[prop];
              }
            }
          }
          for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject$9(parentConfig[prop])) {
              // make sure changes to properties don't modify parent config
              res[prop] = extend({}, res[prop]);
            }
          }
          return res;
        }
        function Locale(config) {
          if (config != null) {
            this.set(config);
          }
        }
        var keys;
        if (Object.keys) {
          keys = Object.keys;
        } else {
          keys = function (obj) {
            var i,
              res = [];
            for (i in obj) {
              if (hasOwnProp(obj, i)) {
                res.push(i);
              }
            }
            return res;
          };
        }
        var defaultCalendar = {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L'
        };
        function calendar(key, mom, now) {
          var output = this._calendar[key] || this._calendar['sameElse'];
          return isFunction$1(output) ? output.call(mom, now) : output;
        }
        function zeroFill(number, targetLength, forceSign) {
          var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
          return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
        }
        var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
          localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
          formatFunctions = {},
          formatTokenFunctions = {};

        // token:    'M'
        // padded:   ['MM', 2]
        // ordinal:  'Mo'
        // callback: function () { this.month() + 1 }
        function addFormatToken(token, padded, ordinal, callback) {
          var func = callback;
          if (typeof callback === 'string') {
            func = function () {
              return this[callback]();
            };
          }
          if (token) {
            formatTokenFunctions[token] = func;
          }
          if (padded) {
            formatTokenFunctions[padded[0]] = function () {
              return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
          }
          if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
              return this.localeData().ordinal(func.apply(this, arguments), token);
            };
          }
        }
        function removeFormattingTokens(input) {
          if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
          }
          return input.replace(/\\/g, '');
        }
        function makeFormatFunction(format) {
          var array = format.match(formattingTokens),
            i,
            length;
          for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
              array[i] = formatTokenFunctions[array[i]];
            } else {
              array[i] = removeFormattingTokens(array[i]);
            }
          }
          return function (mom) {
            var output = '',
              i;
            for (i = 0; i < length; i++) {
              output += isFunction$1(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
          };
        }

        // format date using native date object
        function formatMoment(m, format) {
          if (!m.isValid()) {
            return m.localeData().invalidDate();
          }
          format = expandFormat(format, m.localeData());
          formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
          return formatFunctions[format](m);
        }
        function expandFormat(format, locale) {
          var i = 5;
          function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
          }
          localFormattingTokens.lastIndex = 0;
          while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
          }
          return format;
        }
        var defaultLongDateFormat = {
          LTS: 'h:mm:ss A',
          LT: 'h:mm A',
          L: 'MM/DD/YYYY',
          LL: 'MMMM D, YYYY',
          LLL: 'MMMM D, YYYY h:mm A',
          LLLL: 'dddd, MMMM D, YYYY h:mm A'
        };
        function longDateFormat(key) {
          var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];
          if (format || !formatUpper) {
            return format;
          }
          this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function (tok) {
            if (tok === 'MMMM' || tok === 'MM' || tok === 'DD' || tok === 'dddd') {
              return tok.slice(1);
            }
            return tok;
          }).join('');
          return this._longDateFormat[key];
        }
        var defaultInvalidDate = 'Invalid date';
        function invalidDate() {
          return this._invalidDate;
        }
        var defaultOrdinal = '%d',
          defaultDayOfMonthOrdinalParse = /\d{1,2}/;
        function ordinal(number) {
          return this._ordinal.replace('%d', number);
        }
        var defaultRelativeTime = {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          ss: '%d seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          w: 'a week',
          ww: '%d weeks',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years'
        };
        function relativeTime(number, withoutSuffix, string, isFuture) {
          var output = this._relativeTime[string];
          return isFunction$1(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
        }
        function pastFuture(diff, output) {
          var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
          return isFunction$1(format) ? format(output) : format.replace(/%s/i, output);
        }
        var aliases = {};
        function addUnitAlias(unit, shorthand) {
          var lowerCase = unit.toLowerCase();
          aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
        }
        function normalizeUnits(units) {
          return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
        }
        function normalizeObjectUnits(inputObject) {
          var normalizedInput = {},
            normalizedProp,
            prop;
          for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
              normalizedProp = normalizeUnits(prop);
              if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
              }
            }
          }
          return normalizedInput;
        }
        var priorities = {};
        function addUnitPriority(unit, priority) {
          priorities[unit] = priority;
        }
        function getPrioritizedUnits(unitsObj) {
          var units = [],
            u;
          for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
              units.push({
                unit: u,
                priority: priorities[u]
              });
            }
          }
          units.sort(function (a, b) {
            return a.priority - b.priority;
          });
          return units;
        }
        function isLeapYear(year) {
          return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        }
        function absFloor(number) {
          if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
          } else {
            return Math.floor(number);
          }
        }
        function toInt(argumentForCoercion) {
          var coercedNumber = +argumentForCoercion,
            value = 0;
          if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
          }
          return value;
        }
        function makeGetSet(unit, keepTime) {
          return function (value) {
            if (value != null) {
              set$1(this, unit, value);
              hooks.updateOffset(this, keepTime);
              return this;
            } else {
              return get(this, unit);
            }
          };
        }
        function get(mom, unit) {
          return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
        }
        function set$1(mom, unit, value) {
          if (mom.isValid() && !isNaN(value)) {
            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
              value = toInt(value);
              mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
            } else {
              mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
          }
        }

        // MOMENTS

        function stringGet(units) {
          units = normalizeUnits(units);
          if (isFunction$1(this[units])) {
            return this[units]();
          }
          return this;
        }
        function stringSet(units, value) {
          if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units),
              i,
              prioritizedLen = prioritized.length;
            for (i = 0; i < prioritizedLen; i++) {
              this[prioritized[i].unit](units[prioritized[i].unit]);
            }
          } else {
            units = normalizeUnits(units);
            if (isFunction$1(this[units])) {
              return this[units](value);
            }
          }
          return this;
        }
        var match1 = /\d/,
          //       0 - 9
          match2 = /\d\d/,
          //      00 - 99
          match3 = /\d{3}/,
          //     000 - 999
          match4 = /\d{4}/,
          //    0000 - 9999
          match6 = /[+-]?\d{6}/,
          // -999999 - 999999
          match1to2 = /\d\d?/,
          //       0 - 99
          match3to4 = /\d\d\d\d?/,
          //     999 - 9999
          match5to6 = /\d\d\d\d\d\d?/,
          //   99999 - 999999
          match1to3 = /\d{1,3}/,
          //       0 - 999
          match1to4 = /\d{1,4}/,
          //       0 - 9999
          match1to6 = /[+-]?\d{1,6}/,
          // -999999 - 999999
          matchUnsigned = /\d+/,
          //       0 - inf
          matchSigned = /[+-]?\d+/,
          //    -inf - inf
          matchOffset = /Z|[+-]\d\d:?\d\d/gi,
          // +00:00 -00:00 +0000 -0000 or Z
          matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi,
          // +00 -00 +00:00 -00:00 +0000 -0000 or Z
          matchTimestamp = /[+-]?\d+(\.\d{1,3})?/,
          // 123456789 123456789.123
          // any word (or two) characters or numbers including two/three word month in arabic.
          // includes scottish gaelic two word and hyphenated months
          matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
          regexes;
        regexes = {};
        function addRegexToken(token, regex, strictRegex) {
          regexes[token] = isFunction$1(regex) ? regex : function (isStrict, localeData) {
            return isStrict && strictRegex ? strictRegex : regex;
          };
        }
        function getParseRegexForToken(token, config) {
          if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
          }
          return regexes[token](config._strict, config._locale);
        }

        // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
        function unescapeFormat(s) {
          return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
          }));
        }
        function regexEscape(s) {
          return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
        }
        var tokens = {};
        function addParseToken(token, callback) {
          var i,
            func = callback,
            tokenLen;
          if (typeof token === 'string') {
            token = [token];
          }
          if (isNumber(callback)) {
            func = function (input, array) {
              array[callback] = toInt(input);
            };
          }
          tokenLen = token.length;
          for (i = 0; i < tokenLen; i++) {
            tokens[token[i]] = func;
          }
        }
        function addWeekParseToken(token, callback) {
          addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
          });
        }
        function addTimeToArrayFromToken(token, input, config) {
          if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
          }
        }
        var YEAR = 0,
          MONTH = 1,
          DATE = 2,
          HOUR = 3,
          MINUTE = 4,
          SECOND = 5,
          MILLISECOND = 6,
          WEEK = 7,
          WEEKDAY = 8;
        function mod(n, x) {
          return (n % x + x) % x;
        }
        var indexOf;
        if (Array.prototype.indexOf) {
          indexOf = Array.prototype.indexOf;
        } else {
          indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
              if (this[i] === o) {
                return i;
              }
            }
            return -1;
          };
        }
        function daysInMonth(year, month) {
          if (isNaN(year) || isNaN(month)) {
            return NaN;
          }
          var modMonth = mod(month, 12);
          year += (month - modMonth) / 12;
          return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
        }

        // FORMATTING

        addFormatToken('M', ['MM', 2], 'Mo', function () {
          return this.month() + 1;
        });
        addFormatToken('MMM', 0, 0, function (format) {
          return this.localeData().monthsShort(this, format);
        });
        addFormatToken('MMMM', 0, 0, function (format) {
          return this.localeData().months(this, format);
        });

        // ALIASES

        addUnitAlias('month', 'M');

        // PRIORITY

        addUnitPriority('month', 8);

        // PARSING

        addRegexToken('M', match1to2);
        addRegexToken('MM', match1to2, match2);
        addRegexToken('MMM', function (isStrict, locale) {
          return locale.monthsShortRegex(isStrict);
        });
        addRegexToken('MMMM', function (isStrict, locale) {
          return locale.monthsRegex(isStrict);
        });
        addParseToken(['M', 'MM'], function (input, array) {
          array[MONTH] = toInt(input) - 1;
        });
        addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
          var month = config._locale.monthsParse(input, token, config._strict);
          // if we didn't find a month name, mark the date as invalid.
          if (month != null) {
            array[MONTH] = month;
          } else {
            getParsingFlags(config).invalidMonth = input;
          }
        });

        // LOCALES

        var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
          defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
          MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
          defaultMonthsShortRegex = matchWord,
          defaultMonthsRegex = matchWord;
        function localeMonths(m, format) {
          if (!m) {
            return isArray$2(this._months) ? this._months : this._months['standalone'];
          }
          return isArray$2(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
        }
        function localeMonthsShort(m, format) {
          if (!m) {
            return isArray$2(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
          }
          return isArray$2(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
        }
        function handleStrictParse(monthName, format, strict) {
          var i,
            ii,
            mom,
            llc = monthName.toLocaleLowerCase();
          if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
              mom = createUTC([2000, i]);
              this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
              this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format === 'MMM') {
              ii = indexOf.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format === 'MMM') {
              ii = indexOf.call(this._shortMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._longMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeMonthsParse(monthName, format, strict) {
          var i, mom, regex;
          if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
          }
          if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
          }

          // TODO: add sorting
          // Sorting makes sure if one month (or abbr) is a prefix of another
          // see sorting in computeMonthsParse
          for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
              this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
              this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
              regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
              this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
              return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
              return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
              return i;
            }
          }
        }

        // MOMENTS

        function setMonth(mom, value) {
          var dayOfMonth;
          if (!mom.isValid()) {
            // No op
            return mom;
          }
          if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
              value = toInt(value);
            } else {
              value = mom.localeData().monthsParse(value);
              // TODO: Another silent failure?
              if (!isNumber(value)) {
                return mom;
              }
            }
          }
          dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
          return mom;
        }
        function getSetMonth(value) {
          if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
          } else {
            return get(this, 'Month');
          }
        }
        function getDaysInMonth() {
          return daysInMonth(this.year(), this.month());
        }
        function monthsShortRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsShortStrictRegex;
            } else {
              return this._monthsShortRegex;
            }
          } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
              this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
          }
        }
        function monthsRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsStrictRegex;
            } else {
              return this._monthsRegex;
            }
          } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
              this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
          }
        }
        function computeMonthsParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }
          var shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom;
          for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
          }
          // Sorting makes sure if one month (or abbr) is a prefix of another it
          // will match the longer piece.
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
          }
          for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
          }
          this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._monthsShortRegex = this._monthsRegex;
          this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
          this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        }

        // FORMATTING

        addFormatToken('Y', 0, 0, function () {
          var y = this.year();
          return y <= 9999 ? zeroFill(y, 4) : '+' + y;
        });
        addFormatToken(0, ['YY', 2], 0, function () {
          return this.year() % 100;
        });
        addFormatToken(0, ['YYYY', 4], 0, 'year');
        addFormatToken(0, ['YYYYY', 5], 0, 'year');
        addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

        // ALIASES

        addUnitAlias('year', 'y');

        // PRIORITIES

        addUnitPriority('year', 1);

        // PARSING

        addRegexToken('Y', matchSigned);
        addRegexToken('YY', match1to2, match2);
        addRegexToken('YYYY', match1to4, match4);
        addRegexToken('YYYYY', match1to6, match6);
        addRegexToken('YYYYYY', match1to6, match6);
        addParseToken(['YYYYY', 'YYYYYY'], YEAR);
        addParseToken('YYYY', function (input, array) {
          array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
        });
        addParseToken('YY', function (input, array) {
          array[YEAR] = hooks.parseTwoDigitYear(input);
        });
        addParseToken('Y', function (input, array) {
          array[YEAR] = parseInt(input, 10);
        });

        // HELPERS

        function daysInYear(year) {
          return isLeapYear(year) ? 366 : 365;
        }

        // HOOKS

        hooks.parseTwoDigitYear = function (input) {
          return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
        };

        // MOMENTS

        var getSetYear = makeGetSet('FullYear', true);
        function getIsLeapYear() {
          return isLeapYear(this.year());
        }
        function createDate(y, m, d, h, M, s, ms) {
          // can't just apply() to create a date:
          // https://stackoverflow.com/q/181348
          var date;
          // the date constructor remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
              date.setFullYear(y);
            }
          } else {
            date = new Date(y, m, d, h, M, s, ms);
          }
          return date;
        }
        function createUTCDate(y) {
          var date, args;
          // the Date.UTC function remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
              date.setUTCFullYear(y);
            }
          } else {
            date = new Date(Date.UTC.apply(null, arguments));
          }
          return date;
        }

        // start-of-first-week - start-of-year
        function firstWeekOffset(year, dow, doy) {
          var
            // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
          return -fwdlw + fwd - 1;
        }

        // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
        function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
          var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear,
            resDayOfYear;
          if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
          } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
          } else {
            resYear = year;
            resDayOfYear = dayOfYear;
          }
          return {
            year: resYear,
            dayOfYear: resDayOfYear
          };
        }
        function weekOfYear(mom, dow, doy) {
          var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek,
            resYear;
          if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
          } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
          } else {
            resYear = mom.year();
            resWeek = week;
          }
          return {
            week: resWeek,
            year: resYear
          };
        }
        function weeksInYear(year, dow, doy) {
          var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
          return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
        }

        // FORMATTING

        addFormatToken('w', ['ww', 2], 'wo', 'week');
        addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

        // ALIASES

        addUnitAlias('week', 'w');
        addUnitAlias('isoWeek', 'W');

        // PRIORITIES

        addUnitPriority('week', 5);
        addUnitPriority('isoWeek', 5);

        // PARSING

        addRegexToken('w', match1to2);
        addRegexToken('ww', match1to2, match2);
        addRegexToken('W', match1to2);
        addRegexToken('WW', match1to2, match2);
        addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
          week[token.substr(0, 1)] = toInt(input);
        });

        // HELPERS

        // LOCALES

        function localeWeek(mom) {
          return weekOfYear(mom, this._week.dow, this._week.doy).week;
        }
        var defaultLocaleWeek = {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6 // The week that contains Jan 6th is the first week of the year.
        };

        function localeFirstDayOfWeek() {
          return this._week.dow;
        }
        function localeFirstDayOfYear() {
          return this._week.doy;
        }

        // MOMENTS

        function getSetWeek(input) {
          var week = this.localeData().week(this);
          return input == null ? week : this.add((input - week) * 7, 'd');
        }
        function getSetISOWeek(input) {
          var week = weekOfYear(this, 1, 4).week;
          return input == null ? week : this.add((input - week) * 7, 'd');
        }

        // FORMATTING

        addFormatToken('d', 0, 'do', 'day');
        addFormatToken('dd', 0, 0, function (format) {
          return this.localeData().weekdaysMin(this, format);
        });
        addFormatToken('ddd', 0, 0, function (format) {
          return this.localeData().weekdaysShort(this, format);
        });
        addFormatToken('dddd', 0, 0, function (format) {
          return this.localeData().weekdays(this, format);
        });
        addFormatToken('e', 0, 0, 'weekday');
        addFormatToken('E', 0, 0, 'isoWeekday');

        // ALIASES

        addUnitAlias('day', 'd');
        addUnitAlias('weekday', 'e');
        addUnitAlias('isoWeekday', 'E');

        // PRIORITY
        addUnitPriority('day', 11);
        addUnitPriority('weekday', 11);
        addUnitPriority('isoWeekday', 11);

        // PARSING

        addRegexToken('d', match1to2);
        addRegexToken('e', match1to2);
        addRegexToken('E', match1to2);
        addRegexToken('dd', function (isStrict, locale) {
          return locale.weekdaysMinRegex(isStrict);
        });
        addRegexToken('ddd', function (isStrict, locale) {
          return locale.weekdaysShortRegex(isStrict);
        });
        addRegexToken('dddd', function (isStrict, locale) {
          return locale.weekdaysRegex(isStrict);
        });
        addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
          var weekday = config._locale.weekdaysParse(input, token, config._strict);
          // if we didn't get a weekday name, mark the date as invalid
          if (weekday != null) {
            week.d = weekday;
          } else {
            getParsingFlags(config).invalidWeekday = input;
          }
        });
        addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
          week[token] = toInt(input);
        });

        // HELPERS

        function parseWeekday(input, locale) {
          if (typeof input !== 'string') {
            return input;
          }
          if (!isNaN(input)) {
            return parseInt(input, 10);
          }
          input = locale.weekdaysParse(input);
          if (typeof input === 'number') {
            return input;
          }
          return null;
        }
        function parseIsoWeekday(input, locale) {
          if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
          }
          return isNaN(input) ? null : input;
        }

        // LOCALES
        function shiftWeekdays(ws, n) {
          return ws.slice(n, 7).concat(ws.slice(0, n));
        }
        var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
          defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
          defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
          defaultWeekdaysRegex = matchWord,
          defaultWeekdaysShortRegex = matchWord,
          defaultWeekdaysMinRegex = matchWord;
        function localeWeekdays(m, format) {
          var weekdays = isArray$2(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];
          return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
        }
        function localeWeekdaysShort(m) {
          return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
        }
        function localeWeekdaysMin(m) {
          return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
        }
        function handleStrictParse$1(weekdayName, format, strict) {
          var i,
            ii,
            mom,
            llc = weekdayName.toLocaleLowerCase();
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];
            for (i = 0; i < 7; ++i) {
              mom = createUTC([2000, 1]).day(i);
              this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
              this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
              this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format === 'dddd') {
              ii = indexOf.call(this._weekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format === 'dddd') {
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._minWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeWeekdaysParse(weekdayName, format, strict) {
          var i, mom, regex;
          if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
          }
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
          }
          for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
              this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
              this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
              this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
              regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
              this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
              return i;
            }
          }
        }

        // MOMENTS

        function getSetDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
          if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
          } else {
            return day;
          }
        }
        function getSetLocaleDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
          return input == null ? weekday : this.add(input - weekday, 'd');
        }
        function getSetISODayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }

          // behaves the same as moment#day except
          // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
          // as a setter, sunday should belong to the previous week.

          if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
          } else {
            return this.day() || 7;
          }
        }
        function weekdaysRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysStrictRegex;
            } else {
              return this._weekdaysRegex;
            }
          } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
              this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
          }
        }
        function weekdaysShortRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysShortStrictRegex;
            } else {
              return this._weekdaysShortRegex;
            }
          } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
              this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
          }
        }
        function weekdaysMinRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysMinStrictRegex;
            } else {
              return this._weekdaysMinRegex;
            }
          } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
              this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
          }
        }
        function computeWeekdaysParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }
          var minPieces = [],
            shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom,
            minp,
            shortp,
            longp;
          for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = regexEscape(this.weekdaysMin(mom, ''));
            shortp = regexEscape(this.weekdaysShort(mom, ''));
            longp = regexEscape(this.weekdays(mom, ''));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
          }
          // Sorting makes sure if one weekday (or abbr) is a prefix of another it
          // will match the longer piece.
          minPieces.sort(cmpLenRev);
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._weekdaysShortRegex = this._weekdaysRegex;
          this._weekdaysMinRegex = this._weekdaysRegex;
          this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
          this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
          this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
        }

        // FORMATTING

        function hFormat() {
          return this.hours() % 12 || 12;
        }
        function kFormat() {
          return this.hours() || 24;
        }
        addFormatToken('H', ['HH', 2], 0, 'hour');
        addFormatToken('h', ['hh', 2], 0, hFormat);
        addFormatToken('k', ['kk', 2], 0, kFormat);
        addFormatToken('hmm', 0, 0, function () {
          return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
        });
        addFormatToken('hmmss', 0, 0, function () {
          return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        addFormatToken('Hmm', 0, 0, function () {
          return '' + this.hours() + zeroFill(this.minutes(), 2);
        });
        addFormatToken('Hmmss', 0, 0, function () {
          return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        function meridiem(token, lowercase) {
          addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
          });
        }
        meridiem('a', true);
        meridiem('A', false);

        // ALIASES

        addUnitAlias('hour', 'h');

        // PRIORITY
        addUnitPriority('hour', 13);

        // PARSING

        function matchMeridiem(isStrict, locale) {
          return locale._meridiemParse;
        }
        addRegexToken('a', matchMeridiem);
        addRegexToken('A', matchMeridiem);
        addRegexToken('H', match1to2);
        addRegexToken('h', match1to2);
        addRegexToken('k', match1to2);
        addRegexToken('HH', match1to2, match2);
        addRegexToken('hh', match1to2, match2);
        addRegexToken('kk', match1to2, match2);
        addRegexToken('hmm', match3to4);
        addRegexToken('hmmss', match5to6);
        addRegexToken('Hmm', match3to4);
        addRegexToken('Hmmss', match5to6);
        addParseToken(['H', 'HH'], HOUR);
        addParseToken(['k', 'kk'], function (input, array, config) {
          var kInput = toInt(input);
          array[HOUR] = kInput === 24 ? 0 : kInput;
        });
        addParseToken(['a', 'A'], function (input, array, config) {
          config._isPm = config._locale.isPM(input);
          config._meridiem = input;
        });
        addParseToken(['h', 'hh'], function (input, array, config) {
          array[HOUR] = toInt(input);
          getParsingFlags(config).bigHour = true;
        });
        addParseToken('hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken('hmmss', function (input, array, config) {
          var pos1 = input.length - 4,
            pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken('Hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
        });
        addParseToken('Hmmss', function (input, array, config) {
          var pos1 = input.length - 4,
            pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
        });

        // LOCALES

        function localeIsPM(input) {
          // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
          // Using charAt should be more compatible.
          return (input + '').toLowerCase().charAt(0) === 'p';
        }
        var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
          // Setting the hour should keep the time, because the user explicitly
          // specified which hour they want. So trying to maintain the same hour (in
          // a new timezone) makes sense. Adding/subtracting hours does not follow
          // this rule.
          getSetHour = makeGetSet('Hours', true);
        function localeMeridiem(hours, minutes, isLower) {
          if (hours > 11) {
            return isLower ? 'pm' : 'PM';
          } else {
            return isLower ? 'am' : 'AM';
          }
        }
        var baseConfig = {
          calendar: defaultCalendar,
          longDateFormat: defaultLongDateFormat,
          invalidDate: defaultInvalidDate,
          ordinal: defaultOrdinal,
          dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
          relativeTime: defaultRelativeTime,
          months: defaultLocaleMonths,
          monthsShort: defaultLocaleMonthsShort,
          week: defaultLocaleWeek,
          weekdays: defaultLocaleWeekdays,
          weekdaysMin: defaultLocaleWeekdaysMin,
          weekdaysShort: defaultLocaleWeekdaysShort,
          meridiemParse: defaultLocaleMeridiemParse
        };

        // internal storage for locale config files
        var locales = {},
          localeFamilies = {},
          globalLocale;
        function commonPrefix(arr1, arr2) {
          var i,
            minl = Math.min(arr1.length, arr2.length);
          for (i = 0; i < minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
              return i;
            }
          }
          return minl;
        }
        function normalizeLocale(key) {
          return key ? key.toLowerCase().replace('_', '-') : key;
        }

        // pick the locale from the array
        // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        function chooseLocale(names) {
          var i = 0,
            j,
            next,
            locale,
            split;
          while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
              locale = loadLocale(split.slice(0, j).join('-'));
              if (locale) {
                return locale;
              }
              if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
              }
              j--;
            }
            i++;
          }
          return globalLocale;
        }
        function isLocaleNameSane(name) {
          // Prevent names that look like filesystem paths, i.e contain '/' or '\'
          return name.match('^[^/\\\\]*$') != null;
        }
        function loadLocale(name) {
          var oldLocale = null,
            aliasedRequire;
          // TODO: Find a better way to register and load all the locales in Node
          if (locales[name] === undefined && typeof module !== 'undefined' && module && module.exports && isLocaleNameSane(name)) {
            try {
              oldLocale = globalLocale._abbr;
              aliasedRequire = require;
              aliasedRequire('./locale/' + name);
              getSetGlobalLocale(oldLocale);
            } catch (e) {
              // mark as not found to avoid repeating expensive file require call causing high CPU
              // when trying to find en-US, en_US, en-us for every format call
              locales[name] = null; // null means not found
            }
          }

          return locales[name];
        }

        // This function will load locale and then set the global locale.  If
        // no arguments are passed in, it will simply return the current global
        // locale key.
        function getSetGlobalLocale(key, values) {
          var data;
          if (key) {
            if (isUndefined(values)) {
              data = getLocale(key);
            } else {
              data = defineLocale(key, values);
            }
            if (data) {
              // moment.duration._locale = moment._locale = data;
              globalLocale = data;
            } else {
              if (typeof console !== 'undefined' && console.warn) {
                //warn user if arguments are passed but the locale could not be set
                console.warn('Locale ' + key + ' not found. Did you forget to load it?');
              }
            }
          }
          return globalLocale._abbr;
        }
        function defineLocale(name, config) {
          if (config !== null) {
            var locale,
              parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
              deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
              parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
              if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
              } else {
                locale = loadLocale(config.parentLocale);
                if (locale != null) {
                  parentConfig = locale._config;
                } else {
                  if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                  }
                  localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                  });
                  return null;
                }
              }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));
            if (localeFamilies[name]) {
              localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
              });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);
            return locales[name];
          } else {
            // useful for testing
            delete locales[name];
            return null;
          }
        }
        function updateLocale(name, config) {
          if (config != null) {
            var locale,
              tmpLocale,
              parentConfig = baseConfig;
            if (locales[name] != null && locales[name].parentLocale != null) {
              // Update existing child locale in-place to avoid memory-leaks
              locales[name].set(mergeConfigs(locales[name]._config, config));
            } else {
              // MERGE
              tmpLocale = loadLocale(name);
              if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
              }
              config = mergeConfigs(parentConfig, config);
              if (tmpLocale == null) {
                // updateLocale is called for creating a new locale
                // Set abbr so it will have a name (getters return
                // undefined otherwise).
                config.abbr = name;
              }
              locale = new Locale(config);
              locale.parentLocale = locales[name];
              locales[name] = locale;
            }

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
          } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
              if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
                if (name === getSetGlobalLocale()) {
                  getSetGlobalLocale(name);
                }
              } else if (locales[name] != null) {
                delete locales[name];
              }
            }
          }
          return locales[name];
        }

        // returns locale data
        function getLocale(key) {
          var locale;
          if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
          }
          if (!key) {
            return globalLocale;
          }
          if (!isArray$2(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
              return locale;
            }
            key = [key];
          }
          return chooseLocale(key);
        }
        function listLocales() {
          return keys(locales);
        }
        function checkOverflow(m) {
          var overflow,
            a = m._a;
          if (a && getParsingFlags(m).overflow === -2) {
            overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
              overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
              overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
              overflow = WEEKDAY;
            }
            getParsingFlags(m).overflow = overflow;
          }
          return m;
        }

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
          basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
          tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
          isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/], ['YYYYMM', /\d{6}/, false], ['YYYY', /\d{4}/, false]],
          // iso time formats and regexes
          isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]],
          aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
          // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
          rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
          obsOffsets = {
            UT: 0,
            GMT: 0,
            EDT: -4 * 60,
            EST: -5 * 60,
            CDT: -5 * 60,
            CST: -6 * 60,
            MDT: -6 * 60,
            MST: -7 * 60,
            PDT: -7 * 60,
            PST: -8 * 60
          };

        // date from iso format
        function configFromISO(config) {
          var i,
            l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime,
            dateFormat,
            timeFormat,
            tzFormat,
            isoDatesLen = isoDates.length,
            isoTimesLen = isoTimes.length;
          if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDatesLen; i < l; i++) {
              if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
              }
            }
            if (dateFormat == null) {
              config._isValid = false;
              return;
            }
            if (match[3]) {
              for (i = 0, l = isoTimesLen; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                  // match[2] should be 'T' or space
                  timeFormat = (match[2] || ' ') + isoTimes[i][0];
                  break;
                }
              }
              if (timeFormat == null) {
                config._isValid = false;
                return;
              }
            }
            if (!allowTime && timeFormat != null) {
              config._isValid = false;
              return;
            }
            if (match[4]) {
              if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
              } else {
                config._isValid = false;
                return;
              }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
          } else {
            config._isValid = false;
          }
        }
        function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
          var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];
          if (secondStr) {
            result.push(parseInt(secondStr, 10));
          }
          return result;
        }
        function untruncateYear(yearStr) {
          var year = parseInt(yearStr, 10);
          if (year <= 49) {
            return 2000 + year;
          } else if (year <= 999) {
            return 1900 + year;
          }
          return year;
        }
        function preprocessRFC2822(s) {
          // Remove comments and folding whitespace and replace multiple-spaces with a single space
          return s.replace(/\([^()]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
        }
        function checkWeekday(weekdayStr, parsedInput, config) {
          if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
              weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
              getParsingFlags(config).weekdayMismatch = true;
              config._isValid = false;
              return false;
            }
          }
          return true;
        }
        function calculateOffset(obsOffset, militaryOffset, numOffset) {
          if (obsOffset) {
            return obsOffsets[obsOffset];
          } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
          } else {
            var hm = parseInt(numOffset, 10),
              m = hm % 100,
              h = (hm - m) / 100;
            return h * 60 + m;
          }
        }

        // date and time from ref 2822 format
        function configFromRFC2822(config) {
          var match = rfc2822.exec(preprocessRFC2822(config._i)),
            parsedArray;
          if (match) {
            parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
              return;
            }
            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);
            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
            getParsingFlags(config).rfc2822 = true;
          } else {
            config._isValid = false;
          }
        }

        // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
        function configFromString(config) {
          var matched = aspNetJsonRegex.exec(config._i);
          if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
          }
          configFromISO(config);
          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }
          configFromRFC2822(config);
          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }
          if (config._strict) {
            config._isValid = false;
          } else {
            // Final attempt, use Input Fallback
            hooks.createFromInputFallback(config);
          }
        }
        hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
          config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        });

        // Pick the first defined of two or three arguments.
        function defaults(a, b, c) {
          if (a != null) {
            return a;
          }
          if (b != null) {
            return b;
          }
          return c;
        }
        function currentDateArray(config) {
          // hooks is actually the exported moment object
          var nowValue = new Date(hooks.now());
          if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
          }
          return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
        }

        // convert an array to a date.
        // the array should mirror the parameters below
        // note: all values past the year are optional and will default to the lowest possible value.
        // [year, month, day , hour, minute, second, millisecond]
        function configFromArray(config) {
          var i,
            date,
            input = [],
            currentDate,
            expectedWeekday,
            yearToUse;
          if (config._d) {
            return;
          }
          currentDate = currentDateArray(config);

          //compute day of the year from weeks and weekdays
          if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
          }

          //if the day of the year is set, figure out what it is
          if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
              getParsingFlags(config)._overflowDayOfYear = true;
            }
            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
          }

          // Default to current date.
          // * if no year, month, day of month are given, default to today
          // * if day of month is given, default month and year
          // * if month is given, default only year
          // * if year is given, don't default anything
          for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
          }

          // Zero out whatever was not defaulted, including time
          for (; i < 7; i++) {
            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
          }

          // Check for 24:00:00.000
          if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
          }
          config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
          expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

          // Apply timezone offset from input. The actual utcOffset can be changed
          // with parseZone.
          if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          }
          if (config._nextDay) {
            config._a[HOUR] = 24;
          }

          // check for mismatching day of week
          if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
          }
        }
        function dayOfYearFromWeekInfo(config) {
          var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
          w = config._w;
          if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
              weekdayOverflow = true;
            }
          } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            curWeek = weekOfYear(createLocal(), dow, doy);
            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);
            if (w.d != null) {
              // weekday -- low day numbers are considered next week
              weekday = w.d;
              if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
              }
            } else if (w.e != null) {
              // local weekday -- counting starts from beginning of week
              weekday = w.e + dow;
              if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
              }
            } else {
              // default to beginning of week
              weekday = dow;
            }
          }
          if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
          } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
          } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
          }
        }

        // constant that refers to the ISO standard
        hooks.ISO_8601 = function () {};

        // constant that refers to the RFC 2822 form
        hooks.RFC_2822 = function () {};

        // date from string and format string
        function configFromStringAndFormat(config) {
          // TODO: Move this to another part of the creation flow to prevent circular deps
          if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
          }
          if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
          }
          config._a = [];
          getParsingFlags(config).empty = true;

          // This array is used to make a Date, either with `new Date` or `Date.UTC`
          var string = '' + config._i,
            i,
            parsedInput,
            tokens,
            token,
            skipped,
            stringLength = string.length,
            totalParsedInputLength = 0,
            era,
            tokenLen;
          tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
          tokenLen = tokens.length;
          for (i = 0; i < tokenLen; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
              skipped = string.substr(0, string.indexOf(parsedInput));
              if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
              }
              string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
              totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
              if (parsedInput) {
                getParsingFlags(config).empty = false;
              } else {
                getParsingFlags(config).unusedTokens.push(token);
              }
              addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
              getParsingFlags(config).unusedTokens.push(token);
            }
          }

          // add remaining unparsed input length to the string
          getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
          if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
          }

          // clear _12h flag if hour is <= 12
          if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
          }
          getParsingFlags(config).parsedDateParts = config._a.slice(0);
          getParsingFlags(config).meridiem = config._meridiem;
          // handle meridiem
          config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

          // handle era
          era = getParsingFlags(config).era;
          if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
          }
          configFromArray(config);
          checkOverflow(config);
        }
        function meridiemFixWrap(locale, hour, meridiem) {
          var isPm;
          if (meridiem == null) {
            // nothing to do
            return hour;
          }
          if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
          } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
              hour += 12;
            }
            if (!isPm && hour === 12) {
              hour = 0;
            }
            return hour;
          } else {
            // this is not supposed to happen
            return hour;
          }
        }

        // date from string and array of format strings
        function configFromStringAndArray(config) {
          var tempConfig,
            bestMoment,
            scoreToBeat,
            i,
            currentScore,
            validFormatFound,
            bestFormatIsValid = false,
            configfLen = config._f.length;
          if (configfLen === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
          }
          for (i = 0; i < configfLen; i++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
              tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);
            if (isValid(tempConfig)) {
              validFormatFound = true;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
            getParsingFlags(tempConfig).score = currentScore;
            if (!bestFormatIsValid) {
              if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
                if (validFormatFound) {
                  bestFormatIsValid = true;
                }
              }
            } else {
              if (currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
              }
            }
          }
          extend(config, bestMoment || tempConfig);
        }
        function configFromObject(config) {
          if (config._d) {
            return;
          }
          var i = normalizeObjectUnits(config._i),
            dayOrDate = i.day === undefined ? i.date : i.day;
          config._a = map([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
          });
          configFromArray(config);
        }
        function createFromConfig(config) {
          var res = new Moment(checkOverflow(prepareConfig(config)));
          if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
          }
          return res;
        }
        function prepareConfig(config) {
          var input = config._i,
            format = config._f;
          config._locale = config._locale || getLocale(config._l);
          if (input === null || format === undefined && input === '') {
            return createInvalid({
              nullInput: true
            });
          }
          if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
          }
          if (isMoment(input)) {
            return new Moment(checkOverflow(input));
          } else if (isDate(input)) {
            config._d = input;
          } else if (isArray$2(format)) {
            configFromStringAndArray(config);
          } else if (format) {
            configFromStringAndFormat(config);
          } else {
            configFromInput(config);
          }
          if (!isValid(config)) {
            config._d = null;
          }
          return config;
        }
        function configFromInput(config) {
          var input = config._i;
          if (isUndefined(input)) {
            config._d = new Date(hooks.now());
          } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
          } else if (typeof input === 'string') {
            configFromString(config);
          } else if (isArray$2(input)) {
            config._a = map(input.slice(0), function (obj) {
              return parseInt(obj, 10);
            });
            configFromArray(config);
          } else if (isObject$9(input)) {
            configFromObject(config);
          } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
          } else {
            hooks.createFromInputFallback(config);
          }
        }
        function createLocalOrUTC(input, format, locale, strict, isUTC) {
          var c = {};
          if (format === true || format === false) {
            strict = format;
            format = undefined;
          }
          if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
          }
          if (isObject$9(input) && isObjectEmpty(input) || isArray$2(input) && input.length === 0) {
            input = undefined;
          }
          // object construction must be done this way.
          // https://github.com/moment/moment/issues/1423
          c._isAMomentObject = true;
          c._useUTC = c._isUTC = isUTC;
          c._l = locale;
          c._i = input;
          c._f = format;
          c._strict = strict;
          return createFromConfig(c);
        }
        function createLocal(input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, false);
        }
        var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
              return other < this ? this : other;
            } else {
              return createInvalid();
            }
          }),
          prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
              return other > this ? this : other;
            } else {
              return createInvalid();
            }
          });

        // Pick a moment m from moments so that m[fn](other) is true for all
        // other. This relies on the function fn to be transitive.
        //
        // moments should either be an array of moment objects or an array, whose
        // first element is an array of moment objects.
        function pickBy$2(fn, moments) {
          var res, i;
          if (moments.length === 1 && isArray$2(moments[0])) {
            moments = moments[0];
          }
          if (!moments.length) {
            return createLocal();
          }
          res = moments[0];
          for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
              res = moments[i];
            }
          }
          return res;
        }

        // TODO: Use [].sort instead?
        function min() {
          var args = [].slice.call(arguments, 0);
          return pickBy$2('isBefore', args);
        }
        function max() {
          var args = [].slice.call(arguments, 0);
          return pickBy$2('isAfter', args);
        }
        var now$2 = function () {
          return Date.now ? Date.now() : +new Date();
        };
        var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];
        function isDurationValid(m) {
          var key,
            unitHasDecimal = false,
            i,
            orderLen = ordering.length;
          for (key in m) {
            if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
              return false;
            }
          }
          for (i = 0; i < orderLen; ++i) {
            if (m[ordering[i]]) {
              if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
              }

              if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
              }
            }
          }
          return true;
        }
        function isValid$1() {
          return this._isValid;
        }
        function createInvalid$1() {
          return createDuration(NaN);
        }
        function Duration(duration) {
          var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;
          this._isValid = isDurationValid(normalizedInput);

          // representation for dateAddRemove
          this._milliseconds = +milliseconds + seconds * 1e3 +
          // 1000
          minutes * 6e4 +
          // 1000 * 60
          hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
          // Because of dateAddRemove treats 24 hours as different from a
          // day when working around DST, we need to store them separately
          this._days = +days + weeks * 7;
          // It is impossible to translate months into days without knowing
          // which months you are are talking about, so we have to store
          // it separately.
          this._months = +months + quarters * 3 + years * 12;
          this._data = {};
          this._locale = getLocale();
          this._bubble();
        }
        function isDuration(obj) {
          return obj instanceof Duration;
        }
        function absRound(number) {
          if (number < 0) {
            return Math.round(-1 * number) * -1;
          } else {
            return Math.round(number);
          }
        }

        // compare two arrays, return the number of differences
        function compareArrays(array1, array2, dontConvert) {
          var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
          for (i = 0; i < len; i++) {
            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
              diffs++;
            }
          }
          return diffs + lengthDiff;
        }

        // FORMATTING

        function offset(token, separator) {
          addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset(),
              sign = '+';
            if (offset < 0) {
              offset = -offset;
              sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
          });
        }
        offset('Z', ':');
        offset('ZZ', '');

        // PARSING

        addRegexToken('Z', matchShortOffset);
        addRegexToken('ZZ', matchShortOffset);
        addParseToken(['Z', 'ZZ'], function (input, array, config) {
          config._useUTC = true;
          config._tzm = offsetFromString(matchShortOffset, input);
        });

        // HELPERS

        // timezone chunker
        // '+10:00' > ['10',  '00']
        // '-1530'  > ['-15', '30']
        var chunkOffset = /([\+\-]|\d\d)/gi;
        function offsetFromString(matcher, string) {
          var matches = (string || '').match(matcher),
            chunk,
            parts,
            minutes;
          if (matches === null) {
            return null;
          }
          chunk = matches[matches.length - 1] || [];
          parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
          minutes = +(parts[1] * 60) + toInt(parts[2]);
          return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
        }

        // Return a moment from input, that is local/utc/zone equivalent to model.
        function cloneWithOffset(input, model) {
          var res, diff;
          if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
          } else {
            return createLocal(input).local();
          }
        }
        function getDateOffset(m) {
          // On Firefox.24 Date#getTimezoneOffset returns a floating point.
          // https://github.com/moment/moment/pull/1871
          return -Math.round(m._d.getTimezoneOffset());
        }

        // HOOKS

        // This function will be called whenever a moment is mutated.
        // It is intended to keep the offset in sync with the timezone.
        hooks.updateOffset = function () {};

        // MOMENTS

        // keepLocalTime = true means only change the timezone, without
        // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
        // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
        // +0200, so we adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        function getSetOffset(input, keepLocalTime, keepMinutes) {
          var offset = this._offset || 0,
            localAdjust;
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          if (input != null) {
            if (typeof input === 'string') {
              input = offsetFromString(matchShortOffset, input);
              if (input === null) {
                return this;
              }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
              input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
              localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
              this.add(localAdjust, 'm');
            }
            if (offset !== input) {
              if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
              } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
              }
            }
            return this;
          } else {
            return this._isUTC ? offset : getDateOffset(this);
          }
        }
        function getSetZone(input, keepLocalTime) {
          if (input != null) {
            if (typeof input !== 'string') {
              input = -input;
            }
            this.utcOffset(input, keepLocalTime);
            return this;
          } else {
            return -this.utcOffset();
          }
        }
        function setOffsetToUTC(keepLocalTime) {
          return this.utcOffset(0, keepLocalTime);
        }
        function setOffsetToLocal(keepLocalTime) {
          if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;
            if (keepLocalTime) {
              this.subtract(getDateOffset(this), 'm');
            }
          }
          return this;
        }
        function setOffsetToParsedOffset() {
          if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
          } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
              this.utcOffset(tZone);
            } else {
              this.utcOffset(0, true);
            }
          }
          return this;
        }
        function hasAlignedHourOffset(input) {
          if (!this.isValid()) {
            return false;
          }
          input = input ? createLocal(input).utcOffset() : 0;
          return (this.utcOffset() - input) % 60 === 0;
        }
        function isDaylightSavingTime() {
          return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
        }
        function isDaylightSavingTimeShifted() {
          if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
          }
          var c = {},
            other;
          copyConfig(c, this);
          c = prepareConfig(c);
          if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
          } else {
            this._isDSTShifted = false;
          }
          return this._isDSTShifted;
        }
        function isLocal() {
          return this.isValid() ? !this._isUTC : false;
        }
        function isUtcOffset() {
          return this.isValid() ? this._isUTC : false;
        }
        function isUtc() {
          return this.isValid() ? this._isUTC && this._offset === 0 : false;
        }

        // ASP.NET json date format regex
        var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
          // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
          // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
          // and further modified to allow for strings containing both week and day
          isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
        function createDuration(input, key) {
          var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;
          if (isDuration(input)) {
            duration = {
              ms: input._milliseconds,
              d: input._days,
              M: input._months
            };
          } else if (isNumber(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
              duration[key] = +input;
            } else {
              duration.milliseconds = +input;
            }
          } else if (match = aspNetRegex.exec(input)) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
              y: 0,
              d: toInt(match[DATE]) * sign,
              h: toInt(match[HOUR]) * sign,
              m: toInt(match[MINUTE]) * sign,
              s: toInt(match[SECOND]) * sign,
              ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
          } else if (match = isoRegex.exec(input)) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
              y: parseIso(match[2], sign),
              M: parseIso(match[3], sign),
              w: parseIso(match[4], sign),
              d: parseIso(match[5], sign),
              h: parseIso(match[6], sign),
              m: parseIso(match[7], sign),
              s: parseIso(match[8], sign)
            };
          } else if (duration == null) {
            // checks for null or undefined
            duration = {};
          } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
          }
          ret = new Duration(duration);
          if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
          }
          if (isDuration(input) && hasOwnProp(input, '_isValid')) {
            ret._isValid = input._isValid;
          }
          return ret;
        }
        createDuration.fn = Duration.prototype;
        createDuration.invalid = createInvalid$1;
        function parseIso(inp, sign) {
          // We'd normally use ~~inp for this, but unfortunately it also
          // converts floats to ints.
          // inp may be undefined, so careful calling replace on it.
          var res = inp && parseFloat(inp.replace(',', '.'));
          // apply sign while we're at it
          return (isNaN(res) ? 0 : res) * sign;
        }
        function positiveMomentsDifference(base, other) {
          var res = {};
          res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
          if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
          }
          res.milliseconds = +other - +base.clone().add(res.months, 'M');
          return res;
        }
        function momentsDifference(base, other) {
          var res;
          if (!(base.isValid() && other.isValid())) {
            return {
              milliseconds: 0,
              months: 0
            };
          }
          other = cloneWithOffset(other, base);
          if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
          } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
          }
          return res;
        }

        // TODO: remove 'name' arg after deprecation is removed
        function createAdder(direction, name) {
          return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
              deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
              tmp = val;
              val = period;
              period = tmp;
            }
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
          };
        }
        function addSubtract(mom, duration, isAdding, updateOffset) {
          var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);
          if (!mom.isValid()) {
            // No op
            return;
          }
          updateOffset = updateOffset == null ? true : updateOffset;
          if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
          }
          if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
          }
          if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
          }
          if (updateOffset) {
            hooks.updateOffset(mom, days || months);
          }
        }
        var add = createAdder(1, 'add'),
          subtract = createAdder(-1, 'subtract');
        function isString(input) {
          return typeof input === 'string' || input instanceof String;
        }

        // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
        function isMomentInput(input) {
          return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === undefined;
        }
        function isMomentInputObject(input) {
          var objectTest = isObject$9(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = ['years', 'year', 'y', 'months', 'month', 'M', 'days', 'day', 'd', 'dates', 'date', 'D', 'hours', 'hour', 'h', 'minutes', 'minute', 'm', 'seconds', 'second', 's', 'milliseconds', 'millisecond', 'ms'],
            i,
            property,
            propertyLen = properties.length;
          for (i = 0; i < propertyLen; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function isNumberOrStringArray(input) {
          var arrayTest = isArray$2(input),
            dataTypeTest = false;
          if (arrayTest) {
            dataTypeTest = input.filter(function (item) {
              return !isNumber(item) && isString(input);
            }).length === 0;
          }
          return arrayTest && dataTypeTest;
        }
        function isCalendarSpec(input) {
          var objectTest = isObject$9(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = ['sameDay', 'nextDay', 'lastDay', 'nextWeek', 'lastWeek', 'sameElse'],
            i,
            property;
          for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function getCalendarFormat(myMoment, now) {
          var diff = myMoment.diff(now, 'days', true);
          return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
        }
        function calendar$1(time, formats) {
          // Support for single parameter, formats only overload to the calendar function
          if (arguments.length === 1) {
            if (!arguments[0]) {
              time = undefined;
              formats = undefined;
            } else if (isMomentInput(arguments[0])) {
              time = arguments[0];
              formats = undefined;
            } else if (isCalendarSpec(arguments[0])) {
              formats = arguments[0];
              time = undefined;
            }
          }
          // We want to compare the start of today, vs this.
          // Getting start-of-today depends on whether we're local/utc/offset or not.
          var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse',
            output = formats && (isFunction$1(formats[format]) ? formats[format].call(this, now) : formats[format]);
          return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
        }
        function clone$5() {
          return new Moment(this);
        }
        function isAfter(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || 'millisecond';
          if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
          } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
          }
        }
        function isBefore(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || 'millisecond';
          if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
          } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
          }
        }
        function isBetween(from, to, units, inclusivity) {
          var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
          if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
          }
          inclusivity = inclusivity || '()';
          return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
        }
        function isSame(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || 'millisecond';
          if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
          } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
          }
        }
        function isSameOrAfter(input, units) {
          return this.isSame(input, units) || this.isAfter(input, units);
        }
        function isSameOrBefore(input, units) {
          return this.isSame(input, units) || this.isBefore(input, units);
        }
        function diff(input, units, asFloat) {
          var that, zoneDelta, output;
          if (!this.isValid()) {
            return NaN;
          }
          that = cloneWithOffset(input, this);
          if (!that.isValid()) {
            return NaN;
          }
          zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
          units = normalizeUnits(units);
          switch (units) {
            case 'year':
              output = monthDiff(this, that) / 12;
              break;
            case 'month':
              output = monthDiff(this, that);
              break;
            case 'quarter':
              output = monthDiff(this, that) / 3;
              break;
            case 'second':
              output = (this - that) / 1e3;
              break;
            // 1000
            case 'minute':
              output = (this - that) / 6e4;
              break;
            // 1000 * 60
            case 'hour':
              output = (this - that) / 36e5;
              break;
            // 1000 * 60 * 60
            case 'day':
              output = (this - that - zoneDelta) / 864e5;
              break;
            // 1000 * 60 * 60 * 24, negate dst
            case 'week':
              output = (this - that - zoneDelta) / 6048e5;
              break;
            // 1000 * 60 * 60 * 24 * 7, negate dst
            default:
              output = this - that;
          }
          return asFloat ? output : absFloor(output);
        }
        function monthDiff(a, b) {
          if (a.date() < b.date()) {
            // end-of-month calculations work correct when the start month has more
            // days than the end month.
            return -monthDiff(b, a);
          }
          // difference in months
          var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2,
            adjust;
          if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
          } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
          }

          //check for negative zero, return zero if negative zero
          return -(wholeMonthDiff + adjust) || 0;
        }
        hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
        hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';
        function toString$1() {
          return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
        }
        function toISOString(keepOffset) {
          if (!this.isValid()) {
            return null;
          }
          var utc = keepOffset !== true,
            m = utc ? this.clone().utc() : this;
          if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
          }
          if (isFunction$1(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
              return this.toDate().toISOString();
            } else {
              return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
            }
          }
          return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }

        /**
         * Return a human readable representation of a moment that can
         * also be evaluated to get a new moment which is the same
         *
         * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
         */
        function inspect() {
          if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
          }
          var func = 'moment',
            zone = '',
            prefix,
            year,
            datetime,
            suffix;
          if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
          }
          prefix = '[' + func + '("]';
          year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
          datetime = '-MM-DD[T]HH:mm:ss.SSS';
          suffix = zone + '[")]';
          return this.format(prefix + year + datetime + suffix);
        }
        function format(inputString) {
          if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
          }
          var output = formatMoment(this, inputString);
          return this.localeData().postformat(output);
        }
        function from(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({
              to: this,
              from: time
            }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function fromNow(withoutSuffix) {
          return this.from(createLocal(), withoutSuffix);
        }
        function to(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({
              from: this,
              to: time
            }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function toNow(withoutSuffix) {
          return this.to(createLocal(), withoutSuffix);
        }

        // If passed a locale key, it will set the locale for this
        // instance.  Otherwise, it will return the locale configuration
        // variables for this instance.
        function locale(key) {
          var newLocaleData;
          if (key === undefined) {
            return this._locale._abbr;
          } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
              this._locale = newLocaleData;
            }
            return this;
          }
        }
        var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
          if (key === undefined) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        });
        function localeData() {
          return this._locale;
        }
        var MS_PER_SECOND = 1000,
          MS_PER_MINUTE = 60 * MS_PER_SECOND,
          MS_PER_HOUR = 60 * MS_PER_MINUTE,
          MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

        // actual modulo - handles negative numbers (for dates before 1970):
        function mod$1(dividend, divisor) {
          return (dividend % divisor + divisor) % divisor;
        }
        function localStartOfDate(y, m, d) {
          // the date constructor remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return new Date(y, m, d).valueOf();
          }
        }
        function utcStartOfDate(y, m, d) {
          // Date.UTC remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return Date.UTC(y, m, d);
          }
        }
        function startOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case 'year':
              time = startOfDate(this.year(), 0, 1);
              break;
            case 'quarter':
              time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
              break;
            case 'month':
              time = startOfDate(this.year(), this.month(), 1);
              break;
            case 'week':
              time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
              break;
            case 'isoWeek':
              time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
              break;
            case 'day':
            case 'date':
              time = startOfDate(this.year(), this.month(), this.date());
              break;
            case 'hour':
              time = this._d.valueOf();
              time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
              break;
            case 'minute':
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_MINUTE);
              break;
            case 'second':
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_SECOND);
              break;
          }
          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
        }
        function endOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case 'year':
              time = startOfDate(this.year() + 1, 0, 1) - 1;
              break;
            case 'quarter':
              time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
              break;
            case 'month':
              time = startOfDate(this.year(), this.month() + 1, 1) - 1;
              break;
            case 'week':
              time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
              break;
            case 'isoWeek':
              time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
              break;
            case 'day':
            case 'date':
              time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
              break;
            case 'hour':
              time = this._d.valueOf();
              time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
              break;
            case 'minute':
              time = this._d.valueOf();
              time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
              break;
            case 'second':
              time = this._d.valueOf();
              time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
              break;
          }
          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
        }
        function valueOf() {
          return this._d.valueOf() - (this._offset || 0) * 60000;
        }
        function unix() {
          return Math.floor(this.valueOf() / 1000);
        }
        function toDate() {
          return new Date(this.valueOf());
        }
        function toArray() {
          var m = this;
          return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
        }
        function toObject() {
          var m = this;
          return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
          };
        }
        function toJSON() {
          // new Date(NaN).toJSON() === null
          return this.isValid() ? this.toISOString() : null;
        }
        function isValid$2() {
          return isValid(this);
        }
        function parsingFlags() {
          return extend({}, getParsingFlags(this));
        }
        function invalidAt() {
          return getParsingFlags(this).overflow;
        }
        function creationData() {
          return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
          };
        }
        addFormatToken('N', 0, 0, 'eraAbbr');
        addFormatToken('NN', 0, 0, 'eraAbbr');
        addFormatToken('NNN', 0, 0, 'eraAbbr');
        addFormatToken('NNNN', 0, 0, 'eraName');
        addFormatToken('NNNNN', 0, 0, 'eraNarrow');
        addFormatToken('y', ['y', 1], 'yo', 'eraYear');
        addFormatToken('y', ['yy', 2], 0, 'eraYear');
        addFormatToken('y', ['yyy', 3], 0, 'eraYear');
        addFormatToken('y', ['yyyy', 4], 0, 'eraYear');
        addRegexToken('N', matchEraAbbr);
        addRegexToken('NN', matchEraAbbr);
        addRegexToken('NNN', matchEraAbbr);
        addRegexToken('NNNN', matchEraName);
        addRegexToken('NNNNN', matchEraNarrow);
        addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (input, array, config, token) {
          var era = config._locale.erasParse(input, token, config._strict);
          if (era) {
            getParsingFlags(config).era = era;
          } else {
            getParsingFlags(config).invalidEra = input;
          }
        });
        addRegexToken('y', matchUnsigned);
        addRegexToken('yy', matchUnsigned);
        addRegexToken('yyy', matchUnsigned);
        addRegexToken('yyyy', matchUnsigned);
        addRegexToken('yo', matchEraYearOrdinal);
        addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
        addParseToken(['yo'], function (input, array, config, token) {
          var match;
          if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
          }
          if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
          } else {
            array[YEAR] = parseInt(input, 10);
          }
        });
        function localeEras(m, format) {
          var i,
            l,
            date,
            eras = this._eras || getLocale('en')._eras;
          for (i = 0, l = eras.length; i < l; ++i) {
            switch (typeof eras[i].since) {
              case 'string':
                // truncate time
                date = hooks(eras[i].since).startOf('day');
                eras[i].since = date.valueOf();
                break;
            }
            switch (typeof eras[i].until) {
              case 'undefined':
                eras[i].until = +Infinity;
                break;
              case 'string':
                // truncate time
                date = hooks(eras[i].until).startOf('day').valueOf();
                eras[i].until = date.valueOf();
                break;
            }
          }
          return eras;
        }
        function localeErasParse(eraName, format, strict) {
          var i,
            l,
            eras = this.eras(),
            name,
            abbr,
            narrow;
          eraName = eraName.toUpperCase();
          for (i = 0, l = eras.length; i < l; ++i) {
            name = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            narrow = eras[i].narrow.toUpperCase();
            if (strict) {
              switch (format) {
                case 'N':
                case 'NN':
                case 'NNN':
                  if (abbr === eraName) {
                    return eras[i];
                  }
                  break;
                case 'NNNN':
                  if (name === eraName) {
                    return eras[i];
                  }
                  break;
                case 'NNNNN':
                  if (narrow === eraName) {
                    return eras[i];
                  }
                  break;
              }
            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
              return eras[i];
            }
          }
        }
        function localeErasConvertYear(era, year) {
          var dir = era.since <= era.until ? +1 : -1;
          if (year === undefined) {
            return hooks(era.since).year();
          } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
          }
        }
        function getEraName() {
          var i,
            l,
            val,
            eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].name;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].name;
            }
          }
          return '';
        }
        function getEraNarrow() {
          var i,
            l,
            val,
            eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].narrow;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].narrow;
            }
          }
          return '';
        }
        function getEraAbbr() {
          var i,
            l,
            val,
            eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].abbr;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].abbr;
            }
          }
          return '';
        }
        function getEraYear() {
          var i,
            l,
            dir,
            val,
            eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            dir = eras[i].since <= eras[i].until ? +1 : -1;

            // truncate time
            val = this.clone().startOf('day').valueOf();
            if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
              return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
            }
          }
          return this.year();
        }
        function erasNameRegex(isStrict) {
          if (!hasOwnProp(this, '_erasNameRegex')) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNameRegex : this._erasRegex;
        }
        function erasAbbrRegex(isStrict) {
          if (!hasOwnProp(this, '_erasAbbrRegex')) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasAbbrRegex : this._erasRegex;
        }
        function erasNarrowRegex(isStrict) {
          if (!hasOwnProp(this, '_erasNarrowRegex')) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNarrowRegex : this._erasRegex;
        }
        function matchEraAbbr(isStrict, locale) {
          return locale.erasAbbrRegex(isStrict);
        }
        function matchEraName(isStrict, locale) {
          return locale.erasNameRegex(isStrict);
        }
        function matchEraNarrow(isStrict, locale) {
          return locale.erasNarrowRegex(isStrict);
        }
        function matchEraYearOrdinal(isStrict, locale) {
          return locale._eraYearOrdinalRegex || matchUnsigned;
        }
        function computeErasParse() {
          var abbrPieces = [],
            namePieces = [],
            narrowPieces = [],
            mixedPieces = [],
            i,
            l,
            eras = this.eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            namePieces.push(regexEscape(eras[i].name));
            abbrPieces.push(regexEscape(eras[i].abbr));
            narrowPieces.push(regexEscape(eras[i].narrow));
            mixedPieces.push(regexEscape(eras[i].name));
            mixedPieces.push(regexEscape(eras[i].abbr));
            mixedPieces.push(regexEscape(eras[i].narrow));
          }
          this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
          this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
          this._erasNarrowRegex = new RegExp('^(' + narrowPieces.join('|') + ')', 'i');
        }

        // FORMATTING

        addFormatToken(0, ['gg', 2], 0, function () {
          return this.weekYear() % 100;
        });
        addFormatToken(0, ['GG', 2], 0, function () {
          return this.isoWeekYear() % 100;
        });
        function addWeekYearFormatToken(token, getter) {
          addFormatToken(0, [token, token.length], 0, getter);
        }
        addWeekYearFormatToken('gggg', 'weekYear');
        addWeekYearFormatToken('ggggg', 'weekYear');
        addWeekYearFormatToken('GGGG', 'isoWeekYear');
        addWeekYearFormatToken('GGGGG', 'isoWeekYear');

        // ALIASES

        addUnitAlias('weekYear', 'gg');
        addUnitAlias('isoWeekYear', 'GG');

        // PRIORITY

        addUnitPriority('weekYear', 1);
        addUnitPriority('isoWeekYear', 1);

        // PARSING

        addRegexToken('G', matchSigned);
        addRegexToken('g', matchSigned);
        addRegexToken('GG', match1to2, match2);
        addRegexToken('gg', match1to2, match2);
        addRegexToken('GGGG', match1to4, match4);
        addRegexToken('gggg', match1to4, match4);
        addRegexToken('GGGGG', match1to6, match6);
        addRegexToken('ggggg', match1to6, match6);
        addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
          week[token.substr(0, 2)] = toInt(input);
        });
        addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
          week[token] = hooks.parseTwoDigitYear(input);
        });

        // MOMENTS

        function getSetWeekYear(input) {
          return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
        }
        function getSetISOWeekYear(input) {
          return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
        }
        function getISOWeeksInYear() {
          return weeksInYear(this.year(), 1, 4);
        }
        function getISOWeeksInISOWeekYear() {
          return weeksInYear(this.isoWeekYear(), 1, 4);
        }
        function getWeeksInYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        }
        function getWeeksInWeekYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
        }
        function getSetWeekYearHelper(input, week, weekday, dow, doy) {
          var weeksTarget;
          if (input == null) {
            return weekOfYear(this, dow, doy).year;
          } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
              week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
          }
        }
        function setWeekAll(weekYear, week, weekday, dow, doy) {
          var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
          this.year(date.getUTCFullYear());
          this.month(date.getUTCMonth());
          this.date(date.getUTCDate());
          return this;
        }

        // FORMATTING

        addFormatToken('Q', 0, 'Qo', 'quarter');

        // ALIASES

        addUnitAlias('quarter', 'Q');

        // PRIORITY

        addUnitPriority('quarter', 7);

        // PARSING

        addRegexToken('Q', match1);
        addParseToken('Q', function (input, array) {
          array[MONTH] = (toInt(input) - 1) * 3;
        });

        // MOMENTS

        function getSetQuarter(input) {
          return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        }

        // FORMATTING

        addFormatToken('D', ['DD', 2], 'Do', 'date');

        // ALIASES

        addUnitAlias('date', 'D');

        // PRIORITY
        addUnitPriority('date', 9);

        // PARSING

        addRegexToken('D', match1to2);
        addRegexToken('DD', match1to2, match2);
        addRegexToken('Do', function (isStrict, locale) {
          // TODO: Remove "ordinalParse" fallback in next major release.
          return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
        });
        addParseToken(['D', 'DD'], DATE);
        addParseToken('Do', function (input, array) {
          array[DATE] = toInt(input.match(match1to2)[0]);
        });

        // MOMENTS

        var getSetDayOfMonth = makeGetSet('Date', true);

        // FORMATTING

        addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

        // ALIASES

        addUnitAlias('dayOfYear', 'DDD');

        // PRIORITY
        addUnitPriority('dayOfYear', 4);

        // PARSING

        addRegexToken('DDD', match1to3);
        addRegexToken('DDDD', match3);
        addParseToken(['DDD', 'DDDD'], function (input, array, config) {
          config._dayOfYear = toInt(input);
        });

        // HELPERS

        // MOMENTS

        function getSetDayOfYear(input) {
          var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
          return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
        }

        // FORMATTING

        addFormatToken('m', ['mm', 2], 0, 'minute');

        // ALIASES

        addUnitAlias('minute', 'm');

        // PRIORITY

        addUnitPriority('minute', 14);

        // PARSING

        addRegexToken('m', match1to2);
        addRegexToken('mm', match1to2, match2);
        addParseToken(['m', 'mm'], MINUTE);

        // MOMENTS

        var getSetMinute = makeGetSet('Minutes', false);

        // FORMATTING

        addFormatToken('s', ['ss', 2], 0, 'second');

        // ALIASES

        addUnitAlias('second', 's');

        // PRIORITY

        addUnitPriority('second', 15);

        // PARSING

        addRegexToken('s', match1to2);
        addRegexToken('ss', match1to2, match2);
        addParseToken(['s', 'ss'], SECOND);

        // MOMENTS

        var getSetSecond = makeGetSet('Seconds', false);

        // FORMATTING

        addFormatToken('S', 0, 0, function () {
          return ~~(this.millisecond() / 100);
        });
        addFormatToken(0, ['SS', 2], 0, function () {
          return ~~(this.millisecond() / 10);
        });
        addFormatToken(0, ['SSS', 3], 0, 'millisecond');
        addFormatToken(0, ['SSSS', 4], 0, function () {
          return this.millisecond() * 10;
        });
        addFormatToken(0, ['SSSSS', 5], 0, function () {
          return this.millisecond() * 100;
        });
        addFormatToken(0, ['SSSSSS', 6], 0, function () {
          return this.millisecond() * 1000;
        });
        addFormatToken(0, ['SSSSSSS', 7], 0, function () {
          return this.millisecond() * 10000;
        });
        addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
          return this.millisecond() * 100000;
        });
        addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
          return this.millisecond() * 1000000;
        });

        // ALIASES

        addUnitAlias('millisecond', 'ms');

        // PRIORITY

        addUnitPriority('millisecond', 16);

        // PARSING

        addRegexToken('S', match1to3, match1);
        addRegexToken('SS', match1to3, match2);
        addRegexToken('SSS', match1to3, match3);
        var token, getSetMillisecond;
        for (token = 'SSSS'; token.length <= 9; token += 'S') {
          addRegexToken(token, matchUnsigned);
        }
        function parseMs(input, array) {
          array[MILLISECOND] = toInt(('0.' + input) * 1000);
        }
        for (token = 'S'; token.length <= 9; token += 'S') {
          addParseToken(token, parseMs);
        }
        getSetMillisecond = makeGetSet('Milliseconds', false);

        // FORMATTING

        addFormatToken('z', 0, 0, 'zoneAbbr');
        addFormatToken('zz', 0, 0, 'zoneName');

        // MOMENTS

        function getZoneAbbr() {
          return this._isUTC ? 'UTC' : '';
        }
        function getZoneName() {
          return this._isUTC ? 'Coordinated Universal Time' : '';
        }
        var proto = Moment.prototype;
        proto.add = add;
        proto.calendar = calendar$1;
        proto.clone = clone$5;
        proto.diff = diff;
        proto.endOf = endOf;
        proto.format = format;
        proto.from = from;
        proto.fromNow = fromNow;
        proto.to = to;
        proto.toNow = toNow;
        proto.get = stringGet;
        proto.invalidAt = invalidAt;
        proto.isAfter = isAfter;
        proto.isBefore = isBefore;
        proto.isBetween = isBetween;
        proto.isSame = isSame;
        proto.isSameOrAfter = isSameOrAfter;
        proto.isSameOrBefore = isSameOrBefore;
        proto.isValid = isValid$2;
        proto.lang = lang;
        proto.locale = locale;
        proto.localeData = localeData;
        proto.max = prototypeMax;
        proto.min = prototypeMin;
        proto.parsingFlags = parsingFlags;
        proto.set = stringSet;
        proto.startOf = startOf;
        proto.subtract = subtract;
        proto.toArray = toArray;
        proto.toObject = toObject;
        proto.toDate = toDate;
        proto.toISOString = toISOString;
        proto.inspect = inspect;
        if (typeof Symbol !== 'undefined' && Symbol.for != null) {
          proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
            return 'Moment<' + this.format() + '>';
          };
        }
        proto.toJSON = toJSON;
        proto.toString = toString$1;
        proto.unix = unix;
        proto.valueOf = valueOf;
        proto.creationData = creationData;
        proto.eraName = getEraName;
        proto.eraNarrow = getEraNarrow;
        proto.eraAbbr = getEraAbbr;
        proto.eraYear = getEraYear;
        proto.year = getSetYear;
        proto.isLeapYear = getIsLeapYear;
        proto.weekYear = getSetWeekYear;
        proto.isoWeekYear = getSetISOWeekYear;
        proto.quarter = proto.quarters = getSetQuarter;
        proto.month = getSetMonth;
        proto.daysInMonth = getDaysInMonth;
        proto.week = proto.weeks = getSetWeek;
        proto.isoWeek = proto.isoWeeks = getSetISOWeek;
        proto.weeksInYear = getWeeksInYear;
        proto.weeksInWeekYear = getWeeksInWeekYear;
        proto.isoWeeksInYear = getISOWeeksInYear;
        proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
        proto.date = getSetDayOfMonth;
        proto.day = proto.days = getSetDayOfWeek;
        proto.weekday = getSetLocaleDayOfWeek;
        proto.isoWeekday = getSetISODayOfWeek;
        proto.dayOfYear = getSetDayOfYear;
        proto.hour = proto.hours = getSetHour;
        proto.minute = proto.minutes = getSetMinute;
        proto.second = proto.seconds = getSetSecond;
        proto.millisecond = proto.milliseconds = getSetMillisecond;
        proto.utcOffset = getSetOffset;
        proto.utc = setOffsetToUTC;
        proto.local = setOffsetToLocal;
        proto.parseZone = setOffsetToParsedOffset;
        proto.hasAlignedHourOffset = hasAlignedHourOffset;
        proto.isDST = isDaylightSavingTime;
        proto.isLocal = isLocal;
        proto.isUtcOffset = isUtcOffset;
        proto.isUtc = isUtc;
        proto.isUTC = isUtc;
        proto.zoneAbbr = getZoneAbbr;
        proto.zoneName = getZoneName;
        proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
        proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
        proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
        proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
        proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);
        function createUnix(input) {
          return createLocal(input * 1000);
        }
        function createInZone() {
          return createLocal.apply(null, arguments).parseZone();
        }
        function preParsePostFormat(string) {
          return string;
        }
        var proto$1 = Locale.prototype;
        proto$1.calendar = calendar;
        proto$1.longDateFormat = longDateFormat;
        proto$1.invalidDate = invalidDate;
        proto$1.ordinal = ordinal;
        proto$1.preparse = preParsePostFormat;
        proto$1.postformat = preParsePostFormat;
        proto$1.relativeTime = relativeTime;
        proto$1.pastFuture = pastFuture;
        proto$1.set = set;
        proto$1.eras = localeEras;
        proto$1.erasParse = localeErasParse;
        proto$1.erasConvertYear = localeErasConvertYear;
        proto$1.erasAbbrRegex = erasAbbrRegex;
        proto$1.erasNameRegex = erasNameRegex;
        proto$1.erasNarrowRegex = erasNarrowRegex;
        proto$1.months = localeMonths;
        proto$1.monthsShort = localeMonthsShort;
        proto$1.monthsParse = localeMonthsParse;
        proto$1.monthsRegex = monthsRegex;
        proto$1.monthsShortRegex = monthsShortRegex;
        proto$1.week = localeWeek;
        proto$1.firstDayOfYear = localeFirstDayOfYear;
        proto$1.firstDayOfWeek = localeFirstDayOfWeek;
        proto$1.weekdays = localeWeekdays;
        proto$1.weekdaysMin = localeWeekdaysMin;
        proto$1.weekdaysShort = localeWeekdaysShort;
        proto$1.weekdaysParse = localeWeekdaysParse;
        proto$1.weekdaysRegex = weekdaysRegex;
        proto$1.weekdaysShortRegex = weekdaysShortRegex;
        proto$1.weekdaysMinRegex = weekdaysMinRegex;
        proto$1.isPM = localeIsPM;
        proto$1.meridiem = localeMeridiem;
        function get$1(format, index, field, setter) {
          var locale = getLocale(),
            utc = createUTC().set(setter, index);
          return locale[field](utc, format);
        }
        function listMonthsImpl(format, index, field) {
          if (isNumber(format)) {
            index = format;
            format = undefined;
          }
          format = format || '';
          if (index != null) {
            return get$1(format, index, field, 'month');
          }
          var i,
            out = [];
          for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
          }
          return out;
        }

        // ()
        // (5)
        // (fmt, 5)
        // (fmt)
        // (true)
        // (true, 5)
        // (true, fmt, 5)
        // (true, fmt)
        function listWeekdaysImpl(localeSorted, format, index, field) {
          if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
              index = format;
              format = undefined;
            }
            format = format || '';
          } else {
            format = localeSorted;
            index = format;
            localeSorted = false;
            if (isNumber(format)) {
              index = format;
              format = undefined;
            }
            format = format || '';
          }
          var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0,
            i,
            out = [];
          if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
          }
          for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
          }
          return out;
        }
        function listMonths(format, index) {
          return listMonthsImpl(format, index, 'months');
        }
        function listMonthsShort(format, index) {
          return listMonthsImpl(format, index, 'monthsShort');
        }
        function listWeekdays(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
        }
        function listWeekdaysShort(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
        }
        function listWeekdaysMin(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
        }
        getSetGlobalLocale('en', {
          eras: [{
            since: '0001-01-01',
            until: +Infinity,
            offset: 1,
            name: 'Anno Domini',
            narrow: 'AD',
            abbr: 'AD'
          }, {
            since: '0000-12-31',
            until: -Infinity,
            offset: 1,
            name: 'Before Christ',
            narrow: 'BC',
            abbr: 'BC'
          }],
          dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
          ordinal: function (number) {
            var b = number % 10,
              output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
            return number + output;
          }
        });

        // Side effect imports

        hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
        hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
        var mathAbs = Math.abs;
        function abs() {
          var data = this._data;
          this._milliseconds = mathAbs(this._milliseconds);
          this._days = mathAbs(this._days);
          this._months = mathAbs(this._months);
          data.milliseconds = mathAbs(data.milliseconds);
          data.seconds = mathAbs(data.seconds);
          data.minutes = mathAbs(data.minutes);
          data.hours = mathAbs(data.hours);
          data.months = mathAbs(data.months);
          data.years = mathAbs(data.years);
          return this;
        }
        function addSubtract$1(duration, input, value, direction) {
          var other = createDuration(input, value);
          duration._milliseconds += direction * other._milliseconds;
          duration._days += direction * other._days;
          duration._months += direction * other._months;
          return duration._bubble();
        }

        // supports only 2.0-style add(1, 's') or add(duration)
        function add$1(input, value) {
          return addSubtract$1(this, input, value, 1);
        }

        // supports only 2.0-style subtract(1, 's') or subtract(duration)
        function subtract$1(input, value) {
          return addSubtract$1(this, input, value, -1);
        }
        function absCeil(number) {
          if (number < 0) {
            return Math.floor(number);
          } else {
            return Math.ceil(number);
          }
        }
        function bubble() {
          var milliseconds = this._milliseconds,
            days = this._days,
            months = this._months,
            data = this._data,
            seconds,
            minutes,
            hours,
            years,
            monthsFromDays;

          // if we have a mix of positive and negative values, bubble down first
          // check: https://github.com/moment/moment/issues/2166
          if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
          }

          // The following code bubbles up values, see the tests for
          // examples of what that means.
          data.milliseconds = milliseconds % 1000;
          seconds = absFloor(milliseconds / 1000);
          data.seconds = seconds % 60;
          minutes = absFloor(seconds / 60);
          data.minutes = minutes % 60;
          hours = absFloor(minutes / 60);
          data.hours = hours % 24;
          days += absFloor(hours / 24);

          // convert days to months
          monthsFromDays = absFloor(daysToMonths(days));
          months += monthsFromDays;
          days -= absCeil(monthsToDays(monthsFromDays));

          // 12 months -> 1 year
          years = absFloor(months / 12);
          months %= 12;
          data.days = days;
          data.months = months;
          data.years = years;
          return this;
        }
        function daysToMonths(days) {
          // 400 years have 146097 days (taking into account leap year rules)
          // 400 years have 12 months === 4800
          return days * 4800 / 146097;
        }
        function monthsToDays(months) {
          // the reverse of daysToMonths
          return months * 146097 / 4800;
        }
        function as(units) {
          if (!this.isValid()) {
            return NaN;
          }
          var days,
            months,
            milliseconds = this._milliseconds;
          units = normalizeUnits(units);
          if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
              case 'month':
                return months;
              case 'quarter':
                return months / 3;
              case 'year':
                return months / 12;
            }
          } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
              case 'week':
                return days / 7 + milliseconds / 6048e5;
              case 'day':
                return days + milliseconds / 864e5;
              case 'hour':
                return days * 24 + milliseconds / 36e5;
              case 'minute':
                return days * 1440 + milliseconds / 6e4;
              case 'second':
                return days * 86400 + milliseconds / 1000;
              // Math.floor prevents floating point math errors here
              case 'millisecond':
                return Math.floor(days * 864e5) + milliseconds;
              default:
                throw new Error('Unknown unit ' + units);
            }
          }
        }

        // TODO: Use this.as('ms')?
        function valueOf$1() {
          if (!this.isValid()) {
            return NaN;
          }
          return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
        }
        function makeAs(alias) {
          return function () {
            return this.as(alias);
          };
        }
        var asMilliseconds = makeAs('ms'),
          asSeconds = makeAs('s'),
          asMinutes = makeAs('m'),
          asHours = makeAs('h'),
          asDays = makeAs('d'),
          asWeeks = makeAs('w'),
          asMonths = makeAs('M'),
          asQuarters = makeAs('Q'),
          asYears = makeAs('y');
        function clone$1$1() {
          return createDuration(this);
        }
        function get$2(units) {
          units = normalizeUnits(units);
          return this.isValid() ? this[units + 's']() : NaN;
        }
        function makeGetter(name) {
          return function () {
            return this.isValid() ? this._data[name] : NaN;
          };
        }
        var milliseconds = makeGetter('milliseconds'),
          seconds = makeGetter('seconds'),
          minutes = makeGetter('minutes'),
          hours = makeGetter('hours'),
          days = makeGetter('days'),
          months = makeGetter('months'),
          years = makeGetter('years');
        function weeks() {
          return absFloor(this.days() / 7);
        }
        var round = Math.round,
          thresholds = {
            ss: 44,
            // a few seconds to seconds
            s: 45,
            // seconds to minute
            m: 45,
            // minutes to hour
            h: 22,
            // hours to day
            d: 26,
            // days to month/week
            w: null,
            // weeks to month
            M: 11 // months to year
          };

        // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
        function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
          return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
        }
        function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
          var duration = createDuration(posNegDuration).abs(),
            seconds = round(duration.as('s')),
            minutes = round(duration.as('m')),
            hours = round(duration.as('h')),
            days = round(duration.as('d')),
            months = round(duration.as('M')),
            weeks = round(duration.as('w')),
            years = round(duration.as('y')),
            a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days];
          if (thresholds.w != null) {
            a = a || weeks <= 1 && ['w'] || weeks < thresholds.w && ['ww', weeks];
          }
          a = a || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
          a[2] = withoutSuffix;
          a[3] = +posNegDuration > 0;
          a[4] = locale;
          return substituteTimeAgo.apply(null, a);
        }

        // This function allows you to set the rounding function for relative time strings
        function getSetRelativeTimeRounding(roundingFunction) {
          if (roundingFunction === undefined) {
            return round;
          }
          if (typeof roundingFunction === 'function') {
            round = roundingFunction;
            return true;
          }
          return false;
        }

        // This function allows you to set a threshold for relative time strings
        function getSetRelativeTimeThreshold(threshold, limit) {
          if (thresholds[threshold] === undefined) {
            return false;
          }
          if (limit === undefined) {
            return thresholds[threshold];
          }
          thresholds[threshold] = limit;
          if (threshold === 's') {
            thresholds.ss = limit - 1;
          }
          return true;
        }
        function humanize(argWithSuffix, argThresholds) {
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var withSuffix = false,
            th = thresholds,
            locale,
            output;
          if (typeof argWithSuffix === 'object') {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
          }
          if (typeof argWithSuffix === 'boolean') {
            withSuffix = argWithSuffix;
          }
          if (typeof argThresholds === 'object') {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
              th.ss = argThresholds.s - 1;
            }
          }
          locale = this.localeData();
          output = relativeTime$1(this, !withSuffix, th, locale);
          if (withSuffix) {
            output = locale.pastFuture(+this, output);
          }
          return locale.postformat(output);
        }
        var abs$1 = Math.abs;
        function sign(x) {
          return (x > 0) - (x < 0) || +x;
        }
        function toISOString$1() {
          // for ISO strings we do not use the normal bubbling rules:
          //  * milliseconds bubble up until they become hours
          //  * days do not bubble at all
          //  * months bubble up until they become years
          // This is because there is no context-free conversion between hours and days
          // (think of clock changes)
          // and also not between days and months (28-31 days per month)
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var seconds = abs$1(this._milliseconds) / 1000,
            days = abs$1(this._days),
            months = abs$1(this._months),
            minutes,
            hours,
            years,
            s,
            total = this.asSeconds(),
            totalSign,
            ymSign,
            daysSign,
            hmsSign;
          if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
          }

          // 3600 seconds -> 60 minutes -> 1 hour
          minutes = absFloor(seconds / 60);
          hours = absFloor(minutes / 60);
          seconds %= 60;
          minutes %= 60;

          // 12 months -> 1 year
          years = absFloor(months / 12);
          months %= 12;

          // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
          s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
          totalSign = total < 0 ? '-' : '';
          ymSign = sign(this._months) !== sign(total) ? '-' : '';
          daysSign = sign(this._days) !== sign(total) ? '-' : '';
          hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
          return totalSign + 'P' + (years ? ymSign + years + 'Y' : '') + (months ? ymSign + months + 'M' : '') + (days ? daysSign + days + 'D' : '') + (hours || minutes || seconds ? 'T' : '') + (hours ? hmsSign + hours + 'H' : '') + (minutes ? hmsSign + minutes + 'M' : '') + (seconds ? hmsSign + s + 'S' : '');
        }
        var proto$2 = Duration.prototype;
        proto$2.isValid = isValid$1;
        proto$2.abs = abs;
        proto$2.add = add$1;
        proto$2.subtract = subtract$1;
        proto$2.as = as;
        proto$2.asMilliseconds = asMilliseconds;
        proto$2.asSeconds = asSeconds;
        proto$2.asMinutes = asMinutes;
        proto$2.asHours = asHours;
        proto$2.asDays = asDays;
        proto$2.asWeeks = asWeeks;
        proto$2.asMonths = asMonths;
        proto$2.asQuarters = asQuarters;
        proto$2.asYears = asYears;
        proto$2.valueOf = valueOf$1;
        proto$2._bubble = bubble;
        proto$2.clone = clone$1$1;
        proto$2.get = get$2;
        proto$2.milliseconds = milliseconds;
        proto$2.seconds = seconds;
        proto$2.minutes = minutes;
        proto$2.hours = hours;
        proto$2.days = days;
        proto$2.weeks = weeks;
        proto$2.months = months;
        proto$2.years = years;
        proto$2.humanize = humanize;
        proto$2.toISOString = toISOString$1;
        proto$2.toString = toISOString$1;
        proto$2.toJSON = toISOString$1;
        proto$2.locale = locale;
        proto$2.localeData = localeData;
        proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
        proto$2.lang = lang;

        // FORMATTING

        addFormatToken('X', 0, 0, 'unix');
        addFormatToken('x', 0, 0, 'valueOf');

        // PARSING

        addRegexToken('x', matchSigned);
        addRegexToken('X', matchTimestamp);
        addParseToken('X', function (input, array, config) {
          config._d = new Date(parseFloat(input) * 1000);
        });
        addParseToken('x', function (input, array, config) {
          config._d = new Date(toInt(input));
        });

        //! moment.js

        hooks.version = '2.29.4';
        setHookCallback(createLocal);
        hooks.fn = proto;
        hooks.min = min;
        hooks.max = max;
        hooks.now = now$2;
        hooks.utc = createUTC;
        hooks.unix = createUnix;
        hooks.months = listMonths;
        hooks.isDate = isDate;
        hooks.locale = getSetGlobalLocale;
        hooks.invalid = createInvalid;
        hooks.duration = createDuration;
        hooks.isMoment = isMoment;
        hooks.weekdays = listWeekdays;
        hooks.parseZone = createInZone;
        hooks.localeData = getLocale;
        hooks.isDuration = isDuration;
        hooks.monthsShort = listMonthsShort;
        hooks.weekdaysMin = listWeekdaysMin;
        hooks.defineLocale = defineLocale;
        hooks.updateLocale = updateLocale;
        hooks.locales = listLocales;
        hooks.weekdaysShort = listWeekdaysShort;
        hooks.normalizeUnits = normalizeUnits;
        hooks.relativeTimeRounding = getSetRelativeTimeRounding;
        hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
        hooks.calendarFormat = getCalendarFormat;
        hooks.prototype = proto;

        // currently HTML5 input type only supports 24-hour formats
        hooks.HTML5_FMT = {
          DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
          // <input type="datetime-local" />
          DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
          // <input type="datetime-local" step="1" />
          DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
          // <input type="datetime-local" step="0.001" />
          DATE: 'YYYY-MM-DD',
          // <input type="date" />
          TIME: 'HH:mm',
          // <input type="time" />
          TIME_SECONDS: 'HH:mm:ss',
          // <input type="time" step="1" />
          TIME_MS: 'HH:mm:ss.SSS',
          // <input type="time" step="0.001" />
          WEEK: 'GGGG-[W]WW',
          // <input type="week" />
          MONTH: 'YYYY-MM' // <input type="month" />
        };

        var defaultFormats = {
          normalDateWithWeekday: "ddd, MMM D",
          normalDate: "D MMMM",
          shortDate: "MMM D",
          monthAndDate: "MMMM D",
          dayOfMonth: "D",
          year: "YYYY",
          month: "MMMM",
          monthShort: "MMM",
          monthAndYear: "MMMM YYYY",
          weekday: "dddd",
          weekdayShort: "ddd",
          minutes: "mm",
          hours12h: "hh",
          hours24h: "HH",
          seconds: "ss",
          fullTime: "LT",
          fullTime12h: "hh:mm A",
          fullTime24h: "HH:mm",
          fullDate: "ll",
          fullDateWithWeekday: "dddd, LL",
          fullDateTime: "lll",
          fullDateTime12h: "ll hh:mm A",
          fullDateTime24h: "ll HH:mm",
          keyboardDate: "L",
          keyboardDateTime: "L LT",
          keyboardDateTime12h: "L hh:mm A",
          keyboardDateTime24h: "L HH:mm"
        };
        var MomentUtils = /** @class */function () {
          function MomentUtils(_a) {
            var _this = this;
            var _b = _a === void 0 ? {} : _a,
              locale = _b.locale,
              formats = _b.formats,
              instance = _b.instance;
            this.lib = "moment";
            this.is12HourCycleInCurrentLocale = function () {
              return /A|a/.test(_this.moment.localeData(_this.getCurrentLocaleCode()).longDateFormat("LT"));
            };
            this.getFormatHelperText = function (format) {
              // @see https://github.com/moment/moment/blob/develop/src/lib/format/format.js#L6
              var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})|./g;
              return format.match(localFormattingTokens).map(function (token) {
                var firstCharacter = token[0];
                if (firstCharacter === "L" || firstCharacter === ";") {
                  return _this.moment.localeData(_this.getCurrentLocaleCode()).longDateFormat(token);
                }
                return token;
              }).join("").replace(/a/gi, "(a|p)m").toLocaleLowerCase();
            };
            this.getCurrentLocaleCode = function () {
              return _this.locale || _this.moment.locale();
            };
            this.parseISO = function (isoString) {
              return _this.moment(isoString, true);
            };
            this.toISO = function (value) {
              return value.toISOString();
            };
            this.parse = function (value, format) {
              if (value === "") {
                return null;
              }
              if (_this.locale) {
                return _this.moment(value, format, _this.locale, true);
              }
              return _this.moment(value, format, true);
            };
            this.date = function (value) {
              if (value === null) {
                return null;
              }
              var moment = _this.moment(value);
              moment.locale(_this.locale);
              return moment;
            };
            this.toJsDate = function (value) {
              return value.toDate();
            };
            this.isValid = function (value) {
              return _this.moment(value).isValid();
            };
            this.isNull = function (date) {
              return date === null;
            };
            this.getDiff = function (date, comparing, unit) {
              return date.diff(comparing, unit);
            };
            this.isAfter = function (date, value) {
              return date.isAfter(value);
            };
            this.isBefore = function (date, value) {
              return date.isBefore(value);
            };
            this.isAfterDay = function (date, value) {
              return date.isAfter(value, "day");
            };
            this.isBeforeDay = function (date, value) {
              return date.isBefore(value, "day");
            };
            this.isBeforeYear = function (date, value) {
              return date.isBefore(value, "year");
            };
            this.isAfterYear = function (date, value) {
              return date.isAfter(value, "year");
            };
            this.startOfDay = function (date) {
              return date.clone().startOf("day");
            };
            this.endOfDay = function (date) {
              return date.clone().endOf("day");
            };
            this.format = function (date, formatKey) {
              return _this.formatByString(date, _this.formats[formatKey]);
            };
            this.formatByString = function (date, formatString) {
              var clonedDate = date.clone();
              clonedDate.locale(_this.locale);
              return clonedDate.format(formatString);
            };
            this.formatNumber = function (numberToFormat) {
              return numberToFormat;
            };
            this.getHours = function (date) {
              return date.get("hours");
            };
            this.addSeconds = function (date, count) {
              return count < 0 ? date.clone().subtract(Math.abs(count), "seconds") : date.clone().add(count, "seconds");
            };
            this.addMinutes = function (date, count) {
              return count < 0 ? date.clone().subtract(Math.abs(count), "minutes") : date.clone().add(count, "minutes");
            };
            this.addHours = function (date, count) {
              return count < 0 ? date.clone().subtract(Math.abs(count), "hours") : date.clone().add(count, "hours");
            };
            this.addDays = function (date, count) {
              return count < 0 ? date.clone().subtract(Math.abs(count), "days") : date.clone().add(count, "days");
            };
            this.addWeeks = function (date, count) {
              return count < 0 ? date.clone().subtract(Math.abs(count), "weeks") : date.clone().add(count, "weeks");
            };
            this.addMonths = function (date, count) {
              return count < 0 ? date.clone().subtract(Math.abs(count), "months") : date.clone().add(count, "months");
            };
            this.addYears = function (date, count) {
              return count < 0 ? date.clone().subtract(Math.abs(count), "years") : date.clone().add(count, "years");
            };
            this.setHours = function (date, count) {
              return date.clone().hours(count);
            };
            this.getMinutes = function (date) {
              return date.get("minutes");
            };
            this.setMinutes = function (date, count) {
              return date.clone().minutes(count);
            };
            this.getSeconds = function (date) {
              return date.get("seconds");
            };
            this.setSeconds = function (date, count) {
              return date.clone().seconds(count);
            };
            this.getMonth = function (date) {
              return date.get("month");
            };
            this.getDaysInMonth = function (date) {
              return date.daysInMonth();
            };
            this.isSameDay = function (date, comparing) {
              return date.isSame(comparing, "day");
            };
            this.isSameMonth = function (date, comparing) {
              return date.isSame(comparing, "month");
            };
            this.isSameYear = function (date, comparing) {
              return date.isSame(comparing, "year");
            };
            this.isSameHour = function (date, comparing) {
              return date.isSame(comparing, "hour");
            };
            this.setMonth = function (date, count) {
              return date.clone().month(count);
            };
            this.getMeridiemText = function (ampm) {
              if (_this.is12HourCycleInCurrentLocale()) {
                // AM/PM translation only possible in those who have 12 hour cycle in locale.
                return _this.moment.localeData(_this.getCurrentLocaleCode()).meridiem(ampm === "am" ? 0 : 13, 0, false);
              }
              return ampm === "am" ? "AM" : "PM"; // fallback for de, ru, ...etc
            };

            this.startOfYear = function (date) {
              return date.clone().startOf("year");
            };
            this.endOfYear = function (date) {
              return date.clone().endOf("year");
            };
            this.startOfMonth = function (date) {
              return date.clone().startOf("month");
            };
            this.endOfMonth = function (date) {
              return date.clone().endOf("month");
            };
            this.startOfWeek = function (date) {
              return date.clone().startOf("week");
            };
            this.endOfWeek = function (date) {
              return date.clone().endOf("week");
            };
            this.getNextMonth = function (date) {
              return date.clone().add(1, "month");
            };
            this.getPreviousMonth = function (date) {
              return date.clone().subtract(1, "month");
            };
            this.getMonthArray = function (date) {
              var firstMonth = date.clone().startOf("year");
              var monthArray = [firstMonth];
              while (monthArray.length < 12) {
                var prevMonth = monthArray[monthArray.length - 1];
                monthArray.push(_this.getNextMonth(prevMonth));
              }
              return monthArray;
            };
            this.getYear = function (date) {
              return date.get("year");
            };
            this.setYear = function (date, year) {
              return date.clone().set("year", year);
            };
            this.getDate = function (date) {
              return date.get("date");
            };
            this.setDate = function (date, year) {
              return date.clone().set("date", year);
            };
            this.mergeDateAndTime = function (date, time) {
              return date.hour(time.hour()).minute(time.minute()).second(time.second());
            };
            this.getWeekdays = function () {
              return _this.moment.weekdaysShort(true);
            };
            this.isEqual = function (value, comparing) {
              if (value === null && comparing === null) {
                return true;
              }
              return _this.moment(value).isSame(comparing);
            };
            this.getWeekArray = function (date) {
              var start = date.clone().startOf("month").startOf("week");
              var end = date.clone().endOf("month").endOf("week");
              var count = 0;
              var current = start;
              var nestedWeeks = [];
              while (current.isBefore(end)) {
                var weekNumber = Math.floor(count / 7);
                nestedWeeks[weekNumber] = nestedWeeks[weekNumber] || [];
                nestedWeeks[weekNumber].push(current);
                current = current.clone().add(1, "day");
                count += 1;
              }
              return nestedWeeks;
            };
            this.getYearRange = function (start, end) {
              var startDate = _this.moment(start).startOf("year");
              var endDate = _this.moment(end).endOf("year");
              var years = [];
              var current = startDate;
              while (current.isBefore(endDate)) {
                years.push(current);
                current = current.clone().add(1, "year");
              }
              return years;
            };
            this.isWithinRange = function (date, _a) {
              var start = _a[0],
                end = _a[1];
              return date.isBetween(start, end, null, "[]");
            };
            this.moment = instance || hooks;
            this.locale = locale;
            this.formats = Object.assign({}, defaultFormats, formats);
          }
          return MomentUtils;
        }();
        const MuiTextWidget$1 = function (props) {
          var value = props.value,
            setValue = props.setValue;
          props.config;
          var readonly = props.readonly,
            placeholder = props.placeholder,
            customProps = props.customProps,
            maxLength = props.maxLength;
          var onChange = function onChange(e) {
            var val = e.target.value;
            if (val === "") val = undefined; // don't allow empty value
            setValue(val);
          };
          var textValue = value || "";
          return /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(TextField, _extends$h({
            variant: "standard",
            value: textValue,
            placeholder: !readonly ? placeholder : "",
            InputProps: {
              readOnly: readonly
            },
            inputProps: {
              maxLength: maxLength
            },
            disabled: readonly,
            onChange: onChange,
            size: "small"
          }, customProps)));
        };
        const MuiTextAreaWidget$1 = function (props) {
          var value = props.value,
            setValue = props.setValue,
            config = props.config,
            readonly = props.readonly,
            placeholder = props.placeholder,
            customProps = props.customProps,
            maxLength = props.maxLength,
            maxRows = props.maxRows,
            fullWidth = props.fullWidth;
          var defaultMaxRows = config.settings.defaultMaxRows;
          var onChange = function onChange(e) {
            var val = e.target.value;
            if (val === "") val = undefined; // don't allow empty value
            setValue(val);
          };
          var textValue = value || "";
          return /*#__PURE__*/React.createElement(FormControl, {
            fullWidth: fullWidth
          }, /*#__PURE__*/React.createElement(TextField, _extends$h({
            variant: "standard",
            fullWidth: fullWidth,
            maxRows: maxRows || defaultMaxRows,
            multiline: true,
            value: textValue,
            placeholder: !readonly ? placeholder : "",
            InputProps: {
              readOnly: readonly
            },
            inputProps: {
              maxLength: maxLength
            },
            disabled: readonly,
            onChange: onChange,
            size: "small"
          }, customProps)));
        };
        const MuiDateWidget$1 = function (props) {
          var value = props.value,
            setValue = props.setValue,
            readonly = props.readonly,
            customProps = props.customProps,
            dateFormat = props.dateFormat,
            valueFormat = props.valueFormat,
            placeholder = props.placeholder;
          var formatSingleValue = function formatSingleValue(value) {
            return value && value.isValid() ? value.format(valueFormat) : undefined;
          };
          var handleChange = function handleChange(value) {
            setValue(formatSingleValue(value));
          };
          var renderInput = function renderInput(params) {
            return /*#__PURE__*/React.createElement(TextField, _extends$h({
              size: "small",
              variant: "standard"
            }, params));
          };
          return /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(DatePicker, _extends$h({
            readOnly: readonly,
            disabled: readonly,
            toolbarPlaceholder: !readonly ? placeholder : "",
            inputFormat: dateFormat,
            value: value || null,
            onChange: handleChange,
            renderInput: renderInput
          }, customProps)));
        };
        const MuiDateTimeWidget$1 = function (props) {
          var value = props.value,
            setValue = props.setValue,
            use12Hours = props.use12Hours,
            readonly = props.readonly,
            placeholder = props.placeholder,
            dateFormat = props.dateFormat,
            timeFormat = props.timeFormat,
            valueFormat = props.valueFormat,
            customProps = props.customProps;
          var formatSingleValue = function formatSingleValue(value) {
            return value && value.isValid() ? value.format(valueFormat) : undefined;
          };
          var handleChange = function handleChange(value) {
            setValue(formatSingleValue(value));
          };
          var dateTimeFormat = dateFormat + " " + timeFormat;
          var renderInput = function renderInput(params) {
            return /*#__PURE__*/React.createElement(TextField, _extends$h({
              size: "small",
              variant: "standard"
            }, params));
          };
          return /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(DateTimePicker, _extends$h({
            readOnly: readonly,
            disabled: readonly,
            ampm: !!use12Hours,
            toolbarPlaceholder: !readonly ? placeholder : "",
            inputFormat: dateTimeFormat,
            value: value || null,
            onChange: handleChange,
            renderInput: renderInput
          }, customProps)));
        };
        var immutable = {
          exports: {}
        };

        /**
         * Copyright (c) 2014-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        (function (module, exports) {
          (function (global, factory) {
            module.exports = factory();
          })(commonjsGlobal, function () {
            var SLICE$0 = Array.prototype.slice;
            function createClass(ctor, superClass) {
              if (superClass) {
                ctor.prototype = Object.create(superClass.prototype);
              }
              ctor.prototype.constructor = ctor;
            }
            function Iterable(value) {
              return isIterable(value) ? value : Seq(value);
            }
            createClass(KeyedIterable, Iterable);
            function KeyedIterable(value) {
              return isKeyed(value) ? value : KeyedSeq(value);
            }
            createClass(IndexedIterable, Iterable);
            function IndexedIterable(value) {
              return isIndexed(value) ? value : IndexedSeq(value);
            }
            createClass(SetIterable, Iterable);
            function SetIterable(value) {
              return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
            }
            function isIterable(maybeIterable) {
              return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
            }
            function isKeyed(maybeKeyed) {
              return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
            }
            function isIndexed(maybeIndexed) {
              return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
            }
            function isAssociative(maybeAssociative) {
              return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
            }
            function isOrdered(maybeOrdered) {
              return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
            }
            Iterable.isIterable = isIterable;
            Iterable.isKeyed = isKeyed;
            Iterable.isIndexed = isIndexed;
            Iterable.isAssociative = isAssociative;
            Iterable.isOrdered = isOrdered;
            Iterable.Keyed = KeyedIterable;
            Iterable.Indexed = IndexedIterable;
            Iterable.Set = SetIterable;
            var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
            var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
            var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
            var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

            // Used for setting prototype methods that IE8 chokes on.
            var DELETE = 'delete';

            // Constants describing the size of trie nodes.
            var SHIFT = 5; // Resulted in best performance after ______?
            var SIZE = 1 << SHIFT;
            var MASK = SIZE - 1;

            // A consistent shared value representing "not set" which equals nothing other
            // than itself, and nothing that could be provided externally.
            var NOT_SET = {};

            // Boolean references, Rough equivalent of `bool &`.
            var CHANGE_LENGTH = {
              value: false
            };
            var DID_ALTER = {
              value: false
            };
            function MakeRef(ref) {
              ref.value = false;
              return ref;
            }
            function SetRef(ref) {
              ref && (ref.value = true);
            }

            // A function which returns a value representing an "owner" for transient writes
            // to tries. The return value will only ever equal itself, and will not equal
            // the return of any subsequent call of this function.
            function OwnerID() {}

            // http://jsperf.com/copy-array-inline
            function arrCopy(arr, offset) {
              offset = offset || 0;
              var len = Math.max(0, arr.length - offset);
              var newArr = new Array(len);
              for (var ii = 0; ii < len; ii++) {
                newArr[ii] = arr[ii + offset];
              }
              return newArr;
            }
            function ensureSize(iter) {
              if (iter.size === undefined) {
                iter.size = iter.__iterate(returnTrue);
              }
              return iter.size;
            }
            function wrapIndex(iter, index) {
              // This implements "is array index" which the ECMAString spec defines as:
              //
              //     A String property name P is an array index if and only if
              //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
              //     to 2^32−1.
              //
              // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
              if (typeof index !== 'number') {
                var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
                if ('' + uint32Index !== index || uint32Index === 4294967295) {
                  return NaN;
                }
                index = uint32Index;
              }
              return index < 0 ? ensureSize(iter) + index : index;
            }
            function returnTrue() {
              return true;
            }
            function wholeSlice(begin, end, size) {
              return (begin === 0 || size !== undefined && begin <= -size) && (end === undefined || size !== undefined && end >= size);
            }
            function resolveBegin(begin, size) {
              return resolveIndex(begin, size, 0);
            }
            function resolveEnd(end, size) {
              return resolveIndex(end, size, size);
            }
            function resolveIndex(index, size, defaultIndex) {
              return index === undefined ? defaultIndex : index < 0 ? Math.max(0, size + index) : size === undefined ? index : Math.min(size, index);
            }

            /* global Symbol */

            var ITERATE_KEYS = 0;
            var ITERATE_VALUES = 1;
            var ITERATE_ENTRIES = 2;
            var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
            var FAUX_ITERATOR_SYMBOL = '@@iterator';
            var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
            function Iterator(next) {
              this.next = next;
            }
            Iterator.prototype.toString = function () {
              return '[Iterator]';
            };
            Iterator.KEYS = ITERATE_KEYS;
            Iterator.VALUES = ITERATE_VALUES;
            Iterator.ENTRIES = ITERATE_ENTRIES;
            Iterator.prototype.inspect = Iterator.prototype.toSource = function () {
              return this.toString();
            };
            Iterator.prototype[ITERATOR_SYMBOL] = function () {
              return this;
            };
            function iteratorValue(type, k, v, iteratorResult) {
              var value = type === 0 ? k : type === 1 ? v : [k, v];
              iteratorResult ? iteratorResult.value = value : iteratorResult = {
                value: value,
                done: false
              };
              return iteratorResult;
            }
            function iteratorDone() {
              return {
                value: undefined,
                done: true
              };
            }
            function hasIterator(maybeIterable) {
              return !!getIteratorFn(maybeIterable);
            }
            function isIterator(maybeIterator) {
              return maybeIterator && typeof maybeIterator.next === 'function';
            }
            function getIterator(iterable) {
              var iteratorFn = getIteratorFn(iterable);
              return iteratorFn && iteratorFn.call(iterable);
            }
            function getIteratorFn(iterable) {
              var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);
              if (typeof iteratorFn === 'function') {
                return iteratorFn;
              }
            }
            function isArrayLike(value) {
              return value && typeof value.length === 'number';
            }
            createClass(Seq, Iterable);
            function Seq(value) {
              return value === null || value === undefined ? emptySequence() : isIterable(value) ? value.toSeq() : seqFromValue(value);
            }
            Seq.of = function /*...values*/
            () {
              return Seq(arguments);
            };
            Seq.prototype.toSeq = function () {
              return this;
            };
            Seq.prototype.toString = function () {
              return this.__toString('Seq {', '}');
            };
            Seq.prototype.cacheResult = function () {
              if (!this._cache && this.__iterateUncached) {
                this._cache = this.entrySeq().toArray();
                this.size = this._cache.length;
              }
              return this;
            };

            // abstract __iterateUncached(fn, reverse)

            Seq.prototype.__iterate = function (fn, reverse) {
              return seqIterate(this, fn, reverse, true);
            };

            // abstract __iteratorUncached(type, reverse)

            Seq.prototype.__iterator = function (type, reverse) {
              return seqIterator(this, type, reverse, true);
            };
            createClass(KeyedSeq, Seq);
            function KeyedSeq(value) {
              return value === null || value === undefined ? emptySequence().toKeyedSeq() : isIterable(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : keyedSeqFromValue(value);
            }
            KeyedSeq.prototype.toKeyedSeq = function () {
              return this;
            };
            createClass(IndexedSeq, Seq);
            function IndexedSeq(value) {
              return value === null || value === undefined ? emptySequence() : !isIterable(value) ? indexedSeqFromValue(value) : isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
            }
            IndexedSeq.of = function /*...values*/
            () {
              return IndexedSeq(arguments);
            };
            IndexedSeq.prototype.toIndexedSeq = function () {
              return this;
            };
            IndexedSeq.prototype.toString = function () {
              return this.__toString('Seq [', ']');
            };
            IndexedSeq.prototype.__iterate = function (fn, reverse) {
              return seqIterate(this, fn, reverse, false);
            };
            IndexedSeq.prototype.__iterator = function (type, reverse) {
              return seqIterator(this, type, reverse, false);
            };
            createClass(SetSeq, Seq);
            function SetSeq(value) {
              return (value === null || value === undefined ? emptySequence() : !isIterable(value) ? indexedSeqFromValue(value) : isKeyed(value) ? value.entrySeq() : value).toSetSeq();
            }
            SetSeq.of = function /*...values*/
            () {
              return SetSeq(arguments);
            };
            SetSeq.prototype.toSetSeq = function () {
              return this;
            };
            Seq.isSeq = isSeq;
            Seq.Keyed = KeyedSeq;
            Seq.Set = SetSeq;
            Seq.Indexed = IndexedSeq;
            var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';
            Seq.prototype[IS_SEQ_SENTINEL] = true;
            createClass(ArraySeq, IndexedSeq);
            function ArraySeq(array) {
              this._array = array;
              this.size = array.length;
            }
            ArraySeq.prototype.get = function (index, notSetValue) {
              return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
            };
            ArraySeq.prototype.__iterate = function (fn, reverse) {
              var array = this._array;
              var maxIndex = array.length - 1;
              for (var ii = 0; ii <= maxIndex; ii++) {
                if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
                  return ii + 1;
                }
              }
              return ii;
            };
            ArraySeq.prototype.__iterator = function (type, reverse) {
              var array = this._array;
              var maxIndex = array.length - 1;
              var ii = 0;
              return new Iterator(function () {
                return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++]);
              });
            };
            createClass(ObjectSeq, KeyedSeq);
            function ObjectSeq(object) {
              var keys = Object.keys(object);
              this._object = object;
              this._keys = keys;
              this.size = keys.length;
            }
            ObjectSeq.prototype.get = function (key, notSetValue) {
              if (notSetValue !== undefined && !this.has(key)) {
                return notSetValue;
              }
              return this._object[key];
            };
            ObjectSeq.prototype.has = function (key) {
              return this._object.hasOwnProperty(key);
            };
            ObjectSeq.prototype.__iterate = function (fn, reverse) {
              var object = this._object;
              var keys = this._keys;
              var maxIndex = keys.length - 1;
              for (var ii = 0; ii <= maxIndex; ii++) {
                var key = keys[reverse ? maxIndex - ii : ii];
                if (fn(object[key], key, this) === false) {
                  return ii + 1;
                }
              }
              return ii;
            };
            ObjectSeq.prototype.__iterator = function (type, reverse) {
              var object = this._object;
              var keys = this._keys;
              var maxIndex = keys.length - 1;
              var ii = 0;
              return new Iterator(function () {
                var key = keys[reverse ? maxIndex - ii : ii];
                return ii++ > maxIndex ? iteratorDone() : iteratorValue(type, key, object[key]);
              });
            };
            ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;
            createClass(IterableSeq, IndexedSeq);
            function IterableSeq(iterable) {
              this._iterable = iterable;
              this.size = iterable.length || iterable.size;
            }
            IterableSeq.prototype.__iterateUncached = function (fn, reverse) {
              if (reverse) {
                return this.cacheResult().__iterate(fn, reverse);
              }
              var iterable = this._iterable;
              var iterator = getIterator(iterable);
              var iterations = 0;
              if (isIterator(iterator)) {
                var step;
                while (!(step = iterator.next()).done) {
                  if (fn(step.value, iterations++, this) === false) {
                    break;
                  }
                }
              }
              return iterations;
            };
            IterableSeq.prototype.__iteratorUncached = function (type, reverse) {
              if (reverse) {
                return this.cacheResult().__iterator(type, reverse);
              }
              var iterable = this._iterable;
              var iterator = getIterator(iterable);
              if (!isIterator(iterator)) {
                return new Iterator(iteratorDone);
              }
              var iterations = 0;
              return new Iterator(function () {
                var step = iterator.next();
                return step.done ? step : iteratorValue(type, iterations++, step.value);
              });
            };
            createClass(IteratorSeq, IndexedSeq);
            function IteratorSeq(iterator) {
              this._iterator = iterator;
              this._iteratorCache = [];
            }
            IteratorSeq.prototype.__iterateUncached = function (fn, reverse) {
              if (reverse) {
                return this.cacheResult().__iterate(fn, reverse);
              }
              var iterator = this._iterator;
              var cache = this._iteratorCache;
              var iterations = 0;
              while (iterations < cache.length) {
                if (fn(cache[iterations], iterations++, this) === false) {
                  return iterations;
                }
              }
              var step;
              while (!(step = iterator.next()).done) {
                var val = step.value;
                cache[iterations] = val;
                if (fn(val, iterations++, this) === false) {
                  break;
                }
              }
              return iterations;
            };
            IteratorSeq.prototype.__iteratorUncached = function (type, reverse) {
              if (reverse) {
                return this.cacheResult().__iterator(type, reverse);
              }
              var iterator = this._iterator;
              var cache = this._iteratorCache;
              var iterations = 0;
              return new Iterator(function () {
                if (iterations >= cache.length) {
                  var step = iterator.next();
                  if (step.done) {
                    return step;
                  }
                  cache[iterations] = step.value;
                }
                return iteratorValue(type, iterations, cache[iterations++]);
              });
            };

            // # pragma Helper functions

            function isSeq(maybeSeq) {
              return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
            }
            var EMPTY_SEQ;
            function emptySequence() {
              return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
            }
            function keyedSeqFromValue(value) {
              var seq = Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() : isIterator(value) ? new IteratorSeq(value).fromEntrySeq() : hasIterator(value) ? new IterableSeq(value).fromEntrySeq() : typeof value === 'object' ? new ObjectSeq(value) : undefined;
              if (!seq) {
                throw new TypeError('Expected Array or iterable object of [k, v] entries, ' + 'or keyed object: ' + value);
              }
              return seq;
            }
            function indexedSeqFromValue(value) {
              var seq = maybeIndexedSeqFromValue(value);
              if (!seq) {
                throw new TypeError('Expected Array or iterable object of values: ' + value);
              }
              return seq;
            }
            function seqFromValue(value) {
              var seq = maybeIndexedSeqFromValue(value) || typeof value === 'object' && new ObjectSeq(value);
              if (!seq) {
                throw new TypeError('Expected Array or iterable object of values, or keyed object: ' + value);
              }
              return seq;
            }
            function maybeIndexedSeqFromValue(value) {
              return isArrayLike(value) ? new ArraySeq(value) : isIterator(value) ? new IteratorSeq(value) : hasIterator(value) ? new IterableSeq(value) : undefined;
            }
            function seqIterate(seq, fn, reverse, useKeys) {
              var cache = seq._cache;
              if (cache) {
                var maxIndex = cache.length - 1;
                for (var ii = 0; ii <= maxIndex; ii++) {
                  var entry = cache[reverse ? maxIndex - ii : ii];
                  if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
                    return ii + 1;
                  }
                }
                return ii;
              }
              return seq.__iterateUncached(fn, reverse);
            }
            function seqIterator(seq, type, reverse, useKeys) {
              var cache = seq._cache;
              if (cache) {
                var maxIndex = cache.length - 1;
                var ii = 0;
                return new Iterator(function () {
                  var entry = cache[reverse ? maxIndex - ii : ii];
                  return ii++ > maxIndex ? iteratorDone() : iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
                });
              }
              return seq.__iteratorUncached(type, reverse);
            }
            function fromJS(json, converter) {
              return converter ? fromJSWith(converter, json, '', {
                '': json
              }) : fromJSDefault(json);
            }
            function fromJSWith(converter, json, key, parentJSON) {
              if (Array.isArray(json)) {
                return converter.call(parentJSON, key, IndexedSeq(json).map(function (v, k) {
                  return fromJSWith(converter, v, k, json);
                }));
              }
              if (isPlainObj(json)) {
                return converter.call(parentJSON, key, KeyedSeq(json).map(function (v, k) {
                  return fromJSWith(converter, v, k, json);
                }));
              }
              return json;
            }
            function fromJSDefault(json) {
              if (Array.isArray(json)) {
                return IndexedSeq(json).map(fromJSDefault).toList();
              }
              if (isPlainObj(json)) {
                return KeyedSeq(json).map(fromJSDefault).toMap();
              }
              return json;
            }
            function isPlainObj(value) {
              return value && (value.constructor === Object || value.constructor === undefined);
            }

            /**
             * An extension of the "same-value" algorithm as [described for use by ES6 Map
             * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
             *
             * NaN is considered the same as NaN, however -0 and 0 are considered the same
             * value, which is different from the algorithm described by
             * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
             *
             * This is extended further to allow Objects to describe the values they
             * represent, by way of `valueOf` or `equals` (and `hashCode`).
             *
             * Note: because of this extension, the key equality of Immutable.Map and the
             * value equality of Immutable.Set will differ from ES6 Map and Set.
             *
             * ### Defining custom values
             *
             * The easiest way to describe the value an object represents is by implementing
             * `valueOf`. For example, `Date` represents a value by returning a unix
             * timestamp for `valueOf`:
             *
             *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
             *     var date2 = new Date(1234567890000);
             *     date1.valueOf(); // 1234567890000
             *     assert( date1 !== date2 );
             *     assert( Immutable.is( date1, date2 ) );
             *
             * Note: overriding `valueOf` may have other implications if you use this object
             * where JavaScript expects a primitive, such as implicit string coercion.
             *
             * For more complex types, especially collections, implementing `valueOf` may
             * not be performant. An alternative is to implement `equals` and `hashCode`.
             *
             * `equals` takes another object, presumably of similar type, and returns true
             * if the it is equal. Equality is symmetrical, so the same result should be
             * returned if this and the argument are flipped.
             *
             *     assert( a.equals(b) === b.equals(a) );
             *
             * `hashCode` returns a 32bit integer number representing the object which will
             * be used to determine how to store the value object in a Map or Set. You must
             * provide both or neither methods, one must not exist without the other.
             *
             * Also, an important relationship between these methods must be upheld: if two
             * values are equal, they *must* return the same hashCode. If the values are not
             * equal, they might have the same hashCode; this is called a hash collision,
             * and while undesirable for performance reasons, it is acceptable.
             *
             *     if (a.equals(b)) {
             *       assert( a.hashCode() === b.hashCode() );
             *     }
             *
             * All Immutable collections implement `equals` and `hashCode`.
             *
             */
            function is(valueA, valueB) {
              if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
                return true;
              }
              if (!valueA || !valueB) {
                return false;
              }
              if (typeof valueA.valueOf === 'function' && typeof valueB.valueOf === 'function') {
                valueA = valueA.valueOf();
                valueB = valueB.valueOf();
                if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
                  return true;
                }
                if (!valueA || !valueB) {
                  return false;
                }
              }
              if (typeof valueA.equals === 'function' && typeof valueB.equals === 'function' && valueA.equals(valueB)) {
                return true;
              }
              return false;
            }
            function deepEqual(a, b) {
              if (a === b) {
                return true;
              }
              if (!isIterable(b) || a.size !== undefined && b.size !== undefined && a.size !== b.size || a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) {
                return false;
              }
              if (a.size === 0 && b.size === 0) {
                return true;
              }
              var notAssociative = !isAssociative(a);
              if (isOrdered(a)) {
                var entries = a.entries();
                return b.every(function (v, k) {
                  var entry = entries.next().value;
                  return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
                }) && entries.next().done;
              }
              var flipped = false;
              if (a.size === undefined) {
                if (b.size === undefined) {
                  if (typeof a.cacheResult === 'function') {
                    a.cacheResult();
                  }
                } else {
                  flipped = true;
                  var _ = a;
                  a = b;
                  b = _;
                }
              }
              var allEqual = true;
              var bSize = b.__iterate(function (v, k) {
                if (notAssociative ? !a.has(v) : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
                  allEqual = false;
                  return false;
                }
              });
              return allEqual && a.size === bSize;
            }
            createClass(Repeat, IndexedSeq);
            function Repeat(value, times) {
              if (!(this instanceof Repeat)) {
                return new Repeat(value, times);
              }
              this._value = value;
              this.size = times === undefined ? Infinity : Math.max(0, times);
              if (this.size === 0) {
                if (EMPTY_REPEAT) {
                  return EMPTY_REPEAT;
                }
                EMPTY_REPEAT = this;
              }
            }
            Repeat.prototype.toString = function () {
              if (this.size === 0) {
                return 'Repeat []';
              }
              return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
            };
            Repeat.prototype.get = function (index, notSetValue) {
              return this.has(index) ? this._value : notSetValue;
            };
            Repeat.prototype.includes = function (searchValue) {
              return is(this._value, searchValue);
            };
            Repeat.prototype.slice = function (begin, end) {
              var size = this.size;
              return wholeSlice(begin, end, size) ? this : new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
            };
            Repeat.prototype.reverse = function () {
              return this;
            };
            Repeat.prototype.indexOf = function (searchValue) {
              if (is(this._value, searchValue)) {
                return 0;
              }
              return -1;
            };
            Repeat.prototype.lastIndexOf = function (searchValue) {
              if (is(this._value, searchValue)) {
                return this.size;
              }
              return -1;
            };
            Repeat.prototype.__iterate = function (fn, reverse) {
              for (var ii = 0; ii < this.size; ii++) {
                if (fn(this._value, ii, this) === false) {
                  return ii + 1;
                }
              }
              return ii;
            };
            Repeat.prototype.__iterator = function (type, reverse) {
              var this$0 = this;
              var ii = 0;
              return new Iterator(function () {
                return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone();
              });
            };
            Repeat.prototype.equals = function (other) {
              return other instanceof Repeat ? is(this._value, other._value) : deepEqual(other);
            };
            var EMPTY_REPEAT;
            function invariant(condition, error) {
              if (!condition) throw new Error(error);
            }
            createClass(Range, IndexedSeq);
            function Range(start, end, step) {
              if (!(this instanceof Range)) {
                return new Range(start, end, step);
              }
              invariant(step !== 0, 'Cannot step a Range by 0');
              start = start || 0;
              if (end === undefined) {
                end = Infinity;
              }
              step = step === undefined ? 1 : Math.abs(step);
              if (end < start) {
                step = -step;
              }
              this._start = start;
              this._end = end;
              this._step = step;
              this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
              if (this.size === 0) {
                if (EMPTY_RANGE) {
                  return EMPTY_RANGE;
                }
                EMPTY_RANGE = this;
              }
            }
            Range.prototype.toString = function () {
              if (this.size === 0) {
                return 'Range []';
              }
              return 'Range [ ' + this._start + '...' + this._end + (this._step !== 1 ? ' by ' + this._step : '') + ' ]';
            };
            Range.prototype.get = function (index, notSetValue) {
              return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;
            };
            Range.prototype.includes = function (searchValue) {
              var possibleIndex = (searchValue - this._start) / this._step;
              return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
            };
            Range.prototype.slice = function (begin, end) {
              if (wholeSlice(begin, end, this.size)) {
                return this;
              }
              begin = resolveBegin(begin, this.size);
              end = resolveEnd(end, this.size);
              if (end <= begin) {
                return new Range(0, 0);
              }
              return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
            };
            Range.prototype.indexOf = function (searchValue) {
              var offsetValue = searchValue - this._start;
              if (offsetValue % this._step === 0) {
                var index = offsetValue / this._step;
                if (index >= 0 && index < this.size) {
                  return index;
                }
              }
              return -1;
            };
            Range.prototype.lastIndexOf = function (searchValue) {
              return this.indexOf(searchValue);
            };
            Range.prototype.__iterate = function (fn, reverse) {
              var maxIndex = this.size - 1;
              var step = this._step;
              var value = reverse ? this._start + maxIndex * step : this._start;
              for (var ii = 0; ii <= maxIndex; ii++) {
                if (fn(value, ii, this) === false) {
                  return ii + 1;
                }
                value += reverse ? -step : step;
              }
              return ii;
            };
            Range.prototype.__iterator = function (type, reverse) {
              var maxIndex = this.size - 1;
              var step = this._step;
              var value = reverse ? this._start + maxIndex * step : this._start;
              var ii = 0;
              return new Iterator(function () {
                var v = value;
                value += reverse ? -step : step;
                return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
              });
            };
            Range.prototype.equals = function (other) {
              return other instanceof Range ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);
            };
            var EMPTY_RANGE;
            createClass(Collection, Iterable);
            function Collection() {
              throw TypeError('Abstract');
            }
            createClass(KeyedCollection, Collection);
            function KeyedCollection() {}
            createClass(IndexedCollection, Collection);
            function IndexedCollection() {}
            createClass(SetCollection, Collection);
            function SetCollection() {}
            Collection.Keyed = KeyedCollection;
            Collection.Indexed = IndexedCollection;
            Collection.Set = SetCollection;
            var imul = typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ? Math.imul : function imul(a, b) {
              a = a | 0; // int
              b = b | 0; // int
              var c = a & 0xffff;
              var d = b & 0xffff;
              // Shift by 0 fixes the sign on the high part.
              return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0; // int
            };

            // v8 has an optimization for storing 31-bit signed numbers.
            // Values which have either 00 or 11 as the high order bits qualify.
            // This function drops the highest order bit in a signed number, maintaining
            // the sign bit.
            function smi(i32) {
              return i32 >>> 1 & 0x40000000 | i32 & 0xBFFFFFFF;
            }
            function hash(o) {
              if (o === false || o === null || o === undefined) {
                return 0;
              }
              if (typeof o.valueOf === 'function') {
                o = o.valueOf();
                if (o === false || o === null || o === undefined) {
                  return 0;
                }
              }
              if (o === true) {
                return 1;
              }
              var type = typeof o;
              if (type === 'number') {
                if (o !== o || o === Infinity) {
                  return 0;
                }
                var h = o | 0;
                if (h !== o) {
                  h ^= o * 0xFFFFFFFF;
                }
                while (o > 0xFFFFFFFF) {
                  o /= 0xFFFFFFFF;
                  h ^= o;
                }
                return smi(h);
              }
              if (type === 'string') {
                return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
              }
              if (typeof o.hashCode === 'function') {
                return o.hashCode();
              }
              if (type === 'object') {
                return hashJSObj(o);
              }
              if (typeof o.toString === 'function') {
                return hashString(o.toString());
              }
              throw new Error('Value type ' + type + ' cannot be hashed.');
            }
            function cachedHashString(string) {
              var hash = stringHashCache[string];
              if (hash === undefined) {
                hash = hashString(string);
                if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
                  STRING_HASH_CACHE_SIZE = 0;
                  stringHashCache = {};
                }
                STRING_HASH_CACHE_SIZE++;
                stringHashCache[string] = hash;
              }
              return hash;
            }

            // http://jsperf.com/hashing-strings
            function hashString(string) {
              // This is the hash from JVM
              // The hash code for a string is computed as
              // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
              // where s[i] is the ith character of the string and n is the length of
              // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
              // (exclusive) by dropping high bits.
              var hash = 0;
              for (var ii = 0; ii < string.length; ii++) {
                hash = 31 * hash + string.charCodeAt(ii) | 0;
              }
              return smi(hash);
            }
            function hashJSObj(obj) {
              var hash;
              if (usingWeakMap) {
                hash = weakMap.get(obj);
                if (hash !== undefined) {
                  return hash;
                }
              }
              hash = obj[UID_HASH_KEY];
              if (hash !== undefined) {
                return hash;
              }
              if (!canDefineProperty) {
                hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
                if (hash !== undefined) {
                  return hash;
                }
                hash = getIENodeHash(obj);
                if (hash !== undefined) {
                  return hash;
                }
              }
              hash = ++objHashUID;
              if (objHashUID & 0x40000000) {
                objHashUID = 0;
              }
              if (usingWeakMap) {
                weakMap.set(obj, hash);
              } else if (isExtensible !== undefined && isExtensible(obj) === false) {
                throw new Error('Non-extensible objects are not allowed as keys.');
              } else if (canDefineProperty) {
                Object.defineProperty(obj, UID_HASH_KEY, {
                  'enumerable': false,
                  'configurable': false,
                  'writable': false,
                  'value': hash
                });
              } else if (obj.propertyIsEnumerable !== undefined && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
                // Since we can't define a non-enumerable property on the object
                // we'll hijack one of the less-used non-enumerable properties to
                // save our hash on it. Since this is a function it will not show up in
                // `JSON.stringify` which is what we want.
                obj.propertyIsEnumerable = function () {
                  return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
                };
                obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
              } else if (obj.nodeType !== undefined) {
                // At this point we couldn't get the IE `uniqueID` to use as a hash
                // and we couldn't use a non-enumerable property to exploit the
                // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
                // itself.
                obj[UID_HASH_KEY] = hash;
              } else {
                throw new Error('Unable to set a non-enumerable property on object.');
              }
              return hash;
            }

            // Get references to ES5 object methods.
            var isExtensible = Object.isExtensible;

            // True if Object.defineProperty works as expected. IE8 fails this test.
            var canDefineProperty = function () {
              try {
                Object.defineProperty({}, '@', {});
                return true;
              } catch (e) {
                return false;
              }
            }();

            // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
            // and avoid memory leaks from the IE cloneNode bug.
            function getIENodeHash(node) {
              if (node && node.nodeType > 0) {
                switch (node.nodeType) {
                  case 1:
                    // Element
                    return node.uniqueID;
                  case 9:
                    // Document
                    return node.documentElement && node.documentElement.uniqueID;
                }
              }
            }

            // If possible, use a WeakMap.
            var usingWeakMap = typeof WeakMap === 'function';
            var weakMap;
            if (usingWeakMap) {
              weakMap = new WeakMap();
            }
            var objHashUID = 0;
            var UID_HASH_KEY = '__immutablehash__';
            if (typeof Symbol === 'function') {
              UID_HASH_KEY = Symbol(UID_HASH_KEY);
            }
            var STRING_HASH_CACHE_MIN_STRLEN = 16;
            var STRING_HASH_CACHE_MAX_SIZE = 255;
            var STRING_HASH_CACHE_SIZE = 0;
            var stringHashCache = {};
            function assertNotInfinite(size) {
              invariant(size !== Infinity, 'Cannot perform this action with an infinite size.');
            }
            createClass(Map, KeyedCollection);

            // @pragma Construction

            function Map(value) {
              return value === null || value === undefined ? emptyMap() : isMap(value) && !isOrdered(value) ? value : emptyMap().withMutations(function (map) {
                var iter = KeyedIterable(value);
                assertNotInfinite(iter.size);
                iter.forEach(function (v, k) {
                  return map.set(k, v);
                });
              });
            }
            Map.of = function () {
              var keyValues = SLICE$0.call(arguments, 0);
              return emptyMap().withMutations(function (map) {
                for (var i = 0; i < keyValues.length; i += 2) {
                  if (i + 1 >= keyValues.length) {
                    throw new Error('Missing value for key: ' + keyValues[i]);
                  }
                  map.set(keyValues[i], keyValues[i + 1]);
                }
              });
            };
            Map.prototype.toString = function () {
              return this.__toString('Map {', '}');
            };

            // @pragma Access

            Map.prototype.get = function (k, notSetValue) {
              return this._root ? this._root.get(0, undefined, k, notSetValue) : notSetValue;
            };

            // @pragma Modification

            Map.prototype.set = function (k, v) {
              return updateMap(this, k, v);
            };
            Map.prototype.setIn = function (keyPath, v) {
              return this.updateIn(keyPath, NOT_SET, function () {
                return v;
              });
            };
            Map.prototype.remove = function (k) {
              return updateMap(this, k, NOT_SET);
            };
            Map.prototype.deleteIn = function (keyPath) {
              return this.updateIn(keyPath, function () {
                return NOT_SET;
              });
            };
            Map.prototype.update = function (k, notSetValue, updater) {
              return arguments.length === 1 ? k(this) : this.updateIn([k], notSetValue, updater);
            };
            Map.prototype.updateIn = function (keyPath, notSetValue, updater) {
              if (!updater) {
                updater = notSetValue;
                notSetValue = undefined;
              }
              var updatedValue = updateInDeepMap(this, forceIterator(keyPath), notSetValue, updater);
              return updatedValue === NOT_SET ? undefined : updatedValue;
            };
            Map.prototype.clear = function () {
              if (this.size === 0) {
                return this;
              }
              if (this.__ownerID) {
                this.size = 0;
                this._root = null;
                this.__hash = undefined;
                this.__altered = true;
                return this;
              }
              return emptyMap();
            };

            // @pragma Composition

            Map.prototype.merge = function /*...iters*/
            () {
              return mergeIntoMapWith(this, undefined, arguments);
            };
            Map.prototype.mergeWith = function (merger) {
              var iters = SLICE$0.call(arguments, 1);
              return mergeIntoMapWith(this, merger, iters);
            };
            Map.prototype.mergeIn = function (keyPath) {
              var iters = SLICE$0.call(arguments, 1);
              return this.updateIn(keyPath, emptyMap(), function (m) {
                return typeof m.merge === 'function' ? m.merge.apply(m, iters) : iters[iters.length - 1];
              });
            };
            Map.prototype.mergeDeep = function /*...iters*/
            () {
              return mergeIntoMapWith(this, deepMerger, arguments);
            };
            Map.prototype.mergeDeepWith = function (merger) {
              var iters = SLICE$0.call(arguments, 1);
              return mergeIntoMapWith(this, deepMergerWith(merger), iters);
            };
            Map.prototype.mergeDeepIn = function (keyPath) {
              var iters = SLICE$0.call(arguments, 1);
              return this.updateIn(keyPath, emptyMap(), function (m) {
                return typeof m.mergeDeep === 'function' ? m.mergeDeep.apply(m, iters) : iters[iters.length - 1];
              });
            };
            Map.prototype.sort = function (comparator) {
              // Late binding
              return OrderedMap(sortFactory(this, comparator));
            };
            Map.prototype.sortBy = function (mapper, comparator) {
              // Late binding
              return OrderedMap(sortFactory(this, comparator, mapper));
            };

            // @pragma Mutability

            Map.prototype.withMutations = function (fn) {
              var mutable = this.asMutable();
              fn(mutable);
              return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
            };
            Map.prototype.asMutable = function () {
              return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
            };
            Map.prototype.asImmutable = function () {
              return this.__ensureOwner();
            };
            Map.prototype.wasAltered = function () {
              return this.__altered;
            };
            Map.prototype.__iterator = function (type, reverse) {
              return new MapIterator(this, type, reverse);
            };
            Map.prototype.__iterate = function (fn, reverse) {
              var this$0 = this;
              var iterations = 0;
              this._root && this._root.iterate(function (entry) {
                iterations++;
                return fn(entry[1], entry[0], this$0);
              }, reverse);
              return iterations;
            };
            Map.prototype.__ensureOwner = function (ownerID) {
              if (ownerID === this.__ownerID) {
                return this;
              }
              if (!ownerID) {
                this.__ownerID = ownerID;
                this.__altered = false;
                return this;
              }
              return makeMap(this.size, this._root, ownerID, this.__hash);
            };
            function isMap(maybeMap) {
              return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
            }
            Map.isMap = isMap;
            var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';
            var MapPrototype = Map.prototype;
            MapPrototype[IS_MAP_SENTINEL] = true;
            MapPrototype[DELETE] = MapPrototype.remove;
            MapPrototype.removeIn = MapPrototype.deleteIn;

            // #pragma Trie Nodes

            function ArrayMapNode(ownerID, entries) {
              this.ownerID = ownerID;
              this.entries = entries;
            }
            ArrayMapNode.prototype.get = function (shift, keyHash, key, notSetValue) {
              var entries = this.entries;
              for (var ii = 0, len = entries.length; ii < len; ii++) {
                if (is(key, entries[ii][0])) {
                  return entries[ii][1];
                }
              }
              return notSetValue;
            };
            ArrayMapNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
              var removed = value === NOT_SET;
              var entries = this.entries;
              var idx = 0;
              for (var len = entries.length; idx < len; idx++) {
                if (is(key, entries[idx][0])) {
                  break;
                }
              }
              var exists = idx < len;
              if (exists ? entries[idx][1] === value : removed) {
                return this;
              }
              SetRef(didAlter);
              (removed || !exists) && SetRef(didChangeSize);
              if (removed && entries.length === 1) {
                return; // undefined
              }

              if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
                return createNodes(ownerID, entries, key, value);
              }
              var isEditable = ownerID && ownerID === this.ownerID;
              var newEntries = isEditable ? entries : arrCopy(entries);
              if (exists) {
                if (removed) {
                  idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
                } else {
                  newEntries[idx] = [key, value];
                }
              } else {
                newEntries.push([key, value]);
              }
              if (isEditable) {
                this.entries = newEntries;
                return this;
              }
              return new ArrayMapNode(ownerID, newEntries);
            };
            function BitmapIndexedNode(ownerID, bitmap, nodes) {
              this.ownerID = ownerID;
              this.bitmap = bitmap;
              this.nodes = nodes;
            }
            BitmapIndexedNode.prototype.get = function (shift, keyHash, key, notSetValue) {
              if (keyHash === undefined) {
                keyHash = hash(key);
              }
              var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
              var bitmap = this.bitmap;
              return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key, notSetValue);
            };
            BitmapIndexedNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
              if (keyHash === undefined) {
                keyHash = hash(key);
              }
              var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
              var bit = 1 << keyHashFrag;
              var bitmap = this.bitmap;
              var exists = (bitmap & bit) !== 0;
              if (!exists && value === NOT_SET) {
                return this;
              }
              var idx = popCount(bitmap & bit - 1);
              var nodes = this.nodes;
              var node = exists ? nodes[idx] : undefined;
              var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
              if (newNode === node) {
                return this;
              }
              if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
                return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
              }
              if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
                return nodes[idx ^ 1];
              }
              if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
                return newNode;
              }
              var isEditable = ownerID && ownerID === this.ownerID;
              var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
              var newNodes = exists ? newNode ? setIn(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
              if (isEditable) {
                this.bitmap = newBitmap;
                this.nodes = newNodes;
                return this;
              }
              return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
            };
            function HashArrayMapNode(ownerID, count, nodes) {
              this.ownerID = ownerID;
              this.count = count;
              this.nodes = nodes;
            }
            HashArrayMapNode.prototype.get = function (shift, keyHash, key, notSetValue) {
              if (keyHash === undefined) {
                keyHash = hash(key);
              }
              var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
              var node = this.nodes[idx];
              return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
            };
            HashArrayMapNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
              if (keyHash === undefined) {
                keyHash = hash(key);
              }
              var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
              var removed = value === NOT_SET;
              var nodes = this.nodes;
              var node = nodes[idx];
              if (removed && !node) {
                return this;
              }
              var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
              if (newNode === node) {
                return this;
              }
              var newCount = this.count;
              if (!node) {
                newCount++;
              } else if (!newNode) {
                newCount--;
                if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
                  return packNodes(ownerID, nodes, newCount, idx);
                }
              }
              var isEditable = ownerID && ownerID === this.ownerID;
              var newNodes = setIn(nodes, idx, newNode, isEditable);
              if (isEditable) {
                this.count = newCount;
                this.nodes = newNodes;
                return this;
              }
              return new HashArrayMapNode(ownerID, newCount, newNodes);
            };
            function HashCollisionNode(ownerID, keyHash, entries) {
              this.ownerID = ownerID;
              this.keyHash = keyHash;
              this.entries = entries;
            }
            HashCollisionNode.prototype.get = function (shift, keyHash, key, notSetValue) {
              var entries = this.entries;
              for (var ii = 0, len = entries.length; ii < len; ii++) {
                if (is(key, entries[ii][0])) {
                  return entries[ii][1];
                }
              }
              return notSetValue;
            };
            HashCollisionNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
              if (keyHash === undefined) {
                keyHash = hash(key);
              }
              var removed = value === NOT_SET;
              if (keyHash !== this.keyHash) {
                if (removed) {
                  return this;
                }
                SetRef(didAlter);
                SetRef(didChangeSize);
                return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
              }
              var entries = this.entries;
              var idx = 0;
              for (var len = entries.length; idx < len; idx++) {
                if (is(key, entries[idx][0])) {
                  break;
                }
              }
              var exists = idx < len;
              if (exists ? entries[idx][1] === value : removed) {
                return this;
              }
              SetRef(didAlter);
              (removed || !exists) && SetRef(didChangeSize);
              if (removed && len === 2) {
                return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
              }
              var isEditable = ownerID && ownerID === this.ownerID;
              var newEntries = isEditable ? entries : arrCopy(entries);
              if (exists) {
                if (removed) {
                  idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
                } else {
                  newEntries[idx] = [key, value];
                }
              } else {
                newEntries.push([key, value]);
              }
              if (isEditable) {
                this.entries = newEntries;
                return this;
              }
              return new HashCollisionNode(ownerID, this.keyHash, newEntries);
            };
            function ValueNode(ownerID, keyHash, entry) {
              this.ownerID = ownerID;
              this.keyHash = keyHash;
              this.entry = entry;
            }
            ValueNode.prototype.get = function (shift, keyHash, key, notSetValue) {
              return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
            };
            ValueNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
              var removed = value === NOT_SET;
              var keyMatch = is(key, this.entry[0]);
              if (keyMatch ? value === this.entry[1] : removed) {
                return this;
              }
              SetRef(didAlter);
              if (removed) {
                SetRef(didChangeSize);
                return; // undefined
              }

              if (keyMatch) {
                if (ownerID && ownerID === this.ownerID) {
                  this.entry[1] = value;
                  return this;
                }
                return new ValueNode(ownerID, this.keyHash, [key, value]);
              }
              SetRef(didChangeSize);
              return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
            };

            // #pragma Iterators

            ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function (fn, reverse) {
              var entries = this.entries;
              for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
                if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
                  return false;
                }
              }
            };
            BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function (fn, reverse) {
              var nodes = this.nodes;
              for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
                var node = nodes[reverse ? maxIndex - ii : ii];
                if (node && node.iterate(fn, reverse) === false) {
                  return false;
                }
              }
            };
            ValueNode.prototype.iterate = function (fn, reverse) {
              return fn(this.entry);
            };
            createClass(MapIterator, Iterator);
            function MapIterator(map, type, reverse) {
              this._type = type;
              this._reverse = reverse;
              this._stack = map._root && mapIteratorFrame(map._root);
            }
            MapIterator.prototype.next = function () {
              var type = this._type;
              var stack = this._stack;
              while (stack) {
                var node = stack.node;
                var index = stack.index++;
                var maxIndex;
                if (node.entry) {
                  if (index === 0) {
                    return mapIteratorValue(type, node.entry);
                  }
                } else if (node.entries) {
                  maxIndex = node.entries.length - 1;
                  if (index <= maxIndex) {
                    return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
                  }
                } else {
                  maxIndex = node.nodes.length - 1;
                  if (index <= maxIndex) {
                    var subNode = node.nodes[this._reverse ? maxIndex - index : index];
                    if (subNode) {
                      if (subNode.entry) {
                        return mapIteratorValue(type, subNode.entry);
                      }
                      stack = this._stack = mapIteratorFrame(subNode, stack);
                    }
                    continue;
                  }
                }
                stack = this._stack = this._stack.__prev;
              }
              return iteratorDone();
            };
            function mapIteratorValue(type, entry) {
              return iteratorValue(type, entry[0], entry[1]);
            }
            function mapIteratorFrame(node, prev) {
              return {
                node: node,
                index: 0,
                __prev: prev
              };
            }
            function makeMap(size, root, ownerID, hash) {
              var map = Object.create(MapPrototype);
              map.size = size;
              map._root = root;
              map.__ownerID = ownerID;
              map.__hash = hash;
              map.__altered = false;
              return map;
            }
            var EMPTY_MAP;
            function emptyMap() {
              return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
            }
            function updateMap(map, k, v) {
              var newRoot;
              var newSize;
              if (!map._root) {
                if (v === NOT_SET) {
                  return map;
                }
                newSize = 1;
                newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
              } else {
                var didChangeSize = MakeRef(CHANGE_LENGTH);
                var didAlter = MakeRef(DID_ALTER);
                newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
                if (!didAlter.value) {
                  return map;
                }
                newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
              }
              if (map.__ownerID) {
                map.size = newSize;
                map._root = newRoot;
                map.__hash = undefined;
                map.__altered = true;
                return map;
              }
              return newRoot ? makeMap(newSize, newRoot) : emptyMap();
            }
            function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
              if (!node) {
                if (value === NOT_SET) {
                  return node;
                }
                SetRef(didAlter);
                SetRef(didChangeSize);
                return new ValueNode(ownerID, keyHash, [key, value]);
              }
              return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
            }
            function isLeafNode(node) {
              return node.constructor === ValueNode || node.constructor === HashCollisionNode;
            }
            function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
              if (node.keyHash === keyHash) {
                return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
              }
              var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
              var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
              var newNode;
              var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);
              return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
            }
            function createNodes(ownerID, entries, key, value) {
              if (!ownerID) {
                ownerID = new OwnerID();
              }
              var node = new ValueNode(ownerID, hash(key), [key, value]);
              for (var ii = 0; ii < entries.length; ii++) {
                var entry = entries[ii];
                node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
              }
              return node;
            }
            function packNodes(ownerID, nodes, count, excluding) {
              var bitmap = 0;
              var packedII = 0;
              var packedNodes = new Array(count);
              for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
                var node = nodes[ii];
                if (node !== undefined && ii !== excluding) {
                  bitmap |= bit;
                  packedNodes[packedII++] = node;
                }
              }
              return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
            }
            function expandNodes(ownerID, nodes, bitmap, including, node) {
              var count = 0;
              var expandedNodes = new Array(SIZE);
              for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
                expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
              }
              expandedNodes[including] = node;
              return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
            }
            function mergeIntoMapWith(map, merger, iterables) {
              var iters = [];
              for (var ii = 0; ii < iterables.length; ii++) {
                var value = iterables[ii];
                var iter = KeyedIterable(value);
                if (!isIterable(value)) {
                  iter = iter.map(function (v) {
                    return fromJS(v);
                  });
                }
                iters.push(iter);
              }
              return mergeIntoCollectionWith(map, merger, iters);
            }
            function deepMerger(existing, value, key) {
              return existing && existing.mergeDeep && isIterable(value) ? existing.mergeDeep(value) : is(existing, value) ? existing : value;
            }
            function deepMergerWith(merger) {
              return function (existing, value, key) {
                if (existing && existing.mergeDeepWith && isIterable(value)) {
                  return existing.mergeDeepWith(merger, value);
                }
                var nextValue = merger(existing, value, key);
                return is(existing, nextValue) ? existing : nextValue;
              };
            }
            function mergeIntoCollectionWith(collection, merger, iters) {
              iters = iters.filter(function (x) {
                return x.size !== 0;
              });
              if (iters.length === 0) {
                return collection;
              }
              if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
                return collection.constructor(iters[0]);
              }
              return collection.withMutations(function (collection) {
                var mergeIntoMap = merger ? function (value, key) {
                  collection.update(key, NOT_SET, function (existing) {
                    return existing === NOT_SET ? value : merger(existing, value, key);
                  });
                } : function (value, key) {
                  collection.set(key, value);
                };
                for (var ii = 0; ii < iters.length; ii++) {
                  iters[ii].forEach(mergeIntoMap);
                }
              });
            }
            function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
              var isNotSet = existing === NOT_SET;
              var step = keyPathIter.next();
              if (step.done) {
                var existingValue = isNotSet ? notSetValue : existing;
                var newValue = updater(existingValue);
                return newValue === existingValue ? existing : newValue;
              }
              invariant(isNotSet || existing && existing.set, 'invalid keyPath');
              var key = step.value;
              var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
              var nextUpdated = updateInDeepMap(nextExisting, keyPathIter, notSetValue, updater);
              return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? existing.remove(key) : (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
            }
            function popCount(x) {
              x = x - (x >> 1 & 0x55555555);
              x = (x & 0x33333333) + (x >> 2 & 0x33333333);
              x = x + (x >> 4) & 0x0f0f0f0f;
              x = x + (x >> 8);
              x = x + (x >> 16);
              return x & 0x7f;
            }
            function setIn(array, idx, val, canEdit) {
              var newArray = canEdit ? array : arrCopy(array);
              newArray[idx] = val;
              return newArray;
            }
            function spliceIn(array, idx, val, canEdit) {
              var newLen = array.length + 1;
              if (canEdit && idx + 1 === newLen) {
                array[idx] = val;
                return array;
              }
              var newArray = new Array(newLen);
              var after = 0;
              for (var ii = 0; ii < newLen; ii++) {
                if (ii === idx) {
                  newArray[ii] = val;
                  after = -1;
                } else {
                  newArray[ii] = array[ii + after];
                }
              }
              return newArray;
            }
            function spliceOut(array, idx, canEdit) {
              var newLen = array.length - 1;
              if (canEdit && idx === newLen) {
                array.pop();
                return array;
              }
              var newArray = new Array(newLen);
              var after = 0;
              for (var ii = 0; ii < newLen; ii++) {
                if (ii === idx) {
                  after = 1;
                }
                newArray[ii] = array[ii + after];
              }
              return newArray;
            }
            var MAX_ARRAY_MAP_SIZE = SIZE / 4;
            var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
            var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
            createClass(List, IndexedCollection);

            // @pragma Construction

            function List(value) {
              var empty = emptyList();
              if (value === null || value === undefined) {
                return empty;
              }
              if (isList(value)) {
                return value;
              }
              var iter = IndexedIterable(value);
              var size = iter.size;
              if (size === 0) {
                return empty;
              }
              assertNotInfinite(size);
              if (size > 0 && size < SIZE) {
                return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
              }
              return empty.withMutations(function (list) {
                list.setSize(size);
                iter.forEach(function (v, i) {
                  return list.set(i, v);
                });
              });
            }
            List.of = function /*...values*/
            () {
              return this(arguments);
            };
            List.prototype.toString = function () {
              return this.__toString('List [', ']');
            };

            // @pragma Access

            List.prototype.get = function (index, notSetValue) {
              index = wrapIndex(this, index);
              if (index >= 0 && index < this.size) {
                index += this._origin;
                var node = listNodeFor(this, index);
                return node && node.array[index & MASK];
              }
              return notSetValue;
            };

            // @pragma Modification

            List.prototype.set = function (index, value) {
              return updateList(this, index, value);
            };
            List.prototype.remove = function (index) {
              return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);
            };
            List.prototype.insert = function (index, value) {
              return this.splice(index, 0, value);
            };
            List.prototype.clear = function () {
              if (this.size === 0) {
                return this;
              }
              if (this.__ownerID) {
                this.size = this._origin = this._capacity = 0;
                this._level = SHIFT;
                this._root = this._tail = null;
                this.__hash = undefined;
                this.__altered = true;
                return this;
              }
              return emptyList();
            };
            List.prototype.push = function /*...values*/
            () {
              var values = arguments;
              var oldSize = this.size;
              return this.withMutations(function (list) {
                setListBounds(list, 0, oldSize + values.length);
                for (var ii = 0; ii < values.length; ii++) {
                  list.set(oldSize + ii, values[ii]);
                }
              });
            };
            List.prototype.pop = function () {
              return setListBounds(this, 0, -1);
            };
            List.prototype.unshift = function /*...values*/
            () {
              var values = arguments;
              return this.withMutations(function (list) {
                setListBounds(list, -values.length);
                for (var ii = 0; ii < values.length; ii++) {
                  list.set(ii, values[ii]);
                }
              });
            };
            List.prototype.shift = function () {
              return setListBounds(this, 1);
            };

            // @pragma Composition

            List.prototype.merge = function /*...iters*/
            () {
              return mergeIntoListWith(this, undefined, arguments);
            };
            List.prototype.mergeWith = function (merger) {
              var iters = SLICE$0.call(arguments, 1);
              return mergeIntoListWith(this, merger, iters);
            };
            List.prototype.mergeDeep = function /*...iters*/
            () {
              return mergeIntoListWith(this, deepMerger, arguments);
            };
            List.prototype.mergeDeepWith = function (merger) {
              var iters = SLICE$0.call(arguments, 1);
              return mergeIntoListWith(this, deepMergerWith(merger), iters);
            };
            List.prototype.setSize = function (size) {
              return setListBounds(this, 0, size);
            };

            // @pragma Iteration

            List.prototype.slice = function (begin, end) {
              var size = this.size;
              if (wholeSlice(begin, end, size)) {
                return this;
              }
              return setListBounds(this, resolveBegin(begin, size), resolveEnd(end, size));
            };
            List.prototype.__iterator = function (type, reverse) {
              var index = 0;
              var values = iterateList(this, reverse);
              return new Iterator(function () {
                var value = values();
                return value === DONE ? iteratorDone() : iteratorValue(type, index++, value);
              });
            };
            List.prototype.__iterate = function (fn, reverse) {
              var index = 0;
              var values = iterateList(this, reverse);
              var value;
              while ((value = values()) !== DONE) {
                if (fn(value, index++, this) === false) {
                  break;
                }
              }
              return index;
            };
            List.prototype.__ensureOwner = function (ownerID) {
              if (ownerID === this.__ownerID) {
                return this;
              }
              if (!ownerID) {
                this.__ownerID = ownerID;
                return this;
              }
              return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
            };
            function isList(maybeList) {
              return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
            }
            List.isList = isList;
            var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';
            var ListPrototype = List.prototype;
            ListPrototype[IS_LIST_SENTINEL] = true;
            ListPrototype[DELETE] = ListPrototype.remove;
            ListPrototype.setIn = MapPrototype.setIn;
            ListPrototype.deleteIn = ListPrototype.removeIn = MapPrototype.removeIn;
            ListPrototype.update = MapPrototype.update;
            ListPrototype.updateIn = MapPrototype.updateIn;
            ListPrototype.mergeIn = MapPrototype.mergeIn;
            ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
            ListPrototype.withMutations = MapPrototype.withMutations;
            ListPrototype.asMutable = MapPrototype.asMutable;
            ListPrototype.asImmutable = MapPrototype.asImmutable;
            ListPrototype.wasAltered = MapPrototype.wasAltered;
            function VNode(array, ownerID) {
              this.array = array;
              this.ownerID = ownerID;
            }

            // TODO: seems like these methods are very similar

            VNode.prototype.removeBefore = function (ownerID, level, index) {
              if (index === level ? 1 << level : this.array.length === 0) {
                return this;
              }
              var originIndex = index >>> level & MASK;
              if (originIndex >= this.array.length) {
                return new VNode([], ownerID);
              }
              var removingFirst = originIndex === 0;
              var newChild;
              if (level > 0) {
                var oldChild = this.array[originIndex];
                newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
                if (newChild === oldChild && removingFirst) {
                  return this;
                }
              }
              if (removingFirst && !newChild) {
                return this;
              }
              var editable = editableVNode(this, ownerID);
              if (!removingFirst) {
                for (var ii = 0; ii < originIndex; ii++) {
                  editable.array[ii] = undefined;
                }
              }
              if (newChild) {
                editable.array[originIndex] = newChild;
              }
              return editable;
            };
            VNode.prototype.removeAfter = function (ownerID, level, index) {
              if (index === (level ? 1 << level : 0) || this.array.length === 0) {
                return this;
              }
              var sizeIndex = index - 1 >>> level & MASK;
              if (sizeIndex >= this.array.length) {
                return this;
              }
              var newChild;
              if (level > 0) {
                var oldChild = this.array[sizeIndex];
                newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
                if (newChild === oldChild && sizeIndex === this.array.length - 1) {
                  return this;
                }
              }
              var editable = editableVNode(this, ownerID);
              editable.array.splice(sizeIndex + 1);
              if (newChild) {
                editable.array[sizeIndex] = newChild;
              }
              return editable;
            };
            var DONE = {};
            function iterateList(list, reverse) {
              var left = list._origin;
              var right = list._capacity;
              var tailPos = getTailOffset(right);
              var tail = list._tail;
              return iterateNodeOrLeaf(list._root, list._level, 0);
              function iterateNodeOrLeaf(node, level, offset) {
                return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);
              }
              function iterateLeaf(node, offset) {
                var array = offset === tailPos ? tail && tail.array : node && node.array;
                var from = offset > left ? 0 : left - offset;
                var to = right - offset;
                if (to > SIZE) {
                  to = SIZE;
                }
                return function () {
                  if (from === to) {
                    return DONE;
                  }
                  var idx = reverse ? --to : from++;
                  return array && array[idx];
                };
              }
              function iterateNode(node, level, offset) {
                var values;
                var array = node && node.array;
                var from = offset > left ? 0 : left - offset >> level;
                var to = (right - offset >> level) + 1;
                if (to > SIZE) {
                  to = SIZE;
                }
                return function () {
                  do {
                    if (values) {
                      var value = values();
                      if (value !== DONE) {
                        return value;
                      }
                      values = null;
                    }
                    if (from === to) {
                      return DONE;
                    }
                    var idx = reverse ? --to : from++;
                    values = iterateNodeOrLeaf(array && array[idx], level - SHIFT, offset + (idx << level));
                  } while (true);
                };
              }
            }
            function makeList(origin, capacity, level, root, tail, ownerID, hash) {
              var list = Object.create(ListPrototype);
              list.size = capacity - origin;
              list._origin = origin;
              list._capacity = capacity;
              list._level = level;
              list._root = root;
              list._tail = tail;
              list.__ownerID = ownerID;
              list.__hash = hash;
              list.__altered = false;
              return list;
            }
            var EMPTY_LIST;
            function emptyList() {
              return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
            }
            function updateList(list, index, value) {
              index = wrapIndex(list, index);
              if (index !== index) {
                return list;
              }
              if (index >= list.size || index < 0) {
                return list.withMutations(function (list) {
                  index < 0 ? setListBounds(list, index).set(0, value) : setListBounds(list, 0, index + 1).set(index, value);
                });
              }
              index += list._origin;
              var newTail = list._tail;
              var newRoot = list._root;
              var didAlter = MakeRef(DID_ALTER);
              if (index >= getTailOffset(list._capacity)) {
                newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
              } else {
                newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
              }
              if (!didAlter.value) {
                return list;
              }
              if (list.__ownerID) {
                list._root = newRoot;
                list._tail = newTail;
                list.__hash = undefined;
                list.__altered = true;
                return list;
              }
              return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
            }
            function updateVNode(node, ownerID, level, index, value, didAlter) {
              var idx = index >>> level & MASK;
              var nodeHas = node && idx < node.array.length;
              if (!nodeHas && value === undefined) {
                return node;
              }
              var newNode;
              if (level > 0) {
                var lowerNode = node && node.array[idx];
                var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
                if (newLowerNode === lowerNode) {
                  return node;
                }
                newNode = editableVNode(node, ownerID);
                newNode.array[idx] = newLowerNode;
                return newNode;
              }
              if (nodeHas && node.array[idx] === value) {
                return node;
              }
              SetRef(didAlter);
              newNode = editableVNode(node, ownerID);
              if (value === undefined && idx === newNode.array.length - 1) {
                newNode.array.pop();
              } else {
                newNode.array[idx] = value;
              }
              return newNode;
            }
            function editableVNode(node, ownerID) {
              if (ownerID && node && ownerID === node.ownerID) {
                return node;
              }
              return new VNode(node ? node.array.slice() : [], ownerID);
            }
            function listNodeFor(list, rawIndex) {
              if (rawIndex >= getTailOffset(list._capacity)) {
                return list._tail;
              }
              if (rawIndex < 1 << list._level + SHIFT) {
                var node = list._root;
                var level = list._level;
                while (node && level > 0) {
                  node = node.array[rawIndex >>> level & MASK];
                  level -= SHIFT;
                }
                return node;
              }
            }
            function setListBounds(list, begin, end) {
              // Sanitize begin & end using this shorthand for ToInt32(argument)
              // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
              if (begin !== undefined) {
                begin = begin | 0;
              }
              if (end !== undefined) {
                end = end | 0;
              }
              var owner = list.__ownerID || new OwnerID();
              var oldOrigin = list._origin;
              var oldCapacity = list._capacity;
              var newOrigin = oldOrigin + begin;
              var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
              if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
                return list;
              }

              // If it's going to end after it starts, it's empty.
              if (newOrigin >= newCapacity) {
                return list.clear();
              }
              var newLevel = list._level;
              var newRoot = list._root;

              // New origin might need creating a higher root.
              var offsetShift = 0;
              while (newOrigin + offsetShift < 0) {
                newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
                newLevel += SHIFT;
                offsetShift += 1 << newLevel;
              }
              if (offsetShift) {
                newOrigin += offsetShift;
                oldOrigin += offsetShift;
                newCapacity += offsetShift;
                oldCapacity += offsetShift;
              }
              var oldTailOffset = getTailOffset(oldCapacity);
              var newTailOffset = getTailOffset(newCapacity);

              // New size might need creating a higher root.
              while (newTailOffset >= 1 << newLevel + SHIFT) {
                newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
                newLevel += SHIFT;
              }

              // Locate or create the new tail.
              var oldTail = list._tail;
              var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

              // Merge Tail into tree.
              if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
                newRoot = editableVNode(newRoot, owner);
                var node = newRoot;
                for (var level = newLevel; level > SHIFT; level -= SHIFT) {
                  var idx = oldTailOffset >>> level & MASK;
                  node = node.array[idx] = editableVNode(node.array[idx], owner);
                }
                node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
              }

              // If the size has been reduced, there's a chance the tail needs to be trimmed.
              if (newCapacity < oldCapacity) {
                newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
              }

              // If the new origin is within the tail, then we do not need a root.
              if (newOrigin >= newTailOffset) {
                newOrigin -= newTailOffset;
                newCapacity -= newTailOffset;
                newLevel = SHIFT;
                newRoot = null;
                newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

                // Otherwise, if the root has been trimmed, garbage collect.
              } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
                offsetShift = 0;

                // Identify the new top root node of the subtree of the old root.
                while (newRoot) {
                  var beginIndex = newOrigin >>> newLevel & MASK;
                  if (beginIndex !== newTailOffset >>> newLevel & MASK) {
                    break;
                  }
                  if (beginIndex) {
                    offsetShift += (1 << newLevel) * beginIndex;
                  }
                  newLevel -= SHIFT;
                  newRoot = newRoot.array[beginIndex];
                }

                // Trim the new sides of the new root.
                if (newRoot && newOrigin > oldOrigin) {
                  newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
                }
                if (newRoot && newTailOffset < oldTailOffset) {
                  newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
                }
                if (offsetShift) {
                  newOrigin -= offsetShift;
                  newCapacity -= offsetShift;
                }
              }
              if (list.__ownerID) {
                list.size = newCapacity - newOrigin;
                list._origin = newOrigin;
                list._capacity = newCapacity;
                list._level = newLevel;
                list._root = newRoot;
                list._tail = newTail;
                list.__hash = undefined;
                list.__altered = true;
                return list;
              }
              return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
            }
            function mergeIntoListWith(list, merger, iterables) {
              var iters = [];
              var maxSize = 0;
              for (var ii = 0; ii < iterables.length; ii++) {
                var value = iterables[ii];
                var iter = IndexedIterable(value);
                if (iter.size > maxSize) {
                  maxSize = iter.size;
                }
                if (!isIterable(value)) {
                  iter = iter.map(function (v) {
                    return fromJS(v);
                  });
                }
                iters.push(iter);
              }
              if (maxSize > list.size) {
                list = list.setSize(maxSize);
              }
              return mergeIntoCollectionWith(list, merger, iters);
            }
            function getTailOffset(size) {
              return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;
            }
            createClass(OrderedMap, Map);

            // @pragma Construction

            function OrderedMap(value) {
              return value === null || value === undefined ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function (map) {
                var iter = KeyedIterable(value);
                assertNotInfinite(iter.size);
                iter.forEach(function (v, k) {
                  return map.set(k, v);
                });
              });
            }
            OrderedMap.of = function /*...values*/
            () {
              return this(arguments);
            };
            OrderedMap.prototype.toString = function () {
              return this.__toString('OrderedMap {', '}');
            };

            // @pragma Access

            OrderedMap.prototype.get = function (k, notSetValue) {
              var index = this._map.get(k);
              return index !== undefined ? this._list.get(index)[1] : notSetValue;
            };

            // @pragma Modification

            OrderedMap.prototype.clear = function () {
              if (this.size === 0) {
                return this;
              }
              if (this.__ownerID) {
                this.size = 0;
                this._map.clear();
                this._list.clear();
                return this;
              }
              return emptyOrderedMap();
            };
            OrderedMap.prototype.set = function (k, v) {
              return updateOrderedMap(this, k, v);
            };
            OrderedMap.prototype.remove = function (k) {
              return updateOrderedMap(this, k, NOT_SET);
            };
            OrderedMap.prototype.wasAltered = function () {
              return this._map.wasAltered() || this._list.wasAltered();
            };
            OrderedMap.prototype.__iterate = function (fn, reverse) {
              var this$0 = this;
              return this._list.__iterate(function (entry) {
                return entry && fn(entry[1], entry[0], this$0);
              }, reverse);
            };
            OrderedMap.prototype.__iterator = function (type, reverse) {
              return this._list.fromEntrySeq().__iterator(type, reverse);
            };
            OrderedMap.prototype.__ensureOwner = function (ownerID) {
              if (ownerID === this.__ownerID) {
                return this;
              }
              var newMap = this._map.__ensureOwner(ownerID);
              var newList = this._list.__ensureOwner(ownerID);
              if (!ownerID) {
                this.__ownerID = ownerID;
                this._map = newMap;
                this._list = newList;
                return this;
              }
              return makeOrderedMap(newMap, newList, ownerID, this.__hash);
            };
            function isOrderedMap(maybeOrderedMap) {
              return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
            }
            OrderedMap.isOrderedMap = isOrderedMap;
            OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
            OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
            function makeOrderedMap(map, list, ownerID, hash) {
              var omap = Object.create(OrderedMap.prototype);
              omap.size = map ? map.size : 0;
              omap._map = map;
              omap._list = list;
              omap.__ownerID = ownerID;
              omap.__hash = hash;
              return omap;
            }
            var EMPTY_ORDERED_MAP;
            function emptyOrderedMap() {
              return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
            }
            function updateOrderedMap(omap, k, v) {
              var map = omap._map;
              var list = omap._list;
              var i = map.get(k);
              var has = i !== undefined;
              var newMap;
              var newList;
              if (v === NOT_SET) {
                // removed
                if (!has) {
                  return omap;
                }
                if (list.size >= SIZE && list.size >= map.size * 2) {
                  newList = list.filter(function (entry, idx) {
                    return entry !== undefined && i !== idx;
                  });
                  newMap = newList.toKeyedSeq().map(function (entry) {
                    return entry[0];
                  }).flip().toMap();
                  if (omap.__ownerID) {
                    newMap.__ownerID = newList.__ownerID = omap.__ownerID;
                  }
                } else {
                  newMap = map.remove(k);
                  newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
                }
              } else {
                if (has) {
                  if (v === list.get(i)[1]) {
                    return omap;
                  }
                  newMap = map;
                  newList = list.set(i, [k, v]);
                } else {
                  newMap = map.set(k, list.size);
                  newList = list.set(list.size, [k, v]);
                }
              }
              if (omap.__ownerID) {
                omap.size = newMap.size;
                omap._map = newMap;
                omap._list = newList;
                omap.__hash = undefined;
                return omap;
              }
              return makeOrderedMap(newMap, newList);
            }
            createClass(ToKeyedSequence, KeyedSeq);
            function ToKeyedSequence(indexed, useKeys) {
              this._iter = indexed;
              this._useKeys = useKeys;
              this.size = indexed.size;
            }
            ToKeyedSequence.prototype.get = function (key, notSetValue) {
              return this._iter.get(key, notSetValue);
            };
            ToKeyedSequence.prototype.has = function (key) {
              return this._iter.has(key);
            };
            ToKeyedSequence.prototype.valueSeq = function () {
              return this._iter.valueSeq();
            };
            ToKeyedSequence.prototype.reverse = function () {
              var this$0 = this;
              var reversedSequence = reverseFactory(this, true);
              if (!this._useKeys) {
                reversedSequence.valueSeq = function () {
                  return this$0._iter.toSeq().reverse();
                };
              }
              return reversedSequence;
            };
            ToKeyedSequence.prototype.map = function (mapper, context) {
              var this$0 = this;
              var mappedSequence = mapFactory(this, mapper, context);
              if (!this._useKeys) {
                mappedSequence.valueSeq = function () {
                  return this$0._iter.toSeq().map(mapper, context);
                };
              }
              return mappedSequence;
            };
            ToKeyedSequence.prototype.__iterate = function (fn, reverse) {
              var this$0 = this;
              var ii;
              return this._iter.__iterate(this._useKeys ? function (v, k) {
                return fn(v, k, this$0);
              } : (ii = reverse ? resolveSize(this) : 0, function (v) {
                return fn(v, reverse ? --ii : ii++, this$0);
              }), reverse);
            };
            ToKeyedSequence.prototype.__iterator = function (type, reverse) {
              if (this._useKeys) {
                return this._iter.__iterator(type, reverse);
              }
              var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
              var ii = reverse ? resolveSize(this) : 0;
              return new Iterator(function () {
                var step = iterator.next();
                return step.done ? step : iteratorValue(type, reverse ? --ii : ii++, step.value, step);
              });
            };
            ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;
            createClass(ToIndexedSequence, IndexedSeq);
            function ToIndexedSequence(iter) {
              this._iter = iter;
              this.size = iter.size;
            }
            ToIndexedSequence.prototype.includes = function (value) {
              return this._iter.includes(value);
            };
            ToIndexedSequence.prototype.__iterate = function (fn, reverse) {
              var this$0 = this;
              var iterations = 0;
              return this._iter.__iterate(function (v) {
                return fn(v, iterations++, this$0);
              }, reverse);
            };
            ToIndexedSequence.prototype.__iterator = function (type, reverse) {
              var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
              var iterations = 0;
              return new Iterator(function () {
                var step = iterator.next();
                return step.done ? step : iteratorValue(type, iterations++, step.value, step);
              });
            };
            createClass(ToSetSequence, SetSeq);
            function ToSetSequence(iter) {
              this._iter = iter;
              this.size = iter.size;
            }
            ToSetSequence.prototype.has = function (key) {
              return this._iter.includes(key);
            };
            ToSetSequence.prototype.__iterate = function (fn, reverse) {
              var this$0 = this;
              return this._iter.__iterate(function (v) {
                return fn(v, v, this$0);
              }, reverse);
            };
            ToSetSequence.prototype.__iterator = function (type, reverse) {
              var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
              return new Iterator(function () {
                var step = iterator.next();
                return step.done ? step : iteratorValue(type, step.value, step.value, step);
              });
            };
            createClass(FromEntriesSequence, KeyedSeq);
            function FromEntriesSequence(entries) {
              this._iter = entries;
              this.size = entries.size;
            }
            FromEntriesSequence.prototype.entrySeq = function () {
              return this._iter.toSeq();
            };
            FromEntriesSequence.prototype.__iterate = function (fn, reverse) {
              var this$0 = this;
              return this._iter.__iterate(function (entry) {
                // Check if entry exists first so array access doesn't throw for holes
                // in the parent iteration.
                if (entry) {
                  validateEntry(entry);
                  var indexedIterable = isIterable(entry);
                  return fn(indexedIterable ? entry.get(1) : entry[1], indexedIterable ? entry.get(0) : entry[0], this$0);
                }
              }, reverse);
            };
            FromEntriesSequence.prototype.__iterator = function (type, reverse) {
              var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
              return new Iterator(function () {
                while (true) {
                  var step = iterator.next();
                  if (step.done) {
                    return step;
                  }
                  var entry = step.value;
                  // Check if entry exists first so array access doesn't throw for holes
                  // in the parent iteration.
                  if (entry) {
                    validateEntry(entry);
                    var indexedIterable = isIterable(entry);
                    return iteratorValue(type, indexedIterable ? entry.get(0) : entry[0], indexedIterable ? entry.get(1) : entry[1], step);
                  }
                }
              });
            };
            ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;
            function flipFactory(iterable) {
              var flipSequence = makeSequence(iterable);
              flipSequence._iter = iterable;
              flipSequence.size = iterable.size;
              flipSequence.flip = function () {
                return iterable;
              };
              flipSequence.reverse = function () {
                var reversedSequence = iterable.reverse.apply(this); // super.reverse()
                reversedSequence.flip = function () {
                  return iterable.reverse();
                };
                return reversedSequence;
              };
              flipSequence.has = function (key) {
                return iterable.includes(key);
              };
              flipSequence.includes = function (key) {
                return iterable.has(key);
              };
              flipSequence.cacheResult = cacheResultThrough;
              flipSequence.__iterateUncached = function (fn, reverse) {
                var this$0 = this;
                return iterable.__iterate(function (v, k) {
                  return fn(k, v, this$0) !== false;
                }, reverse);
              };
              flipSequence.__iteratorUncached = function (type, reverse) {
                if (type === ITERATE_ENTRIES) {
                  var iterator = iterable.__iterator(type, reverse);
                  return new Iterator(function () {
                    var step = iterator.next();
                    if (!step.done) {
                      var k = step.value[0];
                      step.value[0] = step.value[1];
                      step.value[1] = k;
                    }
                    return step;
                  });
                }
                return iterable.__iterator(type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES, reverse);
              };
              return flipSequence;
            }
            function mapFactory(iterable, mapper, context) {
              var mappedSequence = makeSequence(iterable);
              mappedSequence.size = iterable.size;
              mappedSequence.has = function (key) {
                return iterable.has(key);
              };
              mappedSequence.get = function (key, notSetValue) {
                var v = iterable.get(key, NOT_SET);
                return v === NOT_SET ? notSetValue : mapper.call(context, v, key, iterable);
              };
              mappedSequence.__iterateUncached = function (fn, reverse) {
                var this$0 = this;
                return iterable.__iterate(function (v, k, c) {
                  return fn(mapper.call(context, v, k, c), k, this$0) !== false;
                }, reverse);
              };
              mappedSequence.__iteratorUncached = function (type, reverse) {
                var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
                return new Iterator(function () {
                  var step = iterator.next();
                  if (step.done) {
                    return step;
                  }
                  var entry = step.value;
                  var key = entry[0];
                  return iteratorValue(type, key, mapper.call(context, entry[1], key, iterable), step);
                });
              };
              return mappedSequence;
            }
            function reverseFactory(iterable, useKeys) {
              var reversedSequence = makeSequence(iterable);
              reversedSequence._iter = iterable;
              reversedSequence.size = iterable.size;
              reversedSequence.reverse = function () {
                return iterable;
              };
              if (iterable.flip) {
                reversedSequence.flip = function () {
                  var flipSequence = flipFactory(iterable);
                  flipSequence.reverse = function () {
                    return iterable.flip();
                  };
                  return flipSequence;
                };
              }
              reversedSequence.get = function (key, notSetValue) {
                return iterable.get(useKeys ? key : -1 - key, notSetValue);
              };
              reversedSequence.has = function (key) {
                return iterable.has(useKeys ? key : -1 - key);
              };
              reversedSequence.includes = function (value) {
                return iterable.includes(value);
              };
              reversedSequence.cacheResult = cacheResultThrough;
              reversedSequence.__iterate = function (fn, reverse) {
                var this$0 = this;
                return iterable.__iterate(function (v, k) {
                  return fn(v, k, this$0);
                }, !reverse);
              };
              reversedSequence.__iterator = function (type, reverse) {
                return iterable.__iterator(type, !reverse);
              };
              return reversedSequence;
            }
            function filterFactory(iterable, predicate, context, useKeys) {
              var filterSequence = makeSequence(iterable);
              if (useKeys) {
                filterSequence.has = function (key) {
                  var v = iterable.get(key, NOT_SET);
                  return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
                };
                filterSequence.get = function (key, notSetValue) {
                  var v = iterable.get(key, NOT_SET);
                  return v !== NOT_SET && predicate.call(context, v, key, iterable) ? v : notSetValue;
                };
              }
              filterSequence.__iterateUncached = function (fn, reverse) {
                var this$0 = this;
                var iterations = 0;
                iterable.__iterate(function (v, k, c) {
                  if (predicate.call(context, v, k, c)) {
                    iterations++;
                    return fn(v, useKeys ? k : iterations - 1, this$0);
                  }
                }, reverse);
                return iterations;
              };
              filterSequence.__iteratorUncached = function (type, reverse) {
                var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
                var iterations = 0;
                return new Iterator(function () {
                  while (true) {
                    var step = iterator.next();
                    if (step.done) {
                      return step;
                    }
                    var entry = step.value;
                    var key = entry[0];
                    var value = entry[1];
                    if (predicate.call(context, value, key, iterable)) {
                      return iteratorValue(type, useKeys ? key : iterations++, value, step);
                    }
                  }
                });
              };
              return filterSequence;
            }
            function countByFactory(iterable, grouper, context) {
              var groups = Map().asMutable();
              iterable.__iterate(function (v, k) {
                groups.update(grouper.call(context, v, k, iterable), 0, function (a) {
                  return a + 1;
                });
              });
              return groups.asImmutable();
            }
            function groupByFactory(iterable, grouper, context) {
              var isKeyedIter = isKeyed(iterable);
              var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
              iterable.__iterate(function (v, k) {
                groups.update(grouper.call(context, v, k, iterable), function (a) {
                  return a = a || [], a.push(isKeyedIter ? [k, v] : v), a;
                });
              });
              var coerce = iterableClass(iterable);
              return groups.map(function (arr) {
                return reify(iterable, coerce(arr));
              });
            }
            function sliceFactory(iterable, begin, end, useKeys) {
              var originalSize = iterable.size;

              // Sanitize begin & end using this shorthand for ToInt32(argument)
              // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
              if (begin !== undefined) {
                begin = begin | 0;
              }
              if (end !== undefined) {
                if (end === Infinity) {
                  end = originalSize;
                } else {
                  end = end | 0;
                }
              }
              if (wholeSlice(begin, end, originalSize)) {
                return iterable;
              }
              var resolvedBegin = resolveBegin(begin, originalSize);
              var resolvedEnd = resolveEnd(end, originalSize);

              // begin or end will be NaN if they were provided as negative numbers and
              // this iterable's size is unknown. In that case, cache first so there is
              // a known size and these do not resolve to NaN.
              if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
                return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
              }

              // Note: resolvedEnd is undefined when the original sequence's length is
              // unknown and this slice did not supply an end and should contain all
              // elements after resolvedBegin.
              // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
              var resolvedSize = resolvedEnd - resolvedBegin;
              var sliceSize;
              if (resolvedSize === resolvedSize) {
                sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
              }
              var sliceSeq = makeSequence(iterable);

              // If iterable.size is undefined, the size of the realized sliceSeq is
              // unknown at this point unless the number of items to slice is 0
              sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;
              if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
                sliceSeq.get = function (index, notSetValue) {
                  index = wrapIndex(this, index);
                  return index >= 0 && index < sliceSize ? iterable.get(index + resolvedBegin, notSetValue) : notSetValue;
                };
              }
              sliceSeq.__iterateUncached = function (fn, reverse) {
                var this$0 = this;
                if (sliceSize === 0) {
                  return 0;
                }
                if (reverse) {
                  return this.cacheResult().__iterate(fn, reverse);
                }
                var skipped = 0;
                var isSkipping = true;
                var iterations = 0;
                iterable.__iterate(function (v, k) {
                  if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
                    iterations++;
                    return fn(v, useKeys ? k : iterations - 1, this$0) !== false && iterations !== sliceSize;
                  }
                });
                return iterations;
              };
              sliceSeq.__iteratorUncached = function (type, reverse) {
                if (sliceSize !== 0 && reverse) {
                  return this.cacheResult().__iterator(type, reverse);
                }
                // Don't bother instantiating parent iterator if taking 0.
                var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
                var skipped = 0;
                var iterations = 0;
                return new Iterator(function () {
                  while (skipped++ < resolvedBegin) {
                    iterator.next();
                  }
                  if (++iterations > sliceSize) {
                    return iteratorDone();
                  }
                  var step = iterator.next();
                  if (useKeys || type === ITERATE_VALUES) {
                    return step;
                  } else if (type === ITERATE_KEYS) {
                    return iteratorValue(type, iterations - 1, undefined, step);
                  } else {
                    return iteratorValue(type, iterations - 1, step.value[1], step);
                  }
                });
              };
              return sliceSeq;
            }
            function takeWhileFactory(iterable, predicate, context) {
              var takeSequence = makeSequence(iterable);
              takeSequence.__iterateUncached = function (fn, reverse) {
                var this$0 = this;
                if (reverse) {
                  return this.cacheResult().__iterate(fn, reverse);
                }
                var iterations = 0;
                iterable.__iterate(function (v, k, c) {
                  return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0);
                });
                return iterations;
              };
              takeSequence.__iteratorUncached = function (type, reverse) {
                var this$0 = this;
                if (reverse) {
                  return this.cacheResult().__iterator(type, reverse);
                }
                var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
                var iterating = true;
                return new Iterator(function () {
                  if (!iterating) {
                    return iteratorDone();
                  }
                  var step = iterator.next();
                  if (step.done) {
                    return step;
                  }
                  var entry = step.value;
                  var k = entry[0];
                  var v = entry[1];
                  if (!predicate.call(context, v, k, this$0)) {
                    iterating = false;
                    return iteratorDone();
                  }
                  return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
                });
              };
              return takeSequence;
            }
            function skipWhileFactory(iterable, predicate, context, useKeys) {
              var skipSequence = makeSequence(iterable);
              skipSequence.__iterateUncached = function (fn, reverse) {
                var this$0 = this;
                if (reverse) {
                  return this.cacheResult().__iterate(fn, reverse);
                }
                var isSkipping = true;
                var iterations = 0;
                iterable.__iterate(function (v, k, c) {
                  if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
                    iterations++;
                    return fn(v, useKeys ? k : iterations - 1, this$0);
                  }
                });
                return iterations;
              };
              skipSequence.__iteratorUncached = function (type, reverse) {
                var this$0 = this;
                if (reverse) {
                  return this.cacheResult().__iterator(type, reverse);
                }
                var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
                var skipping = true;
                var iterations = 0;
                return new Iterator(function () {
                  var step, k, v;
                  do {
                    step = iterator.next();
                    if (step.done) {
                      if (useKeys || type === ITERATE_VALUES) {
                        return step;
                      } else if (type === ITERATE_KEYS) {
                        return iteratorValue(type, iterations++, undefined, step);
                      } else {
                        return iteratorValue(type, iterations++, step.value[1], step);
                      }
                    }
                    var entry = step.value;
                    k = entry[0];
                    v = entry[1];
                    skipping && (skipping = predicate.call(context, v, k, this$0));
                  } while (skipping);
                  return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
                });
              };
              return skipSequence;
            }
            function concatFactory(iterable, values) {
              var isKeyedIterable = isKeyed(iterable);
              var iters = [iterable].concat(values).map(function (v) {
                if (!isIterable(v)) {
                  v = isKeyedIterable ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
                } else if (isKeyedIterable) {
                  v = KeyedIterable(v);
                }
                return v;
              }).filter(function (v) {
                return v.size !== 0;
              });
              if (iters.length === 0) {
                return iterable;
              }
              if (iters.length === 1) {
                var singleton = iters[0];
                if (singleton === iterable || isKeyedIterable && isKeyed(singleton) || isIndexed(iterable) && isIndexed(singleton)) {
                  return singleton;
                }
              }
              var concatSeq = new ArraySeq(iters);
              if (isKeyedIterable) {
                concatSeq = concatSeq.toKeyedSeq();
              } else if (!isIndexed(iterable)) {
                concatSeq = concatSeq.toSetSeq();
              }
              concatSeq = concatSeq.flatten(true);
              concatSeq.size = iters.reduce(function (sum, seq) {
                if (sum !== undefined) {
                  var size = seq.size;
                  if (size !== undefined) {
                    return sum + size;
                  }
                }
              }, 0);
              return concatSeq;
            }
            function flattenFactory(iterable, depth, useKeys) {
              var flatSequence = makeSequence(iterable);
              flatSequence.__iterateUncached = function (fn, reverse) {
                var iterations = 0;
                var stopped = false;
                function flatDeep(iter, currentDepth) {
                  var this$0 = this;
                  iter.__iterate(function (v, k) {
                    if ((!depth || currentDepth < depth) && isIterable(v)) {
                      flatDeep(v, currentDepth + 1);
                    } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
                      stopped = true;
                    }
                    return !stopped;
                  }, reverse);
                }
                flatDeep(iterable, 0);
                return iterations;
              };
              flatSequence.__iteratorUncached = function (type, reverse) {
                var iterator = iterable.__iterator(type, reverse);
                var stack = [];
                var iterations = 0;
                return new Iterator(function () {
                  while (iterator) {
                    var step = iterator.next();
                    if (step.done !== false) {
                      iterator = stack.pop();
                      continue;
                    }
                    var v = step.value;
                    if (type === ITERATE_ENTRIES) {
                      v = v[1];
                    }
                    if ((!depth || stack.length < depth) && isIterable(v)) {
                      stack.push(iterator);
                      iterator = v.__iterator(type, reverse);
                    } else {
                      return useKeys ? step : iteratorValue(type, iterations++, v, step);
                    }
                  }
                  return iteratorDone();
                });
              };
              return flatSequence;
            }
            function flatMapFactory(iterable, mapper, context) {
              var coerce = iterableClass(iterable);
              return iterable.toSeq().map(function (v, k) {
                return coerce(mapper.call(context, v, k, iterable));
              }).flatten(true);
            }
            function interposeFactory(iterable, separator) {
              var interposedSequence = makeSequence(iterable);
              interposedSequence.size = iterable.size && iterable.size * 2 - 1;
              interposedSequence.__iterateUncached = function (fn, reverse) {
                var this$0 = this;
                var iterations = 0;
                iterable.__iterate(function (v, k) {
                  return (!iterations || fn(separator, iterations++, this$0) !== false) && fn(v, iterations++, this$0) !== false;
                }, reverse);
                return iterations;
              };
              interposedSequence.__iteratorUncached = function (type, reverse) {
                var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
                var iterations = 0;
                var step;
                return new Iterator(function () {
                  if (!step || iterations % 2) {
                    step = iterator.next();
                    if (step.done) {
                      return step;
                    }
                  }
                  return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);
                });
              };
              return interposedSequence;
            }
            function sortFactory(iterable, comparator, mapper) {
              if (!comparator) {
                comparator = defaultComparator;
              }
              var isKeyedIterable = isKeyed(iterable);
              var index = 0;
              var entries = iterable.toSeq().map(function (v, k) {
                return [k, v, index++, mapper ? mapper(v, k, iterable) : v];
              }).toArray();
              entries.sort(function (a, b) {
                return comparator(a[3], b[3]) || a[2] - b[2];
              }).forEach(isKeyedIterable ? function (v, i) {
                entries[i].length = 2;
              } : function (v, i) {
                entries[i] = v[1];
              });
              return isKeyedIterable ? KeyedSeq(entries) : isIndexed(iterable) ? IndexedSeq(entries) : SetSeq(entries);
            }
            function maxFactory(iterable, comparator, mapper) {
              if (!comparator) {
                comparator = defaultComparator;
              }
              if (mapper) {
                var entry = iterable.toSeq().map(function (v, k) {
                  return [v, mapper(v, k, iterable)];
                }).reduce(function (a, b) {
                  return maxCompare(comparator, a[1], b[1]) ? b : a;
                });
                return entry && entry[0];
              } else {
                return iterable.reduce(function (a, b) {
                  return maxCompare(comparator, a, b) ? b : a;
                });
              }
            }
            function maxCompare(comparator, a, b) {
              var comp = comparator(b, a);
              // b is considered the new max if the comparator declares them equal, but
              // they are not equal and b is in fact a nullish value.
              return comp === 0 && b !== a && (b === undefined || b === null || b !== b) || comp > 0;
            }
            function zipWithFactory(keyIter, zipper, iters) {
              var zipSequence = makeSequence(keyIter);
              zipSequence.size = new ArraySeq(iters).map(function (i) {
                return i.size;
              }).min();
              // Note: this a generic base implementation of __iterate in terms of
              // __iterator which may be more generically useful in the future.
              zipSequence.__iterate = function (fn, reverse) {
                /* generic:
                var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
                var step;
                var iterations = 0;
                while (!(step = iterator.next()).done) {
                  iterations++;
                  if (fn(step.value[1], step.value[0], this) === false) {
                    break;
                  }
                }
                return iterations;
                */
                // indexed:
                var iterator = this.__iterator(ITERATE_VALUES, reverse);
                var step;
                var iterations = 0;
                while (!(step = iterator.next()).done) {
                  if (fn(step.value, iterations++, this) === false) {
                    break;
                  }
                }
                return iterations;
              };
              zipSequence.__iteratorUncached = function (type, reverse) {
                var iterators = iters.map(function (i) {
                  return i = Iterable(i), getIterator(reverse ? i.reverse() : i);
                });
                var iterations = 0;
                var isDone = false;
                return new Iterator(function () {
                  var steps;
                  if (!isDone) {
                    steps = iterators.map(function (i) {
                      return i.next();
                    });
                    isDone = steps.some(function (s) {
                      return s.done;
                    });
                  }
                  if (isDone) {
                    return iteratorDone();
                  }
                  return iteratorValue(type, iterations++, zipper.apply(null, steps.map(function (s) {
                    return s.value;
                  })));
                });
              };
              return zipSequence;
            }

            // #pragma Helper Functions

            function reify(iter, seq) {
              return isSeq(iter) ? seq : iter.constructor(seq);
            }
            function validateEntry(entry) {
              if (entry !== Object(entry)) {
                throw new TypeError('Expected [K, V] tuple: ' + entry);
              }
            }
            function resolveSize(iter) {
              assertNotInfinite(iter.size);
              return ensureSize(iter);
            }
            function iterableClass(iterable) {
              return isKeyed(iterable) ? KeyedIterable : isIndexed(iterable) ? IndexedIterable : SetIterable;
            }
            function makeSequence(iterable) {
              return Object.create((isKeyed(iterable) ? KeyedSeq : isIndexed(iterable) ? IndexedSeq : SetSeq).prototype);
            }
            function cacheResultThrough() {
              if (this._iter.cacheResult) {
                this._iter.cacheResult();
                this.size = this._iter.size;
                return this;
              } else {
                return Seq.prototype.cacheResult.call(this);
              }
            }
            function defaultComparator(a, b) {
              return a > b ? 1 : a < b ? -1 : 0;
            }
            function forceIterator(keyPath) {
              var iter = getIterator(keyPath);
              if (!iter) {
                // Array might not be iterable in this environment, so we need a fallback
                // to our wrapped type.
                if (!isArrayLike(keyPath)) {
                  throw new TypeError('Expected iterable or array-like: ' + keyPath);
                }
                iter = getIterator(Iterable(keyPath));
              }
              return iter;
            }
            createClass(Record, KeyedCollection);
            function Record(defaultValues, name) {
              var hasInitialized;
              var RecordType = function Record(values) {
                if (values instanceof RecordType) {
                  return values;
                }
                if (!(this instanceof RecordType)) {
                  return new RecordType(values);
                }
                if (!hasInitialized) {
                  hasInitialized = true;
                  var keys = Object.keys(defaultValues);
                  setProps(RecordTypePrototype, keys);
                  RecordTypePrototype.size = keys.length;
                  RecordTypePrototype._name = name;
                  RecordTypePrototype._keys = keys;
                  RecordTypePrototype._defaultValues = defaultValues;
                }
                this._map = Map(values);
              };
              var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
              RecordTypePrototype.constructor = RecordType;
              return RecordType;
            }
            Record.prototype.toString = function () {
              return this.__toString(recordName(this) + ' {', '}');
            };

            // @pragma Access

            Record.prototype.has = function (k) {
              return this._defaultValues.hasOwnProperty(k);
            };
            Record.prototype.get = function (k, notSetValue) {
              if (!this.has(k)) {
                return notSetValue;
              }
              var defaultVal = this._defaultValues[k];
              return this._map ? this._map.get(k, defaultVal) : defaultVal;
            };

            // @pragma Modification

            Record.prototype.clear = function () {
              if (this.__ownerID) {
                this._map && this._map.clear();
                return this;
              }
              var RecordType = this.constructor;
              return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
            };
            Record.prototype.set = function (k, v) {
              if (!this.has(k)) {
                throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
              }
              if (this._map && !this._map.has(k)) {
                var defaultVal = this._defaultValues[k];
                if (v === defaultVal) {
                  return this;
                }
              }
              var newMap = this._map && this._map.set(k, v);
              if (this.__ownerID || newMap === this._map) {
                return this;
              }
              return makeRecord(this, newMap);
            };
            Record.prototype.remove = function (k) {
              if (!this.has(k)) {
                return this;
              }
              var newMap = this._map && this._map.remove(k);
              if (this.__ownerID || newMap === this._map) {
                return this;
              }
              return makeRecord(this, newMap);
            };
            Record.prototype.wasAltered = function () {
              return this._map.wasAltered();
            };
            Record.prototype.__iterator = function (type, reverse) {
              var this$0 = this;
              return KeyedIterable(this._defaultValues).map(function (_, k) {
                return this$0.get(k);
              }).__iterator(type, reverse);
            };
            Record.prototype.__iterate = function (fn, reverse) {
              var this$0 = this;
              return KeyedIterable(this._defaultValues).map(function (_, k) {
                return this$0.get(k);
              }).__iterate(fn, reverse);
            };
            Record.prototype.__ensureOwner = function (ownerID) {
              if (ownerID === this.__ownerID) {
                return this;
              }
              var newMap = this._map && this._map.__ensureOwner(ownerID);
              if (!ownerID) {
                this.__ownerID = ownerID;
                this._map = newMap;
                return this;
              }
              return makeRecord(this, newMap, ownerID);
            };
            var RecordPrototype = Record.prototype;
            RecordPrototype[DELETE] = RecordPrototype.remove;
            RecordPrototype.deleteIn = RecordPrototype.removeIn = MapPrototype.removeIn;
            RecordPrototype.merge = MapPrototype.merge;
            RecordPrototype.mergeWith = MapPrototype.mergeWith;
            RecordPrototype.mergeIn = MapPrototype.mergeIn;
            RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
            RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
            RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
            RecordPrototype.setIn = MapPrototype.setIn;
            RecordPrototype.update = MapPrototype.update;
            RecordPrototype.updateIn = MapPrototype.updateIn;
            RecordPrototype.withMutations = MapPrototype.withMutations;
            RecordPrototype.asMutable = MapPrototype.asMutable;
            RecordPrototype.asImmutable = MapPrototype.asImmutable;
            function makeRecord(likeRecord, map, ownerID) {
              var record = Object.create(Object.getPrototypeOf(likeRecord));
              record._map = map;
              record.__ownerID = ownerID;
              return record;
            }
            function recordName(record) {
              return record._name || record.constructor.name || 'Record';
            }
            function setProps(prototype, names) {
              try {
                names.forEach(setProp.bind(undefined, prototype));
              } catch (error) {
                // Object.defineProperty failed. Probably IE8.
              }
            }
            function setProp(prototype, name) {
              Object.defineProperty(prototype, name, {
                get: function () {
                  return this.get(name);
                },
                set: function (value) {
                  invariant(this.__ownerID, 'Cannot set on an immutable record.');
                  this.set(name, value);
                }
              });
            }
            createClass(Set, SetCollection);

            // @pragma Construction

            function Set(value) {
              return value === null || value === undefined ? emptySet() : isSet(value) && !isOrdered(value) ? value : emptySet().withMutations(function (set) {
                var iter = SetIterable(value);
                assertNotInfinite(iter.size);
                iter.forEach(function (v) {
                  return set.add(v);
                });
              });
            }
            Set.of = function /*...values*/
            () {
              return this(arguments);
            };
            Set.fromKeys = function (value) {
              return this(KeyedIterable(value).keySeq());
            };
            Set.prototype.toString = function () {
              return this.__toString('Set {', '}');
            };

            // @pragma Access

            Set.prototype.has = function (value) {
              return this._map.has(value);
            };

            // @pragma Modification

            Set.prototype.add = function (value) {
              return updateSet(this, this._map.set(value, true));
            };
            Set.prototype.remove = function (value) {
              return updateSet(this, this._map.remove(value));
            };
            Set.prototype.clear = function () {
              return updateSet(this, this._map.clear());
            };

            // @pragma Composition

            Set.prototype.union = function () {
              var iters = SLICE$0.call(arguments, 0);
              iters = iters.filter(function (x) {
                return x.size !== 0;
              });
              if (iters.length === 0) {
                return this;
              }
              if (this.size === 0 && !this.__ownerID && iters.length === 1) {
                return this.constructor(iters[0]);
              }
              return this.withMutations(function (set) {
                for (var ii = 0; ii < iters.length; ii++) {
                  SetIterable(iters[ii]).forEach(function (value) {
                    return set.add(value);
                  });
                }
              });
            };
            Set.prototype.intersect = function () {
              var iters = SLICE$0.call(arguments, 0);
              if (iters.length === 0) {
                return this;
              }
              iters = iters.map(function (iter) {
                return SetIterable(iter);
              });
              var originalSet = this;
              return this.withMutations(function (set) {
                originalSet.forEach(function (value) {
                  if (!iters.every(function (iter) {
                    return iter.includes(value);
                  })) {
                    set.remove(value);
                  }
                });
              });
            };
            Set.prototype.subtract = function () {
              var iters = SLICE$0.call(arguments, 0);
              if (iters.length === 0) {
                return this;
              }
              iters = iters.map(function (iter) {
                return SetIterable(iter);
              });
              var originalSet = this;
              return this.withMutations(function (set) {
                originalSet.forEach(function (value) {
                  if (iters.some(function (iter) {
                    return iter.includes(value);
                  })) {
                    set.remove(value);
                  }
                });
              });
            };
            Set.prototype.merge = function () {
              return this.union.apply(this, arguments);
            };
            Set.prototype.mergeWith = function (merger) {
              var iters = SLICE$0.call(arguments, 1);
              return this.union.apply(this, iters);
            };
            Set.prototype.sort = function (comparator) {
              // Late binding
              return OrderedSet(sortFactory(this, comparator));
            };
            Set.prototype.sortBy = function (mapper, comparator) {
              // Late binding
              return OrderedSet(sortFactory(this, comparator, mapper));
            };
            Set.prototype.wasAltered = function () {
              return this._map.wasAltered();
            };
            Set.prototype.__iterate = function (fn, reverse) {
              var this$0 = this;
              return this._map.__iterate(function (_, k) {
                return fn(k, k, this$0);
              }, reverse);
            };
            Set.prototype.__iterator = function (type, reverse) {
              return this._map.map(function (_, k) {
                return k;
              }).__iterator(type, reverse);
            };
            Set.prototype.__ensureOwner = function (ownerID) {
              if (ownerID === this.__ownerID) {
                return this;
              }
              var newMap = this._map.__ensureOwner(ownerID);
              if (!ownerID) {
                this.__ownerID = ownerID;
                this._map = newMap;
                return this;
              }
              return this.__make(newMap, ownerID);
            };
            function isSet(maybeSet) {
              return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
            }
            Set.isSet = isSet;
            var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';
            var SetPrototype = Set.prototype;
            SetPrototype[IS_SET_SENTINEL] = true;
            SetPrototype[DELETE] = SetPrototype.remove;
            SetPrototype.mergeDeep = SetPrototype.merge;
            SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
            SetPrototype.withMutations = MapPrototype.withMutations;
            SetPrototype.asMutable = MapPrototype.asMutable;
            SetPrototype.asImmutable = MapPrototype.asImmutable;
            SetPrototype.__empty = emptySet;
            SetPrototype.__make = makeSet;
            function updateSet(set, newMap) {
              if (set.__ownerID) {
                set.size = newMap.size;
                set._map = newMap;
                return set;
              }
              return newMap === set._map ? set : newMap.size === 0 ? set.__empty() : set.__make(newMap);
            }
            function makeSet(map, ownerID) {
              var set = Object.create(SetPrototype);
              set.size = map ? map.size : 0;
              set._map = map;
              set.__ownerID = ownerID;
              return set;
            }
            var EMPTY_SET;
            function emptySet() {
              return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
            }
            createClass(OrderedSet, Set);

            // @pragma Construction

            function OrderedSet(value) {
              return value === null || value === undefined ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function (set) {
                var iter = SetIterable(value);
                assertNotInfinite(iter.size);
                iter.forEach(function (v) {
                  return set.add(v);
                });
              });
            }
            OrderedSet.of = function /*...values*/
            () {
              return this(arguments);
            };
            OrderedSet.fromKeys = function (value) {
              return this(KeyedIterable(value).keySeq());
            };
            OrderedSet.prototype.toString = function () {
              return this.__toString('OrderedSet {', '}');
            };
            function isOrderedSet(maybeOrderedSet) {
              return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
            }
            OrderedSet.isOrderedSet = isOrderedSet;
            var OrderedSetPrototype = OrderedSet.prototype;
            OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;
            OrderedSetPrototype.__empty = emptyOrderedSet;
            OrderedSetPrototype.__make = makeOrderedSet;
            function makeOrderedSet(map, ownerID) {
              var set = Object.create(OrderedSetPrototype);
              set.size = map ? map.size : 0;
              set._map = map;
              set.__ownerID = ownerID;
              return set;
            }
            var EMPTY_ORDERED_SET;
            function emptyOrderedSet() {
              return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
            }
            createClass(Stack, IndexedCollection);

            // @pragma Construction

            function Stack(value) {
              return value === null || value === undefined ? emptyStack() : isStack(value) ? value : emptyStack().unshiftAll(value);
            }
            Stack.of = function /*...values*/
            () {
              return this(arguments);
            };
            Stack.prototype.toString = function () {
              return this.__toString('Stack [', ']');
            };

            // @pragma Access

            Stack.prototype.get = function (index, notSetValue) {
              var head = this._head;
              index = wrapIndex(this, index);
              while (head && index--) {
                head = head.next;
              }
              return head ? head.value : notSetValue;
            };
            Stack.prototype.peek = function () {
              return this._head && this._head.value;
            };

            // @pragma Modification

            Stack.prototype.push = function /*...values*/
            () {
              if (arguments.length === 0) {
                return this;
              }
              var newSize = this.size + arguments.length;
              var head = this._head;
              for (var ii = arguments.length - 1; ii >= 0; ii--) {
                head = {
                  value: arguments[ii],
                  next: head
                };
              }
              if (this.__ownerID) {
                this.size = newSize;
                this._head = head;
                this.__hash = undefined;
                this.__altered = true;
                return this;
              }
              return makeStack(newSize, head);
            };
            Stack.prototype.pushAll = function (iter) {
              iter = IndexedIterable(iter);
              if (iter.size === 0) {
                return this;
              }
              assertNotInfinite(iter.size);
              var newSize = this.size;
              var head = this._head;
              iter.reverse().forEach(function (value) {
                newSize++;
                head = {
                  value: value,
                  next: head
                };
              });
              if (this.__ownerID) {
                this.size = newSize;
                this._head = head;
                this.__hash = undefined;
                this.__altered = true;
                return this;
              }
              return makeStack(newSize, head);
            };
            Stack.prototype.pop = function () {
              return this.slice(1);
            };
            Stack.prototype.unshift = function /*...values*/
            () {
              return this.push.apply(this, arguments);
            };
            Stack.prototype.unshiftAll = function (iter) {
              return this.pushAll(iter);
            };
            Stack.prototype.shift = function () {
              return this.pop.apply(this, arguments);
            };
            Stack.prototype.clear = function () {
              if (this.size === 0) {
                return this;
              }
              if (this.__ownerID) {
                this.size = 0;
                this._head = undefined;
                this.__hash = undefined;
                this.__altered = true;
                return this;
              }
              return emptyStack();
            };
            Stack.prototype.slice = function (begin, end) {
              if (wholeSlice(begin, end, this.size)) {
                return this;
              }
              var resolvedBegin = resolveBegin(begin, this.size);
              var resolvedEnd = resolveEnd(end, this.size);
              if (resolvedEnd !== this.size) {
                // super.slice(begin, end);
                return IndexedCollection.prototype.slice.call(this, begin, end);
              }
              var newSize = this.size - resolvedBegin;
              var head = this._head;
              while (resolvedBegin--) {
                head = head.next;
              }
              if (this.__ownerID) {
                this.size = newSize;
                this._head = head;
                this.__hash = undefined;
                this.__altered = true;
                return this;
              }
              return makeStack(newSize, head);
            };

            // @pragma Mutability

            Stack.prototype.__ensureOwner = function (ownerID) {
              if (ownerID === this.__ownerID) {
                return this;
              }
              if (!ownerID) {
                this.__ownerID = ownerID;
                this.__altered = false;
                return this;
              }
              return makeStack(this.size, this._head, ownerID, this.__hash);
            };

            // @pragma Iteration

            Stack.prototype.__iterate = function (fn, reverse) {
              if (reverse) {
                return this.reverse().__iterate(fn);
              }
              var iterations = 0;
              var node = this._head;
              while (node) {
                if (fn(node.value, iterations++, this) === false) {
                  break;
                }
                node = node.next;
              }
              return iterations;
            };
            Stack.prototype.__iterator = function (type, reverse) {
              if (reverse) {
                return this.reverse().__iterator(type);
              }
              var iterations = 0;
              var node = this._head;
              return new Iterator(function () {
                if (node) {
                  var value = node.value;
                  node = node.next;
                  return iteratorValue(type, iterations++, value);
                }
                return iteratorDone();
              });
            };
            function isStack(maybeStack) {
              return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
            }
            Stack.isStack = isStack;
            var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';
            var StackPrototype = Stack.prototype;
            StackPrototype[IS_STACK_SENTINEL] = true;
            StackPrototype.withMutations = MapPrototype.withMutations;
            StackPrototype.asMutable = MapPrototype.asMutable;
            StackPrototype.asImmutable = MapPrototype.asImmutable;
            StackPrototype.wasAltered = MapPrototype.wasAltered;
            function makeStack(size, head, ownerID, hash) {
              var map = Object.create(StackPrototype);
              map.size = size;
              map._head = head;
              map.__ownerID = ownerID;
              map.__hash = hash;
              map.__altered = false;
              return map;
            }
            var EMPTY_STACK;
            function emptyStack() {
              return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
            }

            /**
             * Contributes additional methods to a constructor
             */
            function mixin(ctor, methods) {
              var keyCopier = function (key) {
                ctor.prototype[key] = methods[key];
              };
              Object.keys(methods).forEach(keyCopier);
              Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
              return ctor;
            }
            Iterable.Iterator = Iterator;
            mixin(Iterable, {
              // ### Conversion to other types

              toArray: function () {
                assertNotInfinite(this.size);
                var array = new Array(this.size || 0);
                this.valueSeq().__iterate(function (v, i) {
                  array[i] = v;
                });
                return array;
              },
              toIndexedSeq: function () {
                return new ToIndexedSequence(this);
              },
              toJS: function () {
                return this.toSeq().map(function (value) {
                  return value && typeof value.toJS === 'function' ? value.toJS() : value;
                }).__toJS();
              },
              toJSON: function () {
                return this.toSeq().map(function (value) {
                  return value && typeof value.toJSON === 'function' ? value.toJSON() : value;
                }).__toJS();
              },
              toKeyedSeq: function () {
                return new ToKeyedSequence(this, true);
              },
              toMap: function () {
                // Use Late Binding here to solve the circular dependency.
                return Map(this.toKeyedSeq());
              },
              toObject: function () {
                assertNotInfinite(this.size);
                var object = {};
                this.__iterate(function (v, k) {
                  object[k] = v;
                });
                return object;
              },
              toOrderedMap: function () {
                // Use Late Binding here to solve the circular dependency.
                return OrderedMap(this.toKeyedSeq());
              },
              toOrderedSet: function () {
                // Use Late Binding here to solve the circular dependency.
                return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
              },
              toSet: function () {
                // Use Late Binding here to solve the circular dependency.
                return Set(isKeyed(this) ? this.valueSeq() : this);
              },
              toSetSeq: function () {
                return new ToSetSequence(this);
              },
              toSeq: function () {
                return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
              },
              toStack: function () {
                // Use Late Binding here to solve the circular dependency.
                return Stack(isKeyed(this) ? this.valueSeq() : this);
              },
              toList: function () {
                // Use Late Binding here to solve the circular dependency.
                return List(isKeyed(this) ? this.valueSeq() : this);
              },
              // ### Common JavaScript methods and properties

              toString: function () {
                return '[Iterable]';
              },
              __toString: function (head, tail) {
                if (this.size === 0) {
                  return head + tail;
                }
                return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
              },
              // ### ES6 Collection methods (ES6 Array and Map)

              concat: function () {
                var values = SLICE$0.call(arguments, 0);
                return reify(this, concatFactory(this, values));
              },
              includes: function (searchValue) {
                return this.some(function (value) {
                  return is(value, searchValue);
                });
              },
              entries: function () {
                return this.__iterator(ITERATE_ENTRIES);
              },
              every: function (predicate, context) {
                assertNotInfinite(this.size);
                var returnValue = true;
                this.__iterate(function (v, k, c) {
                  if (!predicate.call(context, v, k, c)) {
                    returnValue = false;
                    return false;
                  }
                });
                return returnValue;
              },
              filter: function (predicate, context) {
                return reify(this, filterFactory(this, predicate, context, true));
              },
              find: function (predicate, context, notSetValue) {
                var entry = this.findEntry(predicate, context);
                return entry ? entry[1] : notSetValue;
              },
              forEach: function (sideEffect, context) {
                assertNotInfinite(this.size);
                return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
              },
              join: function (separator) {
                assertNotInfinite(this.size);
                separator = separator !== undefined ? '' + separator : ',';
                var joined = '';
                var isFirst = true;
                this.__iterate(function (v) {
                  isFirst ? isFirst = false : joined += separator;
                  joined += v !== null && v !== undefined ? v.toString() : '';
                });
                return joined;
              },
              keys: function () {
                return this.__iterator(ITERATE_KEYS);
              },
              map: function (mapper, context) {
                return reify(this, mapFactory(this, mapper, context));
              },
              reduce: function (reducer, initialReduction, context) {
                assertNotInfinite(this.size);
                var reduction;
                var useFirst;
                if (arguments.length < 2) {
                  useFirst = true;
                } else {
                  reduction = initialReduction;
                }
                this.__iterate(function (v, k, c) {
                  if (useFirst) {
                    useFirst = false;
                    reduction = v;
                  } else {
                    reduction = reducer.call(context, reduction, v, k, c);
                  }
                });
                return reduction;
              },
              reduceRight: function (reducer, initialReduction, context) {
                var reversed = this.toKeyedSeq().reverse();
                return reversed.reduce.apply(reversed, arguments);
              },
              reverse: function () {
                return reify(this, reverseFactory(this, true));
              },
              slice: function (begin, end) {
                return reify(this, sliceFactory(this, begin, end, true));
              },
              some: function (predicate, context) {
                return !this.every(not(predicate), context);
              },
              sort: function (comparator) {
                return reify(this, sortFactory(this, comparator));
              },
              values: function () {
                return this.__iterator(ITERATE_VALUES);
              },
              // ### More sequential methods

              butLast: function () {
                return this.slice(0, -1);
              },
              isEmpty: function () {
                return this.size !== undefined ? this.size === 0 : !this.some(function () {
                  return true;
                });
              },
              count: function (predicate, context) {
                return ensureSize(predicate ? this.toSeq().filter(predicate, context) : this);
              },
              countBy: function (grouper, context) {
                return countByFactory(this, grouper, context);
              },
              equals: function (other) {
                return deepEqual(this, other);
              },
              entrySeq: function () {
                var iterable = this;
                if (iterable._cache) {
                  // We cache as an entries array, so we can just return the cache!
                  return new ArraySeq(iterable._cache);
                }
                var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
                entriesSequence.fromEntrySeq = function () {
                  return iterable.toSeq();
                };
                return entriesSequence;
              },
              filterNot: function (predicate, context) {
                return this.filter(not(predicate), context);
              },
              findEntry: function (predicate, context, notSetValue) {
                var found = notSetValue;
                this.__iterate(function (v, k, c) {
                  if (predicate.call(context, v, k, c)) {
                    found = [k, v];
                    return false;
                  }
                });
                return found;
              },
              findKey: function (predicate, context) {
                var entry = this.findEntry(predicate, context);
                return entry && entry[0];
              },
              findLast: function (predicate, context, notSetValue) {
                return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
              },
              findLastEntry: function (predicate, context, notSetValue) {
                return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
              },
              findLastKey: function (predicate, context) {
                return this.toKeyedSeq().reverse().findKey(predicate, context);
              },
              first: function () {
                return this.find(returnTrue);
              },
              flatMap: function (mapper, context) {
                return reify(this, flatMapFactory(this, mapper, context));
              },
              flatten: function (depth) {
                return reify(this, flattenFactory(this, depth, true));
              },
              fromEntrySeq: function () {
                return new FromEntriesSequence(this);
              },
              get: function (searchKey, notSetValue) {
                return this.find(function (_, key) {
                  return is(key, searchKey);
                }, undefined, notSetValue);
              },
              getIn: function (searchKeyPath, notSetValue) {
                var nested = this;
                // Note: in an ES6 environment, we would prefer:
                // for (var key of searchKeyPath) {
                var iter = forceIterator(searchKeyPath);
                var step;
                while (!(step = iter.next()).done) {
                  var key = step.value;
                  nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
                  if (nested === NOT_SET) {
                    return notSetValue;
                  }
                }
                return nested;
              },
              groupBy: function (grouper, context) {
                return groupByFactory(this, grouper, context);
              },
              has: function (searchKey) {
                return this.get(searchKey, NOT_SET) !== NOT_SET;
              },
              hasIn: function (searchKeyPath) {
                return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
              },
              isSubset: function (iter) {
                iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
                return this.every(function (value) {
                  return iter.includes(value);
                });
              },
              isSuperset: function (iter) {
                iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
                return iter.isSubset(this);
              },
              keyOf: function (searchValue) {
                return this.findKey(function (value) {
                  return is(value, searchValue);
                });
              },
              keySeq: function () {
                return this.toSeq().map(keyMapper).toIndexedSeq();
              },
              last: function () {
                return this.toSeq().reverse().first();
              },
              lastKeyOf: function (searchValue) {
                return this.toKeyedSeq().reverse().keyOf(searchValue);
              },
              max: function (comparator) {
                return maxFactory(this, comparator);
              },
              maxBy: function (mapper, comparator) {
                return maxFactory(this, comparator, mapper);
              },
              min: function (comparator) {
                return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
              },
              minBy: function (mapper, comparator) {
                return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
              },
              rest: function () {
                return this.slice(1);
              },
              skip: function (amount) {
                return this.slice(Math.max(0, amount));
              },
              skipLast: function (amount) {
                return reify(this, this.toSeq().reverse().skip(amount).reverse());
              },
              skipWhile: function (predicate, context) {
                return reify(this, skipWhileFactory(this, predicate, context, true));
              },
              skipUntil: function (predicate, context) {
                return this.skipWhile(not(predicate), context);
              },
              sortBy: function (mapper, comparator) {
                return reify(this, sortFactory(this, comparator, mapper));
              },
              take: function (amount) {
                return this.slice(0, Math.max(0, amount));
              },
              takeLast: function (amount) {
                return reify(this, this.toSeq().reverse().take(amount).reverse());
              },
              takeWhile: function (predicate, context) {
                return reify(this, takeWhileFactory(this, predicate, context));
              },
              takeUntil: function (predicate, context) {
                return this.takeWhile(not(predicate), context);
              },
              valueSeq: function () {
                return this.toIndexedSeq();
              },
              // ### Hashable Object

              hashCode: function () {
                return this.__hash || (this.__hash = hashIterable(this));
              }

              // ### Internal

              // abstract __iterate(fn, reverse)

              // abstract __iterator(type, reverse)
            });

            // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
            // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
            // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
            // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

            var IterablePrototype = Iterable.prototype;
            IterablePrototype[IS_ITERABLE_SENTINEL] = true;
            IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
            IterablePrototype.__toJS = IterablePrototype.toArray;
            IterablePrototype.__toStringMapper = quoteString;
            IterablePrototype.inspect = IterablePrototype.toSource = function () {
              return this.toString();
            };
            IterablePrototype.chain = IterablePrototype.flatMap;
            IterablePrototype.contains = IterablePrototype.includes;
            mixin(KeyedIterable, {
              // ### More sequential methods

              flip: function () {
                return reify(this, flipFactory(this));
              },
              mapEntries: function (mapper, context) {
                var this$0 = this;
                var iterations = 0;
                return reify(this, this.toSeq().map(function (v, k) {
                  return mapper.call(context, [k, v], iterations++, this$0);
                }).fromEntrySeq());
              },
              mapKeys: function (mapper, context) {
                var this$0 = this;
                return reify(this, this.toSeq().flip().map(function (k, v) {
                  return mapper.call(context, k, v, this$0);
                }).flip());
              }
            });
            var KeyedIterablePrototype = KeyedIterable.prototype;
            KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
            KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
            KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
            KeyedIterablePrototype.__toStringMapper = function (v, k) {
              return JSON.stringify(k) + ': ' + quoteString(v);
            };
            mixin(IndexedIterable, {
              // ### Conversion to other types

              toKeyedSeq: function () {
                return new ToKeyedSequence(this, false);
              },
              // ### ES6 Collection methods (ES6 Array and Map)

              filter: function (predicate, context) {
                return reify(this, filterFactory(this, predicate, context, false));
              },
              findIndex: function (predicate, context) {
                var entry = this.findEntry(predicate, context);
                return entry ? entry[0] : -1;
              },
              indexOf: function (searchValue) {
                var key = this.keyOf(searchValue);
                return key === undefined ? -1 : key;
              },
              lastIndexOf: function (searchValue) {
                var key = this.lastKeyOf(searchValue);
                return key === undefined ? -1 : key;
              },
              reverse: function () {
                return reify(this, reverseFactory(this, false));
              },
              slice: function (begin, end) {
                return reify(this, sliceFactory(this, begin, end, false));
              },
              splice: function (index, removeNum /*, ...values*/) {
                var numArgs = arguments.length;
                removeNum = Math.max(removeNum | 0, 0);
                if (numArgs === 0 || numArgs === 2 && !removeNum) {
                  return this;
                }
                // If index is negative, it should resolve relative to the size of the
                // collection. However size may be expensive to compute if not cached, so
                // only call count() if the number is in fact negative.
                index = resolveBegin(index, index < 0 ? this.count() : this.size);
                var spliced = this.slice(0, index);
                return reify(this, numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum)));
              },
              // ### More collection methods

              findLastIndex: function (predicate, context) {
                var entry = this.findLastEntry(predicate, context);
                return entry ? entry[0] : -1;
              },
              first: function () {
                return this.get(0);
              },
              flatten: function (depth) {
                return reify(this, flattenFactory(this, depth, false));
              },
              get: function (index, notSetValue) {
                index = wrapIndex(this, index);
                return index < 0 || this.size === Infinity || this.size !== undefined && index > this.size ? notSetValue : this.find(function (_, key) {
                  return key === index;
                }, undefined, notSetValue);
              },
              has: function (index) {
                index = wrapIndex(this, index);
                return index >= 0 && (this.size !== undefined ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);
              },
              interpose: function (separator) {
                return reify(this, interposeFactory(this, separator));
              },
              interleave: function /*...iterables*/
              () {
                var iterables = [this].concat(arrCopy(arguments));
                var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
                var interleaved = zipped.flatten(true);
                if (zipped.size) {
                  interleaved.size = zipped.size * iterables.length;
                }
                return reify(this, interleaved);
              },
              keySeq: function () {
                return Range(0, this.size);
              },
              last: function () {
                return this.get(-1);
              },
              skipWhile: function (predicate, context) {
                return reify(this, skipWhileFactory(this, predicate, context, false));
              },
              zip: function /*, ...iterables */
              () {
                var iterables = [this].concat(arrCopy(arguments));
                return reify(this, zipWithFactory(this, defaultZipper, iterables));
              },
              zipWith: function (zipper /*, ...iterables */) {
                var iterables = arrCopy(arguments);
                iterables[0] = this;
                return reify(this, zipWithFactory(this, zipper, iterables));
              }
            });
            IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
            IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;
            mixin(SetIterable, {
              // ### ES6 Collection methods (ES6 Array and Map)

              get: function (value, notSetValue) {
                return this.has(value) ? value : notSetValue;
              },
              includes: function (value) {
                return this.has(value);
              },
              // ### More sequential methods

              keySeq: function () {
                return this.valueSeq();
              }
            });
            SetIterable.prototype.has = IterablePrototype.includes;
            SetIterable.prototype.contains = SetIterable.prototype.includes;

            // Mixin subclasses

            mixin(KeyedSeq, KeyedIterable.prototype);
            mixin(IndexedSeq, IndexedIterable.prototype);
            mixin(SetSeq, SetIterable.prototype);
            mixin(KeyedCollection, KeyedIterable.prototype);
            mixin(IndexedCollection, IndexedIterable.prototype);
            mixin(SetCollection, SetIterable.prototype);

            // #pragma Helper functions

            function keyMapper(v, k) {
              return k;
            }
            function entryMapper(v, k) {
              return [k, v];
            }
            function not(predicate) {
              return function () {
                return !predicate.apply(this, arguments);
              };
            }
            function neg(predicate) {
              return function () {
                return -predicate.apply(this, arguments);
              };
            }
            function quoteString(value) {
              return typeof value === 'string' ? JSON.stringify(value) : String(value);
            }
            function defaultZipper() {
              return arrCopy(arguments);
            }
            function defaultNegComparator(a, b) {
              return a < b ? 1 : a > b ? -1 : 0;
            }
            function hashIterable(iterable) {
              if (iterable.size === Infinity) {
                return 0;
              }
              var ordered = isOrdered(iterable);
              var keyed = isKeyed(iterable);
              var h = ordered ? 1 : 0;
              var size = iterable.__iterate(keyed ? ordered ? function (v, k) {
                h = 31 * h + hashMerge(hash(v), hash(k)) | 0;
              } : function (v, k) {
                h = h + hashMerge(hash(v), hash(k)) | 0;
              } : ordered ? function (v) {
                h = 31 * h + hash(v) | 0;
              } : function (v) {
                h = h + hash(v) | 0;
              });
              return murmurHashOfSize(size, h);
            }
            function murmurHashOfSize(size, h) {
              h = imul(h, 0xCC9E2D51);
              h = imul(h << 15 | h >>> -15, 0x1B873593);
              h = imul(h << 13 | h >>> -13, 5);
              h = (h + 0xE6546B64 | 0) ^ size;
              h = imul(h ^ h >>> 16, 0x85EBCA6B);
              h = imul(h ^ h >>> 13, 0xC2B2AE35);
              h = smi(h ^ h >>> 16);
              return h;
            }
            function hashMerge(a, b) {
              return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
            }

            var Immutable = {
              Iterable: Iterable,
              Seq: Seq,
              Collection: Collection,
              Map: Map,
              OrderedMap: OrderedMap,
              List: List,
              Stack: Stack,
              Set: Set,
              OrderedSet: OrderedSet,
              Record: Record,
              Range: Range,
              Repeat: Repeat,
              is: is,
              fromJS: fromJS
            };
            return Immutable;
          });
        })(immutable);
        var immutableExports = immutable.exports;
        const Immutable = /*@__PURE__*/getDefaultExportFromCjs(immutableExports);

        // RegExp.quote = function (str) {
        //     return str.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
        // };

        var defaultValue$1 = function defaultValue(value, _default) {
          return typeof value === "undefined" ? _default : value;
        };

        // const immutableEqual = function(v1, v2) {
        //   if (v1 === v2) {
        //     return true;
        //   } else {
        //     return v1.equals(v2);
        //   }
        // };

        var deepEqual = function deepEqual(v1, v2) {
          if (v1 === v2) {
            return true;
          } else if (immutableExports.Map.isMap(v1)) {
            return v1.equals(v2);
          } else {
            return JSON.stringify(v1) == JSON.stringify(v2);
          }
        };

        // //Do sets have same values?
        // const eqSet = function (as, bs) {
        //   if (as.size !== bs.size) return false;
        //   for (var a of as) if (!bs.has(a)) return false;
        //   return true;
        // };

        // //Do arrays have same values?
        // const eqArrSet = function (arr1, arr2) {
        //   return eqSet(new Set(arr1), new Set(arr2));
        // };

        var shallowEqual$2 = function shallowEqual(a, b) {
          var deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          if (a === b) {
            return true;
          } else if (Array.isArray(a)) return shallowEqualArrays$1(a, b, deep);else if (immutableExports.Map.isMap(a)) return a.equals(b);else if (_typeof$2(a) == "object") return shallowEqualObjects$1(a, b, deep);else return a === b;
        };
        function shallowEqualArrays$1(arrA, arrB) {
          var deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          if (arrA === arrB) {
            return true;
          }
          if (!arrA || !arrB) {
            return false;
          }
          var len = arrA.length;
          if (arrB.length !== len) {
            return false;
          }
          for (var i = 0; i < len; i++) {
            var isEqual = deep ? shallowEqual$2(arrA[i], arrB[i], deep) : arrA[i] === arrB[i];
            if (!isEqual) {
              return false;
            }
          }
          return true;
        }
        function shallowEqualObjects$1(objA, objB) {
          var deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          if (objA === objB) {
            return true;
          }
          if (!objA || !objB) {
            return false;
          }
          var aKeys = Object.keys(objA);
          var bKeys = Object.keys(objB);
          var len = aKeys.length;
          if (bKeys.length !== len) {
            return false;
          }
          for (var i = 0; i < len; i++) {
            var key = aKeys[i];
            var isEqual = deep ? shallowEqual$2(objA[key], objB[key], deep) : objA[key] === objB[key];
            if (!isEqual) {
              return false;
            }
          }
          return true;
        }
        var isImmutable = function isImmutable(v) {
          return _typeof$2(v) === "object" && v !== null && typeof v.toJS === "function";
        };
        function toImmutableList(v) {
          return isImmutable(v) ? v : new Immutable.List(v);
        }
        function applyToJS(v) {
          return isImmutable(v) ? v.toJS() : v;
        }
        var escapeRegExp = function escapeRegExp(string) {
          return string.replace(/[.*+?^${}()|[\]\\/]/g, "\\$&"); // $& means the whole matched string
        };

        var isJsonLogic = function isJsonLogic(logic) {
          return _typeof$2(logic) === "object" // An object
          && logic !== null // but not null
          && !Array.isArray(logic) // and not an array
          && Object.keys(logic).length === 1 // with exactly one key
          ;
        };

        function sleep(delay) {
          return new Promise(function (resolve) {
            setTimeout(resolve, delay);
          });
        }

        // [1, 4, 9] + [1, 5, 9] => [1, 4, 5, 9]
        // Used for merging arrays of operators for different widgets of 1 type
        function mergeArraysSmart(arr1, arr2) {
          if (!arr1) arr1 = [];
          if (!arr2) arr2 = [];
          return arr2.map(function (op) {
            return [op, arr1.indexOf(op)];
          }).map(function (_ref, i, orig) {
            var _ref2 = _slicedToArray$1(_ref, 2),
              op = _ref2[0],
              ind = _ref2[1];
            if (ind == -1) {
              var next = orig.slice(i + 1);
              var prev = orig.slice(0, i);
              var after = prev.reverse().find(function (_ref3) {
                var _ref4 = _slicedToArray$1(_ref3, 2);
                _ref4[0];
                var ci = _ref4[1];
                return ci != -1;
              });
              var before = next.find(function (_ref5) {
                var _ref6 = _slicedToArray$1(_ref5, 2);
                _ref6[0];
                var ci = _ref6[1];
                return ci != -1;
              });
              if (before) return [op, "before", before[0]];else if (after) return [op, "after", after[0]];else return [op, "append", null];
            } else {
              // already exists
              return null;
            }
          }).filter(function (x) {
            return x !== null;
          }).reduce(function (acc, _ref7) {
            var _ref8 = _slicedToArray$1(_ref7, 3),
              newOp = _ref8[0],
              rel = _ref8[1],
              relOp = _ref8[2];
            var ind = acc.indexOf(relOp);
            if (acc.indexOf(newOp) == -1) {
              if (ind > -1) {
                // insert after or before
                acc.splice(ind + (rel == "after" ? 1 : 0), 0, newOp);
              } else {
                // insert to end or start
                acc.splice(rel == "append" ? Infinity : 0, 0, newOp);
              }
            }
            return acc;
          }, arr1.slice());
        }
        var isDev$1 = function isDev() {
          return typeof process !== "undefined" && {} && "production" == "development";
        };
        var getLogger$1 = function getLogger() {
          var devMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          var verbose = devMode != undefined ? devMode : isDev$1();
          return verbose ? console : {
            error: function error() {},
            log: function log() {},
            warn: function warn() {},
            debug: function debug() {},
            info: function info() {}
          };
        };
        var getFirstDefined = function getFirstDefined() {
          var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          var ret;
          for (var i = 0; i < arr.length; i++) {
            var v = arr[i];
            if (v !== undefined) {
              ret = v;
              break;
            }
          }
          return ret;
        };
        var logger$1 = getLogger$1();
        function _arrayWithoutHoles(arr) {
          if (Array.isArray(arr)) return _arrayLikeToArray$8(arr);
        }
        function _nonIterableSpread() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _toConsumableArray(arr) {
          return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$8(arr) || _nonIterableSpread();
        }
        var baseAssignValue$1 = _baseAssignValue,
          eq$1 = eq_1;

        /**
         * This function is like `assignValue` except that it doesn't assign
         * `undefined` values.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function assignMergeValue$2(object, key, value) {
          if (value !== undefined && !eq$1(object[key], value) || value === undefined && !(key in object)) {
            baseAssignValue$1(object, key, value);
          }
        }
        var _assignMergeValue = assignMergeValue$2;
        var isArrayLike$1 = isArrayLike_1,
          isObjectLike = isObjectLike_1;

        /**
         * This method is like `_.isArrayLike` except that it also checks if `value`
         * is an object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array-like object,
         *  else `false`.
         * @example
         *
         * _.isArrayLikeObject([1, 2, 3]);
         * // => true
         *
         * _.isArrayLikeObject(document.body.children);
         * // => true
         *
         * _.isArrayLikeObject('abc');
         * // => false
         *
         * _.isArrayLikeObject(_.noop);
         * // => false
         */
        function isArrayLikeObject$1(value) {
          return isObjectLike(value) && isArrayLike$1(value);
        }
        var isArrayLikeObject_1 = isArrayLikeObject$1;

        /**
         * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the property to get.
         * @returns {*} Returns the property value.
         */

        function safeGet$2(object, key) {
          if (key === 'constructor' && typeof object[key] === 'function') {
            return;
          }
          if (key == '__proto__') {
            return;
          }
          return object[key];
        }
        var _safeGet = safeGet$2;
        var copyObject$1 = _copyObject,
          keysIn$1 = keysIn_1;

        /**
         * Converts `value` to a plain object flattening inherited enumerable string
         * keyed properties of `value` to own properties of the plain object.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Object} Returns the converted plain object.
         * @example
         *
         * function Foo() {
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.assign({ 'a': 1 }, new Foo);
         * // => { 'a': 1, 'b': 2 }
         *
         * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
         * // => { 'a': 1, 'b': 2, 'c': 3 }
         */
        function toPlainObject$1(value) {
          return copyObject$1(value, keysIn$1(value));
        }
        var toPlainObject_1 = toPlainObject$1;
        var assignMergeValue$1 = _assignMergeValue,
          cloneBuffer = _cloneBufferExports,
          cloneTypedArray = _cloneTypedArray,
          copyArray = _copyArray,
          initCloneObject = _initCloneObject,
          isArguments$1 = isArguments_1,
          isArray$1 = isArray_1,
          isArrayLikeObject = isArrayLikeObject_1,
          isBuffer = isBufferExports,
          isFunction = isFunction_1,
          isObject$8 = isObject_1,
          isPlainObject$1 = isPlainObject_1,
          isTypedArray = isTypedArray_1,
          safeGet$1 = _safeGet,
          toPlainObject = toPlainObject_1;

        /**
         * A specialized version of `baseMerge` for arrays and objects which performs
         * deep merges and tracks traversed objects enabling objects with circular
         * references to be merged.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {string} key The key of the value to merge.
         * @param {number} srcIndex The index of `source`.
         * @param {Function} mergeFunc The function to merge values.
         * @param {Function} [customizer] The function to customize assigned values.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         */
        function baseMergeDeep$1(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet$1(object, key),
            srcValue = safeGet$1(source, key),
            stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue$1(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
          var isCommon = newValue === undefined;
          if (isCommon) {
            var isArr = isArray$1(srcValue),
              isBuff = !isArr && isBuffer(srcValue),
              isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray$1(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject$1(srcValue) || isArguments$1(srcValue)) {
              newValue = objValue;
              if (isArguments$1(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject$8(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            // Recursively merge objects and arrays (susceptible to call stack limits).
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack['delete'](srcValue);
          }
          assignMergeValue$1(object, key, newValue);
        }
        var _baseMergeDeep = baseMergeDeep$1;
        var Stack = _Stack,
          assignMergeValue = _assignMergeValue,
          baseFor = _baseFor,
          baseMergeDeep = _baseMergeDeep,
          isObject$7 = isObject_1,
          keysIn = keysIn_1,
          safeGet = _safeGet;

        /**
         * The base implementation of `_.merge` without support for multiple sources.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {number} srcIndex The index of `source`.
         * @param {Function} [customizer] The function to customize merged values.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         */
        function baseMerge$2(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function (srcValue, key) {
            stack || (stack = new Stack());
            if (isObject$7(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge$2, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;
              if (newValue === undefined) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        var _baseMerge = baseMerge$2;

        /**
         * A faster alternative to `Function#apply`, this function invokes `func`
         * with the `this` binding of `thisArg` and the arguments of `args`.
         *
         * @private
         * @param {Function} func The function to invoke.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {Array} args The arguments to invoke `func` with.
         * @returns {*} Returns the result of `func`.
         */

        function apply$1(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        var _apply = apply$1;
        var apply = _apply;

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeMax$2 = Math.max;

        /**
         * A specialized version of `baseRest` which transforms the rest array.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @param {Function} transform The rest array transform.
         * @returns {Function} Returns the new function.
         */
        function overRest$2(func, start, transform) {
          start = nativeMax$2(start === undefined ? func.length - 1 : start, 0);
          return function () {
            var args = arguments,
              index = -1,
              length = nativeMax$2(args.length - start, 0),
              array = Array(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform(array);
            return apply(func, this, otherArgs);
          };
        }
        var _overRest = overRest$2;

        /**
         * Creates a function that returns `value`.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Util
         * @param {*} value The value to return from the new function.
         * @returns {Function} Returns the new constant function.
         * @example
         *
         * var objects = _.times(2, _.constant({ 'a': 1 }));
         *
         * console.log(objects);
         * // => [{ 'a': 1 }, { 'a': 1 }]
         *
         * console.log(objects[0] === objects[1]);
         * // => true
         */

        function constant$1(value) {
          return function () {
            return value;
          };
        }
        var constant_1 = constant$1;
        var constant = constant_1,
          defineProperty = _defineProperty$2,
          identity$1 = identity_1;

        /**
         * The base implementation of `setToString` without support for hot loop shorting.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */
        var baseSetToString$1 = !defineProperty ? identity$1 : function (func, string) {
          return defineProperty(func, 'toString', {
            'configurable': true,
            'enumerable': false,
            'value': constant(string),
            'writable': true
          });
        };
        var _baseSetToString = baseSetToString$1;

        /** Used to detect hot functions by number of calls within a span of milliseconds. */

        var HOT_COUNT = 800,
          HOT_SPAN = 16;

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeNow = Date.now;

        /**
         * Creates a function that'll short out and invoke `identity` instead
         * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
         * milliseconds.
         *
         * @private
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new shortable function.
         */
        function shortOut$1(func) {
          var count = 0,
            lastCalled = 0;
          return function () {
            var stamp = nativeNow(),
              remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined, arguments);
          };
        }
        var _shortOut = shortOut$1;
        var baseSetToString = _baseSetToString,
          shortOut = _shortOut;

        /**
         * Sets the `toString` method of `func` to return `string`.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */
        var setToString$2 = shortOut(baseSetToString);
        var _setToString = setToString$2;
        var identity = identity_1,
          overRest$1 = _overRest,
          setToString$1 = _setToString;

        /**
         * The base implementation of `_.rest` which doesn't validate or coerce arguments.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @returns {Function} Returns the new function.
         */
        function baseRest$1(func, start) {
          return setToString$1(overRest$1(func, start, identity), func + '');
        }
        var _baseRest = baseRest$1;
        var eq = eq_1,
          isArrayLike = isArrayLike_1,
          isIndex$1 = _isIndex,
          isObject$6 = isObject_1;

        /**
         * Checks if the given arguments are from an iteratee call.
         *
         * @private
         * @param {*} value The potential iteratee value argument.
         * @param {*} index The potential iteratee index or key argument.
         * @param {*} object The potential iteratee object argument.
         * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
         *  else `false`.
         */
        function isIterateeCall$2(value, index, object) {
          if (!isObject$6(object)) {
            return false;
          }
          var type = typeof index;
          if (type == 'number' ? isArrayLike(object) && isIndex$1(index, object.length) : type == 'string' && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        var _isIterateeCall = isIterateeCall$2;
        var baseRest = _baseRest,
          isIterateeCall$1 = _isIterateeCall;

        /**
         * Creates a function like `_.assign`.
         *
         * @private
         * @param {Function} assigner The function to assign values.
         * @returns {Function} Returns the new assigner function.
         */
        function createAssigner$2(assigner) {
          return baseRest(function (object, sources) {
            var index = -1,
              length = sources.length,
              customizer = length > 1 ? sources[length - 1] : undefined,
              guard = length > 2 ? sources[2] : undefined;
            customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;
            if (guard && isIterateeCall$1(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined : customizer;
              length = 1;
            }
            object = Object(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        var _createAssigner = createAssigner$2;
        var baseMerge$1 = _baseMerge,
          createAssigner$1 = _createAssigner;

        /**
         * This method is like `_.assign` except that it recursively merges own and
         * inherited enumerable string keyed properties of source objects into the
         * destination object. Source properties that resolve to `undefined` are
         * skipped if a destination value exists. Array and plain object properties
         * are merged recursively. Other objects and value types are overridden by
         * assignment. Source objects are applied from left to right. Subsequent
         * sources overwrite property assignments of previous sources.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 0.5.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = {
         *   'a': [{ 'b': 2 }, { 'd': 4 }]
         * };
         *
         * var other = {
         *   'a': [{ 'c': 3 }, { 'e': 5 }]
         * };
         *
         * _.merge(object, other);
         * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
         */
        var merge$1 = createAssigner$1(function (object, source, srcIndex) {
          baseMerge$1(object, source, srcIndex);
        });
        var merge_1 = merge$1;
        const merge$2 = /*@__PURE__*/getDefaultExportFromCjs(merge_1);

        // Had to make uuid use a constant seed so it would generate same sequence across runs. This was needed
        // so server side rendering and client side rendering yield same results (e.g. the uuid is used when rendering
        // the concunctions with their name and id)
        var query_builder_seed = 0;
        const uuid$1 = function () {
          // Generate a random GUID http://stackoverflow.com/a/2117523.
          var timePart = (new Date().getTime().toString(16) + "FF").substr(0, 11);
          var s = "ssssssss-xxxx-4xxx-yxxx-x".replace(/[xys]/g, function (c) {
            var r = c === "s" ? Math.floor(Math.random() * 16) : query_builder_seed++ & 0xf;
            var v = c === "x" ? r : r & 0x3 | 0x8;
            return v.toString(16);
          });
          return s + timePart;
        };
        var baseMerge = _baseMerge,
          createAssigner = _createAssigner;

        /**
         * This method is like `_.merge` except that it accepts `customizer` which
         * is invoked to produce the merged values of the destination and source
         * properties. If `customizer` returns `undefined`, merging is handled by the
         * method instead. The `customizer` is invoked with six arguments:
         * (objValue, srcValue, key, object, source, stack).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} sources The source objects.
         * @param {Function} customizer The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function customizer(objValue, srcValue) {
         *   if (_.isArray(objValue)) {
         *     return objValue.concat(srcValue);
         *   }
         * }
         *
         * var object = { 'a': [1], 'b': [2] };
         * var other = { 'a': [3], 'b': [4] };
         *
         * _.mergeWith(object, other, customizer);
         * // => { 'a': [1, 3], 'b': [2, 4] }
         */
        var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var mergeWith_1 = mergeWith;
        const mergeWith$1 = /*@__PURE__*/getDefaultExportFromCjs(mergeWith_1);
        var settings$4 = {
          formatField: function formatField(field, parts, label2, fieldDefinition, config, isForDisplay) {
            if (isForDisplay) return label2;else return field;
          },
          valueSourcesInfo: {
            value: {}
          },
          fieldSeparator: ".",
          fieldSeparatorDisplay: ".",
          canReorder: true,
          canRegroup: true,
          canDeleteLocked: false,
          canLeaveEmptyGroup: true,
          shouldCreateEmptyGroup: false,
          canShortMongoQuery: true,
          removeEmptyGroupsOnLoad: true,
          removeIncompleteRulesOnLoad: true,
          removeInvalidMultiSelectValuesOnLoad: true,
          setOpOnChangeField: ["keep", "default"],
          // 'default' (default if present), 'keep' (keep prev from last field), 'first', 'none'
          groupOperators: ["some", "all", "none"],
          defaultGroupConjunction: "AND",
          // localization
          locale: {
            moment: "en"
          },
          valueLabel: "Value",
          valuePlaceholder: "Value",
          fieldLabel: "Field",
          operatorLabel: "Operator",
          funcLabel: "Function",
          fieldPlaceholder: "Select field",
          funcPlaceholder: "Select function",
          operatorPlaceholder: "Select operator",
          lockLabel: "Lock",
          lockedLabel: "Locked",
          deleteLabel: null,
          addGroupLabel: "Add group",
          addCaseLabel: "Add condition",
          addDefaultCaseLabel: "Add default condition",
          defaultCaseLabel: "Default:",
          addRuleLabel: "Add rule",
          addSubRuleLabel: "Add sub rule",
          delGroupLabel: "",
          notLabel: "Not",
          valueSourcesPopupTitle: "Select value source",
          removeRuleConfirmOptions: null,
          removeGroupConfirmOptions: null
        };
        function _createForOfIteratorHelper$5(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === "number") {
              if (it) o = it;
              var i = 0;
              var F = function F() {};
              return {
                s: F,
                n: function n() {
                  if (i >= o.length) return {
                    done: true
                  };
                  return {
                    done: false,
                    value: o[i++]
                  };
                },
                e: function e(_e) {
                  throw _e;
                },
                f: F
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true,
            didErr = false,
            err;
          return {
            s: function s() {
              it = it.call(o);
            },
            n: function n() {
              var step = it.next();
              normalCompletion = step.done;
              return step;
            },
            e: function e(_e2) {
              didErr = true;
              err = _e2;
            },
            f: function f() {
              try {
                if (!normalCompletion && it["return"] != null) it["return"]();
              } finally {
                if (didErr) throw err;
              }
            }
          };
        }
        function _unsupportedIterableToArray$5(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray$5(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen);
        }
        function _arrayLikeToArray$5(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }
        var isObject$5 = function isObject(v) {
          return _typeof$2(v) == "object" && v !== null;
        }; // object or array
        var listValue = function listValue(v, title) {
          return isObject$5(v) ? v : {
            value: v,
            title: title !== undefined ? title : v
          };
        };

        // convert {<value>: <title>, ..} or [value, ..] to normal [{value, title}, ..]
        var listValuesToArray$1 = function listValuesToArray(listValuesObj) {
          if (!isObject$5(listValuesObj)) return listValuesObj;
          if (Array.isArray(listValuesObj)) return listValuesObj.map(function (v) {
            return listValue(v);
          });
          var listValuesArr = [];
          for (var v in listValuesObj) {
            var title = listValuesObj[v];
            listValuesArr.push(listValue(v, title));
          }
          return listValuesArr;
        };

        // listValues can be {<value>: <title>, ..} or [{value, title}, ..] or [value, ..]
        var getItemInListValues = function getItemInListValues(listValues, value) {
          if (Array.isArray(listValues)) {
            var values = listValues.map(function (v) {
              return listValue(v);
            });
            return values.find(function (v) {
              return v.value === value;
            }) || values.find(function (v) {
              return "".concat(v.value) === value;
            });
          } else {
            return listValues[value] !== undefined ? listValue(value, listValues[value]) : undefined;
          }
        };
        var getTitleInListValues$1 = function getTitleInListValues(listValues, value) {
          if (listValues == undefined) return value;
          var it = getItemInListValues(listValues, value);
          return it !== undefined ? it.title : value;
        };
        var getValueInListValues = function getValueInListValues(listValues, value) {
          if (listValues == undefined) return value;
          var it = getItemInListValues(listValues, value);
          return it !== undefined ? it.value : value;
        };
        var mapListValues$5 = function mapListValues(listValues, mapFn) {
          var ret = [];
          if (Array.isArray(listValues)) {
            var _iterator = _createForOfIteratorHelper$5(listValues),
              _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var v = _step.value;
                var lv = mapFn(listValue(v));
                if (lv != null) ret.push(lv);
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          } else {
            for (var value in listValues) {
              var _lv = mapFn(listValue(value, listValues[value]));
              if (_lv != null) ret.push(_lv);
            }
          }
          return ret;
        };
        const listValues = /*#__PURE__*/Object.freeze( /*#__PURE__*/Object.defineProperty({
          __proto__: null,
          getItemInListValues,
          getTitleInListValues: getTitleInListValues$1,
          getValueInListValues,
          listValuesToArray: listValuesToArray$1,
          mapListValues: mapListValues$5
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        function ownKeys$v(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$v(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$v(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$v(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        var defaultField = function defaultField(config) {
          var canGetFirst = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          var parentRuleGroupPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          return typeof config.settings.defaultField === "function" ? config.settings.defaultField(parentRuleGroupPath) : config.settings.defaultField || (canGetFirst ? getFirstField(config, parentRuleGroupPath) : null);
        };
        var defaultOperator = function defaultOperator(config, field) {
          var canGetFirst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          var fieldConfig = getFieldConfig$8(config, field);
          var fieldOperators = fieldConfig && fieldConfig.operators || [];
          var fieldDefaultOperator = fieldConfig && fieldConfig.defaultOperator;
          if (!fieldOperators.includes(fieldDefaultOperator)) fieldDefaultOperator = null;
          if (!fieldDefaultOperator && canGetFirst) fieldDefaultOperator = getFirstOperator(config, field);
          var op = typeof config.settings.defaultOperator === "function" ? config.settings.defaultOperator(field, fieldConfig) : fieldDefaultOperator;
          return op;
        };

        //used for complex operators like proximity
        var defaultOperatorOptions = function defaultOperatorOptions(config, operator, field) {
          var operatorConfig = operator ? getOperatorConfig$4(config, operator, field) : null;
          if (!operatorConfig) return null; //new Immutable.Map();
          return operatorConfig.options ? new Immutable.Map(operatorConfig.options && operatorConfig.options.defaults || {}) : null;
        };
        var defaultRuleProperties = function defaultRuleProperties(config) {
          var parentRuleGroupPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var item = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          var field = null,
            operator = null;
          var _config$settings = config.settings,
            setDefaultFieldAndOp = _config$settings.setDefaultFieldAndOp,
            showErrorMessage = _config$settings.showErrorMessage;
          if (item) {
            var _item$properties, _item$properties2;
            field = item === null || item === void 0 ? void 0 : (_item$properties = item.properties) === null || _item$properties === void 0 ? void 0 : _item$properties.field;
            operator = item === null || item === void 0 ? void 0 : (_item$properties2 = item.properties) === null || _item$properties2 === void 0 ? void 0 : _item$properties2.operator;
          } else if (setDefaultFieldAndOp) {
            field = defaultField(config, true, parentRuleGroupPath);
            operator = defaultOperator(config, field);
          }
          var current = new Immutable.Map({
            field: field,
            operator: operator,
            value: new Immutable.List(),
            valueSrc: new Immutable.List(),
            //used for complex operators like proximity
            operatorOptions: defaultOperatorOptions(config, operator, field)
          });
          if (showErrorMessage) {
            current = current.set("valueError", new Immutable.List());
          }
          if (field && operator) {
            var _getNewValueForFieldO = getNewValueForFieldOp(config, config, current, field, operator, "operator", false),
              newValue = _getNewValueForFieldO.newValue,
              newValueSrc = _getNewValueForFieldO.newValueSrc,
              newValueType = _getNewValueForFieldO.newValueType,
              newValueError = _getNewValueForFieldO.newValueError;
            current = current.set("value", newValue).set("valueSrc", newValueSrc).set("valueType", newValueType);
            if (showErrorMessage) {
              current = current.set("valueError", newValueError);
            }
          }
          return current;
        };
        var defaultGroupConjunction$1 = function defaultGroupConjunction(config) {
          var fieldConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          fieldConfig = getFieldConfig$8(config, fieldConfig); // if `fieldConfig` is field name, not config
          var conjs = fieldConfig && fieldConfig.conjunctions || Object.keys(config.conjunctions);
          if (conjs.length == 1) return conjs[0];
          return config.settings.defaultGroupConjunction || config.settings.defaultConjunction || conjs[0];
        };
        var defaultConjunction = function defaultConjunction(config) {
          return config.settings.defaultConjunction || Object.keys(config.conjunctions)[0];
        };
        var defaultGroupProperties = function defaultGroupProperties(config) {
          var fieldConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return new Immutable.Map({
            conjunction: defaultGroupConjunction$1(config, fieldConfig),
            not: false
          });
        };
        var defaultItemProperties = function defaultItemProperties(config, item) {
          var _item$properties3;
          return item && item.type == "group" ? defaultGroupProperties(config, item === null || item === void 0 ? void 0 : (_item$properties3 = item.properties) === null || _item$properties3 === void 0 ? void 0 : _item$properties3.field) : defaultRuleProperties(config, null, item);
        };
        var defaultRule = function defaultRule(id, config) {
          return _defineProperty$4({}, id, new Immutable.Map({
            type: "rule",
            id: id,
            properties: defaultRuleProperties(config)
          }));
        };
        var defaultRoot$1 = function defaultRoot(config) {
          return new Immutable.Map({
            type: "group",
            id: uuid$1(),
            children1: new Immutable.OrderedMap(_objectSpread$v({}, defaultRule(uuid$1(), config))),
            properties: defaultGroupProperties(config)
          });
        };
        var createListFromArray$2 = function createListFromArray(ids) {
          return new Immutable.List(ids);
        };
        var emptyProperies$1 = function emptyProperies() {
          return new Immutable.Map();
        };
        const defaultUtils = /*#__PURE__*/Object.freeze( /*#__PURE__*/Object.defineProperty({
          __proto__: null,
          createListFromArray: createListFromArray$2,
          defaultConjunction,
          defaultField,
          defaultGroupConjunction: defaultGroupConjunction$1,
          defaultGroupProperties,
          defaultItemProperties,
          defaultOperator,
          defaultOperatorOptions,
          defaultRoot: defaultRoot$1,
          defaultRule,
          defaultRuleProperties,
          emptyProperies: emptyProperies$1
        }, Symbol.toStringTag, {
          value: 'Module'
        }));

        /**
         * @param {Immutable.List} path
         * @param {...string} suffix
         * @return {Immutable.List}
         */
        var expandTreePath = function expandTreePath(path) {
          for (var _len = arguments.length, suffix = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            suffix[_key - 1] = arguments[_key];
          }
          return path.interpose("children1").withMutations(function (list) {
            list.skip(1);
            list.push.apply(list, suffix);
            return list;
          });
        };

        /**
         * @param {Immutable.List} path
         * @param {...string} suffix
         * @return {Immutable.List}
         */
        var expandTreeSubpath = function expandTreeSubpath(path) {
          for (var _len2 = arguments.length, suffix = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            suffix[_key2 - 1] = arguments[_key2];
          }
          return path.interpose("children1").withMutations(function (list) {
            list.push.apply(list, suffix);
            return list;
          });
        };

        /**
         * @param {Immutable.Map} path
         * @param {Immutable.List} path
         * @return {Immutable.Map}
         */
        var getItemByPath = function getItemByPath(tree, path) {
          var children = new Immutable.OrderedMap(_defineProperty$4({}, tree.get("id"), tree));
          var res = tree;
          path.forEach(function (id) {
            res = children.get(id);
            children = res.get("children1");
          });
          return res;
        };

        /**
         * Remove `path` in every item
         * @param {Immutable.Map} tree
         * @return {Immutable.Map} tree
         */
        var removePathsInTree = function removePathsInTree(tree) {
          var newTree = tree;
          function _processNode(item, path) {
            var itemPath = path.push(item.get("id"));
            if (item.get("path")) {
              newTree = newTree.removeIn(expandTreePath(itemPath, "path"));
            }
            var children = item.get("children1");
            if (children) {
              children.map(function (child, _childId) {
                _processNode(child, itemPath);
              });
            }
          }
          _processNode(tree, new Immutable.List());
          return newTree;
        };

        /**
         * Remove `isLocked` in items that inherit parent's `isLocked`
         * @param {Immutable.Map} tree
         * @return {Immutable.Map} tree
         */
        var removeIsLockedInTree = function removeIsLockedInTree(tree) {
          var newTree = tree;
          function _processNode(item, path) {
            var isParentLocked = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var itemPath = path.push(item.get("id"));
            var isLocked = item.getIn(["properties", "isLocked"]);
            if (isParentLocked && isLocked) {
              newTree = newTree.deleteIn(expandTreePath(itemPath, "properties", "isLocked"));
            }
            var children = item.get("children1");
            if (children) {
              children.map(function (child, _childId) {
                _processNode(child, itemPath, isLocked || isParentLocked);
              });
            }
          }
          _processNode(tree, new Immutable.List());
          return newTree;
        };

        /**
         * Set correct `path` and `id` in every item
         * @param {Immutable.Map} tree
         * @return {Immutable.Map} tree
         */
        var fixPathsInTree = function fixPathsInTree(tree) {
          var newTree = tree;
          function _processNode(item, path, lev, nodeId) {
            if (!item) return;
            var currPath = item.get("path");
            var currId = item.get("id");
            var itemId = currId || nodeId;
            var itemPath = path.push(itemId);
            if (!currPath || !currPath.equals(itemPath)) {
              newTree = newTree.setIn(expandTreePath(itemPath, "path"), itemPath);
            }
            if (!currId) {
              newTree = newTree.setIn(expandTreePath(itemPath, "id"), itemId);
            }
            var children = item.get("children1");
            if (children) {
              if (children.constructor.name == "Map") {
                // protect: should me OrderedMap, not Map (issue #501)
                newTree = newTree.setIn(expandTreePath(itemPath, "children1"), new Immutable.OrderedMap(children));
              }
              children.map(function (child, childId) {
                _processNode(child, itemPath, lev + 1, childId);
              });
            }
          }
          _processNode(tree, new Immutable.List(), 0);
          return newTree;
        };
        var fixEmptyGroupsInTree = function fixEmptyGroupsInTree(tree) {
          var newTree = tree;
          function _processNode(item, path, lev, nodeId) {
            if (!item) return false;
            var itemId = item.get("id") || nodeId;
            var itemPath = path.push(itemId);
            var children = item.get("children1");
            if (children) {
              var allChildrenGone = children.map(function (child, childId) {
                return _processNode(child, itemPath, lev + 1, childId);
              }).reduce(function (curr, v) {
                return curr && v;
              }, true);
              if ((children.size == 0 || allChildrenGone) && lev > 0) {
                newTree = newTree.deleteIn(expandTreePath(itemPath));
                return true;
              }
            }
            return false;
          }
          _processNode(tree, new Immutable.List(), 0);
          return newTree;
        };

        /**
         * @param {Immutable.Map} tree
         * @return {Object} {flat, items}
         */
        var getFlatTree$1 = function getFlatTree(tree) {
          var flat = [];
          var items = {};
          var realHeight = 0;
          function _flatizeTree(item, path, insideCollapsed, insideLocked, insideRuleGroup, lev, info, parentType, caseId) {
            var type = item.get("type");
            var collapsed = item.get("collapsed");
            var id = item.get("id");
            var children = item.get("children1");
            var isLocked = item.getIn(["properties", "isLocked"]);
            var childrenIds = children ? children.map(function (_child, childId) {
              return childId;
            }) : null;
            var isRuleGroup = type == "rule_group";
            // tip: count rule_group as 1 rule
            var isLeaf = !insideRuleGroup && (!children || isRuleGroup);
            var itemsBefore = flat.length;
            var top = realHeight;
            flat.push(id);
            if (!insideCollapsed) realHeight += 1;
            info.height = (info.height || 0) + 1;
            items[id] = {
              type: type,
              parent: path.length ? path[path.length - 1] : null,
              parentType: parentType,
              caseId: type == "case_group" ? id : caseId,
              isDefaultCase: type == "case_group" && !children,
              path: path.concat(id),
              lev: lev,
              leaf: !children,
              index: itemsBefore,
              id: id,
              children: childrenIds,
              leafsCount: 0,
              _top: itemsBefore,
              //_height: (itemsAfter - itemsBefore),
              top: insideCollapsed ? null : top,
              //height: height,
              //bottom: (insideCollapsed ? null : top) + height,
              collapsed: collapsed,
              node: item,
              isLocked: isLocked || insideLocked
            };
            if (children) {
              var subinfo = {};
              children.map(function (child, _childId) {
                _flatizeTree(child, path.concat(id), insideCollapsed || collapsed, insideLocked || isLocked, insideRuleGroup || isRuleGroup, lev + 1, subinfo, type, type == "case_group" ? id : caseId);
              });
              if (!collapsed) {
                info.height = (info.height || 0) + (subinfo.height || 0);
              }
            }
            if (caseId && isLeaf) {
              items[caseId].leafsCount++;
            }
            var itemsAfter = flat.length;
            var height = info.height;
            Object.assign(items[id], {
              _height: itemsAfter - itemsBefore,
              height: height,
              bottom: (insideCollapsed ? null : top) + height
            });
          }
          _flatizeTree(tree, [], false, false, false, 0, {}, null, null);
          for (var i = 0; i < flat.length; i++) {
            var prevId = i > 0 ? flat[i - 1] : null;
            var nextId = i < flat.length - 1 ? flat[i + 1] : null;
            var item = items[flat[i]];
            item.prev = prevId;
            item.next = nextId;
          }
          return {
            flat: flat,
            items: items
          };
        };

        /**
         * Returns count of reorderable(!) nodes
         * @param {Immutable.Map} tree
         * @return {Integer}
         */
        var getTotalReordableNodesCountInTree$2 = function getTotalReordableNodesCountInTree(tree) {
          if (!tree) return -1;
          var cnt = 0;
          function _processNode(item, path, lev) {
            var id, children, type;
            if (typeof item.get === "function") {
              id = item.get("id");
              children = item.get("children1");
              type = item.get("type");
            } else {
              id = item.id;
              children = item.children1;
              type = item.type;
            }
            var isRuleGroup = type == "rule_group";
            cnt++;
            //tip: rules in rule-group can be reordered only inside
            if (children && !isRuleGroup) {
              children.map(function (child, _childId) {
                _processNode(child, path.concat(id));
              });
            }
          }
          _processNode(tree, []);
          return cnt - 1; // -1 for root
        };

        /**
         * Returns count of rules (leafs, i.e. don't count groups)
         * @param {Immutable.Map} tree
         * @return {Integer}
         */
        var getTotalRulesCountInTree$2 = function getTotalRulesCountInTree(tree) {
          if (!tree) return -1;
          var cnt = 0;
          function _processNode(item, path, lev) {
            var id, children, type;
            if (typeof item.get === "function") {
              id = item.get("id");
              children = item.get("children1");
              type = item.get("type");
            } else {
              id = item.id;
              children = item.children1;
              type = item.type;
            }
            if (type == "rule" || type == "rule_group") {
              // tip: count rule_group as 1 rule
              cnt++;
            } else if (children) {
              children.map(function (child, _childId) {
                _processNode(child, path.concat(id));
              });
            }
          }
          _processNode(tree, []);
          return cnt;
        };
        var getTreeBadFields = function getTreeBadFields(tree) {
          var badFields = [];
          function _processNode(item, path, lev) {
            var id = item.get("id");
            var children = item.get("children1");
            var valueError = item.getIn(["properties", "valueError"]);
            var field = item.getIn(["properties", "field"]);
            if (valueError && valueError.size > 0 && valueError.filter(function (v) {
              return v != null;
            }).size > 0) {
              badFields.push(field);
            }
            if (children) {
              children.map(function (child, _childId) {
                _processNode(child, path.concat(id));
              });
            }
          }
          if (tree) _processNode(tree, []);
          return Array.from(new Set(badFields));
        };

        // Remove fields that can be calced: "id", "path"
        // Remove empty fields: "operatorOptions"
        var getLightTree = function getLightTree(tree) {
          var children1AsArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var newTree = tree;
          function _processNode(item, itemId) {
            if (item.path) delete item.path;
            if (!children1AsArray && itemId) delete item.id;
            var properties = item.properties;
            if (properties) {
              if (properties.operatorOptions == null) delete properties.operatorOptions;
            }
            var children = item.children1;
            if (children) {
              for (var id in children) {
                _processNode(children[id], id);
              }
              if (children1AsArray) {
                item.children1 = Object.values(children);
              }
            }
          }
          _processNode(tree, null);
          return newTree;
        };
        var getSwitchValues = function getSwitchValues(tree) {
          var vals = [];
          var children = tree.get("children1");
          if (children) {
            children.map(function (child) {
              var value = child.getIn(["properties", "value"]);
              var caseValue;
              if (value && value.size == 1) {
                caseValue = value.get(0);
                if (Array.isArray(caseValue) && caseValue.length == 0) {
                  caseValue = null;
                }
              } else {
                caseValue = null;
              }
              vals = [].concat(_toConsumableArray(vals), [caseValue]);
            });
          }
          return vals;
        };
        var isEmptyTree = function isEmptyTree(tree) {
          return !tree.get("children1") || tree.get("children1").size == 0;
        };
        var hasChildren = function hasChildren(tree, path) {
          return tree.getIn(expandTreePath(path, "children1")).size > 0;
        };
        const treeUtils = /*#__PURE__*/Object.freeze( /*#__PURE__*/Object.defineProperty({
          __proto__: null,
          expandTreePath,
          expandTreeSubpath,
          fixEmptyGroupsInTree,
          fixPathsInTree,
          getFlatTree: getFlatTree$1,
          getItemByPath,
          getLightTree,
          getSwitchValues,
          getTotalReordableNodesCountInTree: getTotalReordableNodesCountInTree$2,
          getTotalRulesCountInTree: getTotalRulesCountInTree$2,
          getTreeBadFields,
          hasChildren,
          isEmptyTree,
          removeIsLockedInTree,
          removePathsInTree
        }, Symbol.toStringTag, {
          value: 'Module'
        }));

        /**
         * Gets the last element of `array`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to query.
         * @returns {*} Returns the last element of `array`.
         * @example
         *
         * _.last([1, 2, 3]);
         * // => 3
         */

        function last$1(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined;
        }
        var last_1 = last$1;
        const last$2 = /*@__PURE__*/getDefaultExportFromCjs(last_1);

        /**
         * The base implementation of `_.slice` without an iteratee call guard.
         *
         * @private
         * @param {Array} array The array to slice.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the slice of `array`.
         */

        function baseSlice$1(array, start, end) {
          var index = -1,
            length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result = Array(length);
          while (++index < length) {
            result[index] = array[index + start];
          }
          return result;
        }
        var _baseSlice = baseSlice$1;
        var baseGet$1 = _baseGet,
          baseSlice = _baseSlice;

        /**
         * Gets the parent value at `path` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} path The path to get the parent value of.
         * @returns {*} Returns the parent value.
         */
        function parent$1(object, path) {
          return path.length < 2 ? object : baseGet$1(object, baseSlice(path, 0, -1));
        }
        var _parent = parent$1;
        var castPath$3 = _castPath,
          last = last_1,
          parent = _parent,
          toKey$1 = _toKey;

        /**
         * The base implementation of `_.unset`.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {Array|string} path The property path to unset.
         * @returns {boolean} Returns `true` if the property is deleted, else `false`.
         */
        function baseUnset$1(object, path) {
          path = castPath$3(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey$1(last(path))];
        }
        var _baseUnset = baseUnset$1;
        var isPlainObject = isPlainObject_1;

        /**
         * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
         * objects.
         *
         * @private
         * @param {*} value The value to inspect.
         * @param {string} key The key of the property to inspect.
         * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
         */
        function customOmitClone$1(value) {
          return isPlainObject(value) ? undefined : value;
        }
        var _customOmitClone = customOmitClone$1;
        var Symbol$1 = _Symbol,
          isArguments = isArguments_1,
          isArray = isArray_1;

        /** Built-in value references. */
        var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : undefined;

        /**
         * Checks if `value` is a flattenable `arguments` object or array.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
         */
        function isFlattenable$1(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        var _isFlattenable = isFlattenable$1;
        var arrayPush = _arrayPush,
          isFlattenable = _isFlattenable;

        /**
         * The base implementation of `_.flatten` with support for restricting flattening.
         *
         * @private
         * @param {Array} array The array to flatten.
         * @param {number} depth The maximum recursion depth.
         * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
         * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
         * @param {Array} [result=[]] The initial result value.
         * @returns {Array} Returns the new flattened array.
         */
        function baseFlatten$1(array, depth, predicate, isStrict, result) {
          var index = -1,
            length = array.length;
          predicate || (predicate = isFlattenable);
          result || (result = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                // Recursively flatten arrays (susceptible to call stack limits).
                baseFlatten$1(value, depth - 1, predicate, isStrict, result);
              } else {
                arrayPush(result, value);
              }
            } else if (!isStrict) {
              result[result.length] = value;
            }
          }
          return result;
        }
        var _baseFlatten = baseFlatten$1;
        var baseFlatten = _baseFlatten;

        /**
         * Flattens `array` a single level deep.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to flatten.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * _.flatten([1, [2, [3, [4]], 5]]);
         * // => [1, 2, [3, [4]], 5]
         */
        function flatten$1(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        var flatten_1 = flatten$1;
        var flatten = flatten_1,
          overRest = _overRest,
          setToString = _setToString;

        /**
         * A specialized version of `baseRest` which flattens the rest array.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @returns {Function} Returns the new function.
         */
        function flatRest$2(func) {
          return setToString(overRest(func, undefined, flatten), func + '');
        }
        var _flatRest = flatRest$2;
        var arrayMap$1 = _arrayMap,
          baseClone = _baseClone,
          baseUnset = _baseUnset,
          castPath$2 = _castPath,
          copyObject = _copyObject,
          customOmitClone = _customOmitClone,
          flatRest$1 = _flatRest,
          getAllKeysIn$1 = _getAllKeysIn;

        /** Used to compose bitmasks for cloning. */
        var CLONE_DEEP_FLAG = 1,
          CLONE_FLAT_FLAG = 2,
          CLONE_SYMBOLS_FLAG = 4;

        /**
         * The opposite of `_.pick`; this method creates an object composed of the
         * own and inherited enumerable property paths of `object` that are not omitted.
         *
         * **Note:** This method is considerably slower than `_.pick`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {...(string|string[])} [paths] The property paths to omit.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.omit(object, ['a', 'c']);
         * // => { 'b': '2' }
         */
        var omit = flatRest$1(function (object, paths) {
          var result = {};
          if (object == null) {
            return result;
          }
          var isDeep = false;
          paths = arrayMap$1(paths, function (path) {
            path = castPath$2(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn$1(object), result);
          if (isDeep) {
            result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result, paths[length]);
          }
          return result;
        });
        var omit_1 = omit;
        const omit$1 = /*@__PURE__*/getDefaultExportFromCjs(omit_1);
        var typeOf = function typeOf(v) {
          if (_typeof$2(v) == "object" && v !== null && Array.isArray(v)) return "array";else return _typeof$2(v);
        };
        var isTypeOf = function isTypeOf(v, type) {
          if (typeOf(v) == type) return true;
          if (type == "number" && !isNaN(v)) return true; //can be casted
          return false;
        };
        var validateAndFixTree$1 = function validateAndFixTree(newTree, _oldTree, newConfig, oldConfig, removeEmptyGroups, removeIncompleteRules) {
          var tree = validateTree(newTree, _oldTree, newConfig, oldConfig, removeEmptyGroups, removeIncompleteRules);
          tree = fixPathsInTree(tree);
          return tree;
        };
        var validateTree = function validateTree(tree, _oldTree, config, oldConfig, removeEmptyGroups, removeIncompleteRules) {
          if (removeEmptyGroups === undefined) {
            removeEmptyGroups = config.settings.removeEmptyGroupsOnLoad;
          }
          if (removeIncompleteRules === undefined) {
            removeIncompleteRules = config.settings.removeIncompleteRulesOnLoad;
          }
          var c = {
            config: config,
            oldConfig: oldConfig,
            removeEmptyGroups: removeEmptyGroups,
            removeIncompleteRules: removeIncompleteRules
          };
          return validateItem(tree, [], null, {}, c);
        };
        function validateItem(item, path, itemId, meta, c) {
          var type = item.get("type");
          var children = item.get("children1");
          if ((type === "group" || type === "rule_group" || type == "case_group" || type == "switch_group") && children && children.size) {
            return validateGroup(item, path, itemId, meta, c);
          } else if (type === "rule") {
            return validateRule(item, path, itemId, meta, c);
          } else {
            return item;
          }
        }
        function validateGroup(item, path, itemId, meta, c) {
          var removeEmptyGroups = c.removeEmptyGroups;
          var id = item.get("id");
          var children = item.get("children1");
          var oldChildren = children;
          if (!id && itemId) {
            id = itemId;
            item = item.set("id", id);
            meta.sanitized = true;
          }

          //validate children
          var submeta = {};
          children = children.map(function (currentChild, childId) {
            return validateItem(currentChild, path.concat(id), childId, submeta, c);
          });
          if (removeEmptyGroups) children = children.filter(function (currentChild) {
            return currentChild != undefined;
          });
          var sanitized = submeta.sanitized || oldChildren.size != children.size;
          if (!children.size && removeEmptyGroups && path.length) {
            sanitized = true;
            item = undefined;
          }
          if (sanitized) meta.sanitized = true;
          if (sanitized && item) item = item.set("children1", children);
          return item;
        }
        function validateRule(item, path, itemId, meta, c) {
          var removeIncompleteRules = c.removeIncompleteRules,
            config = c.config,
            oldConfig = c.oldConfig;
          var showErrorMessage = config.settings.showErrorMessage;
          var id = item.get("id");
          var properties = item.get("properties");
          var field = properties.get("field") || null;
          var operator = properties.get("operator") || null;
          var operatorOptions = properties.get("operatorOptions");
          var valueSrc = properties.get("valueSrc");
          var value = properties.get("value");
          var valueError = properties.get("valueError");
          var oldSerialized = {
            field: field,
            operator: operator,
            operatorOptions: operatorOptions ? operatorOptions.toJS() : {},
            valueSrc: valueSrc ? valueSrc.toJS() : null,
            value: value ? value.toJS() : null,
            valueError: valueError ? valueError.toJS() : null
          };
          field && operator && value && !value.includes(undefined);
          if (!id && itemId) {
            id = itemId;
            item = item.set("id", id);
            meta.sanitized = true;
          }

          //validate field
          var fieldDefinition = field ? getFieldConfig$8(config, field) : null;
          if (field && !fieldDefinition) {
            logger$1.warn("No config for field ".concat(field));
            field = null;
          }
          if (field == null) {
            properties = ["operator", "operatorOptions", "valueSrc", "value"].reduce(function (map, key) {
              return map["delete"](key);
            }, properties);
            operator = null;
          }

          //validate operator
          // Backward compatibility: obsolete operator range_between
          if (operator == "range_between" || operator == "range_not_between") {
            operator = operator == "range_between" ? "between" : "not_between";
            console.info("Fixed operator ".concat(properties.get("operator"), " to ").concat(operator));
            properties = properties.set("operator", operator);
          }
          var operatorDefinition = operator ? getOperatorConfig$4(config, operator, field) : null;
          if (operator && !operatorDefinition) {
            console.warn("No config for operator ".concat(operator));
            operator = null;
          }
          var availOps = field ? getOperatorsForField(config, field) : [];
          if (!availOps) {
            console.warn("Type of field ".concat(field, " is not supported"));
            operator = null;
          } else if (operator && availOps.indexOf(operator) == -1) {
            if (operator == "is_empty" || operator == "is_not_empty") {
              // Backward compatibility: is_empty #494
              operator = operator == "is_empty" ? "is_null" : "is_not_null";
              console.info("Fixed operator ".concat(properties.get("operator"), " to ").concat(operator, " for ").concat(field));
              properties = properties.set("operator", operator);
            } else {
              console.warn("Operator ".concat(operator, " is not supported for field ").concat(field));
              operator = null;
            }
          }
          if (operator == null) {
            properties = properties["delete"]("operatorOptions");
            properties = properties["delete"]("valueSrc");
            properties = properties["delete"]("value");
          }

          //validate operator options
          operatorOptions = properties.get("operatorOptions");
          operator ? defaultValue$1(operatorDefinition.cardinality, 1) : null;
          if (!operator || operatorOptions && !operatorDefinition.options) {
            operatorOptions = null;
            properties = properties["delete"]("operatorOptions");
          } else if (operator && !operatorOptions && operatorDefinition.options) {
            operatorOptions = defaultOperatorOptions(config, operator, field);
            properties = properties.set("operatorOptions", operatorOptions);
          }

          //validate values
          valueSrc = properties.get("valueSrc");
          value = properties.get("value");
          var canFix = !showErrorMessage;
          var isEndValue = true;
          var _getNewValueForFieldO = getNewValueForFieldOp(config, oldConfig, properties, field, operator, null, canFix, isEndValue),
            newValue = _getNewValueForFieldO.newValue,
            newValueSrc = _getNewValueForFieldO.newValueSrc,
            newValueError = _getNewValueForFieldO.newValueError;
          value = newValue;
          valueSrc = newValueSrc;
          valueError = newValueError;
          properties = properties.set("value", value);
          properties = properties.set("valueSrc", valueSrc);
          if (showErrorMessage) {
            properties = properties.set("valueError", valueError);
          }
          var newSerialized = {
            field: field,
            operator: operator,
            operatorOptions: operatorOptions ? operatorOptions.toJS() : {},
            valueSrc: valueSrc ? valueSrc.toJS() : null,
            value: value ? value.toJS() : null,
            valueError: valueError ? valueError.toJS() : null
          };
          var sanitized = !deepEqual(oldSerialized, newSerialized);
          var isComplete = field && operator && value && !value.includes(undefined);
          if (sanitized) meta.sanitized = true;
          if (!isComplete && removeIncompleteRules) item = undefined;else if (sanitized) item = item.set("properties", properties);
          return item;
        }

        /**
         * 
         * @param {bool} canFix true is useful for func values to remove bad args
         * @param {bool} isEndValue false if value is in process of editing by user
         * @param {bool} isRawValue false is used only internally from validateFuncValue
         * @return {array} [validError, fixedValue] - if validError === null and canFix == true, fixedValue can differ from value if was fixed
         */
        var validateValue = function validateValue(config, leftField, field, operator, value, valueType, valueSrc, asyncListValues) {
          var canFix = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
          var isEndValue = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;
          var isRawValue = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : true;
          var validError = null;
          var fixedValue = value;
          if (value != null) {
            if (valueSrc == "field") {
              var _validateFieldValue = validateFieldValue(leftField, field, value, valueSrc, valueType, asyncListValues, config);
              var _validateFieldValue2 = _slicedToArray$1(_validateFieldValue, 2);
              validError = _validateFieldValue2[0];
              fixedValue = _validateFieldValue2[1];
            } else if (valueSrc == "func") {
              var _validateFuncValue = validateFuncValue(leftField, field, value, valueSrc, valueType, asyncListValues, config, operator, isEndValue, canFix);
              var _validateFuncValue2 = _slicedToArray$1(_validateFuncValue, 2);
              validError = _validateFuncValue2[0];
              fixedValue = _validateFuncValue2[1];
            } else if (valueSrc == "value" || !valueSrc) {
              var _validateNormalValue = validateNormalValue(leftField, field, value, valueSrc, valueType, asyncListValues, config, operator, isEndValue, canFix);
              var _validateNormalValue2 = _slicedToArray$1(_validateNormalValue, 2);
              validError = _validateNormalValue2[0];
              fixedValue = _validateNormalValue2[1];
            }
            if (!validError) {
              getFieldConfig$8(config, field);
              var w = getWidgetForFieldOp$3(config, field, operator, valueSrc);
              var operatorDefinition = operator ? getOperatorConfig$4(config, operator, field) : null;
              var fieldWidgetDefinition = omit$1(getFieldWidgetConfig$3(config, field, operator, w, valueSrc), ["factory"]);
              var rightFieldDefinition = valueSrc == "field" ? getFieldConfig$8(config, value) : null;
              var fieldSettings = fieldWidgetDefinition; // widget definition merged with fieldSettings

              var fn = fieldWidgetDefinition.validateValue;
              if (typeof fn == "function") {
                var args = [fixedValue, fieldSettings, operator, operatorDefinition];
                if (valueSrc == "field") args.push(rightFieldDefinition);
                var validResult = fn.apply(void 0, args);
                if (typeof validResult == "boolean") {
                  if (validResult == false) validError = "Invalid value";
                } else {
                  validError = validResult;
                }
              }
            }
          }
          if (isRawValue && validError) {
            console.warn("[RAQB validate]", "Field ".concat(field, ": ").concat(validError));
          }
          return [validError, fixedValue];
        };
        var validateValueInList = function validateValueInList(value, listValues, canFix, isEndValue, removeInvalidMultiSelectValuesOnLoad) {
          var values = immutableExports.List.isList(value) ? value.toJS() : value instanceof Array ? _toConsumableArray(value) : undefined;
          if (values) {
            var _values$reduce = values.reduce(function (_ref, val) {
                var _ref2 = _slicedToArray$1(_ref, 2),
                  goodVals = _ref2[0],
                  badVals = _ref2[1];
                var vv = getItemInListValues(listValues, val);
                if (vv == undefined) {
                  return [goodVals, [].concat(_toConsumableArray(badVals), [val])];
                } else {
                  return [[].concat(_toConsumableArray(goodVals), [vv.value]), badVals];
                }
              }, [[], []]),
              _values$reduce2 = _slicedToArray$1(_values$reduce, 2),
              goodValues = _values$reduce2[0],
              badValues = _values$reduce2[1];
            var plural = badValues.length > 1;
            var err = badValues.length ? "".concat(plural ? "Values" : "Value", " ").concat(badValues.join(", "), " ").concat(plural ? "are" : "is", " not in list of values") : null;
            // always remove bad values at tree validation as user can't unselect them (except AntDesign widget)
            if (removeInvalidMultiSelectValuesOnLoad !== undefined) {
              canFix = removeInvalidMultiSelectValuesOnLoad;
            } else {
              canFix = canFix || isEndValue;
            }
            return [err, canFix ? goodValues : value];
          } else {
            var vv = getItemInListValues(listValues, value);
            if (vv == undefined) {
              return ["Value ".concat(value, " is not in list of values"), value];
            } else {
              value = vv.value;
            }
            return [null, value];
          }
        };

        /**
        * 
        */
        var validateNormalValue = function validateNormalValue(leftField, field, value, valueSrc, valueType, asyncListValues, config) {
          var operator = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
          var isEndValue = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
          var canFix = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;
          if (field) {
            var fieldConfig = getFieldConfig$8(config, field);
            var w = getWidgetForFieldOp$3(config, field, operator, valueSrc);
            var wConfig = config.widgets[w];
            var wType = wConfig.type;
            var jsType = wConfig.jsType;
            var fieldSettings = fieldConfig.fieldSettings;
            var listValues = fieldSettings.treeValues || fieldSettings.listValues;
            if (valueType && valueType != wType) return ["Value should have type ".concat(wType, ", but got value of type ").concat(valueType), value];
            if (jsType && !isTypeOf(value, jsType) && !listValues) {
              //tip: can skip type check for listValues
              return ["Value should have JS type ".concat(jsType, ", but got value of type ").concat(_typeof$2(value)), value];
            }
            if (fieldSettings) {
              var realListValues = asyncListValues || listValues;
              if (realListValues && !fieldSettings.allowCustomValues) {
                return validateValueInList(value, realListValues, canFix, isEndValue, config.settings.removeInvalidMultiSelectValuesOnLoad);
              }
              if (fieldSettings.min != null && value < fieldSettings.min) {
                return ["Value ".concat(value, " < min ").concat(fieldSettings.min), canFix ? fieldSettings.min : value];
              }
              if (fieldSettings.max != null && value > fieldSettings.max) {
                return ["Value ".concat(value, " > max ").concat(fieldSettings.max), canFix ? fieldSettings.max : value];
              }
            }
          }
          return [null, value];
        };

        /**
        * 
        */
        var validateFieldValue = function validateFieldValue(leftField, field, value, _valueSrc, valueType, asyncListValues, config) {
          var fieldSeparator = config.settings.fieldSeparator;
          var isFuncArg = _typeof$2(field) == "object" && (field === null || field === void 0 ? void 0 : field._isFuncArg);
          var leftFieldStr = Array.isArray(leftField) ? leftField.join(fieldSeparator) : leftField;
          var rightFieldStr = Array.isArray(value) ? value.join(fieldSeparator) : value;
          var rightFieldDefinition = getFieldConfig$8(config, value);
          if (!rightFieldDefinition) return ["Unknown field ".concat(value), value];
          if (rightFieldStr == leftFieldStr && !isFuncArg) return ["Can't compare field ".concat(leftField, " with itself"), value];
          if (valueType && valueType != rightFieldDefinition.type) return ["Field ".concat(value, " is of type ").concat(rightFieldDefinition.type, ", but expected ").concat(valueType), value];
          return [null, value];
        };

        /**
        * 
        */
        var validateFuncValue = function validateFuncValue(leftField, field, value, _valueSrc, valueType, asyncListValues, config) {
          var operator = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
          var isEndValue = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
          var canFix = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;
          var fixedValue = value;
          if (value) {
            var funcKey = value.get("func");
            if (funcKey) {
              var funcConfig = getFuncConfig$2(config, funcKey);
              if (funcConfig) {
                if (valueType && funcConfig.returnType != valueType) return ["Function ".concat(funcKey, " should return value of type ").concat(funcConfig.returnType, ", but got ").concat(valueType), value];
                for (var argKey in funcConfig.args) {
                  var argConfig = funcConfig.args[argKey];
                  var args = fixedValue.get("args");
                  var argVal = args ? args.get(argKey) : undefined;
                  var fieldDef = getFieldConfig$8(config, argConfig);
                  var argValue = argVal ? argVal.get("value") : undefined;
                  var argValueSrc = argVal ? argVal.get("valueSrc") : undefined;
                  if (argValue !== undefined) {
                    var _validateValue = validateValue(config, leftField, fieldDef, operator, argValue, argConfig.type, argValueSrc, asyncListValues, canFix, isEndValue, false),
                      _validateValue2 = _slicedToArray$1(_validateValue, 2),
                      argValidError = _validateValue2[0],
                      fixedArgVal = _validateValue2[1];
                    if (argValidError !== null) {
                      if (canFix) {
                        fixedValue = fixedValue.deleteIn(["args", argKey]);
                        if (argConfig.defaultValue !== undefined) {
                          fixedValue = fixedValue.setIn(["args", argKey, "value"], argConfig.defaultValue);
                          fixedValue = fixedValue.setIn(["args", argKey, "valueSrc"], "value");
                        }
                      } else {
                        return ["Invalid value of arg ".concat(argKey, " for func ").concat(funcKey, ": ").concat(argValidError), value];
                      }
                    } else if (fixedArgVal !== argValue) {
                      fixedValue = fixedValue.setIn(["args", argKey, "value"], fixedArgVal);
                    }
                  } else if (isEndValue && argConfig.defaultValue === undefined && !canFix) {
                    return ["Value of arg ".concat(argKey, " for func ").concat(funcKey, " is required"), value];
                  }
                }
              } else return ["Unknown function ".concat(funcKey), value];
            } // else it's not function value
          } // empty value

          return [null, fixedValue];
        };
        var selectTypes = ["select", "multiselect", "treeselect", "treemultiselect"];

        /**
         * @param {object} config
         * @param {object} oldConfig
         * @param {Immutable.Map} current
         * @param {string} newField
         * @param {string} newOperator
         * @param {string} changedProp
         * @return {object} - {canReuseValue, newValue, newValueSrc, newValueType, newValueError}
         */
        var getNewValueForFieldOp = function getNewValueForFieldOp(config) {
          var oldConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var current = arguments.length > 2 ? arguments[2] : undefined;
          var newField = arguments.length > 3 ? arguments[3] : undefined;
          var newOperator = arguments.length > 4 ? arguments[4] : undefined;
          var changedProp = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
          var canFix = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;
          var isEndValue = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
          if (!oldConfig) oldConfig = config;
          var currentField = current.get("field");
          var currentOperator = current.get("operator");
          var currentValue = current.get("value");
          var currentValueSrc = current.get("valueSrc", new Immutable.List());
          var currentValueType = current.get("valueType", new Immutable.List());
          var currentAsyncListValues = current.get("asyncListValues");

          //const isValidatingTree = (changedProp === null);
          var _config$settings = config.settings,
            convertableWidgets = _config$settings.convertableWidgets,
            clearValueOnChangeField = _config$settings.clearValueOnChangeField,
            clearValueOnChangeOp = _config$settings.clearValueOnChangeOp,
            showErrorMessage = _config$settings.showErrorMessage;

          //const currentOperatorConfig = getOperatorConfig(oldConfig, currentOperator, currentField);
          var newOperatorConfig = getOperatorConfig$4(config, newOperator, newField);
          //const currentOperatorCardinality = currentOperator ? defaultValue(currentOperatorConfig.cardinality, 1) : null;
          var operatorCardinality = newOperator ? defaultValue$1(newOperatorConfig.cardinality, 1) : null;
          var currentFieldConfig = getFieldConfig$8(oldConfig, currentField);
          var newFieldConfig = getFieldConfig$8(config, newField);
          var canReuseValue = currentField && currentOperator && newOperator && currentValue != undefined && (!changedProp || changedProp == "field" && !clearValueOnChangeField || changedProp == "operator" && !clearValueOnChangeOp) && currentFieldConfig && newFieldConfig && currentFieldConfig.type == newFieldConfig.type;
          if (canReuseValue && selectTypes.includes(currentFieldConfig.type) && changedProp == "field") {
            // different fields of select types has different listValues
            canReuseValue = false;
          }

          // compare old & new widgets
          for (var i = 0; i < operatorCardinality; i++) {
            var vs = currentValueSrc.get(i) || null;
            var currentWidget = getWidgetForFieldOp$3(oldConfig, currentField, currentOperator, vs);
            var newWidget = getWidgetForFieldOp$3(config, newField, newOperator, vs);
            // need to also check value widgets if we changed operator and current value source was 'field'
            // cause for select type op '=' requires single value and op 'in' requires array value
            var currentValueWidget = vs == "value" ? currentWidget : getWidgetForFieldOp$3(oldConfig, currentField, currentOperator, "value");
            var newValueWidget = vs == "value" ? newWidget : getWidgetForFieldOp$3(config, newField, newOperator, "value");
            var canReuseWidget = newValueWidget == currentValueWidget || (convertableWidgets[currentValueWidget] || []).includes(newValueWidget);
            if (!canReuseWidget) canReuseValue = false;
          }
          if (currentOperator != newOperator && [currentOperator, newOperator].includes("proximity")) canReuseValue = false;
          var firstWidgetConfig = getFieldWidgetConfig$3(config, newField, newOperator, null, currentValueSrc.first());
          var valueSources = getValueSourcesForFieldOp$1(config, newField, newOperator);
          var valueFixes = {};
          var valueErrors = Array.from({
            length: operatorCardinality
          }, function () {
            return null;
          });
          if (canReuseValue) {
            var _loop = function _loop() {
              var v = currentValue.get(_i);
              var vType = currentValueType.get(_i) || null;
              var vSrc = currentValueSrc.get(_i) || null;
              var isValidSrc = valueSources.find(function (v) {
                return v == vSrc;
              }) != null;
              if (!isValidSrc && _i > 0 && vSrc == null) isValidSrc = true; // make exception for range widgets (when changing op from '==' to 'between')
              var asyncListValues = currentAsyncListValues;
              var _validateValue = validateValue(config, newField, newField, newOperator, v, vType, vSrc, asyncListValues, canFix, isEndValue),
                _validateValue2 = _slicedToArray$1(_validateValue, 2),
                validateError = _validateValue2[0],
                fixedValue = _validateValue2[1];
              var isValid = !validateError;
              // Allow bad value with error message
              // But not on field change - in that case just drop bad value that can't be reused
              // ? Maybe we should also drop bad value on op change?
              // For bad multiselect value we have both error message + fixed value.
              //  If we show error message, it will gone on next tree validation
              var fixValue = fixedValue !== v;
              var dropValue = !isValidSrc || !isValid && (changedProp == "field" || !showErrorMessage && !fixValue);
              var showValueError = !!validateError && showErrorMessage && !dropValue && !fixValue;
              if (showValueError) {
                valueErrors[_i] = validateError;
              }
              if (fixValue) {
                valueFixes[_i] = fixedValue;
              }
              if (dropValue) {
                canReuseValue = false;
                return "break";
              }
            };
            for (var _i = 0; _i < operatorCardinality; _i++) {
              var _ret = _loop();
              if (_ret === "break") break;
            }
          }

          // reuse value OR get defaultValue for cardinality 1 (it means default range values is not supported yet, todo)
          var newValue = null,
            newValueSrc = null,
            newValueType = null,
            newValueError = null;
          newValue = new Immutable.List(Array.from({
            length: operatorCardinality
          }, function (_ignore, i) {
            var v = undefined;
            if (canReuseValue) {
              if (i < currentValue.size) {
                v = currentValue.get(i);
                if (valueFixes[i] !== undefined) {
                  v = valueFixes[i];
                }
              }
            } else if (operatorCardinality == 1) {
              var _newFieldConfig$field;
              v = getFirstDefined([newFieldConfig === null || newFieldConfig === void 0 ? void 0 : newFieldConfig.defaultValue, newFieldConfig === null || newFieldConfig === void 0 ? void 0 : (_newFieldConfig$field = newFieldConfig.fieldSettings) === null || _newFieldConfig$field === void 0 ? void 0 : _newFieldConfig$field.defaultValue, firstWidgetConfig === null || firstWidgetConfig === void 0 ? void 0 : firstWidgetConfig.defaultValue]);
            }
            return v;
          }));
          newValueSrc = new Immutable.List(Array.from({
            length: operatorCardinality
          }, function (_ignore, i) {
            var vs = null;
            if (canReuseValue) {
              if (i < currentValueSrc.size) vs = currentValueSrc.get(i);
            } else if (valueSources.length == 1) {
              vs = valueSources[0];
            } else if (valueSources.length > 1) {
              vs = valueSources[0];
            }
            return vs;
          }));
          if (showErrorMessage) {
            if (newOperatorConfig && newOperatorConfig.validateValues && newValueSrc.toJS().filter(function (vs) {
              return vs == "value" || vs == null;
            }).length == operatorCardinality) {
              // last element in `valueError` list is for range validation error
              var jsValues = firstWidgetConfig && firstWidgetConfig.toJS ? newValue.toJS().map(function (v) {
                return firstWidgetConfig.toJS(v, firstWidgetConfig);
              }) : newValue.toJS();
              var rangeValidateError = newOperatorConfig.validateValues(jsValues);
              if (showErrorMessage) {
                valueErrors.push(rangeValidateError);
              }
            }
            newValueError = new Immutable.List(valueErrors);
          }
          newValueType = new Immutable.List(Array.from({
            length: operatorCardinality
          }, function (_ignore, i) {
            var vt = null;
            if (canReuseValue) {
              if (i < currentValueType.size) vt = currentValueType.get(i);
            } else if (operatorCardinality == 1 && firstWidgetConfig && firstWidgetConfig.type !== undefined) {
              vt = firstWidgetConfig.type;
            } else if (operatorCardinality == 1 && newFieldConfig && newFieldConfig.type !== undefined) {
              vt = newFieldConfig.type == "!group" ? "number" : newFieldConfig.type;
            }
            return vt;
          }));
          return {
            canReuseValue: canReuseValue,
            newValue: newValue,
            newValueSrc: newValueSrc,
            newValueType: newValueType,
            newValueError: newValueError,
            operatorCardinality: operatorCardinality
          };
        };
        var getFirstField = function getFirstField(config) {
          var parentRuleGroupPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var fieldSeparator = config.settings.fieldSeparator;
          var parentPathArr = typeof parentRuleGroupPath == "string" ? parentRuleGroupPath.split(fieldSeparator) : parentRuleGroupPath;
          var parentField = parentRuleGroupPath ? getFieldRawConfig(config, parentRuleGroupPath) : config;
          var firstField = parentField,
            key = null,
            keysPath = [];
          do {
            var subfields = firstField === config ? config.fields : firstField.subfields;
            if (!subfields || !Object.keys(subfields).length) {
              firstField = key = null;
              break;
            }
            key = Object.keys(subfields)[0];
            keysPath.push(key);
            firstField = subfields[key];
          } while (firstField.type == "!struct" || firstField.type == "!group");
          return (parentPathArr || []).concat(keysPath).join(fieldSeparator);
        };
        var getOperatorsForField = function getOperatorsForField(config, field) {
          var fieldConfig = getFieldConfig$8(config, field);
          var fieldOps = fieldConfig ? fieldConfig.operators : [];
          return fieldOps;
        };
        var getFirstOperator = function getFirstOperator(config, field) {
          var fieldOps = getOperatorsForField(config, field);
          return fieldOps ? fieldOps[0] : null;
        };
        var getFieldPath$3 = function getFieldPath(field, config) {
          var onlyKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          if (!field) return null;
          var fieldSeparator = config.settings.fieldSeparator;
          var parts = Array.isArray(field) ? field : field.split(fieldSeparator);
          if (onlyKeys) return parts;else return parts.map(function (_curr, ind, arr) {
            return arr.slice(0, ind + 1);
          }).map(function (parts) {
            return parts.join(fieldSeparator);
          });
        };
        var getFuncPathLabels$1 = function getFuncPathLabels(field, config) {
          var parentField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          return getFieldPathLabels$3(field, config, parentField, "funcs", "subfields");
        };
        var getFieldPathLabels$3 = function getFieldPathLabels(field, config) {
          var parentField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          var fieldsKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "fields";
          var subfieldsKey = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "subfields";
          if (!field) return null;
          var fieldSeparator = config.settings.fieldSeparator;
          var parts = Array.isArray(field) ? field : field.split(fieldSeparator);
          var parentParts = parentField ? Array.isArray(parentField) ? parentField : parentField.split(fieldSeparator) : [];
          return parts.slice(parentParts.length).map(function (_curr, ind, arr) {
            return arr.slice(0, ind + 1);
          }).map(function (parts) {
            return [].concat(_toConsumableArray(parentParts), _toConsumableArray(parts)).join(fieldSeparator);
          }).map(function (part) {
            var cnf = getFieldRawConfig(config, part, fieldsKey, subfieldsKey);
            return cnf && cnf.label || cnf && last$2(part.split(fieldSeparator));
          }).filter(function (label) {
            return label != null;
          });
        };
        var getFieldPartsConfigs = function getFieldPartsConfigs(field, config) {
          var parentField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          if (!field) return null;
          var parentFieldDef = parentField && getFieldRawConfig(config, parentField) || null;
          var fieldSeparator = config.settings.fieldSeparator;
          var parts = Array.isArray(field) ? field : field.split(fieldSeparator);
          var parentParts = parentField ? Array.isArray(parentField) ? parentField : parentField.split(fieldSeparator) : [];
          return parts.slice(parentParts.length).map(function (_curr, ind, arr) {
            return arr.slice(0, ind + 1);
          }).map(function (parts) {
            return {
              part: [].concat(_toConsumableArray(parentParts), _toConsumableArray(parts)).join(fieldSeparator),
              key: parts[parts.length - 1]
            };
          }).map(function (_ref) {
            var part = _ref.part,
              key = _ref.key;
            var cnf = getFieldRawConfig(config, part);
            return {
              key: key,
              cnf: cnf
            };
          }).map(function (_ref2, ind, arr) {
            var key = _ref2.key,
              cnf = _ref2.cnf;
            var parentCnf = ind > 0 ? arr[ind - 1].cnf : parentFieldDef;
            return [key, cnf, parentCnf];
          });
        };
        var getValueLabel$1 = function getValueLabel(config, field, operator, delta) {
          var valueSrc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          var isSpecialRange = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
          var isFuncArg = field && _typeof$2(field) == "object" && !!field.func && !!field.arg;
          var showLabels = config.settings.showLabels;
          var fieldConfig = getFieldConfig$8(config, field);
          var fieldWidgetConfig = getFieldWidgetConfig$3(config, field, operator, null, valueSrc) || {};
          var mergedOpConfig = getOperatorConfig$4(config, operator, field) || {};
          var cardinality = isSpecialRange ? 1 : mergedOpConfig.cardinality;
          var ret = null;
          if (cardinality > 1) {
            var valueLabels = fieldWidgetConfig.valueLabels || mergedOpConfig.valueLabels;
            if (valueLabels) ret = valueLabels[delta];
            if (ret && _typeof$2(ret) != "object") {
              ret = {
                label: ret,
                placeholder: ret
              };
            }
            if (!ret) {
              ret = {
                label: config.settings.valueLabel + " " + (delta + 1),
                placeholder: config.settings.valuePlaceholder + " " + (delta + 1)
              };
            }
          } else {
            var label = fieldWidgetConfig.valueLabel;
            var placeholder = fieldWidgetConfig.valuePlaceholder;
            if (isFuncArg) {
              if (!label) label = fieldConfig.label || field.arg;
              if (!placeholder && !showLabels) placeholder = fieldConfig.label || field.arg;
            }
            ret = {
              label: label || config.settings.valueLabel,
              placeholder: placeholder || config.settings.valuePlaceholder
            };
          }
          return ret;
        };
        function _getWidgetsAndSrcsForFieldOp(config, field) {
          var operator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          var valueSrc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var widgets = [];
          var valueSrcs = [];
          if (!field) return {
            widgets: widgets,
            valueSrcs: valueSrcs
          };
          var isFuncArg = _typeof$2(field) == "object" && (!!field.func && !!field.arg || field._isFuncArg);
          var fieldConfig = getFieldConfig$8(config, field);
          var opConfig = operator ? config.operators[operator] : null;
          if (fieldConfig && fieldConfig.widgets) {
            var _loop2 = function _loop2() {
              var widgetConfig = fieldConfig.widgets[widget];
              // if (!config.widgets[widget]) {
              //   continue;
              // }
              var widgetValueSrc = config.widgets[widget].valueSrc || "value";
              var canAdd = true;
              if (widget == "field") {
                canAdd = canAdd && filterValueSourcesForField(config, ["field"], fieldConfig).length > 0;
              }
              if (widget == "func") {
                canAdd = canAdd && filterValueSourcesForField(config, ["func"], fieldConfig).length > 0;
              }
              // If can't check operators, don't add
              // Func args don't have operators
              if (valueSrc == "value" && !widgetConfig.operators && !isFuncArg && field != "!case_value") canAdd = false;
              if (widgetConfig.operators && operator) canAdd = canAdd && widgetConfig.operators.indexOf(operator) != -1;
              if (valueSrc && valueSrc != widgetValueSrc && valueSrc != "const") canAdd = false;
              if (opConfig && opConfig.cardinality == 0 && widgetValueSrc != "value") canAdd = false;
              if (canAdd) {
                widgets.push(widget);
                var canAddValueSrc = fieldConfig.valueSources && fieldConfig.valueSources.indexOf(widgetValueSrc) != -1;
                if (opConfig && opConfig.valueSources && opConfig.valueSources.indexOf(widgetValueSrc) == -1) canAddValueSrc = false;
                if (canAddValueSrc && !valueSrcs.find(function (v) {
                  return v == widgetValueSrc;
                })) valueSrcs.push(widgetValueSrc);
              }
            };
            for (var widget in fieldConfig.widgets) {
              _loop2();
            }
          }
          var widgetWeight = function widgetWeight(w) {
            var wg = 0;
            if (fieldConfig.preferWidgets) {
              if (fieldConfig.preferWidgets.includes(w)) wg += 10 - fieldConfig.preferWidgets.indexOf(w);
            } else if (w == fieldConfig.mainWidget) {
              wg += 100;
            }
            if (w == "field") {
              wg -= 1;
            }
            if (w == "func") {
              wg -= 2;
            }
            return wg;
          };
          widgets.sort(function (w1, w2) {
            return widgetWeight(w2) - widgetWeight(w1);
          });
          return {
            widgets: widgets,
            valueSrcs: valueSrcs
          };
        }
        var getWidgetsForFieldOp$1 = function getWidgetsForFieldOp(config, field, operator) {
          var valueSrc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var _getWidgetsAndSrcsFor = _getWidgetsAndSrcsForFieldOp(config, field, operator, valueSrc),
            widgets = _getWidgetsAndSrcsFor.widgets;
          return widgets;
        };
        var filterValueSourcesForField = function filterValueSourcesForField(config, valueSrcs, fieldDefinition) {
          if (!fieldDefinition) return valueSrcs;
          return valueSrcs.filter(function (vs) {
            var canAdd = true;
            if (vs == "field") {
              if (config._fieldsCntByType) {
                // tip: LHS field can be used as arg in RHS function
                var minCnt = fieldDefinition._isFuncArg ? 0 : 1;
                canAdd = canAdd && config._fieldsCntByType[fieldDefinition.type] > minCnt;
              }
            }
            if (vs == "func") {
              if (config._funcsCntByType) canAdd = canAdd && !!config._funcsCntByType[fieldDefinition.type];
              if (fieldDefinition.funcs) canAdd = canAdd && fieldDefinition.funcs.length > 0;
            }
            return canAdd;
          });
        };
        var getValueSourcesForFieldOp$1 = function getValueSourcesForFieldOp(config, field, operator) {
          var fieldDefinition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var _getWidgetsAndSrcsFor2 = _getWidgetsAndSrcsForFieldOp(config, field, operator, null),
            valueSrcs = _getWidgetsAndSrcsFor2.valueSrcs;
          var filteredValueSrcs = filterValueSourcesForField(config, valueSrcs, fieldDefinition);
          return filteredValueSrcs;
        };
        var getWidgetForFieldOp$3 = function getWidgetForFieldOp(config, field, operator) {
          var valueSrc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var _getWidgetsAndSrcsFor3 = _getWidgetsAndSrcsForFieldOp(config, field, operator, valueSrc),
            widgets = _getWidgetsAndSrcsFor3.widgets;
          var widget = null;
          if (widgets.length) widget = widgets[0];
          return widget;
        };
        var formatFieldName$1 = function formatFieldName(field, config, meta) {
          var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          if (!field) return;
          var fieldDef = getFieldConfig$8(config, field) || {};
          var fieldSeparator = config.settings.fieldSeparator;
          var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);
          var fieldName = Array.isArray(field) ? field.join(fieldSeparator) : field;
          if (fieldDef.tableName) {
            // legacy
            var fieldPartsCopy = _toConsumableArray(fieldParts);
            fieldPartsCopy[0] = fieldDef.tableName;
            fieldName = fieldPartsCopy.join(fieldSeparator);
          }
          if (fieldDef.fieldName) {
            fieldName = fieldDef.fieldName;
          }
          if (parentField) {
            var parentFieldDef = getFieldConfig$8(config, parentField) || {};
            var parentFieldName = parentField;
            if (parentFieldDef.fieldName) {
              parentFieldName = parentFieldDef.fieldName;
            }
            if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {
              fieldName = fieldName.slice((parentFieldName + fieldSeparator).length);
            } else {
              meta.errors.push("Can't cut group ".concat(parentFieldName, " from field ").concat(fieldName));
            }
          }
          return fieldName;
        };
        const ruleUtils = /*#__PURE__*/Object.freeze( /*#__PURE__*/Object.defineProperty({
          __proto__: null,
          filterValueSourcesForField,
          formatFieldName: formatFieldName$1,
          getFieldPartsConfigs,
          getFieldPath: getFieldPath$3,
          getFieldPathLabels: getFieldPathLabels$3,
          getFirstField,
          getFirstOperator,
          getFuncPathLabels: getFuncPathLabels$1,
          getNewValueForFieldOp,
          getOperatorsForField,
          getValueLabel: getValueLabel$1,
          getValueSourcesForFieldOp: getValueSourcesForFieldOp$1,
          getWidgetForFieldOp: getWidgetForFieldOp$3,
          getWidgetsForFieldOp: getWidgetsForFieldOp$1
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        var clone$4 = {
          exports: {}
        };
        (function (module) {
          var clone = function () {
            function _instanceof(obj, type) {
              return type != null && obj instanceof type;
            }
            var nativeMap;
            try {
              nativeMap = Map;
            } catch (_) {
              // maybe a reference error because no `Map`. Give it a dummy value that no
              // value will ever be an instanceof.
              nativeMap = function () {};
            }
            var nativeSet;
            try {
              nativeSet = Set;
            } catch (_) {
              nativeSet = function () {};
            }
            var nativePromise;
            try {
              nativePromise = Promise;
            } catch (_) {
              nativePromise = function () {};
            }

            /**
             * Clones (copies) an Object using deep copying.
             *
             * This function supports circular references by default, but if you are certain
             * there are no circular references in your object, you can save some CPU time
             * by calling clone(obj, false).
             *
             * Caution: if `circular` is false and `parent` contains circular references,
             * your program may enter an infinite loop and crash.
             *
             * @param `parent` - the object to be cloned
             * @param `circular` - set to true if the object to be cloned may contain
             *    circular references. (optional - true by default)
             * @param `depth` - set to a number if the object is only to be cloned to
             *    a particular depth. (optional - defaults to Infinity)
             * @param `prototype` - sets the prototype to be used when cloning an object.
             *    (optional - defaults to parent prototype).
             * @param `includeNonEnumerable` - set to true if the non-enumerable properties
             *    should be cloned as well. Non-enumerable properties on the prototype
             *    chain will be ignored. (optional - false by default)
            */
            function clone(parent, circular, depth, prototype, includeNonEnumerable) {
              if (typeof circular === 'object') {
                depth = circular.depth;
                prototype = circular.prototype;
                includeNonEnumerable = circular.includeNonEnumerable;
                circular = circular.circular;
              }
              // maintain two arrays for circular references, where corresponding parents
              // and children have the same index
              var allParents = [];
              var allChildren = [];
              var useBuffer = typeof Buffer != 'undefined';
              if (typeof circular == 'undefined') circular = true;
              if (typeof depth == 'undefined') depth = Infinity;

              // recurse this function so we don't reset allParents and allChildren
              function _clone(parent, depth) {
                // cloning null always returns null
                if (parent === null) return null;
                if (depth === 0) return parent;
                var child;
                var proto;
                if (typeof parent != 'object') {
                  return parent;
                }
                if (_instanceof(parent, nativeMap)) {
                  child = new nativeMap();
                } else if (_instanceof(parent, nativeSet)) {
                  child = new nativeSet();
                } else if (_instanceof(parent, nativePromise)) {
                  child = new nativePromise(function (resolve, reject) {
                    parent.then(function (value) {
                      resolve(_clone(value, depth - 1));
                    }, function (err) {
                      reject(_clone(err, depth - 1));
                    });
                  });
                } else if (clone.__isArray(parent)) {
                  child = [];
                } else if (clone.__isRegExp(parent)) {
                  child = new RegExp(parent.source, __getRegExpFlags(parent));
                  if (parent.lastIndex) child.lastIndex = parent.lastIndex;
                } else if (clone.__isDate(parent)) {
                  child = new Date(parent.getTime());
                } else if (useBuffer && Buffer.isBuffer(parent)) {
                  if (Buffer.allocUnsafe) {
                    // Node.js >= 4.5.0
                    child = Buffer.allocUnsafe(parent.length);
                  } else {
                    // Older Node.js versions
                    child = new Buffer(parent.length);
                  }
                  parent.copy(child);
                  return child;
                } else if (_instanceof(parent, Error)) {
                  child = Object.create(parent);
                } else {
                  if (typeof prototype == 'undefined') {
                    proto = Object.getPrototypeOf(parent);
                    child = Object.create(proto);
                  } else {
                    child = Object.create(prototype);
                    proto = prototype;
                  }
                }
                if (circular) {
                  var index = allParents.indexOf(parent);
                  if (index != -1) {
                    return allChildren[index];
                  }
                  allParents.push(parent);
                  allChildren.push(child);
                }
                if (_instanceof(parent, nativeMap)) {
                  parent.forEach(function (value, key) {
                    var keyChild = _clone(key, depth - 1);
                    var valueChild = _clone(value, depth - 1);
                    child.set(keyChild, valueChild);
                  });
                }
                if (_instanceof(parent, nativeSet)) {
                  parent.forEach(function (value) {
                    var entryChild = _clone(value, depth - 1);
                    child.add(entryChild);
                  });
                }
                for (var i in parent) {
                  var attrs;
                  if (proto) {
                    attrs = Object.getOwnPropertyDescriptor(proto, i);
                  }
                  if (attrs && attrs.set == null) {
                    continue;
                  }
                  child[i] = _clone(parent[i], depth - 1);
                }
                if (Object.getOwnPropertySymbols) {
                  var symbols = Object.getOwnPropertySymbols(parent);
                  for (var i = 0; i < symbols.length; i++) {
                    // Don't need to worry about cloning a symbol because it is a primitive,
                    // like a number or string.
                    var symbol = symbols[i];
                    var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
                    if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                      continue;
                    }
                    child[symbol] = _clone(parent[symbol], depth - 1);
                    if (!descriptor.enumerable) {
                      Object.defineProperty(child, symbol, {
                        enumerable: false
                      });
                    }
                  }
                }
                if (includeNonEnumerable) {
                  var allPropertyNames = Object.getOwnPropertyNames(parent);
                  for (var i = 0; i < allPropertyNames.length; i++) {
                    var propertyName = allPropertyNames[i];
                    var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
                    if (descriptor && descriptor.enumerable) {
                      continue;
                    }
                    child[propertyName] = _clone(parent[propertyName], depth - 1);
                    Object.defineProperty(child, propertyName, {
                      enumerable: false
                    });
                  }
                }
                return child;
              }
              return _clone(parent, depth);
            }

            /**
             * Simple flat clone using prototype, accepts only objects, usefull for property
             * override on FLAT configuration object (no nested props).
             *
             * USE WITH CAUTION! This may not behave as you wish if you do not know how this
             * works.
             */
            clone.clonePrototype = function clonePrototype(parent) {
              if (parent === null) return null;
              var c = function () {};
              c.prototype = parent;
              return new c();
            };

            // private utility functions

            function __objToStr(o) {
              return Object.prototype.toString.call(o);
            }
            clone.__objToStr = __objToStr;
            function __isDate(o) {
              return typeof o === 'object' && __objToStr(o) === '[object Date]';
            }
            clone.__isDate = __isDate;
            function __isArray(o) {
              return typeof o === 'object' && __objToStr(o) === '[object Array]';
            }
            clone.__isArray = __isArray;
            function __isRegExp(o) {
              return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
            }
            clone.__isRegExp = __isRegExp;
            function __getRegExpFlags(re) {
              var flags = '';
              if (re.global) flags += 'g';
              if (re.ignoreCase) flags += 'i';
              if (re.multiline) flags += 'm';
              return flags;
            }
            clone.__getRegExpFlags = __getRegExpFlags;
            return clone;
          }();
          if (module.exports) {
            module.exports = clone;
          }
        })(clone$4);
        var cloneExports = clone$4.exports;
        const clone$3 = /*@__PURE__*/getDefaultExportFromCjs(cloneExports);
        function _createForOfIteratorHelper$4(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === "number") {
              if (it) o = it;
              var i = 0;
              var F = function F() {};
              return {
                s: F,
                n: function n() {
                  if (i >= o.length) return {
                    done: true
                  };
                  return {
                    done: false,
                    value: o[i++]
                  };
                },
                e: function e(_e) {
                  throw _e;
                },
                f: F
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true,
            didErr = false,
            err;
          return {
            s: function s() {
              it = it.call(o);
            },
            n: function n() {
              var step = it.next();
              normalCompletion = step.done;
              return step;
            },
            e: function e(_e2) {
              didErr = true;
              err = _e2;
            },
            f: function f() {
              try {
                if (!normalCompletion && it["return"] != null) it["return"]();
              } finally {
                if (didErr) throw err;
              }
            }
          };
        }
        function _unsupportedIterableToArray$4(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray$4(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen);
        }
        function _arrayLikeToArray$4(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }
        function ownKeys$u(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$u(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$u(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$u(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        var extendConfig$1 = function extendConfig(config, configId) {
          //operators, defaultOperator - merge
          //widgetProps (including valueLabel, valuePlaceholder, hideOperator, operatorInlineLabel) - concrete by widget

          if (config.__configId) {
            return config;
          }
          config = _objectSpread$u({}, config);
          config.settings = merge$2({}, settings$4, config.settings);
          config._fieldsCntByType = {};
          config._funcsCntByType = {};
          config.types = clone$3(config.types);
          _extendTypesConfig(config.types, config);
          config.fields = clone$3(config.fields);
          config.__fieldNames = {};
          _extendFieldsConfig(config.fields, config);
          config.funcs = clone$3(config.funcs);
          _extendFuncArgsConfig(config.funcs, config);
          hooks.locale(config.settings.locale.moment);
          Object.defineProperty(config, "__configId", {
            enumerable: false,
            writable: false,
            value: configId || uuid$1()
          });
          return config;
        };
        function _extendTypesConfig(typesConfig, config) {
          for (var type in typesConfig) {
            var typeConfig = typesConfig[type];
            _extendTypeConfig(type, typeConfig, config);
          }
        }
        function _extendTypeConfig(type, typeConfig, config) {
          var operators = null,
            defaultOperator = null;
          typeConfig.mainWidget = typeConfig.mainWidget || Object.keys(typeConfig.widgets).filter(function (w) {
            return w != "field" && w != "func";
          })[0];
          for (var widget in typeConfig.widgets) {
            var typeWidgetConfig = typeConfig.widgets[widget];
            if (typeWidgetConfig.operators) {
              var typeWidgetOperators = typeWidgetConfig.operators;
              if (typeConfig.excludeOperators) {
                typeWidgetOperators = typeWidgetOperators.filter(function (op) {
                  return !typeConfig.excludeOperators.includes(op);
                });
              }
              operators = mergeArraysSmart(operators, typeWidgetOperators);
            }
            if (typeWidgetConfig.defaultOperator) defaultOperator = typeWidgetConfig.defaultOperator;
            if (widget == typeConfig.mainWidget) {
              typeWidgetConfig = merge$2({}, {
                widgetProps: typeConfig.mainWidgetProps || {}
              }, typeWidgetConfig);
            }
            typeConfig.widgets[widget] = typeWidgetConfig;
          }
          if (!typeConfig.valueSources) typeConfig.valueSources = Object.keys(config.settings.valueSourcesInfo);
          var _iterator = _createForOfIteratorHelper$4(typeConfig.valueSources),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var valueSrc = _step.value;
              if (valueSrc != "value" && !typeConfig.widgets[valueSrc]) {
                typeConfig.widgets[valueSrc] = {};
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          if (!typeConfig.operators && operators) typeConfig.operators = Array.from(new Set(operators)); //unique
          if (!typeConfig.defaultOperator && defaultOperator) typeConfig.defaultOperator = defaultOperator;
        }
        function _extendFieldsConfig(subconfig, config) {
          var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
          for (var field in subconfig) {
            _extendFieldConfig(subconfig[field], config, [].concat(_toConsumableArray(path), [field]));
            if (subconfig[field].subfields) {
              _extendFieldsConfig(subconfig[field].subfields, config, [].concat(_toConsumableArray(path), [field]));
            }
          }
        }
        function _extendFuncArgsConfig(subconfig, config) {
          if (!subconfig) return;
          for (var funcKey in subconfig) {
            var funcDef = subconfig[funcKey];
            if (funcDef.returnType) {
              if (!config._funcsCntByType[funcDef.returnType]) config._funcsCntByType[funcDef.returnType] = 0;
              config._funcsCntByType[funcDef.returnType]++;
            }
            for (var argKey in funcDef.args) {
              _extendFieldConfig(funcDef.args[argKey], config, null, true);
            }

            // isOptional can be only in the end
            if (funcDef.args) {
              var argKeys = Object.keys(funcDef.args);
              var tmpIsOptional = true;
              var _iterator2 = _createForOfIteratorHelper$4(argKeys.reverse()),
                _step2;
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var _argKey = _step2.value;
                  var argDef = funcDef.args[_argKey];
                  if (!tmpIsOptional && argDef.isOptional) {
                    delete argDef.isOptional;
                  }
                  if (!argDef.isOptional) tmpIsOptional = false;
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            }
            if (funcDef.subfields) {
              _extendFuncArgsConfig(funcDef.subfields, config);
            }
          }
        }
        function _extendFieldConfig(fieldConfig, config) {
          var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          var isFuncArg = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          var operators = null,
            defaultOperator = null;
          var typeConfig = config.types[fieldConfig.type];
          var excludeOperatorsForField = fieldConfig.excludeOperators || [];
          if (fieldConfig.type != "!struct" && fieldConfig.type != "!group") {
            var keysToPutInFieldSettings = ["listValues", "treeValues", "allowCustomValues", "validateValue"];
            if (!fieldConfig.fieldSettings) fieldConfig.fieldSettings = {};
            for (var _i = 0, _keysToPutInFieldSett = keysToPutInFieldSettings; _i < _keysToPutInFieldSett.length; _i++) {
              var k = _keysToPutInFieldSett[_i];
              if (fieldConfig[k]) {
                fieldConfig.fieldSettings[k] = fieldConfig[k];
                delete fieldConfig[k];
              }
            }

            // normalize listValues
            if (fieldConfig.fieldSettings.listValues) {
              if (config.settings.normalizeListValues) {
                fieldConfig.fieldSettings.listValues = config.settings.normalizeListValues(fieldConfig.fieldSettings.listValues, fieldConfig.type, fieldConfig.fieldSettings);
              }
            }
            // same for treeValues
            if (fieldConfig.fieldSettings.treeValues) {
              if (config.settings.normalizeListValues) {
                fieldConfig.fieldSettings.treeValues = config.settings.normalizeListValues(fieldConfig.fieldSettings.treeValues, fieldConfig.type, fieldConfig.fieldSettings);
              }
            }
            if (!typeConfig) {
              //console.warn(`No type config for ${fieldConfig.type}`);
              fieldConfig.disabled = true;
              return;
            }
            if (!isFuncArg) {
              if (!config._fieldsCntByType[fieldConfig.type]) config._fieldsCntByType[fieldConfig.type] = 0;
              config._fieldsCntByType[fieldConfig.type]++;
            }
            if (!fieldConfig.widgets) fieldConfig.widgets = {};
            if (isFuncArg) fieldConfig._isFuncArg = true;
            fieldConfig.mainWidget = fieldConfig.mainWidget || typeConfig.mainWidget;
            fieldConfig.valueSources = fieldConfig.valueSources || typeConfig.valueSources;
            var excludeOperatorsForType = typeConfig.excludeOperators || [];
            var _loop = function _loop() {
              var fieldWidgetConfig = fieldConfig.widgets[widget] || {};
              var typeWidgetConfig = typeConfig.widgets[widget] || {};
              if (!isFuncArg) {
                //todo: why I've excluded isFuncArg ?
                var excludeOperators = [].concat(_toConsumableArray(excludeOperatorsForField), _toConsumableArray(excludeOperatorsForType));
                var shouldIncludeOperators = fieldConfig.preferWidgets && (widget == "field" || fieldConfig.preferWidgets.includes(widget)) || excludeOperators.length > 0;
                if (fieldWidgetConfig.operators) {
                  var addOperators = fieldWidgetConfig.operators.filter(function (o) {
                    return !excludeOperators.includes(o);
                  });
                  operators = [].concat(_toConsumableArray(operators || []), _toConsumableArray(addOperators));
                } else if (shouldIncludeOperators && typeWidgetConfig.operators) {
                  var _addOperators = typeWidgetConfig.operators.filter(function (o) {
                    return !excludeOperators.includes(o);
                  });
                  operators = [].concat(_toConsumableArray(operators || []), _toConsumableArray(_addOperators));
                }
                if (fieldWidgetConfig.defaultOperator) defaultOperator = fieldWidgetConfig.defaultOperator;
              }
              if (widget == fieldConfig.mainWidget) {
                fieldWidgetConfig = merge$2({}, {
                  widgetProps: fieldConfig.mainWidgetProps || {}
                }, fieldWidgetConfig);
              }
              fieldConfig.widgets[widget] = fieldWidgetConfig;
            };
            for (var widget in typeConfig.widgets) {
              _loop();
            }
            if (!isFuncArg) {
              if (!fieldConfig.operators && operators) fieldConfig.operators = Array.from(new Set(operators));
              if (!fieldConfig.defaultOperator && defaultOperator) fieldConfig.defaultOperator = defaultOperator;
            }
          }
          var computedFieldName = computeFieldName(config, path);
          if (computedFieldName) {
            fieldConfig.fieldName = computedFieldName;
          }
          if (path && fieldConfig.fieldName) {
            config.__fieldNames[fieldConfig.fieldName] = path;
          }
        }
        var getFieldRawConfig = function getFieldRawConfig(config, field) {
          var fieldsKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "fields";
          var subfieldsKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "subfields";
          if (!field) return null;
          if (field == "!case_value") {
            return {
              type: "case_value",
              mainWidget: "case_value",
              widgets: {
                "case_value": config.widgets["case_value"]
              }
            };
          }
          var fieldSeparator = config.settings.fieldSeparator;
          //field = normalizeField(config, field);
          var parts = Array.isArray(field) ? field : field.split(fieldSeparator);
          var targetFields = config[fieldsKey];
          if (!targetFields) return null;
          var fields = targetFields;
          var fieldConfig = null;
          var path = [];
          for (var i = 0; i < parts.length; i++) {
            var part = parts[i];
            path.push(part);
            var pathKey = path.join(fieldSeparator);
            fieldConfig = fields[pathKey];
            if (i < parts.length - 1) {
              if (fieldConfig && fieldConfig[subfieldsKey]) {
                fields = fieldConfig[subfieldsKey];
                path = [];
              } else {
                fieldConfig = null;
              }
            }
          }
          return fieldConfig;
        };
        var computeFieldName = function computeFieldName(config, path) {
          if (!path) return null;
          var fieldSeparator = config.settings.fieldSeparator;
          var l = _toConsumableArray(path),
            r = [],
            f,
            fConfig;
          while ((f = l.pop()) !== undefined && l.length > 0) {
            r.unshift(f);
            fConfig = getFieldRawConfig(config, l);
            if (fConfig.fieldName) {
              return [fConfig.fieldName].concat(r).join(fieldSeparator);
            }
          }
          return null;
        };
        var normalizeField = function normalizeField(config, field) {
          var fieldSeparator = config.settings.fieldSeparator;
          var fieldStr = Array.isArray(field) ? field.join(fieldSeparator) : field;
          if (config.__fieldNames[fieldStr]) {
            return config.__fieldNames[fieldStr].join(fieldSeparator);
          }
          return fieldStr;
        };
        var getFuncConfig$2 = function getFuncConfig(config, func) {
          if (!func) return null;
          var funcConfig = getFieldRawConfig(config, func, "funcs", "subfields");
          if (!funcConfig) return null; //throw new Error("Can't find func " + func + ", please check your config");
          return funcConfig;
        };
        var getFuncArgConfig = function getFuncArgConfig(config, funcKey, argKey) {
          var funcConfig = getFuncConfig$2(config, funcKey);
          if (!funcConfig) return null; //throw new Error(`Can't find func ${funcKey}, please check your config`);
          var argConfig = funcConfig.args && funcConfig.args[argKey] || null;
          if (!argConfig) return null; //throw new Error(`Can't find arg ${argKey} for func ${funcKey}, please check your config`);

          //merge, but don't merge operators (rewrite instead)
          var typeConfig = config.types[argConfig.type] || {};
          var ret = mergeWith$1({}, typeConfig, argConfig || {}, function (objValue, srcValue, _key, _object, _source, _stack) {
            if (Array.isArray(objValue)) {
              return srcValue;
            }
          });
          return ret;
        };
        var getFieldConfig$8 = function getFieldConfig(config, field) {
          if (!field) return null;
          if (_typeof$2(field) == "object" && !field.func && !!field.type) return field;
          if (_typeof$2(field) == "object" && field.func && field.arg) return getFuncArgConfig(config, field.func, field.arg);
          var fieldConfig = getFieldRawConfig(config, field);
          if (!fieldConfig) return null; //throw new Error("Can't find field " + field + ", please check your config");

          //merge, but don't merge operators (rewrite instead)
          var typeConfig = config.types[fieldConfig.type] || {};
          var ret = mergeWith$1({}, typeConfig, fieldConfig || {}, function (objValue, srcValue, _key, _object, _source, _stack) {
            if (Array.isArray(objValue)) {
              return srcValue;
            }
          });
          return ret;
        };
        var getOperatorConfig$4 = function getOperatorConfig(config, operator) {
          var field = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          if (!operator) return null;
          var opConfig = config.operators[operator];
          if (field) {
            var fieldConfig = getFieldConfig$8(config, field);
            var widget = getWidgetForFieldOp$3(config, field, operator);
            var widgetConfig = config.widgets[widget] || {};
            var fieldWidgetConfig = (fieldConfig && fieldConfig.widgets ? fieldConfig.widgets[widget] : {}) || {};
            var widgetOpProps = (widgetConfig.opProps || {})[operator];
            var fieldWidgetOpProps = (fieldWidgetConfig.opProps || {})[operator];
            var mergedOpConfig = merge$2({}, opConfig, widgetOpProps, fieldWidgetOpProps);
            return mergedOpConfig;
          } else {
            return opConfig;
          }
        };
        var getFieldWidgetConfig$3 = function getFieldWidgetConfig(config, field, operator) {
          var widget = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var valueSrc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          if (!field) return null;
          if (!(operator || widget) && valueSrc != "const" && field != "!case_value") return null;
          var fieldConfig = getFieldConfig$8(config, field);
          if (!widget) widget = getWidgetForFieldOp$3(config, field, operator, valueSrc);
          var widgetConfig = config.widgets[widget] || {};
          var fieldWidgetConfig = (fieldConfig && fieldConfig.widgets ? fieldConfig.widgets[widget] : {}) || {};
          var fieldWidgetProps = fieldWidgetConfig.widgetProps || {};
          var valueFieldSettings = (valueSrc == "value" || !valueSrc) && fieldConfig && fieldConfig.fieldSettings || {}; // useful to take 'validateValue'
          var mergedConfig = merge$2({}, widgetConfig, fieldWidgetProps, valueFieldSettings);
          return mergedConfig;
        };
        const configUtils = /*#__PURE__*/Object.freeze( /*#__PURE__*/Object.defineProperty({
          __proto__: null,
          extendConfig: extendConfig$1,
          getFieldConfig: getFieldConfig$8,
          getFieldRawConfig,
          getFieldWidgetConfig: getFieldWidgetConfig$3,
          getFuncArgConfig,
          getFuncConfig: getFuncConfig$2,
          getOperatorConfig: getOperatorConfig$4,
          normalizeField
        }, Symbol.toStringTag, {
          value: 'Module'
        }));

        // helpers
        var isObject$4 = function isObject(v) {
          return _typeof$2(v) == "object" && v !== null && !Array.isArray(v);
        };

        /**
         * @param {*} value
         * @param {string} valueSrc - 'value' | 'field' | 'func'
         * @param {object} config
         * @return {* | undefined} - undefined if func value is not complete (missing required arg vals); can return completed value != value
         */
        var completeValue = function completeValue(value, valueSrc, config) {
          if (valueSrc == "func") return completeFuncValue(value, config);else return value;
        };

        /**
         * @param {Immutable.Map} value
         * @param {object} config
         * @return {Immutable.Map | undefined} - undefined if func value is not complete (missing required arg vals); can return completed value != value
         */
        var completeFuncValue = function completeFuncValue(value, config) {
          var _checkFuncValue = function _checkFuncValue(value) {
            if (!value) return undefined;
            var funcKey = value.get("func");
            var funcConfig = funcKey && getFuncConfig$2(config, funcKey);
            if (!funcConfig) return undefined;
            var complValue = value;
            var tmpHasOptional = false;
            for (var argKey in funcConfig.args) {
              var argConfig = funcConfig.args[argKey];
              var valueSources = argConfig.valueSources,
                isOptional = argConfig.isOptional,
                defaultValue = argConfig.defaultValue;
              var filteredValueSources = filterValueSourcesForField(config, valueSources, argConfig);
              var args = complValue.get("args");
              var argDefaultValueSrc = filteredValueSources.length == 1 ? filteredValueSources[0] : undefined;
              var argVal = args ? args.get(argKey) : undefined;
              var argValue = argVal ? argVal.get("value") : undefined;
              var argValueSrc = (argVal ? argVal.get("valueSrc") : undefined) || argDefaultValueSrc;
              if (argValue !== undefined) {
                var completeArgValue = completeValue(argValue, argValueSrc, config);
                if (completeArgValue === undefined) {
                  return undefined;
                } else if (completeArgValue !== argValue) {
                  complValue = complValue.setIn(["args", argKey, "value"], completeArgValue);
                }
                if (tmpHasOptional) {
                  // has gap
                  return undefined;
                }
              } else if (defaultValue !== undefined && !isObject$4(defaultValue)) {
                complValue = complValue.setIn(["args", argKey, "value"], getDefaultArgValue(argConfig));
                complValue = complValue.setIn(["args", argKey, "valueSrc"], "value");
              } else if (isOptional) {
                // optional
                tmpHasOptional = true;
              } else {
                // missing value
                return undefined;
              }
            }
            return complValue;
          };
          return _checkFuncValue(value);
        };

        /**
         * Used @ FuncWidget
         * @param {Immutable.Map} value 
         * @param {string} funcKey 
         * @param {object} config 
         */
        var setFunc$1 = function setFunc(value, funcKey, config) {
          var fieldSeparator = config.settings.fieldSeparator;
          value = value || new Immutable.Map();
          if (Array.isArray(funcKey)) {
            // fix for cascader
            funcKey = funcKey.join(fieldSeparator);
          }
          value = value.set("func", funcKey);
          value = value.set("args", new Immutable.Map());

          // defaults
          var funcConfig = funcKey && getFuncConfig$2(config, funcKey);
          if (funcConfig) {
            for (var argKey in funcConfig.args) {
              var argConfig = funcConfig.args[argKey];
              var valueSources = argConfig.valueSources,
                defaultValue = argConfig.defaultValue;
              var filteredValueSources = filterValueSourcesForField(config, valueSources, argConfig);
              var firstValueSrc = filteredValueSources.length ? filteredValueSources[0] : undefined;
              var defaultValueSrc = defaultValue ? isObject$4(defaultValue) && !!defaultValue.func ? "func" : "value" : undefined;
              var argDefaultValueSrc = defaultValueSrc || firstValueSrc;
              if (defaultValue !== undefined) {
                value = value.setIn(["args", argKey, "value"], getDefaultArgValue(argConfig));
              }
              if (argDefaultValueSrc) {
                value = value.setIn(["args", argKey, "valueSrc"], argDefaultValueSrc);
              }
            }
          }
          return value;
        };
        var getDefaultArgValue = function getDefaultArgValue(_ref) {
          var value = _ref.defaultValue;
          if (isObject$4(value) && !Immutable.Map.isMap(value) && value.func) {
            return Immutable.fromJS(value, function (k, v) {
              return Immutable.Iterable.isIndexed(v) ? v.toList() : v.toOrderedMap();
            });
          }
          return value;
        };

        /**
        * Used @ FuncWidget
        * @param {Immutable.Map} value 
        * @param {string} argKey 
        * @param {*} argVal 
        * @param {object} argConfig 
        */
        var setArgValue$1 = function setArgValue(value, argKey, argVal, argConfig, config) {
          if (value && value.get("func")) {
            value = value.setIn(["args", argKey, "value"], argVal);

            // set default arg value sorce
            var valueSources = argConfig.valueSources;
            var filteredValueSources = filterValueSourcesForField(config, valueSources, argConfig);
            var argDefaultValueSrc = filteredValueSources.length == 1 ? filteredValueSources[0] : undefined;
            if (argDefaultValueSrc) {
              value = value.setIn(["args", argKey, "valueSrc"], argDefaultValueSrc);
            }
          }
          return value;
        };

        /**
        * Used @ FuncWidget
        * @param {Immutable.Map} value 
        * @param {string} argKey 
        * @param {string} argValSrc 
        * @param {object} argConfig 
        */
        var setArgValueSrc$1 = function setArgValueSrc(value, argKey, argValSrc, _argConfig, _config) {
          if (value && value.get("func")) {
            value = value.setIn(["args", argKey], new Immutable.Map({
              valueSrc: argValSrc
            }));
          }
          return value;
        };
        const funcUtils = /*#__PURE__*/Object.freeze( /*#__PURE__*/Object.defineProperty({
          __proto__: null,
          completeFuncValue,
          completeValue,
          setArgValue: setArgValue$1,
          setArgValueSrc: setArgValueSrc$1,
          setFunc: setFunc$1
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        function ownKeys$t(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$t(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$t(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$t(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }

        /*
         Build tree to http://querybuilder.js.org/ like format
          Example:
         {
            "condition": "AND",
            "rules": [
                {
                    "id": "price",
                    "field": "price",
                    "type": "double",
                    "input": "text",
                    "operator": "less",
                    "value": "10.25"
                },
                {
                    "condition": "OR",
                    "rules": [
                        {
                            "id": "category",
                            "field": "category",
                            "type": "integer",
                            "input": "select",
                            "operator": "equal",
                            "value": "2"
                        },
                        {
                            "id": "category",
                            "field": "category",
                            "type": "integer",
                            "input": "select",
                            "operator": "equal",
                            "value": "1"
                        }
                    ]
                }
            ]
         }
         */

        var queryBuilderFormat = function queryBuilderFormat(item, config) {
          //meta is mutable
          var meta = {
            usedFields: []
          };
          var res = formatItem$5(item, config, meta);
          if (!res) return undefined;
          return _objectSpread$t(_objectSpread$t({}, res), meta);
        };
        var formatItem$5 = function formatItem(item, config, meta) {
          if (!item) return undefined;
          var type = item.get("type");
          var children = item.get("children1");
          if ((type === "group" || type === "rule_group") && children && children.size) {
            return formatGroup$5(item, config, meta);
          } else if (type === "rule") {
            return formatRule$5(item, config, meta);
          }
          return undefined;
        };
        var formatGroup$5 = function formatGroup(item, config, meta) {
          var properties = item.get("properties") || new immutableExports.Map();
          var children = item.get("children1");
          var id = item.get("id");
          var list = children.map(function (currentChild) {
            return formatItem$5(currentChild, config, meta);
          }).filter(function (currentChild) {
            return typeof currentChild !== "undefined";
          });
          if (!list.size) return undefined;
          var conjunction = properties.get("conjunction");
          if (!conjunction) conjunction = defaultConjunction(config);
          var not = properties.get("not");
          var resultQuery = {
            id: id,
            rules: list.toList(),
            condition: conjunction.toUpperCase(),
            not: not
          };
          return resultQuery;
        };
        var formatRule$5 = function formatRule(item, config, meta) {
          var properties = item.get("properties") || new immutableExports.Map();
          var id = item.get("id");
          var operator = properties.get("operator");
          var options = properties.get("operatorOptions");
          var field = properties.get("field");
          var value = properties.get("value");
          var valueSrc = properties.get("valueSrc");
          var valueType = properties.get("valueType");
          var hasUndefinedValues = value.filter(function (v) {
            return v === undefined;
          }).size > 0;
          if (field == null || operator == null || hasUndefinedValues) return undefined;
          var fieldDefinition = getFieldConfig$8(config, field) || {};
          var operatorDefinition = getOperatorConfig$4(config, operator, field) || {};
          var fieldType = fieldDefinition.type || "undefined";
          var cardinality = defaultValue$1(operatorDefinition.cardinality, 1);
          var typeConfig = config.types[fieldDefinition.type] || {};
          var fieldName = formatFieldName$1(field, config, meta);
          if (value.size < cardinality) return undefined;
          if (meta.usedFields.indexOf(field) == -1) meta.usedFields.push(field);
          value = value.toArray();
          valueSrc = valueSrc.toArray();
          valueType = valueType.toArray();
          var values = [];
          for (var i = 0; i < value.length; i++) {
            var val = {
              type: valueType[i],
              value: value[i]
            };
            values.push(val);
            if (valueSrc[i] == "field") {
              var secondField = value[i];
              if (meta.usedFields.indexOf(secondField) == -1) meta.usedFields.push(secondField);
            }
          }
          var operatorOptions = options ? options.toJS() : null;
          if (operatorOptions && !Object.keys(operatorOptions).length) operatorOptions = null;
          var ruleQuery = {
            id: id,
            fieldName: fieldName,
            type: fieldType,
            input: typeConfig.mainWidget,
            operator: operator
          };
          if (operatorOptions) ruleQuery.operatorOptions = operatorOptions;
          ruleQuery.values = values;
          return ruleQuery;
        };
        var assignValue = _assignValue,
          castPath$1 = _castPath,
          isIndex = _isIndex,
          isObject$3 = isObject_1,
          toKey = _toKey;

        /**
         * The base implementation of `_.set`.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @param {Function} [customizer] The function to customize path creation.
         * @returns {Object} Returns `object`.
         */
        function baseSet$1(object, path, value, customizer) {
          if (!isObject$3(object)) {
            return object;
          }
          path = castPath$1(path, object);
          var index = -1,
            length = path.length,
            lastIndex = length - 1,
            nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]),
              newValue = value;
            if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined;
              if (newValue === undefined) {
                newValue = isObject$3(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var _baseSet = baseSet$1;
        var baseGet = _baseGet,
          baseSet = _baseSet,
          castPath = _castPath;

        /**
         * The base implementation of  `_.pickBy` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The source object.
         * @param {string[]} paths The property paths to pick.
         * @param {Function} predicate The function invoked per property.
         * @returns {Object} Returns the new object.
         */
        function basePickBy$2(object, paths, predicate) {
          var index = -1,
            length = paths.length,
            result = {};
          while (++index < length) {
            var path = paths[index],
              value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result, castPath(path, object), value);
            }
          }
          return result;
        }
        var _basePickBy = basePickBy$2;
        var basePickBy$1 = _basePickBy,
          hasIn = hasIn_1;

        /**
         * The base implementation of `_.pick` without support for individual
         * property identifiers.
         *
         * @private
         * @param {Object} object The source object.
         * @param {string[]} paths The property paths to pick.
         * @returns {Object} Returns the new object.
         */
        function basePick$1(object, paths) {
          return basePickBy$1(object, paths, function (value, path) {
            return hasIn(object, path);
          });
        }
        var _basePick = basePick$1;
        var basePick = _basePick,
          flatRest = _flatRest;

        /**
         * Creates an object composed of the picked `object` properties.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {...(string|string[])} [paths] The property paths to pick.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.pick(object, ['a', 'c']);
         * // => { 'a': 1, 'c': 3 }
         */
        var pick = flatRest(function (object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        var pick_1 = pick;
        const pick$1 = /*@__PURE__*/getDefaultExportFromCjs(pick_1);
        function ownKeys$s(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$s(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$s(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$s(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        function _createForOfIteratorHelper$3(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") {
              if (it) o = it;
              var i = 0;
              var F = function F() {};
              return {
                s: F,
                n: function n() {
                  if (i >= o.length) return {
                    done: true
                  };
                  return {
                    done: false,
                    value: o[i++]
                  };
                },
                e: function e(_e) {
                  throw _e;
                },
                f: F
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true,
            didErr = false,
            err;
          return {
            s: function s() {
              it = it.call(o);
            },
            n: function n() {
              var step = it.next();
              normalCompletion = step.done;
              return step;
            },
            e: function e(_e2) {
              didErr = true;
              err = _e2;
            },
            f: function f() {
              try {
                if (!normalCompletion && it["return"] != null) it["return"]();
              } finally {
                if (didErr) throw err;
              }
            }
          };
        }
        function _unsupportedIterableToArray$3(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray$3(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen);
        }
        function _arrayLikeToArray$3(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }

        // http://jsonlogic.com/

        var jsonLogicFormat = function jsonLogicFormat(item, config) {
          //meta is mutable
          var meta = {
            usedFields: [],
            errors: []
          };
          var logic = formatItem$4(item, config, meta, true);

          // build empty data
          var errors = meta.errors,
            usedFields = meta.usedFields;
          var fieldSeparator = config.settings.fieldSeparator;
          var data = {};
          var _iterator = _createForOfIteratorHelper$3(usedFields),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var ff = _step.value;
              var def = getFieldConfig$8(config, ff) || {};
              var parts = ff.split(fieldSeparator);
              var tmp = data;
              for (var i = 0; i < parts.length; i++) {
                var p = parts[i];
                var pdef = getFieldConfig$8(config, parts.slice(0, i + 1)) || {};
                if (i != parts.length - 1) {
                  if (pdef.type == "!group" && pdef.mode != "struct") {
                    if (!tmp[p]) tmp[p] = [{}];
                    tmp = tmp[p][0];
                  } else {
                    if (!tmp[p]) tmp[p] = {};
                    tmp = tmp[p];
                  }
                } else {
                  if (!tmp[p]) tmp[p] = null; // can use def.type for sample values
                }
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return {
            errors: errors,
            logic: logic,
            data: data
          };
        };
        var formatItem$4 = function formatItem(item, config, meta, isRoot) {
          var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          if (!item) return undefined;
          var type = item.get("type");
          var properties = item.get("properties") || new immutableExports.Map();
          var isLocked = properties.get("isLocked");
          var lockedOp = config.settings.jsonLogic.lockedOp;
          var ret;
          if (type === "group" || type === "rule_group") {
            ret = formatGroup$4(item, config, meta, isRoot, parentField);
          } else if (type === "rule") {
            ret = formatRule$4(item, config, meta, parentField);
          }
          if (isLocked && ret && lockedOp) {
            ret = _defineProperty$4({}, lockedOp, ret);
          }
          return ret;
        };
        var formatGroup$4 = function formatGroup(item, config, meta, isRoot) {
          var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          var type = item.get("type");
          var properties = item.get("properties") || new immutableExports.Map();
          var mode = properties.get("mode");
          var children = item.get("children1") || new immutableExports.List();
          var field = properties.get("field");
          var conjunction = properties.get("conjunction");
          if (!conjunction) conjunction = defaultConjunction(config);
          var conjunctionDefinition = config.conjunctions[conjunction];
          var conj = conjunctionDefinition.jsonLogicConj || conjunction.toLowerCase();
          var not = properties.get("not");
          if (conj != "and" && conj != "or") {
            meta.errors.push("Conjunction ".concat(conj, " is not supported"));
            return undefined;
          }
          var isRuleGroup = type === "rule_group" && !isRoot;
          var groupField = isRuleGroup && mode != "struct" ? field : parentField;
          var groupOperator = properties.get("operator");
          var groupOperatorDefinition = groupOperator && getOperatorConfig$4(config, groupOperator, field) || null;
          var formattedValue = formatItemValue$2(config, properties, meta, groupOperator, parentField);
          var isGroup0 = isRuleGroup && (!groupOperator || groupOperatorDefinition.cardinality == 0);
          var list = children.map(function (currentChild) {
            return formatItem$4(currentChild, config, meta, false, groupField);
          }).filter(function (currentChild) {
            return typeof currentChild !== "undefined";
          });
          if (isRuleGroup && mode != "struct" && !isGroup0) {
            // "count" rule can have no "having" children, but should have number value
            if (formattedValue == undefined) return undefined;
          } else {
            if (!list.size) return undefined;
          }
          var resultQuery = {};
          if (list.size == 1 && !isRoot) resultQuery = list.first();else resultQuery[conj] = list.toList().toJS();

          // revert
          if (not) {
            resultQuery = {
              "!": resultQuery
            };
          }

          // rule_group (issue #246)
          if (isRuleGroup && mode != "struct") {
            var formattedField = formatField$3(meta, config, field, parentField);
            if (isGroup0) {
              // config.settings.groupOperators
              var op = groupOperator || "some";
              resultQuery = _defineProperty$4({}, op, [formattedField, resultQuery]);
            } else {
              // there is rule for count
              var filter = !list.size ? formattedField : {
                "filter": [formattedField, resultQuery]
              };
              var count = {
                "reduce": [filter, {
                  "+": [1, {
                    "var": "accumulator"
                  }]
                }, 0]
              };
              resultQuery = formatLogic(config, properties, count, formattedValue, groupOperator);
            }
          }
          return resultQuery;
        };
        var formatRule$4 = function formatRule(item, config, meta) {
          var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var properties = item.get("properties") || new immutableExports.Map();
          var field = properties.get("field");
          var operator = properties.get("operator");
          var operatorOptions = properties.get("operatorOptions");
          operatorOptions = operatorOptions ? operatorOptions.toJS() : null;
          if (operatorOptions && !Object.keys(operatorOptions).length) operatorOptions = null;
          if (field == null || operator == null) return undefined;
          var fieldDefinition = getFieldConfig$8(config, field) || {};
          var operatorDefinition = getOperatorConfig$4(config, operator, field) || {};
          var reversedOp = operatorDefinition.reversedOp;
          var revOperatorDefinition = getOperatorConfig$4(config, reversedOp, field) || {};

          // check op
          var isRev = false;
          if (!operatorDefinition.jsonLogic && !revOperatorDefinition.jsonLogic) {
            meta.errors.push("Operator ".concat(operator, " is not supported"));
            return undefined;
          }
          if (!operatorDefinition.jsonLogic && revOperatorDefinition.jsonLogic) {
            isRev = true;
            var _ref = [reversedOp, operator];
            operator = _ref[0];
            reversedOp = _ref[1];
            var _ref2 = [revOperatorDefinition, operatorDefinition];
            operatorDefinition = _ref2[0];
            revOperatorDefinition = _ref2[1];
          }
          var formattedValue = formatItemValue$2(config, properties, meta, operator, parentField);
          if (formattedValue === undefined) return undefined;
          var formattedField = formatField$3(meta, config, field, parentField);
          return formatLogic(config, properties, formattedField, formattedValue, operator, operatorOptions, fieldDefinition, isRev);
        };
        var formatItemValue$2 = function formatItemValue(config, properties, meta, operator, parentField) {
          var field = properties.get("field");
          var iValueSrc = properties.get("valueSrc");
          var iValueType = properties.get("valueType");
          var fieldDefinition = getFieldConfig$8(config, field) || {};
          var operatorDefinition = getOperatorConfig$4(config, operator, field) || {};
          var cardinality = defaultValue$1(operatorDefinition.cardinality, 1);
          var iValue = properties.get("value");
          var asyncListValues = properties.get("asyncListValues");
          if (iValue == undefined) return undefined;
          var oldUsedFields = meta.usedFields;
          var fvalue = iValue.map(function (currentValue, ind) {
            var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;
            var valueType = iValueType ? iValueType.get(ind) : null;
            var cValue = completeValue(currentValue, valueSrc, config);
            var widget = getWidgetForFieldOp$3(config, field, operator, valueSrc);
            var fieldWidgetDef = omit$1(getFieldWidgetConfig$3(config, field, operator, widget, valueSrc), ["factory"]);
            var fv = formatValue$4(meta, config, cValue, valueSrc, valueType, fieldWidgetDef, fieldDefinition, operator, operatorDefinition, parentField, asyncListValues);
            return fv;
          });
          var hasUndefinedValues = fvalue.filter(function (v) {
            return v === undefined;
          }).size > 0;
          if (fvalue.size < cardinality || hasUndefinedValues) {
            meta.usedFields = oldUsedFields; // restore
            return undefined;
          }
          return cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;
        };
        var formatValue$4 = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef) {
          var parentField = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;
          var asyncListValues = arguments.length > 10 ? arguments[10] : undefined;
          if (currentValue === undefined) return undefined;
          var ret;
          if (valueSrc == "field") {
            ret = formatField$3(meta, config, currentValue, parentField);
          } else if (valueSrc == "func") {
            ret = formatFunc$4(meta, config, currentValue, parentField);
          } else if (typeof fieldWidgetDef.jsonLogic === "function") {
            var fn = fieldWidgetDef.jsonLogic;
            var args = [currentValue, _objectSpread$s(_objectSpread$s({}, pick$1(fieldDef, ["fieldSettings", "listValues"])), {}, {
              asyncListValues: asyncListValues
            }),
            //useful options: valueFormat for date/time
            omit$1(fieldWidgetDef, ["formatValue", "mongoFormatValue", "sqlFormatValue", "jsonLogic", "elasticSearchFormatValue", "spelFormatValue"])];
            if (operator) {
              args.push(operator);
              args.push(operatorDef);
            }
            ret = fn.apply(void 0, args);
          } else {
            ret = currentValue;
          }
          return ret;
        };
        var formatFunc$4 = function formatFunc(meta, config, currentValue) {
          var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var funcKey = currentValue.get("func");
          var args = currentValue.get("args");
          var funcConfig = getFuncConfig$2(config, funcKey);
          if (!funcConfig.jsonLogic) {
            meta.errors.push("Func ".concat(funcKey, " is not supported"));
            return undefined;
          }
          var formattedArgs = {};
          for (var argKey in funcConfig.args) {
            var argConfig = funcConfig.args[argKey];
            var fieldDef = getFieldConfig$8(config, argConfig);
            var argVal = args ? args.get(argKey) : undefined;
            var argValue = argVal ? argVal.get("value") : undefined;
            var argValueSrc = argVal ? argVal.get("valueSrc") : undefined;
            var formattedArgVal = formatValue$4(meta, config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, parentField);
            if (argValue != undefined && formattedArgVal === undefined) {
              meta.errors.push("Can't format value of arg ".concat(argKey, " for func ").concat(funcKey));
              return undefined;
            }
            if (formattedArgVal !== undefined) {
              // skip optional in the end
              formattedArgs[argKey] = formattedArgVal;
            }
          }
          var formattedArgsArr = Object.values(formattedArgs);
          var ret;
          if (typeof funcConfig.jsonLogic === "function") {
            var fn = funcConfig.jsonLogic;
            var _args = [formattedArgs];
            ret = fn.apply(void 0, _args);
          } else {
            var funcName = funcConfig.jsonLogic || funcKey;
            var isMethod = !!funcConfig.jsonLogicIsMethod;
            if (isMethod) {
              var obj = formattedArgsArr[0],
                params = formattedArgsArr.slice(1);
              if (params.length) {
                ret = {
                  "method": [obj, funcName, params]
                };
              } else {
                ret = {
                  "method": [obj, funcName]
                };
              }
            } else {
              ret = _defineProperty$4({}, funcName, formattedArgsArr);
            }
          }
          return ret;
        };
        var formatField$3 = function formatField(meta, config, field) {
          var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var _config$settings = config.settings,
            fieldSeparator = _config$settings.fieldSeparator,
            jsonLogic = _config$settings.jsonLogic;
          var ret;
          if (field) {
            if (Array.isArray(field)) field = field.join(fieldSeparator);
            var fieldDef = getFieldConfig$8(config, field) || {};
            var fieldName = field;
            if (fieldDef.fieldName) {
              fieldName = fieldDef.fieldName;
            }
            if (parentField) {
              var parentFieldDef = getFieldConfig$8(config, parentField) || {};
              var parentFieldName = parentField;
              if (parentFieldDef.fieldName) {
                parentFieldName = parentFieldDef.fieldName;
              }
              if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {
                fieldName = fieldName.slice((parentFieldName + fieldSeparator).length);
              } else {
                meta.errors.push("Can't cut group ".concat(parentFieldName, " from field ").concat(fieldName));
              }
            }
            var varName = fieldDef.jsonLogicVar || (fieldDef.type == "!group" ? jsonLogic.groupVarKey : "var");
            ret = _defineProperty$4({}, varName, fieldName);
            if (meta.usedFields.indexOf(field) == -1) meta.usedFields.push(field);
          }
          return ret;
        };
        var buildFnToFormatOp$3 = function buildFnToFormatOp(operator, operatorDefinition, formattedField, formattedValue) {
          var formatteOp = operator;
          var cardinality = defaultValue$1(operatorDefinition.cardinality, 1);
          var isReverseArgs = defaultValue$1(operatorDefinition._jsonLogicIsRevArgs, false);
          if (typeof operatorDefinition.jsonLogic == "string") formatteOp = operatorDefinition.jsonLogic;
          var rangeOps = ["<", "<=", ">", ">="];
          var eqOps = ["==", "!="];
          var fn = function fn(field, op, val, opDef, opOpts) {
            if (cardinality == 0 && eqOps.includes(formatteOp)) return _defineProperty$4({}, formatteOp, [formattedField, null]);else if (cardinality == 0) return _defineProperty$4({}, formatteOp, formattedField);else if (cardinality == 1 && isReverseArgs) return _defineProperty$4({}, formatteOp, [formattedValue, formattedField]);else if (cardinality == 1) return _defineProperty$4({}, formatteOp, [formattedField, formattedValue]);else if (cardinality == 2 && rangeOps.includes(formatteOp)) return _defineProperty$4({}, formatteOp, [formattedValue[0], formattedField, formattedValue[1]]);else return _defineProperty$4({}, formatteOp, [formattedField].concat(_toConsumableArray(formattedValue)));
          };
          return fn;
        };
        var formatLogic = function formatLogic(config, properties, formattedField, formattedValue, operator) {
          var operatorOptions = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
          var fieldDefinition = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
          var isRev = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
          var field = properties.get("field");
          var operatorDefinition = getOperatorConfig$4(config, operator, field) || {};
          var fn = typeof operatorDefinition.jsonLogic == "function" ? operatorDefinition.jsonLogic : buildFnToFormatOp$3(operator, operatorDefinition, formattedField, formattedValue);
          var args = [formattedField, operator, formattedValue, omit$1(operatorDefinition, ["formatOp", "mongoFormatOp", "sqlFormatOp", "jsonLogic", "spelFormatOp"]), operatorOptions, fieldDefinition];
          var ruleQuery = fn.apply(void 0, args);
          if (isRev) {
            ruleQuery = {
              "!": ruleQuery
            };
          }
          return ruleQuery;
        };
        function ownKeys$r(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$r(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$r(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$r(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }

        // helpers
        var isObject$2 = function isObject(v) {
          return _typeof$2(v) == "object" && v !== null && !Array.isArray(v);
        };
        var mongodbFormat = function mongodbFormat(tree, config) {
          return _mongodbFormat(tree, config, false);
        };
        var _mongodbFormat = function _mongodbFormat(tree, config) {
          var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          //meta is mutable
          var meta = {
            errors: []
          };
          var res = formatItem$3([], tree, config, meta);
          if (returnErrors) {
            return [res, meta.errors];
          } else {
            if (meta.errors.length) console.warn("Errors while exporting to MongoDb:", meta.errors);
            return res;
          }
        };
        var formatItem$3 = function formatItem(parents, item, config, meta) {
          var _not = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
          var _canWrapExpr = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
          var _fieldName = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;
          var _value = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;
          if (!item) return undefined;
          var type = item.get("type");
          if (type === "group" || type === "rule_group") {
            return formatGroup$3(parents, item, config, meta, _not, _canWrapExpr, _fieldName, _value);
          } else if (type === "rule") {
            return formatRule$3(parents, item, config, meta, _not, _canWrapExpr, _fieldName, _value);
          }
          return undefined;
        };
        var formatGroup$3 = function formatGroup(parents, item, config, meta) {
          var _not = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
          var type = item.get("type");
          var properties = item.get("properties") || new immutableExports.Map();
          var children = item.get("children1") || new immutableExports.List();
          var canShortMongoQuery = config.settings.canShortMongoQuery;
          var hasParentRuleGroup = parents.filter(function (it) {
            return it.get("type") == "rule_group";
          }).length > 0;
          var parentPath = parents.filter(function (it) {
            return it.get("type") == "rule_group";
          }).map(function (it) {
            return it.get("properties").get("field");
          }).slice(-1).pop();
          var realParentPath = hasParentRuleGroup && parentPath;
          var groupField = type === "rule_group" ? properties.get("field") : null;
          var groupFieldName = formatFieldName(groupField, config, meta, realParentPath);
          var groupFieldDef = getFieldConfig$8(config, groupField) || {};
          var mode = groupFieldDef.mode; //properties.get("mode");
          var canHaveEmptyChildren = groupField && mode == "array";
          var not = _not ? !properties.get("not") : properties.get("not");
          var list = children.map(function (currentChild) {
            return formatItem$3([].concat(_toConsumableArray(parents), [item]), currentChild, config, meta, not, mode != "array", mode == "array" ? function (f) {
              return "$$el.".concat(f);
            } : undefined);
          }).filter(function (currentChild) {
            return typeof currentChild !== "undefined";
          });
          if (!canHaveEmptyChildren && !list.size) return undefined;
          var conjunction = properties.get("conjunction");
          if (!conjunction) conjunction = defaultConjunction(config);
          var conjunctionDefinition = config.conjunctions[conjunction];
          var reversedConj = conjunctionDefinition.reversedConj;
          if (not && reversedConj) {
            conjunction = reversedConj;
            conjunctionDefinition = config.conjunctions[conjunction];
          }
          var mongoConj = conjunctionDefinition.mongoConj;
          var resultQuery;
          if (list.size == 1) {
            resultQuery = list.first();
          } else if (list.size > 1) {
            var rules = list.toList().toJS();
            var canShort = canShortMongoQuery && mongoConj == "$and";
            if (canShort) {
              resultQuery = rules.reduce(function (acc, rule) {
                if (!acc) return undefined;
                for (var k in rule) {
                  if (k[0] == "$") {
                    acc = undefined;
                    break;
                  }
                  if (acc[k] == undefined) {
                    acc[k] = rule[k];
                  } else {
                    // https://github.com/ukrbublik/react-awesome-query-builder/issues/182
                    var prev = acc[k],
                      next = rule[k];
                    if (!isObject$2(prev)) {
                      prev = {
                        "$eq": prev
                      };
                    }
                    if (!isObject$2(next)) {
                      next = {
                        "$eq": next
                      };
                    }
                    var prevOp = Object.keys(prev)[0],
                      nextOp = Object.keys(next)[0];
                    if (prevOp == nextOp) {
                      acc = undefined;
                      break;
                    }
                    acc[k] = Object.assign({}, prev, next);
                  }
                }
                return acc;
              }, {});
            }
            if (!resultQuery)
              // can't be shorten
              resultQuery = _defineProperty$4({}, mongoConj, rules);
          }
          if (groupField) {
            if (mode == "array") {
              var totalQuery = {
                "$size": groupFieldName
              };
              var filterQuery = resultQuery ? {
                "$size": {
                  "$ifNull": [{
                    "$filter": {
                      input: "$" + groupFieldName,
                      as: "el",
                      cond: resultQuery
                    }
                  }, []]
                }
              } : totalQuery;
              resultQuery = formatItem$3(parents, item.set("type", "rule"), config, meta, false, false, function (_f) {
                return filterQuery;
              }, totalQuery);
              resultQuery = {
                "$expr": resultQuery
              };
            } else {
              resultQuery = _defineProperty$4({}, groupFieldName, {
                "$elemMatch": resultQuery
              });
            }
          }
          return resultQuery;
        };
        var formatRule$3 = function formatRule(parents, item, config, meta) {
          var _not = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
          var _canWrapExpr = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
          var _fieldName = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;
          var _value = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;
          var properties = item.get("properties") || new immutableExports.Map();
          var hasParentRuleGroup = parents.filter(function (it) {
            return it.get("type") == "rule_group";
          }).length > 0;
          var parentPath = parents.filter(function (it) {
            return it.get("type") == "rule_group";
          }).map(function (it) {
            return it.get("properties").get("field");
          }).slice(-1).pop();
          var realParentPath = hasParentRuleGroup && parentPath;
          var operator = properties.get("operator");
          var operatorOptions = properties.get("operatorOptions");
          var field = properties.get("field");
          var iValue = properties.get("value");
          var iValueSrc = properties.get("valueSrc");
          var iValueType = properties.get("valueType");
          var asyncListValues = properties.get("asyncListValues");
          if (field == null || operator == null || iValue === undefined) return undefined;
          var fieldDef = getFieldConfig$8(config, field) || {};
          var operatorDefinition = getOperatorConfig$4(config, operator, field) || {};
          var reversedOp = operatorDefinition.reversedOp;
          var revOperatorDefinition = getOperatorConfig$4(config, reversedOp, field) || {};
          var cardinality = defaultValue$1(operatorDefinition.cardinality, 1);
          var not = _not;
          if (not && reversedOp) {
            var _ref = [reversedOp, operator];
            operator = _ref[0];
            reversedOp = _ref[1];
            var _ref2 = [revOperatorDefinition, operatorDefinition];
            operatorDefinition = _ref2[0];
            revOperatorDefinition = _ref2[1];
            not = false;
          }
          var fieldName = formatFieldName(field, config, meta, realParentPath);

          //format value
          var valueSrcs = [];
          var valueTypes = [];
          var useExpr = false;
          var fvalue = iValue.map(function (currentValue, ind) {
            var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;
            var valueType = iValueType ? iValueType.get(ind) : null;
            var cValue = completeValue(currentValue, valueSrc, config);
            var widget = getWidgetForFieldOp$3(config, field, operator, valueSrc);
            var fieldWidgetDef = omit$1(getFieldWidgetConfig$3(config, field, operator, widget, valueSrc), ["factory"]);
            var _formatValue = formatValue$3(meta, config, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, realParentPath, operator, operatorDefinition, asyncListValues),
              _formatValue2 = _slicedToArray$1(_formatValue, 2),
              fv = _formatValue2[0],
              fvUseExpr = _formatValue2[1];
            if (fv !== undefined) {
              useExpr = useExpr || fvUseExpr;
              valueSrcs.push(valueSrc);
              valueTypes.push(valueType);
            }
            return fv;
          });
          if (_fieldName) useExpr = true;
          var wrapExpr = useExpr && _canWrapExpr;
          var hasUndefinedValues = fvalue.filter(function (v) {
            return v === undefined;
          }).size > 0;
          if (fvalue.size < cardinality || hasUndefinedValues) return undefined;
          var formattedValue = cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;

          //build rule
          var fn = operatorDefinition.mongoFormatOp;
          if (!fn) {
            meta.errors.push("Operator ".concat(operator, " is not supported"));
            return undefined;
          }
          var args = [_fieldName ? _fieldName(fieldName) : fieldName, operator, _value !== undefined && formattedValue == null ? _value : formattedValue, useExpr, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0], omit$1(operatorDefinition, ["formatOp", "mongoFormatOp", "sqlFormatOp", "jsonLogic", "spelFormatOp"]), operatorOptions, fieldDef];
          var ruleQuery = fn.apply(void 0, args);
          if (wrapExpr) {
            ruleQuery = {
              "$expr": ruleQuery
            };
          }
          if (not) {
            ruleQuery = {
              "$not": ruleQuery
            };
          }
          return ruleQuery;
        };
        var formatValue$3 = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, parentPath, operator, operatorDef, asyncListValues) {
          if (currentValue === undefined) return [undefined, false];
          var ret;
          var useExpr = false;
          if (valueSrc == "field") {
            var _formatRightField = formatRightField(meta, config, currentValue, parentPath);
            var _formatRightField2 = _slicedToArray$1(_formatRightField, 2);
            ret = _formatRightField2[0];
            useExpr = _formatRightField2[1];
          } else if (valueSrc == "func") {
            var _formatFunc = formatFunc$3(meta, config, currentValue, parentPath);
            var _formatFunc2 = _slicedToArray$1(_formatFunc, 2);
            ret = _formatFunc2[0];
            useExpr = _formatFunc2[1];
          } else {
            if (typeof fieldWidgetDef.mongoFormatValue === "function") {
              var fn = fieldWidgetDef.mongoFormatValue;
              var args = [currentValue, _objectSpread$r(_objectSpread$r({}, pick$1(fieldDef, ["fieldSettings", "listValues"])), {}, {
                asyncListValues: asyncListValues
              }),
              //useful options: valueFormat for date/time
              omit$1(fieldWidgetDef, ["formatValue", "mongoFormatValue", "sqlFormatValue", "jsonLogic", "elasticSearchFormatValue", "spelFormatValue"])];
              if (operator) {
                args.push(operator);
                args.push(operatorDef);
              }
              ret = fn.apply(void 0, args);
            } else {
              ret = currentValue;
            }
          }
          return [ret, useExpr];
        };
        var formatFieldName = function formatFieldName(field, config, meta, parentPath) {
          if (!field) return;
          var fieldDef = getFieldConfig$8(config, field) || {};
          var fieldSeparator = config.settings.fieldSeparator;
          Array.isArray(field) ? field : field.split(fieldSeparator);
          var fieldName = Array.isArray(field) ? field.join(fieldSeparator) : field;
          // if (fieldDef.tableName) { // legacy
          //     const fieldPartsCopy = [...fieldParts];
          //     fieldPartsCopy[0] = fieldDef.tableName;
          //     fieldName = fieldPartsCopy.join(fieldSeparator);
          // }
          if (fieldDef.fieldName) {
            fieldName = fieldDef.fieldName;
          }
          if (parentPath) {
            var parentFieldDef = getFieldConfig$8(config, parentPath) || {};
            var parentFieldName = parentPath;
            if (parentFieldDef.fieldName) {
              parentFieldName = parentFieldDef.fieldName;
            }
            if (fieldName.indexOf(parentFieldName + ".") == 0) {
              fieldName = fieldName.slice((parentFieldName + ".").length);
            } else {
              meta.errors.push("Can't cut group ".concat(parentFieldName, " from field ").concat(fieldName));
            }
          }
          return fieldName;
        };
        var formatRightField = function formatRightField(meta, config, rightField, parentPath) {
          var fieldSeparator = config.settings.fieldSeparator;
          var ret;
          var useExpr = true;
          if (rightField) {
            var rightFieldDefinition = getFieldConfig$8(config, rightField) || {};
            var fieldParts = Array.isArray(rightField) ? rightField : rightField.split(fieldSeparator);
            getFieldPath$3(rightField, config);
            var fieldPartsLabels = getFieldPathLabels$3(rightField, config);
            var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparator) : null;
            var formatFieldFn = config.settings.formatField;
            var rightFieldName = formatFieldName(rightField, config, meta, parentPath);
            var formattedField = formatFieldFn(rightFieldName, fieldParts, fieldFullLabel, rightFieldDefinition, config, false);
            ret = "$" + formattedField;
          }
          return [ret, useExpr];
        };
        var formatFunc$3 = function formatFunc(meta, config, currentValue, parentPath) {
          var useExpr = true;
          var ret;
          var funcKey = currentValue.get("func");
          var args = currentValue.get("args");
          var funcConfig = getFuncConfig$2(config, funcKey);
          var funcName = funcConfig.mongoFunc || funcKey;
          var mongoArgsAsObject = funcConfig.mongoArgsAsObject;
          var formattedArgs = {};
          var argsCnt = 0;
          var lastArg = undefined;
          for (var argKey in funcConfig.args) {
            var argConfig = funcConfig.args[argKey];
            var fieldDef = getFieldConfig$8(config, argConfig);
            var argVal = args ? args.get(argKey) : undefined;
            var argValue = argVal ? argVal.get("value") : undefined;
            var argValueSrc = argVal ? argVal.get("valueSrc") : undefined;
            var argAsyncListValues = argVal ? argVal.get("asyncListValues") : undefined;
            var widget = getWidgetForFieldOp$3(config, fieldDef, null, argValueSrc);
            var fieldWidgetDef = omit$1(getFieldWidgetConfig$3(config, fieldDef, null, widget, argValueSrc), ["factory"]);
            var _formatValue3 = formatValue$3(meta, config, argValue, argValueSrc, argConfig.type, fieldWidgetDef, fieldDef, parentPath, null, null, argAsyncListValues),
              _formatValue4 = _slicedToArray$1(_formatValue3, 2),
              formattedArgVal = _formatValue4[0];
            _formatValue4[1];
            if (argValue != undefined && formattedArgVal === undefined) {
              meta.errors.push("Can't format value of arg ".concat(argKey, " for func ").concat(funcKey));
              return [undefined, false];
            }
            argsCnt++;
            if (formattedArgVal !== undefined) {
              // skip optional in the end
              formattedArgs[argKey] = formattedArgVal;
              lastArg = formattedArgVal;
            }
          }
          if (typeof funcConfig.mongoFormatFunc === "function") {
            var fn = funcConfig.mongoFormatFunc;
            var _args = [formattedArgs];
            ret = fn.apply(void 0, _args);
          } else if (funcConfig.mongoFormatFunc === null) {
            meta.errors.push("Functon ".concat(funcName, " is not supported"));
            return [undefined, false];
          } else {
            if (mongoArgsAsObject) ret = _defineProperty$4({}, funcName, formattedArgs);else if (argsCnt == 1 && lastArg !== undefined) ret = _defineProperty$4({}, funcName, lastArg);else ret = _defineProperty$4({}, funcName, Object.values(formattedArgs));
          }
          return [ret, useExpr];
        };
        var SqlString$2 = {};
        (function (exports) {
          var SqlString = exports;
          var ID_GLOBAL_REGEXP = /`/g;
          var QUAL_GLOBAL_REGEXP = /\./g;
          var CHARS_GLOBAL_REGEXP = /[\0\b\t\n\r\x1a\"\'\\]/g; // eslint-disable-line no-control-regex
          var CHARS_ESCAPE_MAP = {
            '\0': '\\0',
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\r': '\\r',
            '\x1a': '\\Z',
            '"': '\\"',
            '\'': '\\\'',
            '\\': '\\\\'
          };
          SqlString.escapeId = function escapeId(val, forbidQualified) {
            if (Array.isArray(val)) {
              var sql = '';
              for (var i = 0; i < val.length; i++) {
                sql += (i === 0 ? '' : ', ') + SqlString.escapeId(val[i], forbidQualified);
              }
              return sql;
            } else if (forbidQualified) {
              return '`' + String(val).replace(ID_GLOBAL_REGEXP, '``') + '`';
            } else {
              return '`' + String(val).replace(ID_GLOBAL_REGEXP, '``').replace(QUAL_GLOBAL_REGEXP, '`.`') + '`';
            }
          };
          SqlString.escape = function escape(val, stringifyObjects, timeZone) {
            if (val === undefined || val === null) {
              return 'NULL';
            }
            switch (typeof val) {
              case 'boolean':
                return val ? 'true' : 'false';
              case 'number':
                return val + '';
              case 'object':
                if (Object.prototype.toString.call(val) === '[object Date]') {
                  return SqlString.dateToString(val, timeZone || 'local');
                } else if (Array.isArray(val)) {
                  return SqlString.arrayToList(val, timeZone);
                } else if (Buffer.isBuffer(val)) {
                  return SqlString.bufferToString(val);
                } else if (typeof val.toSqlString === 'function') {
                  return String(val.toSqlString());
                } else if (stringifyObjects) {
                  return escapeString(val.toString());
                } else {
                  return SqlString.objectToValues(val, timeZone);
                }
              default:
                return escapeString(val);
            }
          };
          SqlString.arrayToList = function arrayToList(array, timeZone) {
            var sql = '';
            for (var i = 0; i < array.length; i++) {
              var val = array[i];
              if (Array.isArray(val)) {
                sql += (i === 0 ? '' : ', ') + '(' + SqlString.arrayToList(val, timeZone) + ')';
              } else {
                sql += (i === 0 ? '' : ', ') + SqlString.escape(val, true, timeZone);
              }
            }
            return sql;
          };
          SqlString.format = function format(sql, values, stringifyObjects, timeZone) {
            if (values == null) {
              return sql;
            }
            if (!Array.isArray(values)) {
              values = [values];
            }
            var chunkIndex = 0;
            var placeholdersRegex = /\?+/g;
            var result = '';
            var valuesIndex = 0;
            var match;
            while (valuesIndex < values.length && (match = placeholdersRegex.exec(sql))) {
              var len = match[0].length;
              if (len > 2) {
                continue;
              }
              var value = len === 2 ? SqlString.escapeId(values[valuesIndex]) : SqlString.escape(values[valuesIndex], stringifyObjects, timeZone);
              result += sql.slice(chunkIndex, match.index) + value;
              chunkIndex = placeholdersRegex.lastIndex;
              valuesIndex++;
            }
            if (chunkIndex === 0) {
              // Nothing was replaced
              return sql;
            }
            if (chunkIndex < sql.length) {
              return result + sql.slice(chunkIndex);
            }
            return result;
          };
          SqlString.dateToString = function dateToString(date, timeZone) {
            var dt = new Date(date);
            if (isNaN(dt.getTime())) {
              return 'NULL';
            }
            var year;
            var month;
            var day;
            var hour;
            var minute;
            var second;
            var millisecond;
            if (timeZone === 'local') {
              year = dt.getFullYear();
              month = dt.getMonth() + 1;
              day = dt.getDate();
              hour = dt.getHours();
              minute = dt.getMinutes();
              second = dt.getSeconds();
              millisecond = dt.getMilliseconds();
            } else {
              var tz = convertTimezone(timeZone);
              if (tz !== false && tz !== 0) {
                dt.setTime(dt.getTime() + tz * 60000);
              }
              year = dt.getUTCFullYear();
              month = dt.getUTCMonth() + 1;
              day = dt.getUTCDate();
              hour = dt.getUTCHours();
              minute = dt.getUTCMinutes();
              second = dt.getUTCSeconds();
              millisecond = dt.getUTCMilliseconds();
            }

            // YYYY-MM-DD HH:mm:ss.mmm
            var str = zeroPad(year, 4) + '-' + zeroPad(month, 2) + '-' + zeroPad(day, 2) + ' ' + zeroPad(hour, 2) + ':' + zeroPad(minute, 2) + ':' + zeroPad(second, 2) + '.' + zeroPad(millisecond, 3);
            return escapeString(str);
          };
          SqlString.bufferToString = function bufferToString(buffer) {
            return 'X' + escapeString(buffer.toString('hex'));
          };
          SqlString.objectToValues = function objectToValues(object, timeZone) {
            var sql = '';
            for (var key in object) {
              var val = object[key];
              if (typeof val === 'function') {
                continue;
              }
              sql += (sql.length === 0 ? '' : ', ') + SqlString.escapeId(key) + ' = ' + SqlString.escape(val, true, timeZone);
            }
            return sql;
          };
          SqlString.raw = function raw(sql) {
            if (typeof sql !== 'string') {
              throw new TypeError('argument sql must be a string');
            }
            return {
              toSqlString: function toSqlString() {
                return sql;
              }
            };
          };
          function escapeString(val) {
            var chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex = 0;
            var escapedVal = '';
            var match;
            while (match = CHARS_GLOBAL_REGEXP.exec(val)) {
              escapedVal += val.slice(chunkIndex, match.index) + CHARS_ESCAPE_MAP[match[0]];
              chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex;
            }
            if (chunkIndex === 0) {
              // Nothing was escaped
              return "'" + val + "'";
            }
            if (chunkIndex < val.length) {
              return "'" + escapedVal + val.slice(chunkIndex) + "'";
            }
            return "'" + escapedVal + "'";
          }
          function zeroPad(number, length) {
            number = number.toString();
            while (number.length < length) {
              number = '0' + number;
            }
            return number;
          }
          function convertTimezone(tz) {
            if (tz === 'Z') {
              return 0;
            }
            var m = tz.match(/([\+\-\s])(\d\d):?(\d\d)?/);
            if (m) {
              return (m[1] === '-' ? -1 : 1) * (parseInt(m[2], 10) + (m[3] ? parseInt(m[3], 10) : 0) / 60) * 60;
            }
            return false;
          }
        })(SqlString$2);
        var sqlstring = SqlString$2;
        const SqlStringOrig = /*@__PURE__*/getDefaultExportFromCjs(sqlstring);
        var SqlString$1 = SqlStringOrig;
        SqlString$1.trim = function (val) {
          if (val.charAt(0) == "'") return val.substring(1, val.length - 1);else return val;
        };
        SqlString$1.escapeLike = function (val) {
          var any_start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          var any_end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          // normal escape
          var res = SqlString$1.escape(val);
          // unwrap ''
          res = SqlString$1.trim(res);
          // escape % and _
          res = res.replace(/[%_]/g, "\\$&");
          // wrap with % for LIKE
          res = (any_start ? "%" : "") + res + (any_end ? "%" : "");
          // wrap ''
          res = "'" + res + "'";
          return res;
        };
        var sqlEmptyValue = function sqlEmptyValue(fieldDef) {
          var v = "''";
          var type = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.type;
          if (type == "date") {
            //todo: support other SQL dialects?  0001-01-01 for oracle, 1970-01-01 for timestamp
            v = "'0000-00-00'";
          } else if (type == "datetime") {
            v = "'0000-00-00 00:00'";
          } else if (type == "time") {
            v = "'00:00'";
          } else if (type == "number") {
            v = "0";
          }
          return v;
        };
        var mongoEmptyValue = function mongoEmptyValue(fieldDef) {
          var v = "";
          var type = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.type;
          if (type == "number") {
            v = 0;
          }
          return v;
        };
        var spelEscapeString = function spelEscapeString(val) {
          // Strings are delimited by single quotes. To put a single quote itself in a string, use two single quote characters. 
          return "'" + val.replace(/'/g, "''") + "'";
        };
        var spelInlineList = function spelInlineList(vals) {
          var toArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          // find java type of values
          var javaType;
          var jt;
          var numberJavaTypes = ["int", "float"];
          vals.map(function (v) {
            if (v !== undefined && v !== null) {
              if (typeof v === "string") {
                jt = "String";
              } else if (typeof v === "number") {
                jt = Number.isInteger(v) ? "int" : "float";
              } else throw new Error("spelEscape: Can't use value ".concat(v, " in array"));
              if (!javaType) {
                javaType = jt;
              } else if (javaType != jt) {
                if (numberJavaTypes.includes(javaType) && numberJavaTypes.includes(jt)) {
                  // found int and float in collecton - use float
                  javaType = "float";
                } else throw new Error("spelEscape: Can't use different types in array: found ".concat(javaType, " and ").concat(jt));
              }
            }
          });
          if (!javaType) {
            javaType = "String"; //default if empty array
          }

          // for floats we should add 'f' to all items
          var escapedVals;
          if (javaType == "float") {
            escapedVals = vals.map(function (v) {
              return spelEscape(v, true);
            });
          } else {
            escapedVals = vals.map(function (v) {
              return spelEscape(v);
            });
          }

          // build inline list or array
          var res;
          if (toArray) {
            res = "new ".concat(javaType, "[]{").concat(escapedVals.join(", "), "}");
          } else {
            res = "{".concat(escapedVals.join(", "), "}");
          }
          return res;
        };
        var spelFixList = function spelFixList(val) {
          // `{1,2}.contains(1)` NOT works
          // `{1,2}.?[true].contains(1)` works
          return "".concat(val, ".?[true]");
        };
        var spelEscape = function spelEscape(val) {
          var numberToFloat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var arrayToArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          // https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html#expressions-ref-literal
          if (val === undefined || val === null) {
            return "null";
          }
          switch (_typeof$2(val)) {
            case "boolean":
              return val ? "true" : "false";
            case "number":
              if (!Number.isFinite(val) || isNaN(val)) return undefined;
              return val + (!Number.isInteger(val) || numberToFloat ? "f" : "");
            case "object":
              if (Array.isArray(val)) {
                return spelInlineList(val, arrayToArray);
              } else {
                // see `spelFormatValue` for Date, LocalTime
                throw new Error("spelEscape: Object is not supported");
              }
            default:
              return spelEscapeString(val);
          }
        };
        var spelFormatConcat = function spelFormatConcat(parts) {
          if (parts && Array.isArray(parts) && parts.length) {
            return parts.map(function (part) {
              if (part.type == "const") {
                return spelEscape(part.value);
              } else if (part.type == "property") {
                return "" + part.value;
              } else if (part.type == "variable") {
                return "#" + part.value;
              }
              return undefined;
            }).filter(function (r) {
              return r != undefined;
            }).join(" + ");
          } else {
            return "null";
          }
        };

        // `val` is {value, valueType, valueSrc}
        // If `valueType` == "case_value", `value` is array of such items (to be considered as concatenation)
        var spelImportConcat = function spelImportConcat(val) {
          if (val == undefined) return [undefined, []];
          var errors = [];
          var parts = val.valueType == "case_value" ? val.value : [val];
          var res = parts.map(function (child) {
            if (child.valueSrc == "value") {
              if (child.value === null) {
                return undefined;
              } else {
                return {
                  type: "const",
                  value: child.value
                };
              }
            } else if (child.valueSrc == "field") {
              return {
                type: child.isVariable ? "variable" : "property",
                value: child.value
              };
            } else {
              errors.push("Unsupported valueSrc ".concat(child.valueSrc, " in concatenation"));
            }
          }).filter(function (v) {
            return v != undefined;
          });
          return [res, errors];
        };
        var stringifyForDisplay$1 = function stringifyForDisplay(v) {
          return v == null ? "NULL" : v.toString();
        };
        const _export = /*#__PURE__*/Object.freeze( /*#__PURE__*/Object.defineProperty({
          __proto__: null,
          SqlString: SqlString$1,
          mongoEmptyValue,
          spelEscape,
          spelFixList,
          spelFormatConcat,
          spelImportConcat,
          sqlEmptyValue,
          stringifyForDisplay: stringifyForDisplay$1
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        function ownKeys$q(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$q(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$q(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$q(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        var sqlFormat = function sqlFormat(tree, config) {
          return _sqlFormat(tree, config, false);
        };
        var _sqlFormat = function _sqlFormat(tree, config) {
          var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          //meta is mutable
          var meta = {
            errors: []
          };
          var res = formatItem$2(tree, config, meta);
          if (returnErrors) {
            return [res, meta.errors];
          } else {
            if (meta.errors.length) console.warn("Errors while exporting to SQL:", meta.errors);
            return res;
          }
        };
        var formatItem$2 = function formatItem(item, config, meta) {
          if (!item) return undefined;
          var type = item.get("type");
          item.get("children1");
          if (type === "group" || type === "rule_group") {
            return formatGroup$2(item, config, meta);
          } else if (type === "rule") {
            return formatRule$2(item, config, meta);
          }
          return undefined;
        };
        var formatGroup$2 = function formatGroup(item, config, meta) {
          var type = item.get("type");
          var properties = item.get("properties") || new immutableExports.Map();
          var children = item.get("children1") || new immutableExports.List();
          var isRuleGroup = type === "rule_group";
          var groupField = isRuleGroup ? properties.get("field") : null;
          var groupFieldDef = getFieldConfig$8(config, groupField) || {};
          var mode = groupFieldDef.mode;
          if (mode == "array") {
            meta.errors.push("Aggregation is not supported for ".concat(groupField));
          }
          var not = properties.get("not");
          var list = children.map(function (currentChild) {
            return formatItem$2(currentChild, config, meta);
          }).filter(function (currentChild) {
            return typeof currentChild !== "undefined";
          });
          if (!list.size) return undefined;
          var conjunction = properties.get("conjunction");
          if (!conjunction) conjunction = defaultConjunction(config);
          var conjunctionDefinition = config.conjunctions[conjunction];
          return conjunctionDefinition.sqlFormatConj(list, conjunction, not);
        };
        var buildFnToFormatOp$2 = function buildFnToFormatOp(operator, operatorDefinition) {
          var sqlOp = operatorDefinition.sqlOp || operator;
          var cardinality = defaultValue$1(operatorDefinition.cardinality, 1);
          var fn;
          if (cardinality == 0) {
            fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
              return "".concat(field, " ").concat(sqlOp);
            };
          } else if (cardinality == 1) {
            fn = function fn(field, op, value, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
              return "".concat(field, " ").concat(sqlOp, " ").concat(value);
            };
          } else if (cardinality == 2) {
            // between
            fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
              var valFrom = values.first();
              var valTo = values.get(1);
              return "".concat(field, " ").concat(sqlOp, " ").concat(valFrom, " AND ").concat(valTo);
            };
          }
          return fn;
        };
        var formatRule$2 = function formatRule(item, config, meta) {
          var properties = item.get("properties") || new immutableExports.Map();
          var field = properties.get("field");
          var operator = properties.get("operator");
          var operatorOptions = properties.get("operatorOptions");
          var iValueSrc = properties.get("valueSrc");
          var iValueType = properties.get("valueType");
          var iValue = properties.get("value");
          var asyncListValues = properties.get("asyncListValues");
          if (field == null || operator == null) return undefined;
          var fieldDefinition = getFieldConfig$8(config, field) || {};
          var opDef = getOperatorConfig$4(config, operator, field) || {};
          var reversedOp = opDef.reversedOp;
          var revOpDef = getOperatorConfig$4(config, reversedOp, field) || {};
          var cardinality = defaultValue$1(opDef.cardinality, 1);

          // check op
          var isRev = false;
          var canFormatOp = opDef.sqlOp || opDef.sqlFormatOp;
          var canFormatRevOp = revOpDef.sqlOp || revOpDef.sqlFormatOp;
          if (!canFormatOp && !canFormatRevOp) {
            meta.errors.push("Operator ".concat(operator, " is not supported"));
            return undefined;
          }
          if (!canFormatRevOp && canFormatRevOp) {
            isRev = true;
            var _ref = [reversedOp, operator];
            operator = _ref[0];
            reversedOp = _ref[1];
            var _ref2 = [revOpDef, opDef];
            opDef = _ref2[0];
            revOpDef = _ref2[1];
          }

          //format value
          var valueSrcs = [];
          var valueTypes = [];
          var fvalue = iValue.map(function (currentValue, ind) {
            var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;
            var valueType = iValueType ? iValueType.get(ind) : null;
            var cValue = completeValue(currentValue, valueSrc, config);
            var widget = getWidgetForFieldOp$3(config, field, operator, valueSrc);
            var fieldWidgetDefinition = omit$1(getFieldWidgetConfig$3(config, field, operator, widget, valueSrc), ["factory"]);
            var fv = formatValue$2(meta, config, cValue, valueSrc, valueType, fieldWidgetDefinition, fieldDefinition, operator, opDef, asyncListValues);
            if (fv !== undefined) {
              valueSrcs.push(valueSrc);
              valueTypes.push(valueType);
            }
            return fv;
          });
          var hasUndefinedValues = fvalue.filter(function (v) {
            return v === undefined;
          }).size > 0;
          if (hasUndefinedValues || fvalue.size < cardinality) return undefined;
          var formattedValue = cardinality == 1 ? fvalue.first() : fvalue;

          //find fn to format expr
          var fn = opDef.sqlFormatOp || buildFnToFormatOp$2(operator, opDef);
          if (!fn) {
            meta.errors.push("Operator ".concat(operator, " is not supported"));
            return undefined;
          }

          //format field
          var formattedField = formatField$2(meta, config, field);

          //format expr
          var args = [formattedField, operator, formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0], omit$1(opDef, ["formatOp", "mongoFormatOp", "sqlFormatOp", "jsonLogic", "spelFormatOp"]), operatorOptions, fieldDefinition];
          var ret;
          ret = fn.apply(void 0, args);
          if (isRev) {
            ret = config.settings.sqlFormatReverse(ret);
          }
          if (ret === undefined) {
            meta.errors.push("Operator ".concat(operator, " is not supported for value source ").concat(valueSrcs.join(", ")));
            return undefined;
          }
          return ret;
        };
        var formatValue$2 = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef, asyncListValues) {
          if (currentValue === undefined) return undefined;
          var ret;
          if (valueSrc == "field") {
            ret = formatField$2(meta, config, currentValue);
          } else if (valueSrc == "func") {
            ret = formatFunc$2(meta, config, currentValue);
          } else {
            if (typeof fieldWidgetDef.sqlFormatValue === "function") {
              var fn = fieldWidgetDef.sqlFormatValue;
              var args = [currentValue, _objectSpread$q(_objectSpread$q({}, pick$1(fieldDef, ["fieldSettings", "listValues"])), {}, {
                asyncListValues: asyncListValues
              }),
              //useful options: valueFormat for date/time
              omit$1(fieldWidgetDef, ["formatValue", "mongoFormatValue", "sqlFormatValue", "jsonLogic", "elasticSearchFormatValue", "spelFormatValue"])];
              if (operator) {
                args.push(operator);
                args.push(operatorDef);
              }
              if (valueSrc == "field") {
                var valFieldDefinition = getFieldConfig$8(config, currentValue) || {};
                args.push(valFieldDefinition);
              }
              ret = fn.apply(void 0, args);
            } else {
              if (Array.isArray(currentValue)) {
                ret = currentValue.map(function (v) {
                  return SqlString$1.escape(v);
                });
              } else {
                ret = SqlString$1.escape(currentValue);
              }
            }
          }
          return ret;
        };
        var formatField$2 = function formatField(meta, config, field) {
          if (!field) return;
          var fieldSeparator = config.settings.fieldSeparator;
          var fieldDefinition = getFieldConfig$8(config, field) || {};
          var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);
          getFieldPath$3(field, config);
          var fieldPartsLabels = getFieldPathLabels$3(field, config);
          var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparator) : null;
          var formatFieldFn = config.settings.formatField;
          var fieldName = formatFieldName$1(field, config, meta);
          var formattedField = formatFieldFn(fieldName, fieldParts, fieldFullLabel, fieldDefinition, config);
          return formattedField;
        };
        var formatFunc$2 = function formatFunc(meta, config, currentValue) {
          var funcKey = currentValue.get("func");
          var args = currentValue.get("args");
          var funcConfig = getFuncConfig$2(config, funcKey);
          var funcName = funcConfig.sqlFunc || funcKey;
          var formattedArgs = {};
          for (var argKey in funcConfig.args) {
            var argConfig = funcConfig.args[argKey];
            var fieldDef = getFieldConfig$8(config, argConfig);
            var argVal = args ? args.get(argKey) : undefined;
            var argValue = argVal ? argVal.get("value") : undefined;
            var argValueSrc = argVal ? argVal.get("valueSrc") : undefined;
            var argAsyncListValues = argVal ? argVal.get("asyncListValues") : undefined;
            var formattedArgVal = formatValue$2(meta, config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, argAsyncListValues);
            if (argValue != undefined && formattedArgVal === undefined) {
              meta.errors.push("Can't format value of arg ".concat(argKey, " for func ").concat(funcKey));
              return undefined;
            }
            if (formattedArgVal !== undefined) {
              // skip optional in the end
              formattedArgs[argKey] = formattedArgVal;
            }
          }
          var ret;
          if (typeof funcConfig.sqlFormatFunc === "function") {
            var fn = funcConfig.sqlFormatFunc;
            var _args = [formattedArgs];
            ret = fn.apply(void 0, _args);
          } else {
            var argsStr = Object.entries(formattedArgs).map(function (_ref3) {
              var _ref4 = _slicedToArray$1(_ref3, 2);
              _ref4[0];
              var v = _ref4[1];
              return v;
            }).join(", ");
            ret = "".concat(funcName, "(").concat(argsStr, ")");
          }
          return ret;
        };
        function ownKeys$p(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$p(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$p(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$p(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        var spelFormat = function spelFormat(tree, config) {
          return _spelFormat(tree, config, false);
        };
        var _spelFormat = function _spelFormat(tree, config) {
          var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          //meta is mutable
          var meta = {
            errors: []
          };
          var res = formatItem$1(tree, config, meta, null);
          if (returnErrors) {
            return [res, meta.errors];
          } else {
            if (meta.errors.length) console.warn("Errors while exporting to SpEL:", meta.errors);
            return res;
          }
        };
        var formatItem$1 = function formatItem(item, config, meta) {
          var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          if (!item) return undefined;
          var type = item.get("type");
          if (type === "group" || type === "rule_group") {
            return formatGroup$1(item, config, meta, parentField);
          } else if (type === "rule") {
            return formatRule$1(item, config, meta, parentField);
          } else if (type == "switch_group") {
            return formatSwitch(item, config, meta);
          } else if (type == "case_group") {
            return formatCase(item, config, meta, parentField);
          }
          return undefined;
        };
        var formatCase = function formatCase(item, config, meta) {
          var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var type = item.get("type");
          if (type != "case_group") {
            meta.errors.push("Unexpected child of type ".concat(type, " inside switch"));
            return undefined;
          }
          var properties = item.get("properties") || new immutableExports.Map();
          var _formatItemValue = formatItemValue$1(config, properties, meta, null, parentField, "!case_value"),
            _formatItemValue2 = _slicedToArray$1(_formatItemValue, 3),
            formattedValue = _formatItemValue2[0];
          _formatItemValue2[1];
          _formatItemValue2[2];
          var cond = formatGroup$1(item, config, meta, parentField);
          return [cond, formattedValue];
        };
        var formatSwitch = function formatSwitch(item, config, meta) {
          item.get("properties") || new immutableExports.Map();
          var children = item.get("children1");
          if (!children) return undefined;
          var cases = children.map(function (currentChild) {
            return formatCase(currentChild, config, meta, null);
          }).filter(function (currentChild) {
            return typeof currentChild !== "undefined";
          }).toArray();
          if (!cases.length) return undefined;
          if (cases.length == 1 && !cases[0][0]) {
            // only 1 case without condition
            return cases[0][1];
          }
          var filteredCases = [];
          for (var i = 0; i < cases.length; i++) {
            if (i != cases.length - 1 && !cases[i][0]) {
              meta.errors.push("No condition for case ".concat(i));
            } else {
              filteredCases.push(cases[i]);
              if (i == cases.length - 1 && cases[i][0]) {
                // no default - add null as default
                filteredCases.push([undefined, null]);
              }
            }
          }
          var left = "",
            right = "";
          for (var _i = 0; _i < filteredCases.length; _i++) {
            var _filteredCases$_i = _slicedToArray$1(filteredCases[_i], 2),
              cond = _filteredCases$_i[0],
              value = _filteredCases$_i[1];
            if (value == undefined) value = "null";
            if (cond == undefined) cond = "true";
            if (_i != filteredCases.length - 1) {
              left += "(".concat(cond, " ? ").concat(value, " : ");
              right += ")";
            } else {
              left += "".concat(value);
            }
          }
          return left + right;
        };
        var formatGroup$1 = function formatGroup(item, config, meta) {
          var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var type = item.get("type");
          var properties = item.get("properties") || new immutableExports.Map();
          var mode = properties.get("mode");
          var children = item.get("children1") || new immutableExports.List();
          var field = properties.get("field");
          var conjunction = properties.get("conjunction");
          if (!conjunction) conjunction = defaultConjunction(config);
          var conjunctionDefinition = config.conjunctions[conjunction];
          var not = properties.get("not");
          var isRuleGroup = type === "rule_group";
          var isRuleGroupArray = isRuleGroup && mode != "struct";
          var groupField = isRuleGroupArray ? field : parentField;
          var groupFieldDef = getFieldConfig$8(config, groupField) || {};
          var isSpelArray = groupFieldDef.isSpelArray;

          // check op for reverse
          var groupOperator = properties.get("operator");
          if (!groupOperator && (!mode || mode == "some")) {
            groupOperator = "some";
          }
          var realGroupOperator = checkOp(config, groupOperator, field);
          var isGroupOpRev = realGroupOperator != groupOperator;
          var realGroupOperatorDefinition = groupOperator && getOperatorConfig$4(config, realGroupOperator, field) || null;
          var isGroup0 = isRuleGroup && (!realGroupOperator || realGroupOperatorDefinition.cardinality == 0);

          // build value for aggregation op
          var _formatItemValue3 = formatItemValue$1(config, properties, meta, realGroupOperator, parentField, null),
            _formatItemValue4 = _slicedToArray$1(_formatItemValue3, 3),
            formattedValue = _formatItemValue4[0],
            valueSrc = _formatItemValue4[1],
            valueType = _formatItemValue4[2];

          // build filter in aggregation
          var list = children.map(function (currentChild) {
            return formatItem$1(currentChild, config, meta, groupField);
          }).filter(function (currentChild) {
            return typeof currentChild !== "undefined";
          });
          if (isRuleGroupArray && !isGroup0) {
            // "count" rule can have no "having" children, but should have number value
            if (formattedValue == undefined) return undefined;
          } else {
            if (!list.size) return undefined;
          }
          var omitBrackets = isRuleGroup;
          var filter = list.size ? conjunctionDefinition.spelFormatConj(list, conjunction, not, omitBrackets) : null;

          // build result
          var ret;
          if (isRuleGroupArray) {
            var formattedField = formatField$1(meta, config, field, parentField);
            var getSize = isSpelArray ? ".length" : ".size()";
            var fullSize = "".concat(formattedField).concat(getSize);
            // https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html#expressions-collection-selection
            var filteredSize = filter ? "".concat(formattedField, ".?[").concat(filter, "]").concat(getSize) : fullSize;
            var groupValue = isGroup0 ? fullSize : formattedValue;
            // format expression
            ret = formatExpression(meta, config, properties, filteredSize, groupValue, realGroupOperator, valueSrc, valueType, isGroupOpRev);
          } else {
            ret = filter;
          }
          return ret;
        };
        var buildFnToFormatOp$1 = function buildFnToFormatOp(operator, operatorDefinition) {
          var spelOp = operatorDefinition.spelOp;
          if (!spelOp) return undefined;
          var objectIsFirstArg = spelOp[0] == "$";
          var isMethod = spelOp[0] == "." || objectIsFirstArg;
          var isFunction = spelOp.substring(spelOp.length - 2) == "()";
          var sop = isMethod ? spelOp.slice(1) : isFunction ? spelOp.substring(0, spelOp.length - 2) : spelOp;
          var fn;
          var cardinality = defaultValue$1(operatorDefinition.cardinality, 1);
          if (cardinality == 0) {
            fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
              if (isMethod) return "".concat(field, ".").concat(sop, "()");else return "".concat(field, " ").concat(sop);
            };
          } else if (cardinality == 1) {
            fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
              if (objectIsFirstArg) return "".concat(values, ".").concat(sop, "(").concat(field, ")");else if (isFunction) return "".concat(sop, "(").concat(field, ", ").concat(values, ")");else if (isMethod) return "".concat(field, ".").concat(sop, "(").concat(values, ")");else return "".concat(field, " ").concat(sop, " ").concat(values);
            };
          }
          return fn;
        };
        var formatExpression = function formatExpression(meta, config, properties, formattedField, formattedValue, operator, valueSrc, valueType) {
          var isRev = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
          var field = properties.get("field");
          var opDef = getOperatorConfig$4(config, operator, field) || {};
          var fieldDef = getFieldConfig$8(config, field) || {};
          var operatorOptions = properties.get("operatorOptions");

          //find fn to format expr
          var fn = opDef.spelFormatOp || buildFnToFormatOp$1(operator, opDef);
          if (!fn) {
            meta.errors.push("Operator ".concat(operator, " is not supported"));
            return undefined;
          }

          //format expr
          var args = [formattedField, operator, formattedValue, valueSrc, valueType, omit$1(opDef, ["formatOp", "mongoFormatOp", "sqlFormatOp", "jsonLogic", "spelFormatOp"]), operatorOptions, fieldDef];
          var ret;
          ret = fn.apply(void 0, args);

          //rev
          if (isRev) {
            ret = config.settings.spelFormatReverse(ret);
          }
          if (ret === undefined) {
            meta.errors.push("Operator ".concat(operator, " is not supported for value source ").concat(valueSrc));
          }
          return ret;
        };
        var checkOp = function checkOp(config, operator, field) {
          if (!operator) return undefined;
          var opDef = getOperatorConfig$4(config, operator, field) || {};
          var reversedOp = opDef.reversedOp;
          var revOpDef = getOperatorConfig$4(config, reversedOp, field) || {};
          var canFormatOp = opDef.spelOp || opDef.spelFormatOp;
          var canFormatRevOp = revOpDef.spelOp || revOpDef.spelFormatOp;
          if (!canFormatOp && !canFormatRevOp) {
            return undefined;
          }
          if (!canFormatOp && canFormatRevOp) {
            var _ref = [reversedOp, operator];
            operator = _ref[0];
            reversedOp = _ref[1];
            var _ref2 = [revOpDef, opDef];
            opDef = _ref2[0];
            revOpDef = _ref2[1];
          }
          return operator;
        };
        var formatRule$1 = function formatRule(item, config, meta) {
          var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var properties = item.get("properties") || new immutableExports.Map();
          var field = properties.get("field");
          var operator = properties.get("operator");
          if (field == null || operator == null) return undefined;

          // check op for reverse
          var realOp = checkOp(config, operator, field);
          if (!realOp) {
            meta.errors.push("Operator ".concat(operator, " is not supported"));
            return undefined;
          }
          var isRev = realOp != operator;

          //format value
          var _formatItemValue5 = formatItemValue$1(config, properties, meta, realOp, parentField, null),
            _formatItemValue6 = _slicedToArray$1(_formatItemValue5, 3),
            formattedValue = _formatItemValue6[0],
            valueSrc = _formatItemValue6[1],
            valueType = _formatItemValue6[2];
          if (formattedValue === undefined) return undefined;

          //format field
          var formattedField = formatField$1(meta, config, field, parentField);

          // format expression
          var res = formatExpression(meta, config, properties, formattedField, formattedValue, realOp, valueSrc, valueType, isRev);
          return res;
        };
        var formatItemValue$1 = function formatItemValue(config, properties, meta, operator, parentField) {
          var expectedValueType = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
          var field = properties.get("field");
          var iValueSrc = properties.get("valueSrc");
          var iValueType = properties.get("valueType");
          if (expectedValueType == "!case_value" || iValueType && iValueType.get(0) == "case_value") {
            field = "!case_value";
          }
          var fieldDef = getFieldConfig$8(config, field) || {};
          var operatorDefinition = getOperatorConfig$4(config, operator, field) || {};
          var cardinality = defaultValue$1(operatorDefinition.cardinality, 1);
          var iValue = properties.get("value");
          var asyncListValues = properties.get("asyncListValues");
          var valueSrcs = [];
          var valueTypes = [];
          var formattedValue;
          if (iValue != undefined) {
            var fvalue = iValue.map(function (currentValue, ind) {
              var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;
              var valueType = iValueType ? iValueType.get(ind) : null;
              var cValue = completeValue(currentValue, valueSrc, config);
              var widget = getWidgetForFieldOp$3(config, field, operator, valueSrc);
              var fieldWidgetDef = omit$1(getFieldWidgetConfig$3(config, field, operator, widget, valueSrc), ["factory"]);
              var fv = formatValue$1(meta, config, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDefinition, parentField, asyncListValues);
              if (fv !== undefined) {
                valueSrcs.push(valueSrc);
                valueTypes.push(valueType);
              }
              return fv;
            });
            var hasUndefinedValues = fvalue.filter(function (v) {
              return v === undefined;
            }).size > 0;
            if (!(fvalue.size < cardinality || hasUndefinedValues)) {
              formattedValue = cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;
            }
          }
          return [formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0]];
        };
        var formatValue$1 = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef) {
          var parentField = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;
          var asyncListValues = arguments.length > 10 ? arguments[10] : undefined;
          if (currentValue === undefined) return undefined;
          var ret;
          if (valueSrc == "field") {
            ret = formatField$1(meta, config, currentValue, parentField);
          } else if (valueSrc == "func") {
            ret = formatFunc$1(meta, config, currentValue, parentField);
          } else {
            if (typeof fieldWidgetDef.spelFormatValue === "function") {
              var fn = fieldWidgetDef.spelFormatValue;
              var args = [currentValue, _objectSpread$p(_objectSpread$p({}, pick$1(fieldDef, ["fieldSettings", "listValues"])), {}, {
                asyncListValues: asyncListValues
              }),
              //useful options: valueFormat for date/time
              omit$1(fieldWidgetDef, ["formatValue", "mongoFormatValue", "sqlFormatValue", "jsonLogic", "elasticSearchFormatValue", "spelFormatValue"])];
              if (operator) {
                args.push(operator);
                args.push(operatorDef);
              }
              if (valueSrc == "field") {
                var valFieldDefinition = getFieldConfig$8(config, currentValue) || {};
                args.push(valFieldDefinition);
              }
              ret = fn.apply(void 0, args);
            } else {
              ret = spelEscape(currentValue);
            }
          }
          return ret;
        };
        var formatField$1 = function formatField(meta, config, field) {
          var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          if (!field) return;
          var fieldSeparator = config.settings.fieldSeparator;
          var fieldDefinition = getFieldConfig$8(config, field) || {};
          var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);
          getFieldPath$3(field, config, parentField);
          var fieldPartsConfigs = getFieldPartsConfigs(field, config, parentField);
          var formatFieldFn = config.settings.formatSpelField;
          var fieldName = formatFieldName$1(field, config, meta);
          if (parentField) {
            var parentFieldDef = getFieldConfig$8(config, parentField) || {};
            var parentFieldName = parentField;
            if (parentFieldDef.fieldName) {
              parentFieldName = parentFieldDef.fieldName;
            }
            if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {
              fieldName = fieldName.slice((parentFieldName + fieldSeparator).length);
              // fieldName = "#this." + fieldName;
            } else {
              meta.errors.push("Can't cut group ".concat(parentFieldName, " from field ").concat(fieldName));
            }
          }
          var fieldPartsMeta = fieldPartsConfigs.map(function (_ref3) {
            var _ref4 = _slicedToArray$1(_ref3, 3),
              key = _ref4[0],
              cnf = _ref4[1],
              parentCnf = _ref4[2];
            var parent;
            if (parentCnf) {
              if (parentCnf.type == "!struct" || parentCnf.type == "!group" && parentCnf.mode == "struct") parent = cnf.isSpelMap ? "map" : "class";else if (parentCnf.type == "!group") parent = cnf.isSpelItemMap ? "[map]" : "[class]";else parent = "class";
            }
            var isSpelVariable = cnf === null || cnf === void 0 ? void 0 : cnf.isSpelVariable;
            return {
              key: key,
              parent: parent,
              isSpelVariable: isSpelVariable
            };
          });
          var formattedField = formatFieldFn(fieldName, parentField, fieldParts, fieldPartsMeta, fieldDefinition, config);
          return formattedField;
        };
        var formatFunc$1 = function formatFunc(meta, config, currentValue) {
          var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var funcKey = currentValue.get("func");
          var args = currentValue.get("args");
          var funcConfig = getFuncConfig$2(config, funcKey);
          var funcName = funcConfig.spelFunc || funcKey;
          var formattedArgs = {};
          for (var argKey in funcConfig.args) {
            var argConfig = funcConfig.args[argKey];
            var fieldDef = getFieldConfig$8(config, argConfig);
            var argVal = args ? args.get(argKey) : undefined;
            var argValue = argVal ? argVal.get("value") : undefined;
            var argValueSrc = argVal ? argVal.get("valueSrc") : undefined;
            var argAsyncListValues = argVal ? argVal.get("asyncListValues") : undefined;
            var formattedArgVal = formatValue$1(meta, config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, parentField, argAsyncListValues);
            if (argValue != undefined && formattedArgVal === undefined) {
              meta.errors.push("Can't format value of arg ".concat(argKey, " for func ").concat(funcKey));
              return undefined;
            }
            if (formattedArgVal !== undefined) {
              // skip optional in the end
              formattedArgs[argKey] = formattedArgVal;
            }
          }
          var ret;
          if (typeof funcConfig.spelFormatFunc === "function") {
            var fn = funcConfig.spelFormatFunc;
            var _args = [formattedArgs];
            ret = fn.apply(void 0, _args);
          } else {
            var _args2 = Object.entries(formattedArgs).map(function (_ref5) {
              var _ref6 = _slicedToArray$1(_ref5, 2);
              _ref6[0];
              var v = _ref6[1];
              return v;
            });
            if (funcName[0] == "." && _args2.length) {
              var _args3 = _toArray(_args2),
                obj = _args3[0],
                params = _args3.slice(1);
              ret = "".concat(obj).concat(funcName, "(").concat(params.join(", "), ")");
            } else {
              ret = "".concat(funcName, "(").concat(_args2.join(", "), ")");
            }
          }
          return ret;
        };
        function ownKeys$o(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$o(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$o(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$o(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        var queryString = function queryString(item, config) {
          var isForDisplay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          //meta is mutable
          var meta = {
            errors: []
          };
          var res = formatItem(item, config, meta, isForDisplay, null);
          if (meta.errors.length) console.warn("Errors while exporting to string:", meta.errors);
          return res;
        };
        var formatItem = function formatItem(item, config, meta) {
          var isForDisplay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          if (!item) return undefined;
          var type = item.get("type");
          item.get("children1");
          if (type === "group" || type === "rule_group") {
            return formatGroup(item, config, meta, isForDisplay, parentField);
          } else if (type === "rule") {
            return formatRule(item, config, meta, isForDisplay, parentField);
          }
          return undefined;
        };
        var formatGroup = function formatGroup(item, config, meta) {
          var isForDisplay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          var type = item.get("type");
          var properties = item.get("properties") || new immutableExports.Map();
          var mode = properties.get("mode");
          var children = item.get("children1") || new immutableExports.List();
          var isRuleGroup = type === "rule_group";
          // TIP: don't cut group for mode == 'struct' and don't do aggr format (maybe later)
          var groupField = isRuleGroup && mode == "array" ? properties.get("field") : null;
          var canHaveEmptyChildren = isRuleGroup && mode == "array";
          var not = properties.get("not");
          var list = children.map(function (currentChild) {
            return formatItem(currentChild, config, meta, isForDisplay, groupField);
          }).filter(function (currentChild) {
            return typeof currentChild !== "undefined";
          });
          if (!canHaveEmptyChildren && !list.size) return undefined;
          var conjunction = properties.get("conjunction");
          if (!conjunction) conjunction = defaultConjunction(config);
          var conjunctionDefinition = config.conjunctions[conjunction];
          var conjStr = list.size ? conjunctionDefinition.formatConj(list, conjunction, not, isForDisplay) : null;
          var ret;
          if (groupField) {
            var aggrArgs = formatRule(item, config, meta, isForDisplay, parentField, true);
            if (aggrArgs) {
              var _config$settings;
              var isRev = aggrArgs.pop();
              var args = [conjStr].concat(_toConsumableArray(aggrArgs));
              ret = (_config$settings = config.settings).formatAggr.apply(_config$settings, _toConsumableArray(args));
              if (isRev) {
                ret = config.settings.formatReverse(ret, null, null, null, null, isForDisplay);
              }
            }
          } else {
            ret = conjStr;
          }
          return ret;
        };
        var formatItemValue = function formatItemValue(config, properties, meta, _operator, isForDisplay, parentField) {
          var field = properties.get("field");
          var iValueSrc = properties.get("valueSrc");
          var iValueType = properties.get("valueType");
          var fieldDef = getFieldConfig$8(config, field) || {};
          var operator = _operator || properties.get("operator");
          var operatorDef = getOperatorConfig$4(config, operator, field) || {};
          var cardinality = defaultValue$1(operatorDef.cardinality, 1);
          var iValue = properties.get("value");
          var asyncListValues = properties.get("asyncListValues");
          var valueSrcs = [];
          var valueTypes = [];
          var formattedValue;
          if (iValue != undefined) {
            var fvalue = iValue.map(function (currentValue, ind) {
              var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;
              var valueType = iValueType ? iValueType.get(ind) : null;
              var cValue = completeValue(currentValue, valueSrc, config);
              var widget = getWidgetForFieldOp$3(config, field, operator, valueSrc);
              var fieldWidgetDef = omit$1(getFieldWidgetConfig$3(config, field, operator, widget, valueSrc), ["factory"]);
              var fv = formatValue(config, meta, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef, isForDisplay, parentField, asyncListValues);
              if (fv !== undefined) {
                valueSrcs.push(valueSrc);
                valueTypes.push(valueType);
              }
              return fv;
            });
            var hasUndefinedValues = fvalue.filter(function (v) {
              return v === undefined;
            }).size > 0;
            if (!(hasUndefinedValues || fvalue.size < cardinality)) {
              formattedValue = cardinality == 1 ? fvalue.first() : fvalue;
            }
          }
          return [formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0]];
        };
        var buildFnToFormatOp = function buildFnToFormatOp(operator, operatorDefinition) {
          var fop = operatorDefinition.labelForFormat || operator;
          var cardinality = defaultValue$1(operatorDefinition.cardinality, 1);
          var fn;
          if (cardinality == 0) {
            fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              return "".concat(field, " ").concat(fop);
            };
          } else if (cardinality == 1) {
            fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              return "".concat(field, " ").concat(fop, " ").concat(values);
            };
          } else if (cardinality == 2) {
            // between
            fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              var valFrom = values.first();
              var valTo = values.get(1);
              return "".concat(field, " ").concat(fop, " ").concat(valFrom, " AND ").concat(valTo);
            };
          }
          return fn;
        };
        var formatRule = function formatRule(item, config, meta) {
          var isForDisplay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          var returnArgs = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
          var properties = item.get("properties") || new immutableExports.Map();
          var field = properties.get("field");
          var operator = properties.get("operator");
          var operatorOptions = properties.get("operatorOptions");
          if (field == null || operator == null) return undefined;
          var fieldDef = getFieldConfig$8(config, field) || {};
          var operatorDef = getOperatorConfig$4(config, operator, field) || {};
          var reversedOp = operatorDef.reversedOp;
          var revOperatorDef = getOperatorConfig$4(config, reversedOp, field) || {};

          //check op
          var isRev = false;
          var fn = operatorDef.formatOp;
          if (!fn && reversedOp) {
            fn = revOperatorDef.formatOp;
            if (fn) {
              isRev = true;
              var _ref = [reversedOp, operator];
              operator = _ref[0];
              reversedOp = _ref[1];
              var _ref2 = [revOperatorDef, operatorDef];
              operatorDef = _ref2[0];
              revOperatorDef = _ref2[1];
            }
          }

          //find fn to format expr
          if (!fn) fn = buildFnToFormatOp(operator, operatorDef);
          if (!fn) return undefined;

          //format field
          var formattedField = formatField(config, meta, field, isForDisplay, parentField);

          //format value
          var _formatItemValue = formatItemValue(config, properties, meta, operator, isForDisplay, parentField),
            _formatItemValue2 = _slicedToArray$1(_formatItemValue, 3),
            formattedValue = _formatItemValue2[0],
            valueSrc = _formatItemValue2[1],
            valueType = _formatItemValue2[2];
          if (formattedValue === undefined) return undefined;
          var args = [formattedField, operator, formattedValue, valueSrc, valueType, omit$1(operatorDef, ["formatOp", "mongoFormatOp", "sqlFormatOp", "jsonLogic", "spelFormatOp"]), operatorOptions, isForDisplay, fieldDef, isRev];
          if (returnArgs) {
            return args;
          } else {
            //format expr
            var ret = fn.apply(void 0, args);

            //rev
            if (isRev) {
              ret = config.settings.formatReverse(ret, operator, reversedOp, operatorDef, revOperatorDef, isForDisplay);
            }
            return ret;
          }
        };
        var formatValue = function formatValue(config, meta, value, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, opDef, isForDisplay) {
          var parentField = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : null;
          var asyncListValues = arguments.length > 11 ? arguments[11] : undefined;
          if (value === undefined) return undefined;
          var ret;
          if (valueSrc == "field") {
            ret = formatField(config, meta, value, isForDisplay, parentField);
          } else if (valueSrc == "func") {
            ret = formatFunc(config, meta, value, isForDisplay, parentField);
          } else {
            if (typeof fieldWidgetDef.formatValue === "function") {
              var fn = fieldWidgetDef.formatValue;
              var args = [value, _objectSpread$o(_objectSpread$o({}, pick$1(fieldDef, ["fieldSettings", "listValues"])), {}, {
                asyncListValues: asyncListValues
              }),
              //useful options: valueFormat for date/time
              omit$1(fieldWidgetDef, ["formatValue", "mongoFormatValue", "sqlFormatValue", "jsonLogic", "elasticSearchFormatValue", "spelFormatValue"]), isForDisplay];
              if (operator) {
                args.push(operator);
                args.push(opDef);
              }
              if (valueSrc == "field") {
                var valFieldDefinition = getFieldConfig$8(config, value) || {};
                args.push(valFieldDefinition);
              }
              ret = fn.apply(void 0, args);
            } else {
              ret = value;
            }
          }
          return ret;
        };
        var formatField = function formatField(config, meta, field, isForDisplay) {
          var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          var cutParentField = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
          var _config$settings2 = config.settings,
            fieldSeparator = _config$settings2.fieldSeparator,
            fieldSeparatorDisplay = _config$settings2.fieldSeparatorDisplay;
          var ret = null;
          if (field) {
            var fieldDefinition = getFieldConfig$8(config, field) || {};
            var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);
            getFieldPath$3(field, config);
            var fieldPartsLabels = getFieldPathLabels$3(field, config, cutParentField ? parentField : null);
            var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparatorDisplay) : null;
            var fieldLabel2 = fieldDefinition.label2 || fieldFullLabel;
            var formatFieldFn = config.settings.formatField;
            var fieldName = formatFieldName$1(field, config, meta, cutParentField ? parentField : null);
            ret = formatFieldFn(fieldName, fieldParts, fieldLabel2, fieldDefinition, config, isForDisplay);
          }
          return ret;
        };
        var formatFunc = function formatFunc(config, meta, funcValue, isForDisplay) {
          var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          var funcKey = funcValue.get("func");
          var args = funcValue.get("args");
          var funcConfig = getFuncConfig$2(config, funcKey);
          var funcName = isForDisplay && funcConfig.label || funcKey;
          var formattedArgs = {};
          var formattedArgsWithNames = {};
          for (var argKey in funcConfig.args) {
            var argConfig = funcConfig.args[argKey];
            var fieldDef = getFieldConfig$8(config, argConfig);
            var argVal = args ? args.get(argKey) : undefined;
            var argValue = argVal ? argVal.get("value") : undefined;
            var argValueSrc = argVal ? argVal.get("valueSrc") : undefined;
            var argAsyncListValues = argVal ? argVal.get("asyncListValues") : undefined;
            var formattedArgVal = formatValue(config, meta, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, isForDisplay, parentField, argAsyncListValues);
            var argName = isForDisplay && argConfig.label || argKey;
            if (formattedArgVal !== undefined) {
              // skip optional in the end
              formattedArgs[argKey] = formattedArgVal;
              formattedArgsWithNames[argName] = formattedArgVal;
            }
          }
          var ret = null;
          if (typeof funcConfig.formatFunc === "function") {
            var fn = funcConfig.formatFunc;
            var _args = [formattedArgs, isForDisplay];
            ret = fn.apply(void 0, _args);
          } else {
            var argsStr = Object.entries(formattedArgsWithNames).map(function (_ref3) {
              var _ref4 = _slicedToArray$1(_ref3, 2),
                k = _ref4[0],
                v = _ref4[1];
              return isForDisplay ? "".concat(k, ": ").concat(v) : "".concat(v);
            }).join(", ");
            ret = "".concat(funcName, "(").concat(argsStr, ")");
          }
          return ret;
        };
        function ownKeys$n(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$n(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$n(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$n(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }

        /**
         * Converts a string representation of top_left and bottom_right cords to
         * a ES geo_point required for query
         *
         * @param {string} geoPointString - comma separated string of lat/lon coods
         * @returns {{top_left: {lon: number, lat: number}, bottom_right: {lon: number, lat: number}}} - ES geoPoint formatted object
         * @private
         */
        function buildEsGeoPoint(geoPointString) {
          if (geoPointString == null) {
            return null;
          }
          var coordsNumberArray = geoPointString.split(",").map(Number);
          return {
            top_left: {
              lat: coordsNumberArray[0],
              lon: coordsNumberArray[1]
            },
            bottom_right: {
              lat: coordsNumberArray[2],
              lon: coordsNumberArray[3]
            }
          };
        }

        /**
         * Converts a dateTime string from the query builder to a ES range formatted object
         *
         * @param {string} dateTime - dateTime formatted string
         * @param {string} operator - query builder operator type, see constants.js and query builder docs
         * @returns {{lt: string}|{lte: string}|{gte: string}|{gte: string, lte: string}|undefined} - ES range query parameter
         *
         * @private
         */
        function buildEsRangeParameters(value, operator) {
          // -- if value is greater than 1 then we assume this is a between operator : BUG this is wrong, a selectable list can have multiple values
          if (value.length > 1) {
            return {
              gte: "".concat(value[0]),
              lte: "".concat(value[1])
            };
          } // -- if value is only one we assume this is a date time query for a specific day

          var dateTime = value[0]; //TODO: Rethink about this part, what if someone adds a new type of opperator

          //todo: move this logic into config
          switch (operator) {
            case "on_date": //todo: not used
            case "not_on_date":
            case "equal":
            case "select_equals":
            case "not_equal":
              return {
                gte: "".concat(dateTime, "||/d"),
                lte: "".concat(dateTime, "||+1d")
              };
            case "less_or_equal":
              return {
                lte: "".concat(dateTime)
              };
            case "greater_or_equal":
              return {
                gte: "".concat(dateTime)
              };
            case "less":
              return {
                lt: "".concat(dateTime)
              };
            case "greater":
              return {
                gt: "".concat(dateTime)
              };
            default:
              return undefined;
          }
        }

        /**
         * Builds the DSL parameters for a Wildcard query
         *
         * @param {string} value - The match value
         * @returns {{value: string}} - The value = value parameter surrounded with * on each end
         * @private
         */
        function buildEsWildcardParameters(value) {
          return {
            value: "*" + value + "*"
          };
        }

        /**
         * Takes the match type string from awesome query builder like 'greater_or_equal' and
         * returns the ES occurrence required for bool queries
         *
         * @param {string} combinator - query group type or rule condition
         * @param {bool} not
         * @returns {string} - ES occurrence type. See constants.js
         * @private
         */
        function determineOccurrence(combinator, not) {
          //todo: move into config, like mongoConj
          switch (combinator) {
            case "AND":
              return not ? "must_not" : "must";
            // -- AND

            case "OR":
              return not ? "should_not" : "should";
            // -- OR

            case "NOT":
              return not ? "must" : "must_not";
            // -- NOT AND

            default:
              return undefined;
          }
        }
        function buildRegexpParameters(value) {
          return {
            value: value
          };
        }
        function determineField(fieldName, config) {
          //todo: ElasticSearchTextField - not used
          //return config.fields[fieldName].ElasticSearchTextField || fieldName;
          return fieldName;
        }
        function buildParameters(queryType, value, operator, fieldName, config, syntax) {
          var textField = determineField(fieldName);
          switch (queryType) {
            case "filter":
              //todo: elasticSearchScript - not used
              return {
                script: config.operators[operator].elasticSearchScript(fieldName, value)
              };
            case "exists":
              return {
                field: fieldName
              };
            case "match":
              return _defineProperty$4({}, textField, value[0]);
            case "term":
              return syntax === ES_7_SYNTAX ? _defineProperty$4({}, fieldName, {
                value: value[0]
              }) : _defineProperty$4({}, fieldName, value[0]);

            //todo: not used
            // need to add geo type into RAQB or remove this code
            case "geo_bounding_box":
              return _defineProperty$4({}, fieldName, buildEsGeoPoint(value[0]));
            case "range":
              return _defineProperty$4({}, fieldName, buildEsRangeParameters(value, operator));
            case "wildcard":
              return _defineProperty$4({}, fieldName, buildEsWildcardParameters(value[0]));
            case "regexp":
              return _defineProperty$4({}, fieldName, buildRegexpParameters(value[0]));
            default:
              return undefined;
          }
        }
        /**
         * Handles the building of the group portion of the DSL
         *
         * @param {string} fieldName - The name of the field you are building a rule for
         * @param {string} fieldDataType - The type of data this field holds
         * @param {string} value - The value of this rule
         * @param {string} operator - The condition on how the value is matched
         * @param {string} syntax - The version of ElasticSearch syntax to generate
         * @returns {object} - The ES rule
         * @private
         */
        function buildEsRule(fieldName, value, operator, config, valueSrc, syntax) {
          if (!fieldName || !operator || value == undefined) return undefined; // rule is not fully entered
          var op = operator;
          var opConfig = config.operators[op];
          if (!opConfig) return undefined; // unknown operator
          var _opConfig = opConfig,
            elasticSearchQueryType = _opConfig.elasticSearchQueryType;

          // not
          var not = false;
          if (!elasticSearchQueryType && opConfig.reversedOp) {
            not = true;
            op = opConfig.reversedOp;
            opConfig = config.operators[op];
            var _opConfig2 = opConfig;
            elasticSearchQueryType = _opConfig2.elasticSearchQueryType;
          }

          // handle if value 0 has multiple values like a select in a array
          var widget = getWidgetForFieldOp$3(config, fieldName, op, valueSrc);
          var widgetConfig = config.widgets[widget];
          if (!widgetConfig) return undefined; // unknown widget
          var elasticSearchFormatValue = widgetConfig.elasticSearchFormatValue;

          /** In most cases the queryType will be static however in some casese (like between) the query type will change
           * based on the data type. i.e. a between time will be different than between number, date, letters etc... */
          var queryType;
          if (typeof elasticSearchQueryType === "function") {
            queryType = elasticSearchQueryType(widget);
          } else {
            queryType = elasticSearchQueryType;
          }
          if (!queryType) {
            // Not supported
            return undefined;
          }

          /** If a widget has a rule on how to format that data then use that otherwise use default way of determineing search parameters
           * */
          var parameters;
          if (typeof elasticSearchFormatValue === "function") {
            parameters = elasticSearchFormatValue(queryType, value, op, fieldName, config);
          } else {
            parameters = buildParameters(queryType, value, op, fieldName, config, syntax);
          }
          if (not) {
            return {
              bool: {
                must_not: _defineProperty$4({}, queryType, _objectSpread$n({}, parameters))
              }
            };
          } else {
            return _defineProperty$4({}, queryType, _objectSpread$n({}, parameters));
          }
        }

        /**
         * Handles the building of the group portion of the DSL
         *
         * @param {object} children - The contents of the group
         * @param {string} conjunction - The way the contents of the group are joined together i.e. AND OR
         * @param {bool} not
         * @param {Function} recursiveFxn - The recursive fxn to build the contents of the groups children
         * @private
         * @returns {object} - The ES group
         */
        function buildEsGroup(children, conjunction, not, recursiveFxn, config, syntax) {
          if (!children || !children.size) return undefined;
          var childrenArray = children.valueSeq().toArray();
          var occurrence = determineOccurrence(conjunction, not);
          var result = childrenArray.map(function (c) {
            return recursiveFxn(c, config, syntax);
          }).filter(function (v) {
            return v !== undefined;
          });
          if (!result.length) return undefined;
          var resultFlat = result.flat(Infinity);
          return {
            bool: _defineProperty$4({}, occurrence, resultFlat)
          };
        }
        var ES_7_SYNTAX = "ES_7_SYNTAX";
        var ES_6_SYNTAX = "ES_6_SYNTAX";
        function elasticSearchFormat(tree, config) {
          var syntax = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ES_6_SYNTAX;
          // -- format the es dsl here
          if (!tree) return undefined;
          var type = tree.get("type");
          var properties = tree.get("properties") || new Map();
          if (type === "rule" && properties.get("field")) {
            var _properties$get, _properties$get2;
            // -- field is null when a new blank rule is added
            var operator = properties.get("operator");
            var field = properties.get("field");
            var value = properties.get("value").toJS();
            (_properties$get = properties.get("valueType")) === null || _properties$get === void 0 ? void 0 : _properties$get.get(0);
            var valueSrc = (_properties$get2 = properties.get("valueSrc")) === null || _properties$get2 === void 0 ? void 0 : _properties$get2.get(0);
            if (valueSrc === "func") {
              // -- elastic search doesn't support functions (that is post processing)
              return;
            }
            if (value && Array.isArray(value[0])) {
              //TODO : Handle case where the value has multiple values such as in the case of a list
              return value[0].map(function (val) {
                return buildEsRule(field, [val], operator, config, valueSrc, syntax);
              });
            } else {
              return buildEsRule(field, value, operator, config, valueSrc, syntax);
            }
          }
          if (type === "group" || type === "rule_group") {
            var not = properties.get("not");
            var conjunction = properties.get("conjunction");
            if (!conjunction) conjunction = defaultConjunction(config);
            var children = tree.get("children1");
            return buildEsGroup(children, conjunction, not, elasticSearchFormat, config, syntax);
          }
        }
        const Export = /*#__PURE__*/Object.freeze( /*#__PURE__*/Object.defineProperty({
          __proto__: null,
          ES_6_SYNTAX,
          ES_7_SYNTAX,
          _mongodbFormat,
          _spelFormat,
          _sqlFormat,
          elasticSearchFormat,
          jsonLogicFormat,
          mongodbFormat,
          queryBuilderFormat,
          queryString,
          spelFormat,
          sqlFormat
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        var getTree = function getTree(immutableTree) {
          var light = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          var children1AsArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          if (!immutableTree) return undefined;
          var tree = immutableTree;
          tree = tree.toJS();
          if (light) tree = getLightTree(tree, children1AsArray);
          return tree;
        };
        var loadTree = function loadTree(serTree) {
          if (isImmutableTree(serTree)) {
            return serTree;
          } else if (isTree(serTree)) {
            return jsTreeToImmutable(serTree);
          } else if (typeof serTree == "string" && serTree.startsWith('["~#iM"')) {
            //tip: old versions of RAQB were saving tree with `transit.toJSON()`
            // https://github.com/ukrbublik/react-awesome-query-builder/issues/69
            throw "You are trying to load query in obsolete serialization format (Immutable string) which is not supported in versions starting from 2.1.17";
          } else if (typeof serTree == "string") {
            return jsTreeToImmutable(JSON.parse(serTree));
          } else throw "Can't load tree!";
        };
        var checkTree = function checkTree(tree, config) {
          if (!tree) return undefined;
          var extendedConfig = extendConfig$1(config);
          return validateTree(tree, null, extendedConfig, extendedConfig);
        };
        var isValidTree = function isValidTree(tree) {
          return getTreeBadFields(tree).length == 0;
        };
        var isImmutableTree = function isImmutableTree(tree) {
          return immutableExports.Map.isMap(tree);
        };
        var isTree = function isTree(tree) {
          return _typeof$2(tree) == "object" && (tree.type == "group" || tree.type == "switch_group");
        };
        function jsTreeToImmutable(tree) {
          return immutableExports.fromJS(tree, function (key, value) {
            var outValue;
            if (key == "properties") {
              outValue = value.toOrderedMap();

              // `value` should be undefined instead of null
              // JSON doesn't support undefined and replaces undefined -> null
              // So fix: null -> undefined
              for (var i = 0; i < 2; i++) {
                var _outValue$get;
                if (((_outValue$get = outValue.get("value")) === null || _outValue$get === void 0 ? void 0 : _outValue$get.get(i)) === null) {
                  outValue = outValue.setIn(["value", i], undefined);
                }
              }
            } else if (key == "value" && value.get(0) && value.get(0).toJS !== undefined) {
              var valueJs = value.get(0).toJS();
              if (valueJs.func) {
                outValue = value.toOrderedMap();
              } else {
                // only for raw values keep JS representation
                outValue = Immutable.List.of(valueJs);
              }
            } else if (key == "asyncListValues") {
              // keep in JS format
              outValue = value.toJS();
            } else if (key == "children1" && Immutable.Iterable.isIndexed(value)) {
              outValue = new Immutable.OrderedMap(value.map(function (child) {
                return [child.get("id"), child];
              }));
            } else {
              outValue = Immutable.Iterable.isIndexed(value) ? value.toList() : value.toOrderedMap();
            }
            return outValue;
          });
        }
        function ownKeys$m(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$m(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$m(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$m(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }

        // http://jsonlogic.com/

        // helpers
        var arrayUniq = function arrayUniq(arr) {
          return Array.from(new Set(arr));
        };
        var loadFromJsonLogic = function loadFromJsonLogic(logicTree, config) {
          return _loadFromJsonLogic(logicTree, config, false);
        };
        var _loadFromJsonLogic = function _loadFromJsonLogic(logicTree, config) {
          var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          //meta is mutable
          var meta = {
            errors: []
          };
          var extendedConfig = extendConfig$1(config);
          var conv = buildConv$1(extendedConfig);
          var jsTree = logicTree ? convertFromLogic(logicTree, conv, extendedConfig, "rule", meta) : undefined;
          if (jsTree && jsTree.type != "group") {
            jsTree = wrapInDefaultConj$1(jsTree, extendedConfig);
          }
          var immTree = jsTree ? loadTree(jsTree) : undefined;
          if (returnErrors) {
            return [immTree, meta.errors];
          } else {
            if (meta.errors.length) console.warn("Errors while importing from JsonLogic:", meta.errors);
            return immTree;
          }
        };
        var buildConv$1 = function buildConv(config) {
          var operators = {};
          for (var opKey in config.operators) {
            var opConfig = config.operators[opKey];
            if (typeof opConfig.jsonLogic == "string") {
              // example: "</2", "#in/1"
              var opk = (opConfig._jsonLogicIsRevArgs ? "#" : "") + opConfig.jsonLogic + "/" + defaultValue$1(opConfig.cardinality, 1);
              if (!operators[opk]) operators[opk] = [];
              operators[opk].push(opKey);
            } else if (typeof opConfig.jsonLogic2 == "string") {
              // example: all-in/1"
              var _opk = opConfig.jsonLogic2 + "/" + defaultValue$1(opConfig.cardinality, 1);
              if (!operators[_opk]) operators[_opk] = [];
              operators[_opk].push(opKey);
            }
          }
          var conjunctions = {};
          for (var conjKey in config.conjunctions) {
            var conjunctionDefinition = config.conjunctions[conjKey];
            var ck = conjunctionDefinition.jsonLogicConj || conjKey.toLowerCase();
            conjunctions[ck] = conjKey;
          }
          var funcs = {};
          for (var funcKey in config.funcs) {
            var funcConfig = config.funcs[funcKey];
            var fk = void 0;
            if (funcConfig.jsonLogicIsMethod) {
              fk = "#" + funcConfig.jsonLogic;
            } else if (typeof funcConfig.jsonLogic == "string") {
              fk = funcConfig.jsonLogic;
            }
            if (fk) {
              if (!funcs[fk]) funcs[fk] = [];
              funcs[fk].push(funcKey);
            }
          }
          var _config$settings$json = config.settings.jsonLogic,
            groupVarKey = _config$settings$json.groupVarKey,
            altVarKey = _config$settings$json.altVarKey;
          return {
            operators: operators,
            conjunctions: conjunctions,
            funcs: funcs,
            varKeys: ["var", groupVarKey, altVarKey]
          };
        };
        var convertFromLogic = function convertFromLogic(logic, conv, config, expectedType, meta) {
          var not = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
          var fieldConfig = arguments.length > 6 ? arguments[6] : undefined;
          var widget = arguments.length > 7 ? arguments[7] : undefined;
          var parentField = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;
          var op, vals;
          if (isJsonLogic(logic)) {
            op = Object.keys(logic)[0];
            vals = logic[op];
            if (!Array.isArray(vals)) vals = [vals];
          }
          var ret;
          var beforeErrorsCnt = meta.errors.length;
          var lockedOp = config.settings.jsonLogic.lockedOp;
          var isEmptyOp = op == "!" && vals.length == 1 && vals[0] && isJsonLogic(vals[0]) && conv.varKeys.includes(Object.keys(vals[0])[0]);
          var isRev = op == "!" && !isEmptyOp;
          var isLocked = lockedOp && op == lockedOp;
          if (isLocked) {
            ret = convertFromLogic(vals[0], conv, config, expectedType, meta, not, fieldConfig, widget, parentField, true);
          } else if (isRev) {
            // reverse with not
            ret = convertFromLogic(vals[0], conv, config, expectedType, meta, !not, fieldConfig, widget, parentField);
          } else if (expectedType == "val") {
            // not is not used here
            ret = convertField(op, vals, conv, config, not, meta, parentField) || convertFunc(op, vals, conv, config, not, fieldConfig, meta, parentField) || convertVal(logic, fieldConfig, widget, config, meta);
          } else if (expectedType == "rule") {
            ret = convertConj(op, vals, conv, config, not, meta, parentField, false) || convertOp(op, vals, conv, config, not, meta, parentField);
          }
          var afterErrorsCnt = meta.errors.length;
          if (op != "!" && ret === undefined && afterErrorsCnt == beforeErrorsCnt) {
            meta.errors.push("Can't parse logic ".concat(JSON.stringify(logic)));
          }
          if (isLocked) {
            ret.properties.isLocked = true;
          }
          return ret;
        };
        var convertVal = function convertVal(val, fieldConfig, widget, config, meta) {
          if (val === undefined) return undefined;
          var widgetConfig = config.widgets[widget || fieldConfig.mainWidget];
          if (!widgetConfig) {
            meta.errors.push("No widget for type ".concat(fieldConfig.type));
            return undefined;
          }
          if (isJsonLogic(val)) {
            meta.errors.push("Unexpected logic in value: ".concat(JSON.stringify(val)));
            return undefined;
          }

          // number of seconds -> time string
          if (fieldConfig && fieldConfig.type == "time" && typeof val == "number") {
            var h = Math.floor(val / 60 / 60) % 24,
              m = Math.floor(val / 60) % 60,
              s = val % 60;
            var valueFormat = widgetConfig.valueFormat;
            if (valueFormat) {
              var dateVal = new Date(val);
              dateVal.setMilliseconds(0);
              dateVal.setHours(h);
              dateVal.setMinutes(m);
              dateVal.setSeconds(s);
              val = hooks(dateVal).format(valueFormat);
            } else {
              val = "".concat(h, ":").concat(m, ":").concat(s);
            }
          }

          // "2020-01-08T22:00:00.000Z" -> Date object
          if (fieldConfig && ["date", "datetime"].includes(fieldConfig.type) && val && !(val instanceof Date)) {
            try {
              var _dateVal = new Date(val);
              if (_dateVal instanceof Date && _dateVal.toISOString() === val) {
                val = _dateVal;
              }
            } catch (e) {
              meta.errors.push("Can't convert value ".concat(val, " as Date"));
              val = undefined;
            }
          }

          // Date object -> formatted string
          if (val instanceof Date && fieldConfig) {
            var _valueFormat = widgetConfig.valueFormat;
            if (_valueFormat) {
              val = hooks(val).format(_valueFormat);
            }
          }
          var asyncListValues;
          if (val && fieldConfig.fieldSettings && fieldConfig.fieldSettings.asyncFetch) {
            var vals = Array.isArray(val) ? val : [val];
            asyncListValues = vals;
          }
          return {
            valueSrc: "value",
            value: val,
            valueType: widgetConfig.type,
            asyncListValues: asyncListValues
          };
        };
        var convertField = function convertField(op, vals, conv, config, not, meta) {
          var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
          var fieldSeparator = config.settings.fieldSeparator;
          if (conv.varKeys.includes(op) && typeof vals[0] == "string") {
            var field = vals[0];
            if (parentField) field = [parentField, field].join(fieldSeparator);
            field = normalizeField(config, field);
            var fieldConfig = getFieldConfig$8(config, field);
            if (!fieldConfig) {
              meta.errors.push("No config for field ".concat(field));
              return undefined;
            }
            return {
              valueSrc: "field",
              value: field,
              valueType: fieldConfig.type
            };
          }
          return undefined;
        };
        var convertFunc = function convertFunc(op, vals, conv, config, not, fieldConfig, meta) {
          var parentField = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
          if (!op) return undefined;
          var func, argsArr, funcKey;
          var jsonLogicIsMethod = op == "method";
          if (jsonLogicIsMethod) {
            var obj, opts;
            var _vals = _toArray(vals);
            obj = _vals[0];
            func = _vals[1];
            opts = _vals.slice(2);
            argsArr = [obj].concat(_toConsumableArray(opts));
          } else {
            func = op;
            argsArr = vals;
          }
          var fk = (jsonLogicIsMethod ? "#" : "") + func;
          var funcKeys = (conv.funcs[fk] || []).filter(function (k) {
            return fieldConfig ? config.funcs[k].returnType == fieldConfig.type : true;
          });
          if (funcKeys.length) {
            funcKey = funcKeys[0];
          } else {
            var v = _defineProperty$4({}, op, vals);
            for (var _i = 0, _Object$entries = Object.entries(config.funcs || {}); _i < _Object$entries.length; _i++) {
              var _Object$entries$_i = _slicedToArray$1(_Object$entries[_i], 2),
                f = _Object$entries$_i[0],
                fc = _Object$entries$_i[1];
              if (fc.jsonLogicImport && fc.returnType == fieldConfig.type) {
                var parsed = void 0;
                try {
                  parsed = fc.jsonLogicImport(v);
                } catch (_e) {
                  // given expression `v` can't be parsed into function
                }
                if (parsed) {
                  funcKey = f;
                  argsArr = parsed;
                }
              }
            }
          }
          if (!funcKey) return undefined;
          if (funcKey) {
            var funcConfig = config.funcs[funcKey];
            var argKeys = Object.keys(funcConfig.args || {});
            var args = argsArr.reduce(function (acc, val, ind) {
              var argKey = argKeys[ind];
              var argConfig = funcConfig.args[argKey];
              var argVal = convertFromLogic(val, conv, config, "val", meta, false, argConfig, null, parentField);
              if (argVal === undefined) {
                argVal = argConfig.defaultValue;
                if (argVal === undefined) {
                  meta.errors.push("No value for arg ".concat(argKey, " of func ").concat(funcKey));
                  return undefined;
                }
              }
              return _objectSpread$m(_objectSpread$m({}, acc), {}, _defineProperty$4({}, argKey, argVal));
            }, {});
            return {
              valueSrc: "func",
              value: {
                func: funcKey,
                args: args
              },
              valueType: funcConfig.returnType
            };
          }
          return undefined;
        };
        var convertConj = function convertConj(op, vals, conv, config, not, meta) {
          var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
          var conjKey = conv.conjunctions[op];
          var fieldSeparator = config.settings.fieldSeparator;
          var parentFieldConfig = parentField ? getFieldConfig$8(config, parentField) : null;
          (parentFieldConfig === null || parentFieldConfig === void 0 ? void 0 : parentFieldConfig.type) == "!group";
          if (conjKey) {
            var type = "group";
            var children = vals.map(function (v) {
              return convertFromLogic(v, conv, config, "rule", meta, false, null, null, parentField);
            }).filter(function (r) {
              return r !== undefined;
            }).reduce(function (acc, r) {
              return _objectSpread$m(_objectSpread$m({}, acc), {}, _defineProperty$4({}, r.id, r));
            }, {});
            var complexFields = Object.values(children).map(function (v) {
              var _v$properties;
              return v === null || v === void 0 ? void 0 : (_v$properties = v.properties) === null || _v$properties === void 0 ? void 0 : _v$properties.field;
            }).filter(function (f) {
              return f && f.includes(fieldSeparator);
            });
            var complexFieldsGroupAncestors = Object.fromEntries(arrayUniq(complexFields).map(function (f) {
              var parts = f.split(fieldSeparator);
              var ancs = Object.fromEntries(parts.slice(0, -1).map(function (f, i, parts) {
                return [].concat(_toConsumableArray(parts.slice(0, i)), [f]);
              }).map(function (fp) {
                return [fp.join(fieldSeparator), getFieldConfig$8(config, fp)];
              }).filter(function (_ref3) {
                var _ref4 = _slicedToArray$1(_ref3, 2);
                _ref4[0];
                var fc = _ref4[1];
                return fc.type == "!group";
              }));
              return [f, Object.keys(ancs)];
            }));
            Object.values(children).map(function (v) {
              var _v$properties2;
              return v === null || v === void 0 ? void 0 : (_v$properties2 = v.properties) === null || _v$properties2 === void 0 ? void 0 : _v$properties2.field;
            }).map(function (f) {
              return complexFieldsGroupAncestors[f];
            }).filter(function (ancs) {
              return ancs && ancs.length;
            });
            var usedRuleGroups = arrayUniq(Object.values(complexFieldsGroupAncestors).flat());
            topLevelFieldsFilter(usedRuleGroups);
            var properties = {
              conjunction: conjKey,
              not: not
            };
            var id = uuid$1();
            var children1 = {};
            var groupToId = {};
            Object.entries(children).map(function (_ref5) {
              var _ref6 = _slicedToArray$1(_ref5, 2),
                k = _ref6[0],
                v = _ref6[1];
              if (v.type == "group" || v.type == "rule_group") {
                // put as-is
                children1[k] = v;
              } else {
                var _v$properties3;
                var field = v === null || v === void 0 ? void 0 : (_v$properties3 = v.properties) === null || _v$properties3 === void 0 ? void 0 : _v$properties3.field;
                var groupAncestors = complexFieldsGroupAncestors[field];
                var groupField = groupAncestors === null || groupAncestors === void 0 ? void 0 : groupAncestors.at(-1);
                if (!groupField) {
                  // not in rule_group (can be simple field or in struct) - put as-is
                  children1[k] = v;
                } else {
                  // wrap field in rule_group (with creating hierarchy if need)
                  var ch = children1;
                  var parentFieldParts = parentField ? parentField.split(fieldSeparator) : [];
                  var isInParent = shallowEqual$2(parentFieldParts, groupField.split(fieldSeparator).slice(0, parentFieldParts.length));
                  if (!isInParent) parentFieldParts = []; // should not be
                  var traverseGroupFields = groupField.split(fieldSeparator).slice(parentFieldParts.length).map(function (f, i, parts) {
                    return [].concat(_toConsumableArray(parentFieldParts), _toConsumableArray(parts.slice(0, i)), [f]).join(fieldSeparator);
                  }).map(function (f) {
                    return normalizeField(config, f);
                  }).map(function (f) {
                    return {
                      f: f,
                      fc: getFieldConfig$8(config, f) || {}
                    };
                  }).filter(function (_ref7) {
                    var fc = _ref7.fc;
                    return fc.type != "!struct";
                  });
                  traverseGroupFields.map(function (_ref8, i) {
                    var gf = _ref8.f,
                      gfc = _ref8.fc;
                    var groupId = groupToId[gf];
                    if (!groupId) {
                      groupId = uuid$1();
                      groupToId[gf] = groupId;
                      ch[groupId] = {
                        type: "rule_group",
                        id: groupId,
                        children1: {},
                        properties: {
                          conjunction: conjKey,
                          not: false,
                          field: gf,
                          mode: gfc.mode
                        }
                      };
                    }
                    ch = ch[groupId].children1;
                  });
                  ch[k] = v;
                }
              }
            });

            // tip: for isRuleGroup=true correct type and properties will be set out of this func

            return {
              type: type,
              id: id,
              children1: children1,
              properties: properties
            };
          }
          return undefined;
        };
        var topLevelFieldsFilter = function topLevelFieldsFilter(fields) {
          var arr = _toConsumableArray(fields).sort(function (a, b) {
            return a.length - b.length;
          });
          for (var i = 0; i < arr.length; i++) {
            for (var j = i + 1; j < arr.length; j++) {
              if (arr[j].indexOf(arr[i]) == 0) {
                // arr[j] is inside arr[i] (eg. "a.b" inside "a")
                arr.splice(j, 1);
                j--;
              }
            }
          }
          return arr;
        };
        var wrapInDefaultConjRuleGroup = function wrapInDefaultConjRuleGroup(rule, parentField, parentFieldConfig, config, conj) {
          if (!rule) return undefined;
          return {
            type: "rule_group",
            id: uuid$1(),
            children1: _defineProperty$4({}, rule.id, rule),
            properties: {
              conjunction: conj || defaultGroupConjunction$1(config, parentFieldConfig),
              not: false,
              field: parentField
            }
          };
        };
        var wrapInDefaultConj$1 = function wrapInDefaultConj(rule, config) {
          var not = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          return {
            type: "group",
            id: uuid$1(),
            children1: _defineProperty$4({}, rule.id, rule),
            properties: {
              conjunction: defaultConjunction(config),
              not: not
            }
          };
        };
        var parseRule = function parseRule(op, arity, vals, parentField, conv, config, meta) {
          var errors = [];
          var res = _parseRule(op, arity, vals, parentField, conv, config, errors, false) || _parseRule(op, arity, vals, parentField, conv, config, errors, true);
          if (!res) {
            meta.errors.push(errors.join("; ") || "Unknown op ".concat(op, "/").concat(arity));
            return undefined;
          }
          return res;
        };
        var _parseRule = function _parseRule(op, arity, vals, parentField, conv, config, errors, isRevArgs) {
          // config.settings.groupOperators are used for group count (cardinality = 0 is exception)
          // but don't confuse with "all-in" or "some-in" for multiselect
          var isAllOrSomeInForMultiselect = (op == "all" || op == "some") && isJsonLogic(vals[1]) && Object.keys(vals[1])[0] == "in";
          var isGroup0 = !isAllOrSomeInForMultiselect && config.settings.groupOperators.includes(op);
          var eqOps = ["==", "!="];
          var cardinality = isGroup0 ? 0 : arity - 1;
          if (isGroup0) cardinality = 0;else if (eqOps.includes(op) && cardinality == 1 && vals[1] === null) {
            arity = 1;
            cardinality = 0;
            vals = [vals[0]];
          }
          var opk = op + "/" + cardinality;
          var fieldSeparator = config.settings.fieldSeparator;
          var opKeys = conv.operators[(isRevArgs ? "#" : "") + opk];
          if (!opKeys) return;
          var jlField,
            args = [];
          var rangeOps = ["<", "<=", ">", ">="];
          if (rangeOps.includes(op) && arity == 3) {
            jlField = vals[1];
            args = [vals[0], vals[2]];
          } else if (isRevArgs) {
            jlField = vals[1];
            args = [vals[0]];
          } else {
            var _vals2 = vals;
            var _vals3 = _toArray(_vals2);
            jlField = _vals3[0];
            args = _vals3.slice(1);
          }
          if (!isJsonLogic(jlField)) {
            errors.push("Incorrect operands for ".concat(op, ": ").concat(JSON.stringify(vals)));
            return;
          }
          var k = Object.keys(jlField)[0];
          var v = Object.values(jlField)[0];
          var field, having;
          if (conv.varKeys.includes(k) && typeof v == "string") {
            field = v;
          }
          if (isGroup0) {
            having = args[0];
            args = [];
          }
          // reduce/filter for group ext
          if (k == "reduce" && Array.isArray(v) && v.length == 3) {
            var _v2 = v,
              _v3 = _slicedToArray$1(_v2, 3),
              filter = _v3[0],
              acc = _v3[1],
              init = _v3[2];
            if (isJsonLogic(filter) && init == 0 && isJsonLogic(acc) && Array.isArray(acc["+"]) && acc["+"][0] == 1 && isJsonLogic(acc["+"][1]) && acc["+"][1]["var"] == "accumulator") {
              k = Object.keys(filter)[0];
              v = Object.values(filter)[0];
              if (k == "filter") {
                var _v4 = v,
                  _v5 = _slicedToArray$1(_v4, 2),
                  group = _v5[0],
                  _filter = _v5[1];
                if (isJsonLogic(group)) {
                  k = Object.keys(group)[0];
                  v = Object.values(group)[0];
                  if (conv.varKeys.includes(k) && typeof v == "string") {
                    field = v;
                    having = _filter;
                  }
                }
              } else if (conv.varKeys.includes(k) && typeof v == "string") {
                field = v;
              }
            }
          }
          if (!field) {
            errors.push("Unknown field ".concat(JSON.stringify(jlField)));
            return;
          }
          if (parentField) field = [parentField, field].join(fieldSeparator);
          field = normalizeField(config, field);
          var fieldConfig = getFieldConfig$8(config, field);
          if (!fieldConfig) {
            errors.push("No config for field ".concat(field));
            return;
          }
          var opKey = opKeys[0];
          if (opKeys.length > 1 && fieldConfig && fieldConfig.operators) {
            // eg. for "equal" and "select_equals"
            opKeys = opKeys.filter(function (k) {
              return fieldConfig.operators.includes(k);
            });
            if (opKeys.length == 0) {
              errors.push("No corresponding ops for field ".concat(field));
              return;
            }
            opKey = opKeys[0];
          }
          return {
            field: field,
            fieldConfig: fieldConfig,
            opKey: opKey,
            args: args,
            having: having
          };
        };
        var convertOp = function convertOp(op, vals, conv, config, not, meta) {
          var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
          if (!op) return undefined;
          var arity = vals.length;
          if ((op == "all" || op == "some") && isJsonLogic(vals[1])) {
            // special case for "all-in" and "some-in"
            var op2 = Object.keys(vals[1])[0];
            if (op2 == "in") {
              vals = [vals[0], vals[1][op2][1]];
              op = op + "-" + op2; // "all-in" and "some-in"
            }
          }

          var parseRes = parseRule(op, arity, vals, parentField, conv, config, meta);
          if (!parseRes) return undefined;
          var field = parseRes.field,
            fieldConfig = parseRes.fieldConfig,
            opKey = parseRes.opKey,
            args = parseRes.args,
            having = parseRes.having;
          var opConfig = config.operators[opKey];

          // Group component in array mode can show NOT checkbox, so do nothing in this case
          // Otherwise try to revert
          fieldConfig.showNot !== undefined ? fieldConfig.showNot : config.settings.showNot;
          var canRev = true;
          // if (fieldConfig.type == "!group" && fieldConfig.mode == "array" && showNot)
          //   canRev = false;

          var conj;
          var havingVals;
          var havingNot = false;
          if (fieldConfig.type == "!group" && having) {
            conj = Object.keys(having)[0];
            havingVals = having[conj];
            if (!Array.isArray(havingVals)) havingVals = [havingVals];

            // Preprocess "!": Try to reverse op in single rule in having
            // Eg. use `not_equal` instead of `not` `equal`
            var isEmptyOp = conj == "!" && havingVals.length == 1 && havingVals[0] && isJsonLogic(havingVals[0]) && conv.varKeys.includes(Object.keys(havingVals[0])[0]);
            if (conj == "!" && !isEmptyOp) {
              havingNot = true;
              having = having["!"];
              conj = Object.keys(having)[0];
              havingVals = having[conj];
              if (!Array.isArray(havingVals)) havingVals = [havingVals];
            }
          }

          // Use reversed op
          if (not && canRev && opConfig.reversedOp) {
            not = false;
            opKey = opConfig.reversedOp;
            opConfig = config.operators[opKey];
          }
          var widget = getWidgetForFieldOp$3(config, field, opKey);
          var convertedArgs = args.map(function (v) {
            return convertFromLogic(v, conv, config, "val", meta, false, fieldConfig, widget, parentField);
          });
          if (convertedArgs.filter(function (v) {
            return v === undefined;
          }).length) {
            //meta.errors.push(`Undefined arg for field ${field} and op ${opKey}`);
            return undefined;
          }
          var res;
          if (fieldConfig.type == "!group" && having) {
            if (conv.conjunctions[conj] !== undefined) {
              // group
              res = convertConj(conj, havingVals, conv, config, havingNot, meta, field, true);
              havingNot = false;
            } else {
              // need to be wrapped in `rule_group`
              var rule = convertOp(conj, havingVals, conv, config, havingNot, meta, field);
              havingNot = false;
              res = wrapInDefaultConjRuleGroup(rule, field, fieldConfig, config, conv.conjunctions["and"]);
            }
            if (!res) return undefined;
            res.type = "rule_group";
            Object.assign(res.properties, {
              field: field,
              mode: fieldConfig.mode,
              operator: opKey
            });
            if (fieldConfig.mode == "array") {
              Object.assign(res.properties, {
                value: convertedArgs.map(function (v) {
                  return v.value;
                }),
                valueSrc: convertedArgs.map(function (v) {
                  return v.valueSrc;
                }),
                valueType: convertedArgs.map(function (v) {
                  return v.valueType;
                })
              });
            }
            if (not) {
              res = wrapInDefaultConj$1(res, config, not);
            }
          } else if (fieldConfig.type == "!group" && !having) {
            res = {
              type: "rule_group",
              id: uuid$1(),
              children1: {},
              properties: {
                conjunction: defaultGroupConjunction$1(config, fieldConfig),
                not: not,
                mode: fieldConfig.mode,
                field: field,
                operator: opKey
              }
            };
            if (fieldConfig.mode == "array") {
              Object.assign(res.properties, {
                value: convertedArgs.map(function (v) {
                  return v.value;
                }),
                valueSrc: convertedArgs.map(function (v) {
                  return v.valueSrc;
                }),
                valueType: convertedArgs.map(function (v) {
                  return v.valueType;
                })
              });
            }
          } else {
            var asyncListValuesArr = convertedArgs.map(function (v) {
              return v.asyncListValues;
            }).filter(function (v) {
              return v != undefined;
            });
            var asyncListValues = asyncListValuesArr.length ? asyncListValuesArr[0] : undefined;
            res = {
              type: "rule",
              id: uuid$1(),
              properties: {
                field: field,
                operator: opKey,
                value: convertedArgs.map(function (v) {
                  return v.value;
                }),
                valueSrc: convertedArgs.map(function (v) {
                  return v.valueSrc;
                }),
                valueType: convertedArgs.map(function (v) {
                  return v.valueType;
                }),
                asyncListValues: asyncListValues
              }
            };
            if (not) {
              //meta.errors.push(`No rev op for ${opKey}`);
              res = wrapInDefaultConj$1(res, config, not);
            }
          }
          return res;
        };
        var spel2js = {
          exports: {}
        };

        /*
         * Copyright 2002-2015 the original author or authors.
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *      http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        (function (module, exports) {
          (function webpackUniversalModuleDefinition(root, factory) {
            module.exports = factory();
          })(commonjsGlobal, function () {
            return (/******/function (modules) {
                // webpackBootstrap
                /******/ // The module cache
                /******/
                var installedModules = {};
                /******/
                /******/ // The require function
                /******/
                function __webpack_require__(moduleId) {
                  /******/
                  /******/ // Check if module is in cache
                  /******/if (installedModules[moduleId]) {
                    /******/return installedModules[moduleId].exports;
                    /******/
                  }
                  /******/ // Create a new module (and put it into the cache)
                  /******/
                  var module = installedModules[moduleId] = {
                    /******/i: moduleId,
                    /******/l: false,
                    /******/exports: {}
                    /******/
                  };
                  /******/
                  /******/ // Execute the module function
                  /******/
                  modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
                  /******/
                  /******/ // Flag the module as loaded
                  /******/
                  module.l = true;
                  /******/
                  /******/ // Return the exports of the module
                  /******/
                  return module.exports;
                  /******/
                }
                /******/
                /******/
                /******/ // expose the modules object (__webpack_modules__)
                /******/
                __webpack_require__.m = modules;
                /******/
                /******/ // expose the module cache
                /******/
                __webpack_require__.c = installedModules;
                /******/
                /******/ // define getter function for harmony exports
                /******/
                __webpack_require__.d = function (exports, name, getter) {
                  /******/if (!__webpack_require__.o(exports, name)) {
                    /******/Object.defineProperty(exports, name, {
                      /******/configurable: false,
                      /******/enumerable: true,
                      /******/get: getter
                      /******/
                    });
                    /******/
                  }
                  /******/
                };
                /******/
                /******/ // getDefaultExport function for compatibility with non-harmony modules
                /******/
                __webpack_require__.n = function (module) {
                  /******/var getter = module && module.__esModule ? /******/function getDefault() {
                    return module['default'];
                  } : /******/function getModuleExports() {
                    return module;
                  };
                  /******/
                  __webpack_require__.d(getter, 'a', getter);
                  /******/
                  return getter;
                  /******/
                };
                /******/
                /******/ // Object.prototype.hasOwnProperty.call
                /******/
                __webpack_require__.o = function (object, property) {
                  return Object.prototype.hasOwnProperty.call(object, property);
                };
                /******/
                /******/ // __webpack_public_path__
                /******/
                __webpack_require__.p = "";
                /******/
                /******/ // Load entry module and return exports
                /******/
                return __webpack_require__(__webpack_require__.s = 3);
                /******/
              }
              /************************************************************************/
              /******/([/* 0 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

                /**
                 * The common supertype of all AST nodes in a parsed Spring Expression Language
                 * format expression.
                 *
                 * @author Andy Clement
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createSpelNode(nodeType, position) {
                  var node = {},
                    type = nodeType || 'Abstract',
                    children = [],
                    parent = null,
                    activeContext;
                  node._type = type;
                  node.getType = function () {
                    return type;
                  };
                  node.setType = function (nodeType) {
                    type = nodeType;
                  };
                  node.getChildren = function () {
                    return children;
                  };
                  node.addChild = function (childNode) {
                    if (!childNode) {
                      // See OpMinus and OpPlus: right node can be null for unary mode
                      return;
                    }
                    if (!childNode.setParent) {
                      throw {
                        name: 'Error',
                        message: 'Trying to add a child which is not a node: ' + JSON.stringify(childNode)
                      };
                    }
                    childNode.setParent(node);
                    children.push(childNode);
                  };
                  node.getParent = function () {
                    return parent;
                  };
                  node.setParent = function (parentNode) {
                    parent = parentNode;
                  };
                  node.getContext = function (state) {
                    return activeContext || state.activeContext.peek();
                  };
                  node.setContext = function (nodeContext) {
                    activeContext = nodeContext;
                  };
                  node.getStartPosition = function () {
                    return position >> 16;
                  };
                  node.getEndPosition = function () {
                    return position & 0xffff;
                  };

                  //must override
                  node.getValue = function () {
                    throw {
                      name: 'MethodNotImplementedException',
                      message: 'SpelNode#getValue() must be overridden.'
                    };
                  };
                  node.toString = function () {
                    var s = 'Kind: ' + node.getType();
                    //s += ', Value: ' + node.getValue();
                    s += ', Children: [';
                    for (var i = 0, l = node.getChildren().length; i < l; i += 1) {
                      s += '{' + node.getChildren()[i] + '}, ';
                    }
                    s += ']';
                    return s;
                  };

                  //constructor
                  if (position === 0) {
                    throw {
                      name: 'Error',
                      message: 'Position cannot be 0'
                    };
                  }
                  for (var _len = arguments.length, operands = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                    operands[_key - 2] = arguments[_key];
                  }
                  if (operands) {
                    operands.forEach(function (operand) {
                      node.addChild(operand);
                    });
                  }
                  return node;
                }
                exports.SpelNode = {
                  create: createSpelNode
                };

                /***/
              }, /* 1 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.Stack = Stack;
                /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

                /**
                 * @author Ben March
                 * @since 0.2.0
                 */

                function Stack(startingElements) {
                  this.elements = startingElements || [];
                }
                Stack.prototype.push = function (el) {
                  this.elements.push(el);
                  return el;
                };
                Stack.prototype.pop = function () {
                  return this.elements.pop();
                };
                Stack.prototype.peek = function () {
                  return this.elements[this.elements.length - 1];
                };
                Stack.prototype.empty = function () {
                  return this.elements.length > 0;
                };
                Stack.prototype.search = function (el) {
                  return this.elements.length - this.elements.indexOf(el);
                };

                /***/
              }, /* 2 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

                /**
                 * @author Andy Clement
                 * @author Ben March
                 * @since 0.2.0
                 */

                var types = {
                  LITERAL_INT: 1,
                  //tested

                  LITERAL_LONG: 2,
                  //tested

                  LITERAL_HEXINT: 3,
                  //tested

                  LITERAL_HEXLONG: 4,
                  //tested

                  LITERAL_STRING: 5,
                  //tested

                  LITERAL_REAL: 6,
                  //tested

                  LITERAL_REAL_FLOAT: 7,
                  //tested

                  LPAREN: '(',
                  //tested

                  RPAREN: ')',
                  //tested

                  COMMA: ',',
                  //tested

                  IDENTIFIER: 0,
                  //tested

                  COLON: ':',
                  //tested

                  HASH: '#',
                  //tested

                  RSQUARE: ']',
                  //tested

                  LSQUARE: '[',
                  //tested

                  LCURLY: '{',
                  //tested

                  RCURLY: '}',
                  //tested

                  DOT: '.',
                  //tested

                  PLUS: '+',
                  //tested

                  STAR: '*',
                  //tested

                  MINUS: '-',
                  //tested

                  SELECT_FIRST: '^[',
                  //tested

                  SELECT_LAST: '$[',
                  //tested

                  QMARK: '?',
                  //tested

                  PROJECT: '![',
                  //tested

                  DIV: '/',
                  //tested

                  GE: '>=',
                  //tested

                  GT: '>',
                  //tested

                  LE: '<=',
                  //tested

                  LT: '<',
                  //tested

                  EQ: '==',
                  //tested

                  NE: '!=',
                  //tested

                  MOD: '%',
                  //tested

                  NOT: '!',
                  //tested

                  ASSIGN: '=',
                  //tested

                  INSTANCEOF: 'instanceof',
                  //test fails

                  MATCHES: 'matches',
                  //test fails

                  BETWEEN: 'between',
                  //test fails

                  SELECT: '?[',
                  //tested

                  POWER: '^',
                  //tested

                  ELVIS: '?:',
                  //tested

                  SAFE_NAVI: '?.',
                  //tested

                  BEAN_REF: '@',
                  //tested

                  SYMBOLIC_OR: '||',
                  //tested

                  SYMBOLIC_AND: '&&',
                  //tested

                  INC: '++',
                  //tested

                  DEC: '--' //tested
                };

                function TokenKind(type) {
                  this.type = type;
                  this.tokenChars = types[type];
                  this._hasPayload = typeof types[type] !== 'string';
                  if (typeof types[type] === 'number') {
                    this._ordinal = types[type];
                  }
                }

                //create enum
                for (var t in types) {
                  if (types.hasOwnProperty(t)) {
                    TokenKind[t] = new TokenKind(t);
                  }
                }
                TokenKind.prototype.toString = function () {
                  return this.type + (this.tokenChars.length !== 0 ? '(' + this.tokenChars + ')' : '');
                };
                TokenKind.prototype.getLength = function () {
                  return this.tokenChars.length;
                };
                TokenKind.prototype.hasPayload = function () {
                  return this._hasPayload;
                };
                TokenKind.prototype.valueOf = function (id) {
                  for (var t in types) {
                    if (types.hasOwnProperty(t) && types[t] === id) {
                      return TokenKind[t];
                    }
                  }
                };
                TokenKind.prototype.ordinal = function () {
                  return this._ordinal;
                };
                exports.TokenKind = TokenKind;

                /***/
              }, /* 3 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.StandardContext = exports.SpelExpressionEvaluator = undefined;
                var _SpelExpressionEvaluator = __webpack_require__(4);
                var _StandardContext = __webpack_require__(50);

                /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

                /**
                 * @author Ben March
                 * @since 0.2.0
                 */

                exports.SpelExpressionEvaluator = _SpelExpressionEvaluator.SpelExpressionEvaluator;
                exports.StandardContext = _StandardContext.StandardContext;

                /***/
              }, /* 4 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.SpelExpressionEvaluator = undefined;
                var _SpelExpressionParser = __webpack_require__(5);
                var _Stack = __webpack_require__(1);

                /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

                /**
                 * @author Ben March
                 * @since 0.2.0
                 */

                var spelExpressionEvaluator = {};
                function evalCompiled(compiledExpression, context, locals) {
                  var activeContext = new _Stack.Stack(),
                    state;
                  if (!context) {
                    context = {};
                  }
                  activeContext.push(context);
                  state = {
                    rootContext: context,
                    activeContext: activeContext,
                    locals: locals
                  };
                  return compiledExpression.getValue(state);
                }
                spelExpressionEvaluator.compile = function (expression) {
                  var compiledExpression = (0, _SpelExpressionParser.SpelExpressionParser)().parse(expression);
                  return {
                    eval: function _eval(context, locals) {
                      return evalCompiled(compiledExpression, context, locals);
                    },
                    _compiledExpression: compiledExpression
                  };
                };
                spelExpressionEvaluator.eval = function (expression, context, locals) {
                  return spelExpressionEvaluator.compile(expression).eval(context, locals);
                };
                exports.SpelExpressionEvaluator = spelExpressionEvaluator;

                /***/
              }, /* 5 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.SpelExpressionParser = undefined;
                var _TokenKind = __webpack_require__(2);
                var _Tokenizer = __webpack_require__(6);
                var _BooleanLiteral = __webpack_require__(8);
                var _NumberLiteral = __webpack_require__(9);
                var _StringLiteral = __webpack_require__(10);
                var _NullLiteral = __webpack_require__(11);
                var _FunctionReference = __webpack_require__(12);
                var _MethodReference = __webpack_require__(13);
                var _PropertyReference = __webpack_require__(14);
                var _VariableReference = __webpack_require__(15);
                var _CompoundExpression = __webpack_require__(16);
                var _Indexer = __webpack_require__(17);
                var _Assign = __webpack_require__(18);
                var _OpEQ = __webpack_require__(19);
                var _OpNE = __webpack_require__(20);
                var _OpGE = __webpack_require__(21);
                var _OpGT = __webpack_require__(22);
                var _OpLE = __webpack_require__(23);
                var _OpLT = __webpack_require__(24);
                var _OpPlus = __webpack_require__(25);
                var _OpMinus = __webpack_require__(26);
                var _OpMultiply = __webpack_require__(27);
                var _OpDivide = __webpack_require__(28);
                var _OpModulus = __webpack_require__(29);
                var _OpPower = __webpack_require__(30);
                var _OpInc = __webpack_require__(31);
                var _OpDec = __webpack_require__(32);
                var _OpNot = __webpack_require__(33);
                var _OpAnd = __webpack_require__(34);
                var _OpOr = __webpack_require__(35);
                var _OpMatches = __webpack_require__(36);
                var _Ternary = __webpack_require__(37);
                var _Elvis = __webpack_require__(38);
                var _InlineList = __webpack_require__(39);
                var _InlineMap = __webpack_require__(40);
                var _Selection = __webpack_require__(41);
                var _Projection = __webpack_require__(42);
                var _OpInstanceof = __webpack_require__(43);
                var _OpBetween = __webpack_require__(44);
                var _TypeReference = __webpack_require__(45);
                var _BeanReference = __webpack_require__(46);
                var _Identifier = __webpack_require__(47);
                var _QualifiedIdentifier = __webpack_require__(48);
                var _ConstructorReference = __webpack_require__(49);

                /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

                /**
                 * @author Andy Clement
                 * @author Juergen Hoeller
                 * @author Ben March
                 * @since 0.2.0
                 *
                 */

                exports.SpelExpressionParser = function SpelExpressionParser() {
                  var VALID_QUALIFIED_ID_PATTERN = new RegExp('[\\p{L}\\p{N}_$]+');

                  // For rules that build nodes, they are stacked here for return
                  var constructedNodes = [];

                  // The expression being parsed
                  var expressionString;

                  // The token stream constructed from that expression string
                  var tokenStream;

                  // length of a populated token stream
                  var tokenStreamLength;

                  // Current location in the token stream when processing tokens
                  var tokenStreamPointer;

                  /**
                   * Create a parser with some configured behavior.
                   * @param config custom configuration options
                   */
                  function setConfiguration(config) {}
                  function parse(expression, context) {
                    try {
                      expressionString = expression;
                      tokenStream = _Tokenizer.Tokenizer.tokenize(expression);
                      tokenStreamLength = tokenStream.length;
                      tokenStreamPointer = 0;
                      constructedNodes = [];
                      var ast = eatExpression();
                      if (moreTokens()) {
                        raiseInternalException(peekToken().startPos, 'MORE_INPUT', nextToken().toString());
                      }
                      //Assert.isTrue(this.constructedNodes.isEmpty());
                      return ast;
                    } catch (e) {
                      throw e.message;
                    }
                  }

                  //	expression
                  //    : logicalOrExpression
                  //      ( (ASSIGN^ logicalOrExpression)
                  //	    | (DEFAULT^ logicalOrExpression)
                  //	    | (QMARK^ expression COLON! expression)
                  //      | (ELVIS^ expression))?;
                  function eatExpression() {
                    var expr = eatLogicalOrExpression();
                    if (moreTokens()) {
                      var token = peekToken();
                      if (token.getKind() === _TokenKind.TokenKind.ASSIGN) {
                        // a=b
                        if (expr === null) {
                          expr = _NullLiteral.NullLiteral.create(toPosBounds(token.startPos - 1, token.endPos - 1));
                        }
                        nextToken();
                        var assignedValue = eatLogicalOrExpression();
                        return _Assign.Assign.create(toPosToken(token), expr, assignedValue);
                      }
                      if (token.getKind() === _TokenKind.TokenKind.ELVIS) {
                        // a?:b (a if it isn't null, otherwise b)
                        if (expr === null) {
                          expr = _NullLiteral.NullLiteral.create(toPosBounds(token.startPos - 1, token.endPos - 2));
                        }
                        nextToken(); // elvis has left the building
                        var valueIfNull = eatExpression();
                        if (valueIfNull === null) {
                          valueIfNull = _NullLiteral.NullLiteral.create(toPosBounds(token.startPos + 1, token.endPos + 1));
                        }
                        return _Elvis.Elvis.create(toPosToken(token), expr, valueIfNull);
                      }
                      if (token.getKind() === _TokenKind.TokenKind.QMARK) {
                        // a?b:c
                        if (expr === null) {
                          expr = _NullLiteral.NullLiteral.create(toPosBounds(token.startPos - 1, token.endPos - 1));
                        }
                        nextToken();
                        var ifTrueExprValue = eatExpression();
                        eatToken(_TokenKind.TokenKind.COLON);
                        var ifFalseExprValue = eatExpression();
                        return _Ternary.Ternary.create(toPosToken(token), expr, ifTrueExprValue, ifFalseExprValue);
                      }
                    }
                    return expr;
                  }

                  //logicalOrExpression : logicalAndExpression (OR^ logicalAndExpression)*;
                  function eatLogicalOrExpression() {
                    var expr = eatLogicalAndExpression();
                    while (peekIdentifierToken('or') || peekTokenOne(_TokenKind.TokenKind.SYMBOLIC_OR)) {
                      var token = nextToken(); //consume OR
                      var rhExpr = eatLogicalAndExpression();
                      checkOperands(token, expr, rhExpr);
                      expr = _OpOr.OpOr.create(toPosToken(token), expr, rhExpr);
                    }
                    return expr;
                  }

                  // logicalAndExpression : relationalExpression (AND^ relationalExpression)*;
                  function eatLogicalAndExpression() {
                    var expr = eatRelationalExpression();
                    while (peekIdentifierToken('and') || peekTokenOne(_TokenKind.TokenKind.SYMBOLIC_AND)) {
                      var token = nextToken(); // consume 'AND'
                      var rhExpr = eatRelationalExpression();
                      checkOperands(token, expr, rhExpr);
                      expr = _OpAnd.OpAnd.create(toPosToken(token), expr, rhExpr);
                    }
                    return expr;
                  }

                  // relationalExpression : sumExpression (relationalOperator^ sumExpression)?;
                  function eatRelationalExpression() {
                    var expr = eatSumExpression();
                    var relationalOperatorToken = maybeEatRelationalOperator();
                    if (relationalOperatorToken !== null) {
                      var token = nextToken(); // consume relational operator token
                      var rhExpr = eatSumExpression();
                      checkOperands(token, expr, rhExpr);
                      var tk = relationalOperatorToken.kind;
                      if (relationalOperatorToken.isNumericRelationalOperator()) {
                        var pos = toPosToken(token);
                        if (tk === _TokenKind.TokenKind.GT) {
                          return _OpGT.OpGT.create(pos, expr, rhExpr);
                        }
                        if (tk === _TokenKind.TokenKind.LT) {
                          return _OpLT.OpLT.create(pos, expr, rhExpr);
                        }
                        if (tk === _TokenKind.TokenKind.LE) {
                          return _OpLE.OpLE.create(pos, expr, rhExpr);
                        }
                        if (tk === _TokenKind.TokenKind.GE) {
                          return _OpGE.OpGE.create(pos, expr, rhExpr);
                        }
                        if (tk === _TokenKind.TokenKind.EQ) {
                          return _OpEQ.OpEQ.create(pos, expr, rhExpr);
                        }
                        //Assert.isTrue(tk === TokenKind.NE);
                        return _OpNE.OpNE.create(pos, expr, rhExpr);
                      }
                      if (tk === _TokenKind.TokenKind.INSTANCEOF) {
                        return _OpInstanceof.OpInstanceof.create(toPosToken(token), expr, rhExpr);
                      }
                      if (tk === _TokenKind.TokenKind.MATCHES) {
                        return _OpMatches.OpMatches.create(toPosToken(token), expr, rhExpr);
                      }

                      //Assert.isTrue(tk === TokenKind.BETWEEN);
                      return _OpBetween.OpBetween.create(toPosToken(token), expr, rhExpr);
                    }
                    return expr;
                  }

                  //sumExpression: productExpression ( (PLUS^ | MINUS^) productExpression)*;
                  function eatSumExpression() {
                    var expr = eatProductExpression();
                    while (peekTokenAny(_TokenKind.TokenKind.PLUS, _TokenKind.TokenKind.MINUS, _TokenKind.TokenKind.INC)) {
                      var token = nextToken(); //consume PLUS or MINUS or INC
                      var rhExpr = eatProductExpression();
                      checkRightOperand(token, rhExpr);
                      if (token.getKind() === _TokenKind.TokenKind.PLUS) {
                        expr = _OpPlus.OpPlus.create(toPosToken(token), expr, rhExpr);
                      } else if (token.getKind() === _TokenKind.TokenKind.MINUS) {
                        expr = _OpMinus.OpMinus.create(toPosToken(token), expr, rhExpr);
                      }
                    }
                    return expr;
                  }

                  // productExpression: powerExpr ((STAR^ | DIV^| MOD^) powerExpr)* ;
                  function eatProductExpression() {
                    var expr = eatPowerIncDecExpression();
                    while (peekTokenAny(_TokenKind.TokenKind.STAR, _TokenKind.TokenKind.DIV, _TokenKind.TokenKind.MOD)) {
                      var token = nextToken(); // consume STAR/DIV/MOD
                      var rhExpr = eatPowerIncDecExpression();
                      checkOperands(token, expr, rhExpr);
                      if (token.getKind() === _TokenKind.TokenKind.STAR) {
                        expr = _OpMultiply.OpMultiply.create(toPosToken(token), expr, rhExpr);
                      } else if (token.getKind() === _TokenKind.TokenKind.DIV) {
                        expr = _OpDivide.OpDivide.create(toPosToken(token), expr, rhExpr);
                      } else {
                        //Assert.isTrue(token.getKind() === TokenKind.MOD);
                        expr = _OpModulus.OpModulus.create(toPosToken(token), expr, rhExpr);
                      }
                    }
                    return expr;
                  }

                  // powerExpr  : unaryExpression (POWER^ unaryExpression)? (INC || DEC) ;
                  function eatPowerIncDecExpression() {
                    var expr = eatUnaryExpression(),
                      token;
                    if (peekTokenOne(_TokenKind.TokenKind.POWER)) {
                      token = nextToken(); //consume POWER
                      var rhExpr = eatUnaryExpression();
                      checkRightOperand(token, rhExpr);
                      return _OpPower.OpPower.create(toPosToken(token), expr, rhExpr);
                    }
                    if (expr !== null && peekTokenAny(_TokenKind.TokenKind.INC, _TokenKind.TokenKind.DEC)) {
                      token = nextToken(); //consume INC/DEC
                      if (token.getKind() === _TokenKind.TokenKind.INC) {
                        return _OpInc.OpInc.create(toPosToken(token), true, expr);
                      }
                      return _OpDec.OpDec.create(toPosToken(token), true, expr);
                    }
                    return expr;
                  }

                  // unaryExpression: (PLUS^ | MINUS^ | BANG^ | INC^ | DEC^) unaryExpression | primaryExpression ;
                  function eatUnaryExpression() {
                    var token, expr;
                    if (peekTokenAny(_TokenKind.TokenKind.PLUS, _TokenKind.TokenKind.MINUS, _TokenKind.TokenKind.NOT)) {
                      token = nextToken();
                      expr = eatUnaryExpression();
                      if (token.getKind() === _TokenKind.TokenKind.NOT) {
                        return _OpNot.OpNot.create(toPosToken(token), expr);
                      }
                      if (token.getKind() === _TokenKind.TokenKind.PLUS) {
                        return _OpPlus.OpPlus.create(toPosToken(token), expr);
                      }
                      //Assert.isTrue(token.getKind() === TokenKind.MINUS);
                      return _OpMinus.OpMinus.create(toPosToken(token), expr);
                    }
                    if (peekTokenAny(_TokenKind.TokenKind.INC, _TokenKind.TokenKind.DEC)) {
                      token = nextToken();
                      expr = eatUnaryExpression();
                      if (token.getKind() === _TokenKind.TokenKind.INC) {
                        return _OpInc.OpInc.create(toPosToken(token), false, expr);
                      }
                      return _OpDec.OpDec.create(toPosToken(token), false, expr);
                    }
                    return eatPrimaryExpression();
                  }

                  // primaryExpression : startNode (node)? -> ^(EXPRESSION startNode (node)?);
                  function eatPrimaryExpression() {
                    var nodes = [];
                    var start = eatStartNode(); // always a start node
                    nodes.push(start);
                    while (maybeEatNode()) {
                      nodes.push(pop());
                    }
                    if (nodes.length === 1) {
                      return nodes[0];
                    }
                    return _CompoundExpression.CompoundExpression.create(toPosBounds(start.getStartPosition(), nodes[nodes.length - 1].getEndPosition()), nodes);
                  }

                  // node : ((DOT dottedNode) | (SAFE_NAVI dottedNode) | nonDottedNode)+;
                  function maybeEatNode() {
                    var expr = null;
                    if (peekTokenAny(_TokenKind.TokenKind.DOT, _TokenKind.TokenKind.SAFE_NAVI)) {
                      expr = eatDottedNode();
                    } else {
                      expr = maybeEatNonDottedNode();
                    }
                    if (expr === null) {
                      return false;
                    } else {
                      push(expr);
                      return true;
                    }
                  }

                  // nonDottedNode: indexer;
                  function maybeEatNonDottedNode() {
                    if (peekTokenOne(_TokenKind.TokenKind.LSQUARE)) {
                      if (maybeEatIndexer()) {
                        return pop();
                      }
                    }
                    return null;
                  }

                  //dottedNode
                  // : ((methodOrProperty
                  //	  | functionOrVar
                  //    | projection
                  //    | selection
                  //    | firstSelection
                  //    | lastSelection
                  //    ))
                  //	;
                  function eatDottedNode() {
                    var token = nextToken(); // it was a '.' or a '?.'
                    var nullSafeNavigation = token.getKind() === _TokenKind.TokenKind.SAFE_NAVI;
                    if (maybeEatMethodOrProperty(nullSafeNavigation) || maybeEatFunctionOrVar() || maybeEatProjection(nullSafeNavigation) || maybeEatSelection(nullSafeNavigation)) {
                      return pop();
                    }
                    if (peekToken() === null) {
                      // unexpectedly ran out of data
                      raiseInternalException(token.startPos, 'OOD');
                    } else {
                      raiseInternalException(token.startPos, 'UNEXPECTED_DATA_AFTER_DOT', toString(peekToken()));
                    }
                    return null;
                  }

                  // functionOrVar
                  // : (POUND ID LPAREN) => function
                  // | var
                  //
                  // function : POUND id=ID methodArgs -> ^(FUNCTIONREF[$id] methodArgs);
                  // var : POUND id=ID -> ^(VARIABLEREF[$id]);
                  function maybeEatFunctionOrVar() {
                    if (!peekTokenOne(_TokenKind.TokenKind.HASH)) {
                      return false;
                    }
                    var token = nextToken();
                    var functionOrVariableName = eatToken(_TokenKind.TokenKind.IDENTIFIER);
                    var args = maybeEatMethodArgs();
                    if (args === null) {
                      push(_VariableReference.VariableReference.create(functionOrVariableName.data, toPosBounds(token.startPos, functionOrVariableName.endPos)));
                      return true;
                    }
                    push(_FunctionReference.FunctionReference.create(functionOrVariableName.data, toPosBounds(token.startPos, functionOrVariableName.endPos), args));
                    return true;
                  }

                  // methodArgs : LPAREN! (argument (COMMA! argument)* (COMMA!)?)? RPAREN!;
                  function maybeEatMethodArgs() {
                    if (!peekTokenOne(_TokenKind.TokenKind.LPAREN)) {
                      return null;
                    }
                    var args = [];
                    consumeArguments(args);
                    eatToken(_TokenKind.TokenKind.RPAREN);
                    return args;
                  }
                  function eatConstructorArgs(accumulatedArguments) {
                    if (!peekTokenOne(_TokenKind.TokenKind.LPAREN)) {
                      raiseInternalException(toPosToken(peekToken()), 'MISSING_CONSTRUCTOR_ARGS');
                    }
                    consumeArguments(accumulatedArguments);
                    eatToken(_TokenKind.TokenKind.RPAREN);
                  }

                  /**
                   * Used for consuming arguments for either a method or a constructor call
                   */
                  function consumeArguments(accumulatedArguments) {
                    var pos = peekToken().startPos;
                    var next;
                    do {
                      nextToken(); // consume ( (first time through) or comma (subsequent times)
                      var token = peekToken();
                      if (token === null) {
                        raiseInternalException(pos, 'RUN_OUT_OF_ARGUMENTS');
                      }
                      if (token.getKind() !== _TokenKind.TokenKind.RPAREN) {
                        accumulatedArguments.push(eatExpression());
                      }
                      next = peekToken();
                    } while (next !== null && next.kind === _TokenKind.TokenKind.COMMA);
                    if (next === null) {
                      raiseInternalException(pos, 'RUN_OUT_OF_ARGUMENTS');
                    }
                  }

                  //startNode
                  // : parenExpr | literal
                  //	    | type
                  //	    | methodOrProperty
                  //	    | functionOrVar
                  //	    | projection
                  //	    | selection
                  //	    | firstSelection
                  //	    | lastSelection
                  //	    | indexer
                  //	    | constructor
                  function eatStartNode() {
                    if (maybeEatLiteral()) {
                      return pop();
                    } else if (maybeEatParenExpression()) {
                      return pop();
                    } else if (maybeEatTypeReference() || maybeEatNullReference() || maybeEatConstructorReference() || maybeEatMethodOrProperty(false) || maybeEatFunctionOrVar()) {
                      return pop();
                    } else if (maybeEatBeanReference()) {
                      return pop();
                    } else if (maybeEatProjection(false) || maybeEatSelection(false) || maybeEatIndexer()) {
                      return pop();
                    } else if (maybeEatInlineListOrMap()) {
                      return pop();
                    } else {
                      return null;
                    }
                  }

                  // parse: @beanname @'bean.name'
                  // quoted if dotted
                  function maybeEatBeanReference() {
                    if (peekTokenOne(_TokenKind.TokenKind.BEAN_REF)) {
                      var beanRefToken = nextToken();
                      var beanNameToken = null;
                      var beanName = null;
                      if (peekTokenOne(_TokenKind.TokenKind.IDENTIFIER)) {
                        beanNameToken = eatToken(_TokenKind.TokenKind.IDENTIFIER);
                        beanName = beanNameToken.data;
                      } else if (peekTokenOne(_TokenKind.TokenKind.LITERAL_STRING)) {
                        beanNameToken = eatToken(_TokenKind.TokenKind.LITERAL_STRING);
                        beanName = beanNameToken.stringValue();
                        beanName = beanName.substring(1, beanName.length() - 1);
                      } else {
                        raiseInternalException(beanRefToken.startPos, 'INVALID_BEAN_REFERENCE');
                      }
                      var beanReference = _BeanReference.BeanReference.create(toPosToken(beanNameToken), beanName);
                      push(beanReference);
                      return true;
                    }
                    return false;
                  }
                  function maybeEatTypeReference() {
                    if (peekTokenOne(_TokenKind.TokenKind.IDENTIFIER)) {
                      var typeName = peekToken();
                      if (typeName.stringValue() !== 'T') {
                        return false;
                      }
                      // It looks like a type reference but is T being used as a map key?
                      var token = nextToken();
                      if (peekTokenOne(_TokenKind.TokenKind.RSQUARE)) {
                        // looks like 'T]' (T is map key)
                        push(_PropertyReference.PropertyReference.create(token.stringValue(), toPosToken(token)));
                        return true;
                      }
                      eatToken(_TokenKind.TokenKind.LPAREN);
                      var node = eatPossiblyQualifiedId();
                      // dotted qualified id
                      // Are there array dimensions?
                      var dims = 0;
                      while (peekTokenConsumeIfMatched(_TokenKind.TokenKind.LSQUARE, true)) {
                        eatToken(_TokenKind.TokenKind.RSQUARE);
                        dims++;
                      }
                      eatToken(_TokenKind.TokenKind.RPAREN);
                      push(_TypeReference.TypeReference.create(toPosToken(typeName), node, dims));
                      return true;
                    }
                    return false;
                  }
                  function maybeEatNullReference() {
                    if (peekTokenOne(_TokenKind.TokenKind.IDENTIFIER)) {
                      var nullToken = peekToken();
                      if (nullToken.stringValue().toLowerCase() !== 'null') {
                        return false;
                      }
                      nextToken();
                      push(_NullLiteral.NullLiteral.create(toPosToken(nullToken)));
                      return true;
                    }
                    return false;
                  }

                  //projection: PROJECT^ expression RCURLY!;
                  function maybeEatProjection(nullSafeNavigation) {
                    var token = peekToken();
                    if (!peekTokenConsumeIfMatched(_TokenKind.TokenKind.PROJECT, true)) {
                      return false;
                    }
                    var expr = eatExpression();
                    eatToken(_TokenKind.TokenKind.RSQUARE);
                    push(_Projection.Projection.create(nullSafeNavigation, toPosToken(token), expr));
                    return true;
                  }

                  // list = LCURLY (element (COMMA element)*) RCURLY
                  // map  = LCURLY (key ':' value (COMMA key ':' value)*) RCURLY
                  function maybeEatInlineListOrMap() {
                    var token = peekToken(),
                      listElements = [];
                    if (!peekTokenConsumeIfMatched(_TokenKind.TokenKind.LCURLY, true)) {
                      return false;
                    }
                    var expr = null;
                    var closingCurly = peekToken();
                    if (peekTokenConsumeIfMatched(_TokenKind.TokenKind.RCURLY, true)) {
                      // empty list '{}'
                      expr = _InlineList.InlineList.create(toPosBounds(token.startPos, closingCurly.endPos));
                    } else if (peekTokenConsumeIfMatched(_TokenKind.TokenKind.COLON, true)) {
                      closingCurly = eatToken(_TokenKind.TokenKind.RCURLY);
                      // empty map '{:}'
                      expr = _InlineMap.InlineMap.create(toPosBounds(token.startPos, closingCurly.endPos));
                    } else {
                      var firstExpression = eatExpression();
                      // Next is either:
                      // '}' - end of list
                      // ',' - more expressions in this list
                      // ':' - this is a map!

                      if (peekTokenOne(_TokenKind.TokenKind.RCURLY)) {
                        // list with one item in it
                        listElements.push(firstExpression);
                        closingCurly = eatToken(_TokenKind.TokenKind.RCURLY);
                        expr = _InlineList.InlineList.create(toPosBounds(token.startPos, closingCurly.endPos), listElements);
                      } else if (peekTokenConsumeIfMatched(_TokenKind.TokenKind.COMMA, true)) {
                        // multi item list
                        listElements.push(firstExpression);
                        do {
                          listElements.push(eatExpression());
                        } while (peekTokenConsumeIfMatched(_TokenKind.TokenKind.COMMA, true));
                        closingCurly = eatToken(_TokenKind.TokenKind.RCURLY);
                        expr = _InlineList.InlineList.create(toPosToken(token.startPos, closingCurly.endPos), listElements);
                      } else if (peekTokenConsumeIfMatched(_TokenKind.TokenKind.COLON, true)) {
                        // map!
                        var mapElements = [];
                        mapElements.push(firstExpression);
                        mapElements.push(eatExpression());
                        while (peekTokenConsumeIfMatched(_TokenKind.TokenKind.COMMA, true)) {
                          mapElements.push(eatExpression());
                          eatToken(_TokenKind.TokenKind.COLON);
                          mapElements.push(eatExpression());
                        }
                        closingCurly = eatToken(_TokenKind.TokenKind.RCURLY);
                        expr = _InlineMap.InlineMap.create(toPosBounds(token.startPos, closingCurly.endPos), mapElements);
                      } else {
                        raiseInternalException(token.startPos, 'OOD');
                      }
                    }
                    push(expr);
                    return true;
                  }
                  function maybeEatIndexer() {
                    var token = peekToken();
                    if (!peekTokenConsumeIfMatched(_TokenKind.TokenKind.LSQUARE, true)) {
                      return false;
                    }
                    var expr = eatExpression();
                    eatToken(_TokenKind.TokenKind.RSQUARE);
                    push(_Indexer.Indexer.create(toPosToken(token), expr));
                    return true;
                  }
                  function maybeEatSelection(nullSafeNavigation) {
                    var token = peekToken();
                    if (!peekSelectToken()) {
                      return false;
                    }
                    nextToken();
                    var expr = eatExpression();
                    if (expr === null) {
                      raiseInternalException(toPosToken(token), 'MISSING_SELECTION_EXPRESSION');
                    }
                    eatToken(_TokenKind.TokenKind.RSQUARE);
                    if (token.getKind() === _TokenKind.TokenKind.SELECT_FIRST) {
                      push(_Selection.Selection.create(nullSafeNavigation, _Selection.Selection.FIRST, toPosToken(token), expr));
                    } else if (token.getKind() === _TokenKind.TokenKind.SELECT_LAST) {
                      push(_Selection.Selection.create(nullSafeNavigation, _Selection.Selection.LAST, toPosToken(token), expr));
                    } else {
                      push(_Selection.Selection.create(nullSafeNavigation, _Selection.Selection.ALL, toPosToken(token), expr));
                    }
                    return true;
                  }

                  /**
                   * Eat an identifier, possibly qualified (meaning that it is dotted).
                   * TODO AndyC Could create complete identifiers (a.b.c) here rather than a sequence of them? (a, b, c)
                   */
                  function eatPossiblyQualifiedId() {
                    var qualifiedIdPieces = [];
                    var node = peekToken();
                    while (isValidQualifiedId(node)) {
                      nextToken();
                      if (node.kind !== _TokenKind.TokenKind.DOT) {
                        qualifiedIdPieces.push(_Identifier.Identifier.create(node.stringValue(), toPosToken(node)));
                      }
                      node = peekToken();
                    }
                    if (!qualifiedIdPieces.length) {
                      if (node === null) {
                        raiseInternalException(expressionString.length(), 'OOD');
                      }
                      raiseInternalException(node.startPos, 'NOT_EXPECTED_TOKEN', 'qualified ID', node.getKind().toString().toLowerCase());
                    }
                    var pos = toPosBounds(qualifiedIdPieces[0].getStartPosition(), qualifiedIdPieces[qualifiedIdPieces.length - 1].getEndPosition());
                    return _QualifiedIdentifier.QualifiedIdentifier.create(pos, qualifiedIdPieces);
                  }
                  function isValidQualifiedId(node) {
                    if (node === null || node.kind === _TokenKind.TokenKind.LITERAL_STRING) {
                      return false;
                    }
                    if (node.kind === _TokenKind.TokenKind.DOT || node.kind === _TokenKind.TokenKind.IDENTIFIER) {
                      return true;
                    }
                    var value = node.stringValue();
                    return value && value.length && VALID_QUALIFIED_ID_PATTERN.test(value);
                  }

                  // This is complicated due to the support for dollars in identifiers.  Dollars are normally separate tokens but
                  // there we want to combine a series of identifiers and dollars into a single identifier
                  function maybeEatMethodOrProperty(nullSafeNavigation) {
                    if (peekTokenOne(_TokenKind.TokenKind.IDENTIFIER)) {
                      var methodOrPropertyName = nextToken();
                      var args = maybeEatMethodArgs();
                      if (args === null) {
                        // property
                        push(_PropertyReference.PropertyReference.create(nullSafeNavigation, methodOrPropertyName.stringValue(), toPosToken(methodOrPropertyName)));
                        return true;
                      }
                      // methodreference
                      push(_MethodReference.MethodReference.create(nullSafeNavigation, methodOrPropertyName.stringValue(), toPosToken(methodOrPropertyName), args));
                      // TODO what is the end position for a method reference? the name or the last arg?
                      return true;
                    }
                    return false;
                  }

                  //constructor
                  //:	('new' qualifiedId LPAREN) => 'new' qualifiedId ctorArgs -> ^(CONSTRUCTOR qualifiedId ctorArgs)
                  function maybeEatConstructorReference() {
                    if (peekIdentifierToken('new')) {
                      var newToken = nextToken();
                      // It looks like a constructor reference but is NEW being used as a map key?
                      if (peekTokenOne(_TokenKind.TokenKind.RSQUARE)) {
                        // looks like 'NEW]' (so NEW used as map key)
                        push(_PropertyReference.PropertyReference.create(newToken.stringValue(), toPosToken(newToken)));
                        return true;
                      }
                      var possiblyQualifiedConstructorName = eatPossiblyQualifiedId();
                      var nodes = [];
                      nodes.push(possiblyQualifiedConstructorName);
                      if (peekTokenOne(_TokenKind.TokenKind.LSQUARE)) {
                        // array initializer
                        var dimensions = [];
                        while (peekTokenConsumeIfMatched(_TokenKind.TokenKind.LSQUARE, true)) {
                          if (!peekTokenOne(_TokenKind.TokenKind.RSQUARE)) {
                            dimensions.push(eatExpression());
                          } else {
                            dimensions.push(null);
                          }
                          eatToken(_TokenKind.TokenKind.RSQUARE);
                        }
                        if (maybeEatInlineListOrMap()) {
                          nodes.push(pop());
                        }
                        push(_ConstructorReference.ConstructorReference.create(toPosToken(newToken), dimensions, nodes));
                      } else {
                        // regular constructor invocation
                        eatConstructorArgs(nodes);
                        // TODO correct end position?
                        push(_ConstructorReference.ConstructorReference.create(toPosToken(newToken), nodes));
                      }
                      return true;
                    }
                    return false;
                  }
                  function push(newNode) {
                    constructedNodes.push(newNode);
                  }
                  function pop() {
                    return constructedNodes.pop();
                  }

                  //	literal
                  //  : INTEGER_LITERAL
                  //	| boolLiteral
                  //	| STRING_LITERAL
                  //  | HEXADECIMAL_INTEGER_LITERAL
                  //  | REAL_LITERAL
                  //	| DQ_STRING_LITERAL
                  //	| NULL_LITERAL
                  function maybeEatLiteral() {
                    var token = peekToken();
                    if (token === null) {
                      return false;
                    }
                    if (token.getKind() === _TokenKind.TokenKind.LITERAL_INT || token.getKind() === _TokenKind.TokenKind.LITERAL_LONG) {
                      push(_NumberLiteral.NumberLiteral.create(parseInt(token.stringValue(), 10), toPosToken(token)));
                    } else if (token.getKind() === _TokenKind.TokenKind.LITERAL_REAL || token.getKind() === _TokenKind.TokenKind.LITERAL_REAL_FLOAT) {
                      push(_NumberLiteral.NumberLiteral.create(parseFloat(token.stringValue()), toPosToken(token)));
                    } else if (token.getKind() === _TokenKind.TokenKind.LITERAL_HEXINT || token.getKind() === _TokenKind.TokenKind.LITERAL_HEXLONG) {
                      push(_NumberLiteral.NumberLiteral.create(parseInt(token.stringValue(), 16), toPosToken(token)));
                    } else if (peekIdentifierToken('true')) {
                      push(_BooleanLiteral.BooleanLiteral.create(true, toPosToken(token)));
                    } else if (peekIdentifierToken('false')) {
                      push(_BooleanLiteral.BooleanLiteral.create(false, toPosToken(token)));
                    } else if (token.getKind() === _TokenKind.TokenKind.LITERAL_STRING) {
                      push(_StringLiteral.StringLiteral.create(token.stringValue(), toPosToken(token)));
                    } else {
                      return false;
                    }
                    nextToken();
                    return true;
                  }

                  //parenExpr : LPAREN! expression RPAREN!;
                  function maybeEatParenExpression() {
                    if (peekTokenOne(_TokenKind.TokenKind.LPAREN)) {
                      nextToken();
                      var expr = eatExpression();
                      eatToken(_TokenKind.TokenKind.RPAREN);
                      push(expr);
                      return true;
                    } else {
                      return false;
                    }
                  }

                  // relationalOperator
                  // : EQUAL | NOT_EQUAL | LESS_THAN | LESS_THAN_OR_EQUAL | GREATER_THAN
                  // | GREATER_THAN_OR_EQUAL | INSTANCEOF | BETWEEN | MATCHES
                  function maybeEatRelationalOperator() {
                    var token = peekToken();
                    if (token === null) {
                      return null;
                    }
                    if (token.isNumericRelationalOperator()) {
                      return token;
                    }
                    if (token.isIdentifier()) {
                      var idString = token.stringValue();
                      if (idString.toLowerCase() === 'instanceof') {
                        return token.asInstanceOfToken();
                      }
                      if (idString.toLowerCase() === 'matches') {
                        return token.asMatchesToken();
                      }
                      if (idString.toLowerCase() === 'between') {
                        return token.asBetweenToken();
                      }
                    }
                    return null;
                  }
                  function eatToken(expectedKind) {
                    var token = nextToken();
                    if (token === null) {
                      raiseInternalException(expressionString.length, 'OOD');
                    }
                    if (token.getKind() !== expectedKind) {
                      raiseInternalException(token.startPos, 'NOT_EXPECTED_TOKEN', expectedKind.toString().toLowerCase(), token.getKind().toString().toLowerCase());
                    }
                    return token;
                  }
                  function peekTokenOne(desiredTokenKind) {
                    return peekTokenConsumeIfMatched(desiredTokenKind, false);
                  }
                  function peekTokenConsumeIfMatched(desiredTokenKind, consumeIfMatched) {
                    if (!moreTokens()) {
                      return false;
                    }
                    var token = peekToken();
                    if (token.getKind() === desiredTokenKind) {
                      if (consumeIfMatched) {
                        tokenStreamPointer++;
                      }
                      return true;
                    }
                    if (desiredTokenKind === _TokenKind.TokenKind.IDENTIFIER) {
                      // might be one of the textual forms of the operators (e.g. NE for !== ) - in which case we can treat it as an identifier
                      // The list is represented here: Tokenizer.alternativeOperatorNames and those ones are in order in the TokenKind enum
                      if (token.getKind().ordinal() >= _TokenKind.TokenKind.DIV.ordinal() && token.getKind().ordinal() <= _TokenKind.TokenKind.NOT.ordinal() && token.data !== null) {
                        // if token.data were null, we'd know it wasn'token the textual form, it was the symbol form
                        return true;
                      }
                    }
                    return false;
                  }
                  function peekTokenAny() {
                    if (!moreTokens()) {
                      return false;
                    }
                    var token = peekToken();
                    var args = Array.prototype.slice.call(arguments);
                    for (var i = 0, l = args.length; i < l; i += 1) {
                      if (token.getKind() === args[i]) {
                        return true;
                      }
                    }
                    return false;
                  }
                  function peekIdentifierToken(identifierString) {
                    if (!moreTokens()) {
                      return false;
                    }
                    var token = peekToken();
                    return token.getKind() === _TokenKind.TokenKind.IDENTIFIER && token.stringValue().toLowerCase() === identifierString.toLowerCase();
                  }
                  function peekSelectToken() {
                    if (!moreTokens()) {
                      return false;
                    }
                    var token = peekToken();
                    return token.getKind() === _TokenKind.TokenKind.SELECT || token.getKind() === _TokenKind.TokenKind.SELECT_FIRST || token.getKind() === _TokenKind.TokenKind.SELECT_LAST;
                  }
                  function moreTokens() {
                    return tokenStreamPointer < tokenStream.length;
                  }
                  function nextToken() {
                    if (tokenStreamPointer >= tokenStreamLength) {
                      return null;
                    }
                    return tokenStream[tokenStreamPointer++];
                  }
                  function peekToken() {
                    if (tokenStreamPointer >= tokenStreamLength) {
                      return null;
                    }
                    return tokenStream[tokenStreamPointer];
                  }
                  function raiseInternalException(pos, message, expected, actual) {
                    if (expected) {
                      message += '\nExpected: ' + expected;
                    }
                    if (actual) {
                      message += '\nActual: ' + actual;
                    }
                    throw {
                      name: 'InternalParseException',
                      message: 'Error occurred while attempting to parse expression \'' + expressionString + '\' at position ' + pos + '. Message: ' + message
                    };
                  }
                  function toString(token) {
                    if (token.getKind().hasPayload()) {
                      return token.stringValue();
                    }
                    return token.getKind().toString().toLowerCase();
                  }
                  function checkOperands(token, left, right) {
                    checkLeftOperand(token, left);
                    checkRightOperand(token, right);
                  }
                  function checkLeftOperand(token, operandExpression) {
                    if (operandExpression === null) {
                      raiseInternalException(token.startPos, 'LEFT_OPERAND_PROBLEM');
                    }
                  }
                  function checkRightOperand(token, operandExpression) {
                    if (operandExpression === null) {
                      raiseInternalException(token.startPos, 'RIGHT_OPERAND_PROBLEM');
                    }
                  }

                  /**
                   * Compress the start and end of a token into a single int.
                   */
                  function toPosToken(token) {
                    return (token.startPos << 16) + token.endPos;
                  }
                  function toPosBounds(start, end) {
                    return (start << 16) + end;
                  }
                  return {
                    setConfiguration: setConfiguration,
                    parse: parse
                  };
                };

                //not yet implemented

                /***/
              }, /* 6 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.Tokenizer = undefined;
                var _Token = __webpack_require__(7);
                var _TokenKind = __webpack_require__(2);

                /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

                /**
                 * @author Andy Clement
                 * @author Phillip Webb
                 * @author Ben March
                 * @since 0.2.0
                 */

                var ALTERNATIVE_OPERATOR_NAMES = ['DIV', 'EQ', 'GE', 'GT', 'LE', 'LT', 'MOD', 'NE', 'NOT'],
                  FLAGS = [],
                  IS_DIGIT = 1,
                  IS_HEXDIGIT = 2,
                  IS_ALPHA = 4;
                function init() {
                  var ch;
                  for (ch = '0'.charCodeAt(0); ch <= '9'.charCodeAt(0); ch += 1) {
                    FLAGS[ch] |= IS_DIGIT | IS_HEXDIGIT;
                  }
                  for (ch = 'A'.charCodeAt(0); ch <= 'F'.charCodeAt(0); ch += 1) {
                    FLAGS[ch] |= IS_HEXDIGIT;
                  }
                  for (ch = 'a'.charCodeAt(0); ch <= 'f'.charCodeAt(0); ch += 1) {
                    FLAGS[ch] |= IS_HEXDIGIT;
                  }
                  for (ch = 'A'.charCodeAt(0); ch <= 'Z'.charCodeAt(0); ch += 1) {
                    FLAGS[ch] |= IS_ALPHA;
                  }
                  for (ch = 'a'.charCodeAt(0); ch <= 'z'.charCodeAt(0); ch += 1) {
                    FLAGS[ch] |= IS_ALPHA;
                  }
                }
                init();
                function tokenize(inputData) {
                  var expressionString = inputData,
                    toProcess = inputData + '\0',
                    max = toProcess.length,
                    pos = 0,
                    tokens = [];
                  function process() {
                    var ch;
                    while (pos < max) {
                      ch = toProcess[pos];
                      if (isAlphabetic(ch)) {
                        lexIdentifier();
                      } else {
                        switch (ch) {
                          case '+':
                            if (isTwoCharToken(_TokenKind.TokenKind.INC)) {
                              pushPairToken(_TokenKind.TokenKind.INC);
                            } else {
                              pushCharToken(_TokenKind.TokenKind.PLUS);
                            }
                            break;
                          case '_':
                            // the other way to start an identifier
                            lexIdentifier();
                            break;
                          case '-':
                            if (isTwoCharToken(_TokenKind.TokenKind.DEC)) {
                              pushPairToken(_TokenKind.TokenKind.DEC);
                            } else {
                              pushCharToken(_TokenKind.TokenKind.MINUS);
                            }
                            break;
                          case ':':
                            pushCharToken(_TokenKind.TokenKind.COLON);
                            break;
                          case '.':
                            pushCharToken(_TokenKind.TokenKind.DOT);
                            break;
                          case ',':
                            pushCharToken(_TokenKind.TokenKind.COMMA);
                            break;
                          case '*':
                            pushCharToken(_TokenKind.TokenKind.STAR);
                            break;
                          case '/':
                            pushCharToken(_TokenKind.TokenKind.DIV);
                            break;
                          case '%':
                            pushCharToken(_TokenKind.TokenKind.MOD);
                            break;
                          case '(':
                            pushCharToken(_TokenKind.TokenKind.LPAREN);
                            break;
                          case ')':
                            pushCharToken(_TokenKind.TokenKind.RPAREN);
                            break;
                          case '[':
                            pushCharToken(_TokenKind.TokenKind.LSQUARE);
                            break;
                          case '#':
                            pushCharToken(_TokenKind.TokenKind.HASH);
                            break;
                          case ']':
                            pushCharToken(_TokenKind.TokenKind.RSQUARE);
                            break;
                          case '{':
                            pushCharToken(_TokenKind.TokenKind.LCURLY);
                            break;
                          case '}':
                            pushCharToken(_TokenKind.TokenKind.RCURLY);
                            break;
                          case '@':
                            pushCharToken(_TokenKind.TokenKind.BEAN_REF);
                            break;
                          case '^':
                            if (isTwoCharToken(_TokenKind.TokenKind.SELECT_FIRST)) {
                              pushPairToken(_TokenKind.TokenKind.SELECT_FIRST);
                            } else {
                              pushCharToken(_TokenKind.TokenKind.POWER);
                            }
                            break;
                          case '!':
                            if (isTwoCharToken(_TokenKind.TokenKind.NE)) {
                              pushPairToken(_TokenKind.TokenKind.NE);
                            } else if (isTwoCharToken(_TokenKind.TokenKind.PROJECT)) {
                              pushPairToken(_TokenKind.TokenKind.PROJECT);
                            } else {
                              pushCharToken(_TokenKind.TokenKind.NOT);
                            }
                            break;
                          case '=':
                            if (isTwoCharToken(_TokenKind.TokenKind.EQ)) {
                              pushPairToken(_TokenKind.TokenKind.EQ);
                            } else {
                              pushCharToken(_TokenKind.TokenKind.ASSIGN);
                            }
                            break;
                          case '&':
                            if (!isTwoCharToken(_TokenKind.TokenKind.SYMBOLIC_AND)) {
                              throw {
                                name: 'SpelParseException',
                                message: 'Missing character \'&\' in expression (' + expressionString + ') at position ' + pos
                              };
                            }
                            pushPairToken(_TokenKind.TokenKind.SYMBOLIC_AND);
                            break;
                          case '|':
                            if (!isTwoCharToken(_TokenKind.TokenKind.SYMBOLIC_OR)) {
                              throw {
                                name: 'SpelParseException',
                                message: 'Missing character \'|\' in expression (' + expressionString + ') at position ' + pos
                              };
                            }
                            pushPairToken(_TokenKind.TokenKind.SYMBOLIC_OR);
                            break;
                          case '?':
                            if (isTwoCharToken(_TokenKind.TokenKind.SELECT)) {
                              pushPairToken(_TokenKind.TokenKind.SELECT);
                            } else if (isTwoCharToken(_TokenKind.TokenKind.ELVIS)) {
                              pushPairToken(_TokenKind.TokenKind.ELVIS);
                            } else if (isTwoCharToken(_TokenKind.TokenKind.SAFE_NAVI)) {
                              pushPairToken(_TokenKind.TokenKind.SAFE_NAVI);
                            } else {
                              pushCharToken(_TokenKind.TokenKind.QMARK);
                            }
                            break;
                          case '$':
                            if (isTwoCharToken(_TokenKind.TokenKind.SELECT_LAST)) {
                              pushPairToken(_TokenKind.TokenKind.SELECT_LAST);
                            } else {
                              lexIdentifier();
                            }
                            break;
                          case '>':
                            if (isTwoCharToken(_TokenKind.TokenKind.GE)) {
                              pushPairToken(_TokenKind.TokenKind.GE);
                            } else {
                              pushCharToken(_TokenKind.TokenKind.GT);
                            }
                            break;
                          case '<':
                            if (isTwoCharToken(_TokenKind.TokenKind.LE)) {
                              pushPairToken(_TokenKind.TokenKind.LE);
                            } else {
                              pushCharToken(_TokenKind.TokenKind.LT);
                            }
                            break;
                          case '0':
                          case '1':
                          case '2':
                          case '3':
                          case '4':
                          case '5':
                          case '6':
                          case '7':
                          case '8':
                          case '9':
                            lexNumericLiteral(ch === '0');
                            break;
                          case ' ':
                          case '\t':
                          case '\r':
                          case '\n':
                            // drift over white space
                            pos += 1;
                            break;
                          case '\'':
                            lexQuotedStringLiteral();
                            break;
                          case '"':
                            lexDoubleQuotedStringLiteral();
                            break;
                          case '\0':
                            // hit sentinel at end of value
                            pos += 1; // will take us to the end
                            break;
                          case '\\':
                            throw {
                              name: 'SpelParseException',
                              message: 'Unexpected escape character in expression (' + expressionString + ') at position ' + pos
                            };
                          default:
                            throw {
                              name: 'SpelParseException',
                              message: 'Cannot handle character \'' + ch + '\' in expression (' + expressionString + ') at position ' + pos
                            };
                        }
                      }
                    }
                  }
                  function lexQuotedStringLiteral() {
                    var start = pos,
                      terminated = false,
                      ch;
                    while (!terminated) {
                      pos += 1;
                      ch = toProcess[pos];
                      if (ch === '\'') {
                        // may not be the end if the char after is also a '
                        if (toProcess[pos + 1] === '\'') {
                          pos += 1; // skip over that too, and continue
                        } else {
                          terminated = true;
                        }
                      }
                      if (ch.charCodeAt(0) === 0) {
                        throw {
                          name: 'SpelParseException',
                          message: 'Non-terminating quoted string in expression (' + expressionString + ') at position ' + pos
                        };
                      }
                    }
                    pos += 1;
                    tokens.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_STRING, subarray(start, pos), start, pos));
                  }
                  function lexDoubleQuotedStringLiteral() {
                    var start = pos,
                      terminated = false,
                      ch;
                    while (!terminated) {
                      pos += 1;
                      ch = toProcess[pos];
                      if (ch === '"') {
                        // may not be the end if the char after is also a '
                        if (toProcess[pos + 1] === '"') {
                          pos += 1; // skip over that too, and continue
                        } else {
                          terminated = true;
                        }
                      }
                      if (ch.charCodeAt(0) === 0) {
                        throw {
                          name: 'SpelParseException',
                          message: 'Non-terminating double-quoted string in expression (' + expressionString + ') at position ' + pos
                        };
                      }
                    }
                    pos += 1;
                    tokens.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_STRING, subarray(start, pos), start, pos));
                  }

                  // REAL_LITERAL :
                  // ('.' (DECIMAL_DIGIT)+ (EXPONENT_PART)? (REAL_TYPE_SUFFIX)?) |
                  // ((DECIMAL_DIGIT)+ '.' (DECIMAL_DIGIT)+ (EXPONENT_PART)? (REAL_TYPE_SUFFIX)?) |
                  // ((DECIMAL_DIGIT)+ (EXPONENT_PART) (REAL_TYPE_SUFFIX)?) |
                  // ((DECIMAL_DIGIT)+ (REAL_TYPE_SUFFIX));
                  // fragment INTEGER_TYPE_SUFFIX : ( 'L' | 'l' );
                  // fragment HEX_DIGIT :
                  // '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|'A'|'B'|'C'|'D'|'E'|'F'|'a'|'b'|'c'|'d'|'e'|'f';
                  //
                  // fragment EXPONENT_PART : 'e' (SIGN)* (DECIMAL_DIGIT)+ | 'E' (SIGN)*
                  // (DECIMAL_DIGIT)+ ;
                  // fragment SIGN : '+' | '-' ;
                  // fragment REAL_TYPE_SUFFIX : 'F' | 'f' | 'D' | 'd';
                  // INTEGER_LITERAL
                  // : (DECIMAL_DIGIT)+ (INTEGER_TYPE_SUFFIX)?;

                  function lexNumericLiteral(firstCharIsZero) {
                    var isReal = false,
                      start = pos,
                      ch = toProcess[pos + 1],
                      isHex = ch === 'x' || ch === 'X',
                      dotpos,
                      endOfNumber,
                      possibleSign,
                      isFloat;

                    // deal with hexadecimal
                    if (firstCharIsZero && isHex) {
                      pos = pos + 1;
                      do {
                        pos += 1;
                      } while (isHexadecimalDigit(toProcess[pos]));
                      if (isChar('L', 'l')) {
                        pushHexIntToken(subarray(start + 2, pos), true, start, pos);
                        pos += 1;
                      } else {
                        pushHexIntToken(subarray(start + 2, pos), false, start, pos);
                      }
                      return;
                    }

                    // real numbers must have leading digits

                    // Consume first part of number
                    do {
                      pos += 1;
                    } while (isDigit(toProcess[pos]));

                    // a '.' indicates this number is a real
                    ch = toProcess[pos];
                    if (ch === '.') {
                      isReal = true;
                      dotpos = pos;
                      // carry on consuming digits
                      do {
                        pos += 1;
                      } while (isDigit(toProcess[pos]));
                      if (pos === dotpos + 1) {
                        // the number is something like '3.'. It is really an int but may be
                        // part of something like '3.toString()'. In this case process it as
                        // an int and leave the dot as a separate token.
                        pos = dotpos;
                        pushIntToken(subarray(start, pos), false, start, pos);
                        return;
                      }
                    }
                    endOfNumber = pos;

                    // Now there may or may not be an exponent

                    // is it a long ?
                    if (isChar('L', 'l')) {
                      if (isReal) {
                        // 3.4L - not allowed
                        throw {
                          name: 'SpelParseException',
                          message: 'Real cannot be long in expression (' + expressionString + ') at position ' + pos
                        };
                      }
                      pushIntToken(subarray(start, endOfNumber), true, start, endOfNumber);
                      pos += 1;
                    } else if (isExponentChar(toProcess[pos])) {
                      isReal = true; // if it wasn't before, it is now
                      pos += 1;
                      possibleSign = toProcess[pos];
                      if (isSign(possibleSign)) {
                        pos += 1;
                      }

                      // exponent digits
                      do {
                        pos += 1;
                      } while (isDigit(toProcess[pos]));
                      isFloat = false;
                      if (isFloatSuffix(toProcess[pos])) {
                        isFloat = true;
                        pos += 1;
                        endOfNumber = pos;
                      } else if (isDoubleSuffix(toProcess[pos])) {
                        pos += 1;
                        endOfNumber = pos;
                      }
                      pushRealToken(subarray(start, pos), isFloat, start, pos);
                    } else {
                      ch = toProcess[pos];
                      isFloat = false;
                      if (isFloatSuffix(ch)) {
                        isReal = true;
                        isFloat = true;
                        pos += 1;
                        endOfNumber = pos;
                      } else if (isDoubleSuffix(ch)) {
                        isReal = true;
                        pos += 1;
                        endOfNumber = pos;
                      }
                      if (isReal) {
                        pushRealToken(subarray(start, endOfNumber), isFloat, start, endOfNumber);
                      } else {
                        pushIntToken(subarray(start, endOfNumber), false, start, endOfNumber);
                      }
                    }
                  }
                  function lexIdentifier() {
                    var start = pos,
                      substring,
                      asString,
                      idx;
                    do {
                      pos += 1;
                    } while (isIdentifier(toProcess[pos]));
                    substring = subarray(start, pos);

                    // Check if this is the alternative (textual) representation of an operator (see
                    // alternativeOperatorNames)
                    if (pos - start === 2 || pos - start === 3) {
                      asString = substring.toUpperCase();
                      idx = ALTERNATIVE_OPERATOR_NAMES.indexOf(asString);
                      if (idx >= 0) {
                        pushOneCharOrTwoCharToken(_TokenKind.TokenKind.valueOf(asString), start, substring);
                        return;
                      }
                    }
                    tokens.push(new _Token.Token(_TokenKind.TokenKind.IDENTIFIER, substring.replace('\0', ''), start, pos));
                  }
                  function pushIntToken(data, isLong, start, end) {
                    if (isLong) {
                      tokens.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_LONG, data, start, end));
                    } else {
                      tokens.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_INT, data, start, end));
                    }
                  }
                  function pushHexIntToken(data, isLong, start, end) {
                    if (data.length === 0) {
                      if (isLong) {
                        throw {
                          name: 'SpelParseException',
                          message: 'Not a long in expression (' + expressionString + ') at position ' + pos
                        };
                      } else {
                        throw {
                          name: 'SpelParseException',
                          message: 'Not an int in expression (' + expressionString + ') at position ' + pos
                        };
                      }
                    }
                    if (isLong) {
                      tokens.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_HEXLONG, data, start, end));
                    } else {
                      tokens.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_HEXINT, data, start, end));
                    }
                  }
                  function pushRealToken(data, isFloat, start, end) {
                    if (isFloat) {
                      tokens.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_REAL_FLOAT, data, start, end));
                    } else {
                      tokens.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_REAL, data, start, end));
                    }
                  }
                  function subarray(start, end) {
                    return toProcess.substring(start, end);
                  }

                  /**
                   * Check if this might be a two character token.
                   */
                  function isTwoCharToken(kind) {
                    if (kind.tokenChars.length === 2 && toProcess[pos] === kind.tokenChars[0]) {
                      return toProcess[pos + 1] === kind.tokenChars[1];
                    }
                    return false;
                  }

                  /**
                   * Push a token of just one character in length.
                   */
                  function pushCharToken(kind) {
                    tokens.push(new _Token.Token(kind, null, pos, pos + 1));
                    pos += 1;
                  }

                  /**
                   * Push a token of two characters in length.
                   */
                  function pushPairToken(kind) {
                    tokens.push(new _Token.Token(kind, null, pos, pos + 2));
                    pos += 2;
                  }
                  function pushOneCharOrTwoCharToken(kind, pos, data) {
                    tokens.push(new _Token.Token(kind, data, pos, pos + kind.getLength()));
                  }

                  // ID: ('a'..'z'|'A'..'Z'|'_'|'$') ('a'..'z'|'A'..'Z'|'_'|'$'|'0'..'9'|DOT_ESCAPED)*;
                  function isIdentifier(ch) {
                    return isAlphabetic(ch) || isDigit(ch) || ch === '_' || ch === '$';
                  }
                  function isChar(a, b) {
                    var ch = toProcess[pos];
                    return ch === a || ch === b;
                  }
                  function isExponentChar(ch) {
                    return ch === 'e' || ch === 'E';
                  }
                  function isFloatSuffix(ch) {
                    return ch === 'f' || ch === 'F';
                  }
                  function isDoubleSuffix(ch) {
                    return ch === 'd' || ch === 'D';
                  }
                  function isSign(ch) {
                    return ch === '+' || ch === '-';
                  }
                  function isDigit(ch) {
                    if (ch.charCodeAt(0) > 255) {
                      return false;
                    }
                    return (FLAGS[ch.charCodeAt(0)] & IS_DIGIT) !== 0;
                  }
                  function isAlphabetic(ch) {
                    if (ch.charCodeAt(0) > 255) {
                      return false;
                    }
                    return (FLAGS[ch.charCodeAt(0)] & IS_ALPHA) !== 0;
                  }
                  function isHexadecimalDigit(ch) {
                    if (ch.charCodeAt(0) > 255) {
                      return false;
                    }
                    return (FLAGS[ch.charCodeAt(0)] & IS_HEXDIGIT) !== 0;
                  }
                  process();
                  return tokens;
                }
                exports.Tokenizer = {
                  tokenize: tokenize
                };

                /***/
              }, /* 7 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.Token = undefined;
                var _TokenKind = __webpack_require__(2);
                function Token(tokenKind, tokenData, startPos, endPos) {
                  this.kind = tokenKind;
                  this.startPos = startPos;
                  this.endPos = endPos;
                  if (tokenData) {
                    this.data = tokenData;
                  }
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                /**
                 * @author Andy Clement
                 * @author Ben March
                 * @since 0.2.0
                 */

                Token.prototype.getKind = function () {
                  return this.kind;
                };
                Token.prototype.toString = function () {
                  var s = '[';
                  s += this.kind.toString();
                  if (this.kind.hasPayload()) {
                    s += ':' + this.data;
                  }
                  s += ']';
                  s += '(' + this.startPos + ',' + this.endPos + ')';
                  return s;
                };
                Token.prototype.isIdentifier = function () {
                  return this.kind === _TokenKind.TokenKind.IDENTIFIER;
                };
                Token.prototype.isNumericRelationalOperator = function () {
                  return this.kind === _TokenKind.TokenKind.GT || this.kind === _TokenKind.TokenKind.GE || this.kind === _TokenKind.TokenKind.LT || this.kind === _TokenKind.TokenKind.LE || this.kind === _TokenKind.TokenKind.EQ || this.kind === _TokenKind.TokenKind.NE;
                };
                Token.prototype.stringValue = function () {
                  return this.data;
                };
                Token.prototype.asInstanceOfToken = function () {
                  return new Token(_TokenKind.TokenKind.INSTANCEOF, this.startPos, this.endPos);
                };
                Token.prototype.asMatchesToken = function () {
                  return new Token(_TokenKind.TokenKind.MATCHES, this.startPos, this.endPos);
                };
                Token.prototype.asBetweenToken = function () {
                  return new Token(_TokenKind.TokenKind.BETWEEN, this.startPos, this.endPos);
                };
                Token.prototype.getStartPosition = function () {
                  return this.startPos;
                };
                Token.prototype.getEndPosition = function () {
                  return this.endPos;
                };
                exports.Token = Token;

                /***/
              }, /* 8 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.BooleanLiteral = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Represents the literal values TRUE and FALSE.
                 *
                 * @author Andy Clement
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(value, position) {
                  var node = _SpelNode.SpelNode.create('boolean', position);
                  node.getValue = function () {
                    return value;
                  };
                  node.setValue = function (newValue) {
                    /*jshint -W093 */
                    return value = newValue;
                    /*jshint +W093 */
                  };

                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.BooleanLiteral = {
                  create: createNode
                };

                /***/
              }, /* 9 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.NumberLiteral = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Expression language AST node that represents a literal number of any kind (since JavaScript only supports doubles anyway)
                 *
                 * @author Andy Clement
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(value, position) {
                  var node = _SpelNode.SpelNode.create('number', position);
                  node.getValue = function () {
                    return value;
                  };
                  node.setValue = function (newValue) {
                    /*jshint -W093 */
                    return value = newValue;
                    /*jshint +W093 */
                  };

                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.NumberLiteral = {
                  create: createNode
                };

                /***/
              }, /* 10 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.StringLiteral = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Expression language AST node that represents a string literal.
                 *
                 * @author Andy Clement
                 * @author Juergen Hoeller
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(value, position) {
                  var node = _SpelNode.SpelNode.create('string', position);
                  function stripQuotes(value) {
                    if (value[0] === '\'' && value[value.length - 1] === '\'' || value[0] === '"' && value[value.length - 1] === '"') {
                      value = value.substring(1, value.length - 1);
                    }
                    return value.replace(/''/g, '\'').replace(/""/g, '"');
                  }

                  //value cannot be null so no check
                  value = stripQuotes(value);
                  node.getValue = function () {
                    return value;
                  };
                  node.setValue = function (newValue) {
                    /*jshint -W093 */
                    return value = newValue;
                    /*jshint +W093 */
                  };

                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.StringLiteral = {
                  create: createNode
                };

                /***/
              }, /* 11 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.NullLiteral = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Expression language AST node that represents null.
                 *
                 * @author Andy Clement
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(value, position) {
                  var node = _SpelNode.SpelNode.create('null', position);
                  node.getValue = function () {
                    return null;
                  };
                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.NullLiteral = {
                  create: createNode
                };

                /***/
              }, /* 12 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.FunctionReference = undefined;
                var _SpelNode = __webpack_require__(0);
                var _Stack = __webpack_require__(1);

                /**
                 * A function reference is of the form "#someFunction(a,b,c)". Functions may be defined in
                 * the context prior to the expression being evaluated or within the expression itself
                 * using a lambda function definition. For example: Lambda function definition in an
                 * expression: "(#max = {|x,y|$x>$y?$x:$y};max(2,3))" Calling context defined function:
                 * "#isEven(37)". Functions may also be static java methods, registered in the context
                 * prior to invocation of the expression.
                 *
                 * <p>Functions are very simplistic, the arguments are not part of the definition (right
                 * now), so the names must be unique.
                 *
                 * @author Andy Clement
                 * @author Ben March
                 * @since 0.2.0
                 */

                /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

                function createNode(functionName, position, args) {
                  var node = _SpelNode.SpelNode.create('function', position);
                  node.getRaw = function () {
                    return {
                      functionName: functionName,
                      args: args
                    };
                  };
                  node.getValue = function (state) {
                    var locals = state.locals || {},
                      context = state.rootContext,
                      compiledArgs = [];

                    //populate arguments
                    args.forEach(function (arg) {
                      // reset the active context to root context for evaluating argument
                      var currentActiveContext = state.activeContext;
                      state.activeContext = new _Stack.Stack();
                      state.activeContext.push(state.rootContext);

                      // evaluate argument
                      compiledArgs.push(arg.getValue(state));

                      // reset the active context
                      state.activeContext = currentActiveContext;
                    });
                    if (locals[functionName]) {
                      return locals[functionName].apply(context, compiledArgs);
                    }
                    throw {
                      name: 'FunctionDoesNotExistException',
                      message: 'Function \'' + functionName + '\' does not exist.'
                    };
                  };
                  return node;
                }
                exports.FunctionReference = {
                  create: createNode
                };

                /***/
              }, /* 13 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.MethodReference = undefined;
                var _SpelNode = __webpack_require__(0);
                var _Stack = __webpack_require__(1);

                /**
                 * Expression language AST node that represents a method reference.
                 *
                 * @author Andy Clement
                 * @author Juergen Hoeller
                 * @author Ben March
                 * @since 0.2.0
                 */

                /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

                function createNode(nullSafeNavigation, methodName, position, args) {
                  var node = _SpelNode.SpelNode.create('method', position);
                  node.getRaw = function () {
                    return {
                      methodName: methodName,
                      args: args
                    };
                  };
                  node.getValue = function (state) {
                    var context = state.activeContext.peek(),
                      compiledArgs = [],
                      method;
                    if (!context) {
                      throw {
                        name: 'ContextDoesNotExistException',
                        message: 'Attempting to look up property \'' + methodName + '\' for an undefined context.'
                      };
                    }

                    //handle safe navigation
                    function maybeHandleNullSafeNavigation(member) {
                      if (member === undefined || member === null) {
                        if (nullSafeNavigation) {
                          return null;
                        }
                        throw {
                          name: 'NullPointerException',
                          message: 'Method ' + methodName + ' does not exist.'
                        };
                      }
                      return member;
                    }

                    //populate arguments
                    args.forEach(function (arg) {
                      // reset the active context to root context for evaluating argument
                      var currentActiveContext = state.activeContext;
                      state.activeContext = new _Stack.Stack();
                      state.activeContext.push(state.rootContext);

                      // evaluate argument
                      compiledArgs.push(arg.getValue(state));

                      // reset the active context
                      state.activeContext = currentActiveContext;
                    });

                    //accessors might not be available
                    if (methodName.substr(0, 3) === 'get' && !context[methodName]) {
                      return maybeHandleNullSafeNavigation(context[methodName.charAt(3).toLowerCase() + methodName.substring(4)]);
                    }
                    if (methodName.substr(0, 3) === 'set' && !context[methodName]) {
                      /*jshint -W093 */
                      return context[methodName.charAt(3).toLowerCase() + methodName.substring(4)] = compiledArgs[0];
                      /*jshint +W093 */
                    }

                    //array methods
                    if (Array.isArray(context)) {
                      //size() -> length
                      if (methodName === 'size') {
                        return context.length;
                      }
                      if (methodName === 'contains') {
                        return context.includes(compiledArgs[0]);
                      }
                    }
                    method = maybeHandleNullSafeNavigation(context[methodName]);
                    if (method) {
                      return method.apply(context, compiledArgs);
                    }
                    return null;
                  };
                  return node;
                }
                exports.MethodReference = {
                  create: createNode
                };

                /***/
              }, /* 14 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.PropertyReference = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Represents a simple property or field reference.
                 *
                 * @author Andy Clement
                 * @author Juergen Hoeller
                 * @author Clark Duplichien
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(nullSafeNavigation, propertyName, position) {
                  var node = _SpelNode.SpelNode.create('property', position);
                  node.getRaw = function () {
                    return propertyName;
                  };
                  node.getValue = function (state) {
                    var context = state.activeContext.peek();
                    if (!context) {
                      if (nullSafeNavigation) {
                        return null;
                      }
                      throw {
                        name: 'ContextDoesNotExistException',
                        message: 'Attempting to look up property \'' + propertyName + '\' for an undefined context.'
                      };
                    }
                    if (context[propertyName] === undefined || context[propertyName] === null) {
                      //handle safe navigation
                      if (nullSafeNavigation) {
                        return null;
                      }

                      //handle conversion of Java properties to JavaScript properties
                      if (propertyName === 'size' && Array.isArray(context)) {
                        return context.length;
                      }
                      throw {
                        name: 'NullPointerException',
                        message: 'Property \'' + propertyName + '\' does not exist.'
                      };
                    }
                    return context[propertyName];
                  };
                  node.setValue = function (value, state) {
                    var context = state.activeContext.peek();
                    if (!context) {
                      throw {
                        name: 'ContextDoesNotExistException',
                        message: 'Attempting to assign property \'' + propertyName + '\' for an undefined context.'
                      };
                    }

                    /*jshint -W093 */
                    return context[propertyName] = value;
                    /*jshint +W093 */
                  };

                  node.getName = function () {
                    return propertyName;
                  };
                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.PropertyReference = {
                  create: createNode
                };

                /***/
              }, /* 15 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.VariableReference = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Represents a variable reference, eg. #someVar. Note this is different to a *local*
                 * variable like $someVar
                 *
                 * @author Andy Clement
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(variableName, position) {
                  var node = _SpelNode.SpelNode.create('variable', position);
                  node.getRaw = function () {
                    return variableName;
                  };
                  node.getValue = function (state) {
                    var context = state.activeContext.peek(),
                      locals = state.locals;
                    if (!context) {
                      throw {
                        name: 'ContextDoesNotExistException',
                        message: 'Attempting to look up variable \'' + variableName + '\' for an undefined context.'
                      };
                    }

                    //there are 2 keywords (root, this) that need to be dealt with
                    if (variableName === 'this') {
                      return context;
                    }
                    if (variableName === 'root') {
                      return state.rootContext;
                    }
                    return locals[variableName];
                  };
                  node.setValue = function (value, state) {
                    var locals = state.locals;

                    /*jshint -W093 */
                    return locals[variableName] = value;
                    /*jshint +W093 */
                  };

                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.VariableReference = {
                  create: createNode
                };

                /***/
              }, /* 16 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.CompoundExpression = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Represents a DOT separated expression sequence, such as 'property1.property2.methodOne()'
                 *
                 * @author Andy Clement
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(position, expressionComponents) {
                  var node = _SpelNode.SpelNode.create.apply(null, ['compound', position].concat(expressionComponents));
                  function buildContextStack(state) {
                    var childrenCount = node.getChildren().length,
                      i;
                    for (i = 0; i < childrenCount; i += 1) {
                      if (node.getChildren()[i].getType() === 'indexer') {
                        state.activeContext.push(state.activeContext.peek()[node.getChildren()[i].getValue(state)]);
                      } else {
                        state.activeContext.push(node.getChildren()[i].getValue(state));
                      }
                    }
                    return function unbuildContextStack() {
                      for (i = 0; i < childrenCount; i += 1) {
                        state.activeContext.pop();
                      }
                    };
                  }
                  node.getValue = function (state) {
                    var context = state.activeContext.peek(),
                      value;
                    if (!context) {
                      throw {
                        name: 'ContextDoesNotExistException',
                        message: 'Attempting to evaluate compound expression with an undefined context.'
                      };
                    }
                    var unbuildContextStack = buildContextStack(state);
                    value = state.activeContext.peek();
                    unbuildContextStack();
                    return value;
                  };
                  node.setValue = function (value, state) {
                    var unbuildContextStack = buildContextStack(state),
                      childCount = node.getChildren().length;
                    state.activeContext.pop();
                    value = node.getChildren()[childCount - 1].setValue(value, state);
                    state.activeContext.push(null);
                    unbuildContextStack();
                    return value;
                  };
                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.CompoundExpression = {
                  create: createNode
                };

                /***/
              }, /* 17 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.Indexer = undefined;
                var _SpelNode = __webpack_require__(0);
                var _Stack = __webpack_require__(1);

                /**
                 * An Indexer can index into some proceeding structure to access a particular piece of it.
                 * Supported structures are: strings / collections (lists/sets) / arrays.
                 *
                 * @author Andy Clement
                 * @author Phillip Webb
                 * @author Stephane Nicoll
                 * @author Ben March
                 * @since 0.2.0
                 */

                /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

                function createNode(position, expressionComponents) {
                  var node = _SpelNode.SpelNode.create.apply(null, ['indexer', position].concat(expressionComponents));
                  node.getValue = function (state) {
                    var activeContext = state.activeContext,
                      context,
                      childrenCount = node.getChildren().length,
                      i,
                      value;
                    state.activeContext = new _Stack.Stack();
                    state.activeContext.push(state.rootContext);
                    context = state.activeContext.peek();
                    if (!context) {
                      throw {
                        name: 'ContextDoesNotExistException',
                        message: 'Attempting to evaluate compound expression with an undefined context.'
                      };
                    }
                    for (i = 0; i < childrenCount; i += 1) {
                      state.activeContext.push(node.getChildren()[i].getValue(state));
                    }
                    value = state.activeContext.peek();
                    for (i = 0; i < childrenCount; i += 1) {
                      state.activeContext.pop();
                    }
                    state.activeContext = activeContext;
                    return value;
                  };

                  //node.setContext(node.getValue());

                  return node;
                }
                exports.Indexer = {
                  create: createNode
                };

                /***/
              }, /* 18 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.Assign = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Represents assignment. An alternative to calling setValue() for an expression is to use
                 * an assign.
                 *
                 * <p>Example: 'someNumberProperty=42'
                 *
                 * @author Andy Clement
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(position, property, assignedValue) {
                  var node = _SpelNode.SpelNode.create('assign', position, property, assignedValue);
                  node.getValue = function (state) {
                    var context = state.activeContext.peek();
                    if (!context) {
                      throw {
                        name: 'ContextDoesNotExistException',
                        message: 'Attempting to assign property \'' + property.getValue(state) + '\' for an undefined context.'
                      };
                    }
                    return property.setValue(assignedValue.getValue(state), state);
                  };
                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.Assign = {
                  create: createNode
                };

                /***/
              }, /* 19 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.OpEQ = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Implements the equality operator.
                 *
                 * @author Andy Clement
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(position, left, right) {
                  var node = _SpelNode.SpelNode.create('op-eq', position, left, right);
                  node.getValue = function (state) {
                    return left.getValue(state) === right.getValue(state);
                  };
                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.OpEQ = {
                  create: createNode
                };

                /***/
              }, /* 20 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.OpNE = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Implements the not-equal operator.
                 *
                 * @author Andy Clement
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(position, left, right) {
                  var node = _SpelNode.SpelNode.create('op-ne', position, left, right);
                  node.getValue = function (state) {
                    return left.getValue(state) !== right.getValue(state);
                  };
                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.OpNE = {
                  create: createNode
                };

                /***/
              }, /* 21 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.OpGE = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Implements greater-than-or-equal operator.
                 *
                 * @author Andy Clement
                 * @author Juergen Hoeller
                 * @author Giovanni Dall'Oglio Risso
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(position, left, right) {
                  var node = _SpelNode.SpelNode.create('op-ge', position, left, right);
                  node.getValue = function (state) {
                    return left.getValue(state) >= right.getValue(state);
                  };
                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.OpGE = {
                  create: createNode
                };

                /***/
              }, /* 22 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.OpGT = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Implements the greater-than operator.
                 *
                 * @author Andy Clement
                 * @author Juergen Hoeller
                 * @author Giovanni Dall'Oglio Risso
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(position, left, right) {
                  var node = _SpelNode.SpelNode.create('op-gt', position, left, right);
                  node.getValue = function (state) {
                    return left.getValue(state) > right.getValue(state);
                  };
                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.OpGT = {
                  create: createNode
                };

                /***/
              }, /* 23 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.OpLE = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Implements the less-than-or-equal operator.
                 *
                 * @author Andy Clement
                 * @author Juergen Hoeller
                 * @author Giovanni Dall'Oglio Risso
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(position, left, right) {
                  var node = _SpelNode.SpelNode.create('op-le', position, left, right);
                  node.getValue = function (state) {
                    return left.getValue(state) <= right.getValue(state);
                  };
                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.OpLE = {
                  create: createNode
                };

                /***/
              }, /* 24 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.OpLT = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Implements the less-than operator.
                 *
                 * @author Andy Clement
                 * @author Juergen Hoeller
                 * @author Giovanni Dall'Oglio Risso
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(position, left, right) {
                  var node = _SpelNode.SpelNode.create('op-lt', position, left, right);
                  node.getValue = function (state) {
                    return left.getValue(state) < right.getValue(state);
                  };
                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.OpLT = {
                  create: createNode
                };

                /***/
              }, /* 25 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.OpPlus = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * The plus operator will:
                 * <ul>
                 * <li>add numbers
                 * <li>concatenate strings
                 * </ul>
                 *
                 * <p>It can be used as a unary operator for numbers.
                 * The standard promotions are performed when the operand types vary (double+int=double).
                 * For other options it defers to the registered overloader.
                 *
                 * @author Andy Clement
                 * @author Juergen Hoeller
                 * @author Ivo Smid
                 * @author Giovanni Dall'Oglio Risso
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(position, left, right) {
                  var node = _SpelNode.SpelNode.create('op-plus', position, left, right);
                  node.getValue = function (state) {
                    if (!right) {
                      return +left.getValue(state);
                    }
                    //javascript will handle string concatenation or addition depending on types
                    return left.getValue(state) + right.getValue(state);
                  };
                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.OpPlus = {
                  create: createNode
                };

                /***/
              }, /* 26 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.OpMinus = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * The minus operator supports:
                 * <ul>
                 * <li>subtraction of numbers
                 * <li>subtraction of an int from a string of one character
                 * (effectively decreasing that character), so 'd'-3='a'
                 * </ul>
                 *
                 * <p>It can be used as a unary operator for numbers.
                 * The standard promotions are performed when the operand types vary (double-int=double).
                 * For other options it defers to the registered overloader.
                 *
                 * @author Andy Clement
                 * @author Juergen Hoeller
                 * @author Giovanni Dall'Oglio Risso
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(position, left, right) {
                  var node = _SpelNode.SpelNode.create('op-minus', position, left, right);
                  node.getValue = function (state) {
                    if (!right) {
                      return -left.getValue(state);
                    }
                    return left.getValue(state) - right.getValue(state);
                  };
                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.OpMinus = {
                  create: createNode
                };

                /***/
              }, /* 27 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.OpMultiply = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Implements the {@code multiply} operator.
                 *
                 * <p>Conversions and promotions are handled as defined in
                 * <a href="http://java.sun.com/docs/books/jls/third_edition/html/conversions.html">Section 5.6.2 of the
                 * Java Language Specification</a>, with the addiction of {@code BigDecimal}/{@code BigInteger} management:
                 *
                 * <p>If any of the operands is of a reference type, unboxing conversion (Section 5.1.8)
                 * is performed. Then:<br>
                 * If either operand is of type {@code BigDecimal}, the other is converted to {@code BigDecimal}.<br>
                 * If either operand is of type double, the other is converted to double.<br>
                 * Otherwise, if either operand is of type float, the other is converted to float.<br>
                 * If either operand is of type {@code BigInteger}, the other is converted to {@code BigInteger}.<br>
                 * Otherwise, if either operand is of type long, the other is converted to long.<br>
                 * Otherwise, both operands are converted to type int.
                 *
                 * @author Andy Clement
                 * @author Juergen Hoeller
                 * @author Sam Brannen
                 * @author Giovanni Dall'Oglio Risso
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(position, left, right) {
                  var node = _SpelNode.SpelNode.create('op-multiply', position, left, right);
                  node.getValue = function (state) {
                    var leftValue = left.getValue(state),
                      rightValue = right.getValue(state);
                    if (typeof leftValue === 'number' && typeof rightValue === 'number') {
                      return leftValue * rightValue;
                    }

                    //repeats (ex. 'abc' * 2 = 'abcabc')
                    if (typeof leftValue === 'string' && typeof rightValue === 'number') {
                      var s = '',
                        i = 0;
                      for (; i < rightValue; i += 1) {
                        s += leftValue;
                      }
                      return s;
                    }
                    return null;
                  };
                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.OpMultiply = {
                  create: createNode
                };

                /***/
              }, /* 28 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.OpDivide = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Implements division operator.
                 *
                 * @author Andy Clement
                 * @author Juergen Hoeller
                 * @author Giovanni Dall'Oglio Risso
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(position, left, right) {
                  var node = _SpelNode.SpelNode.create('op-divide', position, left, right);
                  node.getValue = function (state) {
                    return left.getValue(state) / right.getValue(state);
                  };
                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.OpDivide = {
                  create: createNode
                };

                /***/
              }, /* 29 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.OpModulus = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Implements the modulus operator.
                 *
                 * @author Andy Clement
                 * @author Juergen Hoeller
                 * @author Giovanni Dall'Oglio Risso
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(position, left, right) {
                  var node = _SpelNode.SpelNode.create('op-modulus', position, left, right);
                  node.getValue = function (state) {
                    return left.getValue(state) % right.getValue(state);
                  };
                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.OpModulus = {
                  create: createNode
                };

                /***/
              }, /* 30 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.OpPower = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * The power operator.
                 *
                 * @author Andy Clement
                 * @author Giovanni Dall'Oglio Risso
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(position, base, exp) {
                  var node = _SpelNode.SpelNode.create('op-power', position, base, exp);
                  node.getValue = function (state) {
                    return Math.pow(base.getValue(state), exp.getValue(state));
                  };
                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.OpPower = {
                  create: createNode
                };

                /***/
              }, /* 31 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.OpInc = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Increment operator. Can be used in a prefix or postfix form. This will throw
                 * appropriate exceptions if the operand in question does not support increment.
                 *
                 * @author Andy Clement
                 * @author Juergen Hoeller
                 * @author Giovanni Dall'Oglio Risso
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(position, postfix, int) {
                  var node = _SpelNode.SpelNode.create('op-inc', position, int);
                  node.getValue = function (state) {
                    var cur = int.getValue(state);
                    int.setValue(cur + 1, state);
                    if (postfix) {
                      return cur;
                    }
                    return cur + 1;
                  };
                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.OpInc = {
                  create: createNode
                };

                /***/
              }, /* 32 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.OpDec = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Decrement operator.  Can be used in a prefix or postfix form. This will throw
                 * appropriate exceptions if the operand in question does not support decrement.
                 *
                 * @author Andy Clement
                 * @author Juergen Hoeller
                 * @author Giovanni Dall'Oglio Risso
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(position, postfix, int) {
                  var node = _SpelNode.SpelNode.create('op-dec', position, int);
                  node.getValue = function (state) {
                    var cur = int.getValue(state);
                    int.setValue(cur - 1, state);
                    if (postfix) {
                      return cur;
                    }
                    return cur - 1;
                  };
                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.OpDec = {
                  create: createNode
                };

                /***/
              }, /* 33 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.OpNot = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Represents a NOT operation.
                 *
                 * @author Andy Clement
                 * @author Mark Fisher
                 * @author Oliver Becker
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(position, expr) {
                  var node = _SpelNode.SpelNode.create('op-not', position, expr);
                  node.getValue = function (state) {
                    return !expr.getValue(state);
                  };
                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.OpNot = {
                  create: createNode
                };

                /***/
              }, /* 34 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.OpAnd = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Represents the boolean AND operation.
                 *
                 * @author Andy Clement
                 * @author Mark Fisher
                 * @author Oliver Becker
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(position, left, right) {
                  var node = _SpelNode.SpelNode.create('op-and', position, left, right);
                  node.getValue = function (state) {
                    //double bang for javascript
                    return !!left.getValue(state) && !!right.getValue(state);
                  };
                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.OpAnd = {
                  create: createNode
                };

                /***/
              }, /* 35 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.OpOr = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Represents the boolean OR operation.
                 *
                 * @author Andy Clement
                 * @author Mark Fisher
                 * @author Oliver Becker
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(position, left, right) {
                  var node = _SpelNode.SpelNode.create('op-or', position, left, right);
                  node.getValue = function (state) {
                    //double bang for javascript
                    return !!left.getValue(state) || !!right.getValue(state);
                  };
                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.OpOr = {
                  create: createNode
                };

                /***/
              }, /* 36 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.OpMatches = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Implements the matches operator. Matches takes two operands:
                 * The first is a String and the second is a Java regex.
                 * It will return {@code true} when {@link #getValue} is called
                 * if the first operand matches the regex.
                 *
                 * @author Andy Clement
                 * @author Juergen Hoeller
                 * @author Chris Thielen
                 * @since 3.0
                 */
                function createNode(position, left, right) {
                  var node = _SpelNode.SpelNode.create('matches', position, left, right);

                  /**
                   * Check the first operand matches the regex specified as the second operand.
                   * @param state the expression state
                   * @return {@code true} if the first operand matches the regex specified as the
                   * second operand, otherwise {@code false}
                   * @throws EvaluationException if there is a problem evaluating the expression
                   * (e.g. the regex is invalid)
                   */
                  node.getValue = function (state) {
                    var data = left.getValue(state);
                    var regexpString = right.getValue(state);
                    try {
                      var regexp = new RegExp(regexpString);
                      return !!regexp.exec(data);
                    } catch (error) {
                      throw {
                        name: 'EvaluationException',
                        message: error.toString()
                      };
                    }
                  };
                  return node;
                } /*
                   * Copyright 2002-2019 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      https://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.OpMatches = {
                  create: createNode
                };

                /***/
              }, /* 37 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.Ternary = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Represents a ternary expression, for example: "someCheck()?true:false".
                 *
                 * @author Andy Clement
                 * @author Juergen Hoeller
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(position, expression, ifTrue, ifFalse) {
                  var node = _SpelNode.SpelNode.create('ternary', position, expression, ifTrue, ifFalse);
                  node.getValue = function (state) {
                    return expression.getValue(state) ? ifTrue.getValue(state) : ifFalse.getValue(state);
                  };
                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.Ternary = {
                  create: createNode
                };

                /***/
              }, /* 38 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.Elvis = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Represents the elvis operator ?:. For an expression "a?:b" if a is not null, the value
                 * of the expression is "a", if a is null then the value of the expression is "b".
                 *
                 * @author Andy Clement
                 * @author Juergen Hoeller
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(position, expression, ifFalse) {
                  var node = _SpelNode.SpelNode.create('elvis', position, expression, ifFalse);
                  node.getValue = function (state) {
                    return expression.getValue(state) !== null ? expression.getValue(state) : ifFalse.getValue(state);
                  };
                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.Elvis = {
                  create: createNode
                };

                /***/
              }, /* 39 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.InlineList = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Represent a list in an expression, e.g. '{1,2,3}'
                 *
                 * @author Andy Clement
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(position, elements) {
                  var node = _SpelNode.SpelNode.create('list', position),
                    list = [].concat(elements || []);
                  node.getRaw = function () {
                    return list;
                  };
                  node.getValue = function (state) {
                    return list.map(function (element) {
                      return element.getValue(state);
                    });
                  };
                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.InlineList = {
                  create: createNode
                };

                /***/
              }, /* 40 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.InlineMap = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Represent a map in an expression, e.g. '{name:'foo',age:12}'
                 *
                 * @author Andy Clement
                 * @author Ben March
                 * @since 0.2.0
                 */

                function createNode(position, elements) {
                  var node = _SpelNode.SpelNode.create('map', position),
                    mapPieces = [].concat(elements || []);
                  node.getValue = function (state) {
                    var key = true,
                      keyValue = null,
                      map = {};
                    mapPieces.forEach(function (piece) {
                      if (key) {
                        //unquoted property names come as type "property" but should be treated as strings
                        if (piece.getType() === 'property') {
                          keyValue = piece.getName();
                        } else {
                          keyValue = piece.getValue(state);
                        }
                      } else {
                        map[keyValue] = piece.getValue(state);
                      }
                      key = !key;
                    });
                    return map;
                  };
                  return node;
                } /*
                   * Copyright 2002-2015 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.InlineMap = {
                  create: createNode
                };

                /***/
              }, /* 41 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.Selection = undefined;
                var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
                  return typeof obj;
                } : function (obj) {
                  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                }; /*
                    * Copyright 2002-2015 the original author or authors.
                    *
                    * Licensed under the Apache License, Version 2.0 (the "License");
                    * you may not use this file except in compliance with the License.
                    * You may obtain a copy of the License at
                    *
                    *      http://www.apache.org/licenses/LICENSE-2.0
                    *
                    * Unless required by applicable law or agreed to in writing, software
                    * distributed under the License is distributed on an "AS IS" BASIS,
                    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                    * See the License for the specific language governing permissions and
                    * limitations under the License.
                    */

                var _SpelNode = __webpack_require__(0);

                /**
                 * Represents selection over a map or collection.
                 * For example: {1,2,3,4,5,6,7,8,9,10}.?{#isEven(#this) == 'y'} returns [2, 4, 6, 8, 10]
                 *
                 * <p>Basically a subset of the input data is returned based on the
                 * evaluation of the expression supplied as selection criteria.
                 *
                 * @author Andy Clement
                 * @author Mark Fisher
                 * @author Sam Brannen
                 * @author Ben March
                 * @since 0.2.0
                 */

                function matches(element, expr, state) {
                  var doesMatch = false;
                  state.activeContext.push(element);
                  doesMatch = expr.getValue(state);
                  state.activeContext.pop();
                  return doesMatch;
                }
                function selectFromArray(collection, whichElement, expr, state) {
                  var newCollection = collection.filter(function (element) {
                    return matches(element, expr, state);
                  });
                  switch (whichElement) {
                    case 'ALL':
                      return newCollection;
                    case 'FIRST':
                      return newCollection[0] || null;
                    case 'LAST':
                      if (newCollection.length) {
                        return newCollection[newCollection.length - 1];
                      }
                      return null;
                  }
                }
                function selectFromMap(collection, whichElement, expr, state) {
                  var newCollection = {},
                    entry,
                    key,
                    entries = [],
                    returnValue = {};
                  for (key in collection) {
                    if (collection.hasOwnProperty(key)) {
                      entry = {
                        key: key,
                        value: collection[key]
                      };
                      if (matches(entry, expr, state)) {
                        entries.push(entry);
                      }
                    }
                  }
                  switch (whichElement) {
                    case 'ALL':
                      entries.forEach(function (entry) {
                        newCollection[entry.key] = entry.value;
                      });
                      return newCollection;
                    case 'FIRST':
                      if (entries.length) {
                        returnValue[entries[0].key] = entries[0].value;
                        return returnValue;
                      }
                      return null;
                    case 'LAST':
                      if (entries.length) {
                        returnValue[entries[entries.length - 1].key] = entries[entries.length - 1].value;
                        return returnValue;
                      }
                      return null;
                  }
                  entries.forEach(function (entry) {
                    newCollection[entry.key] = entry.value;
                  });
                }
                function createNode(nullSafeNavigation, whichElement, position, expr) {
                  var node = _SpelNode.SpelNode.create('selection', position, expr);
                  node.getValue = function (state) {
                    var collection = state.activeContext.peek();
                    if (collection) {
                      if (Array.isArray(collection)) {
                        return selectFromArray(collection, whichElement, expr, state);
                      } else if ((typeof collection === 'undefined' ? 'undefined' : _typeof(collection)) === 'object') {
                        return selectFromMap(collection, whichElement, expr, state);
                      }
                    }
                    return null;
                  };
                  return node;
                }
                exports.Selection = {
                  create: createNode,
                  FIRST: 'FIRST',
                  LAST: 'LAST',
                  ALL: 'ALL'
                };

                /***/
              }, /* 42 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.Projection = undefined;
                var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
                  return typeof obj;
                } : function (obj) {
                  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                }; /*
                    * Copyright 2002-2015 the original author or authors.
                    *
                    * Licensed under the Apache License, Version 2.0 (the "License");
                    * you may not use this file except in compliance with the License.
                    * You may obtain a copy of the License at
                    *
                    *      http://www.apache.org/licenses/LICENSE-2.0
                    *
                    * Unless required by applicable law or agreed to in writing, software
                    * distributed under the License is distributed on an "AS IS" BASIS,
                    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                    * See the License for the specific language governing permissions and
                    * limitations under the License.
                    */

                var _SpelNode = __webpack_require__(0);

                /**
                 * Represents projection, where a given operation is performed on all elements in some
                 * input sequence, returning a new sequence of the same size. For example:
                 * "{1,2,3,4,5,6,7,8,9,10}.!{#isEven(#this)}" returns "[n, y, n, y, n, y, n, y, n, y]"
                 *
                 * @author Andy Clement
                 * @author Mark Fisher
                 * @author Ben March
                 * @since 0.2.0
                 */

                function projectCollection(collection, expr, state) {
                  return collection.map(function (element) {
                    var matches;
                    state.activeContext.push(element);
                    matches = expr.getValue(state);
                    state.activeContext.pop();
                    return matches;
                  });
                }
                function createNode(nullSafeNavigation, position, expr) {
                  var node = _SpelNode.SpelNode.create('projection', position, expr);
                  node.getValue = function (state) {
                    var collection = state.activeContext.peek(),
                      entries = [],
                      key;
                    if (Array.isArray(collection)) {
                      return projectCollection(collection, expr, state);
                    } else if ((typeof collection === 'undefined' ? 'undefined' : _typeof(collection)) === 'object') {
                      for (key in collection) {
                        if (collection.hasOwnProperty(key)) {
                          entries.push(collection[key]);
                        }
                      }
                      return projectCollection(entries, expr, state);
                    }
                    return null;
                  };
                  return node;
                }
                exports.Projection = {
                  create: createNode
                };

                /***/
              }, /* 43 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.OpInstanceof = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * The operator 'instanceof' checks if an object is of the class specified in the right
                 * hand operand, in the same way that {@code instanceof} does in Java.
                 *
                 * THIS OPERATOR IS NOT IMPLEMENTED AND WILL THROW AN EXCEPTION
                 *
                 * @author Andy Clement
                 * @since 3.0
                 */
                function createNode(position, left, right) {
                  var node = _SpelNode.SpelNode.create('instanceof', position, left, right);

                  /**
                   * Compare the left operand to see it is an instance of the type specified as the
                   * right operand. The right operand must be a class.
                   * @param state the expression state
                   * @return {@code true} if the left operand is an instanceof of the right operand,
                   * otherwise {@code false}
                   * @throws EvaluationException if there is a problem evaluating the expression
                   */
                  node.getValue = function (state) {
                    throw {
                      name: 'MethodNotImplementedException',
                      message: 'OpInstanceOf: Not implemented'
                    };
                  };
                  return node;
                } /*
                   * Copyright 2002-2019 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      https://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.OpInstanceof = {
                  create: createNode
                };

                /***/
              }, /* 44 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.OpBetween = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Represents the between operator. The left operand to between must be a single value and
                 * the right operand must be a list - this operator returns true if the left operand is
                 * between (using the registered comparator) the two elements in the list. The definition
                 * of between being inclusive follows the SQL BETWEEN definition.
                 *
                 * @author Andy Clement
                 * @since 3.0
                 */
                function createNode(position, left, right) {
                  var node = _SpelNode.SpelNode.create('between', position, left, right);

                  /**
                   * Returns a boolean based on whether a value is in the range expressed. The first
                   * operand is any value whilst the second is a list of two values - those two values
                   * being the bounds allowed for the first operand (inclusive).
                   * @param state the expression state
                   * @return true if the left operand is in the range specified, false otherwise
                   * @throws EvaluationException if there is a problem evaluating the expression
                   */
                  node.getValue = function (state) {
                    throw {
                      name: 'MethodNotImplementedException',
                      message: 'OpBetween: Not implemented'
                    };
                  };
                  return node;
                } /*
                   * Copyright 2002-2019 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      https://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.OpBetween = {
                  create: createNode
                };

                /***/
              }, /* 45 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.TypeReference = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Represents a reference to a type, for example
                 * {@code "T(String)" or "T(com.somewhere.Foo)"}.
                 *
                 * @author Andy Clement
                 */
                function createNode(position, node, _dims) {
                  var node = _SpelNode.SpelNode.create('typeref', position, node);
                  node.getValue = function (state) {
                    throw {
                      name: 'MethodNotImplementedException',
                      message: 'TypeReference: Not implemented'
                    };
                  };
                  return node;
                } /*
                   * Copyright 2002-2019 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      https://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.TypeReference = {
                  create: createNode
                };

                /***/
              }, /* 46 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.BeanReference = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * Represents a bean reference to a type, for example <tt>@foo</tt> or <tt>@'foo.bar'</tt>.
                 * For a FactoryBean the syntax <tt>&foo</tt> can be used to access the factory itself.
                 *
                 * @author Andy Clement
                 */
                function createNode(position, beanName) {
                  var node = _SpelNode.SpelNode.create('beanref', position);
                  node.getValue = function (state) {
                    throw {
                      name: 'MethodNotImplementedException',
                      message: 'BeanReference: Not implemented'
                    };
                  };
                  return node;
                } /*
                   * Copyright 2002-2019 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      https://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.BeanReference = {
                  create: createNode
                };

                /***/
              }, /* 47 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.Identifier = undefined;
                var _SpelNode = __webpack_require__(0);

                /**
                 * An 'identifier' {@link SpelNode}.
                 *
                 * @author Andy Clement
                 * @since 3.0
                 */
                function createNode(identifierName, position) {
                  var node = _SpelNode.SpelNode.create('identifier', position);
                  node.getRaw = function () {
                    return identifierName;
                  };
                  node.getValue = function (state) {
                    throw {
                      name: 'MethodNotImplementedException',
                      message: 'Identifier: Not implemented'
                    };
                  };
                  return node;
                } /*
                   * Copyright 2002-2019 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      https://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                exports.Identifier = {
                  create: createNode
                };

                /***/
              }, /* 48 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.QualifiedIdentifier = undefined;
                var _SpelNode = __webpack_require__(0);
                function _toConsumableArray(arr) {
                  if (Array.isArray(arr)) {
                    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                      arr2[i] = arr[i];
                    }
                    return arr2;
                  } else {
                    return Array.from(arr);
                  }
                } /*
                   * Copyright 2002-2019 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      https://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                /**
                 * Represents a dot separated sequence of strings that indicate a package qualified type
                 * reference.
                 *
                 * <p>Example: "java.lang.String" as in the expression "new java.lang.String('hello')"
                 *
                 * @author Andy Clement
                 * @since 3.0
                 */
                function createNode(position, pieces) {
                  var node = _SpelNode.SpelNode.create.apply(_SpelNode.SpelNode, ['qualifiedidentifier', position].concat(_toConsumableArray(pieces)));
                  node.getRaw = function () {
                    return pieces.map(function (p) {
                      return p.getRaw();
                    });
                  };
                  node.getValue = function (state) {
                    throw {
                      name: 'MethodNotImplementedException',
                      message: 'QualifiedIdentifier: Not implemented'
                    };
                  };
                  return node;
                }
                exports.QualifiedIdentifier = {
                  create: createNode
                };

                /***/
              }, /* 49 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.ConstructorReference = undefined;
                var _SpelNode = __webpack_require__(0);
                var _Stack = __webpack_require__(1);
                function _toConsumableArray(arr) {
                  if (Array.isArray(arr)) {
                    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                      arr2[i] = arr[i];
                    }
                    return arr2;
                  } else {
                    return Array.from(arr);
                  }
                }
                function _toArray(arr) {
                  return Array.isArray(arr) ? arr : Array.from(arr);
                } /*
                   * Copyright 2002-2019 the original author or authors.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *      https://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

                /**
                 * Represents the invocation of a constructor. Either a constructor on a regular type or
                 * construction of an array. When an array is constructed, an initializer can be specified.
                 *
                 * <p>Examples:<br>
                 * new String('hello world')<br>
                 * new int[]{1,2,3,4}<br>
                 * new int[3] new int[3]{1,2,3}
                 *
                 * @author Andy Clement
                 * @author Juergen Hoeller
                 * @since 3.0
                 */
                function createNode(position, dimensions, nodes) {
                  var isArray = nodes !== undefined;
                  var dimension;
                  if (isArray) {
                    dimension = dimensions.length && dimensions[0] && dimensions[0].getType() === 'number' ? dimensions[0].getValue() : null;
                  } else {
                    nodes = dimensions;
                    dimensions = undefined;
                  }
                  var _nodes = nodes,
                    _nodes2 = _toArray(_nodes);
                  _nodes2[0];
                  var args = _nodes2.slice(1);
                  var node = _SpelNode.SpelNode.create.apply(_SpelNode.SpelNode, ['constructorref', position].concat(_toConsumableArray(nodes)));
                  node.getRaw = function () {
                    return dimension;
                  };
                  node.getValue = function (state) {
                    if (isArray && args.length <= 1) {
                      var compiledArgs = [];

                      //populate arguments
                      args.forEach(function (arg) {
                        // reset the active context to root context for evaluating argument
                        var currentActiveContext = state.activeContext;
                        state.activeContext = new _Stack.Stack();
                        state.activeContext.push(state.rootContext);

                        // evaluate argument
                        compiledArgs.push(arg.getValue(state));

                        // reset the active context
                        state.activeContext = currentActiveContext;
                      });
                      if (args.length === 1) {
                        return compiledArgs[0];
                      } else {
                        return dimension ? new Array(dimension) : [];
                      }
                    }
                    throw {
                      name: 'MethodNotImplementedException',
                      message: 'ConstructorReference: Not implemented'
                    };
                  };
                  return node;
                }
                exports.ConstructorReference = {
                  create: createNode
                };

                /***/
              }, /* 50 */
              /***/function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                /*
                 * Copyright 2002-2015 the original author or authors.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *      http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */

                /**
                 * @author Ben March
                 * @since 0.2.0
                 */

                function create(authentication, principal) {
                  var context = {};
                  context.authentication = authentication || {};
                  context.principal = principal || {};
                  context.hasRole = function (role) {
                    var hasRole = false;
                    if (!role) {
                      return false;
                    }
                    if (!context.authentication && !Array.isArray(context.authentication.authorities)) {
                      return false;
                    }
                    context.authentication.authorities.forEach(function (grantedAuthority) {
                      if (grantedAuthority.authority.toLowerCase() === role.toLowerCase()) {
                        hasRole = true;
                      }
                    });
                    return hasRole;
                  };
                  context.hasPermission = function () /*variable arguments*/{
                    var args = Array.prototype.slice.call(arguments);
                    if (args.length === 1) {
                      return context.hasRole(args[0]);
                    }
                  };
                  return context;
                }
                exports.StandardContext = {
                  create: create
                };

                /***/
              }
              /******/])
            );
          });
        })(spel2js);
        var spel2jsExports = spel2js.exports;
        function ownKeys$l(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$l(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$l(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$l(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        var loadFromSpel = function loadFromSpel(logicTree, config) {
          return _loadFromSpel(logicTree, config, true);
        };
        var _loadFromSpel = function _loadFromSpel(spelStr, config) {
          var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          //meta is mutable
          var meta = {
            errors: []
          };
          var extendedConfig = extendConfig$1(config);
          var conv = buildConv(extendedConfig);
          var compiledExpression;
          var convertedObj;
          var jsTree = undefined;
          try {
            var compileRes = spel2jsExports.SpelExpressionEvaluator.compile(spelStr);
            compiledExpression = compileRes._compiledExpression;
          } catch (e) {
            meta.errors.push(e);
          }
          if (compiledExpression) {
            logger$1.debug("compiledExpression:", compiledExpression);
            convertedObj = convertCompiled(compiledExpression, meta);
            logger$1.debug("convertedObj:", convertedObj, meta);
            jsTree = convertToTree(convertedObj, conv, extendedConfig, meta);
            if (jsTree && jsTree.type != "group" && jsTree.type != "switch_group") {
              jsTree = wrapInDefaultConj(jsTree, extendedConfig, convertedObj["not"]);
            }
            logger$1.debug("jsTree:", jsTree);
          }
          var immTree = jsTree ? loadTree(jsTree) : undefined;
          if (returnErrors) {
            return [immTree, meta.errors];
          } else {
            if (meta.errors.length) console.warn("Errors while importing from SpEL:", meta.errors);
            return immTree;
          }
        };
        var convertCompiled = function convertCompiled(expr, meta) {
          var parentExpr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          var type = expr.getType();
          var children = expr.getChildren().map(function (child) {
            return convertCompiled(child, meta, expr);
          });

          // flatize OR/AND
          if (type == "op-or" || type == "op-and") {
            children = children.reduce(function (acc, child) {
              var canFlatize = child.type == type && !child.not;
              var flat = canFlatize ? child.children : [child];
              return [].concat(_toConsumableArray(acc), _toConsumableArray(flat));
            }, []);
          }

          // unwrap NOT
          if (type == "op-not") {
            if (children.length != 1) {
              meta.errors.push("Operator NOT should have 1 child, but got ".concat(children.length, "}"));
            }
            return _objectSpread$l(_objectSpread$l({}, children[0]), {}, {
              not: !(children[0].not || false)
            });
          }
          if (type == "compound") {
            // remove `.?[true]`
            children = children.filter(function (child) {
              var isListFix = child.type == "selection" && child.children.length == 1 && child.children[0].type == "boolean" && child.children[0].val == true;
              return !isListFix;
            });
            // aggregation
            // eg. `results.?[product == 'abc'].length`
            var selection = children.find(function (child) {
              return child.type == "selection";
            });
            if (selection && selection.children.length != 1) {
              meta.errors.push("Selection should have 1 child, but got ".concat(selection.children.length));
            }
            var filter = selection ? selection.children[0] : null;
            var lastChild = children[children.length - 1];
            var isSize = lastChild.type == "method" && lastChild.val.methodName == "size" || lastChild.type == "!func" && lastChild.methodName == "size";
            var isLength = lastChild.type == "property" && lastChild.val == "length";
            var sourceParts = children.filter(function (child) {
              return child !== selection && child !== lastChild;
            });
            var source = {
              type: "compound",
              children: sourceParts
            };
            if (isSize || isLength) {
              return {
                type: "!aggr",
                filter: filter,
                source: source
              };
            }
            // remove `#this`, `#root`
            children = children.filter(function (child) {
              var isThis = child.type == "variable" && child.val == "this";
              var isRoot = child.type == "variable" && child.val == "root";
              return !(isThis || isRoot);
            });
            // indexer
            children = children.map(function (child) {
              if (child.type == "indexer" && child.children.length == 1) {
                return {
                  type: "indexer",
                  val: child.children[0].val,
                  itype: child.children[0].type
                };
              } else {
                return child;
              }
            });
            // method
            if (lastChild.type == "method") {
              var obj = children.filter(function (child) {
                return child !== lastChild;
              });
              return {
                type: "!func",
                obj: obj,
                methodName: lastChild.val.methodName,
                args: lastChild.val.args
              };
            }
            // !func
            if (lastChild.type == "!func") {
              var _obj = children.filter(function (child) {
                return child !== lastChild;
              });
              return _objectSpread$l(_objectSpread$l({}, lastChild), {}, {
                obj: _obj
              });
            }
          }

          // getRaw || getValue
          var val;
          try {
            if (expr.getRaw) {
              // use my fork
              val = expr.getRaw();
            } else if (expr.getValue.length == 0) {
              // getValue not requires context arg -> can use
              val = expr.getValue();
            }
          } catch (e) {
            logger$1.error("[spel2js] Error in getValue()", e);
          }

          // ternary
          if (type == "ternary") {
            val = flatizeTernary(children);
          }

          // convert method/function args
          if (_typeof$2(val) === "object" && val !== null) {
            if (val.methodName || val.functionName) {
              val.args = val.args.map(function (child) {
                return convertCompiled(child, meta, expr);
              });
            }
          }
          // convert list
          if (type == "list") {
            val = val.map(function (item) {
              return convertCompiled(item, meta, expr);
            });

            // fix whole expression wrapped in `{}`
            if (!parentExpr && val.length == 1) {
              return val[0];
            }
          }
          // convert constructor
          if (type == "constructorref") {
            var qid = children.find(function (child) {
              return child.type == "qualifiedidentifier";
            });
            var cls = qid === null || qid === void 0 ? void 0 : qid.val;
            if (!cls) {
              meta.errors.push("Can't find qualifiedidentifier in constructorref children: ".concat(JSON.stringify(children)));
              return undefined;
            }
            var args = children.filter(function (child) {
              return child.type != "qualifiedidentifier";
            });
            return {
              type: "!new",
              cls: cls,
              args: args
            };
          }
          // convert type
          if (type == "typeref") {
            var _qid = children.find(function (child) {
              return child.type == "qualifiedidentifier";
            });
            var _cls = _qid === null || _qid === void 0 ? void 0 : _qid.val;
            if (!_cls) {
              meta.errors.push("Can't find qualifiedidentifier in typeref children: ".concat(JSON.stringify(children)));
              return undefined;
            }
            children.filter(function (child) {
              return child.type != "qualifiedidentifier";
            });
            return {
              type: "!type",
              cls: _cls
            };
          }
          // convert function/method
          if (type == "function" || type == "method") {
            // `foo()` is method, `#foo()` is function
            // let's use common property `methodName` and just add `isVar` for function
            var _val = val,
              functionName = _val.functionName,
              methodName = _val.methodName,
              _args2 = _val.args;
            return {
              type: "!func",
              methodName: functionName || methodName,
              isVar: type == "function",
              args: _args2
            };
          }
          return {
            type: type,
            children: children,
            val: val
          };
        };
        var flatizeTernary = function flatizeTernary(children) {
          var flat = [];
          function _processTernaryChildren(tern) {
            var _tern = _slicedToArray$1(tern, 3),
              cond = _tern[0],
              if_val = _tern[1],
              else_val = _tern[2];
            flat.push([cond, if_val]);
            if ((else_val === null || else_val === void 0 ? void 0 : else_val.type) == "ternary") {
              _processTernaryChildren(else_val.children);
            } else {
              flat.push([undefined, else_val]);
            }
          }
          _processTernaryChildren(children);
          return flat;
        };
        var buildConv = function buildConv(config) {
          var operators = {};
          var _loop = function _loop(opKey) {
            var opConfig = config.operators[opKey];
            if (opConfig.spelOps) {
              // examples: "==", "eq", ".contains", "matches" (can be used for starts_with, ends_with)
              opConfig.spelOps.forEach(function (spelOp) {
                var opk = spelOp; // + "/" + defaultValue(opConfig.cardinality, 1);
                if (!operators[opk]) operators[opk] = [];
                operators[opk].push(opKey);
              });
            } else if (opConfig.spelOp) {
              var opk = opConfig.spelOp; // + "/" + defaultValue(opConfig.cardinality, 1);
              if (!operators[opk]) operators[opk] = [];
              operators[opk].push(opKey);
            } else {
              logger$1.log("[spel] No spelOp for operator ".concat(opKey));
            }
          };
          for (var opKey in config.operators) {
            _loop(opKey);
          }
          var conjunctions = {};
          for (var conjKey in config.conjunctions) {
            var conjunctionDefinition = config.conjunctions[conjKey];
            var ck = conjunctionDefinition.spelConj || conjKey.toLowerCase();
            conjunctions[ck] = conjKey;
          }
          var funcs = {};
          for (var funcKey in config.funcs) {
            var funcConfig = config.funcs[funcKey];
            var fk = void 0;
            if (typeof funcConfig.spelFunc == "string") {
              fk = funcConfig.spelFunc;
            }
            if (fk) {
              if (!funcs[fk]) funcs[fk] = [];
              funcs[fk].push(funcKey);
            }
          }
          return {
            operators: operators,
            conjunctions: conjunctions,
            funcs: funcs
          };
        };
        var convertPath = function convertPath(parts, meta) {
          var isError = false;
          var res = parts.map(function (c) {
            if (c.type == "variable" || c.type == "property" || c.type == "indexer" && c.itype == "string") {
              return c.val;
            } else {
              isError = true;
              meta.errors.push("Unexpected item in compound: ".concat(JSON.stringify(c)));
            }
          });
          return !isError ? res : undefined;
        };
        var convertArg = function convertArg(spel, conv, config, meta, parentSpel) {
          if (spel == undefined) return undefined;
          var fieldSeparator = config.settings.fieldSeparator;
          var literalTypes = {
            number: "number",
            string: "text",
            "boolean": "boolean",
            "null": "null" // should not be
          };

          var groupFieldParts = parentSpel !== null && parentSpel !== void 0 && parentSpel._groupField ? [parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField] : [];
          if (spel.type == "compound") {
            var _spel$children, _spel$children$;
            // complex field
            var parts = convertPath(spel.children, meta);
            if (!parts) {
              return undefined;
            }
            var fullParts = [].concat(groupFieldParts, _toConsumableArray(parts));
            var isVariable = ((_spel$children = spel.children) === null || _spel$children === void 0 ? void 0 : (_spel$children$ = _spel$children[0]) === null || _spel$children$ === void 0 ? void 0 : _spel$children$.type) == "variable";
            return {
              valueSrc: "field",
              //valueType: todo
              isVariable: isVariable,
              value: fullParts.join(fieldSeparator)
            };
          } else if (spel.type == "variable" || spel.type == "property") {
            // normal field
            var _fullParts = [].concat(groupFieldParts, [spel.val]);
            var _isVariable = spel.type == "variable";
            return {
              valueSrc: "field",
              //valueType: todo
              isVariable: _isVariable,
              value: _fullParts.join(fieldSeparator)
            };
          } else if (literalTypes[spel.type]) {
            var value = spel.val;
            var valueType = literalTypes[spel.type];
            if (parentSpel !== null && parentSpel !== void 0 && parentSpel.isUnary) {
              value = -value;
            }
            return {
              valueSrc: "value",
              valueType: valueType,
              value: value
            };
          } else if (spel.type == "list") {
            var _values$;
            var values = spel.val.map(function (v) {
              return convertArg(v, conv, config, meta, spel);
            });
            values.length ? (_values$ = values[0]) === null || _values$ === void 0 ? void 0 : _values$.valueType : null;
            var _value = values.map(function (v) {
              return v === null || v === void 0 ? void 0 : v.value;
            });
            var _valueType = "multiselect";
            return {
              valueSrc: "value",
              valueType: _valueType,
              value: _value
            };
          } else if (spel.type == "!func") {
            var _funcToOpMap;
            var obj = spel.obj,
              methodName = spel.methodName,
              args = spel.args;
            spel.isVar;

            // todo: get from conv
            var funcToOpMap = (_funcToOpMap = {}, _defineProperty$4(_funcToOpMap, ".contains", "like"), _defineProperty$4(_funcToOpMap, ".startsWith", "starts_with"), _defineProperty$4(_funcToOpMap, ".endsWith", "ends_with"), _defineProperty$4(_funcToOpMap, "$contains", "select_any_in"), _defineProperty$4(_funcToOpMap, ".equals", "multiselect_equals"), _defineProperty$4(_funcToOpMap, "CollectionUtils.containsAny()", "multiselect_contains"), _funcToOpMap);
            var convertedArgs = args.map(function (v) {
              return convertArg(v, conv, config, meta, _objectSpread$l(_objectSpread$l({}, spel), {}, {
                _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField
              }));
            });

            //todo: make dynamic: use funcToOpMap and check obj type in basic config
            if (methodName == "contains" && obj && obj[0].type == "list") {
              var convertedObj = obj.map(function (v) {
                return convertArg(v, conv, config, meta, spel);
              });
              // {'yellow', 'green'}.?[true].contains(color)
              if (!(convertedArgs.length == 1 && convertedArgs[0].valueSrc == "field")) {
                meta.errors.push("Expected arg to method ".concat(methodName, " to be field but got: ").concat(JSON.stringify(convertedArgs)));
                return undefined;
              }
              var field = convertedArgs[0].value;
              if (!(convertedObj.length == 1 && convertedObj[0].valueType == "multiselect")) {
                meta.errors.push("Expected object of method ".concat(methodName, " to be inline list but got: ").concat(JSON.stringify(convertedObj)));
                return undefined;
              }
              var opKey = funcToOpMap["$" + methodName];
              var list = convertedObj[0];
              return buildRule(config, meta, field, opKey, [list], spel);
            } else if (obj && obj[0].type == "property" && funcToOpMap[obj[0].val + "." + methodName + "()"]) {
              // CollectionUtils.containsAny(multicolor, {'yellow', 'green'})
              var _opKey = funcToOpMap[obj[0].val + "." + methodName + "()"];
              var _field = convertedArgs[0].value;
              var _args3 = convertedArgs.slice(1);
              return buildRule(config, meta, _field, _opKey, _args3, spel);
            } else if (funcToOpMap["." + methodName]) {
              // user.login.startsWith('gg')
              var _opKey2 = funcToOpMap["." + methodName];
              var _parts = convertPath(obj, meta);
              if (_parts && convertedArgs.length == 1) {
                var _fullParts2 = [].concat(groupFieldParts, _toConsumableArray(_parts));
                var _field2 = _fullParts2.join(fieldSeparator);
                return buildRule(config, meta, _field2, _opKey2, convertedArgs, spel);
              }
            } else if (methodName == "parse" && obj && obj[0].type == "!new" && obj[0].cls.at(-1) == "SimpleDateFormat") {
              // new java.text.SimpleDateFormat('yyyy-MM-dd').parse('2022-01-15')
              var _args4 = obj[0].args.map(function (v) {
                return convertArg(v, conv, config, meta, _objectSpread$l(_objectSpread$l({}, spel), {}, {
                  _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField
                }));
              });
              if (!(_args4.length == 1 && _args4[0].valueType == "text")) {
                meta.errors.push("Expected args of ".concat(obj[0].cls.join("."), ".").concat(methodName, " to be 1 string but got: ").concat(JSON.stringify(_args4)));
                return undefined;
              }
              if (!(convertedArgs.length == 1 && convertedArgs[0].valueType == "text")) {
                meta.errors.push("Expected args of ".concat(obj[0].cls.join("."), " to be 1 string but got: ").concat(JSON.stringify(convertedArgs)));
                return undefined;
              }
              var dateFormat = _args4[0].value;
              var dateString = convertedArgs[0].value;
              var _valueType2 = dateFormat.includes(" ") ? "datetime" : "date";
              var _field3 = null; // todo
              var widget = _valueType2;
              var fieldConfig = getFieldConfig$8(config, _field3);
              var widgetConfig = config.widgets[widget || (fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.mainWidget)];
              var valueFormat = widgetConfig.valueFormat;
              var dateVal = hooks(dateString, hooks.ISO_8601);
              var _value2 = dateVal.isValid() ? dateVal.format(valueFormat) : undefined;
              return {
                valueSrc: "value",
                valueType: _valueType2,
                value: _value2
              };
            } else if (methodName == "parse" && obj && obj[0].type == "!type" && obj[0].cls.at(-1) == "LocalTime") {
              // time == T(java.time.LocalTime).parse('02:03:00')
              if (!(convertedArgs.length == 1 && convertedArgs[0].valueType == "text")) {
                meta.errors.push("Expected args of ".concat(obj[0].cls.join("."), " to be 1 string but got: ").concat(JSON.stringify(convertedArgs)));
                return undefined;
              }
              var timeString = convertedArgs[0].value;
              var _valueType3 = "time";
              var _field4 = null; // todo
              var _widget = _valueType3;
              var _fieldConfig = getFieldConfig$8(config, _field4);
              var _widgetConfig = config.widgets[_widget || (_fieldConfig === null || _fieldConfig === void 0 ? void 0 : _fieldConfig.mainWidget)];
              var _valueFormat = _widgetConfig.valueFormat;
              var _dateVal = hooks(timeString, "HH:mm:ss");
              var _value3 = _dateVal.isValid() ? _dateVal.format(_valueFormat) : undefined;
              return {
                valueSrc: "value",
                valueType: _valueType3,
                value: _value3
              };
            } else {
              // todo: conv.funcs
              meta.errors.push("Unsupported method ".concat(methodName));
            }
          } else if (spel.type == "op-plus" && (parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel.type) == "ternary") {
            return buildCaseValueConcat(spel, conv, config, meta);
          } else {
            meta.errors.push("Can't convert arg of type ".concat(spel.type));
          }
          return undefined;
        };
        var buildRule = function buildRule(config, meta, field, opKey, convertedArgs, spel) {
          if (convertedArgs.filter(function (v) {
            return v === undefined;
          }).length) {
            return undefined;
          }
          var fieldConfig = getFieldConfig$8(config, field);
          if (!fieldConfig) {
            meta.errors.push("No config for field ".concat(field));
            return undefined;
          }
          var canRev = true;
          var needWrapReverse = false;
          if (spel !== null && spel !== void 0 && spel.not && canRev) {
            var opConfig = config.operators[opKey];
            if (opConfig.reversedOp) {
              opKey = opConfig.reversedOp;
              spel.not = false;
            } else {
              needWrapReverse = true;
            }
          }
          var widget = getWidgetForFieldOp$3(config, field, opKey);
          var widgetConfig = config.widgets[widget || fieldConfig.mainWidget];
          var asyncListValuesArr = convertedArgs.map(function (v) {
            return v.asyncListValues;
          }).filter(function (v) {
            return v != undefined;
          });
          var asyncListValues = asyncListValuesArr.length ? asyncListValuesArr[0] : undefined;
          var res = {
            type: "rule",
            id: uuid$1(),
            properties: {
              field: field,
              operator: opKey,
              value: convertedArgs.map(function (v) {
                return v.value;
              }),
              valueSrc: convertedArgs.map(function (v) {
                return v.valueSrc;
              }),
              valueType: convertedArgs.map(function (v) {
                if (v.valueSrc == "value") {
                  return (widgetConfig === null || widgetConfig === void 0 ? void 0 : widgetConfig.type) || (fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type) || v.valueType;
                }
                return v.valueType;
              }),
              asyncListValues: asyncListValues
            }
          };
          if (needWrapReverse) {
            res = wrapInDefaultConj(res, config, spel === null || spel === void 0 ? void 0 : spel.not);
            if (spel !== null && spel !== void 0 && spel.not) {
              spel.not = false;
            }
          }
          return res;
        };
        var buildRuleGroup = function buildRuleGroup(_ref, opKey, convertedArgs, config, meta) {
          var groupFilter = _ref.groupFilter,
            groupFieldValue = _ref.groupFieldValue;
          if (groupFieldValue.valueSrc != "field") throw "Bad groupFieldValue: ".concat(JSON.stringify(groupFieldValue));
          var groupField = groupFieldValue.value;
          var groupOpRule = buildRule(config, meta, groupField, opKey, convertedArgs);
          if (!groupOpRule) return undefined;
          var fieldConfig = getFieldConfig$8(config, groupField);
          var mode = fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.mode;
          var res = _objectSpread$l(_objectSpread$l({}, groupFilter || {}), {}, {
            type: "rule_group",
            properties: _objectSpread$l(_objectSpread$l(_objectSpread$l({}, groupOpRule.properties), (groupFilter === null || groupFilter === void 0 ? void 0 : groupFilter.properties) || {}), {}, {
              mode: mode
            })
          });
          if (!res.id) res.id = uuid$1();
          return res;
        };
        var compareArgs = function compareArgs(left, right, spel, conv, config, meta) {
          var parentSpel = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
          if (left.type == right.type) {
            if (left.type == "!aggr") {
              var _map = [left.source, right.source].map(function (v) {
                  return convertArg(v, conv, config, meta, _objectSpread$l(_objectSpread$l({}, spel), {}, {
                    _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField
                  }));
                }),
                _map2 = _slicedToArray$1(_map, 2),
                leftSource = _map2[0],
                rightSource = _map2[1];
              //todo: check same filter
              return leftSource.value == rightSource.value;
            } else {
              var _map3 = [left, right].map(function (v) {
                  return convertArg(v, conv, config, meta, _objectSpread$l(_objectSpread$l({}, spel), {}, {
                    _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField
                  }));
                }),
                _map4 = _slicedToArray$1(_map3, 2),
                leftVal = _map4[0],
                rightVal = _map4[1];
              return leftVal.value == rightVal.value;
            }
          }
          return false;
        };
        var convertToTree = function convertToTree(spel, conv, config, meta) {
          var parentSpel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          if (!spel) return undefined;
          var res;
          if (spel.type.indexOf("op-") == 0) {
            var op = spel.type.slice("op-".length);

            // unary
            var isUnary = (op == "minus" || op == "plus") && spel.children.length == 1;
            if (isUnary) {
              spel.isUnary = true;
              return convertToTree(spel.children[0], conv, config, meta, spel);
            }

            // between
            var isBetweenNormal = op == "and" && spel.children.length == 2 && spel.children[0].type == "op-ge" && spel.children[1].type == "op-le";
            var isBetweenRev = op == "or" && spel.children.length == 2 && spel.children[0].type == "op-lt" && spel.children[1].type == "op-gt";
            var isBetween = isBetweenNormal || isBetweenRev;
            if (isBetween) {
              var _spel$children$0$chil = _slicedToArray$1(spel.children[0].children, 2),
                left = _spel$children$0$chil[0],
                from = _spel$children$0$chil[1];
              var _spel$children$1$chil = _slicedToArray$1(spel.children[1].children, 2),
                right = _spel$children$1$chil[0],
                to = _spel$children$1$chil[1];
              var isNumbers = from.type == "number" && to.type == "number";
              var isSameSource = compareArgs(left, right, spel, conv, config, meta, parentSpel);
              if (isNumbers && isSameSource) {
                from.val;
                to.val;
                var oneSpel = {
                  type: "op-between",
                  children: [left, from, to]
                };
                return convertToTree(oneSpel, conv, config, meta, parentSpel);
              }
            }

            // find op
            var opKeys = conv.operators[op];
            // todo: make dynamic, use basic config
            if (op == "eq" && spel.children[1].type == "null") {
              opKeys = ["is_null"];
            } else if (op == "ne" && spel.children[1].type == "null") {
              opKeys = ["is_not_null"];
            } else if (op == "le" && spel.children[1].type == "string" && spel.children[1].val == "") {
              opKeys = ["is_empty"];
            } else if (op == "gt" && spel.children[1].type == "string" && spel.children[1].val == "") {
              opKeys = ["is_not_empty"];
            } else if (op == "between") {
              opKeys = ["between"];
            }

            // convert children
            var convertChildren = function convertChildren() {
              return spel.children.map(function (child) {
                return convertToTree(child, conv, config, meta, _objectSpread$l(_objectSpread$l({}, spel), {}, {
                  _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField
                }));
              });
            };
            if (op == "and" || op == "or") {
              var children1 = {};
              var vals = convertChildren();
              vals.forEach(function (v) {
                if (v) {
                  var id = uuid$1();
                  v.id = id;
                  if (v.type != undefined) {
                    children1[id] = v;
                  } else {
                    meta.errors.push("Bad item in AND/OR: ".concat(JSON.stringify(v)));
                  }
                }
              });
              res = {
                type: "group",
                id: uuid$1(),
                children1: children1,
                properties: {
                  conjunction: conv.conjunctions[op],
                  not: spel.not
                }
              };
            } else if (opKeys) {
              var _fieldObj$groupFieldV, _convertedArgs;
              var _vals = convertChildren();
              var fieldObj = _vals[0];
              var convertedArgs = _vals.slice(1);
              var groupField = fieldObj === null || fieldObj === void 0 ? void 0 : (_fieldObj$groupFieldV = fieldObj.groupFieldValue) === null || _fieldObj$groupFieldV === void 0 ? void 0 : _fieldObj$groupFieldV.value;
              var opArg = (_convertedArgs = convertedArgs) === null || _convertedArgs === void 0 ? void 0 : _convertedArgs[0];
              var opKey = opKeys[0];
              if (opKeys.length > 1) {
                logger$1.warn("[spel] Spel operator ".concat(op, " can be mapped to ").concat(opKeys));

                //todo: it's naive
                var field = fieldObj === null || fieldObj === void 0 ? void 0 : fieldObj.value;
                var widgets = opKeys.map(function (op) {
                  return {
                    op: op,
                    widget: getWidgetForFieldOp$3(config, field, op)
                  };
                });
                if (op == "eq" || op == "ne") {
                  var ws = widgets.find(function (_ref2) {
                    _ref2.op;
                    var widget = _ref2.widget;
                    return widget && widget != "field";
                  });
                  if (ws) {
                    opKey = ws.op;
                  }
                }
              }

              // some/all/none
              if (fieldObj !== null && fieldObj !== void 0 && fieldObj.groupFieldValue) {
                if (opArg && opArg.groupFieldValue && opArg.groupFieldValue.valueSrc == "field" && opArg.groupFieldValue.value == groupField) {
                  // group.?[...].size() == group.size()
                  opKey = "all";
                  convertedArgs = [];
                } else if (opKey == "equal" && opArg.valueSrc == "value" && opArg.valueType == "number" && opArg.value == 0) {
                  opKey = "none";
                  convertedArgs = [];
                } else if (opKey == "greater" && opArg.valueSrc == "value" && opArg.valueType == "number" && opArg.value == 0) {
                  opKey = "some";
                  convertedArgs = [];
                }
              }
              var canRev = true;
              var needWrapReverse = false;
              if (spel.not && canRev) {
                var opConfig = config.operators[opKey];
                if (opConfig.reversedOp) {
                  opKey = opConfig.reversedOp;
                  spel.not = false;
                } else {
                  needWrapReverse = true;
                }
              }
              if (!fieldObj) ;else if (fieldObj.groupFieldValue) {
                // 1. group
                if (fieldObj.groupFieldValue.valueSrc != "field") {
                  meta.errors.push("Expected group field ".concat(JSON.stringify(fieldObj)));
                }
                res = buildRuleGroup(fieldObj, opKey, convertedArgs, config, meta);
              } else {
                // 2. not group
                if (fieldObj.valueSrc != "field") {
                  meta.errors.push("Expected field ".concat(JSON.stringify(fieldObj)));
                }
                var _field5 = fieldObj.value;
                res = buildRule(config, meta, _field5, opKey, convertedArgs);
              }
              if (needWrapReverse) {
                if (res.type !== "group") {
                  res = wrapInDefaultConj(res, config, spel.not);
                } else {
                  res.properties.not = !res.properties.not;
                }
              }
            } else {
              if (!parentSpel) {
                // try to parse whole `"str" + prop + #var` as ternary
                res = buildSimpleSwitch(spel, conv, config, meta);
              }
              if (!res) {
                meta.errors.push("Can't convert op ".concat(op));
              }
            }
          } else if (spel.type == "!aggr") {
            var _groupFilter;
            var groupFieldValue = convertToTree(spel.source, conv, config, meta, _objectSpread$l(_objectSpread$l({}, spel), {}, {
              _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField
            }));
            var groupFilter = convertToTree(spel.filter, conv, config, meta, _objectSpread$l(_objectSpread$l({}, spel), {}, {
              _groupField: groupFieldValue === null || groupFieldValue === void 0 ? void 0 : groupFieldValue.value
            }));
            if (((_groupFilter = groupFilter) === null || _groupFilter === void 0 ? void 0 : _groupFilter.type) == "rule") {
              groupFilter = wrapInDefaultConj(groupFilter, config, spel.filter.not);
            }
            res = {
              groupFilter: groupFilter,
              groupFieldValue: groupFieldValue
            };
            if (!parentSpel) {
              // !aggr can't be in root, it should be compared with something
              res = undefined;
              meta.errors.push("Unexpected !aggr in root");
            }
          } else if (spel.type == "ternary") {
            var _children = {};
            spel.val.forEach(function (v) {
              var _v = _slicedToArray$1(v, 2),
                cond = _v[0],
                val = _v[1];
              var caseI = buildCase(cond, val, conv, config, meta, spel);
              if (caseI) {
                _children[caseI.id] = caseI;
              }
            });
            res = {
              type: "switch_group",
              id: uuid$1(),
              children1: _children,
              properties: {}
            };
          } else {
            res = convertArg(spel, conv, config, meta, parentSpel);
            if (res && !res.type && !parentSpel) {
              // try to parse whole `"1"` as ternary
              var sw = buildSimpleSwitch(spel, conv, config, meta);
              if (sw) {
                res = sw;
              } else {
                res = undefined;
                meta.errors.push("Can't convert rule of type ".concat(spel.type, ", it looks like var/literal"));
              }
            }
          }
          return res;
        };
        var buildSimpleSwitch = function buildSimpleSwitch(val, conv, config, meta) {
          var children1 = {};
          var cond = null;
          var caseI = buildCase(cond, val, conv, config, meta);
          if (caseI) {
            children1[caseI.id] = caseI;
          }
          var res = {
            type: "switch_group",
            id: uuid$1(),
            children1: children1,
            properties: {}
          };
          return res;
        };
        var buildCase = function buildCase(cond, val, conv, config, meta) {
          var spel = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
          var valProperties = buildCaseValProperties(config, meta, conv, val, spel);
          var caseI;
          if (cond) {
            caseI = convertToTree(cond, conv, config, meta, spel);
            if (caseI && caseI.type) {
              if (caseI.type != "group") {
                caseI = wrapInDefaultConj(caseI, config);
              }
              caseI.type = "case_group";
            } else {
              meta.errors.push("Unexpected case: ".concat(JSON.stringify(caseI)));
              caseI = undefined;
            }
          } else {
            caseI = {
              id: uuid$1(),
              type: "case_group",
              properties: {}
            };
          }
          if (caseI) {
            caseI.properties = _objectSpread$l(_objectSpread$l({}, caseI.properties), valProperties);
          }
          return caseI;
        };
        var buildCaseValueConcat = function buildCaseValueConcat(spel, conv, config, meta) {
          var flat = [];
          function _processConcatChildren(children) {
            children.map(function (child) {
              if (child.type == "op-plus") {
                _processConcatChildren(child.children);
              } else {
                var convertedChild = convertArg(child, conv, config, meta, spel);
                if (convertedChild) {
                  flat.push(convertedChild);
                } else {
                  meta.errors.push("Can't convert ".concat(child.type, " in concatenation"));
                }
              }
            });
          }
          _processConcatChildren(spel.children);
          return {
            valueSrc: "value",
            valueType: "case_value",
            value: flat
          };
        };
        var buildCaseValProperties = function buildCaseValProperties(config, meta, conv, val) {
          var spel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          var valProperties = {};
          var convVal;
          if ((val === null || val === void 0 ? void 0 : val.type) == "op-plus") {
            convVal = buildCaseValueConcat(val, conv, config, meta);
          } else {
            convVal = convertArg(val, conv, config, meta, spel);
          }
          var widgetDef = config.widgets["case_value"];
          var importCaseValue = widgetDef === null || widgetDef === void 0 ? void 0 : widgetDef.spelImportValue;
          if (importCaseValue) {
            var _importCaseValue = importCaseValue(convVal),
              _importCaseValue2 = _slicedToArray$1(_importCaseValue, 2),
              normVal = _importCaseValue2[0],
              normErrors = _importCaseValue2[1];
            normErrors.map(function (e) {
              return meta.errors.push(e);
            });
            if (normVal) {
              valProperties = {
                value: [normVal],
                valueSrc: ["value"],
                valueType: ["case_value"]
              };
            }
          } else {
            meta.errors.push("No fucntion to import case value");
          }
          return valProperties;
        };
        var wrapInDefaultConj = function wrapInDefaultConj(rule, config) {
          var not = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          return {
            type: "group",
            id: uuid$1(),
            children1: _defineProperty$4({}, rule.id, rule),
            properties: {
              conjunction: defaultConjunction(config),
              not: not || false
            }
          };
        };
        const Import = /*#__PURE__*/Object.freeze( /*#__PURE__*/Object.defineProperty({
          __proto__: null,
          _loadFromJsonLogic,
          _loadFromSpel,
          checkTree,
          getTree,
          isImmutableTree,
          isJsonLogic,
          isTree,
          isValidTree,
          loadFromJsonLogic,
          loadFromSpel,
          loadTree
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
          try {
            var info = gen[key](arg);
            var value = info.value;
          } catch (error) {
            reject(error);
            return;
          }
          if (info.done) {
            resolve(value);
          } else {
            Promise.resolve(value).then(_next, _throw);
          }
        }
        function _asyncToGenerator(fn) {
          return function () {
            var self = this,
              args = arguments;
            return new Promise(function (resolve, reject) {
              var gen = fn.apply(self, args);
              function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
              }
              function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
              }
              _next(undefined);
            });
          };
        }
        var regeneratorRuntime$1 = {
          exports: {}
        };
        var _typeof = {
          exports: {}
        };
        (function (module) {
          function _typeof(obj) {
            "@babel/helpers - typeof";

            return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
              return typeof obj;
            } : function (obj) {
              return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
          }
          module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
        })(_typeof);
        var _typeofExports = _typeof.exports;
        (function (module) {
          var _typeof = _typeofExports["default"];
          function _regeneratorRuntime() {
            module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
              return exports;
            }, module.exports.__esModule = true, module.exports["default"] = module.exports;
            var exports = {},
              Op = Object.prototype,
              hasOwn = Op.hasOwnProperty,
              defineProperty = Object.defineProperty || function (obj, key, desc) {
                obj[key] = desc.value;
              },
              $Symbol = "function" == typeof Symbol ? Symbol : {},
              iteratorSymbol = $Symbol.iterator || "@@iterator",
              asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
              toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
            function define(obj, key, value) {
              return Object.defineProperty(obj, key, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
              }), obj[key];
            }
            try {
              define({}, "");
            } catch (err) {
              define = function define(obj, key, value) {
                return obj[key] = value;
              };
            }
            function wrap(innerFn, outerFn, self, tryLocsList) {
              var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
                generator = Object.create(protoGenerator.prototype),
                context = new Context(tryLocsList || []);
              return defineProperty(generator, "_invoke", {
                value: makeInvokeMethod(innerFn, self, context)
              }), generator;
            }
            function tryCatch(fn, obj, arg) {
              try {
                return {
                  type: "normal",
                  arg: fn.call(obj, arg)
                };
              } catch (err) {
                return {
                  type: "throw",
                  arg: err
                };
              }
            }
            exports.wrap = wrap;
            var ContinueSentinel = {};
            function Generator() {}
            function GeneratorFunction() {}
            function GeneratorFunctionPrototype() {}
            var IteratorPrototype = {};
            define(IteratorPrototype, iteratorSymbol, function () {
              return this;
            });
            var getProto = Object.getPrototypeOf,
              NativeIteratorPrototype = getProto && getProto(getProto(values([])));
            NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
            var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
            function defineIteratorMethods(prototype) {
              ["next", "throw", "return"].forEach(function (method) {
                define(prototype, method, function (arg) {
                  return this._invoke(method, arg);
                });
              });
            }
            function AsyncIterator(generator, PromiseImpl) {
              function invoke(method, arg, resolve, reject) {
                var record = tryCatch(generator[method], generator, arg);
                if ("throw" !== record.type) {
                  var result = record.arg,
                    value = result.value;
                  return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
                    invoke("next", value, resolve, reject);
                  }, function (err) {
                    invoke("throw", err, resolve, reject);
                  }) : PromiseImpl.resolve(value).then(function (unwrapped) {
                    result.value = unwrapped, resolve(result);
                  }, function (error) {
                    return invoke("throw", error, resolve, reject);
                  });
                }
                reject(record.arg);
              }
              var previousPromise;
              defineProperty(this, "_invoke", {
                value: function value(method, arg) {
                  function callInvokeWithMethodAndArg() {
                    return new PromiseImpl(function (resolve, reject) {
                      invoke(method, arg, resolve, reject);
                    });
                  }
                  return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
                }
              });
            }
            function makeInvokeMethod(innerFn, self, context) {
              var state = "suspendedStart";
              return function (method, arg) {
                if ("executing" === state) throw new Error("Generator is already running");
                if ("completed" === state) {
                  if ("throw" === method) throw arg;
                  return doneResult();
                }
                for (context.method = method, context.arg = arg;;) {
                  var delegate = context.delegate;
                  if (delegate) {
                    var delegateResult = maybeInvokeDelegate(delegate, context);
                    if (delegateResult) {
                      if (delegateResult === ContinueSentinel) continue;
                      return delegateResult;
                    }
                  }
                  if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
                    if ("suspendedStart" === state) throw state = "completed", context.arg;
                    context.dispatchException(context.arg);
                  } else "return" === context.method && context.abrupt("return", context.arg);
                  state = "executing";
                  var record = tryCatch(innerFn, self, context);
                  if ("normal" === record.type) {
                    if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
                    return {
                      value: record.arg,
                      done: context.done
                    };
                  }
                  "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
                }
              };
            }
            function maybeInvokeDelegate(delegate, context) {
              var methodName = context.method,
                method = delegate.iterator[methodName];
              if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
              var record = tryCatch(method, delegate.iterator, context.arg);
              if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
              var info = record.arg;
              return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
            }
            function pushTryEntry(locs) {
              var entry = {
                tryLoc: locs[0]
              };
              1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
            }
            function resetTryEntry(entry) {
              var record = entry.completion || {};
              record.type = "normal", delete record.arg, entry.completion = record;
            }
            function Context(tryLocsList) {
              this.tryEntries = [{
                tryLoc: "root"
              }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
            }
            function values(iterable) {
              if (iterable) {
                var iteratorMethod = iterable[iteratorSymbol];
                if (iteratorMethod) return iteratorMethod.call(iterable);
                if ("function" == typeof iterable.next) return iterable;
                if (!isNaN(iterable.length)) {
                  var i = -1,
                    next = function next() {
                      for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
                      return next.value = undefined, next.done = !0, next;
                    };
                  return next.next = next;
                }
              }
              return {
                next: doneResult
              };
            }
            function doneResult() {
              return {
                value: undefined,
                done: !0
              };
            }
            return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
              value: GeneratorFunctionPrototype,
              configurable: !0
            }), defineProperty(GeneratorFunctionPrototype, "constructor", {
              value: GeneratorFunction,
              configurable: !0
            }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
              var ctor = "function" == typeof genFun && genFun.constructor;
              return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
            }, exports.mark = function (genFun) {
              return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
            }, exports.awrap = function (arg) {
              return {
                __await: arg
              };
            }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
              return this;
            }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
              void 0 === PromiseImpl && (PromiseImpl = Promise);
              var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
              return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
                return result.done ? result.value : iter.next();
              });
            }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
              return this;
            }), define(Gp, "toString", function () {
              return "[object Generator]";
            }), exports.keys = function (val) {
              var object = Object(val),
                keys = [];
              for (var key in object) keys.push(key);
              return keys.reverse(), function next() {
                for (; keys.length;) {
                  var key = keys.pop();
                  if (key in object) return next.value = key, next.done = !1, next;
                }
                return next.done = !0, next;
              };
            }, exports.values = values, Context.prototype = {
              constructor: Context,
              reset: function reset(skipTempReset) {
                if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
              },
              stop: function stop() {
                this.done = !0;
                var rootRecord = this.tryEntries[0].completion;
                if ("throw" === rootRecord.type) throw rootRecord.arg;
                return this.rval;
              },
              dispatchException: function dispatchException(exception) {
                if (this.done) throw exception;
                var context = this;
                function handle(loc, caught) {
                  return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
                }
                for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                  var entry = this.tryEntries[i],
                    record = entry.completion;
                  if ("root" === entry.tryLoc) return handle("end");
                  if (entry.tryLoc <= this.prev) {
                    var hasCatch = hasOwn.call(entry, "catchLoc"),
                      hasFinally = hasOwn.call(entry, "finallyLoc");
                    if (hasCatch && hasFinally) {
                      if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                      if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                    } else if (hasCatch) {
                      if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                    } else {
                      if (!hasFinally) throw new Error("try statement without catch or finally");
                      if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                    }
                  }
                }
              },
              abrupt: function abrupt(type, arg) {
                for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                  var entry = this.tryEntries[i];
                  if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                    var finallyEntry = entry;
                    break;
                  }
                }
                finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
                var record = finallyEntry ? finallyEntry.completion : {};
                return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
              },
              complete: function complete(record, afterLoc) {
                if ("throw" === record.type) throw record.arg;
                return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
              },
              finish: function finish(finallyLoc) {
                for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                  var entry = this.tryEntries[i];
                  if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
                }
              },
              "catch": function _catch(tryLoc) {
                for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                  var entry = this.tryEntries[i];
                  if (entry.tryLoc === tryLoc) {
                    var record = entry.completion;
                    if ("throw" === record.type) {
                      var thrown = record.arg;
                      resetTryEntry(entry);
                    }
                    return thrown;
                  }
                }
                throw new Error("illegal catch attempt");
              },
              delegateYield: function delegateYield(iterable, resultName, nextLoc) {
                return this.delegate = {
                  iterator: values(iterable),
                  resultName: resultName,
                  nextLoc: nextLoc
                }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
              }
            }, exports;
          }
          module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
        })(regeneratorRuntime$1);
        var regeneratorRuntimeExports = regeneratorRuntime$1.exports;

        // TODO(Babel 8): Remove this file.

        var runtime = regeneratorRuntimeExports();
        var regenerator = runtime;

        // Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
        try {
          regeneratorRuntime = runtime;
        } catch (accidentalStrictMode) {
          if (typeof globalThis === "object") {
            globalThis.regeneratorRuntime = runtime;
          } else {
            Function("r", "regeneratorRuntime = r")(runtime);
          }
        }
        const _regeneratorRuntime = /*@__PURE__*/getDefaultExportFromCjs(regenerator);
        var simulateAsyncFetch = function simulateAsyncFetch(all) {
          var cPageSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;
          return /*#__PURE__*/function () {
            var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(search, offset, meta) {
              var pageSize, filtered, currentOffset, values, newOffset, hasMore;
              return _regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    pageSize = meta.pageSize != undefined ? meta.pageSize : cPageSize;
                    filtered = listValuesToArray$1(all).filter(function (_ref2) {
                      var title = _ref2.title;
                      return search == null ? true : title.toUpperCase().indexOf(search.toUpperCase()) != -1;
                    });
                    pageSize ? Math.ceil(filtered.length / pageSize) : 0;
                    currentOffset = offset || 0;
                    values = pageSize ? filtered.slice(currentOffset, currentOffset + pageSize) : filtered;
                    newOffset = pageSize ? currentOffset + values.length : null;
                    hasMore = pageSize ? newOffset < filtered.length : false;
                    console.debug("simulateAsyncFetch", {
                      search: search,
                      offset: offset,
                      values: values,
                      hasMore: hasMore,
                      filtered: filtered
                    });
                    _context.next = 11;
                    return sleep(delay);
                  case 11:
                    return _context.abrupt("return", {
                      values: values,
                      hasMore: hasMore
                    });
                  case 12:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            }));
            return function (_x, _x2, _x3) {
              return _ref.apply(this, arguments);
            };
          }();
        };
        var mergeListValues$1 = function mergeListValues(values, newValues) {
          var toStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          if (!newValues) return values;
          var old = values || [];
          var newFiltered = newValues.filter(function (v) {
            return old.find(function (av) {
              return av.value == v.value;
            }) == undefined;
          });
          var merged = toStart ? [].concat(_toConsumableArray(newFiltered), _toConsumableArray(old)) : [].concat(_toConsumableArray(old), _toConsumableArray(newFiltered));
          return merged;
        };
        var listValueToOption$1 = function listValueToOption(lv) {
          if (lv == null) return null;
          var title = lv.title,
            value = lv.value,
            disabled = lv.disabled,
            groupTitle = lv.groupTitle,
            renderTitle = lv.renderTitle;
          var option = {
            title: title,
            value: value
          };
          if (disabled) option.disabled = disabled;
          if (groupTitle) option.groupTitle = groupTitle;
          if (renderTitle) option.renderTitle = renderTitle;
          return option;
        };
        var getListValue$1 = function getListValue(selectedValue, listValues) {
          return mapListValues$5(listValues, function (lv) {
            return lv.value === selectedValue ? lv : null;
          }).filter(function (v) {
            return v !== null;
          }).shift();
        };
        const autocomplete = /*#__PURE__*/Object.freeze( /*#__PURE__*/Object.defineProperty({
          __proto__: null,
          getListValue: getListValue$1,
          listValueToOption: listValueToOption$1,
          mergeListValues: mergeListValues$1,
          simulateAsyncFetch
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        const BasicUtils = /*#__PURE__*/Object.freeze( /*#__PURE__*/Object.defineProperty({
          __proto__: null,
          Autocomplete: autocomplete,
          ConfigUtils: configUtils,
          DefaultUtils: defaultUtils,
          ExportUtils: _export,
          FuncUtils: funcUtils,
          ListUtils: listValues,
          RuleUtils: ruleUtils,
          TreeUtils: treeUtils,
          clone: clone$3,
          getSwitchValues,
          moment: hooks,
          uuid: uuid$1,
          validateAndFixTree: validateAndFixTree$1,
          validateTree
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        function ownKeys$k(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$k(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$k(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$k(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }

        //----------------------------  conjunctions

        var conjunctions$2 = {
          AND: {
            label: "And",
            mongoConj: "$and",
            jsonLogicConj: "and",
            sqlConj: "AND",
            spelConj: "and",
            spelConjs: ["and", "&&"],
            reversedConj: "OR",
            formatConj: function formatConj(children, conj, not, isForDisplay) {
              return children.size > 1 ? (not ? "NOT " : "") + "(" + children.join(" " + (isForDisplay ? "AND" : "&&") + " ") + ")" : (not ? "NOT (" : "") + children.first() + (not ? ")" : "");
            },
            sqlFormatConj: function sqlFormatConj(children, conj, not) {
              return children.size > 1 ? (not ? "NOT " : "") + "(" + children.join(" " + "AND" + " ") + ")" : (not ? "NOT (" : "") + children.first() + (not ? ")" : "");
            },
            spelFormatConj: function spelFormatConj(children, conj, not, omitBrackets) {
              if (not) omitBrackets = false;
              return children.size > 1 ? (not ? "!" : "") + (omitBrackets ? "" : "(") + children.join(" " + "&&" + " ") + (omitBrackets ? "" : ")") : (not ? "!(" : "") + children.first() + (not ? ")" : "");
            }
          },
          OR: {
            label: "Or",
            mongoConj: "$or",
            jsonLogicConj: "or",
            sqlConj: "OR",
            spelConj: "or",
            spelConjs: ["or", "||"],
            reversedConj: "AND",
            formatConj: function formatConj(children, conj, not, isForDisplay) {
              return children.size > 1 ? (not ? "NOT " : "") + "(" + children.join(" " + (isForDisplay ? "OR" : "||") + " ") + ")" : (not ? "NOT (" : "") + children.first() + (not ? ")" : "");
            },
            sqlFormatConj: function sqlFormatConj(children, conj, not) {
              return children.size > 1 ? (not ? "NOT " : "") + "(" + children.join(" " + "OR" + " ") + ")" : (not ? "NOT (" : "") + children.first() + (not ? ")" : "");
            },
            spelFormatConj: function spelFormatConj(children, conj, not, omitBrackets) {
              if (not) omitBrackets = false;
              return children.size > 1 ? (not ? "!" : "") + (omitBrackets ? "" : "(") + children.join(" " + "||" + " ") + (omitBrackets ? "" : ")") : (not ? "!(" : "") + children.first() + (not ? ")" : "");
            }
          }
        };

        //----------------------------  operators

        // helpers for mongo format
        var mongoFormatOp1 = function mongoFormatOp1(mop, mc, not, field, _op, value, useExpr, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
          var $field = typeof field == "string" && !field.startsWith("$") ? "$" + field : field;
          var mv = mc(value, fieldDef);
          if (mv === undefined) return undefined;
          if (not) {
            if (!useExpr && (!mop || mop == "$eq")) return _defineProperty$4({}, field, {
              "$ne": mv
            }); // short form
            return !useExpr ? _defineProperty$4({}, field, {
              "$not": _defineProperty$4({}, mop, mv)
            }) : {
              "$not": _defineProperty$4({}, mop, [$field, mv])
            };
          } else {
            if (!useExpr && (!mop || mop == "$eq")) return _defineProperty$4({}, field, mv); // short form
            return !useExpr ? _defineProperty$4({}, field, _defineProperty$4({}, mop, mv)) : _defineProperty$4({}, mop, [$field, mv]);
          }
        };
        var mongoFormatOp2 = function mongoFormatOp2(mops, not, field, _op, values, useExpr, valueSrcs, valueTypes, opDef, operatorOptions, fieldDef) {
          var $field = typeof field == "string" && !field.startsWith("$") ? "$" + field : field;
          if (not) {
            var _$not3;
            return !useExpr ? _defineProperty$4({}, field, {
              "$not": (_$not3 = {}, _defineProperty$4(_$not3, mops[0], values[0]), _defineProperty$4(_$not3, mops[1], values[1]), _$not3)
            }) : {
              "$not": {
                "$and": [_defineProperty$4({}, mops[0], [$field, values[0]]), _defineProperty$4({}, mops[1], [$field, values[1]])]
              }
            };
          } else {
            var _field2;
            return !useExpr ? _defineProperty$4({}, field, (_field2 = {}, _defineProperty$4(_field2, mops[0], values[0]), _defineProperty$4(_field2, mops[1], values[1]), _field2)) : {
              "$and": [_defineProperty$4({}, mops[0], [$field, values[0]]), _defineProperty$4({}, mops[1], [$field, values[1]])]
            };
          }
        };
        var operators$2 = {
          equal: {
            label: "==",
            labelForFormat: "==",
            sqlOp: "=",
            spelOp: "==",
            spelOps: ["==", "eq"],
            reversedOp: "not_equal",
            formatOp: function formatOp(field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) {
              var opStr = isForDisplay ? "=" : opDef.label;
              if (valueTypes == "boolean" && isForDisplay) return value == "No" ? "NOT ".concat(field) : "".concat(field);else return "".concat(field, " ").concat(opStr, " ").concat(value);
            },
            mongoFormatOp: mongoFormatOp1.bind(null, "$eq", function (v) {
              return v;
            }, false),
            jsonLogic: "==",
            elasticSearchQueryType: "term"
          },
          not_equal: {
            isNotOp: true,
            label: "!=",
            labelForFormat: "!=",
            sqlOp: "<>",
            spelOp: "!=",
            spelOps: ["!=", "ne"],
            reversedOp: "equal",
            formatOp: function formatOp(field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) {
              if (valueTypes == "boolean" && isForDisplay) return value == "No" ? "".concat(field) : "NOT ".concat(field);else return "".concat(field, " ").concat(opDef.label, " ").concat(value);
            },
            mongoFormatOp: mongoFormatOp1.bind(null, "$ne", function (v) {
              return v;
            }, false),
            jsonLogic: "!="
          },
          less: {
            label: "<",
            labelForFormat: "<",
            sqlOp: "<",
            spelOp: "<",
            spelOps: ["<", "lt"],
            reversedOp: "greater_or_equal",
            mongoFormatOp: mongoFormatOp1.bind(null, "$lt", function (v) {
              return v;
            }, false),
            jsonLogic: "<",
            elasticSearchQueryType: "range"
          },
          less_or_equal: {
            label: "<=",
            labelForFormat: "<=",
            sqlOp: "<=",
            spelOp: "<=",
            spelOps: ["<=", "le"],
            reversedOp: "greater",
            mongoFormatOp: mongoFormatOp1.bind(null, "$lte", function (v) {
              return v;
            }, false),
            jsonLogic: "<=",
            elasticSearchQueryType: "range"
          },
          greater: {
            label: ">",
            labelForFormat: ">",
            sqlOp: ">",
            spelOp: ">",
            spelOps: [">", "gt"],
            reversedOp: "less_or_equal",
            mongoFormatOp: mongoFormatOp1.bind(null, "$gt", function (v) {
              return v;
            }, false),
            jsonLogic: ">",
            elasticSearchQueryType: "range"
          },
          greater_or_equal: {
            label: ">=",
            labelForFormat: ">=",
            sqlOp: ">=",
            spelOp: ">=",
            spelOps: [">=", "ge"],
            reversedOp: "less",
            mongoFormatOp: mongoFormatOp1.bind(null, "$gte", function (v) {
              return v;
            }, false),
            jsonLogic: ">=",
            elasticSearchQueryType: "range"
          },
          like: {
            label: "Contains",
            labelForFormat: "Contains",
            reversedOp: "not_like",
            sqlOp: "LIKE",
            spelOp: ".contains",
            spelOps: ["matches", ".contains"],
            mongoFormatOp: mongoFormatOp1.bind(null, "$regex", function (v) {
              return typeof v == "string" ? escapeRegExp(v) : undefined;
            }, false),
            //jsonLogic: (field, op, val) => ({ "in": [val, field] }),
            jsonLogic: "in",
            _jsonLogicIsRevArgs: true,
            valueSources: ["value"],
            elasticSearchQueryType: "regexp"
          },
          not_like: {
            isNotOp: true,
            label: "Not contains",
            reversedOp: "like",
            labelForFormat: "Not Contains",
            sqlOp: "NOT LIKE",
            mongoFormatOp: mongoFormatOp1.bind(null, "$regex", function (v) {
              return typeof v == "string" ? escapeRegExp(v) : undefined;
            }, true),
            valueSources: ["value"]
          },
          starts_with: {
            label: "Starts with",
            labelForFormat: "Starts with",
            sqlOp: "LIKE",
            spelOp: ".startsWith",
            spelOps: ["matches", ".startsWith"],
            mongoFormatOp: mongoFormatOp1.bind(null, "$regex", function (v) {
              return typeof v == "string" ? "^" + escapeRegExp(v) : undefined;
            }, false),
            jsonLogic: undefined,
            // not supported
            valueSources: ["value"]
          },
          ends_with: {
            label: "Ends with",
            labelForFormat: "Ends with",
            sqlOp: "LIKE",
            spelOp: ".endsWith",
            spelOps: ["matches", ".endsWith"],
            mongoFormatOp: mongoFormatOp1.bind(null, "$regex", function (v) {
              return typeof v == "string" ? escapeRegExp(v) + "$" : undefined;
            }, false),
            jsonLogic: undefined,
            // not supported
            valueSources: ["value"]
          },
          between: {
            label: "Between",
            labelForFormat: "BETWEEN",
            sqlOp: "BETWEEN",
            cardinality: 2,
            formatOp: function formatOp(field, op, values, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay) {
              var valFrom = values.first();
              var valTo = values.get(1);
              if (isForDisplay) return "".concat(field, " BETWEEN ").concat(valFrom, " AND ").concat(valTo);else return "".concat(field, " >= ").concat(valFrom, " && ").concat(field, " <= ").concat(valTo);
            },
            spelFormatOp: function spelFormatOp(field, op, values, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) {
              var valFrom = values[0];
              var valTo = values[1];
              return "".concat(field, " >= ").concat(valFrom, " && ").concat(field, " <= ").concat(valTo);
            },
            mongoFormatOp: mongoFormatOp2.bind(null, ["$gte", "$lte"], false),
            valueLabels: ["Value from", "Value to"],
            textSeparators: [null, "and"],
            reversedOp: "not_between",
            jsonLogic: "<=",
            validateValues: function validateValues(values) {
              if (values[0] != undefined && values[1] != undefined) {
                return values[0] <= values[1] ? null : "Invalid range";
              }
              return null;
            },
            elasticSearchQueryType: function elasticSearchQueryType(type) {
              return type === "time" ? "filter" : "range";
            }
          },
          not_between: {
            isNotOp: true,
            label: "Not between",
            labelForFormat: "NOT BETWEEN",
            sqlOp: "NOT BETWEEN",
            cardinality: 2,
            formatOp: function formatOp(field, op, values, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay) {
              var valFrom = values.first();
              var valTo = values.get(1);
              if (isForDisplay) return "".concat(field, " NOT BETWEEN ").concat(valFrom, " AND ").concat(valTo);else return "(".concat(field, " < ").concat(valFrom, " || ").concat(field, " > ").concat(valTo, ")");
            },
            spelFormatOp: function spelFormatOp(field, op, values, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) {
              var valFrom = values[0];
              var valTo = values[1];
              return "(".concat(field, " < ").concat(valFrom, " || ").concat(field, " > ").concat(valTo, ")");
            },
            mongoFormatOp: mongoFormatOp2.bind(null, ["$gte", "$lte"], true),
            valueLabels: ["Value from", "Value to"],
            textSeparators: [null, "and"],
            reversedOp: "between",
            validateValues: function validateValues(values) {
              if (values[0] != undefined && values[1] != undefined) {
                return values[0] <= values[1] ? null : "Invalid range";
              }
              return null;
            }
          },
          is_empty: {
            label: "Is empty",
            labelForFormat: "IS EMPTY",
            cardinality: 0,
            reversedOp: "is_not_empty",
            formatOp: function formatOp(field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              return isForDisplay ? "".concat(field, " IS EMPTY") : "!".concat(field);
            },
            sqlFormatOp: function sqlFormatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
              var empty = sqlEmptyValue(fieldDef);
              return "COALESCE(".concat(field, ", ").concat(empty, ") = ").concat(empty);
            },
            spelFormatOp: function spelFormatOp(field, op, values, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) {
              //tip: is empty or null
              return "".concat(field, " <= ''");
            },
            mongoFormatOp: mongoFormatOp1.bind(null, "$in", function (v, fieldDef) {
              return [mongoEmptyValue(fieldDef), null];
            }, false),
            jsonLogic: "!"
          },
          is_not_empty: {
            isNotOp: true,
            label: "Is not empty",
            labelForFormat: "IS NOT EMPTY",
            cardinality: 0,
            reversedOp: "is_empty",
            formatOp: function formatOp(field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              return isForDisplay ? "".concat(field, " IS NOT EMPTY") : "!!".concat(field);
            },
            sqlFormatOp: function sqlFormatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
              var empty = sqlEmptyValue(fieldDef);
              return "COALESCE(".concat(field, ", ").concat(empty, ") <> ").concat(empty);
            },
            spelFormatOp: function spelFormatOp(field, op, values, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) {
              //tip: is not empty and not null
              return "".concat(field, " > ''");
            },
            mongoFormatOp: mongoFormatOp1.bind(null, "$nin", function (v, fieldDef) {
              return [mongoEmptyValue(fieldDef), null];
            }, false),
            jsonLogic: "!!",
            elasticSearchQueryType: "exists"
          },
          is_null: {
            label: "Is null",
            labelForFormat: "IS NULL",
            sqlOp: "IS NULL",
            cardinality: 0,
            reversedOp: "is_not_null",
            formatOp: function formatOp(field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              return isForDisplay ? "".concat(field, " IS NULL") : "!".concat(field);
            },
            spelFormatOp: function spelFormatOp(field, op, values, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) {
              return "".concat(field, " == null");
            },
            // check if value is null OR not exists
            mongoFormatOp: mongoFormatOp1.bind(null, "$eq", function (v) {
              return null;
            }, false),
            jsonLogic: "=="
          },
          is_not_null: {
            label: "Is not null",
            labelForFormat: "IS NOT NULL",
            sqlOp: "IS NOT NULL",
            cardinality: 0,
            reversedOp: "is_null",
            formatOp: function formatOp(field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              return isForDisplay ? "".concat(field, " IS NOT NULL") : "!!".concat(field);
            },
            spelFormatOp: function spelFormatOp(field, op, values, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) {
              return "".concat(field, " != null");
            },
            // check if value exists and is not null
            mongoFormatOp: mongoFormatOp1.bind(null, "$ne", function (v) {
              return null;
            }, false),
            jsonLogic: "!=",
            elasticSearchQueryType: "exists"
          },
          select_equals: {
            label: "==",
            labelForFormat: "==",
            sqlOp: "=",
            // enum/set
            formatOp: function formatOp(field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              var opStr = isForDisplay ? "=" : "==";
              return "".concat(field, " ").concat(opStr, " ").concat(value);
            },
            spelOp: "==",
            spelOps: ["==", "eq"],
            mongoFormatOp: mongoFormatOp1.bind(null, "$eq", function (v) {
              return v;
            }, false),
            reversedOp: "select_not_equals",
            jsonLogic: "==",
            elasticSearchQueryType: "term"
          },
          select_not_equals: {
            isNotOp: true,
            label: "!=",
            labelForFormat: "!=",
            sqlOp: "<>",
            // enum/set
            formatOp: function formatOp(field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              return "".concat(field, " != ").concat(value);
            },
            spelOp: "!=",
            spelOps: ["!=", "ne"],
            mongoFormatOp: mongoFormatOp1.bind(null, "$ne", function (v) {
              return v;
            }, false),
            reversedOp: "select_equals",
            jsonLogic: "!="
          },
          select_any_in: {
            label: "Any in",
            labelForFormat: "IN",
            sqlOp: "IN",
            formatOp: function formatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              if (valueSrc == "value") return "".concat(field, " IN (").concat(values.join(", "), ")");else return "".concat(field, " IN (").concat(values, ")");
            },
            sqlFormatOp: function sqlFormatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
              if (valueSrc == "value") {
                return "".concat(field, " IN (").concat(values.join(", "), ")");
              } else return undefined; // not supported
            },

            spelOp: "$contains",
            // tip: $ means first arg is object
            mongoFormatOp: mongoFormatOp1.bind(null, "$in", function (v) {
              return v;
            }, false),
            reversedOp: "select_not_any_in",
            jsonLogic: "in",
            elasticSearchQueryType: "term"
          },
          select_not_any_in: {
            isNotOp: true,
            label: "Not in",
            labelForFormat: "NOT IN",
            sqlOp: "NOT IN",
            formatOp: function formatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              if (valueSrc == "value") return "".concat(field, " NOT IN (").concat(values.join(", "), ")");else return "".concat(field, " NOT IN (").concat(values, ")");
            },
            sqlFormatOp: function sqlFormatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
              if (valueSrc == "value") {
                return "".concat(field, " NOT IN (").concat(values.join(", "), ")");
              } else return undefined; // not supported
            },

            mongoFormatOp: mongoFormatOp1.bind(null, "$nin", function (v) {
              return v;
            }, false),
            reversedOp: "select_any_in"
          },
          // it's not "contains all", but "contains any" operator
          multiselect_contains: {
            label: "Contains",
            labelForFormat: "CONTAINS",
            formatOp: function formatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              if (valueSrc == "value") return "".concat(field, " CONTAINS [").concat(values.join(", "), "]");else return "".concat(field, " CONTAINS ").concat(values);
            },
            reversedOp: "multiselect_not_contains",
            jsonLogic2: "some-in",
            jsonLogic: function jsonLogic(field, op, vals) {
              return {
                "some": [field, {
                  "in": [{
                    "var": ""
                  }, vals]
                }]
              };
            },
            //spelOp: ".containsAll",
            spelOp: "CollectionUtils.containsAny()",
            elasticSearchQueryType: "term",
            mongoFormatOp: mongoFormatOp1.bind(null, "$in", function (v) {
              return v;
            }, false)
          },
          multiselect_not_contains: {
            isNotOp: true,
            label: "Not contains",
            labelForFormat: "NOT CONTAINS",
            formatOp: function formatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              if (valueSrc == "value") return "".concat(field, " NOT CONTAINS [").concat(values.join(", "), "]");else return "".concat(field, " NOT CONTAINS ").concat(values);
            },
            reversedOp: "multiselect_contains"
          },
          multiselect_equals: {
            label: "Equals",
            labelForFormat: "==",
            sqlOp: "=",
            formatOp: function formatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              var opStr = isForDisplay ? "=" : "==";
              if (valueSrc == "value") return "".concat(field, " ").concat(opStr, " [").concat(values.join(", "), "]");else return "".concat(field, " ").concat(opStr, " ").concat(values);
            },
            sqlFormatOp: function sqlFormatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
              if (valueSrc == "value")
                // set
                return "".concat(field, " = '").concat(values.map(function (v) {
                  return SqlString$1.trim(v);
                }).join(","), "'");else return undefined; //not supported
            },

            spelOp: ".equals",
            mongoFormatOp: mongoFormatOp1.bind(null, "$eq", function (v) {
              return v;
            }, false),
            reversedOp: "multiselect_not_equals",
            jsonLogic2: "all-in",
            jsonLogic: function jsonLogic(field, op, vals) {
              return {
                // it's not "equals", but "includes" operator - just for example
                "all": [field, {
                  "in": [{
                    "var": ""
                  }, vals]
                }]
              };
            },
            elasticSearchQueryType: "term"
          },
          multiselect_not_equals: {
            isNotOp: true,
            label: "Not equals",
            labelForFormat: "!=",
            sqlOp: "<>",
            formatOp: function formatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              if (valueSrc == "value") return "".concat(field, " != [").concat(values.join(", "), "]");else return "".concat(field, " != ").concat(values);
            },
            sqlFormatOp: function sqlFormatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
              if (valueSrc == "value")
                // set
                return "".concat(field, " != '").concat(values.map(function (v) {
                  return SqlString$1.trim(v);
                }).join(","), "'");else return undefined; //not supported
            },

            mongoFormatOp: mongoFormatOp1.bind(null, "$ne", function (v) {
              return v;
            }, false),
            reversedOp: "multiselect_equals"
          },
          proximity: {
            label: "Proximity search",
            cardinality: 2,
            valueLabels: [{
              label: "Word 1",
              placeholder: "Enter first word"
            }, {
              label: "Word 2",
              placeholder: "Enter second word"
            }],
            textSeparators: [
              //'Word 1',
              //'Word 2'
            ],
            formatOp: function formatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
              var val1 = values.first();
              var val2 = values.get(1);
              var prox = operatorOptions.get("proximity");
              return "".concat(field, " ").concat(val1, " NEAR/").concat(prox, " ").concat(val2);
            },
            sqlFormatOp: function sqlFormatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {
              var val1 = values.first();
              var val2 = values.get(1);
              var aVal1 = SqlString$1.trim(val1);
              var aVal2 = SqlString$1.trim(val2);
              var prox = operatorOptions.get("proximity");
              return "CONTAINS(".concat(field, ", 'NEAR((").concat(aVal1, ", ").concat(aVal2, "), ").concat(prox, ")')");
            },
            mongoFormatOp: undefined,
            // not supported
            jsonLogic: undefined,
            // not supported
            options: {
              optionLabel: "Near",
              // label on top of "near" selectbox (for config.settings.showLabels==true)
              optionTextBefore: "Near",
              // label before "near" selectbox (for config.settings.showLabels==false)
              optionPlaceholder: "Select words between",
              // placeholder for "near" selectbox
              minProximity: 2,
              maxProximity: 10,
              defaults: {
                proximity: 2
              }
            }
          },
          some: {
            label: "Some",
            labelForFormat: "SOME",
            cardinality: 0,
            jsonLogic: "some",
            spelFormatOp: function spelFormatOp(filteredSize) {
              return "".concat(filteredSize, " > 0");
            },
            mongoFormatOp: mongoFormatOp1.bind(null, "$gt", function (v) {
              return 0;
            }, false)
          },
          all: {
            label: "All",
            labelForFormat: "ALL",
            cardinality: 0,
            jsonLogic: "all",
            spelFormatOp: function spelFormatOp(filteredSize, op, fullSize) {
              return "".concat(filteredSize, " == ").concat(fullSize);
            },
            mongoFormatOp: mongoFormatOp1.bind(null, "$eq", function (v) {
              return v;
            }, false)
          },
          none: {
            label: "None",
            labelForFormat: "NONE",
            cardinality: 0,
            jsonLogic: "none",
            spelFormatOp: function spelFormatOp(filteredSize) {
              return "".concat(filteredSize, " == 0");
            },
            mongoFormatOp: mongoFormatOp1.bind(null, "$eq", function (v) {
              return 0;
            }, false)
          }
        };

        //----------------------------  widgets

        var widgets$3 = {
          text: {
            type: "text",
            jsType: "string",
            valueSrc: "value",
            valueLabel: "String",
            valuePlaceholder: "Enter string",
            formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
              return isForDisplay ? stringifyForDisplay$1(val) : JSON.stringify(val);
            },
            spelFormatValue: function spelFormatValue(val, fieldDef, wgtDef, op, opDef) {
              if (opDef.spelOp == "matches" && op != "regex") {
                var regex;
                if (op == "starts_with") {
                  regex = "(?s)^".concat(escapeRegExp(val), ".*");
                } else if (op == "ends_with") {
                  regex = "(?s).*".concat(escapeRegExp(val), "$");
                } else {
                  // op == 'like'
                  regex = "(?s).*".concat(escapeRegExp(val), ".*"); //tip: can use (?sui) for case-insensitive
                }

                return spelEscape(regex);
              } else {
                return spelEscape(val);
              }
            },
            sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
              if (opDef.sqlOp == "LIKE" || opDef.sqlOp == "NOT LIKE") {
                return SqlString$1.escapeLike(val, op != "starts_with", op != "ends_with");
              } else {
                return SqlString$1.escape(val);
              }
            },
            toJS: function toJS(val, fieldSettings) {
              return val;
            },
            mongoFormatValue: function mongoFormatValue(val, fieldDef, wgtDef) {
              return val;
            }
          },
          textarea: {
            type: "text",
            jsType: "string",
            valueSrc: "value",
            valueLabel: "Text",
            valuePlaceholder: "Enter text",
            formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
              return isForDisplay ? stringifyForDisplay$1(val) : JSON.stringify(val);
            },
            sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
              if (opDef.sqlOp == "LIKE" || opDef.sqlOp == "NOT LIKE") {
                return SqlString$1.escapeLike(val, op != "starts_with", op != "ends_with");
              } else {
                return SqlString$1.escape(val);
              }
            },
            spelFormatValue: function spelFormatValue(val) {
              return spelEscape(val);
            },
            toJS: function toJS(val, fieldSettings) {
              return val;
            },
            mongoFormatValue: function mongoFormatValue(val, fieldDef, wgtDef) {
              return val;
            },
            fullWidth: true
          },
          number: {
            type: "number",
            jsType: "number",
            valueSrc: "value",
            valueLabel: "Number",
            valuePlaceholder: "Enter number",
            valueLabels: [{
              label: "Number from",
              placeholder: "Enter number from"
            }, {
              label: "Number to",
              placeholder: "Enter number to"
            }],
            formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
              return isForDisplay ? stringifyForDisplay$1(val) : JSON.stringify(val);
            },
            sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
              return SqlString$1.escape(val);
            },
            spelFormatValue: function spelFormatValue(val, fieldDef, wgtDef) {
              var isFloat = wgtDef.step && !Number.isInteger(wgtDef.step);
              return spelEscape(val, isFloat);
            },
            toJS: function toJS(val, fieldSettings) {
              return val;
            },
            mongoFormatValue: function mongoFormatValue(val, fieldDef, wgtDef) {
              return val;
            }
          },
          slider: {
            type: "number",
            jsType: "number",
            valueSrc: "value",
            valueLabel: "Number",
            valuePlaceholder: "Enter number or move slider",
            formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
              return isForDisplay ? stringifyForDisplay$1(val) : JSON.stringify(val);
            },
            sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
              return SqlString$1.escape(val);
            },
            spelFormatValue: function spelFormatValue(val) {
              return spelEscape(val);
            },
            toJS: function toJS(val, fieldSettings) {
              return val;
            },
            mongoFormatValue: function mongoFormatValue(val, fieldDef, wgtDef) {
              return val;
            }
          },
          select: {
            type: "select",
            jsType: "string",
            valueSrc: "value",
            valueLabel: "Value",
            valuePlaceholder: "Select value",
            formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
              var valLabel = getTitleInListValues$1(fieldDef.fieldSettings.treeValues || fieldDef.fieldSettings.listValues || fieldDef.asyncListValues, val);
              return isForDisplay ? stringifyForDisplay$1(valLabel) : JSON.stringify(val);
            },
            sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
              return SqlString$1.escape(val);
            },
            spelFormatValue: function spelFormatValue(val) {
              return spelEscape(val);
            },
            toJS: function toJS(val, fieldSettings) {
              return val;
            },
            mongoFormatValue: function mongoFormatValue(val, fieldDef, wgtDef) {
              return val;
            }
          },
          multiselect: {
            type: "multiselect",
            jsType: "array",
            valueSrc: "value",
            valueLabel: "Values",
            valuePlaceholder: "Select values",
            formatValue: function formatValue(vals, fieldDef, wgtDef, isForDisplay) {
              var valsLabels = vals.map(function (v) {
                return getTitleInListValues$1(fieldDef.fieldSettings.treeValues || fieldDef.fieldSettings.listValues || fieldDef.asyncListValues, v);
              });
              return isForDisplay ? valsLabels.map(stringifyForDisplay$1) : vals.map(JSON.stringify);
            },
            sqlFormatValue: function sqlFormatValue(vals, fieldDef, wgtDef, op, opDef) {
              return vals.map(function (v) {
                return SqlString$1.escape(v);
              });
            },
            spelFormatValue: function spelFormatValue(vals, fieldDef, wgtDef, op, opDef) {
              var isCallable = opDef.spelOp && opDef.spelOp[0] == "$";
              var res = spelEscape(vals); // inline list
              if (isCallable) {
                // `{1,2}.contains(1)` NOT works
                // `{1,2}.?[true].contains(1)` works
                res = spelFixList(res);
              }
              return res;
            },
            toJS: function toJS(val, fieldSettings) {
              return val;
            },
            mongoFormatValue: function mongoFormatValue(val, fieldDef, wgtDef) {
              return val;
            }
          },
          date: {
            type: "date",
            jsType: "string",
            valueSrc: "value",
            dateFormat: "DD.MM.YYYY",
            valueFormat: "YYYY-MM-DD",
            useKeyboard: true,
            valueLabel: "Date",
            valuePlaceholder: "Enter date",
            valueLabels: [{
              label: "Date from",
              placeholder: "Enter date from"
            }, {
              label: "Date to",
              placeholder: "Enter date to"
            }],
            formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
              var dateVal = hooks(val, wgtDef.valueFormat);
              return isForDisplay ? dateVal.format(wgtDef.dateFormat) : JSON.stringify(val);
            },
            sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
              var dateVal = hooks(val, wgtDef.valueFormat);
              return SqlString$1.escape(dateVal.format("YYYY-MM-DD"));
            },
            spelFormatValue: function spelFormatValue(val, fieldDef, wgtDef, op, opDef) {
              var dateVal = hooks(val, wgtDef.valueFormat);
              return "new java.text.SimpleDateFormat('yyyy-MM-dd').parse('".concat(dateVal.format("YYYY-MM-DD"), "')");
            },
            jsonLogic: function jsonLogic(val, fieldDef, wgtDef) {
              return hooks(val, wgtDef.valueFormat).toDate();
            },
            toJS: function toJS(val, fieldSettings) {
              var dateVal = hooks(val, fieldSettings.valueFormat);
              return dateVal.isValid() ? dateVal.toDate() : undefined;
            },
            mongoFormatValue: function mongoFormatValue(val, fieldDef, wgtDef) {
              var dateVal = hooks(val, wgtDef.valueFormat);
              return dateVal.isValid() ? dateVal.toDate() : undefined;
            }
          },
          time: {
            type: "time",
            jsType: "string",
            valueSrc: "value",
            timeFormat: "HH:mm",
            valueFormat: "HH:mm:ss",
            use12Hours: false,
            useKeyboard: true,
            valueLabel: "Time",
            valuePlaceholder: "Enter time",
            valueLabels: [{
              label: "Time from",
              placeholder: "Enter time from"
            }, {
              label: "Time to",
              placeholder: "Enter time to"
            }],
            formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
              var dateVal = hooks(val, wgtDef.valueFormat);
              return isForDisplay ? dateVal.format(wgtDef.timeFormat) : JSON.stringify(val);
            },
            sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
              var dateVal = hooks(val, wgtDef.valueFormat);
              return SqlString$1.escape(dateVal.format("HH:mm:ss"));
            },
            spelFormatValue: function spelFormatValue(val, fieldDef, wgtDef, op, opDef) {
              var dateVal = hooks(val, wgtDef.valueFormat);
              return "T(java.time.LocalTime).parse('".concat(dateVal.format("HH:mm:ss"), "')");
              //return `new java.text.SimpleDateFormat('HH:mm:ss').parse('${dateVal.format("HH:mm:ss")}')`;
            },

            jsonLogic: function jsonLogic(val, fieldDef, wgtDef) {
              // return seconds of day
              var dateVal = hooks(val, wgtDef.valueFormat);
              return dateVal.get("hour") * 60 * 60 + dateVal.get("minute") * 60 + dateVal.get("second");
            },
            toJS: function toJS(val, fieldSettings) {
              // return seconds of day
              var dateVal = hooks(val, fieldSettings.valueFormat);
              return dateVal.isValid() ? dateVal.get("hour") * 60 * 60 + dateVal.get("minute") * 60 + dateVal.get("second") : undefined;
            },
            mongoFormatValue: function mongoFormatValue(val, fieldDef, wgtDef) {
              // return seconds of day
              var dateVal = hooks(val, wgtDef.valueFormat);
              return dateVal.get("hour") * 60 * 60 + dateVal.get("minute") * 60 + dateVal.get("second");
            },
            elasticSearchFormatValue: function elasticSearchFormatValue(queryType, value, operator, fieldName) {
              return {
                script: {
                  script: {
                    source: "doc[".concat(fieldName, "][0].getHour() >== params.min && doc[").concat(fieldName, "][0].getHour() <== params.max"),
                    params: {
                      min: value[0],
                      max: value[1]
                    }
                  }
                }
              };
            }
          },
          datetime: {
            type: "datetime",
            jsType: "string",
            valueSrc: "value",
            timeFormat: "HH:mm",
            dateFormat: "DD.MM.YYYY",
            valueFormat: "YYYY-MM-DD HH:mm:ss",
            use12Hours: false,
            useKeyboard: true,
            valueLabel: "Datetime",
            valuePlaceholder: "Enter datetime",
            valueLabels: [{
              label: "Datetime from",
              placeholder: "Enter datetime from"
            }, {
              label: "Datetime to",
              placeholder: "Enter datetime to"
            }],
            formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
              var dateVal = hooks(val, wgtDef.valueFormat);
              return isForDisplay ? dateVal.format(wgtDef.dateFormat + " " + wgtDef.timeFormat) : JSON.stringify(val);
            },
            sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
              var dateVal = hooks(val, wgtDef.valueFormat);
              return SqlString$1.escape(dateVal.toDate());
            },
            spelFormatValue: function spelFormatValue(val, fieldDef, wgtDef, op, opDef) {
              var dateVal = hooks(val, wgtDef.valueFormat);
              return "new java.text.SimpleDateFormat('yyyy-MM-dd HH:mm:ss').parse('".concat(dateVal.format("YYYY-MM-DD HH:mm:ss"), "')");
            },
            jsonLogic: function jsonLogic(val, fieldDef, wgtDef) {
              return hooks(val, wgtDef.valueFormat).toDate();
            },
            toJS: function toJS(val, fieldSettings) {
              var dateVal = hooks(val, fieldSettings.valueFormat);
              return dateVal.isValid() ? dateVal.toDate() : undefined;
            },
            mongoFormatValue: function mongoFormatValue(val, fieldDef, wgtDef) {
              var dateVal = hooks(val, wgtDef.valueFormat);
              return dateVal.isValid() ? dateVal.toDate() : undefined;
            }
          },
          "boolean": {
            type: "boolean",
            jsType: "boolean",
            valueSrc: "value",
            labelYes: "Yes",
            labelNo: "No",
            formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
              return isForDisplay ? val ? "Yes" : "No" : JSON.stringify(!!val);
            },
            sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
              return SqlString$1.escape(val);
            },
            spelFormatValue: function spelFormatValue(val, fieldDef, wgtDef, op, opDef) {
              return spelEscape(val);
            },
            defaultValue: false,
            toJS: function toJS(val, fieldSettings) {
              return val;
            },
            mongoFormatValue: function mongoFormatValue(val, fieldDef, wgtDef) {
              return val;
            }
          },
          field: {
            valueSrc: "field",
            formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay, op, opDef, rightFieldDef) {
              return isForDisplay ? rightFieldDef.label || val : val;
            },
            sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef, rightFieldDef) {
              return val;
            },
            spelFormatValue: function spelFormatValue(val, fieldDef, wgtDef, op, opDef) {
              return val;
            },
            valueLabel: "Field to compare",
            valuePlaceholder: "Select field to compare"
          },
          func: {
            valueSrc: "func",
            valueLabel: "Function",
            valuePlaceholder: "Select function"
          },
          case_value: {
            valueSrc: "value",
            type: "case_value",
            spelFormatValue: function spelFormatValue(val) {
              return spelEscape(val === "" ? null : val);
            },
            spelImportValue: function spelImportValue(val) {
              return [val.value, []];
            }
          }
        };

        //----------------------------  types

        var types$4 = {
          text: {
            defaultOperator: "equal",
            mainWidget: "text",
            widgets: {
              text: {
                operators: ["equal", "not_equal", "like", "not_like", "starts_with", "ends_with", "proximity", "is_empty", "is_not_empty", "is_null", "is_not_null"],
                widgetProps: {},
                opProps: {}
              },
              textarea: {
                operators: ["equal", "not_equal", "like", "not_like", "starts_with", "ends_with", "is_empty", "is_not_empty", "is_null", "is_not_null"],
                widgetProps: {},
                opProps: {}
              },
              field: {
                operators: [
                //unary ops (like `is_empty`) will be excluded anyway, see getWidgetsForFieldOp()
                "equal", "not_equal", "proximity" //can exclude if you want
                ]
              }
            }
          },

          number: {
            defaultOperator: "equal",
            mainWidget: "number",
            widgets: {
              number: {
                operators: ["equal", "not_equal", "less", "less_or_equal", "greater", "greater_or_equal", "between", "not_between",
                // "is_empty",
                // "is_not_empty",
                "is_null", "is_not_null"]
              },
              slider: {
                operators: ["equal", "not_equal", "less", "less_or_equal", "greater", "greater_or_equal",
                // "is_empty",
                // "is_not_empty",
                "is_null", "is_not_null"]
              }
            }
          },
          date: {
            defaultOperator: "equal",
            widgets: {
              date: {
                operators: ["equal", "not_equal", "less", "less_or_equal", "greater", "greater_or_equal", "between", "not_between",
                // "is_empty",
                // "is_not_empty",
                "is_null", "is_not_null"]
              }
            }
          },
          time: {
            defaultOperator: "equal",
            widgets: {
              time: {
                operators: ["equal", "not_equal", "less", "less_or_equal", "greater", "greater_or_equal", "between", "not_between",
                // "is_empty",
                // "is_not_empty",
                "is_null", "is_not_null"]
              }
            }
          },
          datetime: {
            defaultOperator: "equal",
            widgets: {
              datetime: {
                operators: ["equal", "not_equal", "less", "less_or_equal", "greater", "greater_or_equal", "between", "not_between",
                // "is_empty",
                // "is_not_empty",
                "is_null", "is_not_null"]
              }
            }
          },
          select: {
            mainWidget: "select",
            defaultOperator: "select_equals",
            widgets: {
              select: {
                operators: ["select_equals", "select_not_equals",
                // "is_empty",
                // "is_not_empty",
                "is_null", "is_not_null"]
              },
              multiselect: {
                operators: ["select_any_in", "select_not_any_in",
                // "is_empty",
                // "is_not_empty",
                "is_null", "is_not_null"]
              }
            }
          },
          multiselect: {
            defaultOperator: "multiselect_equals",
            widgets: {
              multiselect: {
                operators: ["multiselect_contains", "multiselect_not_contains", "multiselect_equals", "multiselect_not_equals",
                // "is_empty",
                // "is_not_empty",
                "is_null", "is_not_null"]
              }
            }
          },
          "boolean": {
            defaultOperator: "equal",
            widgets: {
              "boolean": {
                operators: ["equal", "not_equal", "is_null", "is_not_null"],
                widgetProps: {
                  //you can enable this if you don't use fields as value sources
                  // hideOperator: true,
                  // operatorInlineLabel: "is",
                }
              },
              field: {
                operators: ["equal", "not_equal"]
              }
            }
          },
          "!group": {
            defaultOperator: "some",
            mainWidget: "number",
            widgets: {
              number: {
                widgetProps: {
                  min: 0
                },
                operators: [
                // w/o operand
                "some", "all", "none",
                // w/ operand - count
                "equal", "not_equal", "less", "less_or_equal", "greater", "greater_or_equal", "between", "not_between"],
                opProps: {
                  equal: {
                    label: "Count =="
                  },
                  not_equal: {
                    label: "Count !="
                  },
                  less: {
                    label: "Count <"
                  },
                  less_or_equal: {
                    label: "Count <="
                  },
                  greater: {
                    label: "Count >"
                  },
                  greater_or_equal: {
                    label: "Count >="
                  },
                  between: {
                    label: "Count between"
                  },
                  not_between: {
                    label: "Count not between"
                  }
                }
              }
            }
          },
          "case_value": {
            mainWidget: "case_value",
            widgets: {
              case_value: {}
            }
          }
        };

        //----------------------------  settings

        var settings$3 = _objectSpread$k(_objectSpread$k({}, settings$4), {}, {
          convertableWidgets: {
            "number": ["slider", "rangeslider"],
            "slider": ["number", "rangeslider"],
            "rangeslider": ["number", "slider"],
            "text": ["textarea"],
            "textarea": ["text"]
          },
          formatSpelField: function formatSpelField(field, parentField, parts, partsExt, fieldDefinition, config) {
            var fieldName = partsExt.map(function (_ref12, ind) {
              var key = _ref12.key,
                parent = _ref12.parent;
              if (ind == 0) {
                if (parent == "[map]") return "#this[".concat(spelEscape(key), "]");else if (parent == "[class]") return key;else return key;
              } else {
                if (parent == "map" || parent == "[map]") return "[".concat(spelEscape(key), "]");else if (parent == "class" || parent == "[class]") return ".".concat(key);else return ".".concat(key);
              }
            }).join("");
            if (fieldDefinition.isSpelVariable) {
              fieldName = "#" + fieldName;
            }
            return fieldName;
          },
          sqlFormatReverse: function sqlFormatReverse(q) {
            if (q == undefined) return undefined;
            return "NOT(" + q + ")";
          },
          spelFormatReverse: function spelFormatReverse(q) {
            if (q == undefined) return undefined;
            return "!(" + q + ")";
          },
          formatReverse: function formatReverse(q, operator, reversedOp, operatorDefinition, revOperatorDefinition, isForDisplay) {
            if (q == undefined) return undefined;
            if (isForDisplay) return "NOT (" + q + ")";else return "!(" + q + ")";
          },
          formatAggr: function formatAggr(whereStr, aggrField, operator, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay, aggrFieldDef) {
            var labelForFormat = opDef.labelForFormat,
              cardinality = opDef.cardinality;
            if (cardinality == 0) {
              var cond = whereStr ? " HAVE ".concat(whereStr) : "";
              return "".concat(labelForFormat, " OF ").concat(aggrField).concat(cond);
            } else if (cardinality == undefined || cardinality == 1) {
              var _cond = whereStr ? " WHERE ".concat(whereStr) : "";
              return "COUNT OF ".concat(aggrField).concat(_cond, " ").concat(labelForFormat, " ").concat(value);
            } else if (cardinality == 2) {
              var _cond2 = whereStr ? " WHERE ".concat(whereStr) : "";
              var valFrom = value.first();
              var valTo = value.get(1);
              return "COUNT OF ".concat(aggrField).concat(_cond2, " ").concat(labelForFormat, " ").concat(valFrom, " AND ").concat(valTo);
            }
          },
          jsonLogic: {
            groupVarKey: "var",
            altVarKey: "var",
            lockedOp: "locked"
          },
          canCompareFieldWithField: function canCompareFieldWithField(leftField, leftFieldConfig, rightField, rightFieldConfig) {
            //for type == 'select'/'multiselect' you can check listValues
            return true;
          },
          // enable compare fields
          valueSourcesInfo: {
            value: {
              label: "Value"
            },
            field: {
              label: "Field",
              widget: "field"
            },
            func: {
              label: "Function",
              widget: "func"
            }
          }
        });

        //----------------------------

        const CoreConfig = {
          conjunctions: conjunctions$2,
          operators: operators$2,
          widgets: widgets$3,
          types: types$4,
          settings: settings$3
        };
        var ADD_GROUP = "ADD_GROUP";
        var ADD_CASE_GROUP = "ADD_CASE_GROUP";
        var REMOVE_GROUP = "REMOVE_GROUP";
        var SET_CONJUNCTION = "SET_CONJUNCTION";
        var SET_NOT = "SET_NOT";
        var ADD_RULE = "ADD_RULE";
        var REMOVE_RULE = "REMOVE_RULE";
        var SET_FIELD = "SET_FIELD";
        var SET_OPERATOR = "SET_OPERATOR";
        var SET_VALUE = "SET_VALUE";
        var SET_VALUE_SRC = "SET_VALUE_SRC";
        var SET_OPERATOR_OPTION = "SET_OPERATOR_OPTION";
        var SET_LOCK = "SET_LOCK";
        var SET_TREE = "SET_TREE";
        var MOVE_ITEM = "MOVE_ITEM";
        var PLACEMENT_AFTER$1 = "after";
        var PLACEMENT_BEFORE$1 = "before";
        var PLACEMENT_APPEND$1 = "append";
        var PLACEMENT_PREPEND$1 = "prepend";
        var SET_DRAG_PROGRESS$1 = "SET_DRAG_PROGRESS";
        var SET_DRAG_START$1 = "SET_DRAG_START";
        var SET_DRAG_END$1 = "SET_DRAG_END";
        var baseAssignValue = _baseAssignValue,
          baseForOwn = _baseForOwn,
          baseIteratee$1 = _baseIteratee;

        /**
         * Creates an object with the same keys as `object` and values generated
         * by running each own enumerable string keyed property of `object` thru
         * `iteratee`. The iteratee is invoked with three arguments:
         * (value, key, object).
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns the new mapped object.
         * @see _.mapKeys
         * @example
         *
         * var users = {
         *   'fred':    { 'user': 'fred',    'age': 40 },
         *   'pebbles': { 'user': 'pebbles', 'age': 1 }
         * };
         *
         * _.mapValues(users, function(o) { return o.age; });
         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
         *
         * // The `_.property` iteratee shorthand.
         * _.mapValues(users, 'age');
         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
         */
        function mapValues(object, iteratee) {
          var result = {};
          iteratee = baseIteratee$1(iteratee);
          baseForOwn(object, function (value, key, object) {
            baseAssignValue(result, key, iteratee(value, key, object));
          });
          return result;
        }
        var mapValues_1 = mapValues;
        const mapValues$1 = /*@__PURE__*/getDefaultExportFromCjs(mapValues_1);
        function _createForOfIteratorHelper$2(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") {
              if (it) o = it;
              var i = 0;
              var F = function F() {};
              return {
                s: F,
                n: function n() {
                  if (i >= o.length) return {
                    done: true
                  };
                  return {
                    done: false,
                    value: o[i++]
                  };
                },
                e: function e(_e) {
                  throw _e;
                },
                f: F
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true,
            didErr = false,
            err;
          return {
            s: function s() {
              it = it.call(o);
            },
            n: function n() {
              var step = it.next();
              normalCompletion = step.done;
              return step;
            },
            e: function e(_e2) {
              didErr = true;
              err = _e2;
            },
            f: function f() {
              try {
                if (!normalCompletion && it["return"] != null) it["return"]();
              } finally {
                if (didErr) throw err;
              }
            }
          };
        }
        function _unsupportedIterableToArray$2(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray$2(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);
        }
        function _arrayLikeToArray$2(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }
        function ownKeys$j(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$j(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$j(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$j(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {Immutable.Map} properties
         */
        var addNewGroup = function addNewGroup(state, path, type, groupUuid, properties, config) {
          var children = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
          var meta = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};
          var shouldCreateEmptyGroup = config.settings.shouldCreateEmptyGroup;
          var groupPath = path.push(groupUuid);
          var canAddNewRule = !shouldCreateEmptyGroup;
          var isDefaultCase = !!(meta !== null && meta !== void 0 && meta.isDefaultCase);
          var origState = state;
          state = addItem(state, path, type, groupUuid, defaultGroupProperties(config).merge(properties || {}), config, children);
          if (state !== origState) {
            if (!children && !isDefaultCase) {
              state = state.setIn(expandTreePath(groupPath, "children1"), new Immutable.OrderedMap());

              // Add one empty rule into new group
              if (canAddNewRule) {
                state = addItem(state, groupPath, "rule", uuid$1(), defaultRuleProperties(config), config);
              }
            }
            state = fixPathsInTree(state);
          }
          return state;
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {Immutable.Map} properties
         */
        var removeGroup$1 = function removeGroup(state, path, config) {
          state = removeItem(state, path);
          var canLeaveEmptyGroup = config.settings.canLeaveEmptyGroup;
          var parentPath = path.slice(0, -1);
          var isEmptyParentGroup = !hasChildren(state, parentPath);
          if (isEmptyParentGroup && !canLeaveEmptyGroup) {
            // check ancestors for emptiness (and delete 'em if empty)
            state = fixEmptyGroupsInTree(state);
            if (isEmptyTree(state) && !canLeaveEmptyGroup) {
              // if whole query is empty, add one empty rule to root
              state = addItem(state, new Immutable.List(), "rule", uuid$1(), defaultRuleProperties(config), config);
            }
          }
          state = fixPathsInTree(state);
          return state;
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         */
        var removeRule$1 = function removeRule(state, path, config) {
          state = removeItem(state, path);
          var canLeaveEmptyGroup = config.settings.canLeaveEmptyGroup;
          var parentPath = path.pop();
          var parent = state.getIn(expandTreePath(parentPath));
          var parentField = parent.getIn(["properties", "field"]);
          var parentOperator = parent.getIn(["properties", "operator"]);
          parent.getIn(["properties", "value", 0]);
          var parentFieldConfig = parentField ? getFieldConfig$8(config, parentField) : null;
          var parentOperatorConfig = parentOperator ? getOperatorConfig$4(config, parentOperator, parentField) : null;
          var hasGroupCountRule = parentField && parentOperator && parentOperatorConfig.cardinality != 0; // && parentValue != undefined;

          var isParentRuleGroup = parent.get("type") == "rule_group";
          var isEmptyParentGroup = !hasChildren(state, parentPath);
          var canLeaveEmpty = isParentRuleGroup ? hasGroupCountRule && parentFieldConfig.initialEmptyWhere : canLeaveEmptyGroup;
          if (isEmptyParentGroup && !canLeaveEmpty) {
            if (isParentRuleGroup) {
              // deleted last rule from rule_group, so delete whole rule_group
              state = state.deleteIn(expandTreePath(parentPath));
            }

            // check ancestors for emptiness (and delete 'em if empty)
            state = fixEmptyGroupsInTree(state);
            if (isEmptyTree(state) && !canLeaveEmptyGroup) {
              // if whole query is empty, add one empty rule to root
              state = addItem(state, new Immutable.List(), "rule", uuid$1(), defaultRuleProperties(config), config);
            }
          }
          state = fixPathsInTree(state);
          return state;
        };

        /**
         * @param {Immutable.Map} state
         * @param {Immutable.List} path
         * @param {bool} not
         */
        var setNot$1 = function setNot(state, path, not) {
          return state.setIn(expandTreePath(path, "properties", "not"), not);
        };

        /**
         * @param {Immutable.Map} state
         * @param {Immutable.List} path
         * @param {bool} lock
         */
        var setLock$1 = function setLock(state, path, lock) {
          return removeIsLockedInTree(state.setIn(expandTreePath(path, "properties", "isLocked"), lock));
        };

        /**
         * @param {Immutable.Map} state
         * @param {Immutable.List} path
         * @param {string} conjunction
         */
        var setConjunction$1 = function setConjunction(state, path, conjunction) {
          return state.setIn(expandTreePath(path, "properties", "conjunction"), conjunction);
        };

        // convert children deeply from JS to Immutable
        var _addChildren1 = function _addChildren1(config, item, children) {
          if (children && Array.isArray(children)) {
            item.children1 = new Immutable.OrderedMap(children.reduce(function (map, it) {
              var id1 = uuid$1();
              var it1 = _objectSpread$j(_objectSpread$j({}, it), {}, {
                properties: defaultItemProperties(config, it).merge(it.properties || {}),
                id: id1
              });
              _addChildren1(config, it1, it1.children1);
              //todo: guarantee order
              return _objectSpread$j(_objectSpread$j({}, map), {}, _defineProperty$4({}, id1, new Immutable.Map(it1)));
            }, {}));
          }
        };

        /**
         * @param {Immutable.Map} state
         * @param {Immutable.List} path
         * @param {string} type
         * @param {string} id
         * @param {Immutable.OrderedMap} properties
         * @param {object} config
         */
        var addItem = function addItem(state, path, type, id, properties, config) {
          var children = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
          if (type == "switch_group") throw new Error("Can't add switch_group programmatically");
          var _config$settings = config.settings,
            maxNumberOfCases = _config$settings.maxNumberOfCases,
            maxNumberOfRules = _config$settings.maxNumberOfRules,
            maxNesting = _config$settings.maxNesting;
          var rootType = state.get("type");
          var isTernary = rootType == "switch_group";
          var targetItem = state.getIn(expandTreePath(path));
          var caseGroup = isTernary ? state.getIn(expandTreePath(path.take(2))) : null;
          var childrenPath = expandTreePath(path, "children1");
          var targetChildren = state.getIn(childrenPath);
          var hasChildren = !!targetChildren && targetChildren.size;
          var targetChildrenSize = hasChildren ? targetChildren.size : null;
          var currentNumber, maxNumber;
          if (type == "case_group") {
            currentNumber = targetChildrenSize;
            maxNumber = maxNumberOfCases;
          } else if (type == "group") {
            currentNumber = path.size;
            maxNumber = maxNesting;
          } else if ((targetItem === null || targetItem === void 0 ? void 0 : targetItem.get("type")) == "rule_group") ;else {
            currentNumber = isTernary ? getTotalRulesCountInTree$2(caseGroup) : getTotalRulesCountInTree$2(state);
            maxNumber = maxNumberOfRules;
          }
          var canAdd = maxNumber && currentNumber ? currentNumber < maxNumber : true;
          var item = {
            type: type,
            id: id,
            properties: properties
          };
          _addChildren1(config, item, children);
          var isLastDefaultCase = type == "case_group" && hasChildren && targetChildren.last().get("children1") == null;
          if (canAdd) {
            var newChildren = new Immutable.OrderedMap(_defineProperty$4({}, id, new Immutable.Map(item)));
            if (!hasChildren) {
              state = state.setIn(childrenPath, newChildren);
            } else if (isLastDefaultCase) {
              var _Immutable$OrderedMap2;
              var last = targetChildren.last();
              var newChildrenWithLast = new Immutable.OrderedMap((_Immutable$OrderedMap2 = {}, _defineProperty$4(_Immutable$OrderedMap2, id, new Immutable.Map(item)), _defineProperty$4(_Immutable$OrderedMap2, last.get("id"), last), _Immutable$OrderedMap2));
              state = state.deleteIn(expandTreePath(childrenPath, "children1", last.get("id")));
              state = state.mergeIn(childrenPath, newChildrenWithLast);
            } else {
              state = state.mergeIn(childrenPath, newChildren);
            }
            state = fixPathsInTree(state);
          }
          return state;
        };

        /**
         * @param {Immutable.Map} state
         * @param {Immutable.List} path
         */
        var removeItem = function removeItem(state, path) {
          state = state.deleteIn(expandTreePath(path));
          state = fixPathsInTree(state);
          return state;
        };

        /**
         * @param {Immutable.Map} state
         * @param {Immutable.List} fromPath
         * @param {Immutable.List} toPath
         * @param {string} placement, see constants PLACEMENT_*: PLACEMENT_AFTER, PLACEMENT_BEFORE, PLACEMENT_APPEND, PLACEMENT_PREPEND
         * @param {object} config
         */
        var moveItem$1 = function moveItem(state, fromPath, toPath, placement, config) {
          var from = getItemByPath(state, fromPath);
          var sourcePath = fromPath.pop();
          var source = fromPath.size > 1 ? getItemByPath(state, sourcePath) : null;
          var sourceChildren = source ? source.get("children1") : null;
          var to = getItemByPath(state, toPath);
          var targetPath = placement == PLACEMENT_APPEND$1 || placement == PLACEMENT_PREPEND$1 ? toPath : toPath.pop();
          var target = placement == PLACEMENT_APPEND$1 || placement == PLACEMENT_PREPEND$1 ? to : toPath.size > 1 ? getItemByPath(state, targetPath) : null;
          var targetChildren = target ? target.get("children1") : null;
          if (!source || !target || !from) return state;
          var isSameParent = source.get("id") == target.get("id");
          var isSourceInsideTarget = targetPath.size < sourcePath.size && deepEqual(targetPath.toArray(), sourcePath.toArray().slice(0, targetPath.size));
          var isTargetInsideSource = targetPath.size > sourcePath.size && deepEqual(sourcePath.toArray(), targetPath.toArray().slice(0, sourcePath.size));
          var sourceSubpathFromTarget = null;
          var targetSubpathFromSource = null;
          if (isSourceInsideTarget) {
            sourceSubpathFromTarget = Immutable.List(sourcePath.toArray().slice(targetPath.size));
          } else if (isTargetInsideSource) {
            targetSubpathFromSource = Immutable.List(targetPath.toArray().slice(sourcePath.size));
          }
          var newTargetChildren = targetChildren,
            newSourceChildren = sourceChildren;
          if (!isTargetInsideSource) newSourceChildren = newSourceChildren["delete"](from.get("id"));
          if (isSameParent) {
            newTargetChildren = newSourceChildren;
          } else if (isSourceInsideTarget) {
            newTargetChildren = newTargetChildren.updateIn(expandTreeSubpath(sourceSubpathFromTarget, "children1"), function (_oldChildren) {
              return newSourceChildren;
            });
          }
          if (placement == PLACEMENT_BEFORE$1 || placement == PLACEMENT_AFTER$1) {
            newTargetChildren = Immutable.OrderedMap().withMutations(function (r) {
              var _iterator = _createForOfIteratorHelper$2(newTargetChildren.entries()),
                _step;
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  var _step$value = _slicedToArray$1(_step.value, 2),
                    itemId = _step$value[0],
                    item = _step$value[1];
                  if (itemId == to.get("id") && placement == PLACEMENT_BEFORE$1) {
                    r.set(from.get("id"), from);
                  }
                  r.set(itemId, item);
                  if (itemId == to.get("id") && placement == PLACEMENT_AFTER$1) {
                    r.set(from.get("id"), from);
                  }
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            });
          } else if (placement == PLACEMENT_APPEND$1) {
            newTargetChildren = newTargetChildren.merge(_defineProperty$4({}, from.get("id"), from));
          } else if (placement == PLACEMENT_PREPEND$1) {
            newTargetChildren = Immutable.OrderedMap(_defineProperty$4({}, from.get("id"), from)).merge(newTargetChildren);
          }
          if (isTargetInsideSource) {
            newSourceChildren = newSourceChildren.updateIn(expandTreeSubpath(targetSubpathFromSource, "children1"), function (_oldChildren) {
              return newTargetChildren;
            });
            newSourceChildren = newSourceChildren["delete"](from.get("id"));
          }
          if (!isSameParent && !isSourceInsideTarget) state = state.updateIn(expandTreePath(sourcePath, "children1"), function (_oldChildren) {
            return newSourceChildren;
          });
          if (!isTargetInsideSource) state = state.updateIn(expandTreePath(targetPath, "children1"), function (_oldChildren) {
            return newTargetChildren;
          });
          state = fixPathsInTree(state);
          return state;
        };

        /**
         * @param {Immutable.Map} state
         * @param {Immutable.List} path
         * @param {string} field
         */
        var setField$1 = function setField(state, path, newField, config) {
          if (!newField) return removeItem(state, path);
          var _config$settings2 = config.settings,
            fieldSeparator = _config$settings2.fieldSeparator,
            setOpOnChangeField = _config$settings2.setOpOnChangeField,
            showErrorMessage = _config$settings2.showErrorMessage;
          if (Array.isArray(newField)) newField = newField.join(fieldSeparator);
          var currentType = state.getIn(expandTreePath(path, "type"));
          var currentProperties = state.getIn(expandTreePath(path, "properties"));
          var wasRuleGroup = currentType == "rule_group";
          var newFieldConfig = getFieldConfig$8(config, newField);
          var isRuleGroup = newFieldConfig.type == "!group";
          var isRuleGroupExt = isRuleGroup && newFieldConfig.mode == "array";
          var isChangeToAnotherType = wasRuleGroup != isRuleGroup;
          var currentOperator = currentProperties.get("operator");
          var currentOperatorOptions = currentProperties.get("operatorOptions");
          currentProperties.get("field");
          currentProperties.get("value");
          currentProperties.get("valueSrc", new Immutable.List());
          currentProperties.get("valueType", new Immutable.List());

          // If the newly selected field supports the same operator the rule currently
          // uses, keep it selected.
          var lastOp = newFieldConfig && newFieldConfig.operators.indexOf(currentOperator) !== -1 ? currentOperator : null;
          var newOperator = null;
          var availOps = getOperatorsForField(config, newField);
          if (availOps && availOps.length == 1) newOperator = availOps[0];else if (availOps && availOps.length > 1) {
            var _iterator2 = _createForOfIteratorHelper$2(setOpOnChangeField || []),
              _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var strategy = _step2.value;
                if (strategy == "keep" && !isChangeToAnotherType) newOperator = lastOp;else if (strategy == "default") newOperator = defaultOperator(config, newField, false);else if (strategy == "first") newOperator = getFirstOperator(config, newField);
                if (newOperator)
                  //found op for strategy
                  break;
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
          if (!isRuleGroup && !newFieldConfig.operators) {
            console.warn("Type ".concat(newFieldConfig.type, " is not supported"));
            return state;
          }
          if (wasRuleGroup && !isRuleGroup) {
            state = state.setIn(expandTreePath(path, "type"), "rule");
            state = state.deleteIn(expandTreePath(path, "children1"));
            state = state.setIn(expandTreePath(path, "properties"), new Immutable.OrderedMap());
          }
          if (isRuleGroup) {
            state = state.setIn(expandTreePath(path, "type"), "rule_group");
            var _getNewValueForFieldO = getNewValueForFieldOp(config, config, currentProperties, newField, newOperator, "field", true);
            _getNewValueForFieldO.canReuseValue;
            var newValue = _getNewValueForFieldO.newValue,
              newValueSrc = _getNewValueForFieldO.newValueSrc,
              newValueType = _getNewValueForFieldO.newValueType,
              operatorCardinality = _getNewValueForFieldO.operatorCardinality;
            var groupProperties = defaultGroupProperties(config, newFieldConfig).merge({
              field: newField,
              mode: newFieldConfig.mode
            });
            if (isRuleGroupExt) {
              groupProperties = groupProperties.merge({
                operator: newOperator,
                value: newValue,
                valueSrc: newValueSrc,
                valueType: newValueType
              });
            }
            state = state.setIn(expandTreePath(path, "children1"), new Immutable.OrderedMap());
            state = state.setIn(expandTreePath(path, "properties"), groupProperties);
            if (newFieldConfig.initialEmptyWhere && operatorCardinality == 1) ;else {
              state = addItem(state, path, "rule", uuid$1(), defaultRuleProperties(config, newField), config);
            }
            state = fixPathsInTree(state);
            return state;
          }
          return state.updateIn(expandTreePath(path, "properties"), function (map) {
            return map.withMutations(function (current) {
              var _getNewValueForFieldO2 = getNewValueForFieldOp(config, config, current, newField, newOperator, "field", true),
                canReuseValue = _getNewValueForFieldO2.canReuseValue,
                newValue = _getNewValueForFieldO2.newValue,
                newValueSrc = _getNewValueForFieldO2.newValueSrc,
                newValueType = _getNewValueForFieldO2.newValueType,
                newValueError = _getNewValueForFieldO2.newValueError;
              if (showErrorMessage) {
                current = current.set("valueError", newValueError);
              }
              var newOperatorOptions = canReuseValue ? currentOperatorOptions : defaultOperatorOptions(config, newOperator, newField);
              return current.set("field", newField).set("operator", newOperator).set("operatorOptions", newOperatorOptions).set("value", newValue).set("valueSrc", newValueSrc).set("valueType", newValueType)["delete"]("asyncListValues");
            });
          });
        };

        /**
         * @param {Immutable.Map} state
         * @param {Immutable.List} path
         * @param {string} operator
         */
        var setOperator$1 = function setOperator(state, path, newOperator, config) {
          var showErrorMessage = config.settings.showErrorMessage;
          var properties = state.getIn(expandTreePath(path, "properties"));
          var children = state.getIn(expandTreePath(path, "children1"));
          var currentField = properties.get("field");
          var fieldConfig = getFieldConfig$8(config, currentField);
          var isRuleGroup = fieldConfig.type == "!group";
          var operatorConfig = getOperatorConfig$4(config, newOperator, currentField);
          var operatorCardinality = operatorConfig ? defaultValue$1(operatorConfig.cardinality, 1) : null;
          state = state.updateIn(expandTreePath(path, "properties"), function (map) {
            return map.withMutations(function (current) {
              var currentField = current.get("field");
              var currentOperatorOptions = current.get("operatorOptions");
              current.get("value", new Immutable.List());
              current.get("valueSrc", new Immutable.List());
              current.get("operator");
              var _getNewValueForFieldO3 = getNewValueForFieldOp(config, config, current, currentField, newOperator, "operator", true),
                canReuseValue = _getNewValueForFieldO3.canReuseValue,
                newValue = _getNewValueForFieldO3.newValue,
                newValueSrc = _getNewValueForFieldO3.newValueSrc,
                newValueType = _getNewValueForFieldO3.newValueType,
                newValueError = _getNewValueForFieldO3.newValueError;
              if (showErrorMessage) {
                current = current.set("valueError", newValueError);
              }
              var newOperatorOptions = canReuseValue ? currentOperatorOptions : defaultOperatorOptions(config, newOperator, currentField);
              if (!canReuseValue) {
                current = current["delete"]("asyncListValues");
              }
              return current.set("operator", newOperator).set("operatorOptions", newOperatorOptions).set("value", newValue).set("valueSrc", newValueSrc).set("valueType", newValueType);
            });
          });
          if (isRuleGroup) {
            if (operatorCardinality == 0 && children.size == 0) {
              state = addItem(state, path, "rule", uuid$1(), defaultRuleProperties(config, currentField), config);
            }
          }
          return state;
        };

        /**
         * @param {Immutable.Map} state
         * @param {Immutable.List} path
         * @param {integer} delta
         * @param {*} value
         * @param {string} valueType
         * @param {*} asyncListValues
         * @param {boolean} __isInternal
         */
        var setValue$1 = function setValue(state, path, delta, value, valueType, config, asyncListValues, __isInternal) {
          var _config$settings3 = config.settings,
            fieldSeparator = _config$settings3.fieldSeparator,
            showErrorMessage = _config$settings3.showErrorMessage;
          var isInternalValueChange;
          var valueSrc = state.getIn(expandTreePath(path, "properties", "valueSrc", delta + "")) || null;
          if (valueSrc === "field" && Array.isArray(value)) value = value.join(fieldSeparator);
          var field = state.getIn(expandTreePath(path, "properties", "field")) || null;
          var operator = state.getIn(expandTreePath(path, "properties", "operator")) || null;
          var operatorConfig = getOperatorConfig$4(config, operator, field);
          var operatorCardinality = operator ? defaultValue$1(operatorConfig.cardinality, 1) : null;
          var isEndValue = false;
          var calculatedValueType = valueType || calculateValueType(value, valueSrc, config);
          var canFix = false;
          var _validateValue = validateValue(config, field, field, operator, value, calculatedValueType, valueSrc, asyncListValues, canFix, isEndValue),
            _validateValue2 = _slicedToArray$1(_validateValue, 2),
            validateError = _validateValue2[0],
            fixedValue = _validateValue2[1];
          var isValid = !validateError;
          if (fixedValue !== value) {
            // eg, get exact value from listValues (not string)
            value = fixedValue;
          }

          // Additional validation for range values
          if (showErrorMessage) {
            var w = getWidgetForFieldOp$3(config, field, operator, valueSrc);
            var fieldWidgetDefinition = getFieldWidgetConfig$3(config, field, operator, w, valueSrc);
            var valueSrcs = Array.from({
              length: operatorCardinality
            }, function (_, i) {
              return state.getIn(expandTreePath(path, "properties", "valueSrc", i + "")) || null;
            });
            if (operatorConfig && operatorConfig.validateValues && valueSrcs.filter(function (vs) {
              return vs == "value" || vs == null;
            }).length == operatorCardinality) {
              var values = Array.from({
                length: operatorCardinality
              }, function (_, i) {
                return i == delta ? value : state.getIn(expandTreePath(path, "properties", "value", i + "")) || null;
              });
              var jsValues = fieldWidgetDefinition && fieldWidgetDefinition.toJS ? values.map(function (v) {
                return fieldWidgetDefinition.toJS(v, fieldWidgetDefinition);
              }) : values;
              var rangeValidateError = operatorConfig.validateValues(jsValues);
              state = state.setIn(expandTreePath(path, "properties", "valueError", operatorCardinality), rangeValidateError);
            }
          }
          var lastValueArr = state.getIn(expandTreePath(path, "properties", "value"));
          if (!lastValueArr) {
            state = state.setIn(expandTreePath(path, "properties", "value"), new Immutable.List(new Array(operatorCardinality))).setIn(expandTreePath(path, "properties", "valueType"), new Immutable.List(new Array(operatorCardinality))).setIn(expandTreePath(path, "properties", "valueError"), new Immutable.List(new Array(operatorCardinality)));
          }
          var lastValue = state.getIn(expandTreePath(path, "properties", "value", delta + ""));
          var lastError = state.getIn(expandTreePath(path, "properties", "valueError", delta));
          var isLastEmpty = lastValue == undefined;
          var isLastError = !!lastError;
          if (isValid || showErrorMessage) {
            state = state.deleteIn(expandTreePath(path, "properties", "asyncListValues"));
            // set only good value
            if (typeof value === "undefined") {
              state = state.setIn(expandTreePath(path, "properties", "value", delta + ""), undefined);
              state = state.setIn(expandTreePath(path, "properties", "valueType", delta + ""), null);
            } else {
              if (asyncListValues) {
                state = state.setIn(expandTreePath(path, "properties", "asyncListValues"), asyncListValues);
              }
              state = state.setIn(expandTreePath(path, "properties", "value", delta + ""), value);
              state = state.setIn(expandTreePath(path, "properties", "valueType", delta + ""), calculatedValueType);
              isInternalValueChange = __isInternal && !isLastEmpty && !isLastError;
            }
          }
          if (showErrorMessage) {
            state = state.setIn(expandTreePath(path, "properties", "valueError", delta), validateError);
          }
          if (__isInternal && (isValid && isLastError || !isValid && !isLastError)) {
            state = state.setIn(expandTreePath(path, "properties", "valueError", delta), validateError);
            isInternalValueChange = false;
          }
          return {
            tree: state,
            isInternalValueChange: isInternalValueChange
          };
        };

        /**
         * @param {Immutable.Map} state
         * @param {Immutable.List} path
         * @param {integer} delta
         * @param {*} srcKey
         */
        var setValueSrc$1 = function setValueSrc(state, path, delta, srcKey, config) {
          var showErrorMessage = config.settings.showErrorMessage;
          var field = state.getIn(expandTreePath(path, "properties", "field")) || null;
          var operator = state.getIn(expandTreePath(path, "properties", "operator")) || null;
          state = state.setIn(expandTreePath(path, "properties", "value", delta + ""), undefined);
          state = state.setIn(expandTreePath(path, "properties", "valueType", delta + ""), null);
          state = state.deleteIn(expandTreePath(path, "properties", "asyncListValues"));
          if (showErrorMessage) {
            // clear value error
            state = state.setIn(expandTreePath(path, "properties", "valueError", delta), null);

            // if current operator is range, clear possible range error
            var operatorConfig = getOperatorConfig$4(config, operator, field);
            var operatorCardinality = operator ? defaultValue$1(operatorConfig.cardinality, 1) : null;
            if (operatorConfig.validateValues) {
              state = state.setIn(expandTreePath(path, "properties", "valueError", operatorCardinality), null);
            }
          }

          // set valueSrc
          if (typeof srcKey === "undefined") {
            state = state.setIn(expandTreePath(path, "properties", "valueSrc", delta + ""), null);
          } else {
            state = state.setIn(expandTreePath(path, "properties", "valueSrc", delta + ""), srcKey);
          }

          // maybe set default value
          if (srcKey) {
            var properties = state.getIn(expandTreePath(path, "properties"));
            // this call should return canReuseValue = false and provide default value
            var _getNewValueForFieldO4 = getNewValueForFieldOp(config, config, properties, field, operator, "valueSrc", true),
              canReuseValue = _getNewValueForFieldO4.canReuseValue,
              newValue = _getNewValueForFieldO4.newValue,
              newValueSrc = _getNewValueForFieldO4.newValueSrc,
              newValueType = _getNewValueForFieldO4.newValueType;
            _getNewValueForFieldO4.newValueError;
            if (!canReuseValue && newValueSrc.get(delta) == srcKey) {
              state = state.setIn(expandTreePath(path, "properties", "value", delta + ""), newValue.get(delta));
              state = state.setIn(expandTreePath(path, "properties", "valueType", delta + ""), newValueType.get(delta));
            }
          }
          return state;
        };

        /**
         * @param {Immutable.Map} state
         * @param {Immutable.List} path
         * @param {string} name
         * @param {*} value
         */
        var setOperatorOption$1 = function setOperatorOption(state, path, name, value) {
          return state.setIn(expandTreePath(path, "properties", "operatorOptions", name), value);
        };

        /**
         * @param {Immutable.Map} state
         */
        var checkEmptyGroups = function checkEmptyGroups(state, config) {
          var canLeaveEmptyGroup = config.settings.canLeaveEmptyGroup;
          if (!canLeaveEmptyGroup) {
            state = fixEmptyGroupsInTree(state);
          }
          return state;
        };

        /**
         * 
         */
        var calculateValueType = function calculateValueType(value, valueSrc, config) {
          var calculatedValueType = null;
          if (value) {
            if (valueSrc === "field") {
              var fieldConfig = getFieldConfig$8(config, value);
              if (fieldConfig) {
                calculatedValueType = fieldConfig.type;
              }
            } else if (valueSrc === "func") {
              var funcKey = value.get("func");
              if (funcKey) {
                var funcConfig = getFuncConfig$2(config, funcKey);
                if (funcConfig) {
                  calculatedValueType = funcConfig.returnType;
                }
              }
            }
          }
          return calculatedValueType;
        };
        var getField = function getField(state, path) {
          var field = state.getIn(expandTreePath(path, "properties", "field")) || null;
          return field;
        };
        var emptyDrag = {
          dragging: {
            id: null,
            x: null,
            y: null,
            w: null,
            h: null
          },
          mousePos: {},
          dragStart: {
            id: null
          }
        };
        var getActionMeta = function getActionMeta(action, state) {
          if (!action || !action.type) return null;
          var actionKeysToOmit = ["config", "asyncListValues", "__isInternal"];
          var actionTypesToIgnore = [SET_TREE, SET_DRAG_START$1, SET_DRAG_PROGRESS$1, SET_DRAG_END$1];
          var meta = mapValues$1(omit$1(action, actionKeysToOmit), applyToJS);
          var affectedField = action.path && getField(state.tree, action.path) || action.field;
          if (affectedField) meta.affectedField = affectedField;
          if (actionTypesToIgnore.includes(action.type) || action.type.indexOf("@@redux") == 0) meta = null;
          return meta;
        };

        /**
         * @param {Immutable.Map} state
         * @param {object} action
         */
        const TreeStore = function (config, tree, getMemoizedTree, setLastTree) {
          var emptyTree = defaultRoot$1(config);
          var initTree = tree || emptyTree;
          var emptyState = _objectSpread$j({
            tree: initTree
          }, emptyDrag);
          return function () {
            var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyState;
            var action = arguments.length > 1 ? arguments[1] : undefined;
            var unset = {
              __isInternalValueChange: undefined,
              __lastAction: undefined
            };
            var set = {};
            var actionMeta = getActionMeta(action, state);
            switch (action === null || action === void 0 ? void 0 : action.type) {
              case SET_TREE:
                {
                  var validatedTree = getMemoizedTree(action.config, action.tree);
                  set.tree = validatedTree;
                  break;
                }
              case ADD_CASE_GROUP:
                {
                  set.tree = addNewGroup(state.tree, action.path, "case_group", action.id, action.properties, action.config, action.children, action.meta);
                  break;
                }
              case ADD_GROUP:
                {
                  set.tree = addNewGroup(state.tree, action.path, "group", action.id, action.properties, action.config, action.children, action.meta);
                  break;
                }
              case REMOVE_GROUP:
                {
                  set.tree = removeGroup$1(state.tree, action.path, action.config);
                  break;
                }
              case ADD_RULE:
                {
                  set.tree = addItem(state.tree, action.path, action.ruleType, action.id, action.properties, action.config, action.children);
                  break;
                }
              case REMOVE_RULE:
                {
                  set.tree = removeRule$1(state.tree, action.path, action.config);
                  break;
                }
              case SET_CONJUNCTION:
                {
                  set.tree = setConjunction$1(state.tree, action.path, action.conjunction);
                  break;
                }
              case SET_NOT:
                {
                  set.tree = setNot$1(state.tree, action.path, action.not);
                  break;
                }
              case SET_FIELD:
                {
                  set.tree = setField$1(state.tree, action.path, action.field, action.config);
                  break;
                }
              case SET_LOCK:
                {
                  set.tree = setLock$1(state.tree, action.path, action.lock);
                  break;
                }
              case SET_OPERATOR:
                {
                  set.tree = setOperator$1(state.tree, action.path, action.operator, action.config);
                  break;
                }
              case SET_VALUE:
                {
                  var _setValue = setValue$1(state.tree, action.path, action.delta, action.value, action.valueType, action.config, action.asyncListValues, action.__isInternal),
                    _tree = _setValue.tree,
                    isInternalValueChange = _setValue.isInternalValueChange;
                  set.__isInternalValueChange = isInternalValueChange;
                  set.tree = _tree;
                  break;
                }
              case SET_VALUE_SRC:
                {
                  set.tree = setValueSrc$1(state.tree, action.path, action.delta, action.srcKey, action.config);
                  break;
                }
              case SET_OPERATOR_OPTION:
                {
                  set.tree = setOperatorOption$1(state.tree, action.path, action.name, action.value);
                  break;
                }
              case MOVE_ITEM:
                {
                  set.tree = moveItem$1(state.tree, action.fromPath, action.toPath, action.placement, action.config);
                  break;
                }
              case SET_DRAG_START$1:
                {
                  set.dragStart = action.dragStart;
                  set.dragging = action.dragging;
                  set.mousePos = action.mousePos;
                  break;
                }
              case SET_DRAG_PROGRESS$1:
                {
                  set.mousePos = action.mousePos;
                  set.dragging = action.dragging;
                  break;
                }
              case SET_DRAG_END$1:
                {
                  set.tree = checkEmptyGroups(state.tree, config);
                  set = _objectSpread$j(_objectSpread$j({}, set), emptyDrag);
                  break;
                }
            }
            if (actionMeta) {
              set.__lastAction = actionMeta;
            }
            if (setLastTree && set.tree && state.tree) {
              setLastTree(state.tree);
            }
            return _objectSpread$j(_objectSpread$j(_objectSpread$j({}, state), unset), set);
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.Map} tree
         */
        var setTree = function setTree(config, tree) {
          return {
            type: SET_TREE,
            tree: tree,
            config: config
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {Immutable.Map} properties
         */
        var addRule = function addRule(config, path, properties) {
          var ruleType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "rule";
          var children = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          return {
            type: ADD_RULE,
            ruleType: ruleType,
            children: children,
            path: toImmutableList(path),
            id: uuid$1(),
            properties: defaultRuleProperties(config).merge(properties || {}),
            config: config
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         */
        var removeRule = function removeRule(config, path) {
          return {
            type: REMOVE_RULE,
            path: toImmutableList(path),
            config: config
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {Immutable.Map} properties
         */
        var addDefaultCaseGroup = function addDefaultCaseGroup(config, path, properties) {
          var children = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          return {
            type: ADD_CASE_GROUP,
            path: toImmutableList(path),
            children: children,
            id: uuid$1(),
            properties: defaultGroupProperties(config).merge(properties || {}),
            config: config,
            meta: {
              isDefaultCase: true
            }
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {Immutable.Map} properties
         */
        var addCaseGroup = function addCaseGroup(config, path, properties) {
          var children = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          return {
            type: ADD_CASE_GROUP,
            path: toImmutableList(path),
            children: children,
            id: uuid$1(),
            properties: defaultGroupProperties(config).merge(properties || {}),
            config: config
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {Immutable.Map} properties
         */
        var addGroup = function addGroup(config, path, properties) {
          var children = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          return {
            type: ADD_GROUP,
            path: toImmutableList(path),
            children: children,
            id: uuid$1(),
            properties: defaultGroupProperties(config).merge(properties || {}),
            config: config
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         */
        var removeGroup = function removeGroup(config, path) {
          return {
            type: REMOVE_GROUP,
            path: toImmutableList(path),
            config: config
          };
        };

        /**
         * @param {object} config
         * @param {Array} fromPath
         * @param {Array} toPath
         * @param {String} placement, see constants PLACEMENT_*
         */
        var moveItem = function moveItem(config, fromPath, toPath, placement) {
          return {
            type: MOVE_ITEM,
            fromPath: toImmutableList(fromPath),
            toPath: toImmutableList(toPath),
            placement: placement,
            config: config
          };
        };
        const tree$1 = /*#__PURE__*/Object.freeze( /*#__PURE__*/Object.defineProperty({
          __proto__: null,
          addCaseGroup,
          addDefaultCaseGroup,
          addGroup,
          addRule,
          moveItem,
          removeGroup,
          removeRule,
          setTree
        }, Symbol.toStringTag, {
          value: 'Module'
        }));

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {string} conjunction
         */
        var setConjunction = function setConjunction(config, path, conjunction) {
          return {
            type: SET_CONJUNCTION,
            path: toImmutableList(path),
            conjunction: conjunction
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {bool} not
         */
        var setNot = function setNot(config, path, not) {
          return {
            type: SET_NOT,
            path: toImmutableList(path),
            not: not
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {bool} lock
         */
        var setLock = function setLock(config, path, lock) {
          return {
            type: SET_LOCK,
            path: toImmutableList(path),
            lock: lock
          };
        };
        const group$1 = /*#__PURE__*/Object.freeze( /*#__PURE__*/Object.defineProperty({
          __proto__: null,
          setConjunction,
          setLock,
          setNot
        }, Symbol.toStringTag, {
          value: 'Module'
        }));

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {string} field
         */
        var setField = function setField(config, path, field) {
          return {
            type: SET_FIELD,
            path: toImmutableList(path),
            field: field,
            config: config
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {string} operator
         */
        var setOperator = function setOperator(config, path, operator) {
          return {
            type: SET_OPERATOR,
            path: toImmutableList(path),
            operator: operator,
            config: config
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {integer} delta
         * @param {*} value
         * @param {string} valueType
         * @param {*} asyncListValues
         * @param {boolean} __isInternal
         */
        var setValue = function setValue(config, path, delta, value, valueType, asyncListValues, __isInternal) {
          return {
            type: SET_VALUE,
            path: toImmutableList(path),
            delta: delta,
            value: value,
            valueType: valueType,
            asyncListValues: asyncListValues,
            config: config,
            __isInternal: __isInternal
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {integer} delta
         * @param {*} srcKey
         */
        var setValueSrc = function setValueSrc(config, path, delta, srcKey) {
          return {
            type: SET_VALUE_SRC,
            path: toImmutableList(path),
            delta: delta,
            srcKey: srcKey,
            config: config
          };
        };

        /**
         * @param {object} config
         * @param {Immutable.List} path
         * @param {string} name
         * @param {*} value
         */
        var setOperatorOption = function setOperatorOption(config, path, name, value) {
          return {
            type: SET_OPERATOR_OPTION,
            path: toImmutableList(path),
            name: name,
            value: value,
            config: config
          };
        };
        const rule$1 = /*#__PURE__*/Object.freeze( /*#__PURE__*/Object.defineProperty({
          __proto__: null,
          setField,
          setOperator,
          setOperatorOption,
          setValue,
          setValueSrc
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        function ownKeys$i(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$i(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$i(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$i(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        var Utils$1 = _objectSpread$i(_objectSpread$i(_objectSpread$i({}, BasicUtils), Export), Import);
        const context = /*#__PURE__*/React.createContext();
        var ReactReduxContext = /*#__PURE__*/React.createContext(null);

        // Default to a dummy "batch" implementation that just runs the callback
        function defaultNoopBatch(callback) {
          callback();
        }
        var batch = defaultNoopBatch; // Allow injecting another batching function later

        var setBatch = function setBatch(newBatch) {
          return batch = newBatch;
        }; // Supply a getter just to skip dealing with ESM bindings

        var getBatch = function getBatch() {
          return batch;
        };

        // well as nesting subscriptions of descendant components, so that we can ensure the
        // ancestor components re-render before descendants

        function createListenerCollection() {
          var batch = getBatch();
          var first = null;
          var last = null;
          return {
            clear: function clear() {
              first = null;
              last = null;
            },
            notify: function notify() {
              batch(function () {
                var listener = first;
                while (listener) {
                  listener.callback();
                  listener = listener.next;
                }
              });
            },
            get: function get() {
              var listeners = [];
              var listener = first;
              while (listener) {
                listeners.push(listener);
                listener = listener.next;
              }
              return listeners;
            },
            subscribe: function subscribe(callback) {
              var isSubscribed = true;
              var listener = last = {
                callback: callback,
                next: null,
                prev: last
              };
              if (listener.prev) {
                listener.prev.next = listener;
              } else {
                first = listener;
              }
              return function unsubscribe() {
                if (!isSubscribed || first === null) return;
                isSubscribed = false;
                if (listener.next) {
                  listener.next.prev = listener.prev;
                } else {
                  last = listener.prev;
                }
                if (listener.prev) {
                  listener.prev.next = listener.next;
                } else {
                  first = listener.next;
                }
              };
            }
          };
        }
        var nullListeners = {
          notify: function notify() {},
          get: function get() {
            return [];
          }
        };
        function createSubscription(store, parentSub) {
          var unsubscribe;
          var listeners = nullListeners;
          function addNestedSub(listener) {
            trySubscribe();
            return listeners.subscribe(listener);
          }
          function notifyNestedSubs() {
            listeners.notify();
          }
          function handleChangeWrapper() {
            if (subscription.onStateChange) {
              subscription.onStateChange();
            }
          }
          function isSubscribed() {
            return Boolean(unsubscribe);
          }
          function trySubscribe() {
            if (!unsubscribe) {
              unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
              listeners = createListenerCollection();
            }
          }
          function tryUnsubscribe() {
            if (unsubscribe) {
              unsubscribe();
              unsubscribe = undefined;
              listeners.clear();
              listeners = nullListeners;
            }
          }
          var subscription = {
            addNestedSub: addNestedSub,
            notifyNestedSubs: notifyNestedSubs,
            handleChangeWrapper: handleChangeWrapper,
            isSubscribed: isSubscribed,
            trySubscribe: trySubscribe,
            tryUnsubscribe: tryUnsubscribe,
            getListeners: function getListeners() {
              return listeners;
            }
          };
          return subscription;
        }

        // To get around it, we can conditionally useEffect on the server (no-op) and
        // useLayoutEffect in the browser. We need useLayoutEffect to ensure the store
        // subscription callback always has the selector from the latest render commit
        // available, otherwise a store update may happen between render and the effect,
        // which may cause missed updates; we also must ensure the store subscription
        // is created synchronously, otherwise a store update may occur before the
        // subscription is created and an inconsistent state may be observed

        var useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? reactExports.useLayoutEffect : reactExports.useEffect;
        function Provider(_ref) {
          var store = _ref.store,
            context = _ref.context,
            children = _ref.children;
          var contextValue = reactExports.useMemo(function () {
            var subscription = createSubscription(store);
            return {
              store: store,
              subscription: subscription
            };
          }, [store]);
          var previousState = reactExports.useMemo(function () {
            return store.getState();
          }, [store]);
          useIsomorphicLayoutEffect(function () {
            var subscription = contextValue.subscription;
            subscription.onStateChange = subscription.notifyNestedSubs;
            subscription.trySubscribe();
            if (previousState !== store.getState()) {
              subscription.notifyNestedSubs();
            }
            return function () {
              subscription.tryUnsubscribe();
              subscription.onStateChange = null;
            };
          }, [contextValue, previousState]);
          var Context = context || ReactReduxContext;
          return /*#__PURE__*/React.createElement(Context.Provider, {
            value: contextValue
          }, children);
        }
        var reactIs = {
          exports: {}
        };
        var reactIs_production_min = {};

        /** @license React v17.0.2
         * react-is.production.min.js
         *
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */
        var b = 60103,
          c = 60106,
          d = 60107,
          e = 60108,
          f = 60114,
          g = 60109,
          h = 60110,
          k = 60112,
          l = 60113,
          m = 60120,
          n = 60115,
          p = 60116,
          q = 60121,
          r = 60122,
          u = 60117,
          v = 60129,
          w = 60131;
        if ("function" === typeof Symbol && Symbol.for) {
          var x = Symbol.for;
          b = x("react.element");
          c = x("react.portal");
          d = x("react.fragment");
          e = x("react.strict_mode");
          f = x("react.profiler");
          g = x("react.provider");
          h = x("react.context");
          k = x("react.forward_ref");
          l = x("react.suspense");
          m = x("react.suspense_list");
          n = x("react.memo");
          p = x("react.lazy");
          q = x("react.block");
          r = x("react.server.block");
          u = x("react.fundamental");
          v = x("react.debug_trace_mode");
          w = x("react.legacy_hidden");
        }
        function y(a) {
          if ("object" === typeof a && null !== a) {
            var t = a.$$typeof;
            switch (t) {
              case b:
                switch (a = a.type, a) {
                  case d:
                  case f:
                  case e:
                  case l:
                  case m:
                    return a;
                  default:
                    switch (a = a && a.$$typeof, a) {
                      case h:
                      case k:
                      case p:
                      case n:
                      case g:
                        return a;
                      default:
                        return t;
                    }
                }
              case c:
                return t;
            }
          }
        }
        var z = g,
          A = b,
          B = k,
          C = d,
          D = p,
          E = n,
          F = c,
          G = f,
          H = e,
          I = l;
        reactIs_production_min.ContextConsumer = h;
        reactIs_production_min.ContextProvider = z;
        reactIs_production_min.Element = A;
        reactIs_production_min.ForwardRef = B;
        reactIs_production_min.Fragment = C;
        reactIs_production_min.Lazy = D;
        reactIs_production_min.Memo = E;
        reactIs_production_min.Portal = F;
        reactIs_production_min.Profiler = G;
        reactIs_production_min.StrictMode = H;
        reactIs_production_min.Suspense = I;
        reactIs_production_min.isAsyncMode = function () {
          return !1;
        };
        reactIs_production_min.isConcurrentMode = function () {
          return !1;
        };
        reactIs_production_min.isContextConsumer = function (a) {
          return y(a) === h;
        };
        reactIs_production_min.isContextProvider = function (a) {
          return y(a) === g;
        };
        reactIs_production_min.isElement = function (a) {
          return "object" === typeof a && null !== a && a.$$typeof === b;
        };
        reactIs_production_min.isForwardRef = function (a) {
          return y(a) === k;
        };
        reactIs_production_min.isFragment = function (a) {
          return y(a) === d;
        };
        reactIs_production_min.isLazy = function (a) {
          return y(a) === p;
        };
        reactIs_production_min.isMemo = function (a) {
          return y(a) === n;
        };
        reactIs_production_min.isPortal = function (a) {
          return y(a) === c;
        };
        reactIs_production_min.isProfiler = function (a) {
          return y(a) === f;
        };
        reactIs_production_min.isStrictMode = function (a) {
          return y(a) === e;
        };
        reactIs_production_min.isSuspense = function (a) {
          return y(a) === l;
        };
        reactIs_production_min.isValidElementType = function (a) {
          return "string" === typeof a || "function" === typeof a || a === d || a === f || a === v || a === e || a === l || a === m || a === w || "object" === typeof a && null !== a && (a.$$typeof === p || a.$$typeof === n || a.$$typeof === g || a.$$typeof === h || a.$$typeof === k || a.$$typeof === u || a.$$typeof === q || a[0] === r) ? !0 : !1;
        };
        reactIs_production_min.typeOf = y;
        {
          reactIs.exports = reactIs_production_min;
        }
        var reactIsExports = reactIs.exports;
        var _excluded$b = ["getDisplayName", "methodName", "renderCountProp", "shouldHandleStateChanges", "storeKey", "withRef", "forwardRef", "context"],
          _excluded2 = ["reactReduxForwardedRef"];
        var EMPTY_ARRAY = [];
        var NO_SUBSCRIPTION_ARRAY = [null, null];
        function storeStateUpdatesReducer(state, action) {
          var updateCount = state[1];
          return [action.payload, updateCount + 1];
        }
        function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
          useIsomorphicLayoutEffect(function () {
            return effectFunc.apply(void 0, effectArgs);
          }, dependencies);
        }
        function captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs) {
          // We want to capture the wrapper props and child props we used for later comparisons
          lastWrapperProps.current = wrapperProps;
          lastChildProps.current = actualChildProps;
          renderIsScheduled.current = false; // If the render was from a store update, clear out that reference and cascade the subscriber update

          if (childPropsFromStoreUpdate.current) {
            childPropsFromStoreUpdate.current = null;
            notifyNestedSubs();
          }
        }
        function subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch) {
          // If we're not subscribed to the store, nothing to do here
          if (!shouldHandleStateChanges) return; // Capture values for checking if and when this component unmounts

          var didUnsubscribe = false;
          var lastThrownError = null; // We'll run this callback every time a store subscription update propagates to this component

          var checkForUpdates = function checkForUpdates() {
            if (didUnsubscribe) {
              // Don't run stale listeners.
              // Redux doesn't guarantee unsubscriptions happen until next dispatch.
              return;
            }
            var latestStoreState = store.getState();
            var newChildProps, error;
            try {
              // Actually run the selector with the most recent store state and wrapper props
              // to determine what the child props should be
              newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);
            } catch (e) {
              error = e;
              lastThrownError = e;
            }
            if (!error) {
              lastThrownError = null;
            } // If the child props haven't changed, nothing to do here - cascade the subscription update

            if (newChildProps === lastChildProps.current) {
              if (!renderIsScheduled.current) {
                notifyNestedSubs();
              }
            } else {
              // Save references to the new child props.  Note that we track the "child props from store update"
              // as a ref instead of a useState/useReducer because we need a way to determine if that value has
              // been processed.  If this went into useState/useReducer, we couldn't clear out the value without
              // forcing another re-render, which we don't want.
              lastChildProps.current = newChildProps;
              childPropsFromStoreUpdate.current = newChildProps;
              renderIsScheduled.current = true; // If the child props _did_ change (or we caught an error), this wrapper component needs to re-render

              forceComponentUpdateDispatch({
                type: 'STORE_UPDATED',
                payload: {
                  error: error
                }
              });
            }
          }; // Actually subscribe to the nearest connected ancestor (or store)

          subscription.onStateChange = checkForUpdates;
          subscription.trySubscribe(); // Pull data from the store after first render in case the store has
          // changed since we began.

          checkForUpdates();
          var unsubscribeWrapper = function unsubscribeWrapper() {
            didUnsubscribe = true;
            subscription.tryUnsubscribe();
            subscription.onStateChange = null;
            if (lastThrownError) {
              // It's possible that we caught an error due to a bad mapState function, but the
              // parent re-rendered without this component and we're about to unmount.
              // This shouldn't happen as long as we do top-down subscriptions correctly, but
              // if we ever do those wrong, this throw will surface the error in our tests.
              // In that case, throw the error from here so it doesn't get lost.
              throw lastThrownError;
            }
          };
          return unsubscribeWrapper;
        }
        var initStateUpdates = function initStateUpdates() {
          return [null, 0];
        };
        function connectAdvanced(
        /*
          selectorFactory is a func that is responsible for returning the selector function used to
          compute new props from state, props, and dispatch. For example:
              export default connectAdvanced((dispatch, options) => (state, props) => ({
              thing: state.things[props.thingId],
              saveThing: fields => dispatch(actionCreators.saveThing(props.thingId, fields)),
            }))(YourComponent)
            Access to dispatch is provided to the factory so selectorFactories can bind actionCreators
          outside of their selector as an optimization. Options passed to connectAdvanced are passed to
          the selectorFactory, along with displayName and WrappedComponent, as the second argument.
            Note that selectorFactory is responsible for all caching/memoization of inbound and outbound
          props. Do not use connectAdvanced directly without memoizing results between calls to your
          selector, otherwise the Connect component will re-render on every state or props change.
        */
        selectorFactory,
        // options object:
        _ref) {
          if (_ref === void 0) {
            _ref = {};
          }
          var _ref2 = _ref,
            _ref2$getDisplayName = _ref2.getDisplayName,
            getDisplayName = _ref2$getDisplayName === void 0 ? function (name) {
              return "ConnectAdvanced(" + name + ")";
            } : _ref2$getDisplayName,
            _ref2$methodName = _ref2.methodName,
            methodName = _ref2$methodName === void 0 ? 'connectAdvanced' : _ref2$methodName,
            _ref2$renderCountProp = _ref2.renderCountProp,
            renderCountProp = _ref2$renderCountProp === void 0 ? undefined : _ref2$renderCountProp,
            _ref2$shouldHandleSta = _ref2.shouldHandleStateChanges,
            shouldHandleStateChanges = _ref2$shouldHandleSta === void 0 ? true : _ref2$shouldHandleSta,
            _ref2$storeKey = _ref2.storeKey,
            storeKey = _ref2$storeKey === void 0 ? 'store' : _ref2$storeKey;
          _ref2.withRef;
          var _ref2$forwardRef = _ref2.forwardRef,
            forwardRef = _ref2$forwardRef === void 0 ? false : _ref2$forwardRef,
            _ref2$context = _ref2.context,
            context = _ref2$context === void 0 ? ReactReduxContext : _ref2$context,
            connectOptions = _objectWithoutPropertiesLoose(_ref2, _excluded$b);
          var Context = context;
          return function wrapWithConnect(WrappedComponent) {
            var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';
            var displayName = getDisplayName(wrappedComponentName);
            var selectorFactoryOptions = _extends$h({}, connectOptions, {
              getDisplayName: getDisplayName,
              methodName: methodName,
              renderCountProp: renderCountProp,
              shouldHandleStateChanges: shouldHandleStateChanges,
              storeKey: storeKey,
              displayName: displayName,
              wrappedComponentName: wrappedComponentName,
              WrappedComponent: WrappedComponent
            });
            var pure = connectOptions.pure;
            function createChildSelector(store) {
              return selectorFactory(store.dispatch, selectorFactoryOptions);
            } // If we aren't running in "pure" mode, we don't want to memoize values.
            // To avoid conditionally calling hooks, we fall back to a tiny wrapper
            // that just executes the given callback immediately.

            var usePureOnlyMemo = pure ? reactExports.useMemo : function (callback) {
              return callback();
            };
            function ConnectFunction(props) {
              var _useMemo = reactExports.useMemo(function () {
                  // Distinguish between actual "data" props that were passed to the wrapper component,
                  // and values needed to control behavior (forwarded refs, alternate context instances).
                  // To maintain the wrapperProps object reference, memoize this destructuring.
                  var reactReduxForwardedRef = props.reactReduxForwardedRef,
                    wrapperProps = _objectWithoutPropertiesLoose(props, _excluded2);
                  return [props.context, reactReduxForwardedRef, wrapperProps];
                }, [props]),
                propsContext = _useMemo[0],
                reactReduxForwardedRef = _useMemo[1],
                wrapperProps = _useMemo[2];
              var ContextToUse = reactExports.useMemo(function () {
                // Users may optionally pass in a custom context instance to use instead of our ReactReduxContext.
                // Memoize the check that determines which context instance we should use.
                return propsContext && propsContext.Consumer && reactIsExports.isContextConsumer( /*#__PURE__*/React.createElement(propsContext.Consumer, null)) ? propsContext : Context;
              }, [propsContext, Context]); // Retrieve the store and ancestor subscription via context, if available

              var contextValue = reactExports.useContext(ContextToUse); // The store _must_ exist as either a prop or in context.
              // We'll check to see if it _looks_ like a Redux store first.
              // This allows us to pass through a `store` prop that is just a plain value.

              var didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);
              Boolean(contextValue) && Boolean(contextValue.store);
              var store = didStoreComeFromProps ? props.store : contextValue.store;
              var childPropsSelector = reactExports.useMemo(function () {
                // The child props selector needs the store reference as an input.
                // Re-create this selector whenever the store changes.
                return createChildSelector(store);
              }, [store]);
              var _useMemo2 = reactExports.useMemo(function () {
                  if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY; // This Subscription's source should match where store came from: props vs. context. A component
                  // connected to the store via props shouldn't use subscription from context, or vice versa.

                  // This Subscription's source should match where store came from: props vs. context. A component
                  // connected to the store via props shouldn't use subscription from context, or vice versa.
                  var subscription = createSubscription(store, didStoreComeFromProps ? null : contextValue.subscription); // `notifyNestedSubs` is duplicated to handle the case where the component is unmounted in
                  // the middle of the notification loop, where `subscription` will then be null. This can
                  // probably be avoided if Subscription's listeners logic is changed to not call listeners
                  // that have been unsubscribed in the  middle of the notification loop.

                  // `notifyNestedSubs` is duplicated to handle the case where the component is unmounted in
                  // the middle of the notification loop, where `subscription` will then be null. This can
                  // probably be avoided if Subscription's listeners logic is changed to not call listeners
                  // that have been unsubscribed in the  middle of the notification loop.
                  var notifyNestedSubs = subscription.notifyNestedSubs.bind(subscription);
                  return [subscription, notifyNestedSubs];
                }, [store, didStoreComeFromProps, contextValue]),
                subscription = _useMemo2[0],
                notifyNestedSubs = _useMemo2[1]; // Determine what {store, subscription} value should be put into nested context, if necessary,
              // and memoize that value to avoid unnecessary context updates.

              var overriddenContextValue = reactExports.useMemo(function () {
                if (didStoreComeFromProps) {
                  // This component is directly subscribed to a store from props.
                  // We don't want descendants reading from this store - pass down whatever
                  // the existing context value is from the nearest connected ancestor.
                  return contextValue;
                } // Otherwise, put this component's subscription instance into context, so that
                // connected descendants won't update until after this component is done

                return _extends$h({}, contextValue, {
                  subscription: subscription
                });
              }, [didStoreComeFromProps, contextValue, subscription]); // We need to force this wrapper component to re-render whenever a Redux store update
              // causes a change to the calculated child component props (or we caught an error in mapState)

              var _useReducer = reactExports.useReducer(storeStateUpdatesReducer, EMPTY_ARRAY, initStateUpdates),
                _useReducer$ = _useReducer[0],
                previousStateUpdateResult = _useReducer$[0],
                forceComponentUpdateDispatch = _useReducer[1]; // Propagate any mapState/mapDispatch errors upwards

              if (previousStateUpdateResult && previousStateUpdateResult.error) {
                throw previousStateUpdateResult.error;
              } // Set up refs to coordinate values between the subscription effect and the render logic

              var lastChildProps = reactExports.useRef();
              var lastWrapperProps = reactExports.useRef(wrapperProps);
              var childPropsFromStoreUpdate = reactExports.useRef();
              var renderIsScheduled = reactExports.useRef(false);
              var actualChildProps = usePureOnlyMemo(function () {
                // Tricky logic here:
                // - This render may have been triggered by a Redux store update that produced new child props
                // - However, we may have gotten new wrapper props after that
                // If we have new child props, and the same wrapper props, we know we should use the new child props as-is.
                // But, if we have new wrapper props, those might change the child props, so we have to recalculate things.
                // So, we'll use the child props from store update only if the wrapper props are the same as last time.
                if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {
                  return childPropsFromStoreUpdate.current;
                } // TODO We're reading the store directly in render() here. Bad idea?
                // This will likely cause Bad Things (TM) to happen in Concurrent Mode.
                // Note that we do this because on renders _not_ caused by store updates, we need the latest store state
                // to determine what the child props should be.

                return childPropsSelector(store.getState(), wrapperProps);
              }, [store, previousStateUpdateResult, wrapperProps]); // We need this to execute synchronously every time we re-render. However, React warns
              // about useLayoutEffect in SSR, so we try to detect environment and fall back to
              // just useEffect instead to avoid the warning, since neither will run anyway.

              useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs]); // Our re-subscribe logic only runs when the store/subscription setup changes

              useIsomorphicLayoutEffectWithArgs(subscribeUpdates, [shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch], [store, subscription, childPropsSelector]); // Now that all that's done, we can finally try to actually render the child component.
              // We memoize the elements for the rendered child component as an optimization.

              var renderedWrappedComponent = reactExports.useMemo(function () {
                return /*#__PURE__*/React.createElement(WrappedComponent, _extends$h({}, actualChildProps, {
                  ref: reactReduxForwardedRef
                }));
              }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]); // If React sees the exact same element reference as last time, it bails out of re-rendering
              // that child, same as if it was wrapped in React.memo() or returned false from shouldComponentUpdate.

              var renderedChild = reactExports.useMemo(function () {
                if (shouldHandleStateChanges) {
                  // If this component is subscribed to store updates, we need to pass its own
                  // subscription instance down to our descendants. That means rendering the same
                  // Context instance, and putting a different value into the context.
                  return /*#__PURE__*/React.createElement(ContextToUse.Provider, {
                    value: overriddenContextValue
                  }, renderedWrappedComponent);
                }
                return renderedWrappedComponent;
              }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);
              return renderedChild;
            } // If we're in "pure" mode, ensure our wrapper component only re-renders when incoming props have changed.

            var Connect = pure ? React.memo(ConnectFunction) : ConnectFunction;
            Connect.WrappedComponent = WrappedComponent;
            Connect.displayName = ConnectFunction.displayName = displayName;
            if (forwardRef) {
              var forwarded = React.forwardRef(function forwardConnectRef(props, ref) {
                return /*#__PURE__*/React.createElement(Connect, _extends$h({}, props, {
                  reactReduxForwardedRef: ref
                }));
              });
              forwarded.displayName = displayName;
              forwarded.WrappedComponent = WrappedComponent;
              return hoistStatics(forwarded, WrappedComponent);
            }
            return hoistStatics(Connect, WrappedComponent);
          };
        }
        function is(x, y) {
          if (x === y) {
            return x !== 0 || y !== 0 || 1 / x === 1 / y;
          } else {
            return x !== x && y !== y;
          }
        }
        function shallowEqual$1(objA, objB) {
          if (is(objA, objB)) return true;
          if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
            return false;
          }
          var keysA = Object.keys(objA);
          var keysB = Object.keys(objB);
          if (keysA.length !== keysB.length) return false;
          for (var i = 0; i < keysA.length; i++) {
            if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
              return false;
            }
          }
          return true;
        }
        function bindActionCreators$1(actionCreators, dispatch) {
          var boundActionCreators = {};
          var _loop = function _loop(key) {
            var actionCreator = actionCreators[key];
            if (typeof actionCreator === 'function') {
              boundActionCreators[key] = function () {
                return dispatch(actionCreator.apply(void 0, arguments));
              };
            }
          };
          for (var key in actionCreators) {
            _loop(key);
          }
          return boundActionCreators;
        }
        function wrapMapToPropsConstant(getConstant) {
          return function initConstantSelector(dispatch, options) {
            var constant = getConstant(dispatch, options);
            function constantSelector() {
              return constant;
            }
            constantSelector.dependsOnOwnProps = false;
            return constantSelector;
          };
        } // dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args
        // to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine
        // whether mapToProps needs to be invoked when props have changed.
        //
        // A length of one signals that mapToProps does not depend on props from the parent component.
        // A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and
        // therefore not reporting its length accurately..

        function getDependsOnOwnProps(mapToProps) {
          return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
        } // Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,
        // this function wraps mapToProps in a proxy function which does several things:
        //
        //  * Detects whether the mapToProps function being called depends on props, which
        //    is used by selectorFactory to decide if it should reinvoke on props changes.
        //
        //  * On first call, handles mapToProps if returns another function, and treats that
        //    new function as the true mapToProps for subsequent calls.
        //
        //  * On first call, verifies the first result is a plain object, in order to warn
        //    the developer that their mapToProps function is not returning a valid result.
        //

        function wrapMapToPropsFunc(mapToProps, methodName) {
          return function initProxySelector(dispatch, _ref) {
            _ref.displayName;
            var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
              return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
            }; // allow detectFactoryAndVerify to get ownProps

            proxy.dependsOnOwnProps = true;
            proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
              proxy.mapToProps = mapToProps;
              proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
              var props = proxy(stateOrDispatch, ownProps);
              if (typeof props === 'function') {
                proxy.mapToProps = props;
                proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
                props = proxy(stateOrDispatch, ownProps);
              }
              return props;
            };
            return proxy;
          };
        }
        function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
          return typeof mapDispatchToProps === 'function' ? wrapMapToPropsFunc(mapDispatchToProps) : undefined;
        }
        function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
          return !mapDispatchToProps ? wrapMapToPropsConstant(function (dispatch) {
            return {
              dispatch: dispatch
            };
          }) : undefined;
        }
        function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
          return mapDispatchToProps && typeof mapDispatchToProps === 'object' ? wrapMapToPropsConstant(function (dispatch) {
            return bindActionCreators$1(mapDispatchToProps, dispatch);
          }) : undefined;
        }
        const defaultMapDispatchToPropsFactories = [whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject];
        function whenMapStateToPropsIsFunction(mapStateToProps) {
          return typeof mapStateToProps === 'function' ? wrapMapToPropsFunc(mapStateToProps) : undefined;
        }
        function whenMapStateToPropsIsMissing(mapStateToProps) {
          return !mapStateToProps ? wrapMapToPropsConstant(function () {
            return {};
          }) : undefined;
        }
        const defaultMapStateToPropsFactories = [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing];
        function defaultMergeProps(stateProps, dispatchProps, ownProps) {
          return _extends$h({}, ownProps, stateProps, dispatchProps);
        }
        function wrapMergePropsFunc(mergeProps) {
          return function initMergePropsProxy(dispatch, _ref) {
            _ref.displayName;
            var pure = _ref.pure,
              areMergedPropsEqual = _ref.areMergedPropsEqual;
            var hasRunOnce = false;
            var mergedProps;
            return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
              var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);
              if (hasRunOnce) {
                if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;
              } else {
                hasRunOnce = true;
                mergedProps = nextMergedProps;
              }
              return mergedProps;
            };
          };
        }
        function whenMergePropsIsFunction(mergeProps) {
          return typeof mergeProps === 'function' ? wrapMergePropsFunc(mergeProps) : undefined;
        }
        function whenMergePropsIsOmitted(mergeProps) {
          return !mergeProps ? function () {
            return defaultMergeProps;
          } : undefined;
        }
        const defaultMergePropsFactories = [whenMergePropsIsFunction, whenMergePropsIsOmitted];
        var _excluded$a = ["initMapStateToProps", "initMapDispatchToProps", "initMergeProps"];
        function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {
          return function impureFinalPropsSelector(state, ownProps) {
            return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);
          };
        }
        function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {
          var areStatesEqual = _ref.areStatesEqual,
            areOwnPropsEqual = _ref.areOwnPropsEqual,
            areStatePropsEqual = _ref.areStatePropsEqual;
          var hasRunAtLeastOnce = false;
          var state;
          var ownProps;
          var stateProps;
          var dispatchProps;
          var mergedProps;
          function handleFirstCall(firstState, firstOwnProps) {
            state = firstState;
            ownProps = firstOwnProps;
            stateProps = mapStateToProps(state, ownProps);
            dispatchProps = mapDispatchToProps(dispatch, ownProps);
            mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
            hasRunAtLeastOnce = true;
            return mergedProps;
          }
          function handleNewPropsAndNewState() {
            stateProps = mapStateToProps(state, ownProps);
            if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
            mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
            return mergedProps;
          }
          function handleNewProps() {
            if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);
            if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
            mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
            return mergedProps;
          }
          function handleNewState() {
            var nextStateProps = mapStateToProps(state, ownProps);
            var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
            stateProps = nextStateProps;
            if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
            return mergedProps;
          }
          function handleSubsequentCalls(nextState, nextOwnProps) {
            var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
            var stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);
            state = nextState;
            ownProps = nextOwnProps;
            if (propsChanged && stateChanged) return handleNewPropsAndNewState();
            if (propsChanged) return handleNewProps();
            if (stateChanged) return handleNewState();
            return mergedProps;
          }
          return function pureFinalPropsSelector(nextState, nextOwnProps) {
            return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
          };
        } // TODO: Add more comments
        // If pure is true, the selector returned by selectorFactory will memoize its results,
        // allowing connectAdvanced's shouldComponentUpdate to return false if final
        // props have not changed. If false, the selector will always return a new
        // object and shouldComponentUpdate will always return true.

        function finalPropsSelectorFactory(dispatch, _ref2) {
          var initMapStateToProps = _ref2.initMapStateToProps,
            initMapDispatchToProps = _ref2.initMapDispatchToProps,
            initMergeProps = _ref2.initMergeProps,
            options = _objectWithoutPropertiesLoose(_ref2, _excluded$a);
          var mapStateToProps = initMapStateToProps(dispatch, options);
          var mapDispatchToProps = initMapDispatchToProps(dispatch, options);
          var mergeProps = initMergeProps(dispatch, options);
          var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;
          return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
        }
        var _excluded$9 = ["pure", "areStatesEqual", "areOwnPropsEqual", "areStatePropsEqual", "areMergedPropsEqual"];
        /*
          connect is a facade over connectAdvanced. It turns its args into a compatible
          selectorFactory, which has the signature:
              (dispatch, options) => (nextState, nextOwnProps) => nextFinalProps
          
          connect passes its args to connectAdvanced as options, which will in turn pass them to
          selectorFactory each time a Connect component instance is instantiated or hot reloaded.
            selectorFactory returns a final props selector from its mapStateToProps,
          mapStateToPropsFactories, mapDispatchToProps, mapDispatchToPropsFactories, mergeProps,
          mergePropsFactories, and pure args.
            The resulting final props selector is called by the Connect component instance whenever
          it receives new props or store state.
         */

        function match(arg, factories, name) {
          for (var i = factories.length - 1; i >= 0; i--) {
            var result = factories[i](arg);
            if (result) return result;
          }
          return function (dispatch, options) {
            throw new Error("Invalid value of type " + typeof arg + " for " + name + " argument when connecting component " + options.wrappedComponentName + ".");
          };
        }
        function strictEqual(a, b) {
          return a === b;
        } // createConnect with default args builds the 'official' connect behavior. Calling it with
        // different options opens up some testing and extensibility scenarios

        function createConnect(_temp) {
          var _ref = _temp === void 0 ? {} : _temp,
            _ref$connectHOC = _ref.connectHOC,
            connectHOC = _ref$connectHOC === void 0 ? connectAdvanced : _ref$connectHOC,
            _ref$mapStateToPropsF = _ref.mapStateToPropsFactories,
            mapStateToPropsFactories = _ref$mapStateToPropsF === void 0 ? defaultMapStateToPropsFactories : _ref$mapStateToPropsF,
            _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories,
            mapDispatchToPropsFactories = _ref$mapDispatchToPro === void 0 ? defaultMapDispatchToPropsFactories : _ref$mapDispatchToPro,
            _ref$mergePropsFactor = _ref.mergePropsFactories,
            mergePropsFactories = _ref$mergePropsFactor === void 0 ? defaultMergePropsFactories : _ref$mergePropsFactor,
            _ref$selectorFactory = _ref.selectorFactory,
            selectorFactory = _ref$selectorFactory === void 0 ? finalPropsSelectorFactory : _ref$selectorFactory;
          return function connect(mapStateToProps, mapDispatchToProps, mergeProps, _ref2) {
            if (_ref2 === void 0) {
              _ref2 = {};
            }
            var _ref3 = _ref2,
              _ref3$pure = _ref3.pure,
              pure = _ref3$pure === void 0 ? true : _ref3$pure,
              _ref3$areStatesEqual = _ref3.areStatesEqual,
              areStatesEqual = _ref3$areStatesEqual === void 0 ? strictEqual : _ref3$areStatesEqual,
              _ref3$areOwnPropsEqua = _ref3.areOwnPropsEqual,
              areOwnPropsEqual = _ref3$areOwnPropsEqua === void 0 ? shallowEqual$1 : _ref3$areOwnPropsEqua,
              _ref3$areStatePropsEq = _ref3.areStatePropsEqual,
              areStatePropsEqual = _ref3$areStatePropsEq === void 0 ? shallowEqual$1 : _ref3$areStatePropsEq,
              _ref3$areMergedPropsE = _ref3.areMergedPropsEqual,
              areMergedPropsEqual = _ref3$areMergedPropsE === void 0 ? shallowEqual$1 : _ref3$areMergedPropsE,
              extraOptions = _objectWithoutPropertiesLoose(_ref3, _excluded$9);
            var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps');
            var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps');
            var initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps');
            return connectHOC(selectorFactory, _extends$h({
              // used in error messages
              methodName: 'connect',
              // used to compute Connect's displayName from the wrapped component's displayName.
              getDisplayName: function getDisplayName(name) {
                return "Connect(" + name + ")";
              },
              // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
              shouldHandleStateChanges: Boolean(mapStateToProps),
              // passed through to selectorFactory
              initMapStateToProps: initMapStateToProps,
              initMapDispatchToProps: initMapDispatchToProps,
              initMergeProps: initMergeProps,
              pure: pure,
              areStatesEqual: areStatesEqual,
              areOwnPropsEqual: areOwnPropsEqual,
              areStatePropsEqual: areStatePropsEqual,
              areMergedPropsEqual: areMergedPropsEqual
            }, extraOptions));
          };
        }
        const connect = /*#__PURE__*/createConnect();

        // with standard React renderers (ReactDOM, React Native)

        setBatch(reactDomExports.unstable_batchedUpdates);
        var PLACEMENT_AFTER = "after";
        var PLACEMENT_BEFORE = "before";
        var PLACEMENT_APPEND = "append";
        var PLACEMENT_PREPEND = "prepend";
        var SET_DRAG_PROGRESS = "SET_DRAG_PROGRESS";
        var SET_DRAG_START = "SET_DRAG_START";
        var SET_DRAG_END = "SET_DRAG_END";

        /**
         * @param {Object} mousePos
         * @param {Object} dragging
         */
        var setDragProgress = function setDragProgress(mousePos, dragging) {
          return {
            type: SET_DRAG_PROGRESS,
            mousePos: mousePos,
            dragging: dragging
          };
        };

        /**
         * @param {Object} dragStart
         * @param {Object} dragging
         * @param {Object} mousePos
         */
        var setDragStart = function setDragStart(dragStart, dragging, mousePos) {
          return {
            type: SET_DRAG_START,
            dragStart: dragStart,
            dragging: dragging,
            mousePos: mousePos
          };
        };

        /**
         *
         */
        var setDragEnd = function setDragEnd() {
          return {
            type: SET_DRAG_END
          };
        };
        var tree = tree$1,
          group = group$1,
          rule = rule$1;
        function _createForOfIteratorHelper$1(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
              if (it) o = it;
              var i = 0;
              var F = function F() {};
              return {
                s: F,
                n: function n() {
                  if (i >= o.length) return {
                    done: true
                  };
                  return {
                    done: false,
                    value: o[i++]
                  };
                },
                e: function e(_e) {
                  throw _e;
                },
                f: F
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true,
            didErr = false,
            err;
          return {
            s: function s() {
              it = it.call(o);
            },
            n: function n() {
              var step = it.next();
              normalCompletion = step.done;
              return step;
            },
            e: function e(_e2) {
              didErr = true;
              err = _e2;
            },
            f: function f() {
              try {
                if (!normalCompletion && it["return"] != null) it["return"]();
              } finally {
                if (didErr) throw err;
              }
            }
          };
        }
        function _unsupportedIterableToArray$1(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
        }
        function _arrayLikeToArray$1(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }
        var extendConfig = Utils$1.ConfigUtils.extendConfig;
        var configKeys = ["conjunctions", "fields", "types", "operators", "widgets", "settings", "funcs"];
        var pickConfig = function pickConfig(props) {
          return pick$1(props, configKeys);
        };
        var createConfigMemo = function createConfigMemo() {
          var configStore = new Map();
          var maxSize = 2; // current and prev
          var configId = 0;
          var extendAndStore = function extendAndStore(config) {
            var extendedConfig = extendConfig(config, ++configId);
            if (configStore.size + 1 > maxSize) {
              configStore["delete"](configStore.keys()[0]);
            }
            configStore.set(config, extendedConfig);
            return extendedConfig;
          };
          var findExtended = function findExtended(findConfig) {
            // strict find:
            // return configStore.get(findConfig) || configStore.values().find(ec => ec === findConfig);
            var _iterator = _createForOfIteratorHelper$1(configStore.keys()),
              _step;
            try {
              var _loop = function _loop() {
                var savedConfig = _step.value;
                var found = configKeys.map(function (k) {
                  return savedConfig[k] === findConfig[k];
                }).filter(function (v) {
                  return !v;
                }).length === 0;
                if (found) {
                  return {
                    v: configStore.get(savedConfig)
                  };
                }
              };
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var _ret = _loop();
                if (_typeof$2(_ret) === "object") return _ret.v;
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
            var _iterator2 = _createForOfIteratorHelper$1(configStore.values()),
              _step2;
            try {
              var _loop2 = function _loop2() {
                var extendedConfig = _step2.value;
                var found = configKeys.map(function (k) {
                  return extendedConfig[k] === findConfig[k];
                }).filter(function (v) {
                  return !v;
                }).length === 0;
                if (found) {
                  return {
                    v: extendedConfig
                  };
                }
              };
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var _ret2 = _loop2();
                if (_typeof$2(_ret2) === "object") return _ret2.v;
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
            return null;
          };
          var findOrExtend = function findOrExtend(config) {
            return findExtended(config) || extendAndStore(config);
          };
          return function (props) {
            return findOrExtend(pickConfig(props));
          };
        };
        var defaultValue = function defaultValue(value, _default) {
          return typeof value === "undefined" ? _default : value;
        };
        var truncateString = function truncateString(str, n, useWordBoundary) {
          if (!n || str.length <= n) {
            return str;
          }
          var subString = str.substr(0, n - 1);
          return (useWordBoundary ? subString.substr(0, subString.lastIndexOf(" ")) : subString) + "...";
        };
        var immutableEqual = function immutableEqual(v1, v2) {
          if (v1 === v2) {
            return true;
          } else {
            return v1.equals(v2);
          }
        };

        // const deepEqual = function(v1, v2) {
        //   if (v1 === v2) {
        //     return true;
        //   } else if (Map.isMap(v1)) {
        //     return v1.equals(v2);
        //   } else {
        //     return JSON.stringify(v1) == JSON.stringify(v2);
        //   }
        // };

        var shallowEqual = function shallowEqual(a, b) {
          var deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          if (a === b) {
            return true;
          } else if (Array.isArray(a)) return shallowEqualArrays(a, b, deep);else if (a && typeof a.equals === "function") return a.equals(b);else if (_typeof$2(a) === "object") return shallowEqualObjects(a, b, deep);else return a === b;
        };
        function shallowEqualArrays(arrA, arrB) {
          var deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          if (arrA === arrB) {
            return true;
          }
          if (!arrA || !arrB) {
            return false;
          }
          var len = arrA.length;
          if (arrB.length !== len) {
            return false;
          }
          for (var i = 0; i < len; i++) {
            var isEqual = deep ? shallowEqual(arrA[i], arrB[i], deep) : arrA[i] === arrB[i];
            if (!isEqual) {
              return false;
            }
          }
          return true;
        }
        function shallowEqualObjects(objA, objB) {
          var deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          if (objA === objB) {
            return true;
          }
          if (!objA || !objB) {
            return false;
          }
          var aKeys = Object.keys(objA);
          var bKeys = Object.keys(objB);
          var len = aKeys.length;
          if (bKeys.length !== len) {
            return false;
          }
          for (var i = 0; i < len; i++) {
            var key = aKeys[i];
            var isEqual = deep ? shallowEqual(objA[key], objB[key], deep) : objA[key] === objB[key];
            if (!isEqual) {
              return false;
            }
          }
          return true;
        }

        // export function toImmutableList(v) {
        //   return (isImmutable(v) ? v : new Immutable.List(v));
        // }

        var isDev = function isDev() {
          return typeof process !== "undefined" && {} && "production" == "development";
        };
        var getLogger = function getLogger() {
          var devMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          var verbose = devMode != undefined ? devMode : isDev();
          return verbose ? console : {
            error: function error() {},
            log: function log() {},
            warn: function warn() {},
            debug: function debug() {},
            info: function info() {}
          };
        };
        var logger = getLogger();
        var validateAndFixTree = Utils$1.validateAndFixTree;
        var createValidationMemo = function createValidationMemo() {
          var originalTree;
          var validatedTree;
          var configId;
          return function (config, tree) {
            var oldConfig = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
            var sanitizeTree = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            if (!tree) {
              return null;
            }
            if (config.__configId === configId && (immutableEqual(tree, originalTree) || immutableEqual(tree, validatedTree))) {
              return validatedTree;
            } else {
              configId = config.__configId;
              originalTree = tree;
              if (sanitizeTree === false) {
                validatedTree = validateAndFixTree(tree, null, config, oldConfig || config, false, false);
              } else {
                validatedTree = validateAndFixTree(tree, null, config, oldConfig || config);
              }
              return validatedTree;
            }
          };
        };
        var getReactContainerType = function getReactContainerType(el) {
          if (el._reactRootContainer) {
            return "root";
          }
          if (Object.getOwnPropertyNames(el).filter(function (k) {
            return k.startsWith("__reactContainer");
          }).length > 0) {
            return "container";
          }
          return undefined;
        };
        var getReactRootNodeType = function getReactRootNodeType(node) {
          if (!node) {
            return undefined;
          }
          var type = getReactContainerType(node);
          if (type !== undefined) {
            return type;
          } else {
            return getReactRootNodeType(node.parentNode);
          }
        };
        var isUsingLegacyReactDomRender = function isUsingLegacyReactDomRender(node) {
          return getReactRootNodeType(node) === "root";
        };
        var liteShouldComponentUpdate = function liteShouldComponentUpdate(self, config) {
          return function (nextProps, nextState) {
            var prevProps = self.props;
            var prevState = self.state;
            var should = nextProps != prevProps || nextState != prevState;
            if (should) {
              if (prevState == nextState && prevProps != nextProps) {
                var chs = [];
                for (var k in nextProps) {
                  var changed = nextProps[k] != prevProps[k];
                  if (changed) {
                    if (config[k] == "ignore") changed = false;else if (config[k] == "shallow_deep") changed = !shallowEqual(nextProps[k], prevProps[k], true);else if (config[k] == "shallow") changed = !shallowEqual(nextProps[k], prevProps[k]);else if (typeof config[k] == "function") changed = config[k](nextProps[k], prevProps[k], nextState);
                  }
                  if (changed) chs.push(k);
                }
                if (!chs.length) should = false;
              }
            }
            return should;
          };
        };
        var pureShouldComponentUpdate = function pureShouldComponentUpdate(self) {
          return function (nextProps, nextState) {
            return !shallowEqual(self.props, nextProps) || !shallowEqual(self.state, nextState);
          };
        };
        var canUseOldComponentWillReceiveProps = function canUseOldComponentWillReceiveProps() {
          var v = React.version.split(".").map(parseInt.bind(null, 10));
          return v[0] == 16 && v[1] < 3 || v[0] < 16;
        };
        var useOnPropsChanged = function useOnPropsChanged(obj) {
          // 1. `shouldComponentUpdate` should be called after `componentWillReceiveProps`
          // 2. `shouldComponentUpdate` should not be used for PureComponent

          // Because `useOnPropsChanged` can only be applied to `Component` not `PureComponent`, make it pure now
          if (!obj.shouldComponentUpdate) {
            obj.shouldComponentUpdate = pureShouldComponentUpdate(obj);
          }
          if (canUseOldComponentWillReceiveProps()) {
            // Use old method
            obj.componentWillReceiveProps = function (nextProps) {
              obj.onPropsChanged(nextProps);
            };
          } else {
            // Simulate `componentWillReceiveProps` with `shouldComponentUpdate`
            var origShouldComponentUpdate = obj.shouldComponentUpdate;
            var newShouldComponentUpdate = function newShouldComponentUpdate(nextProps, nextState) {
              var shouldNotify = !shallowEqual(obj.props, nextProps);
              if (shouldNotify) {
                obj.onPropsChanged(nextProps);
              }
              var shouldUpdate = origShouldComponentUpdate.call(obj, nextProps, nextState);
              return shouldUpdate;
            };
            obj.shouldComponentUpdate = newShouldComponentUpdate.bind(obj);
          }
        };
        var bindActionCreators = function bindActionCreators(actionCreators, config, dispatch) {
          return mapValues$1(actionCreators, function (actionCreator) {
            return function () {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return dispatch(actionCreator.apply(void 0, [config].concat(args)));
            };
          });
        };
        const ReactUtils = /*#__PURE__*/Object.freeze( /*#__PURE__*/Object.defineProperty({
          __proto__: null,
          bindActionCreators,
          isUsingLegacyReactDomRender,
          liteShouldComponentUpdate,
          pureShouldComponentUpdate,
          useOnPropsChanged
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        function ownKeys$h(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$h(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$h(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$h(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        function _createSuper$r(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$r();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct$r() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var Query = /*#__PURE__*/function (_Component) {
          _inherits$b(Query, _Component);
          var _super = _createSuper$r(Query);
          function Query(props) {
            var _this;
            _classCallCheck$b(this, Query);
            _this = _super.call(this, props);
            _this.shouldComponentUpdate = liteShouldComponentUpdate(_assertThisInitialized$1(_this), {
              tree: function tree(nextValue) {
                if (nextValue === _this.oldValidatedTree && _this.oldValidatedTree === _this.validatedTree) {
                  // Got value dispatched from QueryContainer
                  // Ignore, because we've just rendered it
                  return false;
                }
                return true;
              }
            });
            useOnPropsChanged(_assertThisInitialized$1(_this));
            _this._updateActions(props);

            // For preventive validation (tree and config consistency)
            // When config has changed from QueryContainer, 
            //  but new dispatched validated tree value is not in redux store yet (tree prop is old)
            _this.validatedTree = props.getMemoizedTree(props.config, props.tree);
            _this.oldValidatedTree = _this.validatedTree;

            //props.onChange && props.onChange(this.validatedTree, props.config);
            return _this;
          }
          _createClass$9(Query, [{
            key: "_updateActions",
            value: function _updateActions(props) {
              var config = props.config,
                dispatch = props.dispatch;
              this.actions = bindActionCreators(_objectSpread$h(_objectSpread$h(_objectSpread$h({}, tree), group), rule), config, dispatch);
            }
          }, {
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {
              var onChange = nextProps.onChange;
              var oldConfig = this.props.config;
              var newTree = nextProps.tree;
              this.props.tree;
              var newConfig = nextProps.config;
              this.oldValidatedTree = this.validatedTree;
              this.validatedTree = newTree;
              if (oldConfig !== newConfig) {
                this._updateActions(nextProps);
                this.validatedTree = nextProps.getMemoizedTree(newConfig, newTree, oldConfig);
              }
              var validatedTreeChanged = !immutableEqual(this.validatedTree, this.oldValidatedTree);
              if (validatedTreeChanged) {
                onChange && onChange(this.validatedTree, newConfig, nextProps.__lastAction);
              }
            }
          }, {
            key: "render",
            value: function render() {
              var _this$props = this.props,
                config = _this$props.config,
                renderBuilder = _this$props.renderBuilder,
                dispatch = _this$props.dispatch,
                __isInternalValueChange = _this$props.__isInternalValueChange;
              var builderProps = {
                tree: this.validatedTree,
                actions: this.actions,
                config: config,
                dispatch: dispatch,
                __isInternalValueChange: __isInternalValueChange
              };
              return renderBuilder(builderProps);
            }
          }]);
          return Query;
        }(reactExports.Component);
        Query.propTypes = {
          config: PropTypes.object.isRequired,
          onChange: PropTypes.func,
          renderBuilder: PropTypes.func,
          tree: PropTypes.any //instanceOf(Immutable.Map)
          //dispatch: PropTypes.func.isRequired,
          //__isInternalValueChange
          //__lastAction
          //getMemoizedTree: PropTypes.func.isRequired,
        };

        var ConnectedQuery = connect(function (state) {
          return {
            tree: state.tree,
            __isInternalValueChange: state.__isInternalValueChange,
            __lastAction: state.__lastAction
          };
        }, null, null, {
          context: context
        })(Query);
        ConnectedQuery.displayName = "ConnectedQuery";
        function _createSuper$q(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$q();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct$q() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var defaultRoot = Utils$1.DefaultUtils.defaultRoot;
        var QueryContainer = /*#__PURE__*/function (_Component) {
          _inherits$b(QueryContainer, _Component);
          var _super = _createSuper$q(QueryContainer);
          function QueryContainer(props, context) {
            var _this;
            _classCallCheck$b(this, QueryContainer);
            _this = _super.call(this, props, context);
            _this.setLastTree = function (lastTree) {
              if (_this.prevTree) {
                _this.prevprevTree = _this.prevTree;
              }
              _this.prevTree = lastTree;
            };
            _this.shouldComponentUpdate = liteShouldComponentUpdate(_assertThisInitialized$1(_this), {
              value: function value(nextValue, prevValue, state) {
                return false;
              }
            });
            useOnPropsChanged(_assertThisInitialized$1(_this));
            _this.getMemoizedConfig = createConfigMemo();
            _this.getMemoizedTree = createValidationMemo();
            var config = _this.getMemoizedConfig(props);
            var tree = props.value;
            var validatedTree = _this.getMemoizedTree(config, tree);
            var reducer = TreeStore(config, validatedTree, _this.getMemoizedTree, _this.setLastTree);
            var store = createStore(reducer);
            _this.config = config;
            _this.state = {
              store: store
            };
            return _this;
          }
          _createClass$9(QueryContainer, [{
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {
              // compare configs
              var oldConfig = this.config;
              var nextConfig = this.getMemoizedConfig(nextProps);
              var isConfigChanged = oldConfig !== nextConfig;

              // compare trees
              var storeValue = this.state.store.getState().tree;
              var isTreeChanged = !immutableEqual(nextProps.value, this.props.value) && !immutableEqual(nextProps.value, storeValue);
              var currentTree = isTreeChanged ? nextProps.value || defaultRoot(nextProps) : storeValue;
              var isTreeTrulyChanged = isTreeChanged && !immutableEqual(nextProps.value, this.prevTree) && !immutableEqual(nextProps.value, this.prevprevTree);
              var sanitizeTree = isTreeTrulyChanged || isConfigChanged;
              if (isConfigChanged) {
                this.config = nextConfig;
              }
              if (isTreeChanged || isConfigChanged) {
                var validatedTree = this.getMemoizedTree(nextConfig, currentTree, oldConfig, sanitizeTree);
                //return Promise.resolve().then(() => {
                this.state.store.dispatch(tree.setTree(nextConfig, validatedTree));
                //});
              }
            }
          }, {
            key: "render",
            value: function render() {
              // `get_children` is deprecated!
              var _this$props = this.props,
                renderBuilder = _this$props.renderBuilder,
                get_children = _this$props.get_children,
                onChange = _this$props.onChange,
                settings = _this$props.settings;
              var store = this.state.store;
              var config = this.config;
              var QueryWrapper = settings.renderProvider;
              return /*#__PURE__*/React.createElement(QueryWrapper, {
                config: config
              }, /*#__PURE__*/React.createElement(Provider, {
                store: store,
                context: context
              }, /*#__PURE__*/React.createElement(ConnectedQuery, {
                config: config,
                getMemoizedTree: this.getMemoizedTree,
                onChange: onChange,
                renderBuilder: renderBuilder || get_children
              })));
            }
          }]);
          return QueryContainer;
        }(reactExports.Component);
        QueryContainer.propTypes = {
          //config
          conjunctions: PropTypes.object.isRequired,
          fields: PropTypes.object.isRequired,
          types: PropTypes.object.isRequired,
          operators: PropTypes.object.isRequired,
          widgets: PropTypes.object.isRequired,
          settings: PropTypes.object.isRequired,
          onChange: PropTypes.func,
          renderBuilder: PropTypes.func,
          value: PropTypes.any //instanceOf(Immutable.Map)
        };

        function _createSuper$p(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$p();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct$p() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var getFieldConfig$7 = Utils$1.ConfigUtils.getFieldConfig;
        var createRuleContainer = function createRuleContainer(Rule) {
          var _class;
          return _class = /*#__PURE__*/function (_Component) {
            _inherits$b(RuleContainer, _Component);
            var _super = _createSuper$p(RuleContainer);
            function RuleContainer(props) {
              var _this;
              _classCallCheck$b(this, RuleContainer);
              _this = _super.call(this, props);
              _this.dummyFn = function () {};
              _this.removeSelf = function () {
                _this.props.actions.removeRule(_this.props.path);
              };
              _this.setLock = function () {
                var lock = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
                _this.props.actions.setLock(_this.props.path, lock);
              };
              _this.setField = function (field) {
                _this.props.actions.setField(_this.props.path, field);
              };
              _this.setOperator = function (operator) {
                _this.props.actions.setOperator(_this.props.path, operator);
              };
              _this.setOperatorOption = function (name, value) {
                _this.props.actions.setOperatorOption(_this.props.path, name, value);
              };
              _this.setValue = function (delta, value, type, asyncListValues, __isInternal) {
                _this.props.actions.setValue(_this.props.path, delta, value, type, asyncListValues, __isInternal);
              };
              _this.setValueSrc = function (delta, srcKey) {
                _this.props.actions.setValueSrc(_this.props.path, delta, srcKey);
              };
              _this.pureShouldComponentUpdate = pureShouldComponentUpdate(_assertThisInitialized$1(_this));
              _this.dummyFn.isDummyFn = true;
              return _this;
            }
            _createClass$9(RuleContainer, [{
              key: "shouldComponentUpdate",
              value: function shouldComponentUpdate(nextProps, nextState) {
                var prevProps = this.props;
                var prevState = this.state;
                var should = this.pureShouldComponentUpdate(nextProps, nextState);
                if (should) {
                  if (prevState == nextState && prevProps != nextProps) {
                    var draggingId = nextProps.dragging.id || prevProps.dragging.id;
                    var isDraggingMe = draggingId == nextProps.id;
                    var chs = [];
                    for (var k in nextProps) {
                      var changed = nextProps[k] != prevProps[k];
                      if (k == "dragging" && !isDraggingMe) {
                        changed = false; //dragging another item -> ignore
                      }

                      if (changed) {
                        chs.push(k);
                      }
                    }
                    if (!chs.length) should = false;
                  }
                }
                return should;
              }
            }, {
              key: "render",
              value: function render() {
                var isDraggingMe = this.props.dragging.id == this.props.id;
                var fieldConfig = getFieldConfig$7(this.props.config, this.props.field);
                var showErrorMessage = this.props.config.settings.showErrorMessage;
                fieldConfig && fieldConfig.type == "!struct";
                var isInDraggingTempo = !isDraggingMe && this.props.isDraggingTempo;
                var valueError = this.props.valueError;
                var oneValueError = valueError && valueError.toArray().filter(function (e) {
                  return !!e;
                }).shift() || null;
                var hasError = oneValueError != null && showErrorMessage;
                return /*#__PURE__*/React.createElement("div", {
                  className: classNames("group-or-rule-container", "rule-container", hasError ? "rule-with-error" : null),
                  "data-id": this.props.id
                }, [isDraggingMe ? /*#__PURE__*/React.createElement(Rule, {
                  key: "dragging",
                  id: this.props.id,
                  groupId: this.props.groupId,
                  isDraggingMe: true,
                  isDraggingTempo: true,
                  dragging: this.props.dragging,
                  setField: this.dummyFn,
                  setOperator: this.dummyFn,
                  setOperatorOption: this.dummyFn,
                  setLock: this.dummyFn,
                  removeSelf: this.dummyFn,
                  setValue: this.dummyFn,
                  setValueSrc: this.dummyFn,
                  selectedField: this.props.field || null,
                  parentField: this.props.parentField || null,
                  selectedOperator: this.props.operator || null,
                  value: this.props.value || null,
                  valueSrc: this.props.valueSrc || null,
                  valueError: this.props.valueError || null,
                  operatorOptions: this.props.operatorOptions,
                  config: this.props.config,
                  reordableNodesCnt: this.props.reordableNodesCnt,
                  totalRulesCnt: this.props.totalRulesCnt,
                  asyncListValues: this.props.asyncListValues,
                  isLocked: this.props.isLocked,
                  isTrueLocked: this.props.isTrueLocked,
                  parentReordableNodesCnt: this.props.parentReordableNodesCnt
                }) : null, /*#__PURE__*/React.createElement(Rule, {
                  key: this.props.id,
                  id: this.props.id,
                  groupId: this.props.groupId,
                  isDraggingMe: isDraggingMe,
                  isDraggingTempo: isInDraggingTempo,
                  onDragStart: this.props.onDragStart,
                  setLock: isInDraggingTempo ? this.dummyFn : this.setLock,
                  removeSelf: isInDraggingTempo ? this.dummyFn : this.removeSelf,
                  setField: isInDraggingTempo ? this.dummyFn : this.setField,
                  setOperator: isInDraggingTempo ? this.dummyFn : this.setOperator,
                  setOperatorOption: isInDraggingTempo ? this.dummyFn : this.setOperatorOption,
                  setValue: isInDraggingTempo ? this.dummyFn : this.setValue,
                  setValueSrc: isInDraggingTempo ? this.dummyFn : this.setValueSrc,
                  selectedField: this.props.field || null,
                  parentField: this.props.parentField || null,
                  selectedOperator: this.props.operator || null,
                  value: this.props.value || null,
                  valueSrc: this.props.valueSrc || null,
                  valueError: this.props.valueError || null,
                  operatorOptions: this.props.operatorOptions,
                  config: this.props.config,
                  reordableNodesCnt: this.props.reordableNodesCnt,
                  totalRulesCnt: this.props.totalRulesCnt,
                  asyncListValues: this.props.asyncListValues,
                  isLocked: this.props.isLocked,
                  isTrueLocked: this.props.isTrueLocked,
                  parentReordableNodesCnt: this.props.parentReordableNodesCnt
                })]);
              }
            }]);
            return RuleContainer;
          }(reactExports.Component), _class.propTypes = {
            id: PropTypes.string.isRequired,
            groupId: PropTypes.string,
            config: PropTypes.object.isRequired,
            path: PropTypes.any.isRequired,
            //instanceOf(Immutable.List)
            operator: PropTypes.string,
            field: PropTypes.string,
            actions: PropTypes.object.isRequired,
            //{removeRule: Funciton, setField, setOperator, setOperatorOption, setValue, setValueSrc, ...}
            onDragStart: PropTypes.func,
            value: PropTypes.any,
            //depends on widget
            valueSrc: PropTypes.any,
            asyncListValues: PropTypes.array,
            valueError: PropTypes.any,
            operatorOptions: PropTypes.object,
            reordableNodesCnt: PropTypes.number,
            parentField: PropTypes.string,
            //from RuleGroup
            isLocked: PropTypes.bool,
            isTrueLocked: PropTypes.bool,
            //connected:
            dragging: PropTypes.object,
            //{id, x, y, w, h}
            isDraggingTempo: PropTypes.bool
          }, _class;
        };
        const RuleContainer = function (Rule) {
          var ConnectedRuleContainer = connect(function (state) {
            return {
              dragging: state.dragging
            };
          }, null, null, {
            context: context
          })(createRuleContainer(Rule));
          ConnectedRuleContainer.displayName = "ConnectedRuleContainer";
          return ConnectedRuleContainer;
        };
        function _createSuper$o(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$o();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct$o() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var clone$2 = Utils$1.clone;
        var getFlatTree = Utils$1.TreeUtils.getFlatTree;
        var _isReorderingTree = false;
        var createSortableContainer = function createSortableContainer(Builder) {
          var _class;
          var CanMoveFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return _class = /*#__PURE__*/function (_Component) {
            _inherits$b(SortableContainer, _Component);
            var _super = _createSuper$o(SortableContainer);
            function SortableContainer(props) {
              var _this;
              _classCallCheck$b(this, SortableContainer);
              _this = _super.call(this, props);
              _this._getEventTarget = function (e, dragStart) {
                return e && e.__mocked_window || document.body || window;
              };
              _this.onDragStart = function (id, dom, e) {
                var treeEl = dom.closest(".query-builder");
                if (_this._isUsingLegacyReactDomRender === undefined) {
                  _this._isUsingLegacyReactDomRender = isUsingLegacyReactDomRender(treeEl);
                }
                document.body.classList.add("qb-dragging");
                treeEl.classList.add("qb-dragging");
                var treeElContainer = treeEl.closest(".query-builder-container") || treeEl;
                treeElContainer = _this._getScrollParent(treeElContainer) || document.body;
                var scrollTop = treeElContainer.scrollTop;
                _this._getDraggableNodeEl(treeEl);
                _this._getPlaceholderNodeEl(treeEl);
                var tmpAllGroups = treeEl.querySelectorAll(".group--children");
                var anyGroup = tmpAllGroups.length ? tmpAllGroups[0] : null;
                var groupPadding;
                if (anyGroup) {
                  groupPadding = window.getComputedStyle(anyGroup, null).getPropertyValue("padding-left");
                  groupPadding = parseInt(groupPadding);
                }
                var dragging = {
                  id: id,
                  x: dom.offsetLeft,
                  y: dom.offsetTop,
                  w: dom.offsetWidth,
                  h: dom.offsetHeight,
                  itemInfo: _this.tree.items[id],
                  paddingLeft: groupPadding
                };
                var dragStart = {
                  id: id,
                  x: dom.offsetLeft,
                  y: dom.offsetTop,
                  scrollTop: scrollTop,
                  clientX: e.clientX,
                  clientY: e.clientY,
                  itemInfo: clone$2(_this.tree.items[id]),
                  treeEl: treeEl,
                  treeElContainer: treeElContainer
                };
                var mousePos = {
                  clientX: e.clientX,
                  clientY: e.clientY
                };
                var target = _this._getEventTarget(e, dragStart);
                _this.eventTarget = target;
                target.addEventListener("mousemove", _this.onDrag);
                target.addEventListener("mouseup", _this.onDragEnd);
                _this.props.setDragStart(dragStart, dragging, mousePos);
              };
              _this.onDrag = function (e) {
                var doHandleDrag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
                var dragging = Object.assign({}, _this.props.dragging);
                var startDragging = _this.props.dragStart;
                var paddingLeft = dragging.paddingLeft; //this.props.paddingLeft;
                var treeElContainer = startDragging.treeElContainer;
                var scrollTop = treeElContainer.scrollTop;
                dragging.itemInfo = _this.tree.items[dragging.id];
                if (!dragging.itemInfo) {
                  return;
                }
                var mousePos = {
                  clientX: e.clientX,
                  clientY: e.clientY
                };
                var startMousePos = {
                  clientX: startDragging.clientX,
                  clientY: startDragging.clientY
                };
                if (e.__mock_dom) {
                  var treeEl = startDragging.treeEl;
                  var dragEl = _this._getDraggableNodeEl(treeEl);
                  var plhEl = _this._getPlaceholderNodeEl(treeEl);
                  e.__mock_dom({
                    treeEl: treeEl,
                    dragEl: dragEl,
                    plhEl: plhEl
                  });
                }

                //first init plX/plY
                if (!startDragging.plX) {
                  var _treeEl = startDragging.treeEl;
                  var _plhEl2 = _this._getPlaceholderNodeEl(_treeEl);
                  if (_plhEl2) {
                    startDragging.plX = _plhEl2.getBoundingClientRect().left + window.scrollX;
                    startDragging.plY = _plhEl2.getBoundingClientRect().top + window.scrollY;
                  }
                }
                var startX = startDragging.x;
                var startY = startDragging.y;
                var startClientX = startDragging.clientX;
                var startClientY = startDragging.clientY;
                var startScrollTop = startDragging.scrollTop;
                var pos = {
                  x: startX + (e.clientX - startClientX),
                  y: startY + (e.clientY - startClientY) + (scrollTop - startScrollTop)
                };
                dragging.x = pos.x;
                dragging.y = pos.y;
                dragging.paddingLeft = paddingLeft;
                dragging.mousePos = mousePos;
                dragging.startMousePos = startMousePos;
                _this.props.setDragProgress(mousePos, dragging);
                var moved = doHandleDrag ? _this.handleDrag(dragging, e, CanMoveFn) : false;
                if (!moved) {
                  if (e.preventDefault) e.preventDefault();
                }
              };
              _this.onDragEnd = function () {
                var treeEl = _this.props.dragStart.treeEl;
                _this.props.setDragEnd();
                treeEl.classList.remove("qb-dragging");
                document.body.classList.remove("qb-dragging");
                _this._cacheEls = {};
                var target = _this.eventTarget || _this._getEventTarget();
                target.removeEventListener("mousemove", _this.onDrag);
                target.removeEventListener("mouseup", _this.onDragEnd);
              };
              _this.pureShouldComponentUpdate = pureShouldComponentUpdate(_assertThisInitialized$1(_this));
              useOnPropsChanged(_assertThisInitialized$1(_this));
              _this.onPropsChanged(props);
              return _this;
            }
            _createClass$9(SortableContainer, [{
              key: "onPropsChanged",
              value: function onPropsChanged(nextProps) {
                this.tree = getFlatTree(nextProps.tree);
              }
            }, {
              key: "shouldComponentUpdate",
              value: function shouldComponentUpdate(nextProps, nextState) {
                var prevProps = this.props;
                var prevState = this.state;
                var should = this.pureShouldComponentUpdate(nextProps, nextState);
                if (should) {
                  if (prevState == nextState && prevProps != nextProps) {
                    var chs = [];
                    for (var k in nextProps) {
                      var changed = nextProps[k] != prevProps[k];
                      if (changed) {
                        //don't render <Builder> on dragging - appropriate redux-connected components will do it
                        if (k != "dragging" && k != "mousePos") chs.push(k);
                      }
                    }
                    if (!chs.length) should = false;
                  }
                }
                return should;
              }
            }, {
              key: "componentDidUpdate",
              value: function componentDidUpdate(_prevProps, _prevState) {
                var dragging = this.props.dragging;
                var startDragging = this.props.dragStart;
                _isReorderingTree = false;
                if (startDragging && startDragging.id) {
                  dragging.itemInfo = this.tree.items[dragging.id];
                  if (dragging.itemInfo) {
                    if (dragging.itemInfo.index != startDragging.itemInfo.index || dragging.itemInfo.parent != startDragging.itemInfo.parent) {
                      var treeEl = startDragging.treeEl;
                      var treeElContainer = startDragging.treeElContainer;
                      var plhEl = this._getPlaceholderNodeEl(treeEl, true);
                      if (plhEl) {
                        var plX = plhEl.getBoundingClientRect().left + window.scrollX;
                        var plY = plhEl.getBoundingClientRect().top + window.scrollY;
                        var oldPlX = startDragging.plX;
                        var oldPlY = startDragging.plY;
                        var scrollTop = treeElContainer.scrollTop;
                        startDragging.plX = plX;
                        startDragging.plY = plY;
                        startDragging.itemInfo = clone$2(dragging.itemInfo);
                        startDragging.y = plhEl.offsetTop;
                        startDragging.x = plhEl.offsetLeft;
                        startDragging.clientY += plY - oldPlY;
                        startDragging.clientX += plX - oldPlX;
                        if (treeElContainer != document.body) startDragging.scrollTop = scrollTop;
                        this.onDrag(this.props.mousePos, false);
                      }
                    }
                  }
                }
              }
            }, {
              key: "_getNodeElById",
              value: function _getNodeElById(treeEl, indexId) {
                var ignoreCache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                if (indexId == null) return null;
                if (!this._cacheEls) this._cacheEls = {};
                var el = this._cacheEls[indexId];
                if (el && document.contains(el) && !ignoreCache) return el;
                el = treeEl.querySelector('.group-or-rule-container[data-id="' + indexId + '"]');
                this._cacheEls[indexId] = el;
                return el;
              }
            }, {
              key: "_getDraggableNodeEl",
              value: function _getDraggableNodeEl(treeEl) {
                var ignoreCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                if (!this._cacheEls) this._cacheEls = {};
                var el = this._cacheEls["draggable"];
                if (el && document.contains(el) && !ignoreCache) return el;
                var els = treeEl.getElementsByClassName("qb-draggable");
                el = els.length ? els[0] : null;
                this._cacheEls["draggable"] = el;
                return el;
              }
            }, {
              key: "_getPlaceholderNodeEl",
              value: function _getPlaceholderNodeEl(treeEl) {
                var ignoreCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                if (!this._cacheEls) this._cacheEls = {};
                var el = this._cacheEls["placeholder"];
                if (el && document.contains(el) && !ignoreCache) return el;
                var els = treeEl.getElementsByClassName("qb-placeholder");
                el = els.length ? els[0] : null;
                this._cacheEls["placeholder"] = el;
                return el;
              }
            }, {
              key: "_isScrollable",
              value: function _isScrollable(node) {
                var overflowY = window.getComputedStyle(node)["overflow-y"];
                return (overflowY === "scroll" || overflowY === "auto") && node.scrollHeight > node.offsetHeight;
              }
            }, {
              key: "_getScrollParent",
              value: function _getScrollParent(node) {
                if (node == null) return null;
                if (node === document.body || this._isScrollable(node)) {
                  return node;
                } else {
                  return this._getScrollParent(node.parentNode);
                }
              }
            }, {
              key: "handleDrag",
              value: function handleDrag(dragInfo, e, canMoveFn) {
                var _this2 = this;
                var canMoveBeforeAfterGroup = true;
                var itemInfo = dragInfo.itemInfo;
                var paddingLeft = dragInfo.paddingLeft;
                var moveInfo = null;
                var treeEl = this.props.dragStart.treeEl;
                var dragId = dragInfo.id;
                var dragEl = this._getDraggableNodeEl(treeEl);
                var plhEl = this._getPlaceholderNodeEl(treeEl);
                var dragRect, plhRect, hovRect, treeRect;
                if (dragEl && plhEl) {
                  dragRect = dragEl.getBoundingClientRect();
                  plhRect = plhEl.getBoundingClientRect();
                  if (!plhRect.width) {
                    return;
                  }
                  var dragDirs = {
                    hrz: 0,
                    vrt: 0
                  };
                  if (dragRect.top < plhRect.top) dragDirs.vrt = -1; //up
                  else if (dragRect.bottom > plhRect.bottom) dragDirs.vrt = +1; //down
                  if (dragRect.left > plhRect.left) dragDirs.hrz = +1; //right
                  else if (dragRect.left < plhRect.left) dragDirs.hrz = -1; //left

                  treeRect = treeEl.getBoundingClientRect();
                  var trgCoord = {
                    x: treeRect.left + (treeRect.right - treeRect.left) / 2,
                    y: dragDirs.vrt >= 0 ? dragRect.bottom : dragRect.top
                  };
                  var hovCNodeEl;
                  if (e.__mocked_hov_container) {
                    hovCNodeEl = e.__mocked_hov_container;
                  } else {
                    var hovNodeEl = document.elementFromPoint(trgCoord.x, trgCoord.y - 1);
                    hovCNodeEl = hovNodeEl ? hovNodeEl.closest(".group-or-rule-container") : null;
                    if (!hovCNodeEl && hovNodeEl && hovNodeEl.classList.contains("query-builder-container")) {
                      var _hovNodeEl$firstChild;
                      // fix 2022-01-24 - get root .group-or-rule-container
                      var rootGroupContainer = hovNodeEl === null || hovNodeEl === void 0 ? void 0 : (_hovNodeEl$firstChild = hovNodeEl.firstChild) === null || _hovNodeEl$firstChild === void 0 ? void 0 : _hovNodeEl$firstChild.firstChild;
                      if (rootGroupContainer && rootGroupContainer.classList.contains("group-or-rule-container")) {
                        hovCNodeEl = rootGroupContainer;
                      }
                    }
                  }
                  if (!hovCNodeEl) {
                    logger.log("out of tree bounds!");
                  } else {
                    var isGroup = hovCNodeEl.classList.contains("group-container");
                    var hovNodeId = hovCNodeEl.getAttribute("data-id");
                    var hovEl = hovCNodeEl;
                    var doAppend = false;
                    var doPrepend = false;
                    if (hovEl) {
                      hovRect = hovEl.getBoundingClientRect();
                      var hovHeight = hovRect.bottom - hovRect.top;
                      var hovII = this.tree.items[hovNodeId];
                      var trgRect = null,
                        trgEl = null,
                        trgII = null,
                        altII = null; //for canMoveBeforeAfterGroup

                      if (dragDirs.vrt == 0) {
                        trgII = itemInfo;
                        trgEl = plhEl;
                        if (trgEl) trgRect = trgEl.getBoundingClientRect();
                      } else {
                        if (isGroup) {
                          if (dragDirs.vrt > 0) {
                            //down
                            //take group header (for prepend only)
                            var hovInnerEl = hovCNodeEl.getElementsByClassName("group--header");
                            var hovEl2 = hovInnerEl.length ? hovInnerEl[0] : null;
                            if (hovEl2) {
                              var hovRect2 = hovEl2.getBoundingClientRect();
                              var hovHeight2 = hovRect2.bottom - hovRect2.top;
                              var isOverHover = dragRect.bottom - hovRect2.top > hovHeight2 * 3 / 4;
                              if (isOverHover && hovII.top > dragInfo.itemInfo.top) {
                                trgII = hovII;
                                trgRect = hovRect2;
                                trgEl = hovEl2;
                                doPrepend = true;
                              }
                            }
                          } else if (dragDirs.vrt < 0) {
                            //up
                            if (hovII.lev >= itemInfo.lev) {
                              //take whole group
                              var isClimbToHover = hovRect.bottom - dragRect.top >= 2;
                              if (isClimbToHover && hovII.top < dragInfo.itemInfo.top) {
                                trgII = hovII;
                                trgRect = hovRect;
                                trgEl = hovEl;
                                doAppend = true;
                              }
                            }
                          }
                          if (!doPrepend && !doAppend || canMoveBeforeAfterGroup) {
                            //take whole group and check if we can move before/after group
                            var _isOverHover = dragDirs.vrt < 0 //up
                            ? hovRect.bottom - dragRect.top > hovHeight - 5 : dragRect.bottom - hovRect.top > hovHeight - 5;
                            if (_isOverHover) {
                              if (!doPrepend && !doAppend) {
                                trgII = hovII;
                                trgRect = hovRect;
                                trgEl = hovEl;
                              }
                              {
                                altII = hovII;
                              }
                            }
                          }
                        } else {
                          //check if we can move before/after group
                          var _isOverHover2 = dragDirs.vrt < 0 //up
                          ? hovRect.bottom - dragRect.top > hovHeight / 2 : dragRect.bottom - hovRect.top > hovHeight / 2;
                          if (_isOverHover2) {
                            trgII = hovII;
                            trgRect = hovRect;
                            trgEl = hovEl;
                          }
                        }
                      }
                      var isSamePos = trgII && trgII.id == dragId;
                      if (trgRect) {
                        var dragLeftOffset = dragRect.left - treeRect.left;
                        trgRect.left - treeRect.left;
                        var dragLev = Math.max(0, Math.round(dragLeftOffset / paddingLeft));

                        //find all possible moves
                        var availMoves = [];
                        var altMoves = []; //alternatively can move after/before group, if can't move into it
                        if (isSamePos) ;else {
                          if (isGroup) {
                            if (doAppend) {
                              availMoves.push([PLACEMENT_APPEND, trgII, trgII.lev + 1]);
                            } else if (doPrepend) {
                              availMoves.push([PLACEMENT_PREPEND, trgII, trgII.lev + 1]);
                            }
                            //alt
                            if (altII) {
                              // fix 2022-01-24: do prepend/append instead of before/after for root
                              var isToRoot = altII.lev == 0;
                              // fix 2022-01-25: fix prepend/append instead of before/after for case_group
                              var isToCase = altII.type == "case_group" && itemInfo.type != "case_group";
                              var prevCaseId = altII.prev && this.tree.items[altII.prev].caseId;
                              var nextCaseId = altII.next && this.tree.items[altII.next].caseId;
                              if (itemInfo.caseId == prevCaseId) prevCaseId = null;
                              if (itemInfo.caseId == nextCaseId) nextCaseId = null;
                              var prevCase = prevCaseId && this.tree.items[prevCaseId];
                              var nextCase = nextCaseId && this.tree.items[nextCaseId];
                              if (dragDirs.vrt > 0) {
                                //down
                                if (isToRoot) {
                                  altMoves.push([PLACEMENT_APPEND, altII, altII.lev + 1]);
                                } else if (isToCase && nextCase) {
                                  altMoves.push([PLACEMENT_PREPEND, nextCase, nextCase.lev + 1]);
                                } else {
                                  altMoves.push([PLACEMENT_AFTER, altII, altII.lev]);
                                }
                              } else if (dragDirs.vrt < 0) {
                                //up
                                if (isToRoot) {
                                  altMoves.push([PLACEMENT_PREPEND, altII, altII.lev + 1]);
                                } else if (isToCase && prevCase) {
                                  altMoves.push([PLACEMENT_APPEND, prevCase, prevCase.lev + 1]);
                                } else {
                                  altMoves.push([PLACEMENT_BEFORE, altII, altII.lev]);
                                }
                              }
                            }
                          }
                          if (!doAppend && !doPrepend) {
                            if (dragDirs.vrt < 0) {
                              //up
                              availMoves.push([PLACEMENT_BEFORE, trgII, trgII.lev]);
                            } else if (dragDirs.vrt > 0) {
                              //down
                              availMoves.push([PLACEMENT_AFTER, trgII, trgII.lev]);
                            }
                          }
                        }

                        //add case
                        var addCaseII = function addCaseII(am) {
                          var toII = am[1];
                          var fromCaseII = itemInfo.caseId ? _this2.tree.items[itemInfo.caseId] : null;
                          var toCaseII = toII.caseId ? _this2.tree.items[toII.caseId] : null;
                          return [].concat(_toConsumableArray(am), [fromCaseII, toCaseII]);
                        };
                        availMoves = availMoves.map(addCaseII);
                        altMoves = altMoves.map(addCaseII);

                        //sanitize
                        availMoves = availMoves.filter(function (am) {
                          var placement = am[0];
                          var trg = am[1];
                          if ((placement == PLACEMENT_BEFORE || placement == PLACEMENT_AFTER) && trg.parent == null) return false;
                          if (trg.collapsed && (placement == PLACEMENT_APPEND || placement == PLACEMENT_PREPEND)) return false;
                          var isInside = trg.id == itemInfo.id;
                          if (!isInside) {
                            var tmp = trg;
                            while (tmp.parent) {
                              tmp = _this2.tree.items[tmp.parent];
                              if (tmp.id == itemInfo.id) {
                                isInside = true;
                                break;
                              }
                            }
                          }
                          return !isInside;
                        }).map(function (am) {
                          var placement = am[0],
                            toII = am[1];
                          am[2];
                          am[3];
                          am[4];
                          var toParentII = null;
                          if (placement == PLACEMENT_APPEND || placement == PLACEMENT_PREPEND) toParentII = toII;else toParentII = _this2.tree.items[toII.parent];
                          if (toParentII && toParentII.parent == null) toParentII = null;
                          am[5] = toParentII;
                          return am;
                        });
                        var bestMode = null;
                        var filteredMoves = availMoves.filter(function (am) {
                          return _this2.canMove(itemInfo, am[1], am[0], am[3], am[4], am[5], canMoveFn);
                        });
                        if (filteredMoves.length == 0 && altMoves.length > 0) {
                          filteredMoves = altMoves.filter(function (am) {
                            return _this2.canMove(itemInfo, am[1], am[0], am[3], am[4], am[5], canMoveFn);
                          });
                        }
                        var levs = filteredMoves.map(function (am) {
                          return am[2];
                        });
                        var curLev = itemInfo.lev;
                        var allLevs = levs.concat(curLev);
                        var closestDragLev = null;
                        if (allLevs.indexOf(dragLev) != -1) closestDragLev = dragLev;else if (dragLev > Math.max.apply(Math, _toConsumableArray(allLevs))) closestDragLev = Math.max.apply(Math, _toConsumableArray(allLevs));else if (dragLev < Math.min.apply(Math, _toConsumableArray(allLevs))) closestDragLev = Math.min.apply(Math, _toConsumableArray(allLevs));
                        bestMode = filteredMoves.find(function (am) {
                          return am[2] == closestDragLev;
                        });
                        if (!isSamePos && !bestMode && filteredMoves.length) bestMode = filteredMoves[0];
                        moveInfo = bestMode;
                      }
                    }
                  }
                }
                if (moveInfo) {
                  this.move(itemInfo, moveInfo[1], moveInfo[0], moveInfo[3]);

                  // logger.log("DRAG-N-DROP", JSON.stringify({
                  //   dragRect,
                  //   plhRect,
                  //   treeRect,
                  //   hovRect,
                  //   startMousePos: dragInfo.startMousePos,
                  //   mousePos: dragInfo.mousePos,
                  // }));
                  return true;
                }
                return false;
              }
            }, {
              key: "canMove",
              value: function canMove(fromII, toII, placement, fromCaseII, toCaseII, toParentII, canMoveFn) {
                if (!fromII || !toII) return false;
                if (fromII.id === toII.id) return false;
                var _this$props$config$se = this.props.config.settings,
                  canRegroup = _this$props$config$se.canRegroup,
                  canRegroupCases = _this$props$config$se.canRegroupCases,
                  maxNesting = _this$props$config$se.maxNesting,
                  maxNumberOfRules = _this$props$config$se.maxNumberOfRules,
                  canLeaveEmptyCase = _this$props$config$se.canLeaveEmptyCase;
                var newLev = toParentII ? toParentII.lev + 1 : toII.lev;
                var isBeforeAfter = placement == PLACEMENT_BEFORE || placement == PLACEMENT_AFTER;
                var isPend = placement == PLACEMENT_PREPEND || placement == PLACEMENT_APPEND;
                var isLev1 = isBeforeAfter && toII.lev == 1 || isPend && toII.lev == 0;
                var isParentChange = fromII.parent != toII.parent;
                var isStructChange = isPend || isParentChange;
                // can't move `case_group` anywhere but before/after anoter `case_group`
                var isForbiddenStructChange = fromII.type == "case_group" && !isLev1
                // can't restruct `rule_group`
                || fromII.parentType == "rule_group" || toII.type == "rule_group" || toII.parentType == "rule_group"
                // only `case_group` can be placed under `switch_group`
                || fromII.type != "case_group" && toII.type == "case_group" && isBeforeAfter || fromII.type != "case_group" && toII.type == "switch_group"
                // can't move rule/group to another case
                || !canRegroupCases && fromII.caseId != toII.caseId;
                var isLockedChange = toII.isLocked || fromII.isLocked || toParentII && toParentII.isLocked;
                if (maxNesting && newLev > maxNesting) return false;
                if (isStructChange && (!canRegroup || isForbiddenStructChange || isLockedChange)) return false;
                if (fromII.type != "case_group" && fromII.caseId != toII.caseId) {
                  var isLastFromCase = fromCaseII ? fromCaseII._height == 2 : false;
                  var newRulesInTargetCase = toCaseII ? toCaseII.leafsCount + 1 : 0;
                  if (maxNumberOfRules && newRulesInTargetCase > maxNumberOfRules) return false;
                  if (isLastFromCase && !canLeaveEmptyCase) return false;
                }
                if (fromII.type == "case_group" && (fromII.isDefaultCase || toII.isDefaultCase || toII.type == "switch_group" && placement == PLACEMENT_APPEND)) {
                  // leave default case alone
                  return false;
                }
                var res = true;
                if (canMoveFn) {
                  res = canMoveFn(fromII.node.toJS(), toII.node.toJS(), placement, toParentII ? toParentII.node.toJS() : null);
                }
                return res;
              }
            }, {
              key: "move",
              value: function move(fromII, toII, placement, toParentII) {
                if (!this._isUsingLegacyReactDomRender) {
                  _isReorderingTree = true;
                }
                //logger.log("move", fromII, toII, placement, toParentII);
                this.props.actions.moveItem(fromII.path, toII.path, placement);
              }
            }, {
              key: "render",
              value: function render() {
                return /*#__PURE__*/React.createElement(Builder, _extends$h({}, this.props, {
                  onDragStart: this.onDragStart
                }));
              }
            }]);
            return SortableContainer;
          }(reactExports.Component), _class.propTypes = {
            tree: PropTypes.any.isRequired,
            //instanceOf(Immutable.Map)
            actions: PropTypes.object.isRequired // {moveItem: Function, ..}
            //... see Builder
          }, _class;
        };
        const SortableContainer = function (Builder) {
          var CanMoveFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var ConnectedSortableContainer = connect(function (state) {
            return {
              dragging: state.dragging,
              dragStart: state.dragStart,
              mousePos: state.mousePos
            };
          }, {
            setDragStart: setDragStart,
            setDragProgress: setDragProgress,
            setDragEnd: setDragEnd
          }, null, {
            context: context
          })(createSortableContainer(Builder, CanMoveFn));
          ConnectedSortableContainer.displayName = "ConnectedSortableContainer";
          return ConnectedSortableContainer;
        };
        var _excluded$8 = ["isDraggingTempo", "isDraggingMe", "dragging"];
        function _createSuper$n(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$n();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct$n() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        const Draggable = function (className) {
          return function (GroupOrRule) {
            var _class;
            return _class = /*#__PURE__*/function (_PureComponent) {
              _inherits$b(Draggable, _PureComponent);
              var _super = _createSuper$n(Draggable);
              function Draggable(props) {
                var _this;
                _classCallCheck$b(this, Draggable);
                _this = _super.call(this, props);
                _this.handleDraggerMouseDown = function (e) {
                  var nodeId = _this.props.id;
                  var dom = _this.wrapper.current;
                  if (_this.props.onDragStart) {
                    _this.props.onDragStart(nodeId, dom, e);
                  }
                };
                _this.wrapper = /*#__PURE__*/React.createRef();
                return _this;
              }
              _createClass$9(Draggable, [{
                key: "render",
                value: function render() {
                  var _this$props = this.props,
                    isDraggingTempo = _this$props.isDraggingTempo,
                    isDraggingMe = _this$props.isDraggingMe,
                    dragging = _this$props.dragging,
                    otherProps = _objectWithoutProperties$2(_this$props, _excluded$8);
                  var isTrueLocked = otherProps.isTrueLocked;
                  var styles = {};
                  if (isDraggingMe && isDraggingTempo) {
                    if (_isReorderingTree) ;else {
                      styles = {
                        top: dragging.y,
                        left: dragging.x,
                        width: dragging.w
                      };
                    }
                  }
                  var cn = classNames(className, "group-or-rule", isDraggingMe && isDraggingTempo ? "qb-draggable" : null, isDraggingMe && !isDraggingTempo ? "qb-placeholder" : null, isTrueLocked ? "locked" : null);
                  return /*#__PURE__*/React.createElement("div", {
                    className: cn,
                    style: styles,
                    ref: this.wrapper,
                    "data-id": this.props.id
                  }, /*#__PURE__*/React.createElement(GroupOrRule, _extends$h({
                    handleDraggerMouseDown: this.handleDraggerMouseDown,
                    isDraggingMe: isDraggingMe,
                    isDraggingTempo: isDraggingTempo
                  }, otherProps)));
                }
              }]);
              return Draggable;
            }(reactExports.PureComponent), _class.propTypes = {
              isDraggingTempo: PropTypes.bool,
              isDraggingMe: PropTypes.bool,
              onDragStart: PropTypes.func,
              dragging: PropTypes.object,
              //{id, x, y, w, h}
              isLocked: PropTypes.bool,
              isTrueLocked: PropTypes.bool
            }, _class;
          };
        };
        var arrayMap = _arrayMap,
          baseIteratee = _baseIteratee,
          basePickBy = _basePickBy,
          getAllKeysIn = _getAllKeysIn;

        /**
         * Creates an object composed of the `object` properties `predicate` returns
         * truthy for. The predicate is invoked with two arguments: (value, key).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The source object.
         * @param {Function} [predicate=_.identity] The function invoked per property.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.pickBy(object, _.isNumber);
         * // => { 'a': 1, 'c': 3 }
         */
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function (prop) {
            return [prop];
          });
          predicate = baseIteratee(predicate);
          return basePickBy(object, props, function (value, path) {
            return predicate(value, path[0]);
          });
        }
        var pickBy_1 = pickBy;
        const pickBy$1 = /*@__PURE__*/getDefaultExportFromCjs(pickBy_1);
        function ownKeys$g(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$g(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$g(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$g(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        function _createSuper$m(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$m();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct$m() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var _Utils$ConfigUtils$4 = Utils$1.ConfigUtils,
          getFieldConfig$6 = _Utils$ConfigUtils$4.getFieldConfig,
          getOperatorConfig$3 = _Utils$ConfigUtils$4.getOperatorConfig;
        var Operator = /*#__PURE__*/function (_Component) {
          _inherits$b(Operator, _Component);
          var _super = _createSuper$m(Operator);
          function Operator(props) {
            var _this;
            _classCallCheck$b(this, Operator);
            _this = _super.call(this, props);
            useOnPropsChanged(_assertThisInitialized$1(_this));
            _this.onPropsChanged(props);
            return _this;
          }
          _createClass$9(Operator, [{
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {
              var prevProps = this.props;
              var keysForMeta = ["config", "selectedField", "selectedOperator"];
              var needUpdateMeta = !this.meta || keysForMeta.map(function (k) {
                return nextProps[k] !== prevProps[k];
              }).filter(function (ch) {
                return ch;
              }).length > 0;
              if (needUpdateMeta) {
                this.meta = this.getMeta(nextProps);
              }
            }
          }, {
            key: "getMeta",
            value: function getMeta(_ref) {
              var config = _ref.config,
                selectedField = _ref.selectedField,
                selectedOperator = _ref.selectedOperator;
              var fieldConfig = getFieldConfig$6(config, selectedField);
              var operators = fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.operators;
              var operatorOptions = mapValues$1(pickBy$1(config.operators, function (item, key) {
                return (operators === null || operators === void 0 ? void 0 : operators.indexOf(key)) !== -1;
              }), function (_opts, op) {
                return getOperatorConfig$3(config, op, selectedField);
              });
              var items = this.buildOptions(config, operatorOptions, operators);
              var isOpSelected = !!selectedOperator;
              var currOp = isOpSelected ? operatorOptions[selectedOperator] : null;
              var selectedOpts = currOp || {};
              var placeholder = this.props.config.settings.operatorPlaceholder;
              var selectedKey = selectedOperator;
              var selectedKeys = isOpSelected ? [selectedKey] : null;
              var selectedPath = selectedKeys;
              var selectedLabel = selectedOpts.label;
              return {
                placeholder: placeholder,
                items: items,
                selectedKey: selectedKey,
                selectedKeys: selectedKeys,
                selectedPath: selectedPath,
                selectedLabel: selectedLabel,
                selectedOpts: selectedOpts,
                fieldConfig: fieldConfig
              };
            }
          }, {
            key: "buildOptions",
            value: function buildOptions(config, fields, ops) {
              if (!fields || !ops) return null;
              return keys$8(fields).sort(function (a, b) {
                return ops.indexOf(a) - ops.indexOf(b);
              }).map(function (fieldKey) {
                var field = fields[fieldKey];
                var label = field.label;
                return {
                  key: fieldKey,
                  path: fieldKey,
                  label: label
                };
              });
            }
          }, {
            key: "render",
            value: function render() {
              var _this$props = this.props,
                config = _this$props.config,
                customProps = _this$props.customProps,
                setOperator = _this$props.setOperator,
                readonly = _this$props.readonly,
                id = _this$props.id,
                groupId = _this$props.groupId;
              var renderOperator = config.settings.renderOperator;
              var renderProps = _objectSpread$g({
                id: id,
                groupId: groupId,
                config: config,
                customProps: customProps,
                readonly: readonly,
                setField: setOperator
              }, this.meta);
              if (!renderProps.items) return null;
              return renderOperator(renderProps);
            }
          }]);
          return Operator;
        }(reactExports.Component);
        Operator.propTypes = {
          id: PropTypes.string,
          groupId: PropTypes.string,
          config: PropTypes.object.isRequired,
          selectedField: PropTypes.string,
          selectedOperator: PropTypes.string,
          readonly: PropTypes.bool,
          //actions
          setOperator: PropTypes.func.isRequired
        };
        var _excluded$7 = ["children"];
        var Col = function Col(_ref) {
          var children = _ref.children,
            props = _objectWithoutProperties$2(_ref, _excluded$7);
          return /*#__PURE__*/React.createElement("div", props, children);
        };
        var dummyFn = function dummyFn() {};
        var DragIcon = function DragIcon() {
          return /*#__PURE__*/React.createElement("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 24 24",
            fill: "gray",
            width: "18px",
            height: "18px"
          }, /*#__PURE__*/React.createElement("path", {
            d: "M0 0h24v24H0V0z",
            fill: "none"
          }), /*#__PURE__*/React.createElement("path", {
            d: "M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"
          }));
        };
        var ConfirmFn = function ConfirmFn(Cmp) {
          return function (props) {
            var useConfirm = props.config.settings.useConfirm;
            var confirmFn = useConfirm ? useConfirm() : null;
            return /*#__PURE__*/React.createElement(Cmp, _extends$h({}, props, {
              confirmFn: confirmFn
            }));
          };
        };
        function _createSuper$l(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$l();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct$l() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var OperatorWrapper = /*#__PURE__*/function (_PureComponent) {
          _inherits$b(OperatorWrapper, _PureComponent);
          var _super = _createSuper$l(OperatorWrapper);
          function OperatorWrapper() {
            _classCallCheck$b(this, OperatorWrapper);
            return _super.apply(this, arguments);
          }
          _createClass$9(OperatorWrapper, [{
            key: "render",
            value: function render() {
              var _this$props = this.props,
                config = _this$props.config,
                selectedField = _this$props.selectedField,
                selectedOperator = _this$props.selectedOperator,
                setOperator = _this$props.setOperator,
                selectedFieldPartsLabels = _this$props.selectedFieldPartsLabels,
                showOperator = _this$props.showOperator,
                showOperatorLabel = _this$props.showOperatorLabel,
                selectedFieldWidgetConfig = _this$props.selectedFieldWidgetConfig,
                readonly = _this$props.readonly,
                id = _this$props.id,
                groupId = _this$props.groupId;
              var operator = showOperator && /*#__PURE__*/React.createElement(Col, {
                key: "operators-for-" + (selectedFieldPartsLabels || []).join("_"),
                className: "rule--operator"
              }, config.settings.showLabels && /*#__PURE__*/React.createElement("label", {
                className: "rule--label"
              }, config.settings.operatorLabel), /*#__PURE__*/React.createElement(Operator, {
                key: "operator",
                config: config,
                selectedField: selectedField,
                selectedOperator: selectedOperator,
                setOperator: setOperator,
                readonly: readonly,
                id: id,
                groupId: groupId
              }));
              var hiddenOperator = showOperatorLabel && /*#__PURE__*/React.createElement(Col, {
                key: "operators-for-" + (selectedFieldPartsLabels || []).join("_"),
                className: "rule--operator"
              }, /*#__PURE__*/React.createElement("div", {
                className: "rule--operator-wrapper"
              }, config.settings.showLabels ? /*#__PURE__*/React.createElement("label", {
                className: "rule--label"
              }, "\xA0") : null, /*#__PURE__*/React.createElement("div", {
                className: "rule--operator-text-wrapper"
              }, /*#__PURE__*/React.createElement("span", {
                className: "rule--operator-text"
              }, selectedFieldWidgetConfig.operatorInlineLabel))));
              return [operator, hiddenOperator];
            }
          }]);
          return OperatorWrapper;
        }(reactExports.PureComponent);
        function ownKeys$f(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$f(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$f(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$f(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        function _createSuper$k(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$k();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct$k() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var _Utils$RuleUtils$3 = Utils$1.RuleUtils,
          getFieldPath$2 = _Utils$RuleUtils$3.getFieldPath,
          getFieldPathLabels$2 = _Utils$RuleUtils$3.getFieldPathLabels;
        var getFieldConfig$5 = Utils$1.ConfigUtils.getFieldConfig;
        var Field = /*#__PURE__*/function (_Component) {
          _inherits$b(Field, _Component);
          var _super = _createSuper$k(Field);
          function Field(props) {
            var _this;
            _classCallCheck$b(this, Field);
            _this = _super.call(this, props);
            useOnPropsChanged(_assertThisInitialized$1(_this));
            _this.onPropsChanged(props);
            return _this;
          }
          _createClass$9(Field, [{
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {
              var prevProps = this.props;
              var keysForMeta = ["selectedField", "config", "parentField"];
              var needUpdateMeta = !this.meta || keysForMeta.map(function (k) {
                return nextProps[k] !== prevProps[k];
              }).filter(function (ch) {
                return ch;
              }).length > 0;
              if (needUpdateMeta) {
                this.meta = this.getMeta(nextProps);
              }
            }
          }, {
            key: "getMeta",
            value: function getMeta(_ref) {
              var selectedField = _ref.selectedField,
                config = _ref.config,
                parentField = _ref.parentField;
              var selectedKey = selectedField;
              var _config$settings = config.settings,
                maxLabelsLength = _config$settings.maxLabelsLength,
                fieldSeparatorDisplay = _config$settings.fieldSeparatorDisplay,
                fieldPlaceholder = _config$settings.fieldPlaceholder,
                fieldSeparator = _config$settings.fieldSeparator;
              var isFieldSelected = !!selectedField;
              var placeholder = !isFieldSelected ? truncateString(fieldPlaceholder, maxLabelsLength) : null;
              var currField = isFieldSelected ? getFieldConfig$5(config, selectedKey) : null;
              var selectedOpts = currField || {};
              var selectedKeys = getFieldPath$2(selectedKey, config);
              var selectedPath = getFieldPath$2(selectedKey, config, true);
              var selectedLabel = this.getFieldLabel(currField, selectedKey, config);
              var partsLabels = getFieldPathLabels$2(selectedKey, config);
              var selectedFullLabel = partsLabels ? partsLabels.join(fieldSeparatorDisplay) : null;
              if (selectedFullLabel == selectedLabel || parentField) selectedFullLabel = null;
              var selectedAltLabel = selectedOpts.label2;
              var parentFieldPath = typeof parentField == "string" ? parentField.split(fieldSeparator) : parentField;
              var parentFieldConfig = parentField ? getFieldConfig$5(config, parentField) : null;
              var sourceFields = parentField ? parentFieldConfig && parentFieldConfig.subfields : config.fields;
              var items = this.buildOptions(parentFieldPath, config, sourceFields, parentFieldPath);
              return {
                placeholder: placeholder,
                items: items,
                parentField: parentField,
                selectedKey: selectedKey,
                selectedKeys: selectedKeys,
                selectedPath: selectedPath,
                selectedLabel: selectedLabel,
                selectedOpts: selectedOpts,
                selectedAltLabel: selectedAltLabel,
                selectedFullLabel: selectedFullLabel
              };
            }
          }, {
            key: "getFieldLabel",
            value: function getFieldLabel(fieldOpts, fieldKey, config) {
              if (!fieldKey) return null;
              var fieldSeparator = config.settings.fieldSeparator;
              var maxLabelsLength = config.settings.maxLabelsLength;
              var fieldParts = Array.isArray(fieldKey) ? fieldKey : fieldKey.split(fieldSeparator);
              var label = fieldOpts && fieldOpts.label || last$2(fieldParts);
              label = truncateString(label, maxLabelsLength);
              return label;
            }
          }, {
            key: "buildOptions",
            value: function buildOptions(parentFieldPath, config, fields) {
              var _this2 = this;
              var path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
              var optGroupLabel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
              if (!fields) return null;
              var _config$settings2 = config.settings,
                fieldSeparator = _config$settings2.fieldSeparator,
                fieldSeparatorDisplay = _config$settings2.fieldSeparatorDisplay;
              var prefix = path ? path.join(fieldSeparator) + fieldSeparator : "";
              return keys$8(fields).map(function (fieldKey) {
                var field = fields[fieldKey];
                var label = _this2.getFieldLabel(field, fieldKey, config);
                var partsLabels = getFieldPathLabels$2(prefix + fieldKey, config);
                var fullLabel = partsLabels.join(fieldSeparatorDisplay);
                if (fullLabel == label || parentFieldPath) fullLabel = null;
                var altLabel = field.label2;
                var tooltip = field.tooltip;
                var subpath = (path ? path : []).concat(fieldKey);
                var disabled = field.disabled;
                if (field.hideForSelect) return undefined;
                if (field.type == "!struct") {
                  return {
                    disabled: disabled,
                    key: fieldKey,
                    path: prefix + fieldKey,
                    label: label,
                    fullLabel: fullLabel,
                    altLabel: altLabel,
                    tooltip: tooltip,
                    items: _this2.buildOptions(parentFieldPath, config, field.subfields, subpath, label)
                  };
                } else {
                  return {
                    disabled: disabled,
                    key: fieldKey,
                    path: prefix + fieldKey,
                    label: label,
                    fullLabel: fullLabel,
                    altLabel: altLabel,
                    tooltip: tooltip,
                    grouplabel: optGroupLabel
                  };
                }
              }).filter(function (o) {
                return !!o;
              });
            }
          }, {
            key: "render",
            value: function render() {
              var _this$props = this.props,
                config = _this$props.config,
                customProps = _this$props.customProps,
                setField = _this$props.setField,
                readonly = _this$props.readonly,
                id = _this$props.id,
                groupId = _this$props.groupId;
              var renderField = config.settings.renderField;
              var renderProps = _objectSpread$f({
                id: id,
                groupId: groupId,
                config: config,
                customProps: customProps,
                readonly: readonly,
                setField: setField
              }, this.meta);
              return renderField(renderProps);
            }
          }]);
          return Field;
        }(reactExports.Component);
        Field.propTypes = {
          id: PropTypes.string,
          groupId: PropTypes.string,
          config: PropTypes.object.isRequired,
          selectedField: PropTypes.string,
          parentField: PropTypes.string,
          customProps: PropTypes.object,
          readonly: PropTypes.bool,
          //actions
          setField: PropTypes.func.isRequired
        };
        function _createSuper$j(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$j();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct$j() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var FieldWrapper = /*#__PURE__*/function (_PureComponent) {
          _inherits$b(FieldWrapper, _PureComponent);
          var _super = _createSuper$j(FieldWrapper);
          function FieldWrapper() {
            _classCallCheck$b(this, FieldWrapper);
            return _super.apply(this, arguments);
          }
          _createClass$9(FieldWrapper, [{
            key: "render",
            value: function render() {
              var _this$props = this.props,
                config = _this$props.config,
                selectedField = _this$props.selectedField,
                setField = _this$props.setField,
                parentField = _this$props.parentField,
                classname = _this$props.classname,
                readonly = _this$props.readonly,
                id = _this$props.id,
                groupId = _this$props.groupId;
              return /*#__PURE__*/React.createElement(Col, {
                className: classname
              }, config.settings.showLabels && /*#__PURE__*/React.createElement("label", {
                className: "rule--label"
              }, config.settings.fieldLabel), /*#__PURE__*/React.createElement(Field, {
                config: config,
                selectedField: selectedField,
                parentField: parentField,
                setField: setField,
                customProps: config.settings.customFieldSelectProps,
                readonly: readonly,
                id: id,
                groupId: groupId
              }));
            }
          }]);
          return FieldWrapper;
        }(reactExports.PureComponent);

        /* Built-in method references for those with the same name as other `lodash` methods. */

        var nativeCeil = Math.ceil,
          nativeMax$1 = Math.max;

        /**
         * The base implementation of `_.range` and `_.rangeRight` which doesn't
         * coerce arguments.
         *
         * @private
         * @param {number} start The start of the range.
         * @param {number} end The end of the range.
         * @param {number} step The value to increment or decrement by.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Array} Returns the range of numbers.
         */
        function baseRange$1(start, end, step, fromRight) {
          var index = -1,
            length = nativeMax$1(nativeCeil((end - start) / (step || 1)), 0),
            result = Array(length);
          while (length--) {
            result[fromRight ? length : ++index] = start;
            start += step;
          }
          return result;
        }
        var _baseRange = baseRange$1;

        /** Used to match a single whitespace character. */

        var reWhitespace = /\s/;

        /**
         * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
         * character of `string`.
         *
         * @private
         * @param {string} string The string to inspect.
         * @returns {number} Returns the index of the last non-whitespace character.
         */
        function trimmedEndIndex$1(string) {
          var index = string.length;
          while (index-- && reWhitespace.test(string.charAt(index))) {}
          return index;
        }
        var _trimmedEndIndex = trimmedEndIndex$1;
        var trimmedEndIndex = _trimmedEndIndex;

        /** Used to match leading whitespace. */
        var reTrimStart = /^\s+/;

        /**
         * The base implementation of `_.trim`.
         *
         * @private
         * @param {string} string The string to trim.
         * @returns {string} Returns the trimmed string.
         */
        function baseTrim$1(string) {
          return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;
        }
        var _baseTrim = baseTrim$1;
        var baseTrim = _baseTrim,
          isObject$1 = isObject_1,
          isSymbol = isSymbol_1;

        /** Used as references for various `Number` constants. */
        var NAN = 0 / 0;

        /** Used to detect bad signed hexadecimal string values. */
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

        /** Used to detect binary string values. */
        var reIsBinary = /^0b[01]+$/i;

        /** Used to detect octal string values. */
        var reIsOctal = /^0o[0-7]+$/i;

        /** Built-in method references without a dependency on `root`. */
        var freeParseInt = parseInt;

        /**
         * Converts `value` to a number.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to process.
         * @returns {number} Returns the number.
         * @example
         *
         * _.toNumber(3.2);
         * // => 3.2
         *
         * _.toNumber(Number.MIN_VALUE);
         * // => 5e-324
         *
         * _.toNumber(Infinity);
         * // => Infinity
         *
         * _.toNumber('3.2');
         * // => 3.2
         */
        function toNumber$2(value) {
          if (typeof value == 'number') {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject$1(value)) {
            var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
            value = isObject$1(other) ? other + '' : other;
          }
          if (typeof value != 'string') {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        var toNumber_1 = toNumber$2;
        var toNumber$1 = toNumber_1;

        /** Used as references for various `Number` constants. */
        var INFINITY = 1 / 0,
          MAX_INTEGER = 1.7976931348623157e+308;

        /**
         * Converts `value` to a finite number.
         *
         * @static
         * @memberOf _
         * @since 4.12.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted number.
         * @example
         *
         * _.toFinite(3.2);
         * // => 3.2
         *
         * _.toFinite(Number.MIN_VALUE);
         * // => 5e-324
         *
         * _.toFinite(Infinity);
         * // => 1.7976931348623157e+308
         *
         * _.toFinite('3.2');
         * // => 3.2
         */
        function toFinite$2(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber$1(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        var toFinite_1 = toFinite$2;
        var baseRange = _baseRange,
          isIterateeCall = _isIterateeCall,
          toFinite$1 = toFinite_1;

        /**
         * Creates a `_.range` or `_.rangeRight` function.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new range function.
         */
        function createRange$1(fromRight) {
          return function (start, end, step) {
            if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
              end = step = undefined;
            }
            // Ensure the sign of `-0` is preserved.
            start = toFinite$1(start);
            if (end === undefined) {
              end = start;
              start = 0;
            } else {
              end = toFinite$1(end);
            }
            step = step === undefined ? start < end ? 1 : -1 : toFinite$1(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        var _createRange = createRange$1;
        var createRange = _createRange;

        /**
         * Creates an array of numbers (positive and/or negative) progressing from
         * `start` up to, but not including, `end`. A step of `-1` is used if a negative
         * `start` is specified without an `end` or `step`. If `end` is not specified,
         * it's set to `start` with `start` then set to `0`.
         *
         * **Note:** JavaScript follows the IEEE-754 standard for resolving
         * floating-point values which can produce unexpected results.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @param {number} [step=1] The value to increment or decrement by.
         * @returns {Array} Returns the range of numbers.
         * @see _.inRange, _.rangeRight
         * @example
         *
         * _.range(4);
         * // => [0, 1, 2, 3]
         *
         * _.range(-4);
         * // => [0, -1, -2, -3]
         *
         * _.range(1, 5);
         * // => [1, 2, 3, 4]
         *
         * _.range(0, 20, 5);
         * // => [0, 5, 10, 15]
         *
         * _.range(0, -4, -1);
         * // => [0, -1, -2, -3]
         *
         * _.range(1, 4, 0);
         * // => [1, 1, 1]
         *
         * _.range(0);
         * // => []
         */
        var range = createRange();
        var range_1 = range;
        const range$1 = /*@__PURE__*/getDefaultExportFromCjs(range_1);
        var _excluded$6 = ["factory"];
        var getTitleInListValues = Utils$1.ListUtils.getTitleInListValues;
        const WidgetFactory = function (_ref) {
          var delta = _ref.delta,
            isFuncArg = _ref.isFuncArg;
          _ref.valueSrc;
          var immValue = _ref.value,
            immValueError = _ref.valueError,
            asyncListValues = _ref.asyncListValues,
            isSpecialRange = _ref.isSpecialRange,
            fieldDefinition = _ref.fieldDefinition;
          _ref.widget;
          var widgetDefinition = _ref.widgetDefinition,
            widgetValueLabel = _ref.widgetValueLabel,
            valueLabels = _ref.valueLabels,
            textSeparators = _ref.textSeparators,
            setValueHandler = _ref.setValueHandler,
            config = _ref.config,
            field = _ref.field,
            operator = _ref.operator,
            readonly = _ref.readonly,
            parentField = _ref.parentField,
            parentFuncs = _ref.parentFuncs,
            id = _ref.id,
            groupId = _ref.groupId;
          var widgetFactory = widgetDefinition.factory,
            fieldWidgetProps = _objectWithoutProperties$2(widgetDefinition, _excluded$6);
          var isConst = isFuncArg && fieldDefinition.valueSources && fieldDefinition.valueSources.length == 1 && fieldDefinition.valueSources[0] == "const";
          var defaultValue = fieldDefinition.defaultValue;
          if (!widgetFactory) {
            return "?";
          }
          var value = isSpecialRange ? [immValue.get(0), immValue.get(1)] : immValue ? immValue.get(delta) : undefined;
          var valueError = immValueError && (isSpecialRange ? [immValueError.get(0), immValueError.get(1)] : immValueError.get(delta)) || null;
          if (isSpecialRange && value[0] === undefined && value[1] === undefined) value = undefined;
          var _ref2 = fieldDefinition || {},
            fieldSettings = _ref2.fieldSettings;
          var widgetProps = Object.assign({}, fieldWidgetProps, fieldSettings, {
            config: config,
            field: field,
            parentField: parentField,
            parentFuncs: parentFuncs,
            fieldDefinition: fieldDefinition,
            operator: operator,
            delta: delta,
            isSpecialRange: isSpecialRange,
            isFuncArg: isFuncArg,
            value: value,
            valueError: valueError,
            label: widgetValueLabel.label,
            placeholder: widgetValueLabel.placeholder,
            placeholders: valueLabels ? valueLabels.placeholder : null,
            textSeparators: textSeparators,
            setValue: setValueHandler,
            readonly: readonly,
            asyncListValues: asyncListValues,
            id: id,
            groupId: groupId
          });
          if (isConst && defaultValue) {
            var listValues = fieldSettings.treeValues || fieldSettings.listValues;
            if (typeof defaultValue == "boolean") {
              return defaultValue ? widgetProps.labelYes || "YES" : widgetProps.labelNo || "NO";
            } else if (listValues) {
              if (Array.isArray(defaultValue)) return defaultValue.map(function (v) {
                return getTitleInListValues(listValues, v) || v;
              }).join(", ");else return getTitleInListValues(listValues, defaultValue) || defaultValue;
            }
            return "" + defaultValue;
          }
          return widgetFactory(widgetProps);
        };
        function _createSuper$i(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$i();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct$i() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var _Utils$ConfigUtils$3 = Utils$1.ConfigUtils,
          getFieldConfig$4 = _Utils$ConfigUtils$3.getFieldConfig,
          getOperatorConfig$2 = _Utils$ConfigUtils$3.getOperatorConfig,
          getFieldWidgetConfig$2 = _Utils$ConfigUtils$3.getFieldWidgetConfig;
        var _Utils$RuleUtils$2 = Utils$1.RuleUtils,
          getValueSourcesForFieldOp = _Utils$RuleUtils$2.getValueSourcesForFieldOp,
          getWidgetsForFieldOp = _Utils$RuleUtils$2.getWidgetsForFieldOp,
          getWidgetForFieldOp$2 = _Utils$RuleUtils$2.getWidgetForFieldOp,
          getValueLabel = _Utils$RuleUtils$2.getValueLabel;
        var createListFromArray$1 = Utils$1.DefaultUtils.createListFromArray;
        var funcArgDummyOpDef = {
          cardinality: 1
        };
        var Widget = /*#__PURE__*/function (_Component) {
          _inherits$b(Widget, _Component);
          var _super = _createSuper$i(Widget);
          function Widget(_props) {
            var _this;
            _classCallCheck$b(this, Widget);
            _this = _super.call(this, _props);
            _this._setValue = function (isSpecialRange, delta, widgetType, value, asyncListValues, __isInternal) {
              if (isSpecialRange && Array.isArray(value)) {
                var oldRange = [_this.props.value.get(0), _this.props.value.get(1)];
                if (oldRange[0] != value[0]) _this.props.setValue(0, value[0], widgetType, asyncListValues, __isInternal);
                if (oldRange[1] != value[1]) _this.props.setValue(1, value[1], widgetType, asyncListValues, __isInternal);
              } else {
                _this.props.setValue(delta, value, widgetType, asyncListValues, __isInternal);
              }
            };
            _this._onChangeValueSrc = function (delta, srcKey) {
              _this.props.setValueSrc(delta, srcKey);
            };
            _this.renderWidget = function (delta, meta, props) {
              var config = props.config,
                isFuncArg = props.isFuncArg,
                leftField = props.leftField,
                operator = props.operator,
                values = props.value,
                valueError = props.valueError,
                readonly = props.readonly,
                parentField = props.parentField,
                parentFuncs = props.parentFuncs,
                id = props.id,
                groupId = props.groupId;
              var settings = config.settings;
              var widgets = meta.widgets,
                iValues = meta.iValues,
                aField = meta.aField;
              var value = isFuncArg ? iValues : values;
              var field = isFuncArg ? leftField : aField;
              var _widgets$delta = widgets[delta],
                valueSrc = _widgets$delta.valueSrc,
                valueLabel = _widgets$delta.valueLabel;
              var widgetLabel = settings.showLabels ? /*#__PURE__*/React.createElement("label", {
                className: "rule--label"
              }, valueLabel.label) : null;
              return /*#__PURE__*/React.createElement("div", {
                key: "widget-" + field + "-" + delta,
                className: "widget--widget"
              }, valueSrc == "func" ? null : widgetLabel, /*#__PURE__*/React.createElement(WidgetFactory, _extends$h({
                id: id,
                groupId: groupId,
                valueSrc: valueSrc,
                delta: delta,
                value: value,
                valueError: valueError,
                isFuncArg: isFuncArg
              }, pick$1(meta, ["isSpecialRange", "fieldDefinition", "asyncListValues"]), pick$1(widgets[delta], ["widget", "widgetDefinition", "widgetValueLabel", "valueLabels", "textSeparators", "setValueHandler"]), {
                config: config,
                field: field,
                parentField: parentField,
                parentFuncs: parentFuncs,
                operator: operator,
                readonly: readonly
              })));
            };
            _this.renderValueSources = function (delta, meta, props) {
              var config = props.config,
                isFuncArg = props.isFuncArg,
                leftField = props.leftField,
                operator = props.operator,
                readonly = props.readonly;
              var settings = config.settings;
              var valueSources = meta.valueSources,
                widgets = meta.widgets,
                aField = meta.aField;
              var field = isFuncArg ? leftField : aField;
              var _widgets$delta2 = widgets[delta],
                valueSrc = _widgets$delta2.valueSrc,
                setValueSrcHandler = _widgets$delta2.setValueSrcHandler;
              var valueSourcesInfo = settings.valueSourcesInfo,
                ValueSources = settings.renderValueSources;
              var valueSourcesOptions = valueSources.map(function (srcKey) {
                return [srcKey, {
                  label: valueSourcesInfo[srcKey].label
                }];
              });
              var sourceLabel = settings.showLabels ? /*#__PURE__*/React.createElement("label", {
                className: "rule--label"
              }, "\xA0") : null;
              return valueSources.length > 1 && !readonly && /*#__PURE__*/React.createElement("div", {
                key: "valuesrc-" + field + "-" + delta,
                className: "widget--valuesrc"
              }, sourceLabel, /*#__PURE__*/React.createElement(ValueSources, {
                key: "valuesrc-" + delta,
                delta: delta,
                valueSources: valueSourcesOptions,
                valueSrc: valueSrc,
                config: config,
                field: field,
                operator: operator,
                setValueSrc: setValueSrcHandler,
                readonly: readonly,
                title: settings.valueSourcesPopupTitle
              }));
            };
            _this.renderSep = function (delta, meta, props) {
              var config = props.config;
              var widgets = meta.widgets;
              var settings = config.settings;
              var sepText = widgets[delta].sepText;
              var sepLabel = settings.showLabels ? /*#__PURE__*/React.createElement("label", {
                className: "rule--label"
              }, "\xA0") : null;
              return sepText && /*#__PURE__*/React.createElement("div", {
                key: "widget-separators-" + delta,
                className: "widget--sep"
              }, sepLabel, /*#__PURE__*/React.createElement("span", null, sepText));
            };
            _this.renderWidgetDelta = function (delta) {
              var sep = _this.renderSep(delta, _this.meta, _this.props);
              var sources = _this.renderValueSources(delta, _this.meta, _this.props);
              var widgetCmp = _this.renderWidget(delta, _this.meta, _this.props);
              return [sep, sources, widgetCmp];
            };
            useOnPropsChanged(_assertThisInitialized$1(_this));
            _this.onPropsChanged(_props);
            return _this;
          }
          _createClass$9(Widget, [{
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {
              var prevProps = this.props;
              var keysForMeta = ["config", "field", "fieldFunc", "fieldArg", "leftField", "operator", "valueSrc", "isFuncArg", "asyncListValues"];
              var needUpdateMeta = !this.meta || keysForMeta.map(function (k) {
                return nextProps[k] !== prevProps[k]
                //tip: for isFuncArg we need to wrap value in Imm list
                || k == "isFuncArg" && nextProps["isFuncArg"] && nextProps["value"] !== prevProps["value"];
              }).filter(function (ch) {
                return ch;
              }).length > 0;
              if (needUpdateMeta) {
                this.meta = this.getMeta(nextProps);
              }
            }
          }, {
            key: "getMeta",
            value: function getMeta(_ref) {
              var _this2 = this;
              var config = _ref.config,
                simpleField = _ref.field,
                fieldFunc = _ref.fieldFunc,
                fieldArg = _ref.fieldArg,
                operator = _ref.operator,
                valueSrcs = _ref.valueSrc,
                values = _ref.value,
                isForRuleGruop = _ref.isForRuleGruop,
                isCaseValue = _ref.isCaseValue,
                isFuncArg = _ref.isFuncArg,
                leftField = _ref.leftField,
                asyncListValues = _ref.asyncListValues;
              var field = isFuncArg ? {
                func: fieldFunc,
                arg: fieldArg
              } : simpleField;
              var iValueSrcs = valueSrcs;
              var iValues = values;
              if (isFuncArg || isForRuleGruop || isCaseValue) {
                iValueSrcs = createListFromArray$1([valueSrcs]);
                iValues = createListFromArray$1([values]);
              }
              var fieldDefinition = getFieldConfig$4(config, field);
              var defaultWidget = getWidgetForFieldOp$2(config, field, operator);
              getWidgetsForFieldOp(config, field, operator);
              var operatorDefinition = isFuncArg ? funcArgDummyOpDef : getOperatorConfig$2(config, operator, field);
              if ((fieldDefinition == null || operatorDefinition == null) && !isCaseValue) {
                return null;
              }
              var isSpecialRange = operatorDefinition === null || operatorDefinition === void 0 ? void 0 : operatorDefinition.isSpecialRange;
              var isSpecialRangeForSrcField = isSpecialRange && (iValueSrcs.get(0) == "field" || iValueSrcs.get(1) == "field");
              var isTrueSpecialRange = isSpecialRange && !isSpecialRangeForSrcField;
              var cardinality = isTrueSpecialRange ? 1 : defaultValue(operatorDefinition === null || operatorDefinition === void 0 ? void 0 : operatorDefinition.cardinality, 1);
              if (cardinality === 0) {
                return null;
              }
              var valueSources = getValueSourcesForFieldOp(config, field, operator, fieldDefinition, isFuncArg ? leftField : null);
              var widgets = range$1(0, cardinality).map(function (delta) {
                var _widgetDefinition;
                var valueSrc = iValueSrcs.get(delta) || null;
                var widget = getWidgetForFieldOp$2(config, field, operator, valueSrc);
                var widgetDefinition = getFieldWidgetConfig$2(config, field, operator, widget, valueSrc);
                if (isSpecialRangeForSrcField) {
                  widget = widgetDefinition.singleWidget;
                  widgetDefinition = getFieldWidgetConfig$2(config, field, operator, widget, valueSrc);
                }
                var widgetType = (_widgetDefinition = widgetDefinition) === null || _widgetDefinition === void 0 ? void 0 : _widgetDefinition.type;
                var valueLabel = getValueLabel(config, field, operator, delta, valueSrc, isTrueSpecialRange);
                var widgetValueLabel = getValueLabel(config, field, operator, delta, null, isTrueSpecialRange);
                var sepText = operatorDefinition !== null && operatorDefinition !== void 0 && operatorDefinition.textSeparators ? operatorDefinition === null || operatorDefinition === void 0 ? void 0 : operatorDefinition.textSeparators[delta] : null;
                var setValueSrcHandler = _this2._onChangeValueSrc.bind(_this2, delta);
                var valueLabels = null;
                var textSeparators = null;
                if (isSpecialRange) {
                  valueLabels = [getValueLabel(config, field, operator, 0), getValueLabel(config, field, operator, 1)];
                  valueLabels = {
                    placeholder: [valueLabels[0].placeholder, valueLabels[1].placeholder],
                    label: [valueLabels[0].label, valueLabels[1].label]
                  };
                  textSeparators = operatorDefinition === null || operatorDefinition === void 0 ? void 0 : operatorDefinition.textSeparators;
                }
                var setValueHandler = _this2._setValue.bind(_this2, isSpecialRange, delta, widgetType);
                return {
                  valueSrc: valueSrc,
                  valueLabel: valueLabel,
                  widget: widget,
                  sepText: sepText,
                  setValueSrcHandler: setValueSrcHandler,
                  widgetDefinition: widgetDefinition,
                  widgetValueLabel: widgetValueLabel,
                  valueLabels: valueLabels,
                  textSeparators: textSeparators,
                  setValueHandler: setValueHandler
                };
              });
              return {
                defaultWidget: defaultWidget,
                fieldDefinition: fieldDefinition,
                operatorDefinition: operatorDefinition,
                isSpecialRange: isTrueSpecialRange,
                cardinality: cardinality,
                valueSources: valueSources,
                widgets: widgets,
                iValues: iValues,
                //correct for isFuncArg
                aField: field,
                //correct for isFuncArg
                asyncListValues: asyncListValues
              };
            }
          }, {
            key: "render",
            value: function render() {
              if (!this.meta) return null;
              var _this$meta = this.meta,
                defaultWidget = _this$meta.defaultWidget,
                cardinality = _this$meta.cardinality;
              if (!defaultWidget) return null;
              var name = defaultWidget;
              return /*#__PURE__*/React.createElement(Col, {
                className: "rule--widget rule--widget--".concat(name.toUpperCase()),
                key: "widget-col-" + name
              }, range$1(0, cardinality).map(this.renderWidgetDelta));
            }
          }]);
          return Widget;
        }(reactExports.Component);
        Widget.propTypes = {
          config: PropTypes.object.isRequired,
          value: PropTypes.any,
          //instanceOf(Immutable.List)
          valueSrc: PropTypes.any,
          //instanceOf(Immutable.List)
          valueError: PropTypes.any,
          field: PropTypes.string,
          operator: PropTypes.string,
          readonly: PropTypes.bool,
          asyncListValues: PropTypes.array,
          id: PropTypes.string,
          groupId: PropTypes.string,
          //actions
          setValue: PropTypes.func,
          setValueSrc: PropTypes.func,
          // for isFuncArg
          isFuncArg: PropTypes.bool,
          fieldFunc: PropTypes.string,
          fieldArg: PropTypes.string,
          leftField: PropTypes.string,
          // for RuleGroupExt
          isForRuleGruop: PropTypes.bool,
          parentField: PropTypes.string,
          // for func in func
          parentFuncs: PropTypes.array,
          // for case_value
          isCaseValue: PropTypes.bool
        };
        var _excluded$5 = ["factory"];
        function _createSuper$h(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$h();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct$h() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var getOperatorConfig$1 = Utils$1.ConfigUtils.getOperatorConfig;
        var OperatorOptions = /*#__PURE__*/function (_PureComponent) {
          _inherits$b(OperatorOptions, _PureComponent);
          var _super = _createSuper$h(OperatorOptions);
          function OperatorOptions() {
            _classCallCheck$b(this, OperatorOptions);
            return _super.apply(this, arguments);
          }
          _createClass$9(OperatorOptions, [{
            key: "render",
            value: function render() {
              if (!this.props.selectedOperator) return null;
              var operatorDefinitions = getOperatorConfig$1(this.props.config, this.props.selectedOperator, this.props.selectedField);
              if (typeof operatorDefinitions.options === "undefined") {
                return null;
              }
              var _operatorDefinitions$ = operatorDefinitions.options,
                optionsFactory = _operatorDefinitions$.factory,
                basicOptionsProps = _objectWithoutProperties$2(_operatorDefinitions$, _excluded$5);
              var optionsProps = Object.assign({}, basicOptionsProps, {
                config: this.props.config,
                field: this.props.selectedField,
                operator: this.props.selectedOperator,
                options: this.props.operatorOptions,
                setOption: this.props.setOperatorOption,
                readonly: this.props.readonly
              });
              var optionsCmp = optionsFactory(optionsProps);
              var name = this.props.selectedOperator;
              return /*#__PURE__*/React.createElement("div", {
                className: "rule--operator rule--operator--".concat(name.toUpperCase())
              }, optionsCmp);
            }
          }]);
          return OperatorOptions;
        }(reactExports.PureComponent);
        OperatorOptions.propTypes = {
          config: PropTypes.object.isRequired,
          operatorOptions: PropTypes.any.isRequired,
          //instanceOf(Immutable.Map)
          selectedField: PropTypes.string.isRequired,
          selectedOperator: PropTypes.string.isRequired,
          readonly: PropTypes.bool,
          //actions
          setOperatorOption: PropTypes.func.isRequired
        };
        function ownKeys$e(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$e(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$e(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$e(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        function _createSuper$g(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$g();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct$g() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var _Utils$ConfigUtils$2 = Utils$1.ConfigUtils,
          getFieldConfig$3 = _Utils$ConfigUtils$2.getFieldConfig,
          getOperatorConfig = _Utils$ConfigUtils$2.getOperatorConfig,
          getFieldWidgetConfig$1 = _Utils$ConfigUtils$2.getFieldWidgetConfig;
        var getFieldPathLabels$1 = Utils$1.RuleUtils.getFieldPathLabels;
        var Rule = /*#__PURE__*/function (_Component) {
          _inherits$b(Rule, _Component);
          var _super = _createSuper$g(Rule);
          function Rule(props) {
            var _this;
            _classCallCheck$b(this, Rule);
            _this = _super.call(this, props);
            useOnPropsChanged(_assertThisInitialized$1(_this));
            _this.removeSelf = _this.removeSelf.bind(_assertThisInitialized$1(_this));
            _this.setLock = _this.setLock.bind(_assertThisInitialized$1(_this));
            _this.onPropsChanged(props);
            return _this;
          }
          _createClass$9(Rule, [{
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {
              var prevProps = this.props;
              var keysForMeta = ["selectedField", "selectedOperator", "config", "reordableNodesCnt", "isLocked"];
              var needUpdateMeta = !this.meta || keysForMeta.map(function (k) {
                return nextProps[k] !== prevProps[k];
              }).filter(function (ch) {
                return ch;
              }).length > 0;
              if (needUpdateMeta) {
                this.meta = this.getMeta(nextProps);
              }
            }
          }, {
            key: "getMeta",
            value: function getMeta(_ref) {
              var selectedField = _ref.selectedField,
                selectedOperator = _ref.selectedOperator,
                config = _ref.config,
                reordableNodesCnt = _ref.reordableNodesCnt,
                isLocked = _ref.isLocked;
              var selectedFieldPartsLabels = getFieldPathLabels$1(selectedField, config);
              var selectedFieldConfig = getFieldConfig$3(config, selectedField);
              var isSelectedGroup = selectedFieldConfig && selectedFieldConfig.type == "!struct";
              var isFieldAndOpSelected = selectedField && selectedOperator && !isSelectedGroup;
              var selectedOperatorConfig = getOperatorConfig(config, selectedOperator, selectedField);
              var selectedOperatorHasOptions = selectedOperatorConfig && selectedOperatorConfig.options != null;
              var selectedFieldWidgetConfig = getFieldWidgetConfig$1(config, selectedField, selectedOperator) || {};
              var hideOperator = selectedFieldWidgetConfig.hideOperator;
              var showDragIcon = config.settings.canReorder && reordableNodesCnt > 1 && !isLocked;
              var showOperator = selectedField && !hideOperator;
              var showOperatorLabel = selectedField && hideOperator && selectedFieldWidgetConfig.operatorInlineLabel;
              var showWidget = isFieldAndOpSelected;
              var showOperatorOptions = isFieldAndOpSelected && selectedOperatorHasOptions;
              return {
                selectedFieldPartsLabels: selectedFieldPartsLabels,
                selectedFieldWidgetConfig: selectedFieldWidgetConfig,
                showDragIcon: showDragIcon,
                showOperator: showOperator,
                showOperatorLabel: showOperatorLabel,
                showWidget: showWidget,
                showOperatorOptions: showOperatorOptions
              };
            }
          }, {
            key: "setLock",
            value: function setLock(lock) {
              this.props.setLock(lock);
            }
          }, {
            key: "removeSelf",
            value: function removeSelf() {
              var _this2 = this;
              var confirmFn = this.props.confirmFn;
              var _this$props$config$se = this.props.config.settings,
                renderConfirm = _this$props$config$se.renderConfirm,
                confirmOptions = _this$props$config$se.removeRuleConfirmOptions;
              var doRemove = function doRemove() {
                _this2.props.removeSelf();
              };
              if (confirmOptions && !this.isEmptyCurrentRule()) {
                renderConfirm(_objectSpread$e(_objectSpread$e({}, confirmOptions), {}, {
                  onOk: doRemove,
                  onCancel: null,
                  confirmFn: confirmFn
                }));
              } else {
                doRemove();
              }
            }
          }, {
            key: "isEmptyCurrentRule",
            value: function isEmptyCurrentRule() {
              return !(this.props.selectedField !== null && this.props.selectedOperator !== null && this.props.value.filter(function (val) {
                return val !== undefined;
              }).size > 0);
            }
          }, {
            key: "renderField",
            value: function renderField() {
              var _this$props = this.props,
                config = _this$props.config,
                isLocked = _this$props.isLocked;
              var immutableFieldsMode = config.settings.immutableFieldsMode;
              return /*#__PURE__*/React.createElement(FieldWrapper, {
                key: "field",
                classname: "rule--field",
                config: config,
                selectedField: this.props.selectedField,
                setField: !immutableFieldsMode ? this.props.setField : dummyFn,
                parentField: this.props.parentField,
                readonly: immutableFieldsMode || isLocked,
                id: this.props.id,
                groupId: this.props.groupId
              });
            }
          }, {
            key: "renderOperator",
            value: function renderOperator() {
              var _this$props2 = this.props,
                config = _this$props2.config,
                isLocked = _this$props2.isLocked;
              var _this$meta = this.meta,
                selectedFieldPartsLabels = _this$meta.selectedFieldPartsLabels,
                selectedFieldWidgetConfig = _this$meta.selectedFieldWidgetConfig,
                showOperator = _this$meta.showOperator,
                showOperatorLabel = _this$meta.showOperatorLabel;
              var immutableOpsMode = config.settings.immutableOpsMode;
              return /*#__PURE__*/React.createElement(OperatorWrapper, {
                key: "operator",
                config: config,
                selectedField: this.props.selectedField,
                selectedOperator: this.props.selectedOperator,
                setOperator: !immutableOpsMode ? this.props.setOperator : dummyFn,
                selectedFieldPartsLabels: selectedFieldPartsLabels,
                showOperator: showOperator,
                showOperatorLabel: showOperatorLabel,
                selectedFieldWidgetConfig: selectedFieldWidgetConfig,
                readonly: immutableOpsMode || isLocked,
                id: this.props.id,
                groupId: this.props.groupId
              });
            }
          }, {
            key: "renderWidget",
            value: function renderWidget() {
              var _this$props3 = this.props,
                config = _this$props3.config,
                valueError = _this$props3.valueError,
                isLocked = _this$props3.isLocked;
              var showWidget = this.meta.showWidget;
              var immutableValuesMode = config.settings.immutableValuesMode;
              if (!showWidget) return null;
              var widget = /*#__PURE__*/React.createElement(Widget, {
                key: "values",
                field: this.props.selectedField,
                parentField: this.props.parentField,
                operator: this.props.selectedOperator,
                value: this.props.value,
                valueSrc: this.props.valueSrc,
                asyncListValues: this.props.asyncListValues,
                valueError: valueError,
                config: config,
                setValue: !immutableValuesMode ? this.props.setValue : dummyFn,
                setValueSrc: !immutableValuesMode ? this.props.setValueSrc : dummyFn,
                readonly: immutableValuesMode || isLocked,
                id: this.props.id,
                groupId: this.props.groupId
              });
              return /*#__PURE__*/React.createElement(Col, {
                key: "widget-for-" + this.props.selectedOperator,
                className: "rule--value"
              }, widget);
            }
          }, {
            key: "renderOperatorOptions",
            value: function renderOperatorOptions() {
              var config = this.props.config;
              var showOperatorOptions = this.meta.showOperatorOptions;
              var _config$settings = config.settings,
                immutableOpsMode = _config$settings.immutableOpsMode,
                immutableValuesMode = _config$settings.immutableValuesMode;
              if (!showOperatorOptions) return null;
              var opOpts = /*#__PURE__*/React.createElement(OperatorOptions, {
                key: "operatorOptions",
                selectedField: this.props.selectedField,
                selectedOperator: this.props.selectedOperator,
                operatorOptions: this.props.operatorOptions,
                setOperatorOption: !immutableOpsMode ? this.props.setOperatorOption : dummyFn,
                config: config,
                readonly: immutableValuesMode
              });
              return /*#__PURE__*/React.createElement(Col, {
                key: "op-options-for-" + this.props.selectedOperator,
                className: "rule--operator-options"
              }, opOpts);
            }
          }, {
            key: "renderBeforeWidget",
            value: function renderBeforeWidget() {
              var config = this.props.config;
              var renderBeforeWidget = config.settings.renderBeforeWidget;
              return renderBeforeWidget && /*#__PURE__*/React.createElement(Col, {
                key: "before-widget-for-" + this.props.selectedOperator,
                className: "rule--before-widget"
              }, typeof renderBeforeWidget === "function" ? renderBeforeWidget(this.props) : renderBeforeWidget);
            }
          }, {
            key: "renderAfterWidget",
            value: function renderAfterWidget() {
              var config = this.props.config;
              var renderAfterWidget = config.settings.renderAfterWidget;
              return renderAfterWidget && /*#__PURE__*/React.createElement(Col, {
                key: "after-widget-for-" + this.props.selectedOperator,
                className: "rule--after-widget"
              }, typeof renderAfterWidget === "function" ? renderAfterWidget(this.props) : renderAfterWidget);
            }
          }, {
            key: "renderError",
            value: function renderError() {
              var _this$props4 = this.props,
                config = _this$props4.config,
                valueError = _this$props4.valueError;
              var _config$settings2 = config.settings,
                renderRuleError = _config$settings2.renderRuleError,
                showErrorMessage = _config$settings2.showErrorMessage;
              var oneValueError = valueError && valueError.toArray().filter(function (e) {
                return !!e;
              }).shift() || null;
              return showErrorMessage && oneValueError && /*#__PURE__*/React.createElement("div", {
                className: "rule--error"
              }, renderRuleError ? renderRuleError({
                error: oneValueError
              }) : oneValueError);
            }
          }, {
            key: "renderDrag",
            value: function renderDrag() {
              var showDragIcon = this.meta.showDragIcon;
              return showDragIcon && /*#__PURE__*/React.createElement("span", {
                key: "rule-drag-icon",
                className: "qb-drag-handler rule--drag-handler",
                onMouseDown: this.props.handleDraggerMouseDown
              }, /*#__PURE__*/React.createElement(DragIcon, null), " ");
            }
          }, {
            key: "renderDel",
            value: function renderDel() {
              var _this$props5 = this.props,
                config = _this$props5.config,
                isLocked = _this$props5.isLocked;
              var _config$settings3 = config.settings,
                deleteLabel = _config$settings3.deleteLabel,
                immutableGroupsMode = _config$settings3.immutableGroupsMode,
                Btn = _config$settings3.renderButton,
                canDeleteLocked = _config$settings3.canDeleteLocked;
              return !immutableGroupsMode && (!isLocked || isLocked && canDeleteLocked) && /*#__PURE__*/React.createElement(Btn, {
                type: "delRule",
                onClick: this.removeSelf,
                label: deleteLabel,
                config: config
              });
            }
          }, {
            key: "renderLock",
            value: function renderLock() {
              var _this$props6 = this.props,
                config = _this$props6.config,
                isLocked = _this$props6.isLocked,
                isTrueLocked = _this$props6.isTrueLocked,
                id = _this$props6.id;
              var _config$settings4 = config.settings,
                lockLabel = _config$settings4.lockLabel,
                lockedLabel = _config$settings4.lockedLabel,
                showLock = _config$settings4.showLock,
                Switch = _config$settings4.renderSwitch;
              return showLock && !(isLocked && !isTrueLocked) && /*#__PURE__*/React.createElement(Switch, {
                type: "lock",
                id: id,
                value: isLocked,
                setValue: this.setLock,
                label: lockLabel,
                checkedLabel: lockedLabel,
                hideLabel: true,
                config: config
              });
            }
          }, {
            key: "render",
            value: function render() {
              var _this$meta2 = this.meta,
                showOperatorOptions = _this$meta2.showOperatorOptions,
                selectedFieldWidgetConfig = _this$meta2.selectedFieldWidgetConfig;
              var _this$props7 = this.props,
                valueSrc = _this$props7.valueSrc,
                value = _this$props7.value,
                config = _this$props7.config;
              var canShrinkValue = valueSrc.first() == "value" && !showOperatorOptions && value.size == 1 && selectedFieldWidgetConfig.fullWidth;
              var BtnGrp = config.settings.renderButtonGroup;
              var parts = [this.renderField(), this.renderOperator(), this.renderBeforeWidget(), this.renderWidget(), this.renderAfterWidget(), this.renderOperatorOptions()];
              var body = /*#__PURE__*/React.createElement("div", {
                key: "rule-body",
                className: classNames("rule--body", canShrinkValue && "can--shrink--value")
              }, parts);
              var error = this.renderError();
              var drag = this.renderDrag();
              var lock = this.renderLock();
              var del = this.renderDel();
              return /*#__PURE__*/React.createElement(React.Fragment, null, drag, /*#__PURE__*/React.createElement("div", {
                className: "rule--body--wrapper"
              }, body, error), /*#__PURE__*/React.createElement("div", {
                className: "rule--header"
              }, /*#__PURE__*/React.createElement(BtnGrp, {
                config: config
              }, lock, del)));
            }
          }]);
          return Rule;
        }(reactExports.Component);
        Rule.propTypes = {
          id: PropTypes.string.isRequired,
          groupId: PropTypes.string,
          selectedField: PropTypes.string,
          selectedOperator: PropTypes.string,
          operatorOptions: PropTypes.object,
          config: PropTypes.object.isRequired,
          value: PropTypes.any,
          //depends on widget
          valueSrc: PropTypes.any,
          asyncListValues: PropTypes.array,
          isDraggingMe: PropTypes.bool,
          isDraggingTempo: PropTypes.bool,
          parentField: PropTypes.string,
          //from RuleGroup
          valueError: PropTypes.any,
          isLocked: PropTypes.bool,
          isTrueLocked: PropTypes.bool,
          //path: PropTypes.instanceOf(Immutable.List),
          //actions
          handleDraggerMouseDown: PropTypes.func,
          setField: PropTypes.func,
          setOperator: PropTypes.func,
          setOperatorOption: PropTypes.func,
          setLock: PropTypes.func,
          removeSelf: PropTypes.func,
          setValue: PropTypes.func,
          setValueSrc: PropTypes.func,
          reordableNodesCnt: PropTypes.number,
          totalRulesCnt: PropTypes.number,
          parentReordableNodesCnt: PropTypes.number
        };
        const Rule$1 = RuleContainer(Draggable("rule")(ConfirmFn(Rule)));

        /**
         * The base implementation of `_.clamp` which doesn't coerce arguments.
         *
         * @private
         * @param {number} number The number to clamp.
         * @param {number} [lower] The lower bound.
         * @param {number} upper The upper bound.
         * @returns {number} Returns the clamped number.
         */

        function baseClamp$1(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        var _baseClamp = baseClamp$1;
        var toFinite = toFinite_1;

        /**
         * Converts `value` to an integer.
         *
         * **Note:** This method is loosely based on
         * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.toInteger(3.2);
         * // => 3
         *
         * _.toInteger(Number.MIN_VALUE);
         * // => 0
         *
         * _.toInteger(Infinity);
         * // => 1.7976931348623157e+308
         *
         * _.toInteger('3.2');
         * // => 3
         */
        function toInteger$1(value) {
          var result = toFinite(value),
            remainder = result % 1;
          return result === result ? remainder ? result - remainder : result : 0;
        }
        var toInteger_1 = toInteger$1;
        var baseClamp = _baseClamp,
          baseToString = _baseToString,
          toInteger = toInteger_1,
          toString = toString_1;

        /**
         * Checks if `string` starts with the given target string.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to inspect.
         * @param {string} [target] The string to search for.
         * @param {number} [position=0] The position to search from.
         * @returns {boolean} Returns `true` if `string` starts with `target`,
         *  else `false`.
         * @example
         *
         * _.startsWith('abc', 'a');
         * // => true
         *
         * _.startsWith('abc', 'b');
         * // => false
         *
         * _.startsWith('abc', 'b', 1);
         * // => true
         */
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        var startsWith_1 = startsWith;
        const startsWith$1 = /*@__PURE__*/getDefaultExportFromCjs(startsWith_1);
        function _createSuper$f(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$f();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct$f() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var defaultGroupConjunction = Utils$1.DefaultUtils.defaultGroupConjunction;
        var createGroupContainer = function createGroupContainer(Group) {
          var _class;
          return _class = /*#__PURE__*/function (_Component) {
            _inherits$b(GroupContainer, _Component);
            var _super = _createSuper$f(GroupContainer);
            function GroupContainer(_props) {
              var _this;
              _classCallCheck$b(this, GroupContainer);
              _this = _super.call(this, _props);
              _this._selectedConjunction = function (props) {
                props = props || _this.props;
                return props.conjunction || defaultGroupConjunction(props.config, props.field);
              };
              _this.setConjunction = function () {
                var conj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
                _this.props.actions.setConjunction(_this.props.path, conj);
              };
              _this.setNot = function () {
                var not = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
                _this.props.actions.setNot(_this.props.path, not);
              };
              _this.setLock = function () {
                var lock = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
                _this.props.actions.setLock(_this.props.path, lock);
              };
              _this.dummyFn = function () {};
              _this.removeSelf = function () {
                _this.props.actions.removeGroup(_this.props.path);
              };
              _this.addGroup = function () {
                _this.props.actions.addGroup(_this.props.path);
              };
              _this.addCaseGroup = function () {
                _this.props.actions.addCaseGroup(_this.props.path);
              };
              _this.addDefaultCaseGroup = function () {
                _this.props.actions.addDefaultCaseGroup(_this.props.path);
              };
              _this.addRule = function () {
                _this.props.actions.addRule(_this.props.path);
              };
              _this.setField = function (field) {
                _this.props.actions.setField(_this.props.path, field);
              };
              _this.setOperator = function (operator) {
                _this.props.actions.setOperator(_this.props.path, operator);
              };
              _this.setValue = function (delta, value, type) {
                _this.props.actions.setValue(_this.props.path, delta, value, type);
              };
              _this.pureShouldComponentUpdate = pureShouldComponentUpdate(_assertThisInitialized$1(_this));
              useOnPropsChanged(_assertThisInitialized$1(_this));
              _this.selectedConjunction = _this._selectedConjunction(_props);
              _this.conjunctionOptions = _this._getConjunctionOptions(_props);
              _this.dummyFn.isDummyFn = true;
              return _this;
            }
            _createClass$9(GroupContainer, [{
              key: "shouldComponentUpdate",
              value: function shouldComponentUpdate(nextProps, nextState) {
                var prevProps = this.props;
                var prevState = this.state;
                var should = this.pureShouldComponentUpdate(nextProps, nextState);
                if (should) {
                  if (prevState == nextState && prevProps != nextProps) {
                    var draggingId = nextProps.dragging.id || prevProps.dragging.id;
                    var isDraggingMe = draggingId == nextProps.id;
                    var chs = [];
                    for (var k in nextProps) {
                      var changed = nextProps[k] != prevProps[k];
                      if (k == "dragging" && !isDraggingMe) {
                        changed = false; //dragging another item -> ignore
                      }

                      if (changed) {
                        chs.push(k);
                      }
                    }
                    if (!chs.length) should = false;
                  }
                }
                return should;
              }
            }, {
              key: "onPropsChanged",
              value: function onPropsChanged(nextProps) {
                var config = nextProps.config;
                nextProps.id;
                var conjunction = nextProps.conjunction;
                var oldConfig = this.props.config;
                var oldConjunction = this.props.conjunction;
                if (oldConfig != config || oldConjunction != conjunction) {
                  this.selectedConjunction = this._selectedConjunction(nextProps);
                  this.conjunctionOptions = this._getConjunctionOptions(nextProps);
                }
              }
            }, {
              key: "_getConjunctionOptions",
              value: function _getConjunctionOptions(props) {
                var _this2 = this;
                return mapValues$1(props.config.conjunctions, function (item, index) {
                  return {
                    id: "conjunction-".concat(props.id, "-").concat(index),
                    name: "conjunction[".concat(props.id, "]"),
                    key: index,
                    label: item.label,
                    checked: index === _this2._selectedConjunction(props)
                  };
                });
              }
            }, {
              key: "render",
              value: function render() {
                var isDraggingMe = this.props.dragging.id == this.props.id;
                var currentNesting = this.props.path.size;
                var maxNesting = this.props.config.settings.maxNesting;
                var isInDraggingTempo = !isDraggingMe && this.props.isDraggingTempo;

                // Don't allow nesting further than the maximum configured depth and don't
                // allow removal of the root group.
                var allowFurtherNesting = typeof maxNesting === "undefined" || currentNesting < maxNesting;
                var isRoot = currentNesting == 1;
                return /*#__PURE__*/React.createElement("div", {
                  className: "group-or-rule-container group-container",
                  "data-id": this.props.id
                }, [isDraggingMe ? /*#__PURE__*/React.createElement(Group, {
                  key: "dragging",
                  id: this.props.id,
                  groupId: this.props.groupId,
                  isDraggingMe: true,
                  isDraggingTempo: true,
                  dragging: this.props.dragging,
                  isRoot: isRoot,
                  allowFurtherNesting: allowFurtherNesting,
                  conjunctionOptions: this.conjunctionOptions,
                  not: this.props.not,
                  selectedConjunction: this.selectedConjunction,
                  setConjunction: this.dummyFn,
                  setNot: this.dummyFn,
                  setLock: this.dummyFn,
                  removeSelf: this.dummyFn,
                  addGroup: this.dummyFn,
                  addCaseGroup: this.dummyFn,
                  addDefaultCaseGroup: this.dummyFn,
                  addRule: this.dummyFn,
                  setField: this.dummyFn,
                  setOperator: this.dummyFn,
                  setValue: this.dummyFn,
                  value: this.props.value || null,
                  config: this.props.config,
                  children1: this.props.children1,
                  actions: this.props.actions
                  //tree={this.props.tree}
                  ,

                  reordableNodesCnt: this.props.reordableNodesCnt,
                  totalRulesCnt: this.props.totalRulesCnt,
                  selectedField: this.props.field || null,
                  parentField: this.props.parentField || null,
                  selectedOperator: this.props.operator || null,
                  isLocked: this.props.isLocked,
                  isTrueLocked: this.props.isTrueLocked,
                  parentReordableNodesCnt: this.props.parentReordableNodesCnt
                }) : null, /*#__PURE__*/React.createElement(Group, {
                  key: this.props.id,
                  id: this.props.id,
                  groupId: this.props.groupId,
                  isDraggingMe: isDraggingMe,
                  isDraggingTempo: isInDraggingTempo,
                  onDragStart: this.props.onDragStart,
                  isRoot: isRoot,
                  allowFurtherNesting: allowFurtherNesting,
                  conjunctionOptions: this.conjunctionOptions,
                  not: this.props.not,
                  selectedConjunction: this.selectedConjunction,
                  setConjunction: isInDraggingTempo ? this.dummyFn : this.setConjunction,
                  setNot: isInDraggingTempo ? this.dummyFn : this.setNot,
                  setLock: isInDraggingTempo ? this.dummyFn : this.setLock,
                  removeSelf: isInDraggingTempo ? this.dummyFn : this.removeSelf,
                  addGroup: isInDraggingTempo ? this.dummyFn : this.addGroup,
                  addCaseGroup: isInDraggingTempo ? this.dummyFn : this.addCaseGroup,
                  addDefaultCaseGroup: isInDraggingTempo ? this.dummyFn : this.addDefaultCaseGroup,
                  addRule: isInDraggingTempo ? this.dummyFn : this.addRule,
                  setField: isInDraggingTempo ? this.dummyFn : this.setField,
                  setOperator: isInDraggingTempo ? this.dummyFn : this.setOperator,
                  setValue: isInDraggingTempo ? this.dummyFn : this.setValue,
                  value: this.props.value || null,
                  config: this.props.config,
                  children1: this.props.children1,
                  actions: this.props.actions
                  //tree={this.props.tree}
                  ,

                  reordableNodesCnt: this.props.reordableNodesCnt,
                  totalRulesCnt: this.props.totalRulesCnt,
                  selectedField: this.props.field || null,
                  parentField: this.props.parentField || null,
                  selectedOperator: this.props.operator || null,
                  isLocked: this.props.isLocked,
                  isTrueLocked: this.props.isTrueLocked,
                  parentReordableNodesCnt: this.props.parentReordableNodesCnt
                })]);
              }
            }]);
            return GroupContainer;
          }(reactExports.Component), _class.propTypes = {
            //tree: PropTypes.instanceOf(Immutable.Map).isRequired,
            config: PropTypes.object.isRequired,
            actions: PropTypes.object.isRequired,
            //{setConjunction: Funciton, removeGroup, addGroup, addRule, ...}
            path: PropTypes.any.isRequired,
            //instanceOf(Immutable.List)
            id: PropTypes.string.isRequired,
            groupId: PropTypes.string,
            not: PropTypes.bool,
            conjunction: PropTypes.string,
            children1: PropTypes.any,
            //instanceOf(Immutable.OrderedMap)
            onDragStart: PropTypes.func,
            reordableNodesCnt: PropTypes.number,
            field: PropTypes.string,
            // for RuleGroup
            parentField: PropTypes.string,
            //from RuleGroup
            isLocked: PropTypes.bool,
            isTrueLocked: PropTypes.bool,
            //connected:
            dragging: PropTypes.object,
            //{id, x, y, w, h}
            isDraggingTempo: PropTypes.bool
          }, _class;
        };
        const GroupContainer = function (Group) {
          var ConnectedGroupContainer = connect(function (state) {
            return {
              dragging: state.dragging
            };
          }, null, null, {
            context: context
          })(createGroupContainer(Group));
          ConnectedGroupContainer.displayName = "ConnectedGroupContainer";
          return ConnectedGroupContainer;
        };
        function _createSuper$e(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$e();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct$e() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var groupActionsPositionList$1 = {
          topLeft: "group--actions--tl",
          topCenter: "group--actions--tc",
          topRight: "group--actions--tr",
          bottomLeft: "group--actions--bl",
          bottomCenter: "group--actions--bc",
          bottomRight: "group--actions--br"
        };
        var defaultPosition$2 = "topRight";
        var GroupActions = /*#__PURE__*/function (_PureComponent) {
          _inherits$b(GroupActions, _PureComponent);
          var _super = _createSuper$e(GroupActions);
          function GroupActions() {
            _classCallCheck$b(this, GroupActions);
            return _super.apply(this, arguments);
          }
          _createClass$9(GroupActions, [{
            key: "render",
            value: function render() {
              var _this$props = this.props,
                config = _this$props.config,
                addRule = _this$props.addRule,
                addGroup = _this$props.addGroup,
                removeSelf = _this$props.removeSelf,
                setLock = _this$props.setLock,
                isLocked = _this$props.isLocked,
                isTrueLocked = _this$props.isTrueLocked,
                id = _this$props.id,
                canAddGroup = _this$props.canAddGroup,
                canAddRule = _this$props.canAddRule,
                canDeleteGroup = _this$props.canDeleteGroup;
              var _config$settings = config.settings,
                immutableGroupsMode = _config$settings.immutableGroupsMode,
                addRuleLabel = _config$settings.addRuleLabel,
                addGroupLabel = _config$settings.addGroupLabel,
                delGroupLabel = _config$settings.delGroupLabel,
                groupActionsPosition = _config$settings.groupActionsPosition,
                Btn = _config$settings.renderButton,
                Switch = _config$settings.renderSwitch,
                BtnGrp = _config$settings.renderButtonGroup,
                lockLabel = _config$settings.lockLabel,
                lockedLabel = _config$settings.lockedLabel,
                showLock = _config$settings.showLock,
                canDeleteLocked = _config$settings.canDeleteLocked;
              var position = groupActionsPositionList$1[groupActionsPosition || defaultPosition$2];
              var setLockSwitch = showLock && !(isLocked && !isTrueLocked) && /*#__PURE__*/React.createElement(Switch, {
                type: "lock",
                id: id,
                value: isLocked,
                setValue: setLock,
                label: lockLabel,
                checkedLabel: lockedLabel,
                config: config
              });
              var addRuleBtn = !immutableGroupsMode && canAddRule && !isLocked && /*#__PURE__*/React.createElement(Btn, {
                type: "addRule",
                onClick: addRule,
                label: addRuleLabel,
                readonly: isLocked,
                config: config
              });
              var addGroupBtn = !immutableGroupsMode && canAddGroup && !isLocked && /*#__PURE__*/React.createElement(Btn, {
                type: "addGroup",
                onClick: addGroup,
                label: addGroupLabel,
                readonly: isLocked,
                config: config
              });
              var delGroupBtn = !immutableGroupsMode && canDeleteGroup && (!isLocked || isLocked && canDeleteLocked) && /*#__PURE__*/React.createElement(Btn, {
                type: "delGroup",
                onClick: removeSelf,
                label: delGroupLabel,
                config: config
              });
              return /*#__PURE__*/React.createElement("div", {
                className: "group--actions ".concat(position)
              }, /*#__PURE__*/React.createElement(BtnGrp, {
                config: config
              }, setLockSwitch, addRuleBtn, addGroupBtn, delGroupBtn));
            }
          }]);
          return GroupActions;
        }(reactExports.PureComponent);
        function ownKeys$d(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$d(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$d(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$d(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        function _createSuper$d(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$d();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct$d() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var defaultPosition$1 = "topRight";
        var BasicGroup = /*#__PURE__*/function (_Component) {
          _inherits$b(BasicGroup, _Component);
          var _super = _createSuper$d(BasicGroup);
          function BasicGroup(props) {
            var _this;
            _classCallCheck$b(this, BasicGroup);
            _this = _super.call(this, props);
            _this.childrenClassName = function () {
              return "";
            };
            _this.renderBeforeActions = function () {
              var BeforeActions = _this.props.config.settings.renderBeforeActions;
              if (BeforeActions == undefined) return null;
              return typeof BeforeActions === "function" ? /*#__PURE__*/React.createElement(BeforeActions, _this.props) : BeforeActions;
            };
            _this.renderAfterActions = function () {
              var AfterActions = _this.props.config.settings.renderAfterActions;
              if (AfterActions == undefined) return null;
              return typeof AfterActions === "function" ? /*#__PURE__*/React.createElement(AfterActions, _this.props) : AfterActions;
            };
            _this.removeSelf = _this.removeSelf.bind(_assertThisInitialized$1(_this));
            _this.setLock = _this.setLock.bind(_assertThisInitialized$1(_this));
            _this.renderItem = _this.renderItem.bind(_assertThisInitialized$1(_this));
            return _this;
          }
          _createClass$9(BasicGroup, [{
            key: "isGroupTopPosition",
            value: function isGroupTopPosition() {
              return startsWith$1(this.props.config.settings.groupActionsPosition || defaultPosition$1, "top");
            }
          }, {
            key: "setLock",
            value: function setLock(lock) {
              this.props.setLock(lock);
            }
          }, {
            key: "removeSelf",
            value: function removeSelf() {
              var _this2 = this;
              var confirmFn = this.props.confirmFn;
              var _this$props$config$se = this.props.config.settings,
                renderConfirm = _this$props$config$se.renderConfirm,
                confirmOptions = _this$props$config$se.removeGroupConfirmOptions;
              var doRemove = function doRemove() {
                _this2.props.removeSelf();
              };
              if (confirmOptions && !this.isEmptyCurrentGroup()) {
                renderConfirm(_objectSpread$d(_objectSpread$d({}, confirmOptions), {}, {
                  onOk: doRemove,
                  onCancel: null,
                  confirmFn: confirmFn
                }));
              } else {
                doRemove();
              }
            }
          }, {
            key: "isEmptyCurrentGroup",
            value: function isEmptyCurrentGroup() {
              var children = this.props.children1;
              return !children || children.size == 0 || children.size == 1 && this.isEmpty(children.first());
            }
          }, {
            key: "isEmpty",
            value: function isEmpty(item) {
              var isGroup = item.get("type") == "group" || item.get("type") == "rule_group";
              return isGroup ? this.isEmptyGroup(item) : this.isEmptyRule(item);
            }
          }, {
            key: "isEmptyGroup",
            value: function isEmptyGroup(group) {
              var children = group.get("children1");
              return !children || children.size == 0 || children.size == 1 && this.isEmpty(children.first());
            }
          }, {
            key: "isEmptyRule",
            value: function isEmptyRule(rule) {
              var properties = rule.get("properties");
              return !(properties.get("field") !== null && properties.get("operator") !== null && properties.get("value").filter(function (val) {
                return val !== undefined;
              }).size > 0);
            }
          }, {
            key: "render",
            value: function render() {
              return /*#__PURE__*/React.createElement(React.Fragment, null, this.renderHeaderWrapper(), this.renderChildrenWrapper(), this.renderFooterWrapper());
            }
          }, {
            key: "showNot",
            value: function showNot() {
              var config = this.props.config;
              return config.settings.showNot;
            }

            // show conjs for 2+ children?
          }, {
            key: "showConjs",
            value: function showConjs() {
              var _this$props = this.props,
                conjunctionOptions = _this$props.conjunctionOptions;
              _this$props.children1;
              _this$props.config;
              var conjunctionCount = Object.keys(conjunctionOptions).length;
              return conjunctionCount > 1 || this.showNot();
            }
          }, {
            key: "isNoChildren",
            value: function isNoChildren() {
              var children1 = this.props.children1;
              return children1 ? children1.size == 0 : true;
            }
          }, {
            key: "isOneChild",
            value: function isOneChild() {
              var children1 = this.props.children1;
              return children1 ? children1.size < 2 : true;
            }
          }, {
            key: "renderChildrenWrapper",
            value: function renderChildrenWrapper() {
              var children1 = this.props.children1;
              return children1 && /*#__PURE__*/React.createElement("div", {
                key: "group-children",
                className: classNames("group--children", !this.showConjs() ? "hide--conjs" : "", this.isOneChild() ? "hide--line" : "", this.isOneChild() ? "one--child" : "", this.childrenClassName())
              }, this.renderChildren());
            }
          }, {
            key: "renderHeaderWrapper",
            value: function renderHeaderWrapper() {
              var isGroupTopPosition = this.isGroupTopPosition();
              return /*#__PURE__*/React.createElement("div", {
                key: "group-header",
                className: classNames("group--header", this.isOneChild() ? "one--child" : "", !this.showConjs() ? "hide--conjs" : "", this.isOneChild() ? "hide--line" : "", this.isNoChildren() ? "no--children" : "")
              }, this.renderHeader(), isGroupTopPosition && this.renderBeforeActions(), isGroupTopPosition && this.renderActions(), isGroupTopPosition && this.renderAfterActions());
            }
          }, {
            key: "renderFooterWrapper",
            value: function renderFooterWrapper() {
              var isGroupTopPosition = this.isGroupTopPosition();
              return !isGroupTopPosition && /*#__PURE__*/React.createElement("div", {
                key: "group-footer",
                className: "group--footer"
              }, this.renderBeforeActions(), this.renderActions(), this.renderAfterActions());
            }
          }, {
            key: "renderActions",
            value: function renderActions() {
              var _this$props2 = this.props,
                config = _this$props2.config,
                addRule = _this$props2.addRule,
                addGroup = _this$props2.addGroup,
                isLocked = _this$props2.isLocked,
                isTrueLocked = _this$props2.isTrueLocked,
                id = _this$props2.id;
              return /*#__PURE__*/React.createElement(GroupActions, {
                config: config,
                addRule: addRule,
                addGroup: addGroup,
                canAddGroup: this.canAddGroup(),
                canAddRule: this.canAddRule(),
                canDeleteGroup: this.canDeleteGroup(),
                removeSelf: this.removeSelf,
                setLock: this.setLock,
                isLocked: isLocked,
                isTrueLocked: isTrueLocked,
                id: id
              });
            }
          }, {
            key: "canAddGroup",
            value: function canAddGroup() {
              return this.props.allowFurtherNesting;
            }
          }, {
            key: "canAddRule",
            value: function canAddRule() {
              var maxNumberOfRules = this.props.config.settings.maxNumberOfRules;
              var totalRulesCnt = this.props.totalRulesCnt;
              if (maxNumberOfRules) {
                return totalRulesCnt < maxNumberOfRules;
              }
              return true;
            }
          }, {
            key: "canDeleteGroup",
            value: function canDeleteGroup() {
              return !this.props.isRoot;
            }
          }, {
            key: "renderChildren",
            value: function renderChildren() {
              var children1 = this.props.children1;
              return children1 ? children1.map(this.renderItem).toList() : null;
            }
          }, {
            key: "renderItem",
            value: function renderItem(item) {
              var props = this.props;
              var config = props.config,
                actions = props.actions,
                onDragStart = props.onDragStart,
                isLocked = props.isLocked;
              var isRuleGroup = item.get("type") == "group" && item.getIn(["properties", "field"]) != null;
              var type = isRuleGroup ? "rule_group" : item.get("type");
              return /*#__PURE__*/React.createElement(Item, _extends$h({}, this.extraPropsForItem(item), {
                key: item.get("id"),
                id: item.get("id"),
                groupId: props.id
                //path={props.path.push(item.get('id'))}
                ,

                path: item.get("path"),
                type: type,
                properties: item.get("properties"),
                config: config,
                actions: actions,
                children1: item.get("children1")
                //tree={props.tree}
                ,

                reordableNodesCnt: this.reordableNodesCntForItem(item),
                totalRulesCnt: this.totalRulesCntForItem(item),
                parentReordableNodesCnt: this.reordableNodesCnt(),
                onDragStart: onDragStart,
                isDraggingTempo: this.props.isDraggingTempo,
                isParentLocked: isLocked
              }));
            }
          }, {
            key: "extraPropsForItem",
            value: function extraPropsForItem(_item) {
              return {};
            }
          }, {
            key: "reordableNodesCnt",
            value: function reordableNodesCnt() {
              if (this.props.isLocked) return 0;
              return this.props.reordableNodesCnt;
            }
          }, {
            key: "totalRulesCntForItem",
            value: function totalRulesCntForItem(_item) {
              return this.props.totalRulesCnt;
            }
          }, {
            key: "reordableNodesCntForItem",
            value: function reordableNodesCntForItem(_item) {
              if (this.props.isLocked) return 0;
              return this.reordableNodesCnt();
            }
          }, {
            key: "showDragIcon",
            value: function showDragIcon() {
              var _this$props3 = this.props,
                config = _this$props3.config,
                isRoot = _this$props3.isRoot,
                isLocked = _this$props3.isLocked;
              var reordableNodesCnt = this.reordableNodesCnt();
              return config.settings.canReorder && !isRoot && reordableNodesCnt > 1 && !isLocked;
            }
          }, {
            key: "renderDrag",
            value: function renderDrag() {
              var handleDraggerMouseDown = this.props.handleDraggerMouseDown;
              var drag = this.showDragIcon() && /*#__PURE__*/React.createElement("span", {
                key: "group-drag-icon",
                className: "qb-drag-handler group--drag-handler",
                onMouseDown: handleDraggerMouseDown
              }, /*#__PURE__*/React.createElement(DragIcon, null), " ");
              return drag;
            }
          }, {
            key: "conjunctionOptions",
            value: function conjunctionOptions() {
              var conjunctionOptions = this.props.conjunctionOptions;
              return conjunctionOptions;
            }
          }, {
            key: "renderConjs",
            value: function renderConjs() {
              var _this$props4 = this.props,
                config = _this$props4.config,
                children1 = _this$props4.children1,
                id = _this$props4.id,
                selectedConjunction = _this$props4.selectedConjunction,
                setConjunction = _this$props4.setConjunction,
                not = _this$props4.not,
                setNot = _this$props4.setNot,
                isLocked = _this$props4.isLocked;
              var _config$settings = config.settings,
                immutableGroupsMode = _config$settings.immutableGroupsMode,
                Conjs = _config$settings.renderConjs;
              _config$settings.showNot;
              var notLabel = _config$settings.notLabel;
              var conjunctionOptions = this.conjunctionOptions();
              if (!this.showConjs()) return null;
              if (!children1 || !children1.size) return null;
              var renderProps = {
                disabled: this.isOneChild(),
                readonly: immutableGroupsMode || isLocked,
                selectedConjunction: selectedConjunction,
                setConjunction: immutableGroupsMode ? dummyFn : setConjunction,
                conjunctionOptions: conjunctionOptions,
                config: config,
                not: not || false,
                id: id,
                setNot: immutableGroupsMode ? dummyFn : setNot,
                notLabel: notLabel,
                showNot: this.showNot(),
                isLocked: isLocked
              };
              return /*#__PURE__*/React.createElement(Conjs, renderProps);
            }
          }, {
            key: "renderHeader",
            value: function renderHeader() {
              return /*#__PURE__*/React.createElement("div", {
                className: "group--conjunctions"
              }, this.renderConjs(), this.renderDrag());
            }
          }]);
          return BasicGroup;
        }(reactExports.Component);
        BasicGroup.propTypes = {
          //tree: PropTypes.instanceOf(Immutable.Map).isRequired,
          reordableNodesCnt: PropTypes.number,
          conjunctionOptions: PropTypes.object.isRequired,
          allowFurtherNesting: PropTypes.bool.isRequired,
          isRoot: PropTypes.bool.isRequired,
          not: PropTypes.bool,
          selectedConjunction: PropTypes.string,
          config: PropTypes.object.isRequired,
          id: PropTypes.string.isRequired,
          groupId: PropTypes.string,
          path: PropTypes.any,
          //instanceOf(Immutable.List)
          children1: PropTypes.any,
          //instanceOf(Immutable.OrderedMap)
          isDraggingMe: PropTypes.bool,
          isDraggingTempo: PropTypes.bool,
          isLocked: PropTypes.bool,
          isTrueLocked: PropTypes.bool,
          //actions
          handleDraggerMouseDown: PropTypes.func,
          onDragStart: PropTypes.func,
          addRule: PropTypes.func.isRequired,
          addGroup: PropTypes.func.isRequired,
          removeSelf: PropTypes.func.isRequired,
          setConjunction: PropTypes.func.isRequired,
          setNot: PropTypes.func.isRequired,
          setLock: PropTypes.func.isRequired,
          actions: PropTypes.object.isRequired
        };
        const Group = GroupContainer(Draggable("group")(ConfirmFn(BasicGroup)));
        function _superPropBase(object, property) {
          while (!Object.prototype.hasOwnProperty.call(object, property)) {
            object = _getPrototypeOf$1(object);
            if (object === null) break;
          }
          return object;
        }
        function _get() {
          if (typeof Reflect !== "undefined" && Reflect.get) {
            _get = Reflect.get.bind();
          } else {
            _get = function _get(target, property, receiver) {
              var base = _superPropBase(target, property);
              if (!base) return;
              var desc = Object.getOwnPropertyDescriptor(base, property);
              if (desc.get) {
                return desc.get.call(arguments.length < 3 ? target : receiver);
              }
              return desc.value;
            };
          }
          return _get.apply(this, arguments);
        }
        function _createSuper$c(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$c();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct$c() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var RuleGroupActions = /*#__PURE__*/function (_PureComponent) {
          _inherits$b(RuleGroupActions, _PureComponent);
          var _super = _createSuper$c(RuleGroupActions);
          function RuleGroupActions() {
            _classCallCheck$b(this, RuleGroupActions);
            return _super.apply(this, arguments);
          }
          _createClass$9(RuleGroupActions, [{
            key: "render",
            value: function render() {
              var _this$props = this.props,
                config = _this$props.config,
                addRule = _this$props.addRule,
                canAddRule = _this$props.canAddRule,
                canDeleteGroup = _this$props.canDeleteGroup,
                removeSelf = _this$props.removeSelf,
                setLock = _this$props.setLock,
                isLocked = _this$props.isLocked,
                isTrueLocked = _this$props.isTrueLocked,
                id = _this$props.id;
              var _config$settings = config.settings,
                immutableGroupsMode = _config$settings.immutableGroupsMode,
                addRuleLabel = _config$settings.addRuleLabel,
                delGroupLabel = _config$settings.delGroupLabel,
                Btn = _config$settings.renderButton,
                Switch = _config$settings.renderSwitch,
                BtnGrp = _config$settings.renderButtonGroup,
                lockLabel = _config$settings.lockLabel,
                lockedLabel = _config$settings.lockedLabel,
                showLock = _config$settings.showLock,
                canDeleteLocked = _config$settings.canDeleteLocked;
              var setLockSwitch = showLock && !(isLocked && !isTrueLocked) && /*#__PURE__*/React.createElement(Switch, {
                type: "lock",
                id: id,
                value: isLocked,
                setValue: setLock,
                label: lockLabel,
                checkedLabel: lockedLabel,
                hideLabel: true,
                config: config
              });
              var addRuleBtn = !immutableGroupsMode && canAddRule && !isLocked && /*#__PURE__*/React.createElement(Btn, {
                type: "addRuleGroup",
                onClick: addRule,
                label: addRuleLabel,
                readonly: isLocked,
                config: config
              });
              var delGroupBtn = !immutableGroupsMode && canDeleteGroup && (!isLocked || isLocked && canDeleteLocked) && /*#__PURE__*/React.createElement(Btn, {
                type: "delRuleGroup",
                onClick: removeSelf,
                label: delGroupLabel,
                config: config
              });
              return /*#__PURE__*/React.createElement("div", {
                className: "group--actions"
              }, /*#__PURE__*/React.createElement(BtnGrp, {
                config: config
              }, setLockSwitch, addRuleBtn, delGroupBtn));
            }
          }]);
          return RuleGroupActions;
        }(reactExports.PureComponent);
        function ownKeys$c(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$c(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$c(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$c(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        function _createSuper$b(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$b();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct$b() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var RuleGroup = /*#__PURE__*/function (_BasicGroup) {
          _inherits$b(RuleGroup, _BasicGroup);
          var _super = _createSuper$b(RuleGroup);
          function RuleGroup(props) {
            var _this;
            _classCallCheck$b(this, RuleGroup);
            _this = _super.call(this, props);
            _this.childrenClassName = function () {
              return "rule_group--children";
            };
            _this.renderHeaderWrapper = function () {
              return null;
            };
            _this.renderFooterWrapper = function () {
              return null;
            };
            _this.renderConjs = function () {
              return null;
            };
            _this.canAddGroup = function () {
              return false;
            };
            _this.canAddRule = function () {
              return true;
            };
            _this.canDeleteGroup = function () {
              return false;
            };
            useOnPropsChanged(_assertThisInitialized$1(_this));
            _this.onPropsChanged(props);
            return _this;
          }
          _createClass$9(RuleGroup, [{
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {}
          }, {
            key: "reordableNodesCntForItem",
            value: function reordableNodesCntForItem(_item) {
              if (this.props.isLocked) return 0;
              var children1 = this.props.children1;
              return (children1 === null || children1 === void 0 ? void 0 : children1.size) || 0;
            }
          }, {
            key: "renderChildrenWrapper",
            value: function renderChildrenWrapper() {
              return /*#__PURE__*/React.createElement(React.Fragment, null, this.renderDrag(), this.renderField(), this.renderActions(), _get(_getPrototypeOf$1(RuleGroup.prototype), "renderChildrenWrapper", this).call(this));
            }
          }, {
            key: "renderField",
            value: function renderField() {
              var _this$props = this.props,
                config = _this$props.config,
                selectedField = _this$props.selectedField,
                setField = _this$props.setField,
                parentField = _this$props.parentField,
                id = _this$props.id,
                groupId = _this$props.groupId,
                isLocked = _this$props.isLocked;
              var immutableFieldsMode = config.settings.immutableFieldsMode;
              return /*#__PURE__*/React.createElement(FieldWrapper, {
                key: "field",
                classname: "group--field",
                config: config,
                selectedField: selectedField,
                setField: setField,
                parentField: parentField,
                readonly: immutableFieldsMode || isLocked,
                id: id,
                groupId: groupId
              });
            }
          }, {
            key: "renderActions",
            value: function renderActions() {
              var _this$props2 = this.props,
                config = _this$props2.config,
                addRule = _this$props2.addRule,
                isLocked = _this$props2.isLocked,
                isTrueLocked = _this$props2.isTrueLocked,
                id = _this$props2.id;
              return /*#__PURE__*/React.createElement(RuleGroupActions, {
                config: config,
                addRule: addRule,
                canAddRule: this.canAddRule(),
                canDeleteGroup: this.canDeleteGroup(),
                removeSelf: this.removeSelf,
                setLock: this.setLock,
                isLocked: isLocked,
                isTrueLocked: isTrueLocked,
                id: id
              });
            }
          }, {
            key: "extraPropsForItem",
            value: function extraPropsForItem(_item) {
              return {
                parentField: this.props.selectedField
              };
            }
          }]);
          return RuleGroup;
        }(BasicGroup);
        RuleGroup.propTypes = _objectSpread$c(_objectSpread$c({}, BasicGroup.propTypes), {}, {
          selectedField: PropTypes.string,
          parentField: PropTypes.string,
          setField: PropTypes.func
        });
        const RuleGroup$1 = GroupContainer(Draggable("group rule_group")(ConfirmFn(RuleGroup)));
        function _createSuper$a(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$a();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct$a() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var RuleGroupExtActions = /*#__PURE__*/function (_PureComponent) {
          _inherits$b(RuleGroupExtActions, _PureComponent);
          var _super = _createSuper$a(RuleGroupExtActions);
          function RuleGroupExtActions() {
            _classCallCheck$b(this, RuleGroupExtActions);
            return _super.apply(this, arguments);
          }
          _createClass$9(RuleGroupExtActions, [{
            key: "render",
            value: function render() {
              var _this$props = this.props,
                config = _this$props.config,
                addRule = _this$props.addRule,
                canAddRule = _this$props.canAddRule,
                canDeleteGroup = _this$props.canDeleteGroup,
                removeSelf = _this$props.removeSelf,
                setLock = _this$props.setLock,
                isLocked = _this$props.isLocked,
                isTrueLocked = _this$props.isTrueLocked,
                id = _this$props.id;
              var _config$settings = config.settings,
                immutableGroupsMode = _config$settings.immutableGroupsMode,
                addSubRuleLabel = _config$settings.addSubRuleLabel,
                delGroupLabel = _config$settings.delGroupLabel,
                Btn = _config$settings.renderButton,
                Switch = _config$settings.renderSwitch,
                BtnGrp = _config$settings.renderButtonGroup,
                lockLabel = _config$settings.lockLabel,
                lockedLabel = _config$settings.lockedLabel,
                showLock = _config$settings.showLock,
                canDeleteLocked = _config$settings.canDeleteLocked;
              var setLockSwitch = showLock && !(isLocked && !isTrueLocked) && /*#__PURE__*/React.createElement(Switch, {
                type: "lock",
                id: id,
                value: isLocked,
                setValue: setLock,
                label: lockLabel,
                checkedLabel: lockedLabel,
                config: config
              });
              var addRuleBtn = !immutableGroupsMode && canAddRule && !isLocked && /*#__PURE__*/React.createElement(Btn, {
                type: "addRuleGroupExt",
                onClick: addRule,
                label: addSubRuleLabel,
                readonly: isLocked,
                config: config
              });
              var delGroupBtn = !immutableGroupsMode && canDeleteGroup && (!isLocked || isLocked && canDeleteLocked) && /*#__PURE__*/React.createElement(Btn, {
                type: "delRuleGroup",
                onClick: removeSelf,
                label: delGroupLabel,
                config: config
              });
              return /*#__PURE__*/React.createElement("div", {
                className: "group--actions group--actions--tr"
              }, /*#__PURE__*/React.createElement(BtnGrp, {
                config: config
              }, setLockSwitch, addRuleBtn, delGroupBtn));
            }
          }]);
          return RuleGroupExtActions;
        }(reactExports.PureComponent);
        function ownKeys$b(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$b(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$b(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$b(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        function _createForOfIteratorHelper(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
              if (it) o = it;
              var i = 0;
              var F = function F() {};
              return {
                s: F,
                n: function n() {
                  if (i >= o.length) return {
                    done: true
                  };
                  return {
                    done: false,
                    value: o[i++]
                  };
                },
                e: function e(_e) {
                  throw _e;
                },
                f: F
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true,
            didErr = false,
            err;
          return {
            s: function s() {
              it = it.call(o);
            },
            n: function n() {
              var step = it.next();
              normalCompletion = step.done;
              return step;
            },
            e: function e(_e2) {
              didErr = true;
              err = _e2;
            },
            f: function f() {
              try {
                if (!normalCompletion && it["return"] != null) it["return"]();
              } finally {
                if (didErr) throw err;
              }
            }
          };
        }
        function _unsupportedIterableToArray(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }
        function _createSuper$9(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$9();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct$9() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var _Utils$ConfigUtils$1 = Utils$1.ConfigUtils,
          getFieldConfig$2 = _Utils$ConfigUtils$1.getFieldConfig,
          getFieldWidgetConfig = _Utils$ConfigUtils$1.getFieldWidgetConfig;
        var RuleGroupExt = /*#__PURE__*/function (_BasicGroup) {
          _inherits$b(RuleGroupExt, _BasicGroup);
          var _super = _createSuper$9(RuleGroupExt);
          function RuleGroupExt(props) {
            var _this;
            _classCallCheck$b(this, RuleGroupExt);
            _this = _super.call(this, props);
            _this.childrenClassName = function () {
              return "rule_group_ext--children";
            };
            _this.renderFooterWrapper = function () {
              return null;
            };
            _this.canAddGroup = function () {
              return false;
            };
            _this.canAddRule = function () {
              return true;
            };
            _this.canDeleteGroup = function () {
              return true;
            };
            useOnPropsChanged(_assertThisInitialized$1(_this));
            _this.onPropsChanged(props);
            return _this;
          }
          _createClass$9(RuleGroupExt, [{
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {}
          }, {
            key: "renderHeaderWrapper",
            value: function renderHeaderWrapper() {
              return /*#__PURE__*/React.createElement("div", {
                key: "group-header",
                className: classNames("group--header", this.isOneChild() ? "one--child" : "", this.isOneChild() ? "hide--line" : "", this.isNoChildren() ? "no--children" : "", this.showDragIcon() ? "with--drag" : "hide--drag", this.showConjs() && (!this.isOneChild() || this.showNot()) ? "with--conjs" : "hide--conjs")
              }, this.renderHeader(), this.renderGroupField(), this.renderActions());
            }
          }, {
            key: "renderHeader",
            value: function renderHeader() {
              return /*#__PURE__*/React.createElement("div", {
                className: "group--conjunctions"
              }, this.renderConjs(), this.renderDrag());
            }
          }, {
            key: "renderGroupField",
            value: function renderGroupField() {
              return /*#__PURE__*/React.createElement("div", {
                className: "group--field--count--rule"
              }, this.renderField(), this.renderOperator(), this.renderWidget());
            }
          }, {
            key: "showNot",
            value: function showNot() {
              var _this$props = this.props,
                config = _this$props.config,
                selectedField = _this$props.selectedField;
              _this$props.selectedOperator;
              var selectedFieldConfig = getFieldConfig$2(config, selectedField) || {};
              return selectedFieldConfig.showNot != undefined ? selectedFieldConfig.showNot : config.settings.showNot;
            }
          }, {
            key: "conjunctionOptions",
            value: function conjunctionOptions() {
              var _this$props2 = this.props,
                config = _this$props2.config,
                selectedField = _this$props2.selectedField;
              _this$props2.selectedOperator;
              var selectedFieldConfig = getFieldConfig$2(config, selectedField) || {};
              var conjunctionOptions = _get(_getPrototypeOf$1(RuleGroupExt.prototype), "conjunctionOptions", this).call(this);
              if (selectedFieldConfig.conjunctions) {
                var filtered = {};
                var _iterator = _createForOfIteratorHelper(selectedFieldConfig.conjunctions),
                  _step;
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    var k = _step.value;
                    filtered[k] = conjunctionOptions[k];
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
                conjunctionOptions = filtered;
              }
              return conjunctionOptions;
            }
          }, {
            key: "renderField",
            value: function renderField() {
              var _this$props3 = this.props,
                config = _this$props3.config,
                selectedField = _this$props3.selectedField,
                setField = _this$props3.setField,
                parentField = _this$props3.parentField,
                id = _this$props3.id,
                groupId = _this$props3.groupId,
                isLocked = _this$props3.isLocked;
              var immutableFieldsMode = config.settings.immutableFieldsMode;
              return /*#__PURE__*/React.createElement(FieldWrapper, {
                key: "field",
                classname: "rule--field",
                config: config,
                selectedField: selectedField,
                setField: setField,
                parentField: parentField,
                readonly: immutableFieldsMode || isLocked,
                id: id,
                groupId: groupId
              });
            }
          }, {
            key: "renderOperator",
            value: function renderOperator() {
              var _this$props4 = this.props,
                config = _this$props4.config,
                selectedField = _this$props4.selectedField,
                selectedOperator = _this$props4.selectedOperator,
                setField = _this$props4.setField,
                setOperator = _this$props4.setOperator,
                isLocked = _this$props4.isLocked;
              var immutableFieldsMode = config.settings.immutableFieldsMode;
              var selectedFieldWidgetConfig = getFieldWidgetConfig(config, selectedField, selectedOperator) || {};
              var hideOperator = selectedFieldWidgetConfig.hideOperator;
              var showOperatorLabel = selectedField && hideOperator && selectedFieldWidgetConfig.operatorInlineLabel;
              var showOperator = selectedField && !hideOperator;
              return /*#__PURE__*/React.createElement(OperatorWrapper, {
                key: "operator",
                classname: "group--operator",
                config: config,
                selectedField: selectedField,
                selectedOperator: selectedOperator,
                setField: setField,
                setOperator: setOperator,
                selectedFieldPartsLabels: ["group"],
                showOperator: showOperator,
                showOperatorLabel: showOperatorLabel,
                selectedFieldWidgetConfig: selectedFieldWidgetConfig,
                readonly: immutableFieldsMode || isLocked,
                id: this.props.id,
                groupId: this.props.groupId
              });
            }
          }, {
            key: "renderWidget",
            value: function renderWidget() {
              var _this$props5 = this.props,
                config = _this$props5.config,
                selectedField = _this$props5.selectedField,
                selectedOperator = _this$props5.selectedOperator,
                isLocked = _this$props5.isLocked;
              var immutableValuesMode = config.settings.immutableValuesMode;
              var isFieldAndOpSelected = selectedField && selectedOperator;
              var showWidget = isFieldAndOpSelected;
              if (!showWidget) return null;
              var widget = /*#__PURE__*/React.createElement(Widget, {
                key: "values",
                isForRuleGruop: true,
                field: this.props.selectedField,
                operator: this.props.selectedOperator,
                value: this.props.value,
                valueSrc: "value",
                valueError: null,
                config: config,
                setValue: !immutableValuesMode ? this.props.setValue : dummyFn,
                setValueSrc: dummyFn,
                readonly: immutableValuesMode || isLocked,
                id: this.props.id,
                groupId: this.props.groupId
              });
              return /*#__PURE__*/React.createElement(Col, {
                key: "widget-for-" + this.props.selectedOperator,
                className: "rule--value"
              }, widget);
            }
          }, {
            key: "renderActions",
            value: function renderActions() {
              var _this$props6 = this.props,
                config = _this$props6.config,
                addRule = _this$props6.addRule,
                isLocked = _this$props6.isLocked,
                isTrueLocked = _this$props6.isTrueLocked,
                id = _this$props6.id;
              return /*#__PURE__*/React.createElement(RuleGroupExtActions, {
                config: config,
                addRule: addRule,
                canAddRule: this.canAddRule(),
                canDeleteGroup: this.canDeleteGroup(),
                removeSelf: this.removeSelf,
                setLock: this.setLock,
                isLocked: isLocked,
                isTrueLocked: isTrueLocked,
                id: id
              });
            }
          }, {
            key: "reordableNodesCntForItem",
            value: function reordableNodesCntForItem(_item) {
              if (this.props.isLocked) return 0;
              var children1 = this.props.children1;
              return (children1 === null || children1 === void 0 ? void 0 : children1.size) || 0;
            }
          }, {
            key: "extraPropsForItem",
            value: function extraPropsForItem(_item) {
              return {
                parentField: this.props.selectedField
              };
            }
          }]);
          return RuleGroupExt;
        }(BasicGroup);
        RuleGroupExt.propTypes = _objectSpread$b(_objectSpread$b({}, BasicGroup.propTypes), {}, {
          selectedField: PropTypes.string,
          selectedOperator: PropTypes.string,
          value: PropTypes.any,
          parentField: PropTypes.string,
          setField: PropTypes.func,
          setOperator: PropTypes.func,
          setValue: PropTypes.func
        });
        const RuleGroupExt$1 = GroupContainer(Draggable("group rule_group_ext")(ConfirmFn(RuleGroupExt)));
        function _createSuper$8(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$8();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct$8() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var groupActionsPositionList = {
          topLeft: "group--actions--tl",
          topCenter: "group--actions--tc",
          topRight: "group--actions--tr",
          bottomLeft: "group--actions--bl",
          bottomCenter: "group--actions--bc",
          bottomRight: "group--actions--br"
        };
        var defaultPosition = "topRight";
        var SwitchGroupActions = /*#__PURE__*/function (_PureComponent) {
          _inherits$b(SwitchGroupActions, _PureComponent);
          var _super = _createSuper$8(SwitchGroupActions);
          function SwitchGroupActions() {
            _classCallCheck$b(this, SwitchGroupActions);
            return _super.apply(this, arguments);
          }
          _createClass$9(SwitchGroupActions, [{
            key: "render",
            value: function render() {
              var _this$props = this.props,
                config = _this$props.config,
                addCaseGroup = _this$props.addCaseGroup,
                addDefaultCaseGroup = _this$props.addDefaultCaseGroup,
                setLock = _this$props.setLock,
                isLocked = _this$props.isLocked,
                isTrueLocked = _this$props.isTrueLocked,
                id = _this$props.id,
                canAddGroup = _this$props.canAddGroup,
                canAddDefault = _this$props.canAddDefault;
              var _config$settings = config.settings,
                immutableGroupsMode = _config$settings.immutableGroupsMode,
                addCaseLabel = _config$settings.addCaseLabel,
                addDefaultCaseLabel = _config$settings.addDefaultCaseLabel,
                groupActionsPosition = _config$settings.groupActionsPosition,
                Btn = _config$settings.renderButton,
                Switch = _config$settings.renderSwitch,
                BtnGrp = _config$settings.renderButtonGroup,
                lockLabel = _config$settings.lockLabel,
                lockedLabel = _config$settings.lockedLabel,
                showLock = _config$settings.showLock;
              var position = groupActionsPositionList[groupActionsPosition || defaultPosition];
              var setLockSwitch = showLock && !(isLocked && !isTrueLocked) && /*#__PURE__*/React.createElement(Switch, {
                type: "lock",
                id: id,
                value: isLocked,
                setValue: setLock,
                label: lockLabel,
                checkedLabel: lockedLabel,
                config: config
              });
              var addCaseGroupBtn = !immutableGroupsMode && canAddGroup && !isLocked && /*#__PURE__*/React.createElement(Btn, {
                type: "addCaseGroup",
                onClick: addCaseGroup,
                label: addCaseLabel,
                readonly: isLocked,
                config: config
              });
              var addDefaultCaseGroupBtn = !immutableGroupsMode && canAddDefault && !isLocked && /*#__PURE__*/React.createElement(Btn, {
                type: "addDefaultCaseGroup",
                onClick: addDefaultCaseGroup,
                label: addDefaultCaseLabel,
                readonly: isLocked,
                config: config
              });
              return /*#__PURE__*/React.createElement("div", {
                className: "group--actions ".concat(position)
              }, /*#__PURE__*/React.createElement(BtnGrp, {
                config: config
              }, setLockSwitch, addCaseGroupBtn, addDefaultCaseGroupBtn));
            }
          }]);
          return SwitchGroupActions;
        }(reactExports.PureComponent);
        function ownKeys$a(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$a(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$a(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$a(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        function _createSuper$7(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$7();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct$7() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var _Utils$TreeUtils$1 = Utils$1.TreeUtils,
          getTotalReordableNodesCountInTree$1 = _Utils$TreeUtils$1.getTotalReordableNodesCountInTree,
          getTotalRulesCountInTree$1 = _Utils$TreeUtils$1.getTotalRulesCountInTree;
        var SwitchGroup = /*#__PURE__*/function (_BasicGroup) {
          _inherits$b(SwitchGroup, _BasicGroup);
          var _super = _createSuper$7(SwitchGroup);
          function SwitchGroup(props) {
            var _this;
            _classCallCheck$b(this, SwitchGroup);
            _this = _super.call(this, props);
            _this.childrenClassName = function () {
              return "switch_group--children";
            };
            _this.renderFooterWrapper = function () {
              return null;
            };
            _this.hasDefaultCase = function () {
              var _this$props$children;
              return ((_this$props$children = _this.props.children1) === null || _this$props$children === void 0 ? void 0 : _this$props$children.size) && _this.props.children1.filter(function (c) {
                return c.get("children1") == null;
              }).size > 0;
            };
            useOnPropsChanged(_assertThisInitialized$1(_this));
            _this.onPropsChanged(props);
            return _this;
          }
          _createClass$9(SwitchGroup, [{
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {}
          }, {
            key: "canAddGroup",
            value: function canAddGroup() {
              var _this$props$children2;
              var maxNumberOfCases = this.props.config.settings.maxNumberOfCases;
              var totalCasesCnt = ((_this$props$children2 = this.props.children1) === null || _this$props$children2 === void 0 ? void 0 : _this$props$children2.size) || 0;
              if (maxNumberOfCases) {
                return totalCasesCnt < maxNumberOfCases;
              }
              return true;
            }
          }, {
            key: "canAddRule",
            value: function canAddRule() {
              return false;
            }
          }, {
            key: "reordableNodesCnt",
            value: function reordableNodesCnt() {
              var _this$props$children3;
              // result will be passed to each case's `parentReordableNodesCnt` prop
              var totalCasesCnt = ((_this$props$children3 = this.props.children1) === null || _this$props$children3 === void 0 ? void 0 : _this$props$children3.size) || 0;
              var casesToReorder = totalCasesCnt;
              if (this.hasDefaultCase()) {
                casesToReorder--;
              }
              return casesToReorder;
            }
          }, {
            key: "totalRulesCntForItem",
            value: function totalRulesCntForItem(item) {
              return getTotalRulesCountInTree$1(item);
            }
          }, {
            key: "reordableNodesCntForItem",
            value: function reordableNodesCntForItem(item) {
              var _this$props$children4;
              if (this.props.isLocked) return 0;
              var _this$props$config$se = this.props.config.settings,
                canLeaveEmptyCase = _this$props$config$se.canLeaveEmptyCase,
                canRegroupCases = _this$props$config$se.canRegroupCases;
              var totalCasesCnt = ((_this$props$children4 = this.props.children1) === null || _this$props$children4 === void 0 ? void 0 : _this$props$children4.size) || 0;
              var casesToReorder = totalCasesCnt;
              if (this.hasDefaultCase()) {
                casesToReorder--;
              }
              var nodesInCase = getTotalReordableNodesCountInTree$1(item);
              var cnt = nodesInCase;
              if (cnt == 1 && canRegroupCases && canLeaveEmptyCase && casesToReorder > 1) cnt = 111;
              return cnt;
            }
          }, {
            key: "renderHeaderWrapper",
            value: function renderHeaderWrapper() {
              return /*#__PURE__*/React.createElement("div", {
                key: "group-header",
                className: classNames("group--header", this.isOneChild() ? "one--child" : "", this.isOneChild() ? "hide--line" : "", this.isNoChildren() ? "no--children" : "", this.showDragIcon() ? "with--drag" : "hide--drag"
                //this.showConjs() && (!this.isOneChild() || this.showNot()) ? "with--conjs" : "hide--conjs"
                )
              }, this.renderHeader(), this.renderActions());
            }
          }, {
            key: "renderHeader",
            value: function renderHeader() {
              return /*#__PURE__*/React.createElement("div", {
                className: "group--conjunctions"
              }, this.renderConjs(), this.renderDrag());
            }
          }, {
            key: "renderConjs",
            value: function renderConjs() {
              var renderSwitchPrefix = this.props.config.settings.renderSwitchPrefix;
              return renderSwitchPrefix ? renderSwitchPrefix() : null;
            }
          }, {
            key: "showNot",
            value: function showNot() {
              return false;
            }
          }, {
            key: "renderActions",
            value: function renderActions() {
              var _this$props = this.props,
                config = _this$props.config,
                addCaseGroup = _this$props.addCaseGroup,
                addDefaultCaseGroup = _this$props.addDefaultCaseGroup,
                isLocked = _this$props.isLocked,
                isTrueLocked = _this$props.isTrueLocked,
                id = _this$props.id;
              return /*#__PURE__*/React.createElement(SwitchGroupActions, {
                config: config,
                addCaseGroup: addCaseGroup,
                addDefaultCaseGroup: addDefaultCaseGroup,
                canAddDefault: !this.hasDefaultCase(),
                canAddGroup: this.canAddGroup(),
                setLock: this.setLock,
                isLocked: isLocked,
                isTrueLocked: isTrueLocked,
                id: id
              });
            }
          }]);
          return SwitchGroup;
        }(BasicGroup);
        SwitchGroup.propTypes = _objectSpread$a({}, BasicGroup.propTypes);
        const SwitchGroup$1 = GroupContainer(Draggable("group switch_group")(ConfirmFn(SwitchGroup)));
        function ownKeys$9(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$9(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$9(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$9(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        function _createSuper$6(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$6();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct$6() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var CaseGroup = /*#__PURE__*/function (_BasicGroup) {
          _inherits$b(CaseGroup, _BasicGroup);
          var _super = _createSuper$6(CaseGroup);
          function CaseGroup(props) {
            var _this;
            _classCallCheck$b(this, CaseGroup);
            _this = _super.call(this, props);
            _this.childrenClassName = function () {
              return "case_group--children";
            };
            _this.renderFooterWrapper = function () {
              return null;
            };
            useOnPropsChanged(_assertThisInitialized$1(_this));
            _this.onPropsChanged(props);
            return _this;
          }
          _createClass$9(CaseGroup, [{
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {}
          }, {
            key: "isDefaultCase",
            value: function isDefaultCase() {
              return this.props.children1 == undefined;
            }
          }, {
            key: "reordableNodesCnt",
            value: function reordableNodesCnt() {
              // `parentReordableNodesCnt` is number of cases to reorder
              return this.props.parentReordableNodesCnt;
            }
          }, {
            key: "reordableNodesCntForItem",
            value: function reordableNodesCntForItem(_item) {
              // `reordableNodesCnt` is number of nodes is current case
              if (this.props.isLocked) return 0;
              return this.props.reordableNodesCnt;
            }
          }, {
            key: "totalRulesCntForItem",
            value: function totalRulesCntForItem(_item) {
              // `totalRulesCnt` is number of nodes is current case
              return this.props.totalRulesCnt;
            }
          }, {
            key: "showDragIcon",
            value: function showDragIcon() {
              // default impl of `showDragIcon()` uses `this.reordableNodesCnt()`
              if (this.isDefaultCase()) return false;
              return _get(_getPrototypeOf$1(CaseGroup.prototype), "showDragIcon", this).call(this);
            }
          }, {
            key: "renderHeaderWrapper",
            value: function renderHeaderWrapper() {
              return /*#__PURE__*/React.createElement("div", {
                key: "group-header",
                className: classNames("group--header", this.isOneChild() ? "one--child" : "", this.isOneChild() ? "hide--line" : "", this.isNoChildren() ? "no--children" : "", this.showDragIcon() ? "with--drag" : "hide--drag", this.showConjs() && (!this.isOneChild() || this.showNot()) ? "with--conjs" : "hide--conjs")
              }, this.renderHeaderLeft(), this.renderHeaderCenter(), this.renderActions());
            }
          }, {
            key: "renderChildrenWrapper",
            value: function renderChildrenWrapper() {
              if (this.isDefaultCase()) return null;
              // body has 2 columns: condition & value
              return /*#__PURE__*/React.createElement("div", {
                className: "case_group--body"
              }, this.renderCondition(), this.renderValue());
            }
          }, {
            key: "renderHeaderLeft",
            value: function renderHeaderLeft() {
              if (this.isDefaultCase()) {
                var defaultCaseLabel = this.props.config.settings.defaultCaseLabel;
                return defaultCaseLabel || "";
              }
              // default impl:
              return /*#__PURE__*/React.createElement("div", {
                className: "group--conjunctions"
              }, this.renderConjs(), this.renderDrag());
            }
          }, {
            key: "renderCondition",
            value: function renderCondition() {
              if (this.isDefaultCase()) return null;
              return _get(_getPrototypeOf$1(CaseGroup.prototype), "renderChildrenWrapper", this).call(this);
            }
          }, {
            key: "renderHeaderCenter",
            value: function renderHeaderCenter() {
              if (this.isDefaultCase()) return this.renderValue();else return null;
            }
          }, {
            key: "canAddGroup",
            value: function canAddGroup() {
              if (this.isDefaultCase()) return false;
              return _get(_getPrototypeOf$1(CaseGroup.prototype), "canAddGroup", this).call(this);
            }
          }, {
            key: "canAddRule",
            value: function canAddRule() {
              if (this.isDefaultCase()) return false;
              return _get(_getPrototypeOf$1(CaseGroup.prototype), "canAddRule", this).call(this);
            }
          }, {
            key: "renderValue",
            value: function renderValue() {
              var _this$props = this.props,
                config = _this$props.config,
                isLocked = _this$props.isLocked,
                value = _this$props.value,
                setValue = _this$props.setValue,
                id = _this$props.id;
              var immutableValuesMode = config.settings.immutableValuesMode;
              var widget = /*#__PURE__*/React.createElement(Widget, {
                key: "values",
                isCaseValue: true,
                field: "!case_value",
                operator: null,
                value: value,
                valueSrc: "value",
                valueError: null,
                config: config,
                setValue: !immutableValuesMode ? setValue : dummyFn,
                setValueSrc: dummyFn,
                readonly: immutableValuesMode || isLocked,
                id: id,
                groupId: null
              });
              return /*#__PURE__*/React.createElement(Col, {
                className: "case_group--value"
              }, widget);
            }
          }, {
            key: "renderActions",
            value: function renderActions() {
              var _this$props2 = this.props,
                config = _this$props2.config,
                addGroup = _this$props2.addGroup,
                addRule = _this$props2.addRule,
                isLocked = _this$props2.isLocked,
                isTrueLocked = _this$props2.isTrueLocked,
                id = _this$props2.id;
              return /*#__PURE__*/React.createElement(GroupActions, {
                config: config,
                addGroup: addGroup,
                addRule: addRule,
                canAddRule: this.canAddRule(),
                canAddGroup: this.canAddGroup(),
                canDeleteGroup: this.canDeleteGroup(),
                removeSelf: this.removeSelf,
                setLock: this.setLock,
                isLocked: isLocked,
                isTrueLocked: isTrueLocked,
                id: id
              });
            }
          }, {
            key: "isEmptyCurrentGroup",
            value: function isEmptyCurrentGroup() {
              // used to confirm self-deletion
              var value = this.props.value;
              var oneValue = value && value.size ? value.get(0) : null;
              var hasValue = oneValue != null && (Array.isArray(oneValue) ? oneValue.length > 0 : true);
              return _get(_getPrototypeOf$1(CaseGroup.prototype), "isEmptyCurrentGroup", this).call(this) && !hasValue;
            }
          }]);
          return CaseGroup;
        }(BasicGroup);
        CaseGroup.propTypes = _objectSpread$9(_objectSpread$9({}, BasicGroup.propTypes), {}, {
          parentReordableNodesCnt: PropTypes.number,
          value: PropTypes.any,
          setValue: PropTypes.func
        });
        const CaseGroup$1 = GroupContainer(Draggable("group case_group")(ConfirmFn(CaseGroup)));
        var _excluded$4 = ["type"];
        function _createSuper$5(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct$5() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        function ownKeys$8(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$8(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$8(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$8(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        var types$3 = ["rule", "group", "rule_group", "switch_group", "case_group"];
        var getProperties = function getProperties(props) {
          var _props$properties;
          var properties = ((_props$properties = props.properties) === null || _props$properties === void 0 ? void 0 : _props$properties.toObject()) || {};
          var result = _objectSpread$8({}, properties);
          if (props.isParentLocked) {
            result.isLocked = true;
          }
          if (properties.isLocked) {
            result.isTrueLocked = true;
          }
          return result;
        };
        var typeMap = {
          rule: function rule(props) {
            return /*#__PURE__*/React.createElement(Rule$1, _extends$h({}, getProperties(props), {
              id: props.id,
              groupId: props.groupId,
              path: props.path,
              actions: props.actions,
              reordableNodesCnt: props.reordableNodesCnt,
              totalRulesCnt: props.totalRulesCnt,
              config: props.config,
              onDragStart: props.onDragStart,
              isDraggingTempo: props.isDraggingTempo,
              parentField: props.parentField,
              parentReordableNodesCnt: props.parentReordableNodesCnt
            }));
          },
          group: function group(props) {
            return /*#__PURE__*/React.createElement(Group, _extends$h({}, getProperties(props), {
              id: props.id,
              groupId: props.groupId,
              path: props.path,
              actions: props.actions,
              config: props.config
              //tree={props.tree}
              ,

              reordableNodesCnt: props.reordableNodesCnt,
              totalRulesCnt: props.totalRulesCnt,
              onDragStart: props.onDragStart,
              isDraggingTempo: props.isDraggingTempo,
              children1: props.children1,
              parentField: null,
              parentReordableNodesCnt: props.parentReordableNodesCnt
            }));
          },
          rule_group: function rule_group(props) {
            return /*#__PURE__*/React.createElement(RuleGroup$1, _extends$h({}, getProperties(props), {
              id: props.id,
              groupId: props.groupId,
              path: props.path,
              actions: props.actions,
              config: props.config
              //tree={props.tree}
              ,

              reordableNodesCnt: props.reordableNodesCnt,
              totalRulesCnt: props.totalRulesCnt,
              onDragStart: props.onDragStart,
              isDraggingTempo: props.isDraggingTempo,
              children1: props.children1,
              parentField: props.parentField,
              parentReordableNodesCnt: props.parentReordableNodesCnt
            }));
          },
          rule_group_ext: function rule_group_ext(props) {
            return /*#__PURE__*/React.createElement(RuleGroupExt$1, _extends$h({}, getProperties(props), {
              id: props.id,
              groupId: props.groupId,
              path: props.path,
              actions: props.actions,
              config: props.config
              //tree={props.tree}
              ,

              reordableNodesCnt: props.reordableNodesCnt,
              totalRulesCnt: props.totalRulesCnt,
              onDragStart: props.onDragStart,
              isDraggingTempo: props.isDraggingTempo,
              children1: props.children1,
              parentField: props.parentField,
              parentReordableNodesCnt: props.parentReordableNodesCnt
            }));
          },
          switch_group: function switch_group(props) {
            return /*#__PURE__*/React.createElement(SwitchGroup$1, _extends$h({}, getProperties(props), {
              id: props.id,
              groupId: props.groupId,
              path: props.path,
              actions: props.actions,
              config: props.config
              //tree={props.tree}
              ,

              reordableNodesCnt: props.reordableNodesCnt,
              totalRulesCnt: props.totalRulesCnt,
              onDragStart: props.onDragStart,
              isDraggingTempo: props.isDraggingTempo,
              children1: props.children1,
              parentField: null,
              parentReordableNodesCnt: props.parentReordableNodesCnt
            }));
          },
          case_group: function case_group(props) {
            return /*#__PURE__*/React.createElement(CaseGroup$1, _extends$h({}, getProperties(props), {
              id: props.id,
              groupId: props.groupId,
              path: props.path,
              actions: props.actions,
              config: props.config
              //tree={props.tree}
              ,

              reordableNodesCnt: props.reordableNodesCnt,
              totalRulesCnt: props.totalRulesCnt,
              onDragStart: props.onDragStart,
              isDraggingTempo: props.isDraggingTempo,
              children1: props.children1,
              parentField: null,
              parentReordableNodesCnt: props.parentReordableNodesCnt
            }));
          }
        };
        var Item = /*#__PURE__*/function (_PureComponent) {
          _inherits$b(Item, _PureComponent);
          var _super = _createSuper$5(Item);
          function Item() {
            _classCallCheck$b(this, Item);
            return _super.apply(this, arguments);
          }
          _createClass$9(Item, [{
            key: "render",
            value: function render() {
              var _props$properties2;
              var _this$props = this.props,
                type = _this$props.type,
                props = _objectWithoutProperties$2(_this$props, _excluded$4);
              var mode = (_props$properties2 = props.properties) === null || _props$properties2 === void 0 ? void 0 : _props$properties2.get("mode");
              var postfix = mode == "array" ? "_ext" : "";
              var renderItem = props.config.settings.renderItem;
              var Cmp = typeMap[type + postfix];
              if (renderItem) {
                return renderItem(_objectSpread$8(_objectSpread$8({}, props), {}, {
                  type: type,
                  itemComponent: Cmp
                }));
              }
              if (!Cmp) return null;
              return Cmp(props);
            }
          }]);
          return Item;
        }(reactExports.PureComponent);
        Item.propTypes = {
          //tree: PropTypes.instanceOf(Immutable.Map).isRequired,
          config: PropTypes.object.isRequired,
          id: PropTypes.string.isRequired,
          groupId: PropTypes.string,
          type: PropTypes.oneOf(types$3).isRequired,
          path: PropTypes.any.isRequired,
          //instanceOf(Immutable.List)
          properties: PropTypes.any.isRequired,
          //instanceOf(Immutable.Map)
          children1: PropTypes.any,
          //instanceOf(Immutable.OrderedMap)
          actions: PropTypes.object.isRequired,
          reordableNodesCnt: PropTypes.number,
          onDragStart: PropTypes.func,
          parentField: PropTypes.string,
          //from RuleGroup
          isDraggingTempo: PropTypes.bool,
          isParentLocked: PropTypes.bool
        };
        function _createSuper$4(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct$4() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var _Utils$TreeUtils = Utils$1.TreeUtils,
          getTotalReordableNodesCountInTree = _Utils$TreeUtils.getTotalReordableNodesCountInTree,
          getTotalRulesCountInTree = _Utils$TreeUtils.getTotalRulesCountInTree;
        var _Utils$DefaultUtils = Utils$1.DefaultUtils,
          createListFromArray = _Utils$DefaultUtils.createListFromArray,
          emptyProperies = _Utils$DefaultUtils.emptyProperies;
        var Builder = /*#__PURE__*/function (_Component) {
          _inherits$b(Builder, _Component);
          var _super = _createSuper$4(Builder);
          function Builder(props) {
            var _this;
            _classCallCheck$b(this, Builder);
            _this = _super.call(this, props);
            _this.pureShouldComponentUpdate = pureShouldComponentUpdate(_assertThisInitialized$1(_this));
            _this._updPath(props);
            return _this;
          }
          _createClass$9(Builder, [{
            key: "shouldComponentUpdate",
            value: function shouldComponentUpdate(nextProps, nextState) {
              var prevProps = this.props;
              var should = this.pureShouldComponentUpdate(nextProps, nextState);
              if (should) {
                var chs = [];
                for (var k in nextProps) {
                  var changed = nextProps[k] !== prevProps[k];
                  if (changed && k != "__isInternalValueChange") {
                    chs.push(k);
                  }
                }
                if (!chs.length) should = false;
                //optimize render
                if (chs.length == 1 && chs[0] == "tree" && nextProps.__isInternalValueChange) should = false;
              }
              return should;
            }
          }, {
            key: "_updPath",
            value: function _updPath(props) {
              var id = props.tree.get("id");
              this.path = createListFromArray([id]);
            }
          }, {
            key: "render",
            value: function render() {
              var tree = this.props.tree;
              var rootType = tree.get("type");
              var isTernary = rootType == "switch_group";
              var reordableNodesCnt = isTernary ? null : getTotalReordableNodesCountInTree(tree);
              var totalRulesCnt = isTernary ? null : getTotalRulesCountInTree(tree);
              var id = tree.get("id");
              return /*#__PURE__*/React.createElement(Item, {
                key: id,
                id: id,
                path: this.path,
                type: rootType,
                properties: tree.get("properties") || emptyProperies(),
                config: this.props.config,
                actions: this.props.actions,
                children1: tree.get("children1") || emptyProperies()
                //tree={tree}
                ,

                reordableNodesCnt: reordableNodesCnt,
                totalRulesCnt: totalRulesCnt,
                parentReordableNodesCnt: 0,
                onDragStart: this.props.onDragStart
              });
            }
          }]);
          return Builder;
        }(reactExports.Component);
        Builder.propTypes = {
          tree: PropTypes.any.isRequired,
          //instanceOf(Immutable.Map)
          config: PropTypes.object.isRequired,
          actions: PropTypes.object.isRequired,
          onDragStart: PropTypes.func
        };
        const Builder$1 = SortableContainer(Builder);
        function ownKeys$7(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$7(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$7(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$7(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        function _createSuper$3(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct$3() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var clone$1 = Utils$1.clone;
        var getFieldConfig$1 = Utils$1.ConfigUtils.getFieldConfig;
        var _Utils$RuleUtils$1 = Utils$1.RuleUtils,
          getFieldPath$1 = _Utils$RuleUtils$1.getFieldPath,
          getFieldPathLabels = _Utils$RuleUtils$1.getFieldPathLabels,
          getWidgetForFieldOp$1 = _Utils$RuleUtils$1.getWidgetForFieldOp;

        //tip: this.props.value - right value, this.props.field - left value
        var ValueField = /*#__PURE__*/function (_Component) {
          _inherits$b(ValueField, _Component);
          var _super = _createSuper$3(ValueField);
          function ValueField(props) {
            var _this;
            _classCallCheck$b(this, ValueField);
            _this = _super.call(this, props);
            useOnPropsChanged(_assertThisInitialized$1(_this));
            _this.onPropsChanged(props);
            return _this;
          }
          _createClass$9(ValueField, [{
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {
              var prevProps = this.props;
              var keysForItems = ["config", "field", "operator", "isFuncArg", "parentField"];
              var keysForMeta = ["config", "field", "operator", "value", "placeholder", "isFuncArg", "parentField"];
              var needUpdateItems = !this.items || keysForItems.map(function (k) {
                return nextProps[k] !== prevProps[k];
              }).filter(function (ch) {
                return ch;
              }).length > 0;
              var needUpdateMeta = !this.meta || keysForMeta.map(function (k) {
                return nextProps[k] !== prevProps[k];
              }).filter(function (ch) {
                return ch;
              }).length > 0;
              if (needUpdateItems) {
                this.items = this.getItems(nextProps);
              }
              if (needUpdateMeta) {
                this.meta = this.getMeta(nextProps);
              }
            }
          }, {
            key: "getItems",
            value: function getItems(_ref) {
              var config = _ref.config,
                field = _ref.field,
                operator = _ref.operator,
                parentField = _ref.parentField,
                isFuncArg = _ref.isFuncArg,
                fieldDefinition = _ref.fieldDefinition;
              var canCompareFieldWithField = config.settings.canCompareFieldWithField;
              var fieldSeparator = config.settings.fieldSeparator;
              var parentFieldPath = typeof parentField == "string" ? parentField.split(fieldSeparator) : parentField;
              var parentFieldConfig = parentField ? getFieldConfig$1(config, parentField) : null;
              var sourceFields = parentField ? parentFieldConfig && parentFieldConfig.subfields : config.fields;
              var filteredFields = this.filterFields(config, sourceFields, field, parentField, parentFieldPath, operator, canCompareFieldWithField, isFuncArg, fieldDefinition);
              var items = this.buildOptions(parentFieldPath, config, filteredFields, parentFieldPath);
              return items;
            }
          }, {
            key: "getMeta",
            value: function getMeta(_ref2) {
              var config = _ref2.config,
                field = _ref2.field;
              _ref2.operator;
              var value = _ref2.value,
                customPlaceholder = _ref2.placeholder,
                isFuncArg = _ref2.isFuncArg,
                parentField = _ref2.parentField;
              var _config$settings = config.settings,
                fieldPlaceholder = _config$settings.fieldPlaceholder,
                fieldSeparatorDisplay = _config$settings.fieldSeparatorDisplay;
              var selectedKey = value;
              var isFieldSelected = !!value;
              var leftFieldConfig = getFieldConfig$1(config, field);
              var leftFieldWidgetField = leftFieldConfig.widgets.field;
              var leftFieldWidgetFieldProps = leftFieldWidgetField && leftFieldWidgetField.widgetProps || {};
              var placeholder = isFieldSelected ? null : isFuncArg && customPlaceholder || leftFieldWidgetFieldProps.valuePlaceholder || fieldPlaceholder;
              var currField = isFieldSelected ? getFieldConfig$1(config, selectedKey) : null;
              var selectedOpts = currField || {};
              var selectedKeys = getFieldPath$1(selectedKey, config);
              var selectedPath = getFieldPath$1(selectedKey, config, true);
              var selectedLabel = this.getFieldLabel(currField, selectedKey, config);
              var partsLabels = getFieldPathLabels(selectedKey, config);
              var selectedFullLabel = partsLabels ? partsLabels.join(fieldSeparatorDisplay) : null;
              if (selectedFullLabel == selectedLabel || parentField) selectedFullLabel = null;
              var selectedAltLabel = selectedOpts.label2;
              return {
                placeholder: placeholder,
                selectedKey: selectedKey,
                selectedKeys: selectedKeys,
                selectedPath: selectedPath,
                selectedLabel: selectedLabel,
                selectedOpts: selectedOpts,
                selectedAltLabel: selectedAltLabel,
                selectedFullLabel: selectedFullLabel
              };
            }
          }, {
            key: "filterFields",
            value: function filterFields(config, fields, leftFieldFullkey, parentField, parentFieldPath, operator, canCompareFieldWithField, isFuncArg, fieldDefinition) {
              fields = clone$1(fields);
              var fieldSeparator = config.settings.fieldSeparator;
              var leftFieldConfig = getFieldConfig$1(config, leftFieldFullkey);
              var widget = getWidgetForFieldOp$1(config, leftFieldFullkey, operator, "value");
              config.widgets[widget];
              var expectedType;
              if (isFuncArg && fieldDefinition) {
                expectedType = fieldDefinition.type;
              } else {
                expectedType = leftFieldConfig.type;
              }
              function _filter(list, path) {
                for (var rightFieldKey in list) {
                  var subfields = list[rightFieldKey].subfields;
                  var subpath = (path ? path : []).concat(rightFieldKey);
                  var rightFieldFullkey = subpath.join(fieldSeparator);
                  var rightFieldConfig = getFieldConfig$1(config, rightFieldFullkey);
                  if (!rightFieldConfig) {
                    delete list[rightFieldKey];
                  } else if (rightFieldConfig.type == "!struct" || rightFieldConfig.type == "!group") {
                    if (_filter(subfields, subpath) == 0) delete list[rightFieldKey];
                  } else {
                    // tip: LHS field can be used as arg in RHS function
                    var canUse = rightFieldConfig.type == expectedType && (isFuncArg ? true : rightFieldFullkey != leftFieldFullkey);
                    var fn = canCompareFieldWithField || config.settings.canCompareFieldWithField;
                    if (fn) canUse = canUse && fn(leftFieldFullkey, leftFieldConfig, rightFieldFullkey, rightFieldConfig, operator);
                    if (!canUse) delete list[rightFieldKey];
                  }
                }
                return keys$8(list).length;
              }
              _filter(fields, parentFieldPath || []);
              return fields;
            }
          }, {
            key: "buildOptions",
            value: function buildOptions(parentFieldPath, config, fields) {
              var _this2 = this;
              var path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
              var optGroupLabel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
              if (!fields) return null;
              var _config$settings2 = config.settings,
                fieldSeparator = _config$settings2.fieldSeparator,
                fieldSeparatorDisplay = _config$settings2.fieldSeparatorDisplay;
              var prefix = path ? path.join(fieldSeparator) + fieldSeparator : "";
              return keys$8(fields).map(function (fieldKey) {
                var field = fields[fieldKey];
                var label = _this2.getFieldLabel(field, fieldKey, config);
                var partsLabels = getFieldPathLabels(fieldKey, config);
                var fullLabel = partsLabels.join(fieldSeparatorDisplay);
                if (fullLabel == label || parentFieldPath) fullLabel = null;
                var altLabel = field.label2;
                var tooltip = field.tooltip;
                var subpath = (path ? path : []).concat(fieldKey);
                if (field.hideForCompare) return undefined;
                if (field.type == "!struct" || field.type == "!group") {
                  return {
                    key: fieldKey,
                    path: prefix + fieldKey,
                    label: label,
                    fullLabel: fullLabel,
                    altLabel: altLabel,
                    tooltip: tooltip,
                    items: _this2.buildOptions(parentFieldPath, config, field.subfields, subpath, label)
                  };
                } else {
                  return {
                    key: fieldKey,
                    path: prefix + fieldKey,
                    label: label,
                    fullLabel: fullLabel,
                    altLabel: altLabel,
                    tooltip: tooltip,
                    grouplabel: optGroupLabel
                  };
                }
              }).filter(function (o) {
                return !!o;
              });
            }
          }, {
            key: "getFieldLabel",
            value: function getFieldLabel(fieldOpts, fieldKey, config) {
              if (!fieldKey) return null;
              var fieldSeparator = config.settings.fieldSeparator;
              var maxLabelsLength = config.settings.maxLabelsLength;
              var fieldParts = Array.isArray(fieldKey) ? fieldKey : fieldKey.split(fieldSeparator);
              var label = fieldOpts.label || last$2(fieldParts);
              label = truncateString(label, maxLabelsLength);
              return label;
            }
          }, {
            key: "render",
            value: function render() {
              var _this$props = this.props,
                config = _this$props.config,
                customProps = _this$props.customProps,
                setValue = _this$props.setValue,
                readonly = _this$props.readonly,
                id = _this$props.id,
                groupId = _this$props.groupId;
              var renderField = config.settings.renderField;
              var renderProps = _objectSpread$7({
                config: config,
                customProps: customProps,
                setField: setValue,
                readonly: readonly,
                items: this.items,
                id: id,
                groupId: groupId
              }, this.meta);
              return renderField(renderProps);
            }
          }]);
          return ValueField;
        }(reactExports.Component);
        ValueField.propTypes = {
          id: PropTypes.string,
          groupId: PropTypes.string,
          setValue: PropTypes.func.isRequired,
          config: PropTypes.object.isRequired,
          field: PropTypes.string.isRequired,
          value: PropTypes.string,
          operator: PropTypes.string,
          customProps: PropTypes.object,
          readonly: PropTypes.bool,
          parentField: PropTypes.string,
          fieldDefinition: PropTypes.object,
          isFuncArg: PropTypes.bool
        };
        function ownKeys$6(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$6(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$6(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        function _createSuper$2(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct$2() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var clone = Utils$1.clone;
        var _Utils$ConfigUtils = Utils$1.ConfigUtils,
          getFieldConfig = _Utils$ConfigUtils.getFieldConfig,
          getFuncConfig$1 = _Utils$ConfigUtils.getFuncConfig;
        var _Utils$RuleUtils = Utils$1.RuleUtils,
          getFieldPath = _Utils$RuleUtils.getFieldPath,
          getFuncPathLabels = _Utils$RuleUtils.getFuncPathLabels,
          getWidgetForFieldOp = _Utils$RuleUtils.getWidgetForFieldOp;

        //tip: this.props.value - right value, this.props.field - left value
        var FuncSelect = /*#__PURE__*/function (_Component) {
          _inherits$b(FuncSelect, _Component);
          var _super = _createSuper$2(FuncSelect);
          function FuncSelect(props) {
            var _this;
            _classCallCheck$b(this, FuncSelect);
            _this = _super.call(this, props);
            useOnPropsChanged(_assertThisInitialized$1(_this));
            _this.onPropsChanged(props);
            return _this;
          }
          _createClass$9(FuncSelect, [{
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {
              var prevProps = this.props;
              var keysForItems = ["config", "field", "operator", "isFuncArg"];
              var keysForMeta = ["config", "field", "value"];
              var needUpdateItems = !this.items || keysForItems.map(function (k) {
                return nextProps[k] !== prevProps[k];
              }).filter(function (ch) {
                return ch;
              }).length > 0;
              var needUpdateMeta = !this.meta || keysForMeta.map(function (k) {
                return nextProps[k] !== prevProps[k];
              }).filter(function (ch) {
                return ch;
              }).length > 0;
              if (needUpdateMeta) {
                this.meta = this.getMeta(nextProps);
              }
              if (needUpdateItems) {
                this.items = this.getItems(nextProps);
              }
            }
          }, {
            key: "getItems",
            value: function getItems(_ref) {
              var config = _ref.config,
                field = _ref.field,
                operator = _ref.operator,
                parentFuncs = _ref.parentFuncs,
                fieldDefinition = _ref.fieldDefinition,
                isFuncArg = _ref.isFuncArg;
              var canUseFuncForField = config.settings.canUseFuncForField;
              var filteredFuncs = this.filterFuncs(config, config.funcs, field, operator, canUseFuncForField, parentFuncs, isFuncArg, fieldDefinition);
              var items = this.buildOptions(config, filteredFuncs);
              return items;
            }
          }, {
            key: "getMeta",
            value: function getMeta(_ref2) {
              var config = _ref2.config,
                field = _ref2.field,
                value = _ref2.value;
              var _config$settings = config.settings,
                funcPlaceholder = _config$settings.funcPlaceholder,
                fieldSeparatorDisplay = _config$settings.fieldSeparatorDisplay;
              var selectedFuncKey = value;
              var isFuncSelected = !!value;
              var leftFieldConfig = getFieldConfig(config, field);
              var leftFieldWidgetField = leftFieldConfig.widgets.field;
              leftFieldWidgetField && leftFieldWidgetField.widgetProps || {};
              var placeholder = !isFuncSelected ? funcPlaceholder : null;
              var currFunc = isFuncSelected ? getFuncConfig$1(config, selectedFuncKey) : null;
              var selectedOpts = currFunc || {};
              var selectedKeys = getFieldPath(selectedFuncKey, config);
              var selectedPath = getFieldPath(selectedFuncKey, config, true);
              var selectedLabel = this.getFuncLabel(currFunc, selectedFuncKey, config);
              var partsLabels = getFuncPathLabels(selectedFuncKey, config);
              var selectedFullLabel = partsLabels ? partsLabels.join(fieldSeparatorDisplay) : null;
              if (selectedFullLabel == selectedLabel) selectedFullLabel = null;
              return {
                placeholder: placeholder,
                selectedKey: selectedFuncKey,
                selectedKeys: selectedKeys,
                selectedPath: selectedPath,
                selectedLabel: selectedLabel,
                selectedOpts: selectedOpts,
                selectedFullLabel: selectedFullLabel
              };
            }
          }, {
            key: "filterFuncs",
            value: function filterFuncs(config, funcs, leftFieldFullkey, operator, canUseFuncForField, parentFuncs, isFuncArg, fieldDefinition) {
              funcs = clone(funcs);
              var fieldSeparator = config.settings.fieldSeparator;
              var leftFieldConfig = getFieldConfig(config, leftFieldFullkey);
              var expectedType;
              var targetDefinition = leftFieldConfig;
              var widget = getWidgetForFieldOp(config, leftFieldFullkey, operator, "value");
              if (isFuncArg && fieldDefinition) {
                targetDefinition = fieldDefinition;
                expectedType = fieldDefinition.type;
              } else if (widget) {
                var widgetConfig = config.widgets[widget];
                var widgetType = widgetConfig.type;
                //expectedType = leftFieldConfig.type;
                expectedType = widgetType;
              } else {
                expectedType = leftFieldConfig.type;
              }
              function _filter(list, path) {
                for (var funcKey in list) {
                  var subfields = list[funcKey].subfields;
                  var subpath = (path ? path : []).concat(funcKey);
                  var funcFullkey = subpath.join(fieldSeparator);
                  var funcConfig = getFuncConfig$1(config, funcFullkey);
                  if (funcConfig.type == "!struct") {
                    if (_filter(subfields, subpath) == 0) delete list[funcKey];
                  } else {
                    var canUse = funcConfig.returnType == expectedType;
                    if (targetDefinition.funcs) canUse = canUse && targetDefinition.funcs.includes(funcFullkey);
                    if (canUseFuncForField) canUse = canUse && canUseFuncForField(leftFieldFullkey, leftFieldConfig, funcFullkey, funcConfig, operator);
                    // don't use func in func (can be configurable, but usually users don't need this)
                    if (!funcConfig.allowSelfNesting && parentFuncs && parentFuncs.map(function (_ref3) {
                      var _ref4 = _slicedToArray$1(_ref3, 2),
                        func = _ref4[0];
                      _ref4[1];
                      return func;
                    }).includes(funcFullkey)) canUse = false;
                    if (!canUse) delete list[funcKey];
                  }
                }
                return keys$8(list).length;
              }
              _filter(funcs, []);
              return funcs;
            }
          }, {
            key: "buildOptions",
            value: function buildOptions(config, funcs) {
              var _this2 = this;
              var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
              var optGroupLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
              if (!funcs) return null;
              var _config$settings2 = config.settings,
                fieldSeparator = _config$settings2.fieldSeparator,
                fieldSeparatorDisplay = _config$settings2.fieldSeparatorDisplay;
              var prefix = path ? path.join(fieldSeparator) + fieldSeparator : "";
              return keys$8(funcs).map(function (funcKey) {
                var func = funcs[funcKey];
                var label = _this2.getFuncLabel(func, funcKey, config);
                var partsLabels = getFuncPathLabels(funcKey, config);
                var fullLabel = partsLabels.join(fieldSeparatorDisplay);
                if (fullLabel == label) fullLabel = null;
                var tooltip = func.tooltip;
                var subpath = (path ? path : []).concat(funcKey);
                if (func.type == "!struct") {
                  return {
                    key: funcKey,
                    path: prefix + funcKey,
                    label: label,
                    fullLabel: fullLabel,
                    tooltip: tooltip,
                    items: _this2.buildOptions(config, func.subfields, subpath, label)
                  };
                } else {
                  return {
                    key: funcKey,
                    path: prefix + funcKey,
                    label: label,
                    fullLabel: fullLabel,
                    tooltip: tooltip,
                    grouplabel: optGroupLabel
                  };
                }
              });
            }
          }, {
            key: "getFuncLabel",
            value: function getFuncLabel(funcOpts, funcKey, config) {
              if (!funcKey) return null;
              var fieldSeparator = config.settings.fieldSeparator;
              var maxLabelsLength = config.settings.maxLabelsLength;
              var funcParts = Array.isArray(funcKey) ? funcKey : funcKey.split(fieldSeparator);
              var label = funcOpts.label || last$2(funcParts);
              label = truncateString(label, maxLabelsLength);
              return label;
            }
          }, {
            key: "render",
            value: function render() {
              var _this$props = this.props,
                config = _this$props.config,
                customProps = _this$props.customProps,
                setValue = _this$props.setValue,
                readonly = _this$props.readonly,
                id = _this$props.id,
                groupId = _this$props.groupId;
              var renderFunc = config.settings.renderFunc;
              var renderProps = _objectSpread$6({
                config: config,
                customProps: customProps,
                readonly: readonly,
                setField: setValue,
                items: this.items,
                id: id,
                groupId: groupId
              }, this.meta);
              return renderFunc(renderProps);
            }
          }]);
          return FuncSelect;
        }(reactExports.Component);
        FuncSelect.propTypes = {
          id: PropTypes.string,
          groupId: PropTypes.string,
          config: PropTypes.object.isRequired,
          field: PropTypes.string.isRequired,
          operator: PropTypes.string,
          customProps: PropTypes.object,
          value: PropTypes.string,
          setValue: PropTypes.func.isRequired,
          readonly: PropTypes.bool,
          parentFuncs: PropTypes.array,
          fieldDefinition: PropTypes.object,
          isFuncArg: PropTypes.bool
        };
        function _createSuper$1(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct$1() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var getFuncConfig = Utils$1.ConfigUtils.getFuncConfig;
        var _Utils$FuncUtils = Utils$1.FuncUtils,
          setFunc = _Utils$FuncUtils.setFunc,
          setArgValue = _Utils$FuncUtils.setArgValue,
          setArgValueSrc = _Utils$FuncUtils.setArgValueSrc;
        var FuncWidget$1 = /*#__PURE__*/function (_Component) {
          _inherits$b(FuncWidget, _Component);
          var _super = _createSuper$1(FuncWidget);
          function FuncWidget(props) {
            var _this;
            _classCallCheck$b(this, FuncWidget);
            _this = _super.call(this, props);
            _this.setFunc = function (funcKey) {
              _this.props.setValue(setFunc(_this.props.value, funcKey, _this.props.config));
            };
            _this.setArgValue = function (argKey, argVal) {
              var config = _this.props.config;
              var funcDefinition = _this.meta.funcDefinition;
              var args = funcDefinition.args;
              var argDefinition = args[argKey];
              _this.props.setValue(setArgValue(_this.props.value, argKey, argVal, argDefinition, config));
            };
            _this.setArgValueSrc = function (argKey, argValSrc) {
              var config = _this.props.config;
              var funcDefinition = _this.meta.funcDefinition;
              var args = funcDefinition.args;
              var argDefinition = args[argKey];
              _this.props.setValue(setArgValueSrc(_this.props.value, argKey, argValSrc, argDefinition, config));
            };
            _this.renderFuncSelect = function () {
              var _this$props = _this.props,
                config = _this$props.config,
                field = _this$props.field,
                operator = _this$props.operator,
                customProps = _this$props.customProps,
                value = _this$props.value,
                readonly = _this$props.readonly,
                parentFuncs = _this$props.parentFuncs,
                id = _this$props.id,
                groupId = _this$props.groupId,
                isFuncArg = _this$props.isFuncArg,
                fieldDefinition = _this$props.fieldDefinition;
              var funcKey = value ? value.get("func") : null;
              var selectProps = {
                value: funcKey,
                setValue: _this.setFunc,
                config: config,
                field: field,
                operator: operator,
                customProps: customProps,
                readonly: readonly,
                parentFuncs: parentFuncs,
                isFuncArg: isFuncArg,
                fieldDefinition: fieldDefinition,
                id: id,
                groupId: groupId
              };
              var _config$settings = config.settings,
                showLabels = _config$settings.showLabels,
                funcLabel = _config$settings.funcLabel;
              var widgetLabel = showLabels ? /*#__PURE__*/React.createElement("label", {
                className: "rule--label"
              }, funcLabel) : null;
              return /*#__PURE__*/React.createElement(Col, {
                key: "func",
                className: "rule--func"
              }, widgetLabel, /*#__PURE__*/React.createElement(FuncSelect, selectProps));
            };
            _this.renderArgLabel = function (argKey, argDefinition) {
              var valueSources = argDefinition.valueSources,
                type = argDefinition.type,
                showPrefix = argDefinition.showPrefix,
                label = argDefinition.label;
              var config = _this.props.config;
              var isConst = valueSources && valueSources.length == 1 && valueSources[0] == "const";
              var forceShow = !config.settings.showLabels && (type == "boolean" || isConst) && showPrefix;
              if (!forceShow) return null;
              return /*#__PURE__*/React.createElement(Col, {
                className: "rule--func--arg-label"
              }, label || argKey);
            };
            _this.renderArgLabelSep = function (argKey, argDefinition) {
              var valueSources = argDefinition.valueSources,
                type = argDefinition.type,
                showPrefix = argDefinition.showPrefix;
              var config = _this.props.config;
              var isConst = valueSources && valueSources.length == 1 && valueSources[0] == "const";
              var forceShow = !config.settings.showLabels && (type == "boolean" || isConst) && showPrefix;
              if (!forceShow) return null;
              return /*#__PURE__*/React.createElement(Col, {
                className: "rule--func--arg-label-sep"
              }, ":");
            };
            _this.renderArgVal = function (funcKey, argKey, argDefinition) {
              var _this$props2 = _this.props,
                config = _this$props2.config,
                field = _this$props2.field;
              _this$props2.operator;
              var value = _this$props2.value,
                readonly = _this$props2.readonly,
                parentFuncs = _this$props2.parentFuncs,
                id = _this$props2.id,
                groupId = _this$props2.groupId;
              var arg = value ? value.getIn(["args", argKey]) : null;
              var argVal = arg ? arg.get("value") : undefined;
              var defaultValueSource = argDefinition.valueSources.length == 1 ? argDefinition.valueSources[0] : undefined;
              var argValSrc = arg ? arg.get("valueSrc") || defaultValueSource || "value" : defaultValueSource;
              var widgetProps = {
                config: config,
                fieldFunc: funcKey,
                fieldArg: argKey,
                leftField: field,
                operator: null,
                value: argVal,
                valueSrc: argValSrc,
                setValue: _this.setArgValue,
                setValueSrc: _this.setArgValueSrc,
                funcKey: funcKey,
                argKey: argKey,
                argDefinition: argDefinition,
                readonly: readonly,
                parentFuncs: parentFuncs,
                id: id,
                groupId: groupId
              };
              //tip: value & valueSrc will be converted to Immutable.List at <Widget>

              return /*#__PURE__*/React.createElement(Col, {
                className: "rule--func--arg-value"
              }, /*#__PURE__*/React.createElement(ArgWidget, widgetProps));
            };
            _this.renderArgSep = function (argKey, argDefinition, argIndex, _ref) {
              var renderSeps = _ref.renderSeps;
              if (!argIndex) return null;
              return /*#__PURE__*/React.createElement(Col, {
                className: "rule--func--arg-sep"
              }, renderSeps ? renderSeps[argIndex - 1] : ", ");
            };
            _this.renderBracketBefore = function (_ref2) {
              var renderBrackets = _ref2.renderBrackets;
              return /*#__PURE__*/React.createElement(Col, {
                key: "before_args",
                className: "rule--func--bracket-before"
              }, renderBrackets ? renderBrackets[0] : "(");
            };
            _this.renderBracketAfter = function (_ref3) {
              var renderBrackets = _ref3.renderBrackets;
              return /*#__PURE__*/React.createElement(Col, {
                key: "after_args",
                className: "rule--func--bracket-after"
              }, renderBrackets ? renderBrackets[1] : ")");
            };
            _this.renderFuncArgs = function () {
              var _this$meta = _this.meta,
                funcDefinition = _this$meta.funcDefinition,
                funcKey = _this$meta.funcKey;
              if (!funcKey) return null;
              var args = funcDefinition.args;
              if (!args) return null;
              return /*#__PURE__*/React.createElement(React.Fragment, null, _this.renderBracketBefore(funcDefinition), /*#__PURE__*/React.createElement(Col, {
                key: "args",
                className: "rule--func--args"
              }, Object.keys(args).map(function (argKey, argIndex) {
                return /*#__PURE__*/React.createElement(Col, {
                  key: "arg-".concat(argKey, "-").concat(argIndex),
                  className: "rule--func--arg"
                }, _this.renderArgSep(argKey, args[argKey], argIndex, funcDefinition), _this.renderArgLabel(argKey, args[argKey]), _this.renderArgLabelSep(argKey, args[argKey]), _this.renderArgVal(funcKey, argKey, args[argKey]));
              })), _this.renderBracketAfter(funcDefinition));
            };
            useOnPropsChanged(_assertThisInitialized$1(_this));
            _this.onPropsChanged(props);
            return _this;
          }
          _createClass$9(FuncWidget, [{
            key: "onPropsChanged",
            value: function onPropsChanged(nextProps) {
              var prevProps = this.props;
              var keysForMeta = ["config", "field", "operator", "value"];
              var needUpdateMeta = !this.meta || keysForMeta.map(function (k) {
                return nextProps[k] !== prevProps[k];
              }).filter(function (ch) {
                return ch;
              }).length > 0;
              if (needUpdateMeta) {
                this.meta = this.getMeta(nextProps);
              }
            }
          }, {
            key: "getMeta",
            value: function getMeta(_ref4) {
              var config = _ref4.config;
              _ref4.field;
              _ref4.operator;
              var value = _ref4.value;
              var funcKey = value ? value.get("func") : null;
              var funcDefinition = funcKey ? getFuncConfig(config, funcKey) : null;
              return {
                funcDefinition: funcDefinition,
                funcKey: funcKey
              };
            }
          }, {
            key: "render",
            value: function render() {
              return /*#__PURE__*/React.createElement(Col, {
                className: "rule--func--wrapper"
              }, this.renderFuncSelect(), this.renderFuncArgs());
            }
          }]);
          return FuncWidget;
        }(reactExports.Component);
        FuncWidget$1.propTypes = {
          id: PropTypes.string,
          groupId: PropTypes.string,
          config: PropTypes.object.isRequired,
          field: PropTypes.string.isRequired,
          operator: PropTypes.string,
          customProps: PropTypes.object,
          value: PropTypes.object,
          //instanceOf(Immutable.Map) //with keys 'func' and `args`
          setValue: PropTypes.func.isRequired,
          readonly: PropTypes.bool,
          parentFuncs: PropTypes.array,
          fieldDefinition: PropTypes.object,
          isFuncArg: PropTypes.bool
        };
        var ArgWidget = /*#__PURE__*/function (_PureComponent) {
          _inherits$b(ArgWidget, _PureComponent);
          var _super2 = _createSuper$1(ArgWidget);
          function ArgWidget() {
            var _this2;
            _classCallCheck$b(this, ArgWidget);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            _this2 = _super2.call.apply(_super2, [this].concat(args));
            _this2.setValue = function (_delta, value, _widgetType) {
              var _this2$props = _this2.props,
                setValue = _this2$props.setValue,
                argKey = _this2$props.argKey;
              setValue(argKey, value);
            };
            _this2.setValueSrc = function (_delta, valueSrc, _widgetType) {
              var _this2$props2 = _this2.props,
                setValueSrc = _this2$props2.setValueSrc,
                argKey = _this2$props2.argKey;
              setValueSrc(argKey, valueSrc);
            };
            return _this2;
          }
          _createClass$9(ArgWidget, [{
            key: "render",
            value: function render() {
              var _this$props3 = this.props,
                funcKey = _this$props3.funcKey,
                argKey = _this$props3.argKey,
                parentFuncs = _this$props3.parentFuncs;
              return /*#__PURE__*/React.createElement(Widget, _extends$h({}, this.props, {
                setValue: this.setValue,
                setValueSrc: this.setValueSrc,
                isFuncArg: true,
                parentFuncs: [].concat(_toConsumableArray(parentFuncs || []), [[funcKey, argKey]])
              }));
            }
          }]);
          return ArgWidget;
        }(reactExports.PureComponent);
        ArgWidget.propTypes = {
          funcKey: PropTypes.string.isRequired,
          argKey: PropTypes.string.isRequired,
          setValue: PropTypes.func.isRequired,
          setValueSrc: PropTypes.func.isRequired,
          readonly: PropTypes.bool,
          parentFuncs: PropTypes.array,
          id: PropTypes.string,
          groupId: PropTypes.string
        };
        var uuid = Utils$1.uuid;
        const VanillaBoolean = function (props) {
          var value = props.value,
            setValue = props.setValue;
          props.config;
          var labelYes = props.labelYes,
            labelNo = props.labelNo,
            readonly = props.readonly,
            _props$customProps = props.customProps,
            customProps = _props$customProps === void 0 ? {} : _props$customProps;
          var customRadioYesProps = customProps.radioYes || {};
          var customRadioNoProps = customProps.radioNo || {};
          var onRadioChange = function onRadioChange(e) {
            return setValue(e.target.value == "true");
          };
          var id = uuid(),
            id2 = uuid();

          // return <>
          //     <input key={id}  type="checkbox" id={id} checked={!!value} disabled={readonly} onChange={onCheckboxChange} />
          //     <label style={{display: "inline"}} key={id+"label"}  htmlFor={id}>{value ? labelYes : labelNo}</label>
          // </>;

          return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("input", _extends$h({
            key: id,
            type: "radio",
            id: id,
            value: true,
            checked: !!value,
            disabled: readonly,
            onChange: onRadioChange
          }, customRadioYesProps)), /*#__PURE__*/React.createElement("label", {
            style: {
              display: "inline"
            },
            key: id + "label",
            htmlFor: id
          }, labelYes), /*#__PURE__*/React.createElement("input", _extends$h({
            key: id2,
            type: "radio",
            id: id2,
            value: false,
            checked: !value,
            disabled: readonly,
            onChange: onRadioChange
          }, customRadioNoProps)), /*#__PURE__*/React.createElement("label", {
            style: {
              display: "inline"
            },
            key: id2 + "label",
            htmlFor: id2
          }, labelNo));
        };
        const VanillaText = function (props) {
          var value = props.value,
            setValue = props.setValue;
          props.config;
          var readonly = props.readonly,
            placeholder = props.placeholder,
            maxLength = props.maxLength,
            customProps = props.customProps;
          var onChange = function onChange(e) {
            var val = e.target.value;
            if (val === "") val = undefined; // don't allow empty value
            setValue(val);
          };
          var textValue = value || "";
          return /*#__PURE__*/React.createElement("input", _extends$h({
            type: "text",
            value: textValue,
            placeholder: placeholder,
            disabled: readonly,
            onChange: onChange,
            maxLength: maxLength
          }, customProps));
        };
        const VanillaTextArea = function (props) {
          var value = props.value,
            setValue = props.setValue;
          props.config;
          var readonly = props.readonly,
            placeholder = props.placeholder,
            maxLength = props.maxLength;
          props.maxRows;
          var fullWidth = props.fullWidth,
            customProps = props.customProps;
          var onChange = function onChange(e) {
            var val = e.target.value;
            if (val === "") val = undefined; // don't allow empty value
            setValue(val);
          };
          var textValue = value || "";
          return /*#__PURE__*/React.createElement("textarea", _extends$h({
            value: textValue,
            placeholder: placeholder,
            disabled: readonly,
            onChange: onChange,
            maxLength: maxLength,
            style: {
              width: fullWidth ? "100%" : undefined
            }
          }, customProps));
        };
        Utils$1.moment;
        const VanillaDate = function (props) {
          var value = props.value,
            setValue = props.setValue;
          props.config;
          props.valueFormat;
          var readonly = props.readonly,
            customProps = props.customProps;
          var onChange = function onChange(e) {
            var value = e.target.value;
            if (value == "") value = undefined;
            setValue(value);
          };
          return /*#__PURE__*/React.createElement("input", _extends$h({
            type: "date",
            value: value || "",
            disabled: readonly,
            onChange: onChange
          }, customProps));
        };
        const VanillaTime = function (props) {
          var value = props.value,
            setValue = props.setValue;
          props.config;
          props.valueFormat;
          props.use12Hours;
          var readonly = props.readonly,
            customProps = props.customProps;
          var onChange = function onChange(e) {
            var value = e.target.value;
            if (value == "") value = undefined;
            setValue(value);
          };
          return /*#__PURE__*/React.createElement("input", _extends$h({
            type: "time",
            value: value || "",
            disabled: readonly,
            onChange: onChange
          }, customProps));
        };
        var moment$1 = Utils$1.moment;
        const VanillaDateTime = function (props) {
          var value = props.value,
            setValue = props.setValue;
          props.config;
          var valueFormat = props.valueFormat;
          props.use12Hours;
          var readonly = props.readonly,
            customProps = props.customProps;
          var onChange = function onChange(e) {
            var value = e.target.value;
            if (value == "") value = undefined;else value = moment$1(new Date(value)).format(valueFormat);
            setValue(value);
          };
          var dtValue = value;
          if (!value) dtValue = "";else dtValue = moment$1(value).format("YYYY-MM-DDTHH:mm");
          return /*#__PURE__*/React.createElement("input", _extends$h({
            type: "datetime-local",
            value: dtValue,
            disabled: readonly,
            onChange: onChange
          }, customProps));
        };
        var mapListValues$4 = Utils$1.ListUtils.mapListValues;
        const VanillaMultiSelect = function (_ref) {
          var listValues = _ref.listValues,
            value = _ref.value,
            setValue = _ref.setValue;
          _ref.allowCustomValues;
          var readonly = _ref.readonly,
            customProps = _ref.customProps;
          var renderOptions = function renderOptions() {
            return mapListValues$4(listValues, function (_ref2) {
              var title = _ref2.title,
                value = _ref2.value;
              return /*#__PURE__*/React.createElement("option", {
                key: value,
                value: value
              }, title);
            });
          };
          var getMultiSelectValues = function getMultiSelectValues(multiselect) {
            var values = [];
            var options = multiselect.options;
            for (var i = 0; i < options.length; i++) {
              var opt = options[i];
              if (opt.selected) {
                values.push(opt.value);
              }
            }
            if (!values.length) values = undefined; //not allow []
            return values;
          };
          var onChange = function onChange(e) {
            return setValue(getMultiSelectValues(e.target));
          };
          return /*#__PURE__*/React.createElement("select", _extends$h({
            multiple: true,
            onChange: onChange,
            value: value,
            disabled: readonly
          }, omit$1(customProps, ["showSearch", "input", "showCheckboxes"])), renderOptions());
        };
        var mapListValues$3 = Utils$1.ListUtils.mapListValues;
        const VanillaSelect = function (_ref) {
          var listValues = _ref.listValues,
            value = _ref.value,
            setValue = _ref.setValue;
          _ref.allowCustomValues;
          var readonly = _ref.readonly,
            customProps = _ref.customProps;
          var renderOptions = function renderOptions() {
            return mapListValues$3(listValues, function (_ref2) {
              var title = _ref2.title,
                value = _ref2.value;
              return /*#__PURE__*/React.createElement("option", {
                key: value,
                value: value
              }, title);
            });
          };
          var onChange = function onChange(e) {
            return setValue(e.target.value);
          };
          var hasValue = value != null;
          return /*#__PURE__*/React.createElement("select", _extends$h({
            onChange: onChange,
            value: hasValue ? value : "",
            disabled: readonly
          }, omit$1(customProps, ["showSearch", "input"])), !hasValue && /*#__PURE__*/React.createElement("option", {
            disabled: true,
            value: ""
          }), renderOptions());
        };
        const VanillaNumber = function (props) {
          var value = props.value,
            setValue = props.setValue;
          props.config;
          var readonly = props.readonly,
            min = props.min,
            max = props.max,
            step = props.step,
            placeholder = props.placeholder,
            customProps = props.customProps;
          var onChange = function onChange(e) {
            var val = e.target.value;
            if (val === "" || val === null) val = undefined;else val = Number(val);
            setValue(val);
          };
          var numberValue = value == undefined ? "" : value;
          return /*#__PURE__*/React.createElement("input", _extends$h({
            type: "number",
            value: numberValue,
            placeholder: placeholder,
            disabled: readonly,
            min: min,
            max: max,
            step: step,
            onChange: onChange
          }, customProps));
        };
        const VanillaSlider = function (props) {
          var value = props.value,
            setValue = props.setValue;
          props.config;
          var readonly = props.readonly,
            min = props.min,
            max = props.max,
            step = props.step,
            placeholder = props.placeholder,
            _props$customProps = props.customProps,
            customProps = _props$customProps === void 0 ? {} : _props$customProps;
          var customInputProps = customProps.input || {};
          var customSliderProps = customProps.slider || customProps;
          var onChange = function onChange(e) {
            var val = e.target.value;
            if (val === "" || val === null) val = undefined;else val = Number(val);
            setValue(val);
          };
          var numberValue = value == undefined ? "" : value;
          return /*#__PURE__*/React.createElement("div", {
            style: {
              display: "inline-flex"
            }
          }, /*#__PURE__*/React.createElement("input", _extends$h({
            key: "number",
            type: "number",
            value: numberValue,
            placeholder: placeholder,
            disabled: readonly,
            min: min,
            max: max,
            step: step,
            onChange: onChange
          }, customInputProps)), /*#__PURE__*/React.createElement("input", _extends$h({
            key: "range",
            type: "range",
            value: numberValue,
            disabled: readonly,
            min: min,
            max: max,
            step: step,
            onChange: onChange
          }, customSliderProps)));
        };
        const VanillaFieldSelect$1 = function (_ref) {
          var items = _ref.items,
            setField = _ref.setField,
            selectedKey = _ref.selectedKey,
            readonly = _ref.readonly;
          var renderOptions = function renderOptions(fields) {
            return fields.map(function (field) {
              var items = field.items,
                path = field.path,
                label = field.label,
                disabled = field.disabled;
              if (items) {
                return /*#__PURE__*/React.createElement("optgroup", {
                  disabled: disabled,
                  key: path,
                  label: label
                }, renderOptions(items));
              } else {
                return /*#__PURE__*/React.createElement("option", {
                  disabled: disabled,
                  key: path,
                  value: path
                }, label);
              }
            });
          };
          var onChange = function onChange(e) {
            return setField(e.target.value);
          };
          var hasValue = selectedKey != null;
          return /*#__PURE__*/React.createElement("select", {
            onChange: onChange,
            value: hasValue ? selectedKey : "",
            disabled: readonly
          }, !hasValue && /*#__PURE__*/React.createElement("option", {
            disabled: true,
            value: ""
          }), renderOptions(items));
        };
        const VanillaConjs$1 = function (_ref) {
          var id = _ref.id,
            not = _ref.not,
            setNot = _ref.setNot,
            conjunctionOptions = _ref.conjunctionOptions,
            setConjunction = _ref.setConjunction,
            disabled = _ref.disabled,
            readonly = _ref.readonly,
            config = _ref.config,
            showNot = _ref.showNot,
            notLabel = _ref.notLabel;
          var conjsCount = Object.keys(conjunctionOptions).length;
          var lessThenTwo = disabled;
          var forceShowConj = config.settings.forceShowConj;
          var showConj = forceShowConj || conjsCount > 1 && !lessThenTwo;
          var renderOptions = function renderOptions() {
            return Object.keys(conjunctionOptions).map(function (key) {
              var _conjunctionOptions$k = conjunctionOptions[key],
                id = _conjunctionOptions$k.id,
                name = _conjunctionOptions$k.name,
                label = _conjunctionOptions$k.label,
                checked = _conjunctionOptions$k.checked;
              var postfix = setConjunction.isDummyFn ? "__dummy" : "";
              if ((readonly || disabled) && !checked) return null;
              return [/*#__PURE__*/React.createElement("input", {
                key: id + postfix,
                type: "radio",
                id: id + postfix,
                name: name + postfix,
                checked: checked,
                disabled: readonly || disabled,
                value: key,
                onChange: onChange
              }), /*#__PURE__*/React.createElement("label", {
                key: id + postfix + "label",
                htmlFor: id + postfix
              }, label)];
            });
          };
          var renderNot = function renderNot() {
            var postfix = "not";
            return [/*#__PURE__*/React.createElement("input", {
              key: id + postfix,
              type: "checkbox",
              id: id + postfix,
              checked: not,
              disabled: readonly,
              onChange: onNotChange
            }), /*#__PURE__*/React.createElement("label", {
              key: id + postfix + "label",
              htmlFor: id + postfix
            }, notLabel || "NOT")];
          };
          var onChange = function onChange(e) {
            return setConjunction(e.target.value);
          };
          var onNotChange = function onNotChange(e) {
            return setNot(e.target.checked);
          };
          return [showNot && renderNot(), showConj && renderOptions()];
        };
        const VanillaButton$1 = function (_ref) {
          var type = _ref.type,
            label = _ref.label,
            onClick = _ref.onClick,
            readonly = _ref.readonly;
          _ref.config;
          var typeToLabel = {
            "addRuleGroup": "+",
            "addRuleGroupExt": "+",
            "delGroup": "x",
            "delRuleGroup": "x",
            "delRule": "x"
          };
          var btnLabel = label || typeToLabel[type];
          return /*#__PURE__*/React.createElement("button", {
            onClick: onClick,
            type: "button",
            disabled: readonly
          }, btnLabel);
        };
        const VanillaButtonGroup$1 = function (_ref) {
          var children = _ref.children;
          _ref.config;
          return /*#__PURE__*/React.createElement(React.Fragment, null, children);
        };
        const VanillaValueSources$1 = function (_ref) {
          _ref.config;
          var valueSources = _ref.valueSources,
            valueSrc = _ref.valueSrc;
          _ref.title;
          var setValueSrc = _ref.setValueSrc,
            readonly = _ref.readonly;
          var renderOptions = function renderOptions(valueSources) {
            return valueSources.map(function (_ref2) {
              var _ref3 = _slicedToArray$1(_ref2, 2),
                srcKey = _ref3[0],
                info = _ref3[1];
              return /*#__PURE__*/React.createElement("option", {
                key: srcKey,
                value: srcKey
              }, info.label);
            });
          };
          var onChange = function onChange(e) {
            return setValueSrc(e.target.value);
          };
          return /*#__PURE__*/React.createElement("select", {
            onChange: onChange,
            value: valueSrc,
            disabled: readonly
          }, renderOptions(valueSources));
        };
        const VanillaSwitch$1 = function (_ref) {
          var value = _ref.value,
            setValue = _ref.setValue,
            label = _ref.label,
            id = _ref.id;
          _ref.config;
          var type = _ref.type;
          var onChange = function onChange(e) {
            return setValue(e.target.checked);
          };
          var postfix = type;
          return [/*#__PURE__*/React.createElement("input", {
            key: id + postfix,
            type: "checkbox",
            id: id + postfix,
            checked: !!value,
            onChange: onChange
          }), /*#__PURE__*/React.createElement("label", {
            key: id + postfix + "label",
            htmlFor: id + postfix
          }, label)];
        };
        const vanillaConfirm$1 = function (_ref) {
          var onOk = _ref.onOk;
          _ref.okText;
          _ref.cancelText;
          var title = _ref.title;
          if (confirm(title)) {
            onOk();
          }
        };
        var VanillaProvider$1 = function VanillaProvider(_ref) {
          _ref.config;
          var children = _ref.children;
          return children;
        };
        function _createSuper(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf$1(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf$1(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn$b(this, result);
          };
        }
        function _isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        var Proximity = /*#__PURE__*/function (_PureComponent) {
          _inherits$b(Proximity, _PureComponent);
          var _super = _createSuper(Proximity);
          function Proximity() {
            var _this;
            _classCallCheck$b(this, Proximity);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            _this = _super.call.apply(_super, [this].concat(args));
            _this.handleChange = function (value) {
              _this.props.setOption("proximity", parseInt(value));
            };
            return _this;
          }
          _createClass$9(Proximity, [{
            key: "render",
            value: function render() {
              var _this$props = this.props,
                defaults = _this$props.defaults,
                options = _this$props.options,
                config = _this$props.config,
                optionLabel = _this$props.optionLabel,
                optionPlaceholder = _this$props.optionPlaceholder,
                customProps = _this$props.customProps,
                minProximity = _this$props.minProximity,
                maxProximity = _this$props.maxProximity,
                optionTextBefore = _this$props.optionTextBefore,
                readonly = _this$props.readonly;
              var settings = config.settings,
                widgets = config.widgets;
              var defaultProximity = defaults ? defaults.proximity : undefined;
              var showLabels = settings.showLabels;
              var selectedProximity = options.get("proximity", defaultProximity);
              var proxValues = range$1(minProximity, maxProximity + 1).map(function (item) {
                return {
                  title: item,
                  value: item
                };
              });
              var Select = widgets.select.factory;
              return /*#__PURE__*/React.createElement("div", {
                className: "operator--PROXIMITY"
              }, /*#__PURE__*/React.createElement("div", {
                className: "operator--options"
              }, showLabels && /*#__PURE__*/React.createElement("label", {
                className: "rule--label"
              }, optionLabel), !showLabels && optionTextBefore && /*#__PURE__*/React.createElement("div", {
                className: "operator--options--sep"
              }, /*#__PURE__*/React.createElement("span", null, optionTextBefore)), /*#__PURE__*/React.createElement(Select, _extends$h({
                config: config,
                value: selectedProximity,
                listValues: proxValues,
                setValue: this.handleChange,
                readonly: readonly,
                placeholder: optionPlaceholder
              }, customProps))), /*#__PURE__*/React.createElement("div", {
                className: "operator--widgets"
              }, this.props.children));
            }
          }]);
          return Proximity;
        }(reactExports.PureComponent);
        Proximity.propTypes = {
          config: PropTypes.object.isRequired,
          setOption: PropTypes.func.isRequired,
          options: PropTypes.any.isRequired,
          //instanceOf(Immutable.Map)
          minProximity: PropTypes.number,
          maxProximity: PropTypes.number,
          optionPlaceholder: PropTypes.string,
          optionTextBefore: PropTypes.string,
          optionLabel: PropTypes.string,
          customProps: PropTypes.object,
          readonly: PropTypes.bool
          //children
        };

        Proximity.defaultProps = {
          customProps: {},
          minProximity: 2,
          maxProximity: 10,
          optionPlaceholder: "Select words between",
          optionLabel: "Words between",
          optionTextBefore: null
        };
        function ownKeys$5(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$5(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$5(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        var VanillaBooleanWidget = VanillaBoolean,
          VanillaTextWidget = VanillaText,
          VanillaTextAreaWidget = VanillaTextArea,
          VanillaDateWidget = VanillaDate,
          VanillaTimeWidget = VanillaTime,
          VanillaDateTimeWidget = VanillaDateTime,
          VanillaMultiSelectWidget = VanillaMultiSelect,
          VanillaSelectWidget = VanillaSelect,
          VanillaNumberWidget = VanillaNumber,
          VanillaSliderWidget = VanillaSlider,
          VanillaFieldSelect = VanillaFieldSelect$1,
          VanillaConjs = VanillaConjs$1,
          VanillaButton = VanillaButton$1,
          VanillaButtonGroup = VanillaButtonGroup$1,
          VanillaProvider = VanillaProvider$1,
          VanillaValueSources = VanillaValueSources$1,
          vanillaConfirm = vanillaConfirm$1,
          VanillaSwitch = VanillaSwitch$1,
          ValueFieldWidget = ValueField,
          FuncWidget = FuncWidget$1;
        var ProximityOperator = Proximity;

        //----------------------------  conjunctions

        var conjunctions$1 = _objectSpread$5({}, CoreConfig.conjunctions);

        //----------------------------  operators

        var operators$1 = _objectSpread$5(_objectSpread$5({}, CoreConfig.operators), {}, {
          proximity: _objectSpread$5(_objectSpread$5({}, CoreConfig.operators.proximity), {}, {
            options: _objectSpread$5(_objectSpread$5({}, CoreConfig.operators.proximity.options), {}, {
              factory: function factory(props) {
                return /*#__PURE__*/React.createElement(ProximityOperator, props);
              }
            })
          })
        });

        //----------------------------  widgets

        var widgets$2 = {
          text: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.text), {}, {
            factory: function factory(props) {
              return /*#__PURE__*/React.createElement(VanillaTextWidget, props);
            }
          }),
          textarea: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.textarea), {}, {
            factory: function factory(props) {
              return /*#__PURE__*/React.createElement(VanillaTextAreaWidget, props);
            }
          }),
          number: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.number), {}, {
            factory: function factory(props) {
              return /*#__PURE__*/React.createElement(VanillaNumberWidget, props);
            }
          }),
          slider: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.slider), {}, {
            factory: function factory(props) {
              return /*#__PURE__*/React.createElement(VanillaSliderWidget, props);
            }
          }),
          select: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.select), {}, {
            factory: function factory(props) {
              return /*#__PURE__*/React.createElement(VanillaSelectWidget, props);
            }
          }),
          multiselect: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.multiselect), {}, {
            factory: function factory(props) {
              return /*#__PURE__*/React.createElement(VanillaMultiSelectWidget, props);
            }
          }),
          date: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.date), {}, {
            factory: function factory(props) {
              return /*#__PURE__*/React.createElement(VanillaDateWidget, props);
            }
          }),
          time: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.time), {}, {
            factory: function factory(props) {
              return /*#__PURE__*/React.createElement(VanillaTimeWidget, props);
            }
          }),
          datetime: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.datetime), {}, {
            factory: function factory(props) {
              return /*#__PURE__*/React.createElement(VanillaDateTimeWidget, props);
            }
          }),
          "boolean": _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets["boolean"]), {}, {
            factory: function factory(props) {
              return /*#__PURE__*/React.createElement(VanillaBooleanWidget, props);
            }
          }),
          field: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.field), {}, {
            factory: function factory(props) {
              return /*#__PURE__*/React.createElement(ValueFieldWidget, props);
            },
            customProps: {
              showSearch: true
            }
          }),
          func: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.func), {}, {
            factory: function factory(props) {
              return /*#__PURE__*/React.createElement(FuncWidget, props);
            },
            customProps: {
              //showSearch: true
            }
          }),
          case_value: _objectSpread$5(_objectSpread$5({}, CoreConfig.widgets.case_value), {}, {
            factory: function factory(_ref) {
              var value = _ref.value,
                setValue = _ref.setValue;
              return /*#__PURE__*/React.createElement("input", {
                type: "text",
                value: value || "",
                onChange: function onChange(e) {
                  return setValue(e.target.value);
                }
              });
            }
          })
        };

        //----------------------------  types

        var types$2 = _objectSpread$5(_objectSpread$5({}, CoreConfig.types), {}, {
          select: _objectSpread$5(_objectSpread$5({}, CoreConfig.types.select), {}, {
            widgets: _objectSpread$5(_objectSpread$5({}, CoreConfig.types.select.widgets), {}, {
              select: _objectSpread$5(_objectSpread$5({}, CoreConfig.types.select.widgets.select), {}, {
                widgetProps: {
                  customProps: {
                    showSearch: true
                  }
                }
              })
            })
          })
        });

        //----------------------------  settings

        var settings$2 = _objectSpread$5(_objectSpread$5({}, CoreConfig.settings), {}, {
          renderField: function renderField(props) {
            return /*#__PURE__*/React.createElement(VanillaFieldSelect, props);
          },
          renderOperator: function renderOperator(props) {
            return /*#__PURE__*/React.createElement(VanillaFieldSelect, props);
          },
          renderFunc: function renderFunc(props) {
            return /*#__PURE__*/React.createElement(VanillaFieldSelect, props);
          },
          renderConjs: function renderConjs(props) {
            return /*#__PURE__*/React.createElement(VanillaConjs, props);
          },
          renderSwitch: function renderSwitch(props) {
            return /*#__PURE__*/React.createElement(VanillaSwitch, props);
          },
          renderButton: function renderButton(props) {
            return /*#__PURE__*/React.createElement(VanillaButton, props);
          },
          renderButtonGroup: function renderButtonGroup(props) {
            return /*#__PURE__*/React.createElement(VanillaButtonGroup, props);
          },
          renderProvider: function renderProvider(props) {
            return /*#__PURE__*/React.createElement(VanillaProvider, props);
          },
          renderValueSources: function renderValueSources(props) {
            return /*#__PURE__*/React.createElement(VanillaValueSources, props);
          },
          renderConfirm: vanillaConfirm,
          renderSwitchPrefix: function renderSwitchPrefix() {
            return /*#__PURE__*/React.createElement(React.Fragment, null, "Conditions");
          },
          customFieldSelectProps: {
            showSearch: true
          },
          defaultSliderWidth: "200px",
          defaultSelectWidth: "200px",
          defaultSearchWidth: "100px",
          defaultMaxRows: 5,
          renderSize: "small",
          maxLabelsLength: 100,
          showLock: false,
          showNot: true,
          forceShowConj: false,
          groupActionsPosition: "topRight" // oneOf [topLeft, topCenter, topRight, bottomLeft, bottomCenter, bottomRight]
        });

        //----------------------------

        const BasicConfig = {
          conjunctions: conjunctions$1,
          operators: operators$1,
          widgets: widgets$2,
          types: types$2,
          settings: settings$2
        };
        var root = _root;

        /**
         * Gets the timestamp of the number of milliseconds that have elapsed since
         * the Unix epoch (1 January 1970 00:00:00 UTC).
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Date
         * @returns {number} Returns the timestamp.
         * @example
         *
         * _.defer(function(stamp) {
         *   console.log(_.now() - stamp);
         * }, _.now());
         * // => Logs the number of milliseconds it took for the deferred invocation.
         */
        var now$1 = function () {
          return root.Date.now();
        };
        var now_1 = now$1;
        var isObject = isObject_1,
          now = now_1,
          toNumber = toNumber_1;

        /** Error message constants. */
        var FUNC_ERROR_TEXT = 'Expected a function';

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeMax = Math.max,
          nativeMin = Math.min;

        /**
         * Creates a debounced function that delays invoking `func` until after `wait`
         * milliseconds have elapsed since the last time the debounced function was
         * invoked. The debounced function comes with a `cancel` method to cancel
         * delayed `func` invocations and a `flush` method to immediately invoke them.
         * Provide `options` to indicate whether `func` should be invoked on the
         * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
         * with the last arguments provided to the debounced function. Subsequent
         * calls to the debounced function return the result of the last `func`
         * invocation.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is
         * invoked on the trailing edge of the timeout only if the debounced function
         * is invoked more than once during the `wait` timeout.
         *
         * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
         * until to the next tick, similar to `setTimeout` with a timeout of `0`.
         *
         * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
         * for details over the differences between `_.debounce` and `_.throttle`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to debounce.
         * @param {number} [wait=0] The number of milliseconds to delay.
         * @param {Object} [options={}] The options object.
         * @param {boolean} [options.leading=false]
         *  Specify invoking on the leading edge of the timeout.
         * @param {number} [options.maxWait]
         *  The maximum time `func` is allowed to be delayed before it's invoked.
         * @param {boolean} [options.trailing=true]
         *  Specify invoking on the trailing edge of the timeout.
         * @returns {Function} Returns the new debounced function.
         * @example
         *
         * // Avoid costly calculations while the window size is in flux.
         * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
         *
         * // Invoke `sendMail` when clicked, debouncing subsequent calls.
         * jQuery(element).on('click', _.debounce(sendMail, 300, {
         *   'leading': true,
         *   'trailing': false
         * }));
         *
         * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
         * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
         * var source = new EventSource('/stream');
         * jQuery(source).on('message', debounced);
         *
         * // Cancel the trailing debounced invocation.
         * jQuery(window).on('popstate', debounced.cancel);
         */
        function debounce(func, wait, options) {
          var lastArgs,
            lastThis,
            maxWait,
            result,
            timerId,
            lastCallTime,
            lastInvokeTime = 0,
            leading = false,
            maxing = false,
            trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = 'maxWait' in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs,
              thisArg = lastThis;
            lastArgs = lastThis = undefined;
            lastInvokeTime = time;
            result = func.apply(thisArg, args);
            return result;
          }
          function leadingEdge(time) {
            // Reset any `maxWait` timer.
            lastInvokeTime = time;
            // Start the timer for the trailing edge.
            timerId = setTimeout(timerExpired, wait);
            // Invoke the leading edge.
            return leading ? invokeFunc(time) : result;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime,
              timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime;

            // Either this is the first call, activity has stopped and we're at the
            // trailing edge, the system time has gone backwards and we're treating
            // it as the trailing edge, or we've hit the `maxWait` limit.
            return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            // Restart the timer.
            timerId = setTimeout(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined;

            // Only invoke if we have `lastArgs` which means `func` has been
            // debounced at least once.
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined;
            return result;
          }
          function cancel() {
            if (timerId !== undefined) {
              clearTimeout(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined;
          }
          function flush() {
            return timerId === undefined ? result : trailingEdge(now());
          }
          function debounced() {
            var time = now(),
              isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                // Handle invocations in a tight loop.
                clearTimeout(timerId);
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined) {
              timerId = setTimeout(timerExpired, wait);
            }
            return result;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var debounce_1 = debounce;
        const debounce$1 = /*@__PURE__*/getDefaultExportFromCjs(debounce_1);
        function ownKeys$4(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$4(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$4(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        var _Utils$Autocomplete = Utils$1.Autocomplete,
          mergeListValues = _Utils$Autocomplete.mergeListValues,
          listValueToOption = _Utils$Autocomplete.listValueToOption,
          getListValue = _Utils$Autocomplete.getListValue;
        var _Utils$ListUtils = Utils$1.ListUtils,
          mapListValues$2 = _Utils$ListUtils.mapListValues,
          listValuesToArray = _Utils$ListUtils.listValuesToArray;
        var useListValuesAutocomplete$1 = function useListValuesAutocomplete(_ref, _ref2) {
          var asyncFetch = _ref.asyncFetch,
            useLoadMore = _ref.useLoadMore,
            useAsyncSearch = _ref.useAsyncSearch,
            forceAsyncSearch = _ref.forceAsyncSearch,
            selectedAsyncListValues = _ref.asyncListValues,
            staticListValues = _ref.listValues,
            allowCustomValues = _ref.allowCustomValues,
            selectedValue = _ref.value,
            setValue = _ref.setValue,
            placeholder = _ref.placeholder;
          var debounceTimeout = _ref2.debounceTimeout,
            multiple = _ref2.multiple;
          var knownSpecialValues = ["LOAD_MORE", "LOADING_MORE"];
          var loadMoreTitle = "Load more...";
          var loadingMoreTitle = "Loading more...";
          var aPlaceholder = forceAsyncSearch ? "Type to search" : placeholder;

          // state
          var _React$useState = React.useState(false),
            _React$useState2 = _slicedToArray$1(_React$useState, 2),
            open = _React$useState2[0],
            setOpen = _React$useState2[1];
          var _React$useState3 = React.useState(undefined),
            _React$useState4 = _slicedToArray$1(_React$useState3, 2),
            asyncFetchMeta = _React$useState4[0],
            setAsyncFetchMeta = _React$useState4[1];
          var _React$useState5 = React.useState(0),
            _React$useState6 = _slicedToArray$1(_React$useState5, 2),
            loadingCnt = _React$useState6[0],
            setLoadingCnt = _React$useState6[1];
          var _React$useState7 = React.useState(false),
            _React$useState8 = _slicedToArray$1(_React$useState7, 2),
            isLoadingMore = _React$useState8[0],
            setIsLoadingMore = _React$useState8[1];
          var _React$useState9 = React.useState(""),
            _React$useState10 = _slicedToArray$1(_React$useState9, 2),
            inputValue = _React$useState10[0],
            setInputValue = _React$useState10[1];
          var _React$useState11 = React.useState(undefined),
            _React$useState12 = _slicedToArray$1(_React$useState11, 2),
            asyncListValues = _React$useState12[0],
            setAsyncListValues = _React$useState12[1];

          // ref
          var asyncFectchCnt = React.useRef(0);
          var componentIsMounted = React.useRef(0);
          var isSelectedLoadMore = React.useRef(false);

          // compute
          var nSelectedAsyncListValues = listValuesToArray(selectedAsyncListValues);
          var listValues = asyncFetch ? !allowCustomValues ? mergeListValues(asyncListValues, nSelectedAsyncListValues, true) : asyncListValues : staticListValues;
          //const isDirtyInitialListValues = asyncListValues == undefined && selectedAsyncListValues && selectedAsyncListValues.length && typeof selectedAsyncListValues[0] != "object";
          var isLoading = loadingCnt > 0;
          var canInitialLoad = open && asyncFetch && asyncListValues === undefined && (forceAsyncSearch ? inputValue : true);
          var isInitialLoading = canInitialLoad && isLoading;
          var canLoadMore = !isInitialLoading && listValues && listValues.length > 0 && asyncFetchMeta && asyncFetchMeta.hasMore && (asyncFetchMeta.filter || "") === inputValue;
          var canShowLoadMore = !isLoading && canLoadMore;
          var options = mapListValues$2(listValues, listValueToOption);
          var hasValue = selectedValue != null;
          // const selectedListValue = hasValue ? getListValue(selectedValue, listValues) : null;
          // const selectedOption = listValueToOption(selectedListValue);

          // fetch
          var fetchListValues = /*#__PURE__*/function () {
            var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
              var filter,
                isLoadMore,
                offset,
                meta,
                newAsyncFetchCnt,
                res,
                isFetchCancelled,
                _ref4,
                values,
                hasMore,
                newMeta,
                nValues,
                assumeHasMore,
                newValues,
                realNewMeta,
                _args = arguments;
              return _regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    filter = _args.length > 0 && _args[0] !== undefined ? _args[0] : null;
                    isLoadMore = _args.length > 1 && _args[1] !== undefined ? _args[1] : false;
                    // clear obsolete meta
                    if (!isLoadMore && asyncFetchMeta) {
                      setAsyncFetchMeta(undefined);
                    }
                    offset = isLoadMore && asyncListValues ? asyncListValues.length : 0;
                    meta = isLoadMore && asyncFetchMeta || !useLoadMore && {
                      pageSize: 0
                    };
                    newAsyncFetchCnt = ++asyncFectchCnt.current;
                    _context.next = 8;
                    return asyncFetch(filter, offset, meta);
                  case 8:
                    res = _context.sent;
                    isFetchCancelled = asyncFectchCnt.current != newAsyncFetchCnt;
                    if (!(isFetchCancelled || !componentIsMounted.current)) {
                      _context.next = 12;
                      break;
                    }
                    return _context.abrupt("return", null);
                  case 12:
                    _ref4 = res && res.values ? res : {
                      values: res
                    }, values = _ref4.values, hasMore = _ref4.hasMore, newMeta = _ref4.meta;
                    nValues = listValuesToArray(values);
                    if (isLoadMore) {
                      newValues = mergeListValues(asyncListValues, nValues, false);
                      assumeHasMore = newValues.length > asyncListValues.length;
                    } else {
                      newValues = nValues;
                      if (useLoadMore) {
                        assumeHasMore = newValues.length > 0;
                      }
                    }

                    // save new meta
                    realNewMeta = hasMore != null || newMeta != null || assumeHasMore != null ? _objectSpread$4(_objectSpread$4(_objectSpread$4(_objectSpread$4({}, assumeHasMore != null ? {
                      hasMore: assumeHasMore
                    } : {}), hasMore != null ? {
                      hasMore: hasMore
                    } : {}), newMeta != null ? newMeta : {}), {}, {
                      filter: filter
                    }) : undefined;
                    if (realNewMeta) {
                      setAsyncFetchMeta(realNewMeta);
                    }
                    return _context.abrupt("return", newValues);
                  case 18:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            }));
            return function fetchListValues() {
              return _ref3.apply(this, arguments);
            };
          }();
          var loadListValues = /*#__PURE__*/function () {
            var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
              var filter,
                isLoadMore,
                list,
                _args2 = arguments;
              return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) switch (_context2.prev = _context2.next) {
                  case 0:
                    filter = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : null;
                    isLoadMore = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : false;
                    setLoadingCnt(function (x) {
                      return x + 1;
                    });
                    setIsLoadingMore(isLoadMore);
                    _context2.next = 6;
                    return fetchListValues(filter, isLoadMore);
                  case 6:
                    list = _context2.sent;
                    if (componentIsMounted.current) {
                      _context2.next = 9;
                      break;
                    }
                    return _context2.abrupt("return");
                  case 9:
                    if (list != null) {
                      // tip: null can be used for reject (eg, if user don't want to filter by input)
                      setAsyncListValues(list);
                    }
                    setLoadingCnt(function (x) {
                      return x - 1;
                    });
                    setIsLoadingMore(false);
                  case 12:
                  case "end":
                    return _context2.stop();
                }
              }, _callee2);
            }));
            return function loadListValues() {
              return _ref5.apply(this, arguments);
            };
          }();
          var loadListValuesDebounced = React.useCallback(debounce$1(loadListValues, debounceTimeout), []);
          React.useEffect(function () {
            componentIsMounted.current++;
            // Initial loading
            if (canInitialLoad && loadingCnt == 0 && asyncFectchCnt.current == 0) {
              _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
                return _regeneratorRuntime.wrap(function _callee3$(_context3) {
                  while (1) switch (_context3.prev = _context3.next) {
                    case 0:
                      _context3.next = 2;
                      return loadListValues();
                    case 2:
                    case "end":
                      return _context3.stop();
                  }
                }, _callee3);
              }))();
            }
            // Unmount
            return function () {
              componentIsMounted.current--;
            };
          }, [canInitialLoad]);

          // Event handlers
          var onOpen = function onOpen() {
            setOpen(true);
          };
          var onClose = function onClose(_e) {
            if (isSelectedLoadMore.current) {
              isSelectedLoadMore.current = false;
              if (multiple) {
                setOpen(false);
              }
            } else {
              setOpen(false);
            }
          };
          var onDropdownVisibleChange = function onDropdownVisibleChange(open) {
            if (open) {
              onOpen();
            } else {
              onClose();
            }
          };
          var isSpecialValue = function isSpecialValue(option) {
            var specialValue = (option === null || option === void 0 ? void 0 : option.specialValue) || (option === null || option === void 0 ? void 0 : option.value);
            return knownSpecialValues.includes(specialValue);
          };
          var onChange = /*#__PURE__*/function () {
            var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_e, option) {
              var specialValue, _options, newSelectedListValues, newSelectedValues, v;
              return _regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) switch (_context4.prev = _context4.next) {
                  case 0:
                    specialValue = (option === null || option === void 0 ? void 0 : option.specialValue) || (option === null || option === void 0 ? void 0 : option.value) || multiple && option.map(function (opt) {
                      return (opt === null || opt === void 0 ? void 0 : opt.specialValue) || (opt === null || opt === void 0 ? void 0 : opt.value);
                    }).find(function (v) {
                      return !!v;
                    });
                    if (!(specialValue == "LOAD_MORE")) {
                      _context4.next = 7;
                      break;
                    }
                    isSelectedLoadMore.current = true;
                    _context4.next = 5;
                    return loadListValues(inputValue, true);
                  case 5:
                    _context4.next = 8;
                    break;
                  case 7:
                    if (specialValue == "LOADING_MORE") {
                      isSelectedLoadMore.current = true;
                    } else {
                      if (multiple) {
                        _options = option;
                        newSelectedListValues = _options.map(function (o, i) {
                          var item = o.value != null ? o : getListValue(o, listValues);
                          // AntDesign puts array of labels in `_e` (`option` is array of objects, but custom option is always `{}`)
                          // MUI puts array of labels in `option`
                          var customItem = allowCustomValues && !item ? Array.isArray(_e) ? _e[i] : o : null;
                          return item || customItem;
                        });
                        newSelectedValues = newSelectedListValues.filter(function (o) {
                          return o !== undefined;
                        }).map(function (o) {
                          return o.value !== undefined ? o.value : o;
                        });
                        if (!newSelectedValues.length) newSelectedValues = undefined; //not allow []
                        setValue(newSelectedValues, newSelectedListValues);
                      } else {
                        v = option == null ? undefined : option.value;
                        setValue(v, [option]);
                      }
                    }
                  case 8:
                  case "end":
                    return _context4.stop();
                }
              }, _callee4);
            }));
            return function onChange(_x, _x2) {
              return _ref7.apply(this, arguments);
            };
          }();
          var onInputChange = /*#__PURE__*/function () {
            var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(_e, newInputValue) {
              var val, canSearchAsync;
              return _regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) switch (_context5.prev = _context5.next) {
                  case 0:
                    val = newInputValue; //const isTypeToSearch = e.type == 'change';
                    if (!(val === loadMoreTitle || val === loadingMoreTitle)) {
                      _context5.next = 3;
                      break;
                    }
                    return _context5.abrupt("return");
                  case 3:
                    setInputValue(val);
                    if (allowCustomValues) {
                      if (multiple) ;else {
                        setValue(val, [val]);
                      }
                    }
                    canSearchAsync = useAsyncSearch && (forceAsyncSearch ? !!val : true);
                    if (!canSearchAsync) {
                      _context5.next = 11;
                      break;
                    }
                    _context5.next = 9;
                    return loadListValuesDebounced(val);
                  case 9:
                    _context5.next = 12;
                    break;
                  case 11:
                    if (useAsyncSearch && forceAsyncSearch) {
                      setAsyncListValues([]);
                    }
                  case 12:
                  case "end":
                    return _context5.stop();
                }
              }, _callee5);
            }));
            return function onInputChange(_x3, _x4) {
              return _ref8.apply(this, arguments);
            };
          }();

          // to keep compatibility with antD
          var onSearch = /*#__PURE__*/function () {
            var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(newInputValue) {
              return _regeneratorRuntime.wrap(function _callee6$(_context6) {
                while (1) switch (_context6.prev = _context6.next) {
                  case 0:
                    if (!(newInputValue === "" && !open)) {
                      _context6.next = 2;
                      break;
                    }
                    return _context6.abrupt("return");
                  case 2:
                    _context6.next = 4;
                    return onInputChange(null, newInputValue);
                  case 4:
                  case "end":
                    return _context6.stop();
                }
              }, _callee6);
            }));
            return function onSearch(_x5) {
              return _ref9.apply(this, arguments);
            };
          }();

          // Options
          var extendOptions = function extendOptions(options) {
            var filtered = _toConsumableArray(options);
            if (useLoadMore) {
              if (canShowLoadMore) {
                filtered.push({
                  specialValue: "LOAD_MORE",
                  title: loadMoreTitle
                });
              } else if (isLoadingMore) {
                filtered.push({
                  specialValue: "LOADING_MORE",
                  title: loadingMoreTitle,
                  disabled: true
                });
              }
            }
            return filtered;
          };
          var getOptionSelected = function getOptionSelected(option, valueOrOption) {
            if (valueOrOption == null) return null;
            var selectedValue = valueOrOption.value != undefined ? valueOrOption.value : valueOrOption;
            return option.value === selectedValue;
          };
          var getOptionDisabled = function getOptionDisabled(valueOrOption) {
            return valueOrOption && valueOrOption.disabled;
          };
          var getOptionLabel = function getOptionLabel(valueOrOption) {
            if (valueOrOption == null) return null;
            var option = valueOrOption.value != undefined ? valueOrOption : listValueToOption(getListValue(valueOrOption, listValues));
            if (!option && valueOrOption.specialValue) {
              // special last 'Load more...' item
              return valueOrOption.title;
            }
            if (!option && allowCustomValues) {
              // there is just string value, it's not item from list
              return valueOrOption;
            }
            if (!option) {
              // weird
              return valueOrOption;
            }
            return option.title;
          };
          return {
            options: options,
            listValues: listValues,
            hasValue: hasValue,
            open: open,
            onOpen: onOpen,
            onClose: onClose,
            onDropdownVisibleChange: onDropdownVisibleChange,
            onChange: onChange,
            inputValue: inputValue,
            onInputChange: onInputChange,
            onSearch: onSearch,
            canShowLoadMore: canShowLoadMore,
            isInitialLoading: isInitialLoading,
            isLoading: isLoading,
            isLoadingMore: isLoadingMore,
            isSpecialValue: isSpecialValue,
            extendOptions: extendOptions,
            getOptionSelected: getOptionSelected,
            getOptionDisabled: getOptionDisabled,
            getOptionLabel: getOptionLabel,
            // unused
            //selectedListValue,
            //selectedOption,
            aPlaceholder: aPlaceholder
          };
        };
        function ownKeys$3(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$3(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        const Utils = _objectSpread$3(_objectSpread$3({}, Utils$1), {}, {
          ReactUtils: ReactUtils
        });
        var moment = Utils.moment;
        const MuiTimeWidget$1 = function (props) {
          var value = props.value,
            setValue = props.setValue,
            use12Hours = props.use12Hours,
            readonly = props.readonly,
            placeholder = props.placeholder,
            timeFormat = props.timeFormat,
            valueFormat = props.valueFormat,
            customProps = props.customProps;
          var formatSingleValue = function formatSingleValue(value) {
            return value && value.isValid() ? value.format(valueFormat) : undefined;
          };
          var handleChange = function handleChange(value) {
            setValue(formatSingleValue(value));
          };
          var hasSeconds = timeFormat.indexOf(":ss") != -1;
          var timeValue = value ? moment(value, timeFormat) : null;
          var renderInput = function renderInput(params) {
            return /*#__PURE__*/React.createElement(TextField, _extends$h({
              size: "small",
              variant: "standard"
            }, params));
          };
          return /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(TimePicker, _extends$h({
            readOnly: readonly,
            disabled: readonly,
            ampm: !!use12Hours,
            toolbarPlaceholder: !readonly ? placeholder : "",
            inputFormat: timeFormat,
            value: timeValue || null,
            onChange: handleChange,
            views: hasSeconds ? ["hours", "minutes", "seconds"] : ["hours", "minutes"],
            renderInput: renderInput
          }, customProps)));
        };
        var mapListValues$1 = Utils.ListUtils.mapListValues;
        const MuiSelectWidget$1 = function (_ref) {
          var listValues = _ref.listValues,
            value = _ref.value,
            setValue = _ref.setValue;
          _ref.allowCustomValues;
          var readonly = _ref.readonly,
            placeholder = _ref.placeholder,
            customProps = _ref.customProps;
          var renderOptions = function renderOptions() {
            return mapListValues$1(listValues, function (_ref2) {
              var title = _ref2.title,
                value = _ref2.value;
              return /*#__PURE__*/React.createElement(MenuItem, {
                key: value,
                value: value
              }, title);
            });
          };
          var onChange = function onChange(e) {
            if (e.target.value === undefined) return;
            setValue(e.target.value);
          };
          var renderValue = function renderValue(selectedValue) {
            if (!readonly && selectedValue == null) return placeholder;
            return getListValueTitle(selectedValue);
          };
          var getListValueTitle = function getListValueTitle(selectedValue) {
            return mapListValues$1(listValues, function (_ref3) {
              var title = _ref3.title,
                value = _ref3.value;
              return value === selectedValue ? title : null;
            }).filter(function (v) {
              return v !== null;
            }).shift();
          };
          var hasValue = value != null;
          return /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Select, _extends$h({
            variant: "standard",
            autoWidth: true,
            displayEmpty: true,
            placeholder: !readonly ? placeholder : "",
            onChange: onChange,
            value: hasValue ? value : "",
            disabled: readonly,
            readOnly: readonly,
            renderValue: renderValue,
            size: "small"
          }, omit$1(customProps, ["showSearch", "input"])), renderOptions()));
        };
        const MuiNumberWidget$1 = function (props) {
          var value = props.value,
            setValue = props.setValue;
          props.config;
          var readonly = props.readonly,
            min = props.min,
            max = props.max,
            step = props.step,
            placeholder = props.placeholder,
            customProps = props.customProps;
          var onChange = function onChange(e) {
            var val = e.target.value;
            if (val === "" || val === null) val = undefined;else val = Number(val);
            setValue(val);
          };
          var numberValue = value == undefined ? "" : value;
          return /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(TextField, _extends$h({
            variant: "standard",
            type: "number",
            value: numberValue,
            placeholder: !readonly ? placeholder : "",
            InputProps: {
              readOnly: readonly
            },
            inputProps: {
              min: min,
              max: max,
              step: step
            },
            disabled: readonly,
            onChange: onChange,
            size: "small"
          }, customProps)));
        };
        var _excluded$3 = ["width"];
        const MuiSliderWidget$1 = function (props) {
          var config = props.config,
            placeholder = props.placeholder,
            customProps = props.customProps,
            value = props.value,
            setValue = props.setValue,
            min = props.min,
            max = props.max,
            step = props.step,
            marks = props.marks,
            readonly = props.readonly;
          var defaultSliderWidth = config.settings.defaultSliderWidth;
          var handleSliderChange = reactExports.useCallback(function (_e, newValue) {
            setValue(newValue);
          }, []);
          var handleInputChange = function handleInputChange(e) {
            var val = e.target.value;
            if (val === "" || val === null) val = undefined;else val = Number(val);
            setValue(val);
          };
          var handleInputBlur = function handleInputBlur() {
            // TIP: Fix if typed value out of range in input
            if (value < min) {
              setValue(min);
            } else if (value > max) {
              setValue(max);
            }
          };
          var _ref = customProps || {},
            width = _ref.width,
            rest = _objectWithoutProperties$2(_ref, _excluded$3);
          var customInputProps = rest.input || {};
          var customSliderProps = rest.slider || rest;

          // TIP: Can't pass undefined to MUI, cause it means uncontrolled component use.
          //      For empty value input needs "", slider needs null or 0
          var inputValue = typeof value === "number" ? value : "";
          var sliderValue = typeof value === "number" ? value : null;

          // marks example: { 0: "0%", 100: React.createElement('strong', null, "100%") }
          var muiMarks = reactExports.useMemo(function () {
            return marks ? Object.keys(marks).map(function (v) {
              return {
                value: Number(v),
                label: _typeof$2(marks[v]) === "object" || typeof marks[v] === "undefined" ? marks[v] : /*#__PURE__*/React.createElement("p", null, marks[v])
              };
            }) : false;
          }, [marks]);
          var InputCmp = /*#__PURE__*/React.createElement(TextField, _extends$h({
            variant: "standard",
            type: "number",
            value: inputValue,
            placeholder: placeholder,
            InputProps: {
              readOnly: readonly
            },
            inputProps: {
              min: min,
              max: max,
              step: step
            },
            disabled: readonly,
            onChange: handleInputChange,
            onBlur: handleInputBlur,
            size: "small"
          }, customInputProps));
          var SliderCmp = /*#__PURE__*/React.createElement(Slider$2, _extends$h({
            value: sliderValue,
            onChange: handleSliderChange,
            disabled: readonly,
            min: min,
            max: max,
            step: step,
            marks: muiMarks,
            valueLabelDisplay: "auto",
            size: "small"
          }, customSliderProps));
          var stylesWrapper = {
            display: "inline-flex",
            alignItems: "center",
            flexWrap: "wrap"
          };
          var stylesInputWrapper = {
            marginLeft: "5px"
          };
          var stylesSliderWrapper = {
            marginLeft: "5px",
            paddingLeft: "12px",
            marginBottom: muiMarks && "-16px",
            width: width || defaultSliderWidth
          };
          return /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement("div", {
            style: stylesWrapper
          }, /*#__PURE__*/React.createElement("div", {
            style: stylesInputWrapper
          }, InputCmp), /*#__PURE__*/React.createElement("div", {
            style: stylesSliderWrapper
          }, SliderCmp)));
        };
        var _excluded$2 = ["width"];
        const MuiRangeWidget$1 = function (props) {
          var config = props.config,
            placeholders = props.placeholders,
            customProps = props.customProps,
            value = props.value,
            setValue = props.setValue,
            min = props.min,
            max = props.max,
            step = props.step,
            marks = props.marks,
            readonly = props.readonly,
            textSeparators = props.textSeparators;
          var defaultSliderWidth = config.settings.defaultSliderWidth;
          reactExports.useEffect(function () {
            var _ref = props.value || [undefined, undefined],
              _ref2 = _slicedToArray$1(_ref, 2),
              valueFrom = _ref2[0],
              valueTo = _ref2[1];
            if (props.value && (valueFrom == undefined || valueTo == undefined)) {
              // happens if we changed op from '==' to 'between'
              // (I know, timeout is dirty hack..)
              setTimeout(function () {
                var oneValue = valueFrom || valueTo;
                var value = [oneValue, oneValue];
                setValue(value);
              }, 1);
            }
          }, []);
          var handleSliderChange = function handleSliderChange(_e, newValues) {
            setValue(newValues);
          };
          var handleInputChangeFrom = function handleInputChangeFrom(e) {
            // TIP: need to use props.value instead of value
            var valueFrom = e.target.value;
            if (valueFrom === "" || valueFrom == null) valueFrom = undefined;else valueFrom = Number(valueFrom);
            var value = props.value ? _toConsumableArray(props.value) : [undefined, undefined];
            value[0] = valueFrom;
            setValue(value);
          };
          var handleInputChangeTo = function handleInputChangeTo(e) {
            var valueTo = e.target.value;
            if (valueTo === "" || valueTo == null) valueTo = undefined;else valueTo = Number(valueTo);
            var value = props.value ? _toConsumableArray(props.value) : [undefined, undefined];
            value[1] = valueTo;
            setValue(value);
          };
          var handleInputBlur = function handleInputBlur() {
            // TIP: Fix if typed value out of range in inputs
            if (!value) return;
            if (value[0] < min) {
              setValue([min, value[1]]);
            } else if (value[1] > max) {
              setValue([value[0], max]);
            }
          };
          var _ref3 = customProps || {},
            width = _ref3.width,
            rest = _objectWithoutProperties$2(_ref3, _excluded$2);
          var customInputProps = rest.input || {};
          var customSliderProps = rest.slider || rest;

          // marks example: { 0: "0%", 100: React.createElement('strong', null, "100%") }
          var muiMarks = marks ? Object.keys(marks).map(function (v) {
            return {
              value: Number(v),
              label: _typeof$2(marks[v]) === "object" || typeof marks[v] === "undefined" ? marks[v] : /*#__PURE__*/React.createElement("p", null, marks[v])
            };
          }) : false;

          // TIP: Can't pass undefined to MUI, cause it means uncontrolled component use.
          //      For empty value input needs "", slider needs null or 0, but null will cause problems with range mode
          var sliderValue = value ? _toConsumableArray(value) : [undefined, undefined];
          var _sliderValue = _slicedToArray$1(sliderValue, 2),
            valueFrom = _sliderValue[0],
            valueTo = _sliderValue[1];
          if (valueFrom == undefined) {
            valueFrom = "";
            sliderValue[0] = 0;
          }
          if (valueTo == undefined) {
            valueTo = "";
            sliderValue[1] = 0;
          }
          var FromInputCmp = /*#__PURE__*/React.createElement(TextField, _extends$h({
            variant: "standard",
            type: "number",
            value: valueFrom,
            placeholder: placeholders[0],
            InputProps: {
              readOnly: readonly
            },
            inputProps: {
              min: min,
              max: max,
              step: step
            },
            disabled: readonly,
            onChange: handleInputChangeFrom,
            onBlur: handleInputBlur,
            size: "small"
          }, customInputProps));
          var ToInputCmp = /*#__PURE__*/React.createElement(TextField, _extends$h({
            variant: "standard",
            type: "number",
            value: valueTo,
            placeholder: placeholders[1],
            InputProps: {
              readOnly: readonly
            },
            inputProps: {
              min: min,
              max: max,
              step: step
            },
            disabled: readonly,
            onChange: handleInputChangeTo,
            onBlur: handleInputBlur,
            size: "small"
          }, customInputProps));
          var SliderCmp = /*#__PURE__*/React.createElement(Slider$2, _extends$h({
            value: sliderValue,
            onChange: handleSliderChange,
            disabled: readonly,
            min: min,
            max: max,
            step: step,
            marks: muiMarks,
            valueLabelDisplay: "auto",
            size: "small"
          }, customSliderProps));
          var stylesWrapper = {
            display: "inline-flex",
            flexWrap: "wrap"
          };
          var stylesInputWrapper = {
            marginLeft: "5px"
          };
          var stylesSliderWrapper = {
            marginLeft: "5px",
            paddingLeft: "12px",
            marginBottom: muiMarks && "-16px",
            width: width || defaultSliderWidth
          };
          return /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement("div", {
            style: stylesWrapper
          }, /*#__PURE__*/React.createElement("div", {
            style: stylesInputWrapper
          }, FromInputCmp), /*#__PURE__*/React.createElement("div", {
            className: "widget--sep"
          }, /*#__PURE__*/React.createElement("span", null, textSeparators[1])), /*#__PURE__*/React.createElement("div", {
            style: stylesInputWrapper
          }, ToInputCmp), /*#__PURE__*/React.createElement("div", {
            style: stylesSliderWrapper
          }, SliderCmp)));
        };
        const MuiBooleanWidget$1 = function (props) {
          var customProps = props.customProps,
            value = props.value,
            setValue = props.setValue,
            labelYes = props.labelYes,
            labelNo = props.labelNo,
            readonly = props.readonly;
          var onChange = function onChange() {
            setValue(!value);
          };
          return /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Typography, {
            component: "div"
          }, /*#__PURE__*/React.createElement(Grid, {
            component: "label",
            container: true,
            alignItems: "center",
            spacing: 0
          }, /*#__PURE__*/React.createElement(Grid, {
            item: true,
            component: "span"
          }, labelNo), /*#__PURE__*/React.createElement(Grid, {
            item: true,
            component: "span"
          }, /*#__PURE__*/React.createElement(Switch, _extends$h({
            checked: !!value,
            onChange: onChange,
            disabled: readonly
          }, customProps))), /*#__PURE__*/React.createElement(Grid, {
            item: true,
            component: "span"
          }, labelYes))));
        };
        var mapListValues = Utils.ListUtils.mapListValues;
        const MuiMultiSelectWidget$1 = function (_ref) {
          var listValues = _ref.listValues,
            value = _ref.value,
            setValue = _ref.setValue;
          _ref.allowCustomValues;
          var readonly = _ref.readonly,
            placeholder = _ref.placeholder,
            customProps = _ref.customProps;
          var renderOptions = function renderOptions(selectedValues) {
            return mapListValues(listValues, function (_ref2) {
              var title = _ref2.title,
                value = _ref2.value;
              return /*#__PURE__*/React.createElement(MenuItem, {
                key: value,
                value: value
              }, /*#__PURE__*/React.createElement(Checkbox, {
                checked: selectedValues.indexOf(value) > -1
              }), /*#__PURE__*/React.createElement(ListItemText$1, {
                primary: title
              }));
            });
          };
          var renderValue = function renderValue(selectedValues) {
            if (!readonly && !selectedValues.length) return placeholder;
            var selectedTitles = mapListValues(listValues, function (_ref3) {
              var title = _ref3.title,
                value = _ref3.value;
              return selectedValues.indexOf(value) > -1 ? title : null;
            }).filter(function (v) {
              return v !== null;
            });
            return selectedTitles.join(", ");
          };
          var hasValue = value != null && value.length > 0;
          var onChange = function onChange(e) {
            if (e.target.value === undefined) return;
            setValue(e.target.value);
          };
          return /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Select, _extends$h({
            multiple: true,
            variant: "standard",
            autoWidth: true,
            displayEmpty: true,
            label: !readonly ? placeholder : "",
            onChange: onChange,
            value: hasValue ? value : [],
            disabled: readonly,
            readOnly: readonly,
            renderValue: renderValue,
            size: "small"
          }, omit$1(customProps, ["showSearch", "input", "showCheckboxes"])), renderOptions(hasValue ? value : [])));
        };
        var _excluded$1 = ["width", "showCheckboxes"];
        function ownKeys$2(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$2(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        var useListValuesAutocomplete = useListValuesAutocomplete$1;
        var nonCheckedIcon = /*#__PURE__*/React.createElement(default_1$m, {
          fontSize: "small"
        });
        var checkedIcon = /*#__PURE__*/React.createElement(default_1$t, {
          fontSize: "small"
        });
        var defaultFilterOptions = createFilterOptions();
        var emptyArray = [];
        const MuiAutocompleteWidget$1 = function (props) {
          var allowCustomValues = props.allowCustomValues,
            multiple = props.multiple,
            selectedValue = props.value,
            customProps = props.customProps,
            readonly = props.readonly,
            config = props.config,
            groupBy = props.groupBy,
            filterOptionsConfig = props.filterOptionsConfig;
          var filterOptionsFn = filterOptionsConfig ? createFilterOptions(filterOptionsConfig) : defaultFilterOptions;

          // hook
          var _useListValuesAutocom = useListValuesAutocomplete(props, {
              debounceTimeout: 100,
              multiple: multiple
            }),
            open = _useListValuesAutocom.open,
            onOpen = _useListValuesAutocom.onOpen,
            onClose = _useListValuesAutocom.onClose,
            onChange = _useListValuesAutocom.onChange,
            onInputChange = _useListValuesAutocom.onInputChange,
            inputValue = _useListValuesAutocom.inputValue,
            options = _useListValuesAutocom.options,
            isInitialLoading = _useListValuesAutocom.isInitialLoading,
            isLoading = _useListValuesAutocom.isLoading,
            aPlaceholder = _useListValuesAutocom.aPlaceholder,
            extendOptions = _useListValuesAutocom.extendOptions,
            getOptionDisabled = _useListValuesAutocom.getOptionDisabled,
            getOptionLabel = _useListValuesAutocom.getOptionLabel;

          // setings
          var _config$settings = config.settings,
            defaultSelectWidth = _config$settings.defaultSelectWidth,
            defaultSearchWidth = _config$settings.defaultSearchWidth;
          var _ref = customProps || {},
            width = _ref.width,
            showCheckboxes = _ref.showCheckboxes,
            rest = _objectWithoutProperties$2(_ref, _excluded$1);
          var customInputProps = rest.input || {};
          customInputProps.width || defaultSearchWidth; // todo: use as min-width for Autocomplete comp
          customInputProps = omit$1(customInputProps, ["width"]);
          var customAutocompleteProps = omit$1(rest, ["showSearch", "showCheckboxes"]);
          var fullWidth = true;
          var minWidth = width || defaultSelectWidth;
          var style = {
            width: multiple ? undefined : minWidth,
            minWidth: minWidth
          };
          var placeholder = !readonly ? aPlaceholder : "";
          var hasValue = selectedValue != null;
          // should be simple value to prevent re-render!s
          var value = hasValue ? selectedValue : multiple ? emptyArray : null;
          var filterOptions = function filterOptions(options, params) {
            var filtered = filterOptionsFn(options, params);
            var extended = extendOptions(filtered);
            return extended;
          };

          // render
          var renderInput = function renderInput(params) {
            return /*#__PURE__*/React.createElement(TextField, _extends$h({
              variant: "standard"
            }, params, {
              InputProps: _objectSpread$2(_objectSpread$2({}, params.InputProps), {}, {
                readOnly: readonly,
                endAdornment: /*#__PURE__*/React.createElement(React.Fragment, null, isLoading ? /*#__PURE__*/React.createElement(CircularProgress, {
                  color: "inherit",
                  size: 20
                }) : null, params.InputProps.endAdornment)
              }),
              disabled: readonly,
              placeholder: placeholder
              //onChange={onInputChange}
            }, customInputProps));
          };
          var isOptionEqualToValue = function isOptionEqualToValue(option, value) {
            return (option === null || option === void 0 ? void 0 : option.value) == value;
          };
          var renderOption = function renderOption(props, option) {
            var title = option.title,
              renderTitle = option.renderTitle,
              value = option.value;
            var selected = (selectedValue || []).includes(value);
            if (option.specialValue) {
              return /*#__PURE__*/React.createElement("div", props, renderTitle || title);
            } else if (multiple && showCheckboxes != false) {
              return /*#__PURE__*/React.createElement("div", props, /*#__PURE__*/React.createElement(Checkbox, {
                icon: nonCheckedIcon,
                checkedIcon: checkedIcon,
                style: {
                  marginRight: 8
                },
                checked: selected
              }), title);
            } else {
              return /*#__PURE__*/React.createElement("div", props, renderTitle || title);
            }
          };
          return /*#__PURE__*/React.createElement(FormControl, {
            fullWidth: fullWidth
          }, /*#__PURE__*/React.createElement(Autocomplete$1, _extends$h({
            disableCloseOnSelect: multiple,
            fullWidth: fullWidth,
            multiple: multiple,
            style: style,
            freeSolo: allowCustomValues,
            loading: isInitialLoading,
            open: open,
            onOpen: onOpen,
            onClose: onClose,
            inputValue: inputValue,
            onInputChange: onInputChange,
            label: placeholder,
            onChange: onChange,
            value: value,
            disabled: readonly,
            readOnly: readonly,
            options: options,
            groupBy: groupBy,
            getOptionLabel: getOptionLabel,
            getOptionDisabled: getOptionDisabled,
            renderInput: renderInput
            //renderTags={renderTags}
            ,

            renderOption: renderOption,
            filterOptions: filterOptions,
            isOptionEqualToValue: isOptionEqualToValue,
            size: "small"
          }, customAutocompleteProps)));
        };
        const MuiFieldSelect$1 = function (_ref) {
          var items = _ref.items,
            setField = _ref.setField,
            selectedKey = _ref.selectedKey,
            readonly = _ref.readonly,
            placeholder = _ref.placeholder;
          var renderOptions = function renderOptions(fields) {
            var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            return Object.keys(fields).map(function (fieldKey) {
              var field = fields[fieldKey];
              var items = field.items,
                path = field.path,
                label = field.label,
                disabled = field.disabled;
              var prefix = "\xA0\xA0".repeat(level);
              if (items) {
                return [/*#__PURE__*/React.createElement(ListSubheader$1, {
                  disabled: disabled,
                  key: path,
                  disableSticky: true
                }, prefix && /*#__PURE__*/React.createElement("span", null, prefix), label), renderOptions(items, level + 1)];
              } else {
                return /*#__PURE__*/React.createElement(MenuItem, {
                  disabled: disabled,
                  key: path,
                  value: path
                }, prefix && /*#__PURE__*/React.createElement("span", null, prefix), label);
              }
            });
          };
          var onChange = function onChange(e) {
            if (e.target.value === undefined) return;
            setField(e.target.value);
          };
          var renderValue = function renderValue(selectedValue) {
            if (!readonly && !selectedValue) return placeholder;
            var findLabel = function findLabel(fields) {
              return fields.map(function (field) {
                if (!field.items) return field.path === selectedValue ? field.label : null;
                return findLabel(field.items);
              });
            };
            return findLabel(items).filter(function (v) {
              if (Array.isArray(v)) {
                return v.some(function (value) {
                  return value !== null;
                });
              } else {
                return v !== null;
              }
            }).pop();
          };
          var hasValue = selectedKey != null;
          return /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Select, {
            variant: "standard",
            autoWidth: true,
            displayEmpty: true,
            placeholder: placeholder,
            onChange: onChange,
            value: hasValue ? selectedKey : "",
            disabled: readonly,
            renderValue: renderValue,
            size: "small"
          }, renderOptions(items)));
        };
        var _excluded = ["items", "selectedKey", "setField"];
        function ownKeys$1(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread$1(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        var itemsToListValues = function itemsToListValues(items) {
          var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          return items.map(function (item) {
            var items = item.items,
              path = item.path,
              label = item.label,
              disabled = item.disabled,
              grouplabel = item.grouplabel;
            var prefix = "\xA0\xA0".repeat(level);
            if (items) {
              return itemsToListValues(items, level + 1);
            } else {
              return {
                title: label,
                renderTitle: prefix + label,
                value: path,
                disabled: disabled,
                groupTitle: level > 0 ? prefix + grouplabel : null
              };
            }
          }).flat(Infinity);
        };
        var filterOptionsConfig = {
          stringify: function stringify(option) {
            var keysForFilter = ["title", "value", "grouplabel", "label"];
            var valueForFilter = keysForFilter.map(function (k) {
              return typeof option[k] == "string" ? option[k] : "";
            }).join("\0");
            return valueForFilter;
          }
        };
        var fieldAdapter = function fieldAdapter(_ref) {
          var items = _ref.items,
            selectedKey = _ref.selectedKey,
            setField = _ref.setField,
            rest = _objectWithoutProperties$2(_ref, _excluded);
          var listValues = itemsToListValues(items);
          var groupBy = function groupBy(option) {
            return option.groupTitle;
          };
          var value = selectedKey;
          var setValue = function setValue(value, _asyncValues) {
            if (!value) return undefined;
            return setField(value);
          };
          return _objectSpread$1(_objectSpread$1({}, rest), {}, {
            listValues: listValues,
            setValue: setValue,
            groupBy: groupBy,
            filterOptionsConfig: filterOptionsConfig,
            allowCustomValues: false,
            multiple: false,
            value: value
          });
        };
        const MuiFieldAutocomplete$1 = function (props) {
          return /*#__PURE__*/React.createElement(MuiAutocompleteWidget$1, fieldAdapter(props));
        };
        const MuiButton$1 = function (_ref) {
          var type = _ref.type,
            label = _ref.label,
            onClick = _ref.onClick,
            readonly = _ref.readonly;
          _ref.config;
          var hideLabelsFor = {
            "addRuleGroup": true,
            "addRuleGroupExt": true
          };
          var typeToIcon = {
            "delGroup": /*#__PURE__*/React.createElement(default_1$u, null),
            "delRuleGroup": /*#__PURE__*/React.createElement(default_1$u, null),
            "delRule": /*#__PURE__*/React.createElement(default_1$u, null),
            "addRule": /*#__PURE__*/React.createElement(default_1$9, null),
            "addGroup": /*#__PURE__*/React.createElement(default_1$9, null),
            "addRuleGroupExt": /*#__PURE__*/React.createElement(default_1$9, null),
            "addRuleGroup": /*#__PURE__*/React.createElement(default_1$9, null)
          };
          var typeToColor = {
            "addRule": "neutral",
            "addGroup": "primary",
            "delGroup": "secondary",
            "delRuleGroup": "secondary",
            "delRule": "secondary"
          };
          if (!label || hideLabelsFor[type]) {
            return /*#__PURE__*/React.createElement(IconButton, {
              size: "small",
              disabled: readonly,
              onClick: onClick,
              color: typeToColor[type]
            }, typeToIcon[type]);
          } else {
            return /*#__PURE__*/React.createElement(Button, {
              size: "small",
              disabled: readonly,
              onClick: onClick,
              color: typeToColor[type],
              startIcon: typeToIcon[type]
            }, label);
          }
        };
        const MuiButtonGroup$1 = function (_ref) {
          var children = _ref.children;
          _ref.config;
          return /*#__PURE__*/React.createElement(React.Fragment, null, children);
        };
        const MuiConjs$1 = function (_ref) {
          var id = _ref.id,
            not = _ref.not,
            setNot = _ref.setNot,
            conjunctionOptions = _ref.conjunctionOptions,
            setConjunction = _ref.setConjunction,
            disabled = _ref.disabled,
            readonly = _ref.readonly,
            config = _ref.config,
            showNot = _ref.showNot,
            notLabel = _ref.notLabel;
          //TIP: disabled=true if only 1 rule; readonly=true if immutable mode
          var conjsCount = Object.keys(conjunctionOptions).length;
          var lessThenTwo = disabled;
          var forceShowConj = config.settings.forceShowConj;
          var showConj = forceShowConj || conjsCount > 1 && !lessThenTwo;
          var renderOptions = function renderOptions() {
            return Object.keys(conjunctionOptions).map(function (key) {
              var _conjunctionOptions$k = conjunctionOptions[key],
                id = _conjunctionOptions$k.id;
              _conjunctionOptions$k.name;
              var label = _conjunctionOptions$k.label,
                checked = _conjunctionOptions$k.checked;
              var postfix = setConjunction.isDummyFn ? "__dummy" : "";
              if ((readonly || disabled) && !checked) return null;
              return /*#__PURE__*/React.createElement(Button, {
                key: id + postfix,
                id: id + postfix,
                color: checked ? "primary" : "neutral",
                value: key,
                onClick: onClick.bind(null, key),
                disabled: readonly || disabled
              }, label);
            });
          };
          var renderNot = function renderNot() {
            if (readonly && !not) return null;
            return /*#__PURE__*/React.createElement(Button, {
              key: id,
              id: id + "__not",
              color: not ? "secondary" : "neutral",
              onClick: onNotClick.bind(null, !not),
              disabled: readonly
            }, notLabel || "NOT");
          };
          var onClick = function onClick(value) {
            return setConjunction(value);
          };
          var onNotClick = function onNotClick(checked) {
            return setNot(checked);
          };
          return /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(ButtonGroup$1, {
            disableElevation: true,
            variant: "contained",
            size: "small",
            disabled: readonly
          }, showNot && renderNot(), showConj && renderOptions()));
        };
        var LockOpen = {};
        var _interopRequireDefault$6 = interopRequireDefaultExports;
        Object.defineProperty(LockOpen, "__esModule", {
          value: true
        });
        var default_1$6 = LockOpen.default = void 0;
        var _createSvgIcon$6 = _interopRequireDefault$6(requireCreateSvgIcon());
        var _jsxRuntime$6 = jsxRuntimeExports;
        var _default$6 = (0, _createSvgIcon$6.default)( /*#__PURE__*/(0, _jsxRuntime$6.jsx)("path", {
          d: "M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6h1.9c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm0 12H6V10h12v10z"
        }), 'LockOpen');
        default_1$6 = LockOpen.default = _default$6;
        var Lock = {};
        var _interopRequireDefault$5 = interopRequireDefaultExports;
        Object.defineProperty(Lock, "__esModule", {
          value: true
        });
        var default_1$5 = Lock.default = void 0;
        var _createSvgIcon$5 = _interopRequireDefault$5(requireCreateSvgIcon());
        var _jsxRuntime$5 = jsxRuntimeExports;
        var _default$5 = (0, _createSvgIcon$5.default)( /*#__PURE__*/(0, _jsxRuntime$5.jsx)("path", {
          d: "M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"
        }), 'Lock');
        default_1$5 = Lock.default = _default$5;
        const MuiSwitch$1 = function (_ref) {
          var value = _ref.value,
            setValue = _ref.setValue,
            label = _ref.label,
            checkedLabel = _ref.checkedLabel,
            hideLabel = _ref.hideLabel,
            id = _ref.id,
            config = _ref.config,
            type = _ref.type;
          config.settings.renderSize;
          var onChange = function onChange(e) {
            return setValue(e.target.checked);
          };
          var onClick = function onClick() {
            return setValue(!value);
          };
          var postfix = type;
          var showLabel = value ? checkedLabel || label : label;
          var icon = value ? /*#__PURE__*/React.createElement(default_1$5, null) : /*#__PURE__*/React.createElement(default_1$6, null);
          if (type == "lock") {
            if (hideLabel) {
              return /*#__PURE__*/React.createElement(IconButton, {
                key: id + postfix,
                onClick: onClick,
                size: "small"
              }, icon);
            } else {
              return /*#__PURE__*/React.createElement(Button, {
                key: id + postfix,
                onClick: onClick,
                size: "small",
                startIcon: icon
              }, showLabel);
            }
          }
          return /*#__PURE__*/React.createElement(FormControlLabel, {
            control: /*#__PURE__*/React.createElement(Switch, {
              checked: !!value,
              size: "small",
              onChange: onChange
            }),
            label: showLabel
          });
        };
        var ExpandMoreSharp = {};
        var _interopRequireDefault$4 = interopRequireDefaultExports;
        Object.defineProperty(ExpandMoreSharp, "__esModule", {
          value: true
        });
        var default_1$4 = ExpandMoreSharp.default = void 0;
        var _createSvgIcon$4 = _interopRequireDefault$4(requireCreateSvgIcon());
        var _jsxRuntime$4 = jsxRuntimeExports;
        var _default$4 = (0, _createSvgIcon$4.default)( /*#__PURE__*/(0, _jsxRuntime$4.jsx)("path", {
          d: "M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6-1.41-1.41z"
        }), 'ExpandMoreSharp');
        default_1$4 = ExpandMoreSharp.default = _default$4;
        const MuiValueSources$1 = function (_ref) {
          var valueSources = _ref.valueSources,
            valueSrc = _ref.valueSrc,
            title = _ref.title,
            setValueSrc = _ref.setValueSrc;
          _ref.readonly;
          var _React$useState = React.useState(null),
            _React$useState2 = _slicedToArray$1(_React$useState, 2),
            anchorEl = _React$useState2[0],
            setAnchorEl = _React$useState2[1];
          var handleOpen = function handleOpen(event) {
            setAnchorEl(event.currentTarget);
          };
          var handleClose = function handleClose() {
            setAnchorEl(null);
          };
          var toggleOpenClose = function toggleOpenClose(event) {
            anchorEl ? handleClose() : handleOpen(event);
          };
          var handleChange = function handleChange(e) {
            if (e.target.value === undefined) return;
            setValueSrc(e.target.value);
            handleClose();
          };
          var renderOptions = function renderOptions(valueSources) {
            return valueSources.map(function (_ref2) {
              var _ref3 = _slicedToArray$1(_ref2, 2),
                srcKey = _ref3[0],
                info = _ref3[1];
              return /*#__PURE__*/React.createElement(FormControlLabel, {
                key: srcKey,
                value: srcKey,
                checked: valueSrc == srcKey || !valueSrc && srcKey == "value",
                control: /*#__PURE__*/React.createElement(Radio, null),
                label: info.label
              });
            });
          };
          var open = Boolean(anchorEl);
          return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(IconButton, {
            size: "small",
            onClick: toggleOpenClose
          }, /*#__PURE__*/React.createElement(default_1$4, null)), /*#__PURE__*/React.createElement(Popover, {
            open: open,
            anchorEl: anchorEl,
            anchorOrigin: {
              vertical: "bottom",
              horizontal: "left"
            },
            transformOrigin: {
              vertical: "top",
              horizontal: "left"
            },
            onClose: handleClose,
            sx: {
              padding: function padding(theme) {
                return theme.spacing(1);
              }
            },
            disablePortal: true
          }, /*#__PURE__*/React.createElement(FormControl, {
            component: "fieldset",
            sx: {
              p: 2
            }
          }, /*#__PURE__*/React.createElement(FormLabel, {
            component: "legend"
          }, title), /*#__PURE__*/React.createElement(RadioGroup, {
            value: valueSrc || "value",
            onChange: handleChange
          }, renderOptions(valueSources)))));
        };
        const MuiConfirm$1 = function (_ref) {
          var onOk = _ref.onOk,
            okText = _ref.okText,
            cancelText = _ref.cancelText,
            title = _ref.title,
            confirmFn = _ref.confirmFn;
          confirmFn({
            description: title || "Are you sure?",
            title: null,
            confirmationText: okText || "Ok",
            cancellationText: cancelText || "Cancel"
          }).then(onOk)["catch"](function () {});
        };

        // provider
        var MuiProvider$1 = function MuiProvider(_ref) {
          var config = _ref.config,
            children = _ref.children;
          var settingsTheme = config.settings.theme || {};
          var settingsLocale = config.settings.locale || {};
          var themeConfig = settingsTheme.mui;
          var locale = settingsLocale.mui;
          var theme = createTheme(themeConfig, locale, {
            palette: {
              neutral: {
                main: "#64748B",
                contrastText: "#fff"
              }
            }
          });
          var base = /*#__PURE__*/React.createElement("div", {
            className: "mui"
          }, children);
          var withProviders = /*#__PURE__*/React.createElement(LocalizationProvider, {
            dateAdapter: MomentUtils
          }, /*#__PURE__*/React.createElement(ConfirmProvider, null, base));
          var withTheme = theme ? /*#__PURE__*/React.createElement(ThemeProvider, {
            theme: theme
          }, withProviders) : withProviders;
          return withTheme;
        };
        const MuiWidgets = {
          MuiTextWidget: MuiTextWidget$1,
          MuiTextAreaWidget: MuiTextAreaWidget$1,
          MuiDateWidget: MuiDateWidget$1,
          MuiDateTimeWidget: MuiDateTimeWidget$1,
          MuiTimeWidget: MuiTimeWidget$1,
          MuiSelectWidget: MuiSelectWidget$1,
          MuiNumberWidget: MuiNumberWidget$1,
          MuiSliderWidget: MuiSliderWidget$1,
          MuiRangeWidget: MuiRangeWidget$1,
          MuiBooleanWidget: MuiBooleanWidget$1,
          MuiMultiSelectWidget: MuiMultiSelectWidget$1,
          MuiAutocompleteWidget: MuiAutocompleteWidget$1,
          MuiFieldSelect: MuiFieldSelect$1,
          MuiFieldAutocomplete: MuiFieldAutocomplete$1,
          MuiButton: MuiButton$1,
          MuiButtonGroup: MuiButtonGroup$1,
          MuiConjs: MuiConjs$1,
          MuiSwitch: MuiSwitch$1,
          MuiValueSources: MuiValueSources$1,
          MuiConfirm: MuiConfirm$1,
          MuiUseConfirm: useConfirm,
          MuiProvider: MuiProvider$1
        };
        function ownKeys(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
              _defineProperty$4(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        var _Utils$ExportUtils = Utils.ExportUtils,
          SqlString = _Utils$ExportUtils.SqlString,
          stringifyForDisplay = _Utils$ExportUtils.stringifyForDisplay;
        var MuiBooleanWidget = MuiWidgets.MuiBooleanWidget,
          MuiTextWidget = MuiWidgets.MuiTextWidget,
          MuiTextAreaWidget = MuiWidgets.MuiTextAreaWidget,
          MuiDateWidget = MuiWidgets.MuiDateWidget,
          MuiTimeWidget = MuiWidgets.MuiTimeWidget,
          MuiDateTimeWidget = MuiWidgets.MuiDateTimeWidget,
          MuiMultiSelectWidget = MuiWidgets.MuiMultiSelectWidget,
          MuiSelectWidget = MuiWidgets.MuiSelectWidget,
          MuiNumberWidget = MuiWidgets.MuiNumberWidget,
          MuiSliderWidget = MuiWidgets.MuiSliderWidget,
          MuiRangeWidget = MuiWidgets.MuiRangeWidget,
          MuiAutocompleteWidget = MuiWidgets.MuiAutocompleteWidget,
          MuiFieldSelect = MuiWidgets.MuiFieldSelect,
          MuiFieldAutocomplete = MuiWidgets.MuiFieldAutocomplete,
          MuiConjs = MuiWidgets.MuiConjs,
          MuiSwitch = MuiWidgets.MuiSwitch,
          MuiButton = MuiWidgets.MuiButton,
          MuiButtonGroup = MuiWidgets.MuiButtonGroup,
          MuiValueSources = MuiWidgets.MuiValueSources,
          MuiProvider = MuiWidgets.MuiProvider,
          MuiConfirm = MuiWidgets.MuiConfirm,
          MuiUseConfirm = MuiWidgets.MuiUseConfirm;
        var settings$1 = _objectSpread(_objectSpread({}, BasicConfig.settings), {}, {
          renderField: function renderField(props) {
            var _props$customProps;
            return props !== null && props !== void 0 && (_props$customProps = props.customProps) !== null && _props$customProps !== void 0 && _props$customProps.showSearch ? /*#__PURE__*/React.createElement(MuiFieldAutocomplete, props) : /*#__PURE__*/React.createElement(MuiFieldSelect, props);
          },
          renderOperator: function renderOperator(props) {
            return /*#__PURE__*/React.createElement(MuiFieldSelect, props);
          },
          renderFunc: function renderFunc(props) {
            return /*#__PURE__*/React.createElement(MuiFieldSelect, props);
          },
          renderConjs: function renderConjs(props) {
            return /*#__PURE__*/React.createElement(MuiConjs, props);
          },
          renderSwitch: function renderSwitch(props) {
            return /*#__PURE__*/React.createElement(MuiSwitch, props);
          },
          renderButton: function renderButton(props) {
            return /*#__PURE__*/React.createElement(MuiButton, props);
          },
          renderButtonGroup: function renderButtonGroup(props) {
            return /*#__PURE__*/React.createElement(MuiButtonGroup, props);
          },
          renderValueSources: function renderValueSources(props) {
            return /*#__PURE__*/React.createElement(MuiValueSources, props);
          },
          renderProvider: function renderProvider(props) {
            return /*#__PURE__*/React.createElement(MuiProvider, props);
          },
          renderConfirm: MuiConfirm,
          useConfirm: MuiUseConfirm
        });
        var widgets$1 = _objectSpread(_objectSpread({}, BasicConfig.widgets), {}, {
          text: _objectSpread(_objectSpread({}, BasicConfig.widgets.text), {}, {
            factory: function factory(props) {
              return /*#__PURE__*/React.createElement(MuiTextWidget, props);
            }
          }),
          textarea: _objectSpread(_objectSpread({}, BasicConfig.widgets.textarea), {}, {
            factory: function factory(props) {
              return /*#__PURE__*/React.createElement(MuiTextAreaWidget, props);
            }
          }),
          number: _objectSpread(_objectSpread({}, BasicConfig.widgets.number), {}, {
            factory: function factory(props) {
              return /*#__PURE__*/React.createElement(MuiNumberWidget, props);
            }
          }),
          multiselect: _objectSpread(_objectSpread({}, BasicConfig.widgets.multiselect), {}, {
            factory: function factory(props) {
              return props.asyncFetch || props.showSearch ? /*#__PURE__*/React.createElement(MuiAutocompleteWidget, _extends$h({
                multiple: true
              }, props)) : /*#__PURE__*/React.createElement(MuiMultiSelectWidget, props);
            }
          }),
          select: _objectSpread(_objectSpread({}, BasicConfig.widgets.select), {}, {
            factory: function factory(props) {
              return props.asyncFetch || props.showSearch ? /*#__PURE__*/React.createElement(MuiAutocompleteWidget, props) : /*#__PURE__*/React.createElement(MuiSelectWidget, props);
            }
          }),
          slider: _objectSpread(_objectSpread({}, BasicConfig.widgets.slider), {}, {
            factory: function factory(props) {
              return /*#__PURE__*/React.createElement(MuiSliderWidget, props);
            }
          }),
          "boolean": _objectSpread(_objectSpread({}, BasicConfig.widgets["boolean"]), {}, {
            factory: function factory(props) {
              return /*#__PURE__*/React.createElement(MuiBooleanWidget, props);
            }
          }),
          date: _objectSpread(_objectSpread({}, BasicConfig.widgets.date), {}, {
            factory: function factory(props) {
              return /*#__PURE__*/React.createElement(MuiDateWidget, props);
            }
          }),
          time: _objectSpread(_objectSpread({}, BasicConfig.widgets.time), {}, {
            factory: function factory(props) {
              return /*#__PURE__*/React.createElement(MuiTimeWidget, props);
            }
          }),
          datetime: _objectSpread(_objectSpread({}, BasicConfig.widgets.datetime), {}, {
            factory: function factory(props) {
              return /*#__PURE__*/React.createElement(MuiDateTimeWidget, props);
            }
          }),
          rangeslider: {
            type: "number",
            jsType: "number",
            valueSrc: "value",
            factory: function factory(props) {
              return /*#__PURE__*/React.createElement(MuiRangeWidget, props);
            },
            valueLabel: "Range",
            valuePlaceholder: "Select range",
            valueLabels: [{
              label: "Number from",
              placeholder: "Enter number from"
            }, {
              label: "Number to",
              placeholder: "Enter number to"
            }],
            formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
              return isForDisplay ? stringifyForDisplay(val) : JSON.stringify(val);
            },
            sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
              return SqlString.escape(val);
            },
            singleWidget: "slider",
            toJS: function toJS(val, fieldSettings) {
              return val;
            }
          }
        });
        var types$1 = _objectSpread(_objectSpread({}, BasicConfig.types), {}, {
          number: _objectSpread(_objectSpread({}, BasicConfig.types.number), {}, {
            widgets: _objectSpread(_objectSpread({}, BasicConfig.types.number.widgets), {}, {
              rangeslider: {
                opProps: {
                  between: {
                    isSpecialRange: true
                  },
                  not_between: {
                    isSpecialRange: true
                  }
                },
                operators: ["between", "not_between", "is_empty", "is_not_empty"]
              }
            })
          })
        });
        const MuiConfig = _objectSpread(_objectSpread({}, BasicConfig), {}, {
          types: types$1,
          widgets: widgets$1,
          settings: settings$1
        });
        var lodash_merge = {
          exports: {}
        };

        /**
         * Lodash (Custom Build) <https://lodash.com/>
         * Build: `lodash modularize exports="npm" -o ./`
         * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
         * Released under MIT license <https://lodash.com/license>
         * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
         * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
         */
        lodash_merge.exports;
        (function (module, exports) {
          /** Used as the size to enable large array optimizations. */
          var LARGE_ARRAY_SIZE = 200;

          /** Used to stand-in for `undefined` hash values. */
          var HASH_UNDEFINED = '__lodash_hash_undefined__';

          /** Used to detect hot functions by number of calls within a span of milliseconds. */
          var HOT_COUNT = 800,
            HOT_SPAN = 16;

          /** Used as references for various `Number` constants. */
          var MAX_SAFE_INTEGER = 9007199254740991;

          /** `Object#toString` result references. */
          var argsTag = '[object Arguments]',
            arrayTag = '[object Array]',
            asyncTag = '[object AsyncFunction]',
            boolTag = '[object Boolean]',
            dateTag = '[object Date]',
            errorTag = '[object Error]',
            funcTag = '[object Function]',
            genTag = '[object GeneratorFunction]',
            mapTag = '[object Map]',
            numberTag = '[object Number]',
            nullTag = '[object Null]',
            objectTag = '[object Object]',
            proxyTag = '[object Proxy]',
            regexpTag = '[object RegExp]',
            setTag = '[object Set]',
            stringTag = '[object String]',
            undefinedTag = '[object Undefined]',
            weakMapTag = '[object WeakMap]';
          var arrayBufferTag = '[object ArrayBuffer]',
            dataViewTag = '[object DataView]',
            float32Tag = '[object Float32Array]',
            float64Tag = '[object Float64Array]',
            int8Tag = '[object Int8Array]',
            int16Tag = '[object Int16Array]',
            int32Tag = '[object Int32Array]',
            uint8Tag = '[object Uint8Array]',
            uint8ClampedTag = '[object Uint8ClampedArray]',
            uint16Tag = '[object Uint16Array]',
            uint32Tag = '[object Uint32Array]';

          /**
           * Used to match `RegExp`
           * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
           */
          var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

          /** Used to detect host constructors (Safari). */
          var reIsHostCtor = /^\[object .+?Constructor\]$/;

          /** Used to detect unsigned integer values. */
          var reIsUint = /^(?:0|[1-9]\d*)$/;

          /** Used to identify `toStringTag` values of typed arrays. */
          var typedArrayTags = {};
          typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
          typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

          /** Detect free variable `global` from Node.js. */
          var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

          /** Detect free variable `self`. */
          var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

          /** Used as a reference to the global object. */
          var root = freeGlobal || freeSelf || Function('return this')();

          /** Detect free variable `exports`. */
          var freeExports = exports && !exports.nodeType && exports;

          /** Detect free variable `module`. */
          var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

          /** Detect the popular CommonJS extension `module.exports`. */
          var moduleExports = freeModule && freeModule.exports === freeExports;

          /** Detect free variable `process` from Node.js. */
          var freeProcess = moduleExports && freeGlobal.process;

          /** Used to access faster Node.js helpers. */
          var nodeUtil = function () {
            try {
              // Use `util.types` for Node.js 10+.
              var types = freeModule && freeModule.require && freeModule.require('util').types;
              if (types) {
                return types;
              }

              // Legacy `process.binding('util')` for Node.js < 10.
              return freeProcess && freeProcess.binding && freeProcess.binding('util');
            } catch (e) {}
          }();

          /* Node.js helper references. */
          var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

          /**
           * A faster alternative to `Function#apply`, this function invokes `func`
           * with the `this` binding of `thisArg` and the arguments of `args`.
           *
           * @private
           * @param {Function} func The function to invoke.
           * @param {*} thisArg The `this` binding of `func`.
           * @param {Array} args The arguments to invoke `func` with.
           * @returns {*} Returns the result of `func`.
           */
          function apply(func, thisArg, args) {
            switch (args.length) {
              case 0:
                return func.call(thisArg);
              case 1:
                return func.call(thisArg, args[0]);
              case 2:
                return func.call(thisArg, args[0], args[1]);
              case 3:
                return func.call(thisArg, args[0], args[1], args[2]);
            }
            return func.apply(thisArg, args);
          }

          /**
           * The base implementation of `_.times` without support for iteratee shorthands
           * or max array length checks.
           *
           * @private
           * @param {number} n The number of times to invoke `iteratee`.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array} Returns the array of results.
           */
          function baseTimes(n, iteratee) {
            var index = -1,
              result = Array(n);
            while (++index < n) {
              result[index] = iteratee(index);
            }
            return result;
          }

          /**
           * The base implementation of `_.unary` without support for storing metadata.
           *
           * @private
           * @param {Function} func The function to cap arguments for.
           * @returns {Function} Returns the new capped function.
           */
          function baseUnary(func) {
            return function (value) {
              return func(value);
            };
          }

          /**
           * Gets the value at `key` of `object`.
           *
           * @private
           * @param {Object} [object] The object to query.
           * @param {string} key The key of the property to get.
           * @returns {*} Returns the property value.
           */
          function getValue(object, key) {
            return object == null ? undefined : object[key];
          }

          /**
           * Creates a unary function that invokes `func` with its argument transformed.
           *
           * @private
           * @param {Function} func The function to wrap.
           * @param {Function} transform The argument transform.
           * @returns {Function} Returns the new function.
           */
          function overArg(func, transform) {
            return function (arg) {
              return func(transform(arg));
            };
          }

          /** Used for built-in method references. */
          var arrayProto = Array.prototype,
            funcProto = Function.prototype,
            objectProto = Object.prototype;

          /** Used to detect overreaching core-js shims. */
          var coreJsData = root['__core-js_shared__'];

          /** Used to resolve the decompiled source of functions. */
          var funcToString = funcProto.toString;

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty;

          /** Used to detect methods masquerading as native. */
          var maskSrcKey = function () {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
            return uid ? 'Symbol(src)_1.' + uid : '';
          }();

          /**
           * Used to resolve the
           * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
           * of values.
           */
          var nativeObjectToString = objectProto.toString;

          /** Used to infer the `Object` constructor. */
          var objectCtorString = funcToString.call(Object);

          /** Used to detect if a method is native. */
          var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

          /** Built-in value references. */
          var Buffer = moduleExports ? root.Buffer : undefined,
            Symbol = root.Symbol,
            Uint8Array = root.Uint8Array,
            allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
            getPrototype = overArg(Object.getPrototypeOf, Object),
            objectCreate = Object.create,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            splice = arrayProto.splice,
            symToStringTag = Symbol ? Symbol.toStringTag : undefined;
          var defineProperty = function () {
            try {
              var func = getNative(Object, 'defineProperty');
              func({}, '', {});
              return func;
            } catch (e) {}
          }();

          /* Built-in method references for those with the same name as other `lodash` methods. */
          var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
            nativeMax = Math.max,
            nativeNow = Date.now;

          /* Built-in method references that are verified to be native. */
          var Map = getNative(root, 'Map'),
            nativeCreate = getNative(Object, 'create');

          /**
           * The base implementation of `_.create` without support for assigning
           * properties to the created object.
           *
           * @private
           * @param {Object} proto The object to inherit from.
           * @returns {Object} Returns the new object.
           */
          var baseCreate = function () {
            function object() {}
            return function (proto) {
              if (!isObject(proto)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto);
              }
              object.prototype = proto;
              var result = new object();
              object.prototype = undefined;
              return result;
            };
          }();

          /**
           * Creates a hash object.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function Hash(entries) {
            var index = -1,
              length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }

          /**
           * Removes all key-value entries from the hash.
           *
           * @private
           * @name clear
           * @memberOf Hash
           */
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }

          /**
           * Removes `key` and its value from the hash.
           *
           * @private
           * @name delete
           * @memberOf Hash
           * @param {Object} hash The hash to modify.
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function hashDelete(key) {
            var result = this.has(key) && delete this.__data__[key];
            this.size -= result ? 1 : 0;
            return result;
          }

          /**
           * Gets the hash value for `key`.
           *
           * @private
           * @name get
           * @memberOf Hash
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result = data[key];
              return result === HASH_UNDEFINED ? undefined : result;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined;
          }

          /**
           * Checks if a hash value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf Hash
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
          }

          /**
           * Sets the hash `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf Hash
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the hash instance.
           */
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
            return this;
          }

          // Add methods to `Hash`.
          Hash.prototype.clear = hashClear;
          Hash.prototype['delete'] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;

          /**
           * Creates an list cache object.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function ListCache(entries) {
            var index = -1,
              length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }

          /**
           * Removes all key-value entries from the list cache.
           *
           * @private
           * @name clear
           * @memberOf ListCache
           */
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }

          /**
           * Removes `key` and its value from the list cache.
           *
           * @private
           * @name delete
           * @memberOf ListCache
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function listCacheDelete(key) {
            var data = this.__data__,
              index = assocIndexOf(data, key);
            if (index < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index, 1);
            }
            --this.size;
            return true;
          }

          /**
           * Gets the list cache value for `key`.
           *
           * @private
           * @name get
           * @memberOf ListCache
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function listCacheGet(key) {
            var data = this.__data__,
              index = assocIndexOf(data, key);
            return index < 0 ? undefined : data[index][1];
          }

          /**
           * Checks if a list cache value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf ListCache
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }

          /**
           * Sets the list cache `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf ListCache
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the list cache instance.
           */
          function listCacheSet(key, value) {
            var data = this.__data__,
              index = assocIndexOf(data, key);
            if (index < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index][1] = value;
            }
            return this;
          }

          // Add methods to `ListCache`.
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype['delete'] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;

          /**
           * Creates a map cache object to store key-value pairs.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function MapCache(entries) {
            var index = -1,
              length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }

          /**
           * Removes all key-value entries from the map.
           *
           * @private
           * @name clear
           * @memberOf MapCache
           */
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              'hash': new Hash(),
              'map': new (Map || ListCache)(),
              'string': new Hash()
            };
          }

          /**
           * Removes `key` and its value from the map.
           *
           * @private
           * @name delete
           * @memberOf MapCache
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function mapCacheDelete(key) {
            var result = getMapData(this, key)['delete'](key);
            this.size -= result ? 1 : 0;
            return result;
          }

          /**
           * Gets the map value for `key`.
           *
           * @private
           * @name get
           * @memberOf MapCache
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }

          /**
           * Checks if a map value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf MapCache
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }

          /**
           * Sets the map `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf MapCache
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the map cache instance.
           */
          function mapCacheSet(key, value) {
            var data = getMapData(this, key),
              size = data.size;
            data.set(key, value);
            this.size += data.size == size ? 0 : 1;
            return this;
          }

          // Add methods to `MapCache`.
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype['delete'] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;

          /**
           * Creates a stack cache object to store key-value pairs.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }

          /**
           * Removes all key-value entries from the stack.
           *
           * @private
           * @name clear
           * @memberOf Stack
           */
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }

          /**
           * Removes `key` and its value from the stack.
           *
           * @private
           * @name delete
           * @memberOf Stack
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function stackDelete(key) {
            var data = this.__data__,
              result = data['delete'](key);
            this.size = data.size;
            return result;
          }

          /**
           * Gets the stack value for `key`.
           *
           * @private
           * @name get
           * @memberOf Stack
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function stackGet(key) {
            return this.__data__.get(key);
          }

          /**
           * Checks if a stack value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf Stack
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function stackHas(key) {
            return this.__data__.has(key);
          }

          /**
           * Sets the stack `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf Stack
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the stack cache instance.
           */
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }

          // Add methods to `Stack`.
          Stack.prototype.clear = stackClear;
          Stack.prototype['delete'] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;

          /**
           * Creates an array of the enumerable property names of the array-like `value`.
           *
           * @private
           * @param {*} value The value to query.
           * @param {boolean} inherited Specify returning inherited property names.
           * @returns {Array} Returns the array of property names.
           */
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value),
              isArg = !isArr && isArguments(value),
              isBuff = !isArr && !isArg && isBuffer(value),
              isType = !isArr && !isArg && !isBuff && isTypedArray(value),
              skipIndexes = isArr || isArg || isBuff || isType,
              result = skipIndexes ? baseTimes(value.length, String) : [],
              length = result.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (
              // Safari 9 has enumerable `arguments.length` in strict mode.
              key == 'length' ||
              // Node.js 0.10 has enumerable non-index properties on buffers.
              isBuff && (key == 'offset' || key == 'parent') ||
              // PhantomJS 2 has enumerable non-index properties on typed arrays.
              isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
              // Skip index properties.
              isIndex(key, length)))) {
                result.push(key);
              }
            }
            return result;
          }

          /**
           * This function is like `assignValue` except that it doesn't assign
           * `undefined` values.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {string} key The key of the property to assign.
           * @param {*} value The value to assign.
           */
          function assignMergeValue(object, key, value) {
            if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }

          /**
           * Assigns `value` to `key` of `object` if the existing value is not equivalent
           * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {string} key The key of the property to assign.
           * @param {*} value The value to assign.
           */
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }

          /**
           * Gets the index at which the `key` is found in `array` of key-value pairs.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {*} key The key to search for.
           * @returns {number} Returns the index of the matched value, else `-1`.
           */
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }

          /**
           * The base implementation of `assignValue` and `assignMergeValue` without
           * value checks.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {string} key The key of the property to assign.
           * @param {*} value The value to assign.
           */
          function baseAssignValue(object, key, value) {
            if (key == '__proto__' && defineProperty) {
              defineProperty(object, key, {
                'configurable': true,
                'enumerable': true,
                'value': value,
                'writable': true
              });
            } else {
              object[key] = value;
            }
          }

          /**
           * The base implementation of `baseForOwn` which iterates over `object`
           * properties returned by `keysFunc` and invokes `iteratee` for each property.
           * Iteratee functions may exit iteration early by explicitly returning `false`.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {Function} keysFunc The function to get the keys of `object`.
           * @returns {Object} Returns `object`.
           */
          var baseFor = createBaseFor();

          /**
           * The base implementation of `getTag` without fallbacks for buggy environments.
           *
           * @private
           * @param {*} value The value to query.
           * @returns {string} Returns the `toStringTag`.
           */
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
          }

          /**
           * The base implementation of `_.isArguments`.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an `arguments` object,
           */
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }

          /**
           * The base implementation of `_.isNative` without bad shim checks.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a native function,
           *  else `false`.
           */
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }

          /**
           * The base implementation of `_.isTypedArray` without Node.js optimizations.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
           */
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }

          /**
           * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           */
          function baseKeysIn(object) {
            if (!isObject(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype(object),
              result = [];
            for (var key in object) {
              if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                result.push(key);
              }
            }
            return result;
          }

          /**
           * The base implementation of `_.merge` without support for multiple sources.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @param {number} srcIndex The index of `source`.
           * @param {Function} [customizer] The function to customize merged values.
           * @param {Object} [stack] Tracks traversed source values and their merged
           *  counterparts.
           */
          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return;
            }
            baseFor(source, function (srcValue, key) {
              stack || (stack = new Stack());
              if (isObject(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;
                if (newValue === undefined) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key, newValue);
              }
            }, keysIn);
          }

          /**
           * A specialized version of `baseMerge` for arrays and objects which performs
           * deep merges and tracks traversed objects enabling objects with circular
           * references to be merged.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @param {string} key The key of the value to merge.
           * @param {number} srcIndex The index of `source`.
           * @param {Function} mergeFunc The function to merge values.
           * @param {Function} [customizer] The function to customize assigned values.
           * @param {Object} [stack] Tracks traversed source values and their merged
           *  counterparts.
           */
          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key),
              srcValue = safeGet(source, key),
              stacked = stack.get(srcValue);
            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
            var isCommon = newValue === undefined;
            if (isCommon) {
              var isArr = isArray(srcValue),
                isBuff = !isArr && isBuffer(srcValue),
                isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                newValue = objValue;
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject(objValue) || isFunction(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              // Recursively merge objects and arrays (susceptible to call stack limits).
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack['delete'](srcValue);
            }
            assignMergeValue(object, key, newValue);
          }

          /**
           * The base implementation of `_.rest` which doesn't validate or coerce arguments.
           *
           * @private
           * @param {Function} func The function to apply a rest parameter to.
           * @param {number} [start=func.length-1] The start position of the rest parameter.
           * @returns {Function} Returns the new function.
           */
          function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + '');
          }

          /**
           * The base implementation of `setToString` without support for hot loop shorting.
           *
           * @private
           * @param {Function} func The function to modify.
           * @param {Function} string The `toString` result.
           * @returns {Function} Returns `func`.
           */
          var baseSetToString = !defineProperty ? identity : function (func, string) {
            return defineProperty(func, 'toString', {
              'configurable': true,
              'enumerable': false,
              'value': constant(string),
              'writable': true
            });
          };

          /**
           * Creates a clone of  `buffer`.
           *
           * @private
           * @param {Buffer} buffer The buffer to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Buffer} Returns the cloned buffer.
           */
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }
            var length = buffer.length,
              result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            buffer.copy(result);
            return result;
          }

          /**
           * Creates a clone of `arrayBuffer`.
           *
           * @private
           * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
           * @returns {ArrayBuffer} Returns the cloned array buffer.
           */
          function cloneArrayBuffer(arrayBuffer) {
            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array(result).set(new Uint8Array(arrayBuffer));
            return result;
          }

          /**
           * Creates a clone of `typedArray`.
           *
           * @private
           * @param {Object} typedArray The typed array to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Object} Returns the cloned typed array.
           */
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }

          /**
           * Copies the values of `source` to `array`.
           *
           * @private
           * @param {Array} source The array to copy values from.
           * @param {Array} [array=[]] The array to copy values to.
           * @returns {Array} Returns `array`.
           */
          function copyArray(source, array) {
            var index = -1,
              length = source.length;
            array || (array = Array(length));
            while (++index < length) {
              array[index] = source[index];
            }
            return array;
          }

          /**
           * Copies properties of `source` to `object`.
           *
           * @private
           * @param {Object} source The object to copy properties from.
           * @param {Array} props The property identifiers to copy.
           * @param {Object} [object={}] The object to copy properties to.
           * @param {Function} [customizer] The function to customize copied values.
           * @returns {Object} Returns `object`.
           */
          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1,
              length = props.length;
            while (++index < length) {
              var key = props[index];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
              if (newValue === undefined) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }
            return object;
          }

          /**
           * Creates a function like `_.assign`.
           *
           * @private
           * @param {Function} assigner The function to assign values.
           * @returns {Function} Returns the new assigner function.
           */
          function createAssigner(assigner) {
            return baseRest(function (object, sources) {
              var index = -1,
                length = sources.length,
                customizer = length > 1 ? sources[length - 1] : undefined,
                guard = length > 2 ? sources[2] : undefined;
              customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined : customizer;
                length = 1;
              }
              object = Object(object);
              while (++index < length) {
                var source = sources[index];
                if (source) {
                  assigner(object, source, index, customizer);
                }
              }
              return object;
            });
          }

          /**
           * Creates a base function for methods like `_.forIn` and `_.forOwn`.
           *
           * @private
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new base function.
           */
          function createBaseFor(fromRight) {
            return function (object, iteratee, keysFunc) {
              var index = -1,
                iterable = Object(object),
                props = keysFunc(object),
                length = props.length;
              while (length--) {
                var key = props[fromRight ? length : ++index];
                if (iteratee(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }

          /**
           * Gets the data for `map`.
           *
           * @private
           * @param {Object} map The map to query.
           * @param {string} key The reference key.
           * @returns {*} Returns the map data.
           */
          function getMapData(map, key) {
            var data = map.__data__;
            return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
          }

          /**
           * Gets the native function at `key` of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {string} key The key of the method to get.
           * @returns {*} Returns the function if it's native, else `undefined`.
           */
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined;
          }

          /**
           * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
           *
           * @private
           * @param {*} value The value to query.
           * @returns {string} Returns the raw `toStringTag`.
           */
          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag),
              tag = value[symToStringTag];
            try {
              value[symToStringTag] = undefined;
              var unmasked = true;
            } catch (e) {}
            var result = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result;
          }

          /**
           * Initializes an object clone.
           *
           * @private
           * @param {Object} object The object to clone.
           * @returns {Object} Returns the initialized clone.
           */
          function initCloneObject(object) {
            return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
          }

          /**
           * Checks if `value` is a valid array-like index.
           *
           * @private
           * @param {*} value The value to check.
           * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
           * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
           */
          function isIndex(value, length) {
            var type = typeof value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
          }

          /**
           * Checks if the given arguments are from an iteratee call.
           *
           * @private
           * @param {*} value The potential iteratee value argument.
           * @param {*} index The potential iteratee index or key argument.
           * @param {*} object The potential iteratee object argument.
           * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
           *  else `false`.
           */
          function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
              return false;
            }
            var type = typeof index;
            if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
              return eq(object[index], value);
            }
            return false;
          }

          /**
           * Checks if `value` is suitable for use as unique object key.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
           */
          function isKeyable(value) {
            var type = typeof value;
            return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
          }

          /**
           * Checks if `func` has its source masked.
           *
           * @private
           * @param {Function} func The function to check.
           * @returns {boolean} Returns `true` if `func` is masked, else `false`.
           */
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }

          /**
           * Checks if `value` is likely a prototype object.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
           */
          function isPrototype(value) {
            var Ctor = value && value.constructor,
              proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
            return value === proto;
          }

          /**
           * This function is like
           * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
           * except that it includes inherited enumerable properties.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           */
          function nativeKeysIn(object) {
            var result = [];
            if (object != null) {
              for (var key in Object(object)) {
                result.push(key);
              }
            }
            return result;
          }

          /**
           * Converts `value` to a string using `Object.prototype.toString`.
           *
           * @private
           * @param {*} value The value to convert.
           * @returns {string} Returns the converted string.
           */
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }

          /**
           * A specialized version of `baseRest` which transforms the rest array.
           *
           * @private
           * @param {Function} func The function to apply a rest parameter to.
           * @param {number} [start=func.length-1] The start position of the rest parameter.
           * @param {Function} transform The rest array transform.
           * @returns {Function} Returns the new function.
           */
          function overRest(func, start, transform) {
            start = nativeMax(start === undefined ? func.length - 1 : start, 0);
            return function () {
              var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                array = Array(length);
              while (++index < length) {
                array[index] = args[start + index];
              }
              index = -1;
              var otherArgs = Array(start + 1);
              while (++index < start) {
                otherArgs[index] = args[index];
              }
              otherArgs[start] = transform(array);
              return apply(func, this, otherArgs);
            };
          }

          /**
           * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
           *
           * @private
           * @param {Object} object The object to query.
           * @param {string} key The key of the property to get.
           * @returns {*} Returns the property value.
           */
          function safeGet(object, key) {
            if (key === 'constructor' && typeof object[key] === 'function') {
              return;
            }
            if (key == '__proto__') {
              return;
            }
            return object[key];
          }

          /**
           * Sets the `toString` method of `func` to return `string`.
           *
           * @private
           * @param {Function} func The function to modify.
           * @param {Function} string The `toString` result.
           * @returns {Function} Returns `func`.
           */
          var setToString = shortOut(baseSetToString);

          /**
           * Creates a function that'll short out and invoke `identity` instead
           * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
           * milliseconds.
           *
           * @private
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new shortable function.
           */
          function shortOut(func) {
            var count = 0,
              lastCalled = 0;
            return function () {
              var stamp = nativeNow(),
                remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined, arguments);
            };
          }

          /**
           * Converts `func` to its source code.
           *
           * @private
           * @param {Function} func The function to convert.
           * @returns {string} Returns the source code.
           */
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {}
              try {
                return func + '';
              } catch (e) {}
            }
            return '';
          }

          /**
           * Performs a
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * comparison between two values to determine if they are equivalent.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           * @example
           *
           * var object = { 'a': 1 };
           * var other = { 'a': 1 };
           *
           * _.eq(object, object);
           * // => true
           *
           * _.eq(object, other);
           * // => false
           *
           * _.eq('a', 'a');
           * // => true
           *
           * _.eq('a', Object('a'));
           * // => false
           *
           * _.eq(NaN, NaN);
           * // => true
           */
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }

          /**
           * Checks if `value` is likely an `arguments` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an `arguments` object,
           *  else `false`.
           * @example
           *
           * _.isArguments(function() { return arguments; }());
           * // => true
           *
           * _.isArguments([1, 2, 3]);
           * // => false
           */
          var isArguments = baseIsArguments(function () {
            return arguments;
          }()) ? baseIsArguments : function (value) {
            return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
          };

          /**
           * Checks if `value` is classified as an `Array` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an array, else `false`.
           * @example
           *
           * _.isArray([1, 2, 3]);
           * // => true
           *
           * _.isArray(document.body.children);
           * // => false
           *
           * _.isArray('abc');
           * // => false
           *
           * _.isArray(_.noop);
           * // => false
           */
          var isArray = Array.isArray;

          /**
           * Checks if `value` is array-like. A value is considered array-like if it's
           * not a function and has a `value.length` that's an integer greater than or
           * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
           * @example
           *
           * _.isArrayLike([1, 2, 3]);
           * // => true
           *
           * _.isArrayLike(document.body.children);
           * // => true
           *
           * _.isArrayLike('abc');
           * // => true
           *
           * _.isArrayLike(_.noop);
           * // => false
           */
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
          }

          /**
           * This method is like `_.isArrayLike` except that it also checks if `value`
           * is an object.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an array-like object,
           *  else `false`.
           * @example
           *
           * _.isArrayLikeObject([1, 2, 3]);
           * // => true
           *
           * _.isArrayLikeObject(document.body.children);
           * // => true
           *
           * _.isArrayLikeObject('abc');
           * // => false
           *
           * _.isArrayLikeObject(_.noop);
           * // => false
           */
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }

          /**
           * Checks if `value` is a buffer.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
           * @example
           *
           * _.isBuffer(new Buffer(2));
           * // => true
           *
           * _.isBuffer(new Uint8Array(2));
           * // => false
           */
          var isBuffer = nativeIsBuffer || stubFalse;

          /**
           * Checks if `value` is classified as a `Function` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a function, else `false`.
           * @example
           *
           * _.isFunction(_);
           * // => true
           *
           * _.isFunction(/abc/);
           * // => false
           */
          function isFunction(value) {
            if (!isObject(value)) {
              return false;
            }
            // The use of `Object#toString` avoids issues with the `typeof` operator
            // in Safari 9 which returns 'object' for typed arrays and other constructors.
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }

          /**
           * Checks if `value` is a valid array-like length.
           *
           * **Note:** This method is loosely based on
           * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
           * @example
           *
           * _.isLength(3);
           * // => true
           *
           * _.isLength(Number.MIN_VALUE);
           * // => false
           *
           * _.isLength(Infinity);
           * // => false
           *
           * _.isLength('3');
           * // => false
           */
          function isLength(value) {
            return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }

          /**
           * Checks if `value` is the
           * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
           * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an object, else `false`.
           * @example
           *
           * _.isObject({});
           * // => true
           *
           * _.isObject([1, 2, 3]);
           * // => true
           *
           * _.isObject(_.noop);
           * // => true
           *
           * _.isObject(null);
           * // => false
           */
          function isObject(value) {
            var type = typeof value;
            return value != null && (type == 'object' || type == 'function');
          }

          /**
           * Checks if `value` is object-like. A value is object-like if it's not `null`
           * and has a `typeof` result of "object".
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
           * @example
           *
           * _.isObjectLike({});
           * // => true
           *
           * _.isObjectLike([1, 2, 3]);
           * // => true
           *
           * _.isObjectLike(_.noop);
           * // => false
           *
           * _.isObjectLike(null);
           * // => false
           */
          function isObjectLike(value) {
            return value != null && typeof value == 'object';
          }

          /**
           * Checks if `value` is a plain object, that is, an object created by the
           * `Object` constructor or one with a `[[Prototype]]` of `null`.
           *
           * @static
           * @memberOf _
           * @since 0.8.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           * }
           *
           * _.isPlainObject(new Foo);
           * // => false
           *
           * _.isPlainObject([1, 2, 3]);
           * // => false
           *
           * _.isPlainObject({ 'x': 0, 'y': 0 });
           * // => true
           *
           * _.isPlainObject(Object.create(null));
           * // => true
           */
          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
            return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }

          /**
           * Checks if `value` is classified as a typed array.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
           * @example
           *
           * _.isTypedArray(new Uint8Array);
           * // => true
           *
           * _.isTypedArray([]);
           * // => false
           */
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

          /**
           * Converts `value` to a plain object flattening inherited enumerable string
           * keyed properties of `value` to own properties of the plain object.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {Object} Returns the converted plain object.
           * @example
           *
           * function Foo() {
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.assign({ 'a': 1 }, new Foo);
           * // => { 'a': 1, 'b': 2 }
           *
           * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
           * // => { 'a': 1, 'b': 2, 'c': 3 }
           */
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }

          /**
           * Creates an array of the own and inherited enumerable property names of `object`.
           *
           * **Note:** Non-object values are coerced to objects.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.keysIn(new Foo);
           * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
           */
          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
          }

          /**
           * This method is like `_.assign` except that it recursively merges own and
           * inherited enumerable string keyed properties of source objects into the
           * destination object. Source properties that resolve to `undefined` are
           * skipped if a destination value exists. Array and plain object properties
           * are merged recursively. Other objects and value types are overridden by
           * assignment. Source objects are applied from left to right. Subsequent
           * sources overwrite property assignments of previous sources.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 0.5.0
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var object = {
           *   'a': [{ 'b': 2 }, { 'd': 4 }]
           * };
           *
           * var other = {
           *   'a': [{ 'c': 3 }, { 'e': 5 }]
           * };
           *
           * _.merge(object, other);
           * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
           */
          var merge = createAssigner(function (object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });

          /**
           * Creates a function that returns `value`.
           *
           * @static
           * @memberOf _
           * @since 2.4.0
           * @category Util
           * @param {*} value The value to return from the new function.
           * @returns {Function} Returns the new constant function.
           * @example
           *
           * var objects = _.times(2, _.constant({ 'a': 1 }));
           *
           * console.log(objects);
           * // => [{ 'a': 1 }, { 'a': 1 }]
           *
           * console.log(objects[0] === objects[1]);
           * // => true
           */
          function constant(value) {
            return function () {
              return value;
            };
          }

          /**
           * This method returns the first argument it receives.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @param {*} value Any value.
           * @returns {*} Returns `value`.
           * @example
           *
           * var object = { 'a': 1 };
           *
           * console.log(_.identity(object) === object);
           * // => true
           */
          function identity(value) {
            return value;
          }

          /**
           * This method returns `false`.
           *
           * @static
           * @memberOf _
           * @since 4.13.0
           * @category Util
           * @returns {boolean} Returns `false`.
           * @example
           *
           * _.times(2, _.stubFalse);
           * // => [false, false]
           */
          function stubFalse() {
            return false;
          }
          module.exports = merge;
        })(lodash_merge, lodash_merge.exports);
        var lodash_mergeExports = lodash_merge.exports;
        const merge = /*@__PURE__*/getDefaultExportFromCjs(lodash_mergeExports);
        const InitialConfig = MuiConfig;
        const wrapField = field => {
          return '<span class="logicField">' + field + "</span>";
        };
        const wrapOperator = op => {
          return '<span class="logicOp">' + op + "</span>";
        };
        const wrapValue = (value, valueTypes) => {
          return '<span class="logicValue">' + (valueTypes == "text" ? '"' + value + '"' : value) + "</span>";
        };
        const conjunctions = {
          AND: InitialConfig.conjunctions.AND,
          OR: InitialConfig.conjunctions.OR
        };
        const operators = {
          ...InitialConfig.operators,
          less: {
            ...InitialConfig.operators.less,
            formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
              return `${wrapField(field)} ${wrapOperator("<")} ${wrapValue(value, valueTypes)}`;
            }
          },
          less_or_equal: {
            ...InitialConfig.operators.less_or_equal,
            formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
              return `${wrapField(field)} ${wrapOperator("<=")} ${wrapValue(value, valueTypes)}`;
            }
          },
          greater: {
            ...InitialConfig.operators.greater,
            formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
              return `${wrapField(field)} ${wrapOperator(">")} ${wrapValue(value, valueTypes)}`;
            }
          },
          greater_or_equal: {
            ...InitialConfig.operators.greater_or_equal,
            formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
              return `${wrapField(field)} ${wrapOperator(">=")} ${wrapValue(value, valueTypes)}`;
            }
          },
          equal: {
            ...InitialConfig.operators.equal,
            label: "Equals",
            jsonLogic: "==",
            formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
              const opStr = isForDisplay ? "equals" : opDef.label;
              return `${wrapField(field)} ${wrapOperator(opStr)} ${wrapValue(value, valueTypes)}`;
            }
          },
          not_equal: {
            ...InitialConfig.operators.not_equal,
            label: "Not Equals",
            jsonLogic: "!=",
            formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
              const opStr = isForDisplay ? "not equals" : opDef.label;
              return `${wrapField(field)} ${wrapOperator(opStr)} ${wrapValue(value, valueTypes)}`;
            }
          },
          starts_with: {
            ...InitialConfig.operators.starts_with,
            jsonLogic: "startsWith",
            formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
              const opStr = isForDisplay ? "starts with" : opDef.label;
              return `${wrapField(field)} ${wrapOperator(opStr)} ${wrapValue(value, valueTypes)}`;
            }
          },
          ends_with: {
            ...InitialConfig.operators.ends_with,
            jsonLogic: "endsWith",
            formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
              const opStr = isForDisplay ? "ends with" : opDef.label;
              return `${wrapField(field)} ${wrapOperator(opStr)} ${wrapValue(value, valueTypes)}`;
            }
          },
          between: {
            ...InitialConfig.operators.between,
            label: "Between",
            jsonLogic: "between",
            formatOp: (field, op, values, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay) => {
              let valFrom = values.first();
              let valTo = values.get(1);
              if (isForDisplay) return `${wrapField(field)} ${wrapOperator("between")} ${wrapValue(valFrom, valueTypes)} ${wrapOperator("and")} ${wrapValue(valTo, valueTypes)}`;else return `${field} >= ${valFrom} && ${field} <= ${valTo}`;
            }
          },
          not_between: {
            ...InitialConfig.operators.not_between,
            label: "Not Between",
            jsonLogic: "not_between",
            formatOp: (field, op, values, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay) => {
              let valFrom = values.first();
              let valTo = values.get(1);
              if (isForDisplay) return `${wrapField(field)} ${wrapOperator("not between")} ${wrapValue(valFrom, valueTypes)} ${wrapOperator("and")} ${wrapValue(valTo, valueTypes)}`;else return `${field} >= ${valFrom} && ${field} <= ${valTo}`;
            }
          },
          like: {
            ...InitialConfig.operators.like,
            label: "Contains",
            jsonLogic: "contains",
            _jsonLogicIsRevArgs: false,
            formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
              const opStr = isForDisplay ? "contains" : opDef.label;
              return `${wrapField(field)} ${wrapOperator(opStr)} ${wrapValue(value, valueTypes)}`;
            }
          },
          not_like: {
            ...InitialConfig.operators.not_like,
            label: "Not Contains",
            jsonLogic: "not_contains",
            formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
              const opStr = isForDisplay ? "does not containends with" : opDef.label;
              return `${wrapField(field)} ${wrapOperator(opStr)} ${wrapValue(value, valueTypes)}`;
            }
          },
          select_any_in: {
            ...InitialConfig.operators.select_any_in,
            label: "Any In",
            jsonLogic: "in",
            formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
              let formattedValues = values.join(", ");
              return `${wrapField(field)} ${wrapOperator("in")} (${wrapValue(formattedValues, "")})`;
            }
          },
          select_not_any_in: {
            ...InitialConfig.operators.select_not_any_in,
            label: "None In",
            jsonLogic: "not_in",
            formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
              let formattedValues = values.join(", ");
              return `${wrapField(field)} ${wrapOperator("not in")} (${wrapValue(formattedValues, "")})`;
            }
          },
          multiselect_equals: {
            ...InitialConfig.operators.multiselect_equals,
            label: "Any In",
            jsonLogic: "any_in",
            formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
              let formattedValues = values.join(", ");
              return `${wrapOperator("Any of")} (${wrapValue(formattedValues, "")}) in ${wrapField(field)} ${wrapOperator("is selected")}`;
            }
          },
          multiselect_not_equals: {
            ...InitialConfig.operators.multiselect_not_equals,
            label: "None In",
            jsonLogic: "none_in",
            formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
              let formattedValues = values.join(", ");
              return `${wrapOperator("None of")} (${wrapValue(formattedValues, "")}) in ${wrapField(field)} ${wrapOperator("is selected")}`;
            }
          },
          is_relevant: {
            label: "Is Displayed",
            jsonLogic: "relevance",
            cardinality: 0,
            formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
              return `${wrapField(field)} ${wrapValue("is shown")}`;
            }
          },
          is_not_relevant: {
            label: "Is Hidden",
            jsonLogic: "not_relevance",
            cardinality: 0,
            formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
              return `${wrapField(field)} ${wrapValue("is not shown")}`;
            }
          },
          is_valid: {
            label: "Is Valid",
            jsonLogic: "validity",
            cardinality: 0,
            formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
              return `${wrapField(field)} ${wrapValue("is valid")}`;
            }
          },
          is_not_valid: {
            label: "Is Not Valid",
            jsonLogic: "not_validity",
            cardinality: 0,
            formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
              return `${wrapField(field)} ${wrapValue("is not valid")}`;
            }
          },
          is_void: {
            cardinality: 0,
            label: "Is Empty",
            jsonLogic: "is_void",
            formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
              return `${wrapField(field)} ${wrapValue("is empty")}`;
            }
          },
          is_not_void: {
            cardinality: 0,
            label: "Is not Empty",
            jsonLogic: "is_not_void",
            formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
              return `${wrapField(field)} ${wrapValue("is not empty")}`;
            }
          },
          is_file_void: {
            cardinality: 0,
            label: "Is Empty",
            jsonLogic: "is_file_void",
            formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
              return `${wrapField(field)} ${wrapValue("is empty")}`;
            }
          },
          is_file_not_void: {
            cardinality: 0,
            label: "Is not Empty",
            jsonLogic: "is_file_not_void",
            formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
              return `${wrapField(field)} ${wrapValue("is not empty")}`;
            }
          }
        };
        const widgets = {
          ...InitialConfig.widgets,
          // examples of  overriding
          text: {
            ...InitialConfig.widgets.text
          },
          slider: {
            ...InitialConfig.widgets.slider,
            customProps: {
              width: "300px"
            }
          },
          rangeslider: {
            ...InitialConfig.widgets.rangeslider,
            customProps: {
              width: "300px"
            }
          },
          date: {
            ...InitialConfig.widgets.date,
            dateFormat: "DD.MM.YYYY",
            valueFormat: "YYYY-MM-DD"
          },
          time: {
            ...InitialConfig.widgets.time,
            timeFormat: "HH:mm",
            valueFormat: "HH:mm:ss"
          },
          datetime: {
            ...InitialConfig.widgets.datetime,
            timeFormat: "HH:mm",
            dateFormat: "DD.MM.YYYY",
            valueFormat: "YYYY-MM-DD HH:mm:ss"
          },
          func: {
            ...InitialConfig.widgets.func,
            customProps: {
              showSearch: true
            }
          },
          treeselect: {
            ...InitialConfig.widgets.treeselect,
            customProps: {
              showSearch: true
            }
          }
        };
        const types = {
          ...InitialConfig.types,
          boolean: merge(InitialConfig.types.boolean, {
            widgets: {
              boolean: {
                widgetProps: {
                  hideOperator: true,
                  operatorInlineLabel: "is"
                }
              }
            }
          })
        };
        const localeSettings = {
          valueLabel: "Value",
          valuePlaceholder: "Value",
          fieldLabel: "Field",
          operatorLabel: "Operator",
          fieldPlaceholder: "Select field",
          operatorPlaceholder: "Select operator",
          deleteLabel: null,
          addGroupLabel: "Add group",
          addRuleLabel: "Add rule",
          addSubRuleLabel: "Add sub rule",
          delGroupLabel: null,
          notLabel: "Not",
          valueSourcesPopupTitle: "Select value source",
          removeRuleConfirmOptions: {
            title: "Are you sure delete this rule?",
            okText: "Yes",
            okType: "danger"
          },
          removeGroupConfirmOptions: {
            title: "Are you sure delete this group?",
            okText: "Yes",
            okType: "danger"
          }
        };
        const settings = {
          ...InitialConfig.settings,
          ...localeSettings,
          valueSourcesInfo: {
            value: {
              label: "Value"
            },
            field: {
              label: "Field",
              widget: "field"
            },
            func: {
              label: "Function",
              widget: "func"
            }
          },
          canReorder: false,
          showNot: false,
          maxNesting: 1,
          canLeaveEmptyGroup: false
          //after deletion
        };

        const funcs = {};
        const config = {
          conjunctions,
          operators,
          widgets,
          types,
          settings,
          funcs
        };
        const styles$b = '';
        const override = '';
        function LogicBuilder(props) {
          const {
            jsonLogicFormat,
            queryString,
            loadTree,
            uuid,
            loadFromJsonLogic,
            checkTree
          } = Utils;
          const config$1 = {
            ...config,
            fields: props.fields
          };
          const initTree = props.logic ? checkTree(loadFromJsonLogic(props.logic, config$1), config$1) : loadTree({
            id: uuid(),
            type: "group"
          });
          const [tree, setTree] = reactExports.useState(initTree);
          const [html, setHtml] = reactExports.useState(queryString(tree, config$1, true));
          const renderBuilder = props2 => /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            jey: "builder",
            className: "query-builder-container",
            children: /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: "query-builder",
              children: /* @__PURE__ */jsxRuntimeExports.jsx(Builder$1, {
                ...props2
              })
            })
          });
          const onChange = immutableTree => {
            setTree(immutableTree);
          };
          const saveState = () => {
            const {
              logic,
              errors
            } = jsonLogicFormat(tree, config$1);
            setHtml(queryString(tree, config$1, true));
            props.onChange(logic);
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: "query-builder-result",
              children: [props.logic && html ? /* @__PURE__ */jsxRuntimeExports.jsx("pre", {
                className: "condition-human-text",
                dangerouslySetInnerHTML: {
                  __html: html
                }
              }) : /* @__PURE__ */jsxRuntimeExports.jsx("pre", {
                className: "condition-human-text",
                children: props.t("no_condition")
              }), /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                onClick: () => props.onDialogStateChanged(true),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(EditOutlined, {})
              })]
            }, "result"), /* @__PURE__ */jsxRuntimeExports.jsxs(Dialog, {
              fullScreen: true,
              sx: {
                margin: "200px"
              },
              open: props.dialogOpen,
              onClose: () => props.onDialogStateChanged(false),
              "aria-labelledby": "alert-dialog-title-logic-builder",
              "aria-describedby": "alert-dialog-description",
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(DialogTitle, {
                id: "alert-dialog-title-logic-builder",
                children: props.title
              }), /* @__PURE__ */jsxRuntimeExports.jsx(DialogContent, {
                children: /* @__PURE__ */jsxRuntimeExports.jsx(QueryContainer, {
                  ...config$1,
                  value: tree,
                  onChange,
                  renderBuilder
                })
              }), /* @__PURE__ */jsxRuntimeExports.jsx(DialogActions, {
                children: /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                  onClick: () => {
                    props.onDialogStateChanged(false);
                    saveState();
                  },
                  autoFocus: true,
                  children: "Agree"
                })
              })]
            })]
          });
        }
        const buildFields = (componentIndices, code, state, mainLang) => {
          let dependencies = accessibleDependencies(componentIndices, code);
          let returnResult = {};
          dependencies.forEach(el => {
            if (state[el] && (isQuestion(el) || isGroup(el))) {
              returnResult = {
                ...returnResult,
                ...buildField$1(el, state[el], state, mainLang)
              };
            }
          });
          return returnResult;
        };
        const buildField$1 = (code, component, state, mainLang) => {
          var _component$content2, _component$content2$l, _component$children, _component$children2, _state$scqOther$quali, _component$children3, _component$children4, _state$mcqOther$quali, _component$children5, _component$children6, _component$children7, _component$children8;
          const label = code + ". " + stripTags((_component$content2 = component.content) === null || _component$content2 === void 0 ? void 0 : (_component$content2$l = _component$content2.label) === null || _component$content2$l === void 0 ? void 0 : _component$content2$l[mainLang]);
          if (isGroup(code)) {
            return {
              [code]: {
                label,
                type: "text",
                valueSources: ["value"],
                operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid"]
              }
            };
          }
          switch (component.type) {
            case "text":
            case "email":
              return {
                [code]: {
                  label,
                  type: "text",
                  valueSources: ["value"],
                  operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid", "is_void", "is_not_void", "equal", "not_equal", "like", "not_like", "starts_with", "ends_with"]
                }
              };
            case "paragraph":
              return {
                [code]: {
                  label,
                  type: "text",
                  valueSources: ["value"],
                  operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid", "is_void", "is_not_void", "like", "not_like", "starts_with", "ends_with"]
                }
              };
            case "number":
              return {
                [code]: {
                  label,
                  type: "number",
                  valueSources: ["value"],
                  operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid", "is_void", "is_not_void", "equal", "not_equal", "less", "less_or_equal", "greater", "greater_or_equal", "between", "not_between"]
                }
              };
            case "file_upload":
              return {
                [code]: {
                  label,
                  type: "text",
                  valueSources: ["value"],
                  operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid", "is_file_void", "is_file_not_void"]
                }
              };
            case "signature":
            case "photo_capture":
            case "video_capture":
              return {
                [code]: {
                  label,
                  type: "text",
                  valueSources: ["value"],
                  operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid", "is_file_void", "is_file_not_void"]
                }
              };
            case "date":
              return {
                [code]: {
                  label,
                  type: "date",
                  valueSources: ["value"],
                  operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid", "is_void", "is_not_void", "greater_or_equal", "less_or_equal", "between"]
                }
              };
            case "time":
              return {
                [code]: {
                  label,
                  type: "time",
                  valueSources: ["value"],
                  operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid", "is_void", "is_not_void", "greater_or_equal", "less_or_equal", "between"]
                }
              };
            case "date_time":
              return {
                [code]: {
                  label,
                  type: "datetime",
                  valueSources: ["value"],
                  operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid", "is_void", "is_not_void", "greater_or_equal", "less_or_equal", "between"]
                }
              };
            case "image_scq":
            case "scq":
              let scqReturnList = {};
              let scqListValues = {};
              (_component$children = component.children) === null || _component$children === void 0 ? void 0 : _component$children.forEach(element => {
                var _state$element$qualif3, _state$element$qualif4;
                scqListValues[element.code] = stripTags((_state$element$qualif3 = state[element.qualifiedCode].content) === null || _state$element$qualif3 === void 0 ? void 0 : (_state$element$qualif4 = _state$element$qualif3.label) === null || _state$element$qualif4 === void 0 ? void 0 : _state$element$qualif4[mainLang]);
              });
              scqReturnList[code] = {
                label,
                fieldSettings: {
                  listValues: scqListValues
                },
                type: "select",
                valueSources: ["value"],
                operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid", "is_void", "is_not_void", "select_any_in", "select_not_any_in"]
              };
              let scqOther = (_component$children2 = component.children) === null || _component$children2 === void 0 ? void 0 : _component$children2.find(el => el.code === "Aother");
              if (scqOther && (_state$scqOther$quali = state[scqOther.qualifiedCode].children) !== null && _state$scqOther$quali !== void 0 && _state$scqOther$quali.find(el => el.code === "Atext")) {
                var _state$scqOther$quali2, _state$scqOther$quali3;
                scqReturnList[code + "AotherAtext"] = {
                  label: `${label} [${(_state$scqOther$quali2 = state[scqOther.qualifiedCode].content) === null || _state$scqOther$quali2 === void 0 ? void 0 : (_state$scqOther$quali3 = _state$scqOther$quali2.label) === null || _state$scqOther$quali3 === void 0 ? void 0 : _state$scqOther$quali3[mainLang]}]`,
                  type: "text",
                  valueSources: ["value"],
                  operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid", "is_void", "is_not_void", "equal", "not_equal", "like", "not_like", "starts_with", "ends_with"]
                };
              }
              return scqReturnList;
            case "image_mcq":
            case "mcq":
              let mcqReturnList = {};
              let mcqListValues = {};
              (_component$children3 = component.children) === null || _component$children3 === void 0 ? void 0 : _component$children3.forEach(element => {
                var _state$element$qualif5, _state$element$qualif6;
                mcqListValues[element.code] = stripTags((_state$element$qualif5 = state[element.qualifiedCode].content) === null || _state$element$qualif5 === void 0 ? void 0 : (_state$element$qualif6 = _state$element$qualif5.label) === null || _state$element$qualif6 === void 0 ? void 0 : _state$element$qualif6[mainLang]);
              });
              mcqReturnList[code] = {
                label,
                fieldSettings: {
                  listValues: mcqListValues
                },
                type: "multiselect",
                valueSources: ["value"],
                operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid", "multiselect_equals", "multiselect_not_equals"]
              };
              let mcqOther = (_component$children4 = component.children) === null || _component$children4 === void 0 ? void 0 : _component$children4.find(el => el.code === "Aother");
              if (mcqOther && (_state$mcqOther$quali = state[mcqOther.qualifiedCode].children) !== null && _state$mcqOther$quali !== void 0 && _state$mcqOther$quali.find(el => el.code === "Atext")) {
                var _state$mcqOther$quali2, _state$mcqOther$quali3;
                mcqReturnList[code + "AotherAtext"] = {
                  label: `${label} [${(_state$mcqOther$quali2 = state[mcqOther.qualifiedCode].content) === null || _state$mcqOther$quali2 === void 0 ? void 0 : (_state$mcqOther$quali3 = _state$mcqOther$quali2.label) === null || _state$mcqOther$quali3 === void 0 ? void 0 : _state$mcqOther$quali3[mainLang]}]`,
                  type: "text",
                  valueSources: ["value"],
                  operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid", "is_void", "is_not_void", "equal", "not_equal", "like", "not_like", "starts_with", "ends_with"]
                };
              }
              return mcqReturnList;
            case "nps":
              let npsReturnList = {};
              (_component$children5 = component.children) === null || _component$children5 === void 0 ? void 0 : _component$children5.forEach(element => {
                var _state$element$qualif7, _state$element$qualif8;
                mcqListValues[element.code] = stripTags((_state$element$qualif7 = state[element.qualifiedCode].content) === null || _state$element$qualif7 === void 0 ? void 0 : (_state$element$qualif8 = _state$element$qualif7.label) === null || _state$element$qualif8 === void 0 ? void 0 : _state$element$qualif8[mainLang]);
              });
              npsReturnList[code] = {
                label,
                fieldSettings: {
                  min: 0,
                  max: 10
                },
                type: "number",
                valueSources: ["value"],
                operators: ["is_void", "is_not_void", "equal", "not_equal", "less", "less_or_equal", "greater", "greater_or_equal", "between", "not_between"]
              };
              return npsReturnList;
            case "scq_array":
              let scqArrayReturnList = {};
              let scqArrayListValues = {};
              (_component$children6 = component.children) === null || _component$children6 === void 0 ? void 0 : _component$children6.filter(el => el.type == "column").forEach(element => {
                var _state$element$qualif9, _state$element$qualif10;
                scqArrayListValues[element.code] = stripTags((_state$element$qualif9 = state[element.qualifiedCode].content) === null || _state$element$qualif9 === void 0 ? void 0 : (_state$element$qualif10 = _state$element$qualif9.label) === null || _state$element$qualif10 === void 0 ? void 0 : _state$element$qualif10[mainLang]);
              });
              scqArrayReturnList[code] = {
                label,
                type: "text",
                valueSources: ["value"],
                operators: ["is_relevant", "is_not_relevant", "is_valid", "is_not_valid"]
              };
              (_component$children7 = component.children) === null || _component$children7 === void 0 ? void 0 : _component$children7.filter(el => el.type == "row").forEach(element => {
                var _state$element$qualif11, _state$element$qualif12;
                scqArrayReturnList[code + element.code] = {
                  label: label + " - " + stripTags((_state$element$qualif11 = state[element.qualifiedCode].content) === null || _state$element$qualif11 === void 0 ? void 0 : (_state$element$qualif12 = _state$element$qualif11.label) === null || _state$element$qualif12 === void 0 ? void 0 : _state$element$qualif12[mainLang]),
                  type: "select",
                  valueSources: ["value"],
                  fieldSettings: {
                    listValues: scqArrayListValues
                  },
                  operators: ["select_any_in", "select_not_any_in"]
                };
              });
              return scqArrayReturnList;
            case "ranking":
            case "image_ranking":
              let rankingReturnList = {};
              (_component$children8 = component.children) === null || _component$children8 === void 0 ? void 0 : _component$children8.forEach(element => {
                var _state$element$qualif13, _state$element$qualif14;
                rankingReturnList[code + element.code] = {
                  label: label + " - " + stripTags((_state$element$qualif13 = state[element.qualifiedCode].content) === null || _state$element$qualif13 === void 0 ? void 0 : (_state$element$qualif14 = _state$element$qualif13.label) === null || _state$element$qualif14 === void 0 ? void 0 : _state$element$qualif14[mainLang]),
                  type: "number",
                  fieldSettings: {
                    min: 1,
                    max: component.children.length
                  },
                  valueSources: ["value"],
                  operators: ["is_void", "is_not_void", "equal", "not_equal", "less", "less_or_equal", "greater", "greater_or_equal", "between", "not_between"]
                };
              });
              return rankingReturnList;
            default:
              return [];
          }
        };
        const relevance = "_relevance_1j5a5_1";
        const relevanceError = "_relevanceError_1j5a5_5";
        const errorContainer = "_errorContainer_1j5a5_9";
        const styles$a = {
          relevance: relevance,
          relevanceError: relevanceError,
          errorContainer: errorContainer
        };
        function Relevance({
          code,
          t
        }) {
          var _state$instructionLis2, _state$relevance, _state$relevance2;
          const dispatch = useDispatch();
          const [logicDialogOpen, setLogicDialogOpen] = reactExports.useState(false);
          const langInfo = useSelector(state2 => {
            return state2.designState.langInfo;
          });
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const fields = useSelector(state2 => {
            return buildFields(state2.designState.componentIndex, code, state2.designState, langInfo.mainLang);
          });
          const instruction = (_state$instructionLis2 = state.instructionList) === null || _state$instructionLis2 === void 0 ? void 0 : _state$instructionLis2.find(instruction2 => instruction2.code == "conditional_relevance");
          const errors = (instruction === null || instruction === void 0 ? void 0 : instruction.errors) || [];
          const hasErrors = errors.length > 0;
          const logic = (_state$relevance = state.relevance) === null || _state$relevance === void 0 ? void 0 : _state$relevance.logic;
          const logicDisabled = !hasErrors && Object.keys(fields).length > 0;
          const [rule, setRule] = reactExports.useState(((_state$relevance2 = state.relevance) === null || _state$relevance2 === void 0 ? void 0 : _state$relevance2.rule) || "show_always");
          const shouldHaveLogic = rule == "show_if" || rule == "hide_if";
          const onRuleChange = rule2 => {
            setRule(rule2);
            switch (rule2) {
              case "show_always":
                reset();
                return;
              case "hide_always":
                dispatch(changeRelevance({
                  code,
                  key: "relevance",
                  value: {
                    logic: void 0,
                    rule: rule2
                  }
                }));
                return;
              case "show_if":
              case "hide_if":
                if ((logic === null || logic === void 0 ? void 0 : logic.rule) != "show_if" && (logic === null || logic === void 0 ? void 0 : logic.rule) != "hide_if") {
                  setLogicDialogOpen(true);
                }
                if (logic) {
                  dispatch(changeRelevance({
                    code,
                    key: "relevance",
                    value: {
                      logic,
                      rule: rule2
                    }
                  }));
                }
                return;
            }
          };
          const reset = () => dispatch(changeRelevance({
            code,
            key: "relevance",
            value: {
              logic: void 0,
              rule: "show_always"
            }
          }));
          const onLogicChange = logic2 => {
            setLogicDialogOpen(false);
            if (shouldHaveLogic) {
              dispatch(changeRelevance({
                code,
                key: "relevance",
                value: {
                  logic: logic2,
                  rule
                }
              }));
            }
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            className: `${hasErrors ? styles$a.relevanceError : ""}`,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormControl, {
              variant: "standard",
              fullWidth: true,
              children: /* @__PURE__ */jsxRuntimeExports.jsxs(Select, {
                id: "show-hide-select",
                value: rule,
                label: "Age",
                onChange: e => onRuleChange(e.target.value),
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                  disabled: hasErrors,
                  value: "show_always",
                  children: t("show_always")
                }, "show_always"), /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                  disabled: !logicDisabled,
                  value: "show_if",
                  children: t("show_if")
                }, "show_if"), /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                  disabled: !logicDisabled,
                  value: "hide_if",
                  children: t("hide_if")
                }, "hide_if"), /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                  disabled: hasErrors,
                  value: "hide_always",
                  children: t("hide_always")
                }, "hide_always")]
              })
            }), !hasErrors && shouldHaveLogic && /* @__PURE__ */jsxRuntimeExports.jsx(LogicBuilder, {
              title: rule == "show_if" ? t("condition_to_show") : t("condition_to_hide"),
              onChange: onLogicChange,
              onDialogStateChanged: state2 => setLogicDialogOpen(state2),
              fields,
              t,
              dialogOpen: logicDialogOpen,
              logic
            }), hasErrors ? /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$a.errorContainer,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Trans, {
                t,
                i18nKey: "wrong_logic_err"
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                variant: "contained",
                onClick: () => reset(),
                children: "OK"
              })]
            }) : "", shouldHaveLogic && !logic ? /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              children: /* @__PURE__ */jsxRuntimeExports.jsx(Trans, {
                t,
                i18nKey: "no_logic_err"
              })
            }) : ""]
          });
        }
        const buildField = (code, state, mainLang) => {
          var _component$content3, _component$content3$l;
          const component = state[code];
          const label = code + ". " + stripTags((_component$content3 = component.content) === null || _component$content3 === void 0 ? void 0 : (_component$content3$l = _component$content3.label) === null || _component$content3$l === void 0 ? void 0 : _component$content3$l[mainLang]);
          return {
            code: code,
            label: label
          };
        };
        const jumpDestinations = (componentIndices, code, state, mainLang) => {
          let dependencies = [];
          if (!componentIndices) {
            return dependencies;
          }
          let componentIndex = componentIndices.find(element => element.code === code);
          if (!componentIndex) {
            return dependencies;
          }
          dependencies = dependencies.concat(accessibleSiblings(componentIndices, componentIndex, state, mainLang));
          if (componentIndex.parent) {
            parents(componentIndices, componentIndex).filter(elem => isQuestion(elem.code) || isGroup(elem.code)).forEach(element => {
              dependencies = dependencies.concat(accessibleSiblings(componentIndices, element, state, mainLang));
            });
          }
          return dependencies;
        };
        const parents = (componentIndices, componentIndex) => {
          let result = [];
          let parent = componentIndices.find(element => element.code === componentIndex.parent);
          if (parent && parent.parent) {
            result.push(parent);
            result = result.concat(parents(componentIndices, parent));
          }
          return result;
        };
        const accessibleSiblings = (componentIndices, componentIndex, state, mainLang) => {
          let result = [];
          if (!isGroup(componentIndex.code) && !isQuestion(componentIndex.code)) {
            return result;
          }
          let accessibleSiblings = componentIndices.filter(elem => {
            return elem.parent == componentIndex.parent && elem.minIndex > componentIndex.maxIndex && (!componentIndex.prioritisedSiblings || componentIndex.prioritisedSiblings.indexOf(elem.code) === -1);
          });
          accessibleSiblings.forEach(sibling => {
            result = result.concat(buildField(sibling.code, state, mainLang));
            result = result.concat(childrenDependencies(componentIndices, sibling, state, mainLang));
          });
          return result;
        };
        const childrenDependencies = (componentIndices, componentIndex, state, mainLang) => {
          let result = [];
          if (!isGroup(componentIndex.code)) {
            return result;
          }
          if (componentIndex.children) {
            componentIndex.children.forEach(childCode => {
              let child = componentIndices.find(element => element.code === childCode);
              result = result.concat(buildField(child.code, state, mainLang));
              result = result.concat(childrenDependencies(componentIndices, child, state, mainLang));
            });
          }
          return result;
        };
        const skipItem = "_skipItem_1n8m2_1";
        const toEnd = "_toEnd_1n8m2_6";
        const styles$9 = {
          skipItem: skipItem,
          toEnd: toEnd
        };
        function SkipLogic({
          code,
          t
        }) {
          const dispatch = useDispatch();
          const skipLogic = useSelector(state => {
            return state.designState[code].skip_logic || {};
          });
          const destinations = useSelector(state => {
            const mainLang = state.designState.langInfo.mainLang;
            return jumpDestinations(state.designState.componentIndex, code, state.designState, mainLang);
          });
          const instructions = useSelector(state => {
            return state.designState[code].instructionList.filter(el => el.code.startsWith("skip_to"));
          });
          const children = useSelector(state => {
            var _state$designState$co18, _state$designState$co19;
            const lang = state.designState.langInfo.lang;
            return (_state$designState$co18 = state.designState[code]) === null || _state$designState$co18 === void 0 ? void 0 : (_state$designState$co19 = _state$designState$co18.children) === null || _state$designState$co19 === void 0 ? void 0 : _state$designState$co19.map(child => {
              var _state$designState$ch, _state$designState$ch2;
              return {
                code: child.code,
                label: ((_state$designState$ch = state.designState[child.qualifiedCode].content) === null || _state$designState$ch === void 0 ? void 0 : (_state$designState$ch2 = _state$designState$ch.label) === null || _state$designState$ch2 === void 0 ? void 0 : _state$designState$ch2[lang]) || child.code
              };
            });
          });
          const onChange = (answerCode, targetCode) => {
            if (targetCode == "proceed") {
              dispatch(removeSkipDestination({
                code,
                answerCode
              }));
            } else {
              dispatch(editSkipDestination({
                code,
                answerCode,
                skipTo: targetCode
              }));
            }
          };
          const onToEndChanged = (answerCode, checked) => {
            dispatch(editSkipToEnd({
              code,
              answerCode,
              toEnd: checked
            }));
          };
          return /* @__PURE__ */jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
            children: children === null || children === void 0 ? void 0 : children.map(element => {
              var _instructions$find, _instructions$find$er;
              const code2 = element.code;
              const original = skipLogic === null || skipLogic === void 0 ? void 0 : skipLogic[code2];
              const skipTo = original === null || original === void 0 ? void 0 : original.skipTo;
              const skipToCode = skipTo || "proceed";
              const invalidSkipDestination = skipTo && (instructions === null || instructions === void 0 ? void 0 : (_instructions$find = instructions.find(el => el.code == "skip_to_on_" + code2)) === null || _instructions$find === void 0 ? void 0 : (_instructions$find$er = _instructions$find.errors) === null || _instructions$find$er === void 0 ? void 0 : _instructions$find$er.find(el => el.name == "InvalidSkipReference"));
              return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                className: styles$9.skipItem,
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(Trans, {
                  t,
                  values: {
                    code: element.label
                  },
                  i18nKey: "if_answer_is"
                }), invalidSkipDestination ? skipValueError(code2, skipTo, onChange, t) : skipSelectValue(code2, destinations, skipToCode, original === null || original === void 0 ? void 0 : original.toEnd, onChange, onToEndChanged, t)]
              }, element.code);
            })
          });
        }
        function skipValueError(answerCode, skipToCode, onChange, t) {
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
            className: styles$9.errorDisplay,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(ErrorOutlineOutlined, {
              style: {
                verticalAlign: "middle"
              }
            }), " ", /* @__PURE__ */jsxRuntimeExports.jsx(Trans, {
              t,
              values: {
                code: skipToCode
              },
              i18nKey: "invalid_skip_destination_err"
            }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
              variant: "contained",
              onClick: () => onChange(answerCode, "proceed"),
              children: t("ok")
            })]
          });
        }
        function skipSelectValue(answerCode, destinations, skipToCode, toEnd, onChange, onToEndChanged, t) {
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormControl, {
              variant: "standard",
              fullWidth: true,
              children: /* @__PURE__ */jsxRuntimeExports.jsxs(Select, {
                id: "skip-action",
                value: skipToCode,
                label: t("skip_to"),
                onChange: e => onChange(answerCode, e.target.value),
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                  value: "proceed",
                  children: t("proceed_as_usual")
                }, "proceed"), destinations && (destinations === null || destinations === void 0 ? void 0 : destinations.map(element => {
                  return /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                    value: element.code,
                    children: element.label
                  }, element.code);
                }))]
              })
            }), skipToCode && skipToCode.startsWith("G") && /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$9.toEnd,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("h4", {
                children: t("to_group_end")
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Switch, {
                checked: toEnd || false,
                onChange: event => onToEndChanged(answerCode, event.target.checked)
              })]
            })]
          });
        }
        const sectionTitle = "_sectionTitle_1aw08_1";
        const styles$8 = {
          sectionTitle: sectionTitle
        };
        const errorDisplay$2 = "_errorDisplay_1avr2_1";
        const CustomPriority_module = {
          errorDisplay: errorDisplay$2
        };
        const errorDisplay$1 = "_errorDisplay_1avr2_1";
        const styles$7 = {
          errorDisplay: errorDisplay$1
        };
        function RandomError({
          errors
        }) {
          const {
            t
          } = useTranslation("design");
          return /* @__PURE__ */jsxRuntimeExports.jsx(Box, {
            className: styles$7.errorDisplay,
            children: errors.map(error => {
              if (error.name == "PriorityGroupItemNotChild") {
                return /* @__PURE__ */jsxRuntimeExports.jsx(Trans, {
                  t,
                  i18nKey: "err_priority_group_item_not_child",
                  values: {
                    items: error.items.join(", ")
                  }
                }, error.name);
              } else if (error.name == "DuplicatePriorityGroupItems") {
                return /* @__PURE__ */jsxRuntimeExports.jsx(Trans, {
                  t,
                  i18nKey: "err_duplicate_priority_group_items",
                  values: {
                    items: error.items.join(", ")
                  }
                }, error.name);
              } else if (error.name == "PriorityLimitMismatch") {
                return t("err_priority_limit_mismatch");
              } else if (error.name == "RandomGroupItemNotChild") {
                return /* @__PURE__ */jsxRuntimeExports.jsx(Trans, {
                  t,
                  i18nKey: "err_random_group_item_not_child",
                  values: {
                    items: error.items.join(", ")
                  }
                }, error.name);
              } else if (error.name == "DuplicateRandomGroupItems") {
                return /* @__PURE__ */jsxRuntimeExports.jsx(Trans, {
                  t,
                  i18nKey: "err_duplicate_random_group_items",
                  values: {
                    items: error.items.join(", ")
                  }
                }, error.name);
              }
            })
          }, "box");
        }
        const randomHeader$1 = "_randomHeader_1pjix_1";
        const title$3 = "_title_1pjix_6";
        const action$1 = "_action_1pjix_11";
        const settingIcon$1 = "_settingIcon_1pjix_15";
        const randomBody$1 = "_randomBody_1pjix_19";
        const list$3 = "_list_1pjix_19";
        const weight$1 = "_weight_1pjix_30";
        const randomAction$3 = "_randomAction_1pjix_47";
        const listItem$3 = "_listItem_1pjix_53";
        const label$2 = "_label_1pjix_58";
        const input$3 = "_input_1pjix_64";
        const listItemError$1 = "_listItemError_1pjix_68";
        const randomItem$3 = "_randomItem_1pjix_84";
        const highlighted$1 = "_highlighted_1pjix_89";
        const styles$6 = {
          randomHeader: randomHeader$1,
          title: title$3,
          action: action$1,
          settingIcon: settingIcon$1,
          randomBody: randomBody$1,
          list: list$3,
          weight: weight$1,
          randomAction: randomAction$3,
          listItem: listItem$3,
          label: label$2,
          input: input$3,
          listItemError: listItemError$1,
          randomItem: randomItem$3,
          highlighted: highlighted$1
        };
        var Mode = {};
        var _interopRequireDefault$3 = interopRequireDefaultExports;
        Object.defineProperty(Mode, "__esModule", {
          value: true
        });
        var default_1$3 = Mode.default = void 0;
        var _createSvgIcon$3 = _interopRequireDefault$3(requireCreateSvgIcon());
        var _jsxRuntime$3 = jsxRuntimeExports;
        var _default$3 = (0, _createSvgIcon$3.default)( /*#__PURE__*/(0, _jsxRuntime$3.jsx)("path", {
          d: "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75zM20.71 5.63l-2.34-2.34a.9959.9959 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83c.39-.39.39-1.02 0-1.41z"
        }), 'Mode');
        default_1$3 = Mode.default = _default$3;
        function PriorityItemDisplay(props) {
          var _props$data$weights;
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Card, {
            className: `${styles$6.randomItem} ${props.isBeingEdited ? styles$6.highlighted : ""}`,
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$6.randomHeader,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("h4", {
                className: styles$6.title,
                children: props.t("prioritise")
              }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                className: styles$6.action,
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                  onClick: () => props.onEditClicked(props.index),
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$3, {
                    className: styles$6.settingIcon
                  })
                }), /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                  onClick: () => props.onDeleteClicked(props.index),
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$u, {
                    className: styles$6.settingIcon
                  })
                })]
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$6.randomBody,
              children: [props.t("priority_show_limit_from_count", {
                limit: props.data.limit,
                count: (_props$data$weights = props.data.weights) === null || _props$data$weights === void 0 ? void 0 : _props$data$weights.length
              }), /* @__PURE__ */jsxRuntimeExports.jsx("ul", {
                className: styles$6.list,
                children: props.data && props.data.weights && props.data.weights.map((nestedItem, index) => {
                  return /* @__PURE__ */jsxRuntimeExports.jsx(PrioritisedChildDisplay$1, {
                    label: props.getChildLabelByCode(nestedItem.code),
                    code: nestedItem.code,
                    childrenCodes: props.childrenCodes,
                    weight: nestedItem.weight
                  }, index);
                })
              })]
            })]
          });
        }
        function PrioritisedChildDisplay$1({
          code,
          label,
          weight,
          childrenCodes
        }) {
          return /* @__PURE__ */jsxRuntimeExports.jsxs("li", {
            className: childrenCodes.indexOf(code) !== -1 ? styles$6.listItem : styles$6.listItemError,
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: `${styles$6.content} ${styles$6.label}`,
              children: [code, ": ", label]
            }), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: styles$6.weight,
              children: /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                children: weight
              })
            })]
          });
        }
        const title$2 = "_title_5cg20_1";
        const randomBody = "_randomBody_5cg20_6";
        const list$2 = "_list_5cg20_6";
        const weight = "_weight_5cg20_18";
        const label$1 = "_label_5cg20_35";
        const randomAction$2 = "_randomAction_5cg20_39";
        const listItem$2 = "_listItem_5cg20_45";
        const input$2 = "_input_5cg20_50";
        const randomItem$2 = "_randomItem_5cg20_54";
        const styles$5 = {
          title: title$2,
          randomBody: randomBody,
          list: list$2,
          weight: weight,
          label: label$1,
          randomAction: randomAction$2,
          listItem: listItem$2,
          input: input$2,
          randomItem: randomItem$2
        };
        var RemoveCircle = {};
        var _interopRequireDefault$2 = interopRequireDefaultExports;
        Object.defineProperty(RemoveCircle, "__esModule", {
          value: true
        });
        var default_1$2 = RemoveCircle.default = void 0;
        var _createSvgIcon$2 = _interopRequireDefault$2(requireCreateSvgIcon());
        var _jsxRuntime$2 = jsxRuntimeExports;
        var _default$2 = (0, _createSvgIcon$2.default)( /*#__PURE__*/(0, _jsxRuntime$2.jsx)("path", {
          d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11H7v-2h10v2z"
        }), 'RemoveCircle');
        default_1$2 = RemoveCircle.default = _default$2;
        var AddCircle = {};
        var _interopRequireDefault$1 = interopRequireDefaultExports;
        Object.defineProperty(AddCircle, "__esModule", {
          value: true
        });
        var default_1$1 = AddCircle.default = void 0;
        var _createSvgIcon$1 = _interopRequireDefault$1(requireCreateSvgIcon());
        var _jsxRuntime$1 = jsxRuntimeExports;
        var _default$1 = (0, _createSvgIcon$1.default)( /*#__PURE__*/(0, _jsxRuntime$1.jsx)("path", {
          d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"
        }), 'AddCircle');
        default_1$1 = AddCircle.default = _default$1;
        function PriorityItemSetup(props) {
          const t = props.t;
          const [checked, setChecked] = reactExports.useState(props.checked);
          const [data, setData] = reactExports.useState(props.data);
          const isSubmitEnabled = () => {
            const checkCount = checked.filter(x => x).length;
            return checkCount >= 2 && data.limit <= checkCount - 1 && data.limit >= 1;
          };
          const onSubmit = () => {
            const selected = checked.filter(x => x).length;
            if (selected < 2) {
              return false;
            }
            const submitData = {
              ...data
            };
            const weightsData = checked.reduce((sum, el, i) => {
              if (el) {
                sum.push(submitData.weights[i]);
              }
              return sum;
            }, []);
            props.onSubmit({
              ...submitData,
              weights: weightsData
            });
          };
          const handleCheckboxChange = (e, i) => {
            const cloneChecked = [...checked];
            cloneChecked[i] = e;
            setChecked([...cloneChecked]);
          };
          const changeLimit = limit => {
            setData({
              ...data,
              limit
            });
          };
          const changeWeight = (e, i) => {
            const newData = {
              ...data
            };
            newData.weights = [...data.weights];
            newData.weights[i] = {
              ...data.weights[i],
              weight: e
            };
            setData(newData);
          };
          const decreaseLimit = limit => {
            if (limit === 1) {
              return false;
            }
            limit--;
            changeLimit(limit);
          };
          const increaseLimit = limit => {
            if (limit === data.weights.length - 1) {
              return false;
            }
            limit++;
            changeLimit(limit);
          };
          const decreaseWeight = (e, i) => {
            if (e === 1) {
              return false;
            }
            e--;
            changeWeight(e, i);
          };
          const increaseWeight = (e, i) => {
            e++;
            changeWeight(e, i);
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Card, {
            className: styles$5.randomItem,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("h4", {
              className: styles$5.title,
              children: props.title
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$5.randomBody,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(PriorityLimitController, {
                t,
                increaseLimit,
                decreaseLimit,
                limit: data.limit
              }), /* @__PURE__ */jsxRuntimeExports.jsx("ul", {
                className: `${styles$5.list} ${styles$5.active}`,
                children: data && data.weights && data.weights.map((nestedItem, index) => /* @__PURE__ */jsxRuntimeExports.jsx(PrioritisedChildDisplay, {
                  code: nestedItem.code,
                  weight: nestedItem.weight,
                  handleChange: checked2 => handleCheckboxChange(checked2, index),
                  decreaseWeight: weight => decreaseWeight(weight, index),
                  increaseWeight: weight => increaseWeight(weight, index),
                  checked: (checked === null || checked === void 0 ? void 0 : checked[index]) || false,
                  label: props.getChildLabelByCode(nestedItem.code)
                }, index))
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$5.randomAction,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                variant: "text",
                onClick: e => props.onCancel(),
                children: t("cancel")
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                variant: "contained",
                onClick: e => onSubmit(),
                disabled: !isSubmitEnabled(),
                children: t("submit")
              })]
            })]
          });
        }
        function PrioritisedChildDisplay({
          code,
          checked,
          label,
          weight,
          handleChange,
          increaseWeight,
          decreaseWeight
        }) {
          return /* @__PURE__ */jsxRuntimeExports.jsxs("li", {
            className: styles$5.listItem,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(Checkbox, {
              checked,
              onChange: e => handleChange(e.target.checked)
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: `${styles$5.content} ${styles$5.label}`,
              children: [code, ": ", label]
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$5.weight,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                size: "small",
                onClick: e => decreaseWeight(weight),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$2, {})
              }), /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                children: weight
              }), /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                size: "small",
                onClick: e => increaseWeight(weight),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$1, {})
              })]
            })]
          });
        }
        function PriorityLimitController({
          limit,
          increaseLimit,
          decreaseLimit,
          t
        }) {
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [t("priority_show"), /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
              size: "small",
              onClick: e => decreaseLimit(limit),
              children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$2, {})
            }), limit, /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
              size: "small",
              onClick: e => increaseLimit(limit),
              children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$1, {})
            })]
          });
        }
        function CustomPriority({
          t,
          type,
          code,
          hideErrors
        }) {
          var _priorityInstruction$, _priorityInstruction$2;
          const dispatch = useDispatch();
          const [action, setAction] = reactExports.useState({});
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const childrenCodes = useSelector(state2 => {
            var _state2$designState$c, _state2$designState$c2, _state2$designState$c3, _state2$designState$c4;
            return ((_state2$designState$c = state2.designState[code]) === null || _state2$designState$c === void 0 ? void 0 : (_state2$designState$c2 = _state2$designState$c.children) === null || _state2$designState$c2 === void 0 ? void 0 : (_state2$designState$c3 = _state2$designState$c2.filter(el => type ? el.type == type : true)) === null || _state2$designState$c3 === void 0 ? void 0 : (_state2$designState$c4 = _state2$designState$c3.filter(el => {
              var _el$groupType, _el$groupType2;
              return ((_el$groupType = el.groupType) === null || _el$groupType === void 0 ? void 0 : _el$groupType.toLowerCase()) != "welcome" && ((_el$groupType2 = el.groupType) === null || _el$groupType2 === void 0 ? void 0 : _el$groupType2.toLowerCase()) != "end";
            })) === null || _state2$designState$c4 === void 0 ? void 0 : _state2$designState$c4.map(el => el.code)) || [];
          });
          const lang = useSelector(state2 => {
            return state2.designState.langInfo.lang;
          });
          const childrenLabels = useSelector(state2 => {
            var _state2$designState$c5, _state2$designState$c6, _state2$designState$c7;
            return ((_state2$designState$c5 = state2.designState[code]) === null || _state2$designState$c5 === void 0 ? void 0 : (_state2$designState$c6 = _state2$designState$c5.children) === null || _state2$designState$c6 === void 0 ? void 0 : (_state2$designState$c7 = _state2$designState$c6.filter(el => type ? el.type == type : true)) === null || _state2$designState$c7 === void 0 ? void 0 : _state2$designState$c7.map(child => {
              var _state2$designState$c8, _state2$designState$c9;
              return {
                code: child.code,
                label: (_state2$designState$c8 = state2.designState[child.qualifiedCode].content) === null || _state2$designState$c8 === void 0 ? void 0 : (_state2$designState$c9 = _state2$designState$c8.label) === null || _state2$designState$c9 === void 0 ? void 0 : _state2$designState$c9[lang]
              };
            })) || [];
          });
          const priorityInstruction = instructionByCode(state, "priority_groups");
          const priorities = (priorityInstruction === null || priorityInstruction === void 0 ? void 0 : (_priorityInstruction$ = priorityInstruction.priorities) === null || _priorityInstruction$ === void 0 ? void 0 : _priorityInstruction$.filter(priority => type ? priority.weights.some(el => childrenCodes.includes(el.code)) : true)) || [];
          let allCodesinPriority = priorities.map(priority => priority.weights).flat().map(weight => weight.code).flat();
          const priorityErrors = (priorityInstruction === null || priorityInstruction === void 0 ? void 0 : (_priorityInstruction$2 = priorityInstruction.errors) === null || _priorityInstruction$2 === void 0 ? void 0 : _priorityInstruction$2.filter(error => error.items.some(item => allCodesinPriority.includes(item)))) || [];
          const updatePriorities = priorities2 => {
            dispatch(type ? updatePriorityByType({
              code,
              priorities: priorities2,
              type
            }) : updatePriority({
              code,
              priorities: priorities2
            }));
          };
          const getChildLabelByCode = code2 => {
            var _childrenLabels$find;
            const label = (_childrenLabels$find = childrenLabels.find(el => el.code == code2)) === null || _childrenLabels$find === void 0 ? void 0 : _childrenLabels$find.label;
            return label === null || label === void 0 ? void 0 : label.replace(/<[^>]*>/g, "");
          };
          const getUnPrioritisedChildrenCodes = () => {
            return childrenCodes.filter(el => !allCodesinPriority.includes(el));
          };
          const onDeleteClicked = index => {
            if (window.confirm(t("are_you_sure"))) {
              updatePriorities(priorities.filter((el, i) => i !== index));
            }
          };
          const isActionEmpty = !action || Object.keys(action).length == 0;
          const onEditClicked = index => {
            let checked = [];
            let data = [];
            data.weights = [];
            const unPrioritised = getUnPrioritisedChildrenCodes();
            childrenCodes.forEach(code2 => {
              if (unPrioritised.includes(code2)) {
                data.weights.push({
                  code: code2,
                  weight: 1
                });
                checked.push(false);
              } else {
                let weightIndex = priorities[index].weights.findIndex(weight => weight.code == code2);
                if (weightIndex > -1) {
                  data.weights.push(priorities[index].weights[weightIndex]);
                  checked.push(true);
                }
              }
              data.limit = priorities[index].limit;
            });
            setAction({
              index,
              checked,
              title: t("edit_priority_rule"),
              data
            });
          };
          const resetData = () => {
            setAction({});
          };
          const onSubmit = (value, index) => {
            const newPriorities = priorities ? [...priorities] : [];
            newPriorities[index] = {
              ...value
            };
            updatePriorities(newPriorities);
            resetData();
          };
          const addNewPriority = () => {
            const listQuestionCode = getUnPrioritisedChildrenCodes();
            const weights = listQuestionCode.map(el => ({
              code: el,
              weight: 1
            }));
            setAction({
              title: t("add_priority_rule"),
              checked: listQuestionCode.map(el => false),
              data: {
                limit: 1,
                weights
              },
              index: priorities ? priorities.length : 0,
              icon: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$b, {})
            });
          };
          const sortPriorityItem = item => {
            let newWeights = [...item.weights].sort(function (a, b) {
              return childrenCodes.findIndex(x => x === a.code) - childrenCodes.findIndex(x => x === b.code);
            });
            return {
              ...item,
              weights: newWeights
            };
          };
          const sanitize = (data, childrenCodes2) => {
            let weights = [...data.weights].filter(el => childrenCodes2.includes(el.code));
            if (weights.length <= 1) {
              resetData();
            }
            return {
              limit: Math.min(data.limit, weights.length - 1),
              weights
            };
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [priorities && priorities.map((item, i) => {
              return /* @__PURE__ */jsxRuntimeExports.jsx(PriorityItemDisplay, {
                t,
                data: sortPriorityItem(item),
                index: i,
                childrenCodes,
                isBeingEdited: action.index == i,
                onDeleteClicked: index => {
                  setAction({});
                  onDeleteClicked(index);
                },
                onEditClicked: index => onEditClicked(index),
                getChildLabelByCode
              }, i);
            }), !hideErrors && priorityErrors.length > 0 ? /* @__PURE__ */jsxRuntimeExports.jsx(RandomError, {
              errors: priorityErrors
            }) : "", isActionEmpty && /* @__PURE__ */jsxRuntimeExports.jsxs(Button, {
              variant: "contained",
              disabled: getUnPrioritisedChildrenCodes().length < 2,
              onClick: addNewPriority,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(default_1$b, {
                sx: {
                  paddingRight: "8px"
                }
              }), " ", t("add_priority_rule")]
            }), action && action.data && /* @__PURE__ */jsxRuntimeExports.jsx(PriorityItemSetup, {
              t,
              title: action.title,
              data: sanitize(action.data, childrenCodes),
              index: action.index,
              getChildLabelByCode,
              checked: action.checked,
              onSubmit: data => onSubmit(data, action.index),
              onCancel: resetData
            })]
          });
        }
        const selectValue = "_selectValue_14l81_1";
        const styles$4 = {
          selectValue: selectValue
        };
        const errorDisplay = "_errorDisplay_1vtlj_1";
        const addNew = "_addNew_1vtlj_10";
        const styles$3 = {
          errorDisplay: errorDisplay,
          addNew: addNew
        };
        const title$1 = "_title_1p7e9_1";
        const list$1 = "_list_1p7e9_6";
        const randomAction$1 = "_randomAction_1p7e9_19";
        const listItem$1 = "_listItem_1p7e9_25";
        const input$1 = "_input_1p7e9_30";
        const randomItem$1 = "_randomItem_1p7e9_34";
        const styles$2 = {
          title: title$1,
          list: list$1,
          randomAction: randomAction$1,
          listItem: listItem$1,
          input: input$1,
          randomItem: randomItem$1
        };
        function RandomItemSetup(props) {
          const t = props.t;
          const [checked, setChecked] = reactExports.useState(props.checked);
          const [randomOption, setRandomOption] = reactExports.useState(props.randomOption);
          const isSubmitEnabled = () => {
            return checked.filter(x => x).length >= 2;
          };
          const labels = [t("random_order"), t("flip_order"), t("sort_by_label")];
          const values = ["RANDOM", "FLIP", "ALPHA"];
          const onSubmit = () => {
            const selected = checked.filter(x => x).length;
            if (selected < 2) {
              return false;
            }
            const submitList = checked.reduce((sum, el, i) => {
              if (el) {
                sum.push(props.data[i]);
              }
              return sum;
            }, []);
            props.onSubmit(submitList, randomOption);
          };
          const handleCheckboxChange = (e, i) => {
            const cloneChecked = [...checked];
            cloneChecked[i] = e;
            setChecked([...cloneChecked]);
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Card, {
            className: styles$2.randomItem,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("h4", {
              className: styles$2.title,
              children: props.title
            }), /* @__PURE__ */jsxRuntimeExports.jsx(FormControl, {
              variant: "standard",
              fullWidth: true,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(Select, {
                id: "select-value",
                value: randomOption,
                label: "Select Value",
                onChange: e => {
                  setRandomOption(e.target.value);
                },
                children: labels.map((element, index) => {
                  return /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                    value: values[index],
                    children: element
                  }, element);
                })
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx("ul", {
              className: styles$2.list,
              children: props.data && props.data.map((code, index) => /* @__PURE__ */jsxRuntimeExports.jsx(RandomisedChildDisplay$1, {
                code,
                handleChange: checked2 => handleCheckboxChange(checked2, index),
                checked: (checked === null || checked === void 0 ? void 0 : checked[index]) || false,
                label: props.getChildLabelByCode(code)
              }, index))
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$2.randomAction,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                variant: "text",
                onClick: e => props.onCancel(),
                children: t("cancel")
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                variant: "contained",
                onClick: e => onSubmit(),
                disabled: !isSubmitEnabled(),
                children: t("submit")
              })]
            })]
          });
        }
        function RandomisedChildDisplay$1({
          code,
          label,
          checked,
          handleChange
        }) {
          return /* @__PURE__ */jsxRuntimeExports.jsxs("li", {
            className: styles$2.listItem,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(Checkbox, {
              checked,
              onChange: e => handleChange(e.target.checked)
            }), code, ": ", label]
          });
        }
        const randomHeader = "_randomHeader_10d2m_1";
        const title = "_title_10d2m_6";
        const action = "_action_10d2m_11";
        const settingIcon = "_settingIcon_10d2m_15";
        const list = "_list_10d2m_19";
        const randomAction = "_randomAction_10d2m_30";
        const listItem = "_listItem_10d2m_36";
        const label = "_label_10d2m_41";
        const input = "_input_10d2m_47";
        const listItemError = "_listItemError_10d2m_51";
        const randomItem = "_randomItem_10d2m_63";
        const highlighted = "_highlighted_10d2m_68";
        const styles$1 = {
          randomHeader: randomHeader,
          title: title,
          action: action,
          settingIcon: settingIcon,
          list: list,
          randomAction: randomAction,
          listItem: listItem,
          label: label,
          input: input,
          listItemError: listItemError,
          randomItem: randomItem,
          highlighted: highlighted
        };
        const randomOptionToText = (randomOption, t) => {
          switch (randomOption) {
            case "ALPHA":
              return t("sort_by_label");
            case "RANDOM":
              return t("random_order");
            case "FLIP":
              return t("flip_order");
          }
          throw "unidentified randomOption: " + randomOption;
        };
        function RandomItemDisplay(props) {
          const t = props.t;
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Card, {
            className: `${styles$1.randomItem} ${props.isBeingEdited ? styles$1.highlighted : ""}`,
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$1.randomHeader,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("h4", {
                className: styles$1.title,
                children: randomOptionToText(props.randomOption, t)
              }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                className: styles$1.action,
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                  onClick: () => props.onEditClicked(props.index),
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$3, {
                    className: styles$1.settingIcon
                  })
                }), /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                  onClick: () => props.onDeleteClicked(props.index),
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$u, {
                    className: styles$1.settingIcon
                  })
                })]
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsx("ul", {
              className: styles$1.list,
              children: props.data && props.data.map((code, index) => {
                return /* @__PURE__ */jsxRuntimeExports.jsx(RandomisedChildDisplay, {
                  label: props.getChildLabelByCode(code),
                  code,
                  childrenCodes: props.childrenCodes
                }, index);
              })
            })]
          });
        }
        function RandomisedChildDisplay({
          code,
          label,
          childrenCodes
        }) {
          return /* @__PURE__ */jsxRuntimeExports.jsx("li", {
            className: childrenCodes.indexOf(code) !== -1 ? styles$1.listItem : styles$1.listItemError,
            children: /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: `${styles$1.content} ${styles$1.label}`,
              children: [code, ": ", label]
            })
          });
        }
        function CustomRandom({
          t,
          type,
          code,
          hideErrors
        }) {
          var _randomInstruction$gr, _randomInstruction$er;
          const dispatch = useDispatch();
          const [action, setAction] = reactExports.useState({});
          const state = useSelector(state2 => {
            return state2.designState[code];
          });
          const childrenCodes = useSelector(state2 => {
            var _state2$designState$c10, _state2$designState$c11, _state2$designState$c12, _state2$designState$c13;
            return ((_state2$designState$c10 = state2.designState[code]) === null || _state2$designState$c10 === void 0 ? void 0 : (_state2$designState$c11 = _state2$designState$c10.children) === null || _state2$designState$c11 === void 0 ? void 0 : (_state2$designState$c12 = _state2$designState$c11.filter(el => type ? el.type == type : true)) === null || _state2$designState$c12 === void 0 ? void 0 : (_state2$designState$c13 = _state2$designState$c12.filter(el => {
              var _el$groupType3, _el$groupType4;
              return ((_el$groupType3 = el.groupType) === null || _el$groupType3 === void 0 ? void 0 : _el$groupType3.toLowerCase()) != "welcome" && ((_el$groupType4 = el.groupType) === null || _el$groupType4 === void 0 ? void 0 : _el$groupType4.toLowerCase()) != "end";
            })) === null || _state2$designState$c13 === void 0 ? void 0 : _state2$designState$c13.map(el => el.code)) || [];
          });
          const lang = useSelector(state2 => {
            return state2.designState.langInfo.lang;
          });
          const childrenLabels = useSelector(state2 => {
            var _state2$designState$c14, _state2$designState$c15, _state2$designState$c16;
            return ((_state2$designState$c14 = state2.designState[code]) === null || _state2$designState$c14 === void 0 ? void 0 : (_state2$designState$c15 = _state2$designState$c14.children) === null || _state2$designState$c15 === void 0 ? void 0 : (_state2$designState$c16 = _state2$designState$c15.filter(el => type ? el.type == type : true)) === null || _state2$designState$c16 === void 0 ? void 0 : _state2$designState$c16.map(child => {
              var _state2$designState$c17, _state2$designState$c18;
              return {
                code: child.code,
                label: (_state2$designState$c17 = state2.designState[child.qualifiedCode].content) === null || _state2$designState$c17 === void 0 ? void 0 : (_state2$designState$c18 = _state2$designState$c17.label) === null || _state2$designState$c18 === void 0 ? void 0 : _state2$designState$c18[lang]
              };
            })) || [];
          });
          const randomInstruction = instructionByCode(state, "random_group");
          const randomOrders = (randomInstruction === null || randomInstruction === void 0 ? void 0 : (_randomInstruction$gr = randomInstruction.groups) === null || _randomInstruction$gr === void 0 ? void 0 : _randomInstruction$gr.filter(group => type ? group.codes.some(code2 => childrenCodes.includes(code2)) : true)) || [];
          const allCodesinRandomOrders = randomOrders.map(it => it.codes).flat();
          const randomErrors = (randomInstruction === null || randomInstruction === void 0 ? void 0 : (_randomInstruction$er = randomInstruction.errors) === null || _randomInstruction$er === void 0 ? void 0 : _randomInstruction$er.filter(error => error.items.some(item => allCodesinRandomOrders.includes(item)))) || [];
          const updateRandomOrders = groups => {
            dispatch(type ? updateRandomByType({
              code,
              groups,
              type
            }) : updateRandom({
              code,
              groups
            }));
          };
          const getChildLabelByCode = code2 => {
            var _childrenLabels$find2;
            const label = (_childrenLabels$find2 = childrenLabels.find(el => el.code == code2)) === null || _childrenLabels$find2 === void 0 ? void 0 : _childrenLabels$find2.label;
            return label === null || label === void 0 ? void 0 : label.replace(/<[^>]*>/g, "");
          };
          const getUnrandomisedChildrenCodes = data => {
            return childrenCodes.filter(el => !allCodesinRandomOrders.includes(el));
          };
          const onDeleteClicked = index => {
            if (window.confirm(t("are_you_sure"))) {
              updateRandomOrders(randomOrders.filter((el, i) => i !== index));
            }
          };
          const sortRandomItem = item => {
            return [...item.codes].sort(function (a, b) {
              return childrenCodes.findIndex(x => x === a) - childrenCodes.findIndex(x => x === b);
            });
          };
          const onEditClicked = index => {
            let checked = [];
            let data = [];
            let unrandomized = getUnrandomisedChildrenCodes();
            data = childrenCodes.filter(el => unrandomized.includes(el) || randomOrders[index].codes.includes(el));
            checked = data.map(el => randomOrders[index].codes.includes(el) ? true : false);
            setAction({
              index,
              checked,
              randomOption: randomOrders[index].randomOption || "RANDOM",
              title: t("edit_random_rule"),
              data
            });
          };
          const resetData = () => {
            setAction({});
          };
          const isActionEmpty = !action || Object.keys(action).length == 0;
          const onSubmit = (value, randomOption, index) => {
            const newRandomOrders = randomOrders ? [...randomOrders] : [];
            newRandomOrders[index] = {
              codes: value,
              randomOption
            };
            updateRandomOrders(newRandomOrders);
            resetData();
          };
          const addNewRule = () => {
            const data = getUnrandomisedChildrenCodes();
            setAction({
              title: t("add_new_random_rule"),
              data,
              checked: [],
              randomOption: "RANDOM",
              index: randomOrders ? randomOrders.length : 0
            });
          };
          const sanitize = (data, childrenCodes2) => {
            let groups = [...data].filter(code2 => childrenCodes2.includes(code2));
            if (groups.length <= 1) {
              resetData();
            }
            return groups;
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [randomOrders && randomOrders.map((item, i) => {
              return /* @__PURE__ */jsxRuntimeExports.jsx(RandomItemDisplay, {
                t,
                data: sortRandomItem(item),
                randomOption: item.randomOption,
                index: i,
                isBeingEdited: action.index == i,
                childrenCodes,
                getChildLabelByCode,
                onDeleteClicked: index => {
                  setAction({});
                  onDeleteClicked(index);
                },
                onEditClicked: index => onEditClicked(index)
              }, i);
            }), !hideErrors && randomErrors.length > 0 ? /* @__PURE__ */jsxRuntimeExports.jsx(RandomError, {
              errors: randomErrors
            }) : "", isActionEmpty && /* @__PURE__ */jsxRuntimeExports.jsxs(Button, {
              className: styles$3.addNew,
              variant: "contained",
              disabled: getUnrandomisedChildrenCodes().length < 2,
              onClick: addNewRule,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(default_1$c, {
                sx: {
                  paddingRight: "8px"
                }
              }), " ", t("add_random_rule")]
            }), action && action.data && /* @__PURE__ */jsxRuntimeExports.jsx(RandomItemSetup, {
              t,
              title: action.title,
              data: sanitize(action.data, childrenCodes),
              randomOption: action.randomOption,
              getChildLabelByCode,
              checked: action.checked,
              onSubmit: (data, randomOption) => onSubmit(data, randomOption, action.index),
              onCancel: resetData
            })]
          });
        }
        function OrderPrioritySetup({
          t,
          rule,
          code
        }) {
          const dispatch = useDispatch();
          const value = useSelector(state => {
            return state.designState[code][rule] || "NONE";
          });
          let title = "";
          let labels = [];
          let values = [];
          switch (rule) {
            case "randomize_questions":
              title = t("questions_order");
              labels = [t("as_is"), t("random_order"), t("flip_order"), t("custom_random")];
              values = ["NONE", "RANDOM", "FLIP", "custom"];
              break;
            case "prioritize_questions":
              title = t("questions_priority");
              labels = [t("no_priority"), t("prioritise_questions")];
              values = ["NONE", "prioritize"];
              break;
            case "randomize_groups":
              title = t("groups_order");
              labels = [t("as_is"), t("random_order"), t("flip_order"), t("custom_random")];
              values = ["NONE", "RANDOM", "FLIP", "custom"];
              break;
            case "prioritize_groups":
              title = t("groups_priority");
              labels = [t("no_priority"), t("prioritise_groups")];
              values = ["NONE", "prioritize"];
              break;
            case "randomize_options":
              title = t("options_order");
              labels = [t("as_is"), t("random_order"), t("flip_order"), t("sort_by_label"), t("custom_random")];
              values = ["NONE", "RANDOM", "FLIP", "ALPHA", "custom"];
              break;
            case "prioritize_options":
              title = t("options_priority");
              labels = [t("no_priority"), t("prioritise_options")];
              values = ["NONE", "prioritize"];
              break;
            case "randomize_rows":
              title = t("rows_order");
              labels = [t("as_is"), t("random_order"), t("flip_order"), t("sort_by_label"), t("custom_random")];
              values = ["NONE", "RANDOM", "FLIP", "ALPHA", "custom"];
              break;
            case "prioritize_rows":
              title = t("rows_priority");
              labels = [t("no_priority"), t("prioritise_rows")];
              values = ["NONE", "prioritize"];
              break;
            case "randomize_columns":
              title = t("columns_order");
              labels = [t("as_is"), t("random_order"), t("flip_order"), t("sort_by_label"), t("custom_random")];
              values = ["NONE", "RANDOM", "FLIP", "ALPHA", "custom"];
              break;
            case "prioritize_columns":
              title = t("columns_priority");
              labels = [t("no_priority"), t("prioritise_columns")];
              values = ["NONE", "prioritize"];
              break;
          }
          const onChange = value2 => {
            const finalValue = value2 == "NONE" ? void 0 : value2;
            dispatch(changeAttribute({
              code,
              key: rule,
              value: finalValue
            }));
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("h4", {
              children: title
            }), /* @__PURE__ */jsxRuntimeExports.jsx(FormControl, {
              className: styles$4.selectValue,
              variant: "standard",
              fullWidth: true,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(Select, {
                id: "select-value",
                value,
                label: "Select Value",
                onChange: e => {
                  onChange(e.target.value);
                },
                children: labels.map((element, index) => {
                  return /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                    value: values[index],
                    children: element
                  }, element);
                })
              })
            }), value == "custom" && ["randomize_questions", "randomize_options", "randomize_groups"].indexOf(rule) !== -1 && /* @__PURE__ */jsxRuntimeExports.jsx(CustomRandom, {
              label: "",
              code,
              t
            }), value == "custom" && "randomize_rows" == rule && /* @__PURE__ */jsxRuntimeExports.jsx(CustomRandom, {
              label: "",
              type: "row",
              code,
              t
            }), value == "prioritize" && "prioritize_rows" == rule && /* @__PURE__ */jsxRuntimeExports.jsx(CustomPriority, {
              label: "",
              type: "row",
              code,
              t
            }), value == "custom" && "randomize_columns" == rule && /* @__PURE__ */jsxRuntimeExports.jsx(CustomRandom, {
              label: "",
              type: "column",
              code,
              t
            }), value == "prioritize" && "prioritize_columns" == rule && /* @__PURE__ */jsxRuntimeExports.jsx(CustomPriority, {
              label: "",
              type: "column",
              code,
              t
            }), value == "prioritize" && ["prioritize_questions", "prioritize_options", "prioritize_groups"].indexOf(rule) !== -1 && /* @__PURE__ */jsxRuntimeExports.jsx(CustomPriority, {
              label: "",
              code,
              t
            })]
          });
        }
        function SetupPanel({
          setupInfo,
          t
        }) {
          var _setupInfo$rules;
          const dispatch = useDispatch();
          const toggleExpand = key => {
            dispatch(setupToggleExpand(key));
          };
          const isSingleRule = ((_setupInfo$rules = setupInfo.rules) === null || _setupInfo$rules === void 0 ? void 0 : _setupInfo$rules.length) === 1;
          const generateSetupSection = rule => {
            var _setupInfo$expanded;
            return /* @__PURE__ */jsxRuntimeExports.jsxs(Accordion, {
              expanded: ((_setupInfo$expanded = setupInfo.expanded) === null || _setupInfo$expanded === void 0 ? void 0 : _setupInfo$expanded.includes(rule.key)) || isSingleRule || false,
              TransitionProps: {
                unmountOnExit: true
              },
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(AccordionSummary, {
                sx: {
                  backgroundColor: "#ECECEC",
                  margin: 0
                },
                onClick: () => toggleExpand(rule.key),
                className: styles$8.setupHeader,
                expandIcon: isSingleRule ? null : /* @__PURE__ */jsxRuntimeExports.jsx(default_1$v, {}),
                children: /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                  className: styles$8.sectionTitle,
                  children: t(rule.title)
                })
              }), /* @__PURE__ */jsxRuntimeExports.jsx(AccordionDetails, {
                sx: {
                  backgroundColor: rule.key == setupInfo.highlighted ? "beige" : "background.paper"
                },
                children: rule.rules.map(rule2 => generateSetupcomponent(rule2))
              })]
            }, setupInfo.code + rule.title);
          };
          const generateSetupcomponent = rule => {
            if (rule.startsWith("validation_")) {
              return /* @__PURE__ */jsxRuntimeExports.jsx(ValidationSetupItem$1, {
                t,
                rule,
                code: setupInfo.code
              }, setupInfo.code + rule);
            }
            switch (rule) {
              case "theme":
                return /* @__PURE__ */jsxRuntimeExports.jsx(Theming, {
                  t
                }, setupInfo.code + rule);
              case "maxChars":
                return /* @__PURE__ */jsxRuntimeExports.jsx(FieldSize, {
                  label: t("text_field_size"),
                  rule,
                  lowerBound: 1,
                  upperBound: 500,
                  defaultValue: 20,
                  code: setupInfo.code
                }, setupInfo.code + rule);
              case "minRows":
                return /* @__PURE__ */jsxRuntimeExports.jsx(FieldSize, {
                  label: t("textarea_lines"),
                  lowerBound: 1,
                  upperBound: 500,
                  code: setupInfo.code,
                  defaultValue: 20
                }, setupInfo.code + rule);
              case "hideText":
                return /* @__PURE__ */jsxRuntimeExports.jsx(ToggleValue, {
                  label: t("hide_text"),
                  rule,
                  code: setupInfo.code
                }, setupInfo.code + rule);
              case "showWordCount":
                return /* @__PURE__ */jsxRuntimeExports.jsx(ToggleValue, {
                  label: t("show_word_count"),
                  rule,
                  code: setupInfo.code
                }, setupInfo.code + rule);
              case "hint":
                return /* @__PURE__ */jsxRuntimeExports.jsx(ShowHint, {
                  t,
                  code: setupInfo.code
                }, setupInfo.code + rule);
              case "lower_bound_hint":
                return /* @__PURE__ */jsxRuntimeExports.jsx(ContentEditor, {
                  title: t("lower_bound_hint"),
                  objectName: "lower_bound_hint",
                  code: setupInfo.code
                }, setupInfo.code + rule);
              case "higher_bound_hint":
                return /* @__PURE__ */jsxRuntimeExports.jsx(ContentEditor, {
                  title: t("upper_bound_hint"),
                  objectName: "higher_bound_hint",
                  code: setupInfo.code
                }, setupInfo.code + rule);
              case "loop":
                return /* @__PURE__ */jsxRuntimeExports.jsx(ToggleValue, {
                  rule,
                  code: setupInfo.code,
                  label: t("loop_video")
                }, setupInfo.code + rule);
              case "audio_only":
                return /* @__PURE__ */jsxRuntimeExports.jsx(ToggleValue, {
                  rule,
                  code: setupInfo.code,
                  label: t("audio_only")
                }, setupInfo.code + rule);
              case "fullDayFormat":
                return /* @__PURE__ */jsxRuntimeExports.jsx(ToggleValue, {
                  rule,
                  code: setupInfo.code,
                  label: t("fullday_format")
                }, setupInfo.code + rule);
              case "randomize_questions":
              case "prioritize_questions":
              case "randomize_options":
              case "prioritize_options":
              case "randomize_groups":
              case "prioritize_groups":
              case "randomize_rows":
              case "prioritize_rows":
              case "randomize_columns":
              case "prioritize_columns":
                return /* @__PURE__ */jsxRuntimeExports.jsx(OrderPrioritySetup, {
                  t,
                  rule,
                  code: setupInfo.code
                }, setupInfo.code + rule);
              case "maxDate":
                return /* @__PURE__ */jsxRuntimeExports.jsx(SelectDate, {
                  lowerBound: 1,
                  code: setupInfo.code,
                  label: t("max_date"),
                  rule
                }, setupInfo.code + rule);
              case "minDate":
                return /* @__PURE__ */jsxRuntimeExports.jsx(SelectDate, {
                  label: t("min_date"),
                  rule,
                  code: setupInfo.code
                }, setupInfo.code + rule);
              case "dateFormat":
                const listDateFormat = ["DD.MM.YYYY", "MM.DD.YYYY", "YYYY.MM.DD", "DD/MM/YYYY", "MM/DD/YYYY", "YYYY/MM/DD"];
                return /* @__PURE__ */jsxRuntimeExports.jsx(SelectValue, {
                  values: listDateFormat,
                  defaultValue: "DD.MM.YYYY",
                  label: t("date_format"),
                  rule,
                  code: setupInfo.code
                }, setupInfo.code + rule);
              case "imageAspectRatio":
                const aspectLabels = ["1:1", "16:9", "4:3", "3:2", "9:16", "3:4", "2:3"];
                const aspectValues = [1, 1.7778, 1.3333, 1.5, 0.562, 0.75, 0.6667];
                return /* @__PURE__ */jsxRuntimeExports.jsx(SelectValue, {
                  values: aspectValues,
                  labels: aspectLabels,
                  defaultValue: "1:1",
                  label: t("image_aspect_ratio"),
                  rule,
                  code: setupInfo.code
                }, setupInfo.code + rule);
              case "columns":
                const columnsOptions = ["1", "2", "3", "4", "6"];
                return /* @__PURE__ */jsxRuntimeExports.jsx(SelectValue, {
                  values: columnsOptions,
                  defaultValue: "2",
                  label: t("columns_number"),
                  rule,
                  code: setupInfo.code
                }, setupInfo.code + rule);
              case "imageHeight":
                return /* @__PURE__ */jsxRuntimeExports.jsx(FieldSize, {
                  label: t("image_height"),
                  lowerBound: 50,
                  upperBound: 500,
                  code: setupInfo.code,
                  defaultValue: 250,
                  rule
                }, setupInfo.code + rule);
              case "spacing":
                return /* @__PURE__ */jsxRuntimeExports.jsx(FieldSize, {
                  label: t("spacing"),
                  lowerBound: 2,
                  upperBound: 32,
                  code: setupInfo.code,
                  defaultValue: 8,
                  rule
                }, setupInfo.code + rule);
              case "skip_logic":
                return /* @__PURE__ */jsxRuntimeExports.jsx(SkipLogic, {
                  t,
                  code: setupInfo.code
                }, setupInfo.code + rule);
              case "relevance":
                return /* @__PURE__ */jsxRuntimeExports.jsx(Relevance, {
                  t,
                  code: setupInfo.code
                }, setupInfo.code + rule);
              default:
                return "";
            }
          };
          return /* @__PURE__ */jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
            children: setupInfo.rules.map((rule, index) => generateSetupSection(rule))
          });
        }
        var PlayCircleFilledWhite = {};
        var _interopRequireDefault = interopRequireDefaultExports;
        Object.defineProperty(PlayCircleFilledWhite, "__esModule", {
          value: true
        });
        var default_1 = PlayCircleFilledWhite.default = void 0;
        _interopRequireWildcard(reactExports);
        var _createSvgIcon = _interopRequireDefault(requireCreateSvgIcon());
        var _jsxRuntime = jsxRuntimeExports;
        function _getRequireWildcardCache(nodeInterop) {
          if (typeof WeakMap !== "function") return null;
          var cacheBabelInterop = new WeakMap();
          var cacheNodeInterop = new WeakMap();
          return (_getRequireWildcardCache = function (nodeInterop) {
            return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
          })(nodeInterop);
        }
        function _interopRequireWildcard(obj, nodeInterop) {
          if (!nodeInterop && obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
            return {
              default: obj
            };
          }
          var cache = _getRequireWildcardCache(nodeInterop);
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }
        var _default = (0, _createSvgIcon.default)( /*#__PURE__*/(0, _jsxRuntime.jsx)("path", {
          transform: "scale(0.5, 0.5)",
          d: "M24 4C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm-4 29V15l12 9-12 9z"
        }), 'PlayCircleFilledWhite');
        default_1 = PlayCircleFilledWhite.default = _default;
        function LeftPanel({
          t
        }) {
          const dispatch = useDispatch();
          const setupInfo = useSelector(state => {
            return state.designState.setup;
          });
          const nav = useNavigate();
          const surveyId = sessionStorage.getItem("surveyId");
          const hasFatalErrors = useSelector(state => {
            return state.designState.Survey.errors && state.designState.Survey.errors.length > 0;
          });
          const isPushingStateToServer = useSelector(state => {
            return state.designState.isSaving;
          });
          const langInfo = useSelector(state => {
            return state.designState.langInfo;
          });
          const preview = lang2 => {
            nav(`/preview-survey/${surveyId}`);
          };
          const params = useSelector(state => {
            return new URLSearchParams([["version", state.designState.versionDto.version], ["sub_version", state.designState.versionDto.subVersion]]);
          });
          const back = () => {
            nav(`/`);
          };
          const logout = () => {
            AuthService.logout();
            nav("/login");
          };
          const publish = () => {
            DesignService.publish(params).then(data => {
              dispatch(newVersionReceived(data));
              console.log(data);
            });
          };
          const lang = langInfo === null || langInfo === void 0 ? void 0 : langInfo.lang;
          const languagesList = langInfo === null || langInfo === void 0 ? void 0 : langInfo.languagesList;
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Box, {
            sx: {
              backgroundColor: "background.paper"
            },
            className: styles$m.leftContent,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(Select, {
              id: "ChangeLang",
              value: lang,
              onChange: event => {
                dispatch(changeLang(event.target.value));
              },
              children: languagesList ? languagesList.map((lang2, index) => /* @__PURE__ */jsxRuntimeExports.jsx(MenuItem, {
                value: lang2.code,
                children: lang2.langName
              }, index)) : ""
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: styles$m.leftPanelGroupItem,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                onClick: () => back(),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$w, {
                  className: styles$m.settingIcon
                })
              }), /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                onClick: () => preview(),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(PreviewOutlined, {
                  className: styles$m.settingIcon
                })
              }), /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                onClick: () => logout(),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(LogoutOutlined, {
                  className: styles$m.settingIcon
                })
              }), /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                disabled: hasFatalErrors || isPushingStateToServer,
                onClick: () => publish(),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1, {
                  className: styles$m.settingIcon
                })
              }), /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                onClick: () => dispatch(setup({
                  code: "Survey",
                  rules: [{
                    title: t("theme"),
                    rules: ["theme"]
                  }]
                })),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$8, {
                  className: styles$m.settingIcon
                })
              }), /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                onClick: () => dispatch(setup(serveyRandomSetup)),
                children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$j, {
                  className: styles$m.settingIcon
                })
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
              children: setupInfo ? /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx("div", {
                  className: styles$m.close,
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(IconButton, {
                    onClick: () => dispatch(resetSetup()),
                    children: /* @__PURE__ */jsxRuntimeExports.jsx(default_1$k, {})
                  })
                }), /* @__PURE__ */jsxRuntimeExports.jsx(SetupPanel, {
                  t,
                  setupInfo
                })]
              }) : /* @__PURE__ */jsxRuntimeExports.jsx(NewComponentsPanel, {
                t
              })
            })]
          });
        }
        const savingProgress = "_savingProgress_zztu3_1";
        const styles = {
          savingProgress: savingProgress
        };
        function SavingSurvey() {
          const isSaving = useSelector(state => {
            return state.designState.isSaving;
          });
          return /* @__PURE__ */jsxRuntimeExports.jsx(Snackbar, {
            open: isSaving,
            children: /* @__PURE__ */jsxRuntimeExports.jsxs(Alert, {
              severity: "warning",
              children: ["Saving Survey...", " ", /* @__PURE__ */jsxRuntimeExports.jsx(CircularProgress, {
                className: styles.savingProgress,
                color: "warning"
              })]
            })
          });
        }
        function ErrorWrapper() {
          const dispatch = useDispatch();
          const error = useSelector(state => {
            const error2 = state.designState.error || false;
            return error2;
          });
          const setErrorSeen = () => {
            dispatch(onErrorSeen(false));
          };
          return error && !error.seen && /* @__PURE__ */jsxRuntimeExports.jsxs(Dialog, {
            open: true,
            onClose: () => setErrorSeen(),
            "aria-labelledby": "alert-dialog-title-error",
            "aria-describedby": "alert-dialog-description",
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(DialogTitle, {
              id: "alert-dialog-title-error",
              children: "Error"
            }), /* @__PURE__ */jsxRuntimeExports.jsx(DialogContent, {
              children: error.message || ""
            }), /* @__PURE__ */jsxRuntimeExports.jsx(DialogActions, {
              children: /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                onClick: () => setErrorSeen(),
                children: "OK"
              })
            })]
          });
        }
        function DesignSurvey() {
          const {
            t,
            i18n
          } = useTranslation(["design", "run"]);
          const dispatch = useDispatch();
          const [render, setRender] = reactExports.useState(false);
          const headerImage = useSelector(state => {
            var _state$designState$Su, _state$designState$Su2;
            return (_state$designState$Su = state.designState["Survey"]) === null || _state$designState$Su === void 0 ? void 0 : (_state$designState$Su2 = _state$designState$Su.resources) === null || _state$designState$Su2 === void 0 ? void 0 : _state$designState$Su2.headerImage;
          });
          const groups = useSelector(state => {
            var _state$designState$Su3;
            return (_state$designState$Su3 = state.designState["Survey"]) === null || _state$designState$Su3 === void 0 ? void 0 : _state$designState$Su3.children;
          });
          const langInfo = useSelector(state => {
            return state.designState.langInfo;
          });
          const lang = langInfo === null || langInfo === void 0 ? void 0 : langInfo.lang;
          const theme = useSelector(state => {
            var _state$designState$Su4;
            return (_state$designState$Su4 = state.designState["Survey"]) === null || _state$designState$Su4 === void 0 ? void 0 : _state$designState$Su4.theme;
          });
          const setState = state => {
            dispatch(designStateReceived(state));
          };
          const setError = error => {
            dispatch(onError(error));
          };
          reactExports.useEffect(() => {
            document.body.style.overflow = "hidden";
            dispatch(setFetching(true));
            GetData(setState, setError).then(data => {
              if (data) {
                setRender(true);
                i18n.loadLanguages(data.languages);
                dispatch(setFetching(false));
              }
            }).catch(err => {
              dispatch(setFetching(false));
            });
          }, []);
          function changeLanguage(lang2) {
            return new Promise((resolve, reject) => {
              const dir = rtlLanguage.includes(lang2) ? "rtl" : "ltr";
              if (document.dir != dir) {
                document.dir = dir;
              }
              if (lang2) {
                i18n.changeLanguage(lang2);
              }
              resolve();
            });
          }
          reactExports.useEffect(() => {
            changeLanguage(lang);
          }, [lang]);
          const cacheRtl = createCache({
            key: rtlLanguage.includes(lang) ? "muirtl" : "muiltr",
            stylisPlugins: rtlLanguage.includes(lang) ? [prefixer, stylisRTLPlugin] : null
          });
          const surveyTheme = React.useCallback(createTheme({
            ...defualtTheme(theme),
            direction: rtlLanguage.includes(lang) ? "rtl" : "ltr"
          }), [theme]);
          return /* @__PURE__ */jsxRuntimeExports.jsx(CacheProvider, {
            value: cacheRtl,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(ThemeProvider, {
              theme: surveyTheme,
              children: /* @__PURE__ */jsxRuntimeExports.jsxs(Layout, {
                children: [render && /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx("div", {
                    className: styles$L.mainContainer,
                    children: /* @__PURE__ */jsxRuntimeExports.jsxs(DragDropContext, {
                      onDragEnd: event => {
                        onDragEnd(event, payload => {
                          dispatch(onDrag(payload));
                        });
                      },
                      children: [/* @__PURE__ */jsxRuntimeExports.jsx(LeftPanel, {
                        t
                      }), /* @__PURE__ */jsxRuntimeExports.jsx(ContentPanel, {
                        className: styles$L.contentPanel,
                        t,
                        headerImage,
                        groups
                      })]
                    })
                  }), /* @__PURE__ */jsxRuntimeExports.jsx(SavingSurvey, {})]
                }), /* @__PURE__ */jsxRuntimeExports.jsx(ErrorWrapper, {})]
              })
            })
          });
        }
      }
    };
  });
})();
